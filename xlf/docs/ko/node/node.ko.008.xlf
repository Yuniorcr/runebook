<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="node">
    <body>
      <group id="node">
        <trans-unit id="05f539596c85a8dcff913b8786aee719a585dfe5" translate="yes" xml:space="preserve">
          <source>Flush operations</source>
          <target state="translated">플러시 작업</target>
        </trans-unit>
        <trans-unit id="c3db444af1ef5ead4ffca281491c5831f95302fb" translate="yes" xml:space="preserve">
          <source>Flush pending data. Don't call this frivolously, premature flushes negatively impact the effectiveness of the compression algorithm.</source>
          <target state="translated">보류중인 데이터를 비 웁니다. 이것을 엄청나게 부르지 말고 조기 플러시는 압축 알고리즘의 효과에 부정적인 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="af0144ad8588391b2f587a0b967a54e12bfe650e" translate="yes" xml:space="preserve">
          <source>Flushes the request headers.</source>
          <target state="translated">요청 헤더를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="6581c7edc58d10b0e77e444e8de35dff2af33545" translate="yes" xml:space="preserve">
          <source>Flushes the response headers. See also: &lt;a href=&quot;#http_request_flushheaders&quot;&gt;&lt;code&gt;request.flushHeaders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답 헤더를 플러시합니다. &lt;a href=&quot;#http_request_flushheaders&quot;&gt; &lt;code&gt;request.flushHeaders()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca447072e179b8239502f1f4cd8c8f7174c9b801" translate="yes" xml:space="preserve">
          <source>Flushing</source>
          <target state="translated">Flushing</target>
        </trans-unit>
        <trans-unit id="948f30180920619fed0f6f0ff2fa1b319bfa7d68" translate="yes" xml:space="preserve">
          <source>Folders as Modules</source>
          <target state="translated">모듈로서의 폴더</target>
        </trans-unit>
        <trans-unit id="4e483ed60c6aa1a4fc52b273f85d228cdbd3d352" translate="yes" xml:space="preserve">
          <source>Folders as modules</source>
          <target state="translated">모듈로서의 폴더</target>
        </trans-unit>
        <trans-unit id="e964430cef74586c5f2c2f25b435d9e04075a1a5" translate="yes" xml:space="preserve">
          <source>Folders can also be mapped with package exports:</source>
          <target state="translated">패키지 내보내기로 폴더를 매핑 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c99c144cf5b270c52f8725c4b844b0c19827c50" translate="yes" xml:space="preserve">
          <source>Following are some example Addons intended to help developers get started. The examples make use of the V8 APIs. Refer to the online &lt;a href=&quot;https://v8docs.nodesource.com/&quot;&gt;V8 reference&lt;/a&gt; for help with the various V8 calls, and V8's &lt;a href=&quot;https://github.com/v8/v8/wiki/Embedder's%20Guide&quot;&gt;Embedder's Guide&lt;/a&gt; for an explanation of several concepts used such as handles, scopes, function templates, etc.</source>
          <target state="translated">다음은 개발자가 시작하는 데 도움이되는 애드온의 예입니다. 예제는 V8 API를 사용합니다. 다양한 V8 호출에 대한 도움말 은 온라인 &lt;a href=&quot;https://v8docs.nodesource.com/&quot;&gt;V8 참조&lt;/a&gt; 를, 핸들, 스코프, 함수 템플릿 등과 같은 여러 개념에 대한 설명은 V8 &lt;a href=&quot;https://github.com/v8/v8/wiki/Embedder's%20Guide&quot;&gt;Embedder 's Guide&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be114c032e5aa483843b89d61eb74bf019fafc7c" translate="yes" xml:space="preserve">
          <source>Following are some example addons intended to help developers get started. The examples use the V8 APIs. Refer to the online &lt;a href=&quot;https://v8docs.nodesource.com/&quot;&gt;V8 reference&lt;/a&gt; for help with the various V8 calls, and V8's &lt;a href=&quot;https://github.com/v8/v8/wiki/Embedder's%20Guide&quot;&gt;Embedder's Guide&lt;/a&gt; for an explanation of several concepts used such as handles, scopes, function templates, etc.</source>
          <target state="translated">다음은 개발자가 시작하는 데 도움이되는 몇 가지 예제 애드온입니다. 예제는 V8 API를 사용합니다. 다양한 V8 호출에 대한 도움말 은 온라인 &lt;a href=&quot;https://v8docs.nodesource.com/&quot;&gt;V8 참조&lt;/a&gt; 를 참조 하고 핸들, 범위, 함수 템플릿 등과 같이 사용되는 여러 개념에 대한 설명은 V8의 &lt;a href=&quot;https://github.com/v8/v8/wiki/Embedder's%20Guide&quot;&gt;Embedder 's Guide&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fbf548c54fc5019a00dc97cf34a6dbbf46c6fb9" translate="yes" xml:space="preserve">
          <source>Following is a simple overview of the public API.</source>
          <target state="translated">다음은 공개 API에 대한 간단한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="3d3da17627bbb105a67ffaef4cde451b1975b1c7" translate="yes" xml:space="preserve">
          <source>Following is an example of a client of the echo server described in the &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt;&lt;code&gt;net.createServer()&lt;/code&gt;&lt;/a&gt; section:</source>
          <target state="translated">다음은 &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt; &lt;code&gt;net.createServer()&lt;/code&gt; &lt;/a&gt; 섹션에 설명 된 에코 서버 클라이언트의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5df4ece871f653674e17cd451f5434f8b2e055b2" translate="yes" xml:space="preserve">
          <source>Following is an example of a client using the &lt;code&gt;onread&lt;/code&gt; option:</source>
          <target state="translated">다음은 &lt;code&gt;onread&lt;/code&gt; 옵션을 사용하는 클라이언트의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="50f12e835371a94a0761fa5bd02427c269944d14" translate="yes" xml:space="preserve">
          <source>Following successful read, the &lt;code&gt;Promise&lt;/code&gt; is resolved with an object with a &lt;code&gt;bytesRead&lt;/code&gt; property specifying the number of bytes read, and a &lt;code&gt;buffer&lt;/code&gt; property that is a reference to the passed in &lt;code&gt;buffer&lt;/code&gt; argument.</source>
          <target state="translated">읽은 후, &lt;code&gt;Promise&lt;/code&gt; 는 읽은 바이트 수를 지정 하는 &lt;code&gt;bytesRead&lt;/code&gt; 속성과 전달 된 &lt;code&gt;buffer&lt;/code&gt; 인수 에 대한 참조 인 &lt;code&gt;buffer&lt;/code&gt; 속성을 가진 개체로 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e751ad7175cba92753720b10ba78d5928c127b0" translate="yes" xml:space="preserve">
          <source>Follows &lt;code&gt;require()&lt;/code&gt;'s module resolution rules. &lt;code&gt;module&lt;/code&gt; may be either a path to a file, or a node module name.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 의 모듈 확인 규칙을 따릅니다 . &lt;code&gt;module&lt;/code&gt; 은 파일의 경로이거나 노드 모듈 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0ab2ca2c0cf15e6c487567e8ddb28ffdb646c9" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt;, its value will be equal to &lt;a href=&quot;process#process_process_execpath&quot;&gt;&lt;code&gt;process.execPath&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt;, its value will be the name of the executable file. For &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt;&lt;code&gt;child_process.exec()&lt;/code&gt;&lt;/a&gt;, its value will be the name of the shell in which the child process is launched.</source>
          <target state="translated">들면 &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; , 그 값은 동일 할 것이다 &lt;a href=&quot;process#process_process_execpath&quot;&gt; &lt;code&gt;process.execPath&lt;/code&gt; &lt;/a&gt; . 들어 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; , 그 값은 실행 파일의 이름이됩니다. 들어 &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt; &lt;code&gt;child_process.exec()&lt;/code&gt; &lt;/a&gt; , 그 값은 자식 프로세스가 실행되는 쉘의 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="364153e1c2cf21cfe5f226aed551c4d175223ae8" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; connections, available &lt;code&gt;options&lt;/code&gt; are:</source>
          <target state="translated">들어 &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC의&lt;/a&gt; 연결 가능한 &lt;code&gt;options&lt;/code&gt; 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6743ce5cc737d221faa9da6d6e2770ef67f0eaed" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'base64'&lt;/code&gt; and &lt;code&gt;'hex'&lt;/code&gt;, this function assumes valid input. For strings that contain non-Base64/Hex-encoded data (e.g. whitespace), the return value might be greater than the length of a &lt;code&gt;Buffer&lt;/code&gt; created from the string.</source>
          <target state="translated">들어 &lt;code&gt;'base64'&lt;/code&gt; 와 &lt;code&gt;'hex'&lt;/code&gt; ,이 기능은 유효한 입력을 가정합니다. Base64가 아닌 16 진수로 인코딩 된 데이터 (예 : 공백)가 포함 된 문자열의 경우 반환 값이 문자열에서 생성 된 &lt;code&gt;Buffer&lt;/code&gt; 길이보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d60a3b84e1c02079ddc1d21cc4e988581081bf3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'base64'&lt;/code&gt; and &lt;code&gt;'hex'&lt;/code&gt;, this function assumes valid input. For strings that contain non-base64/hex-encoded data (e.g. whitespace), the return value might be greater than the length of a &lt;code&gt;Buffer&lt;/code&gt; created from the string.</source>
          <target state="translated">들어 &lt;code&gt;'base64'&lt;/code&gt; 와 &lt;code&gt;'hex'&lt;/code&gt; ,이 기능은 유효한 입력을 가정합니다. base64 / hex 인코딩이 아닌 데이터 (예 : 공백)를 포함하는 문자열의 경우 반환 값은 문자열에서 생성 된 &lt;code&gt;Buffer&lt;/code&gt; 의 길이보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce3d9763b5b0e16694af18b9fd21ad80180e71e8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Buffer&lt;/code&gt; instances, specifically, whether the underlying &lt;code&gt;ArrayBuffer&lt;/code&gt; can be transferred or cloned depends entirely on how instances were created, which often cannot be reliably determined.</source>
          <target state="translated">들어 &lt;code&gt;Buffer&lt;/code&gt; 경우, 특히, 기본 여부를 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 전송하거나 복제 할 수 종종 확실하게 판단 할 수없는, 완전히 인스턴스가 생성 된 방법에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="5738b1d816bc0019a52ca62db0ce81fdbf60fca3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Duplex&lt;/code&gt; streams, &lt;code&gt;objectMode&lt;/code&gt; can be set exclusively for either the &lt;code&gt;Readable&lt;/code&gt; or &lt;code&gt;Writable&lt;/code&gt; side using the &lt;code&gt;readableObjectMode&lt;/code&gt; and &lt;code&gt;writableObjectMode&lt;/code&gt; options respectively.</source>
          <target state="translated">들면 &lt;code&gt;Duplex&lt;/code&gt; 스트림 &lt;code&gt;objectMode&lt;/code&gt; 는 어느만으로 설정 될 수 &lt;code&gt;Readable&lt;/code&gt; 또는 &lt;code&gt;Writable&lt;/code&gt; 은 USING 측 &lt;code&gt;readableObjectMode&lt;/code&gt; 및 &lt;code&gt;writableObjectMode&lt;/code&gt; 의 각각 옵션.</target>
        </trans-unit>
        <trans-unit id="6a2f669d8368ce836c3edfc9f3610622d501a24a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;EventEmitter&lt;/code&gt;s this behaves exactly the same as calling &lt;code&gt;.listeners&lt;/code&gt; on the emitter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d795b81e12b054fd6e181ea6bf140a456191ba2" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;EventTarget&lt;/code&gt;s this is the only way to get the event listeners for the event target. This is useful for debugging and diagnostic purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726a3814672a51bb16b132deb5b27c9dfceacadd" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;IPv6&lt;/code&gt;, the minimum &lt;code&gt;MTU&lt;/code&gt; is &lt;code&gt;1280&lt;/code&gt; octets, however, the mandatory minimum fragment reassembly buffer size is &lt;code&gt;1500&lt;/code&gt; octets. The value of &lt;code&gt;68&lt;/code&gt; octets is very small, since most current link layer technologies, like Ethernet, have a minimum &lt;code&gt;MTU&lt;/code&gt; of &lt;code&gt;1500&lt;/code&gt;.</source>
          <target state="translated">내용 &lt;code&gt;IPv6&lt;/code&gt; , 최소 &lt;code&gt;MTU&lt;/code&gt; 는 인 &lt;code&gt;1280&lt;/code&gt; 옥텟 그러나, 필수 최소 단편 재조합 버퍼 크기가 &lt;code&gt;1500&lt;/code&gt; 옥텟. 이더넷과 같은 대부분의 현재 링크 계층 기술은 최소 &lt;code&gt;MTU&lt;/code&gt; 가 &lt;code&gt;1500&lt;/code&gt; 이기 때문에 &lt;code&gt;68&lt;/code&gt; 옥텟 의 값 은 매우 작습니다 .</target>
        </trans-unit>
        <trans-unit id="ef13c995164441a286908cff880af59f92199d7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;setImmediate()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fac0e3beb08b280ae9fdefb7a5164b9203b742" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;setTimeout()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="807ed9c50474fd97ddcf0fbafe4910d8a06b93be" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;all&lt;/em&gt;&lt;a href=&quot;events#events_class_eventemitter&quot;&gt;&lt;code&gt;EventEmitter&lt;/code&gt;&lt;/a&gt; objects, if an &lt;code&gt;'error'&lt;/code&gt; event handler is not provided, the error will be thrown, causing the Node.js process to report an uncaught exception and crash unless either: The &lt;a href=&quot;domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; module is used appropriately or a handler has been registered for the &lt;a href=&quot;process#process_event_uncaughtexception&quot;&gt;&lt;code&gt;'uncaughtException'&lt;/code&gt;&lt;/a&gt; event.</source>
          <target state="translated">들어 &lt;em&gt;모든 &lt;/em&gt;&lt;a href=&quot;events#events_class_eventemitter&quot;&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 의&lt;/a&gt; 는 IF 객체, &lt;code&gt;'error'&lt;/code&gt; : 이벤트 핸들러가 제공되지 않는 오류가하지 않는 한 어느 쪽 캐치되지 않는 예외와 충돌을보고 할 Node.js를 원인 프로세스 발생합니다 &lt;a href=&quot;domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 모듈이 적절하게 사용하거나 핸들러가 등록 된 에 대한 &lt;a href=&quot;process#process_event_uncaughtexception&quot;&gt; &lt;code&gt;'uncaughtException'&lt;/code&gt; &lt;/a&gt; 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="9db239cb39b6243c0a9896e792edcb1f42803ef2" translate="yes" xml:space="preserve">
          <source>For API consistency &lt;code&gt;disable()&lt;/code&gt; also returns the &lt;code&gt;AsyncHook&lt;/code&gt; instance.</source>
          <target state="translated">API 일관성을 위해 &lt;code&gt;disable()&lt;/code&gt; 은 &lt;code&gt;AsyncHook&lt;/code&gt; 인스턴스 도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="61a8023e4bdff1f9b5524c44b26bb178ebbb4dd7" translate="yes" xml:space="preserve">
          <source>For APIs that accept options objects, some options might be mandatory. This code is thrown if a required option is missing.</source>
          <target state="translated">옵션 객체를 허용하는 API의 경우 일부 옵션이 필수 일 수 있습니다. 이 코드는 필수 옵션이 누락 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3588eddb6018d7625324d1f57375f846d2459584" translate="yes" xml:space="preserve">
          <source>For Brotli-based streams</source>
          <target state="translated">Brotli 기반 스트림</target>
        </trans-unit>
        <trans-unit id="f745f32641eabb2eb1367bcb56d453946dde71bc" translate="yes" xml:space="preserve">
          <source>For EC keys, the following properties may be defined:</source>
          <target state="translated">EC 키의 경우 다음 속성을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19ff2da1e3a9deef252592555908b062e3d215e3" translate="yes" xml:space="preserve">
          <source>For HTTP/2 Client &lt;code&gt;Http2Session&lt;/code&gt; instances only, the &lt;code&gt;http2session.request()&lt;/code&gt; creates and returns an &lt;code&gt;Http2Stream&lt;/code&gt; instance that can be used to send an HTTP/2 request to the connected server.</source>
          <target state="translated">HTTP / 2 클라이언트 &lt;code&gt;Http2Session&lt;/code&gt; 인스턴스의 경우에만 &lt;code&gt;http2session.request()&lt;/code&gt; 는 연결된 서버에 HTTP / 2 요청을 보내는 데 사용할 수 있는 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스를 작성하고 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ac52d39bfe5e210ec0d46e02a56edabe98515f79" translate="yes" xml:space="preserve">
          <source>For HTTP/2 requests using the &lt;code&gt;CONNECT&lt;/code&gt; method, the &lt;code&gt;:authority&lt;/code&gt; pseudo-header is required.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 메소드를 사용하는 HTTP / 2 요청의 경우 &lt;code&gt;:authority&lt;/code&gt; pseudo-header가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1235c965de149b89779a05b39e095354458ec8b3" translate="yes" xml:space="preserve">
          <source>For HTTP/2 requests using the &lt;code&gt;CONNECT&lt;/code&gt; method, the &lt;code&gt;:path&lt;/code&gt; pseudo-header is forbidden.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 메소드를 사용하는 HTTP / 2 요청의 경우 &lt;code&gt;:path&lt;/code&gt; 의사 헤더는 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="9f76b25e7f9c52c79a4dd8c33b36c128a6246cd7" translate="yes" xml:space="preserve">
          <source>For HTTP/2 requests using the &lt;code&gt;CONNECT&lt;/code&gt; method, the &lt;code&gt;:scheme&lt;/code&gt; pseudo-header is forbidden.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 메소드를 사용하는 HTTP / 2 요청의 경우 &lt;code&gt;:scheme&lt;/code&gt; 의사 헤더가 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b4dc5adbc9a37cc0fa282f9707d1bf909242a6" translate="yes" xml:space="preserve">
          <source>For IPv4 sockets, this should be the IP configured for the desired physical interface. All packets sent to multicast on the socket will be sent on the interface determined by the most recent successful use of this call.</source>
          <target state="translated">IPv4 소켓의 경우 원하는 물리적 인터페이스에 대해 구성된 IP 여야합니다. 소켓에서 멀티 캐스트로 전송 된 모든 패킷은이 호출의 가장 최근 사용에 의해 결정된 인터페이스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="da7e5155b506d17e1cd7f7057b5e95a6f05d933c" translate="yes" xml:space="preserve">
          <source>For IPv6 sockets, &lt;code&gt;multicastInterface&lt;/code&gt; should include a scope to indicate the interface as in the examples that follow. In IPv6, individual &lt;code&gt;send&lt;/code&gt; calls can also use explicit scope in addresses, so only packets sent to a multicast address without specifying an explicit scope are affected by the most recent successful use of this call.</source>
          <target state="translated">IPv6 소켓의 경우 &lt;code&gt;multicastInterface&lt;/code&gt; 에는 다음 예제와 같이 인터페이스를 나타내는 범위가 포함되어야합니다. IPv6에서 개별 &lt;code&gt;send&lt;/code&gt; 호출은 주소에서 명시 적 범위를 사용할 수도 있으므로 명시 적 범위를 지정하지 않고 멀티 캐스트 주소로 전송 된 패킷 만이 호출의 가장 성공적인 사용에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="02597d7f74042275d6b90bcf4683898c152cdc72" translate="yes" xml:space="preserve">
          <source>For IPv6 sockets, multicastInterface should include a scope to indicate the interface as in the examples that follow. In IPv6, individual send calls can also use explicit scope in addresses, so only packets sent to a multicast address without specifying an explicit scope are affected by the most recent successful use of this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c41f0e4ba827786793ba1797a213c932c51a72" translate="yes" xml:space="preserve">
          <source>For IPv6, the minimum &lt;code&gt;MTU&lt;/code&gt; is 1280 octets. However, the mandatory minimum fragment reassembly buffer size is 1500 octets. The value of 68 octets is very small, since most current link layer technologies, like Ethernet, have a minimum &lt;code&gt;MTU&lt;/code&gt; of 1500.</source>
          <target state="translated">IPv6의 경우 최소 &lt;code&gt;MTU&lt;/code&gt; 는 1280 옥텟입니다. 그러나 필수 최소 조각 리 어셈블리 버퍼 크기는 1500 옥텟입니다. 이더넷과 같은 최신 링크 계층 기술의 최소 &lt;code&gt;MTU&lt;/code&gt; 는 1500 이므로 68 옥텟의 값은 매우 작습니다 .</target>
        </trans-unit>
        <trans-unit id="67ba1d2388ff36aedcbc507dd344fe06dc257e1c" translate="yes" xml:space="preserve">
          <source>For Linux developers, the necessary C/C++ toolchain packages are readily available. &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt; is widely used in the Node.js community to build and test across a variety of platforms. For many developers, the &lt;a href=&quot;https://llvm.org&quot;&gt;LLVM&lt;/a&gt; compiler infrastructure is also a good choice.</source>
          <target state="translated">Linux 개발자의 경우 필요한 C / C ++ 도구 모음 패키지를 즉시 사용할 수 있습니다. &lt;a href=&quot;https://gcc.gnu.org&quot;&gt;GCC&lt;/a&gt; 는 다양한 플랫폼에서 빌드하고 테스트하기 위해 Node.js 커뮤니티에서 널리 사용됩니다. 많은 개발자에게 &lt;a href=&quot;https://llvm.org&quot;&gt;LLVM&lt;/a&gt; 컴파일러 인프라도 좋은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d7079da88ff656dcfb94b7f2c8acf26ac05a4746" translate="yes" xml:space="preserve">
          <source>For Mac developers, &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode&lt;/a&gt; offers all the required compiler tools. However, it is not necessary to install the entire Xcode IDE. The following command installs the necessary toolchain:</source>
          <target state="translated">Mac 개발자를 위해 &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;Xcode&lt;/a&gt; 는 필요한 모든 컴파일러 도구를 제공합니다. 그러나 전체 Xcode IDE를 설치할 필요는 없습니다. 다음 명령은 필요한 도구 모음을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="d72f8355ff2ff242fbb93f63d211c16d47fcbf07" translate="yes" xml:space="preserve">
          <source>For Node.js &amp;gt;=4 &lt;code&gt;Buffers&lt;/code&gt; are &lt;code&gt;Uint8Array&lt;/code&gt;s.</source>
          <target state="translated">Node.js&amp;gt; = 4의 경우 &lt;code&gt;Buffers&lt;/code&gt; 는 &lt;code&gt;Uint8Array&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d91b862c34fefcbbfc2f7f3f050ba30ad9c62cea" translate="yes" xml:space="preserve">
          <source>For Node.js, clients use the same APIs for resumption with session identifiers as for resumption with session tickets. For debugging, if &lt;a href=&quot;#tls_tlssocket_gettlsticket&quot;&gt;&lt;code&gt;tls.TLSSocket.getTLSTicket()&lt;/code&gt;&lt;/a&gt; returns a value, the session data contains a ticket, otherwise it contains client-side session state.</source>
          <target state="translated">Node.js의 경우 클라이언트는 세션 티켓으로 재개 할 때와 세션 식별자로 재개 할 때 동일한 API를 사용합니다. 디버깅을 위해 &lt;a href=&quot;#tls_tlssocket_gettlsticket&quot;&gt; &lt;code&gt;tls.TLSSocket.getTLSTicket()&lt;/code&gt; &lt;/a&gt; 이 값을 반환하면 세션 데이터에 티켓이 포함되고 그렇지 않으면 클라이언트 측 세션 상태가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c96e0afc2bb2d26f14d553f20addf6a5c8b0dd68" translate="yes" xml:space="preserve">
          <source>For Node.js, clients wait for the &lt;a href=&quot;#tls_event_session&quot;&gt;&lt;code&gt;'session'&lt;/code&gt;&lt;/a&gt; event to get the session data, and provide the data to the &lt;code&gt;session&lt;/code&gt; option of a subsequent &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt;&lt;code&gt;tls.connect()&lt;/code&gt;&lt;/a&gt; to reuse the session. Servers must implement handlers for the &lt;a href=&quot;#tls_event_newsession&quot;&gt;&lt;code&gt;'newSession'&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tls_event_resumesession&quot;&gt;&lt;code&gt;'resumeSession'&lt;/code&gt;&lt;/a&gt; events to save and restore the session data using the session ID as the lookup key to reuse sessions. To reuse sessions across load balancers or cluster workers, servers must use a shared session cache (such as Redis) in their session handlers.</source>
          <target state="translated">Node.js의 경우 클라이언트는 &lt;a href=&quot;#tls_event_session&quot;&gt; &lt;code&gt;'session'&lt;/code&gt; &lt;/a&gt; 이벤트가 세션 데이터를 가져 오기를 &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt; &lt;code&gt;tls.connect()&lt;/code&gt; &lt;/a&gt; 세션을 재사용하기 위해 후속 tls.connect () 의 &lt;code&gt;session&lt;/code&gt; 옵션에 데이터를 제공합니다 . 서버는 세션을 재사용하기위한 검색 키로 세션 ID를 사용하여 세션 데이터를 저장하고 복원 하려면 &lt;a href=&quot;#tls_event_newsession&quot;&gt; &lt;code&gt;'newSession'&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tls_event_resumesession&quot;&gt; &lt;code&gt;'resumeSession'&lt;/code&gt; &lt;/a&gt; 이벤트에 대한 핸들러를 구현해야 합니다. 로드 밸런서 또는 클러스터 워커에서 세션을 재사용하려면 서버는 세션 핸들러에서 공유 세션 캐시 (예 : Redis)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a31791d20d42eff4891173bcddf13197675ee48" translate="yes" xml:space="preserve">
          <source>For RSA keys, the following properties may be defined:</source>
          <target state="translated">RSA 키의 경우 다음 속성을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d77554b430ac3edbc023e55df228aa42aa46a1fd" translate="yes" xml:space="preserve">
          <source>For TCP connections, available &lt;code&gt;options&lt;/code&gt; are:</source>
          <target state="translated">TCP 연결의 경우 사용 가능한 &lt;code&gt;options&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bc85e42d0151641a80b220c2cea7d2ccf0260a9" translate="yes" xml:space="preserve">
          <source>For TLSv1.2 and below, &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt;&lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt;&lt;/a&gt; can be called once the handshake is complete. For TLSv1.3, only ticket-based resumption is allowed by the protocol, multiple tickets are sent, and the tickets aren't sent until after the handshake completes. So it is necessary to wait for the &lt;code&gt;'session'&lt;/code&gt; event to get a resumable session. Applications should use the &lt;code&gt;'session'&lt;/code&gt; event instead of &lt;code&gt;getSession()&lt;/code&gt; to ensure they will work for all TLS versions. Applications that only expect to get or use one session should listen for this event only once:</source>
          <target state="translated">TLSv1.2 이하의 경우 핸드 셰이크가 완료되면 &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt; &lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다. TLSv1.3의 경우 프로토콜에서 티켓 기반 재개 만 허용되고 여러 티켓이 전송되며 핸드 셰이크가 완료 될 때까지 티켓이 전송되지 않습니다. 따라서 재개 가능한 세션을 얻으려면 &lt;code&gt;'session'&lt;/code&gt; 이벤트를 기다려야합니다 . 애플리케이션은 모든 TLS 버전에서 작동하는지 확인하기 위해 &lt;code&gt;getSession()&lt;/code&gt; 대신 &lt;code&gt;'session'&lt;/code&gt; 이벤트를 사용해야합니다 . 하나의 세션 만 가져 오거나 사용할 것으로 예상되는 응용 프로그램은이 이벤트를 한 번만 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="979dfbcfa700e680c9501372ceaa9ed2a59656aa" translate="yes" xml:space="preserve">
          <source>For TLSv1.3, renegotiation cannot be initiated, it is not supported by the protocol.</source>
          <target state="translated">TLSv1.3의 경우 재협상을 시작할 수 없으며 프로토콜에서 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3744b46885dc2cf0f0abd7bd5b5b20e9ce947bf9" translate="yes" xml:space="preserve">
          <source>For UDP sockets, causes the &lt;code&gt;dgram.Socket&lt;/code&gt; to listen for datagram messages on a named &lt;code&gt;port&lt;/code&gt; and optional &lt;code&gt;address&lt;/code&gt; that are passed as properties of an &lt;code&gt;options&lt;/code&gt; object passed as the first argument. If &lt;code&gt;port&lt;/code&gt; is not specified or is &lt;code&gt;0&lt;/code&gt;, the operating system will attempt to bind to a random port. If &lt;code&gt;address&lt;/code&gt; is not specified, the operating system will attempt to listen on all addresses. Once binding is complete, a &lt;code&gt;'listening'&lt;/code&gt; event is emitted and the optional &lt;code&gt;callback&lt;/code&gt; function is called.</source>
          <target state="translated">UDP 소켓의 경우 &lt;code&gt;dgram.Socket&lt;/code&gt; 이 첫 번째 인수로 전달 된 &lt;code&gt;options&lt;/code&gt; 객체의 속성으로 전달 된 명명 된 &lt;code&gt;port&lt;/code&gt; 및 선택적 &lt;code&gt;address&lt;/code&gt; 에서 데이터 그램 메시지를 수신합니다 . 경우 &lt;code&gt;port&lt;/code&gt; 지정되지 않았거나 &lt;code&gt;0&lt;/code&gt; , 운영 시스템은 임의의 포트에 바인딩을 시도합니다. 경우 &lt;code&gt;address&lt;/code&gt; 지정되지 않은 운영 체제는 모든 주소를 수신 할 시도합니다. 바인딩이 완료되면 &lt;code&gt;'listening'&lt;/code&gt; 이벤트가 생성되고 선택적 &lt;code&gt;callback&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63b5a5e0d8c4664472ec4c4a544906d5dce5d01e" translate="yes" xml:space="preserve">
          <source>For UDP sockets, causes the &lt;code&gt;dgram.Socket&lt;/code&gt; to listen for datagram messages on a named &lt;code&gt;port&lt;/code&gt; and optional &lt;code&gt;address&lt;/code&gt;. If &lt;code&gt;port&lt;/code&gt; is not specified or is &lt;code&gt;0&lt;/code&gt;, the operating system will attempt to bind to a random port. If &lt;code&gt;address&lt;/code&gt; is not specified, the operating system will attempt to listen on all addresses. Once binding is complete, a &lt;code&gt;'listening'&lt;/code&gt; event is emitted and the optional &lt;code&gt;callback&lt;/code&gt; function is called.</source>
          <target state="translated">UDP 소켓의 경우 &lt;code&gt;dgram.Socket&lt;/code&gt; 이 이름 지정된 &lt;code&gt;port&lt;/code&gt; 및 선택적 &lt;code&gt;address&lt;/code&gt; 에서 데이터 그램 메시지를 청취 합니다 . 경우 &lt;code&gt;port&lt;/code&gt; 지정되지 않았거나 &lt;code&gt;0&lt;/code&gt; , 운영 시스템은 임의의 포트에 바인딩을 시도합니다. 경우 &lt;code&gt;address&lt;/code&gt; 지정되지 않은 운영 체제는 모든 주소를 수신 할 시도합니다. 바인딩이 완료되면 &lt;code&gt;'listening'&lt;/code&gt; 이벤트가 생성되고 선택적 &lt;code&gt;callback&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0ee3ae7e425979df5dd17216782c2ca6246fe6" translate="yes" xml:space="preserve">
          <source>For Windows developers, &lt;a href=&quot;https://visualstudio.microsoft.com&quot;&gt;Visual Studio&lt;/a&gt; offers all the required compiler tools. However, it is not necessary to install the entire Visual Studio IDE. The following command installs the necessary toolchain:</source>
          <target state="translated">Windows 개발자를 위해 &lt;a href=&quot;https://visualstudio.microsoft.com&quot;&gt;Visual Studio&lt;/a&gt; 는 필요한 모든 컴파일러 도구를 제공합니다. 그러나 전체 Visual Studio IDE를 설치할 필요는 없습니다. 다음 명령은 필요한 도구 모음을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="0f10d6312c65a10e40478628490edb2096732122" translate="yes" xml:space="preserve">
          <source>For a client, returns the TLS session ticket if one is available, or &lt;code&gt;undefined&lt;/code&gt;. For a server, always returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">클라이언트의 경우 TLS 세션 티켓이 사용 가능하거나 &lt;code&gt;undefined&lt;/code&gt; 경우이를 리턴합니다 . 서버의 경우 항상 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a16be6b0edd494d3453e8550a0985bf92717f07d" translate="yes" xml:space="preserve">
          <source>For a complete &lt;code&gt;require.resolve&lt;/code&gt; replacement, there is a flagged experimental &lt;a href=&quot;#esm_import_meta_resolve_specifier_parent&quot;&gt;&lt;code&gt;import.meta.resolve&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630f6e17ed438455cfbf701cc3919cfedd516f9b" translate="yes" xml:space="preserve">
          <source>For a file &lt;code&gt;foo.js&lt;/code&gt;, this will be &lt;code&gt;true&lt;/code&gt; if run via &lt;code&gt;node foo.js&lt;/code&gt;, but &lt;code&gt;false&lt;/code&gt; if run by &lt;code&gt;require('./foo')&lt;/code&gt;.</source>
          <target state="translated">파일의 경우 &lt;code&gt;foo.js&lt;/code&gt; ,이 될 것입니다 &lt;code&gt;true&lt;/code&gt; 통해 실행하는 경우 &lt;code&gt;node foo.js&lt;/code&gt; 하지만 &lt;code&gt;false&lt;/code&gt; 으로 실행하는 경우 &lt;code&gt;require('./foo')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092b0e56ba5f0c7434ace0be825451abc0fc5031" translate="yes" xml:space="preserve">
          <source>For a main program this is not necessarily the same as the file name used in the command line.</source>
          <target state="translated">기본 프로그램의 경우 이는 명령 행에 사용 된 파일 이름과 반드시 ​​같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="094a7aed80ffd76ce1da617382947687f2caf83d" translate="yes" xml:space="preserve">
          <source>For a server listening on a pipe or Unix domain socket, the name is returned as a string.</source>
          <target state="translated">파이프 또는 Unix 도메인 소켓에서 수신 대기하는 서버의 경우 이름이 문자열로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b77166bb59c03f091498405867db62e6d7e2ce9f" translate="yes" xml:space="preserve">
          <source>For a timer that was previously started by calling &lt;a href=&quot;#console_console_time_label&quot;&gt;&lt;code&gt;console.time()&lt;/code&gt;&lt;/a&gt;, prints the elapsed time and other &lt;code&gt;data&lt;/code&gt; arguments to &lt;code&gt;stdout&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#console_console_time_label&quot;&gt; &lt;code&gt;console.time()&lt;/code&gt; &lt;/a&gt; 을 호출하여 이전에 시작한 타이머의 경우 경과 시간 및 기타 &lt;code&gt;data&lt;/code&gt; 인수를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d97dbfb76da7ef6e4ade39dc2ca4fda8cbd356aa" translate="yes" xml:space="preserve">
          <source>For advanced line-editors, start Node.js with the environment variable &lt;code&gt;NODE_NO_READLINE=1&lt;/code&gt;. This will start the main and debugger REPL in canonical terminal settings, which will allow use with &lt;code&gt;rlwrap&lt;/code&gt;.</source>
          <target state="translated">고급 라인 편집기의 경우 환경 변수 &lt;code&gt;NODE_NO_READLINE=1&lt;/code&gt; 로 Node.js를 시작하십시오 . 그러면 정식 터미널 설정에서 기본 및 디버거 REPL이 시작되어 &lt;code&gt;rlwrap&lt;/code&gt; 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="956902aa84cfb91f426f18cd11e77e87658eab1e" translate="yes" xml:space="preserve">
          <source>For all other headers, the values are joined together with ', '.</source>
          <target state="translated">다른 모든 헤더의 경우 값은 ','와 함께 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9e78e07b8e3d47493e082f3a0b59b361f8d9f4" translate="yes" xml:space="preserve">
          <source>For all string values of &lt;code&gt;urlObject.protocol&lt;/code&gt; that &lt;em&gt;do not end&lt;/em&gt; with an ASCII colon (&lt;code&gt;:&lt;/code&gt;) character, the literal string &lt;code&gt;:&lt;/code&gt; will be appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">모든 문자열 값에 대한 &lt;code&gt;urlObject.protocol&lt;/code&gt; &lt;em&gt;말을하지 않습니다&lt;/em&gt; (아스키 콜론 &lt;code&gt;:&lt;/code&gt; ) 문자, 리터럴 문자열 &lt;code&gt;:&lt;/code&gt; 에 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca59737c208aca1081310d096f89773e74cabed" translate="yes" xml:space="preserve">
          <source>For all the mechanisms, when resumption fails, servers will create new sessions. Since failing to resume the session does not cause TLS/HTTPS connection failures, it is easy to not notice unnecessarily poor TLS performance. The OpenSSL CLI can be used to verify that servers are resuming sessions. Use the &lt;code&gt;-reconnect&lt;/code&gt; option to &lt;code&gt;openssl s_client&lt;/code&gt;, for example:</source>
          <target state="translated">모든 메커니즘에서 재개에 실패하면 서버는 새 세션을 만듭니다. 세션 재개에 실패해도 TLS / HTTPS 연결 실패가 발생하지 않으므로 불필요하게 TLS 성능이 저하되는 것을 쉽게 알 수 없습니다. OpenSSL CLI를 사용하여 서버가 세션을 재개하고 있는지 확인할 수 있습니다. &lt;code&gt;-reconnect&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;openssl s_client&lt;/code&gt; 를 입력하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="a0b60983e76d7f440441e08547a1823af1549878" translate="yes" xml:space="preserve">
          <source>For an example of running a &quot;full-featured&quot; (&lt;code&gt;terminal&lt;/code&gt;) REPL over a &lt;code&gt;net.Server&lt;/code&gt; and &lt;code&gt;net.Socket&lt;/code&gt; instance, see: &lt;a href=&quot;https://gist.github.com/TooTallNate/2209310&quot;&gt;https://gist.github.com/TooTallNate/2209310&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;net.Server&lt;/code&gt; 를 통해 &quot;전 기능&quot;( &lt;code&gt;terminal&lt;/code&gt; ) REPL을 실행하는 예제 및 &lt;code&gt;net.Socket&lt;/code&gt; 인스턴스에서&lt;a href=&quot;https://gist.github.com/TooTallNate/2209310&quot;&gt; https://gist.github.com/TooTallNate/2209310을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="07a0aeba9b4457e77a58461fba017f92063a71cb" translate="yes" xml:space="preserve">
          <source>For an example of running a REPL instance over &lt;a href=&quot;https://curl.haxx.se/docs/manpage.html&quot;&gt;&lt;code&gt;curl(1)&lt;/code&gt;&lt;/a&gt;, see: &lt;a href=&quot;https://gist.github.com/TooTallNate/2053342&quot;&gt;https://gist.github.com/TooTallNate/2053342&lt;/a&gt;.</source>
          <target state="translated">REPL 인스턴스를 실행하는 예제 &lt;a href=&quot;https://curl.haxx.se/docs/manpage.html&quot;&gt; &lt;code&gt;curl(1)&lt;/code&gt; &lt;/a&gt; 에서&lt;a href=&quot;https://gist.github.com/TooTallNate/2053342&quot;&gt; https://gist.github.com/TooTallNate/2053342를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4be3dea74f8c5394f0d772060dd8dfe750945e2" translate="yes" xml:space="preserve">
          <source>For asymmetric keys, the &lt;code&gt;options&lt;/code&gt; parameter is used to determine the export format.</source>
          <target state="translated">비대칭 키의 경우 &lt;code&gt;options&lt;/code&gt; 매개 변수를 사용하여 내보내기 형식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6d94d466d7937d23e8d706b37324e3a1192a7b33" translate="yes" xml:space="preserve">
          <source>For asymmetric keys, this property represents the type of the key. Supported key types are:</source>
          <target state="translated">비대칭 키의 경우이 속성은 키 유형을 나타냅니다. 지원되는 키 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4ad1d8fe67baf4433fd03726b4832dd9a01cc76" translate="yes" xml:space="preserve">
          <source>For asynchronous cleanup, &lt;a href=&quot;#n_api_napi_add_async_cleanup_hook&quot;&gt;&lt;code&gt;napi_add_async_cleanup_hook&lt;/code&gt;&lt;/a&gt; is available.</source>
          <target state="translated">비동기 정리의 경우 &lt;a href=&quot;#n_api_napi_add_async_cleanup_hook&quot;&gt; &lt;code&gt;napi_add_async_cleanup_hook&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec619ed21139aa754437a9abbf846fa6dc1227ce" translate="yes" xml:space="preserve">
          <source>For available options, see &lt;a href=&quot;#net_new_net_socket_options&quot;&gt;&lt;code&gt;new net.Socket([options])&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt;&lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션은 &lt;a href=&quot;#net_new_net_socket_options&quot;&gt; &lt;code&gt;new net.Socket([options])&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt; &lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e719e3fc1d310a7e64c540e90b09027f0d710116" translate="yes" xml:space="preserve">
          <source>For backward compatibility reasons, removing &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; event handlers will &lt;strong&gt;not&lt;/strong&gt; automatically pause the stream. Also, if there are piped destinations, then calling &lt;a href=&quot;#stream_readable_pause&quot;&gt;&lt;code&gt;stream.pause()&lt;/code&gt;&lt;/a&gt; will not guarantee that the stream will &lt;em&gt;remain&lt;/em&gt; paused once those destinations drain and ask for more data.</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러를 제거해도 스트림이 자동으로 일시 중지 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 또한 파이프 된 대상이있는 경우 &lt;a href=&quot;#stream_readable_pause&quot;&gt; &lt;code&gt;stream.pause()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 스트림이&lt;em&gt;&lt;/em&gt; 하면 해당 대상이 배출되고 더 많은 데이터를 요청 일시 중지 된 &lt;em&gt;상태로 유지&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8467f6f4c373a250fecab051adc8e06066b9452a" translate="yes" xml:space="preserve">
          <source>For backward compatibility, &lt;code&gt;res&lt;/code&gt; will only emit &lt;code&gt;'error'&lt;/code&gt; if there is an &lt;code&gt;'error'&lt;/code&gt; listener registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b572ea5a61b0e2dd4b314ad5fd04ca49678855" translate="yes" xml:space="preserve">
          <source>For better compatibility with existing usage in the JS ecosystem, Node.js in addition attempts to determine the CommonJS named exports of every imported CommonJS module to provide them as separate ES module exports using a static analysis process.</source>
          <target state="translated">JS 생태계의 기존 사용과의 호환성을 높이기 위해 Node.js는 추가로 가져온 모든 CommonJS 모듈의 CommonJS 명명 된 내보내기를 결정하여 정적 분석 프로세스를 사용하여 별도의 ES 모듈 내보내기로 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b0aa0856c9a116c6cf6dca4bd616192d4bafd000" translate="yes" xml:space="preserve">
          <source>For both types, available &lt;code&gt;options&lt;/code&gt; include:</source>
          <target state="translated">두 유형 모두 사용 가능한 &lt;code&gt;options&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="391e7d798da035e1df8b3a58985f8189e10524aa" translate="yes" xml:space="preserve">
          <source>For certain use cases, such as automating shell scripts, the &lt;a href=&quot;#child_process_synchronous_process_creation&quot;&gt;synchronous counterparts&lt;/a&gt; may be more convenient. In many cases, however, the synchronous methods can have significant impact on performance due to stalling the event loop while spawned processes complete.</source>
          <target state="translated">셸 스크립트 자동화와 같은 특정 사용 사례의 경우 &lt;a href=&quot;#child_process_synchronous_process_creation&quot;&gt; 동기 상대방&lt;/a&gt; 이 더 편리 할 수 ​​있습니다. 그러나 대부분의 경우 동기 메소드는 생성 된 프로세스가 완료되는 동안 이벤트 루프가 정지되어 성능에 상당한 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fed84099ae298e282510b979a03e0e6d087d46" translate="yes" xml:space="preserve">
          <source>For compatibility with &lt;a href=&quot;http&quot;&gt;HTTP/1&lt;/a&gt;, a human-readable &lt;code&gt;statusMessage&lt;/code&gt; may be passed as the second argument. However, because the &lt;code&gt;statusMessage&lt;/code&gt; has no meaning within HTTP/2, the argument will have no effect and a process warning will be emitted.</source>
          <target state="translated">&lt;a href=&quot;http&quot;&gt;HTTP / 1&lt;/a&gt; 과의 호환성을 위해 , 사람이 읽을 수있는 &lt;code&gt;statusMessage&lt;/code&gt; 가 두 번째 인수로 전달 될 수 있습니다. 그러나 &lt;code&gt;statusMessage&lt;/code&gt; 는 HTTP / 2 내에서 의미가 없으므로 인수가 적용되지 않으며 프로세스 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="31e384f06cf594d15b7f90d53096bd4481fa0bc8" translate="yes" xml:space="preserve">
          <source>For completeness there is also &lt;code&gt;--input-type=commonjs&lt;/code&gt;, for explicitly running string input as CommonJS. This is the default behavior if &lt;code&gt;--input-type&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;--input-type=commonjs&lt;/code&gt; 을 위해 문자열 입력을 CommonJS로 명시 적으로 실행하기위한 --input-type = commonjs 도 있습니다 . &lt;code&gt;--input-type&lt;/code&gt; 이 지정되지 않은 경우 이것이 기본 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="98fc04d7d5785d371edbb41ee50020498b1a136b" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;options.stdio&lt;/code&gt; may be one of the following strings:</source>
          <target state="translated">편의상, &lt;code&gt;options.stdio&lt;/code&gt; 는 다음 문자열 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bed0fbf79e83dbe9b208684ee2d517bec0c11bf" translate="yes" xml:space="preserve">
          <source>For convenience, the &lt;code&gt;child_process&lt;/code&gt; module provides a handful of synchronous and asynchronous alternatives to &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;. Each of these alternatives are implemented on top of &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상 &lt;code&gt;child_process&lt;/code&gt; 모듈은 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; 대한 소수의 동기 및 비동기 대안을 제공합니다 . 이러한 각 대안은 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; 위에 구현됩니다. .</target>
        </trans-unit>
        <trans-unit id="057dd38e823bb2e1cba139ab7426a8ac0df9e0f5" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_chmod_path_mode_callback&quot;&gt;&lt;code&gt;fs.chmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_chmod_path_mode_callback&quot;&gt; &lt;code&gt;fs.chmod()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f55866a6066caed39753b96f223b49821bcdf3e" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_ftruncate_fd_len_callback&quot;&gt;&lt;code&gt;fs.ftruncate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_ftruncate_fd_len_callback&quot;&gt; &lt;code&gt;fs.ftruncate()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7966b350e8f4af364eac8a1a2f1cfe584ac00d9c" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_mkdtemp_prefix_options_callback&quot;&gt;&lt;code&gt;fs.mkdtemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_mkdtemp_prefix_options_callback&quot;&gt; &lt;code&gt;fs.mkdtemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="345ea263ca7cd8151a65a6e51b81b5683256d83d" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_open_path_flags_mode_callback&quot;&gt;&lt;code&gt;fs.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_open_path_flags_mode_callback&quot;&gt; &lt;code&gt;fs.open()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="686d2f045c616932d3ff22cc8786f2b1c1995cbc" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_read_fd_buffer_offset_length_position_callback&quot;&gt;&lt;code&gt;fs.read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_read_fd_buffer_offset_length_position_callback&quot;&gt; &lt;code&gt;fs.read()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a0b8688ce27c0c13b0e5e638b026b6e915dcedb" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_readfile_path_options_callback&quot;&gt;&lt;code&gt;fs.readFile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_readfile_path_options_callback&quot;&gt; &lt;code&gt;fs.readFile()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee160f8866cb5dd20b9cf3fc3081d8afad49124" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_readv_fd_buffers_position_callback&quot;&gt;&lt;code&gt;fs.readv()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 문서 &lt;a href=&quot;#fs_fs_readv_fd_buffers_position_callback&quot;&gt; &lt;code&gt;fs.readv()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="026100d5ae38e39e11318cc2cb6d97aac4353ca6" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_realpath_path_options_callback&quot;&gt;&lt;code&gt;fs.realpath()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_realpath_path_options_callback&quot;&gt; &lt;code&gt;fs.realpath()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7177737b8cf18949166e6d0bb6268a458923d13" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_symlink_target_path_type_callback&quot;&gt;&lt;code&gt;fs.symlink()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_symlink_target_path_type_callback&quot;&gt; &lt;code&gt;fs.symlink()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4720f7b4719a50a736dc74b6b468dc1ad01a1e0f" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_utimes_path_atime_mtime_callback&quot;&gt;&lt;code&gt;fs.utimes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_utimes_path_atime_mtime_callback&quot;&gt; &lt;code&gt;fs.utimes()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48e8602ce9e660170055a6f47c4dc1959e90dce6" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_write_fd_buffer_offset_length_position_callback&quot;&gt;&lt;code&gt;fs.write(fd, buffer...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 &lt;a href=&quot;#fs_fs_write_fd_buffer_offset_length_position_callback&quot;&gt; &lt;code&gt;fs.write(fd, buffer...)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="915a4eebfd2351966e0f2be56e64fc6fd86cdd29" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_write_fd_string_position_encoding_callback&quot;&gt;&lt;code&gt;fs.write(fd, string...)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_write_fd_string_position_encoding_callback&quot;&gt; &lt;code&gt;fs.write(fd, string...)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cef3142dfe3ea04c130dffb0f747452a95966d87" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_writefile_file_data_options_callback&quot;&gt;&lt;code&gt;fs.writeFile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;#fs_fs_writefile_file_data_options_callback&quot;&gt; &lt;code&gt;fs.writeFile()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bd81a73f2e605eb60c72787c48b4ebfb0a3515" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;#fs_fs_writev_fd_buffers_position_callback&quot;&gt;&lt;code&gt;fs.writev()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은이 API의 비동기 버전 설명서 인 &lt;a href=&quot;#fs_fs_writev_fd_buffers_position_callback&quot;&gt; &lt;code&gt;fs.writev()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb460aea3653b08568036649165ab5edfff25bc7" translate="yes" xml:space="preserve">
          <source>For detailed information, see the documentation of the asynchronous version of this API: &lt;a href=&quot;fs#fs_fs_exists_path_callback&quot;&gt;&lt;code&gt;fs.exists()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는이 API의 비동기 버전 문서 인 &lt;a href=&quot;fs#fs_fs_exists_path_callback&quot;&gt; &lt;code&gt;fs.exists()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a31e5f2151cc75df2278c49c6c634780f443d5f2" translate="yes" xml:space="preserve">
          <source>For details of how to read from &lt;code&gt;stdin&lt;/code&gt; see &lt;a href=&quot;stream#stream_readable_read_size&quot;&gt;&lt;code&gt;readable.read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 에서 읽는 방법에 대한 자세한 내용 은 &lt;a href=&quot;stream#stream_readable_read_size&quot;&gt; &lt;code&gt;readable.read()&lt;/code&gt; &lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="5548576daa00995aa2b7df9a676d077c05f285e4" translate="yes" xml:space="preserve">
          <source>For details on these package resolution rules that apply to bare specifiers in the Node.js module resolution, see the &lt;a href=&quot;packages&quot;&gt;packages documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4255927b82eac232a3604f861da1b4f744c0e1" translate="yes" xml:space="preserve">
          <source>For duplicate &lt;code&gt;cookie&lt;/code&gt; headers, the values are joined together with '; '.</source>
          <target state="translated">중복 &lt;code&gt;cookie&lt;/code&gt; 헤더의 경우 값은 '; '.</target>
        </trans-unit>
        <trans-unit id="9a215762dd9627461e893eb50e7ebc4a894bd5b4" translate="yes" xml:space="preserve">
          <source>For each item &lt;em&gt;targetValue&lt;/em&gt; in &lt;em&gt;target&lt;/em&gt;, do</source>
          <target state="translated">&lt;em&gt;target의&lt;/em&gt; 각 항목 &lt;em&gt;targetValue&lt;/em&gt; 에 대해 다음을 수행하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c2ec175e11de8ee7e10fd9de87958e9ab2fbadf" translate="yes" xml:space="preserve">
          <source>For each key &lt;em&gt;directory&lt;/em&gt; in &lt;em&gt;directoryKeys&lt;/em&gt;, do</source>
          <target state="translated">각 키의 경우 &lt;em&gt;디렉토리&lt;/em&gt; 에 &lt;em&gt;directoryKeys&lt;/em&gt; 수행</target>
        </trans-unit>
        <trans-unit id="1d3069d86c41a494c783d4b2dd1fe82b5936547f" translate="yes" xml:space="preserve">
          <source>For each key &lt;em&gt;expansionKey&lt;/em&gt; in &lt;em&gt;expansionKeys&lt;/em&gt;, do</source>
          <target state="translated">각 키에 대해 &lt;em&gt;expansionKey&lt;/em&gt; 에서 &lt;em&gt;expansionKeys&lt;/em&gt; 수행</target>
        </trans-unit>
        <trans-unit id="cb4fb1b39fdc4354722af5dcbbc8e4232478dc4a" translate="yes" xml:space="preserve">
          <source>For each property &lt;em&gt;p&lt;/em&gt; of &lt;em&gt;target&lt;/em&gt;, in object insertion order as,</source>
          <target state="translated">&lt;em&gt;target의&lt;/em&gt; 각 속성 &lt;em&gt;p&lt;/em&gt; 에 대해 객체 삽입 순서에서&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57ba04e0b7bcbfc8b08ec80a0e3f27a752793ffd" translate="yes" xml:space="preserve">
          <source>For efficiency reasons, Node.js normally buffers the request headers until &lt;code&gt;request.end()&lt;/code&gt; is called or the first chunk of request data is written. It then tries to pack the request headers and data into a single TCP packet.</source>
          <target state="translated">효율성상의 이유로 Node.js는 일반적으로 &lt;code&gt;request.end()&lt;/code&gt; 가 호출되거나 요청 데이터의 첫 번째 청크가 작성 될 때까지 요청 헤더를 버퍼링합니다 . 그런 다음 요청 헤더와 데이터를 단일 TCP 패킷으로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="55784e38364a3c74fb65e18506c562ba93681880" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--pending-deprecation&lt;/code&gt; is equivalent to &lt;code&gt;--pending_deprecation&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;--pending-deprecation&lt;/code&gt; 은 &lt;code&gt;--pending_deprecation&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="81efa59dff5974501c74872b767ce28b3355d17d" translate="yes" xml:space="preserve">
          <source>For example, a dummy loader to load JavaScript restricted to browser resolution rules with only JS file extension and Node.js builtin modules support could be written:</source>
          <target state="translated">예를 들어, JS 파일 확장자 및 Node.js 내장 모듈 만 지원하는 브라우저 확인 규칙으로 제한되는 JavaScript를로드하는 더미 로더를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1fd6f29efda8714a94ce5aafcd3a0076cfabc91" translate="yes" xml:space="preserve">
          <source>For example, a package that wants to provide different ES module exports for &lt;code&gt;require()&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; can be written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e61c77fd207165adf6649bf4866952e2f3edfa" translate="yes" xml:space="preserve">
          <source>For example, an &lt;code&gt;index.mjs&lt;/code&gt; containing:</source>
          <target state="translated">예를 들어 &lt;code&gt;index.mjs&lt;/code&gt; 포함 하는 index.mjs :</target>
        </trans-unit>
        <trans-unit id="791196aee4b2d4aa0012058507fbdff766fc7664" translate="yes" xml:space="preserve">
          <source>For example, assuming the following script for &lt;code&gt;process-args.js&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;process-args.js&lt;/code&gt; 에 대한 다음 스크립트를 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="b56e15494fee7d0716e0d023ff2d5d693fb34575" translate="yes" xml:space="preserve">
          <source>For example, consider a CommonJS module written:</source>
          <target state="translated">예를 들어 다음과 같이 작성된 CommonJS 모듈을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="translated">예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd48e979ca8c1e29635d97a1d94e0bde8b21e51" translate="yes" xml:space="preserve">
          <source>For example, given the following directory structure:</source>
          <target state="translated">예를 들어 다음과 같은 디렉토리 구조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8204daa0aa3b64001a20242119f9653776f37906" translate="yes" xml:space="preserve">
          <source>For example, given the following folder structure:</source>
          <target state="translated">예를 들어 다음과 같은 폴더 구조가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="edbcaae834047f2d42e2dc73d0381d1160281bb3" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;fs.writeFile()&lt;/code&gt; is called twice in a row, first to write the string &lt;code&gt;'Hello'&lt;/code&gt;, then to write the string &lt;code&gt;', World'&lt;/code&gt;, the file would contain &lt;code&gt;'Hello, World'&lt;/code&gt;, and might contain some of the file's original data (depending on the size of the original file, and the position of the file descriptor). If a file name had been used instead of a descriptor, the file would be guaranteed to contain only &lt;code&gt;', World'&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;fs.writeFile()&lt;/code&gt; 이 두 번 연속으로 호출되면 먼저 문자열 &lt;code&gt;'Hello'&lt;/code&gt; 를 쓰고 문자열 &lt;code&gt;', World'&lt;/code&gt; 를 쓰 려면 파일에 &lt;code&gt;'Hello, World'&lt;/code&gt; 가 포함되며 일부는 파일의 원본 데이터 (원본 파일의 크기 및 파일 설명 자의 위치에 따라 다름) 디스크립터 대신 파일 이름이 사용 된 경우 파일에는 &lt;code&gt;', World'&lt;/code&gt; 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="83817681c437a9bbd3db2ac07540c577eeb01fe0" translate="yes" xml:space="preserve">
          <source>For example, if an attacker can cause an application to receive a number where a string is expected, the application may call &lt;code&gt;new Buffer(100)&lt;/code&gt; instead of &lt;code&gt;new Buffer(&quot;100&quot;)&lt;/code&gt;, it will allocate a 100 byte buffer instead of allocating a 3 byte buffer with content &lt;code&gt;&quot;100&quot;&lt;/code&gt;. This is commonly possible using JSON API calls. Since JSON distinguishes between numeric and string types, it allows injection of numbers where a naive application might expect to always receive a string. Before Node.js 8.0.0, the 100 byte buffer might contain arbitrary pre-existing in-memory data, so may be used to expose in-memory secrets to a remote attacker. Since Node.js 8.0.0, exposure of memory cannot occur because the data is zero-filled. However, other attacks are still possible, such as causing very large buffers to be allocated by the server, leading to performance degradation or crashing on memory exhaustion.</source>
          <target state="translated">예를 들어 공격자가 응용 프로그램에서 문자열이 예상되는 숫자를 수신하도록 할 수있는 경우 응용 프로그램은 &lt;code&gt;new Buffer(&quot;100&quot;)&lt;/code&gt; 대신 &lt;code&gt;new Buffer(100)&lt;/code&gt; 호출 할 수 있습니다 . 내용이 포함 된 3 바이트 버퍼 &lt;code&gt;&quot;100&quot;&lt;/code&gt; 인. 이것은 일반적으로 JSON API 호출을 사용하여 가능합니다. JSON은 숫자 유형과 문자열 유형을 구별하기 때문에 순진 애플리케이션이 항상 문자열을 수신 할 것으로 예상되는 곳에 숫자를 삽입 할 수 있습니다. Node.js 8.0.0 이전에는 100 바이트 버퍼에 임의의 기존 메모리 내 데이터가 포함되어있을 수 있으므로 메모리 내 비밀을 원격 공격자에게 노출시키는 데 사용될 수 있습니다. Node.js 8.0.0부터는 데이터가 0으로 채워져 메모리 노출이 발생할 수 없습니다. 그러나 서버에서 매우 큰 버퍼를 할당하여 성능이 저하되거나 메모리 소진이 발생하는 등의 다른 공격이 여전히 가능합니다.</target>
        </trans-unit>
        <trans-unit id="47b1704b6ea7680c0c55b9d52c9e216c6cad8a45" translate="yes" xml:space="preserve">
          <source>For example, if an attacker can cause an application to receive a number where a string is expected, the application may call &lt;code&gt;new Buffer(100)&lt;/code&gt; instead of &lt;code&gt;new Buffer(&quot;100&quot;)&lt;/code&gt;, leading it to allocate a 100 byte buffer instead of allocating a 3 byte buffer with content &lt;code&gt;&quot;100&quot;&lt;/code&gt;. This is commonly possible using JSON API calls. Since JSON distinguishes between numeric and string types, it allows injection of numbers where a naively written application that does not validate its input sufficiently might expect to always receive a string. Before Node.js 8.0.0, the 100 byte buffer might contain arbitrary pre-existing in-memory data, so may be used to expose in-memory secrets to a remote attacker. Since Node.js 8.0.0, exposure of memory cannot occur because the data is zero-filled. However, other attacks are still possible, such as causing very large buffers to be allocated by the server, leading to performance degradation or crashing on memory exhaustion.</source>
          <target state="translated">예를 들어 공격자가 응용 프로그램이 문자열이 예상되는 번호를 받도록 만들 수있는 경우 응용 프로그램은 &lt;code&gt;new Buffer(&quot;100&quot;)&lt;/code&gt; 대신 &lt;code&gt;new Buffer(100)&lt;/code&gt; 를 호출 하여 할당하는 대신 100 바이트 버퍼를 할당 할 수 있습니다. 내용이 &lt;code&gt;&quot;100&quot;&lt;/code&gt; 인 3 바이트 버퍼. 이는 일반적으로 JSON API 호출을 사용하여 가능합니다. JSON은 숫자 유형과 문자열 유형을 구분하기 때문에 입력을 충분히 검증하지 않는 순진하게 작성된 애플리케이션이 항상 문자열을 수신 할 것으로 예상하는 경우 숫자 삽입을 허용합니다. Node.js 8.0.0 이전에는 100 바이트 버퍼에 임의의 기존 메모리 내 데이터가 포함될 수 있으므로 원격 공격자에게 메모리 내 비밀을 노출하는 데 사용될 수 있습니다. Node.js 8.0.0부터 데이터가 0으로 채워져 있으므로 메모리 노출이 발생할 수 없습니다. 그러나 서버에서 매우 큰 버퍼를 할당하여 성능 저하 또는 메모리 고갈로 인한 충돌과 같은 다른 공격은 여전히 ​​가능합니다.</target>
        </trans-unit>
        <trans-unit id="f1025750a0bfba66023ecadd2e06770fcbd925fd" translate="yes" xml:space="preserve">
          <source>For example, if the file at &lt;code&gt;'/home/ry/projects/foo.js'&lt;/code&gt; called &lt;code&gt;require('bar.js')&lt;/code&gt;, then Node.js would look in the following locations, in this order:</source>
          <target state="translated">에서 파일 예를 들어, &lt;code&gt;'/home/ry/projects/foo.js'&lt;/code&gt; 라는이 &lt;code&gt;require('bar.js')&lt;/code&gt; 하고 Node.js를이 순서대로 다음 위치에 보일 것이다 :</target>
        </trans-unit>
        <trans-unit id="3b0f2056b45a2559c1472d535117f55bdedb6244" translate="yes" xml:space="preserve">
          <source>For example, in the parent script:</source>
          <target state="translated">예를 들어, 부모 스크립트에서 :</target>
        </trans-unit>
        <trans-unit id="67a0d1e33770f9ea91b472de0a7268d921bab538" translate="yes" xml:space="preserve">
          <source>For example, looking up &lt;code&gt;iana.org&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;iana.org&lt;/code&gt; 를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="5f9b50abb71fe1243d71bc3deae82a5ec37fd08d" translate="yes" xml:space="preserve">
          <source>For example, on POSIX:</source>
          <target state="translated">예를 들어 POSIX에서 :</target>
        </trans-unit>
        <trans-unit id="80772b48d8fee4f56aa373bb49a7eceb85d6d0a7" translate="yes" xml:space="preserve">
          <source>For example, suppose we were making a module called &lt;code&gt;a.js&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;a.js&lt;/code&gt; 라는 모듈을 만들고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9ba613f62c42163b625f2f325ed7988a5b30d289" translate="yes" xml:space="preserve">
          <source>For example, the ASCII space character (&lt;code&gt;' '&lt;/code&gt;) is encoded as &lt;code&gt;%20&lt;/code&gt;. The ASCII forward slash (&lt;code&gt;/&lt;/code&gt;) character is encoded as &lt;code&gt;%3C&lt;/code&gt;.</source>
          <target state="translated">예를 들어 ASCII 공백 문자 ( &lt;code&gt;' '&lt;/code&gt; )는 &lt;code&gt;%20&lt;/code&gt; 인코딩됩니다 . ASCII 슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 문자는 &lt;code&gt;%3C&lt;/code&gt; 로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="0daafbfc8f622fbbbf3dc05ed0fe2f79d7ba67f6" translate="yes" xml:space="preserve">
          <source>For example, the code:</source>
          <target state="translated">예를 들어 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f817e6e8af1e18f940aeb34cdd6a390f1393d6ed" translate="yes" xml:space="preserve">
          <source>For example, the following can be added to a &lt;code&gt;.bashrc&lt;/code&gt; file:</source>
          <target state="translated">예를 들어 &lt;code&gt;.bashrc&lt;/code&gt; 파일에 다음을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7062ec00a8c1f78373bb58b32df0bbbb0623d2a5" translate="yes" xml:space="preserve">
          <source>For example, the following code executed by &lt;code&gt;vm.runInNewContext()&lt;/code&gt; with a timeout of 5 milliseconds schedules an infinite loop to run after a promise resolves. The scheduled loop is never interrupted by the timeout:</source>
          <target state="translated">예를 들어 시간 제한이 5 밀리 &lt;code&gt;vm.runInNewContext()&lt;/code&gt; 의해 실행 된 다음 코드 는 약속이 해결 된 후 무한 루프가 실행되도록 예약합니다. 스케줄 된 루프는 시간 종료에 의해 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="253119df57953f965aae87ba4baa7e428da8850a" translate="yes" xml:space="preserve">
          <source>For example, the following program retains only the first four bytes of the file:</source>
          <target state="translated">예를 들어, 다음 프로그램은 파일의 처음 4 바이트 만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0d0cc05ed83946cbc26daf63025dcf7a7bc32bc1" translate="yes" xml:space="preserve">
          <source>For example, the imports field can be used to gain the benefits of conditional exports for internal modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb3dadf374a52eddc18a55a08c68490065d1798" translate="yes" xml:space="preserve">
          <source>For example, the octal value &lt;code&gt;0o765&lt;/code&gt; means:</source>
          <target state="translated">예를 들어, 8 진수 값 &lt;code&gt;0o765&lt;/code&gt; 는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6de4cd8836649e28fe680a474b55dd4cd12f68eb" translate="yes" xml:space="preserve">
          <source>For example, the query string &lt;code&gt;'foo=bar&amp;amp;abc=xyz&amp;amp;abc=123'&lt;/code&gt; is parsed into:</source>
          <target state="translated">예를 들어 쿼리 문자열 &lt;code&gt;'foo=bar&amp;amp;abc=xyz&amp;amp;abc=123'&lt;/code&gt; 은 다음과 같이 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="c4faa016c1fe90248554940ea2a901f2767764e1" translate="yes" xml:space="preserve">
          <source>For example, the value &lt;code&gt;'h2=&quot;example.org:81&quot;'&lt;/code&gt; indicates that the HTTP/2 protocol is available on the host &lt;code&gt;'example.org'&lt;/code&gt; on TCP/IP port 81. The host and port &lt;em&gt;must&lt;/em&gt; be contained within the quote (&lt;code&gt;&quot;&lt;/code&gt;) characters.</source>
          <target state="translated">예를 들어, 값 &lt;code&gt;'h2=&quot;example.org:81&quot;'&lt;/code&gt; 은 HTTP / 2 프로토콜이 TCP / IP 포트 81의 &lt;code&gt;'example.org'&lt;/code&gt; 호스트에서 사용 가능함을 나타냅니다 . 호스트 및 포트 &lt;em&gt;는&lt;/em&gt; 인용 부호 안에 포함되어야합니다. ( &lt;code&gt;&quot;&lt;/code&gt; ) 자</target>
        </trans-unit>
        <trans-unit id="f95e4eeabc8b5c5766a98b87237a905f5362fd09" translate="yes" xml:space="preserve">
          <source>For example, there could be one domain in use for an HTTP server, but perhaps we would like to have a separate domain to use for each request.</source>
          <target state="translated">예를 들어 HTTP 서버에 사용중인 도메인이 하나있을 수 있지만 각 요청에 사용할 별도의 도메인을 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c70aab1281bafc98591fb41a8a2e156b4733b83" translate="yes" xml:space="preserve">
          <source>For example, this is not a good idea:</source>
          <target state="translated">예를 들어, 이것은 좋은 생각이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e99d0e4483ca3b79ca406bdcee63685fc7db1e22" translate="yes" xml:space="preserve">
          <source>For example, to copy &lt;code&gt;process.stdin&lt;/code&gt; to &lt;code&gt;process.stdout&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;process.stdin&lt;/code&gt; 을 &lt;code&gt;process.stdout&lt;/code&gt; 에 복사 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="74c8c01fdcc407c4056c3c4c23fbc67e2bab6243" translate="yes" xml:space="preserve">
          <source>For example, to create a promise and pass it to an asynchronous worker:</source>
          <target state="translated">예를 들어, 약속을 작성하여 비동기 작업자에게 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="194be4aacd10dff8468a811071e79ccd2a5fd5f2" translate="yes" xml:space="preserve">
          <source>For example, to define a package that only has dual mode entry points for use in Node.js but not the browser:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df453f73e080d9b234f689c60388312d2911405c" translate="yes" xml:space="preserve">
          <source>For example, to reduce the default memory requirements from 256K to 128K, the options should be set to:</source>
          <target state="translated">예를 들어 기본 메모리 요구 사항을 256K에서 128K로 줄이려면 옵션을 다음과 같이 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b5a5c3485b1b24a59e97f7e53ad29c392af3458" translate="yes" xml:space="preserve">
          <source>For example, with a function that takes in &lt;code&gt;(foo, onSuccessCallback, onErrorCallback)&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;(foo, onSuccessCallback, onErrorCallback)&lt;/code&gt; 함수를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ae799d12f1b44275fbc0da9bcd67a2da1006e7c" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'#hash'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'#hash'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c86de8e00622a7747509a64e10a55fe34615d87b" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'/p/a/t/h'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'/p/a/t/h'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6e5f08123a700de002eb4d0e40657ba4c345591" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'/p/a/t/h?query=string'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'/p/a/t/h?query=string'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3bdbc1893285ae2bc6187853f472bb89b348832d" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'8080'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'8080'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b18a73507aef0be5082b6fdcfbb3d2764429f21c" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'?query=string'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'?query=string'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1431a97ff50bfe6b8c67eaa08445cc79d5cbf2cd" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'http:'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'http:'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e875c30c2bd795fb8f83356873fa8387d92e587" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'&lt;/code&gt;.</source>
          <target state="translated">예를 들면 &lt;code&gt;'http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="326379a1cda187f82e1710768f1264546688dc9d" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'query=string'&lt;/code&gt; or &lt;code&gt;{'query': 'string'}&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'query=string'&lt;/code&gt; 또는 &lt;code&gt;{'query': 'string'}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c80eba690887dc33a88b69fed72632e28fc2b10d" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'sub.example.com'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'sub.example.com'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e91a6553effbbe4dda469429f21b677db459ecb4" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'sub.example.com:8080'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'sub.example.com:8080'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30ac7f71aef57cd86825b42aad02544467fac9f1" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;'user:pass'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;'user:pass'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb56fd25c97e401b170d334578f71eec41d07444" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;{ name: 'AES256-SHA', version: 'TLSv1.2' }&lt;/code&gt;.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;{ name: 'AES256-SHA', version: 'TLSv1.2' }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ef9a1e93233f967d1e9c16153dffc3223c156f" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;{ type: 'ECDH', name: 'prime256v1', size: 256 }&lt;/code&gt;.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;{ type: 'ECDH', name: 'prime256v1', size: 256 }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88800ff5db7cf730ee7fea6074e752c847677a0e" translate="yes" xml:space="preserve">
          <source>For further information on &lt;code&gt;napi_create_external&lt;/code&gt;, refer to &lt;a href=&quot;n-api#n_api_napi_create_external&quot;&gt;&lt;code&gt;napi_create_external()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;napi_create_external&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;n-api#n_api_napi_create_external&quot;&gt; &lt;code&gt;napi_create_external()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ffd0ce6961facbf22f866f23a22e700aae1c9c0" translate="yes" xml:space="preserve">
          <source>For incoming headers:</source>
          <target state="translated">수신 헤더 :</target>
        </trans-unit>
        <trans-unit id="015b6275e1ee8dfd8d259a1e7dd30758f09835c4" translate="yes" xml:space="preserve">
          <source>For instance, changing from &lt;code&gt;http&lt;/code&gt; to &lt;code&gt;https&lt;/code&gt; works:</source>
          <target state="translated">예를 들어 &lt;code&gt;http&lt;/code&gt; 에서 &lt;code&gt;https&lt;/code&gt; 로 변경 하면 작동합니다.</target>
        </trans-unit>
        <trans-unit id="271858bddcffa7d0c42a54bdba61f9004a962156" translate="yes" xml:space="preserve">
          <source>For instance, consider the following JavaScript code snippet:</source>
          <target state="translated">예를 들어, 다음 JavaScript 코드 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8de3f2a74ab84a9ac2fd498796cb9fa9361c6fdb" translate="yes" xml:space="preserve">
          <source>For instance, the following example illustrates a &lt;em&gt;misuse&lt;/em&gt; of the &lt;code&gt;process.exit()&lt;/code&gt; method that could lead to data printed to stdout being truncated and lost:</source>
          <target state="translated">예를 들어, 다음 예제 는 stdout으로 인쇄 된 데이터가 잘리고 손실 될 수 있는 &lt;code&gt;process.exit()&lt;/code&gt; 메소드 의 &lt;em&gt;오용&lt;/em&gt; 을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="77ea46760578e2f2b62948845228f02c4dee3345" translate="yes" xml:space="preserve">
          <source>For instance: &lt;code&gt;[[substr1, substr2, ...], originalsubstring]&lt;/code&gt;.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;[[substr1, substr2, ...], originalsubstring]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c59bd509f789ff650135339c76dd7b0ac979c77a" translate="yes" xml:space="preserve">
          <source>For instance: a &lt;a href=&quot;net#net_class_net_server&quot;&gt;&lt;code&gt;net.Server&lt;/code&gt;&lt;/a&gt; object emits an event each time a peer connects to it; a &lt;a href=&quot;fs#fs_class_fs_readstream&quot;&gt;&lt;code&gt;fs.ReadStream&lt;/code&gt;&lt;/a&gt; emits an event when the file is opened; a &lt;a href=&quot;stream&quot;&gt;stream&lt;/a&gt; emits an event whenever data is available to be read.</source>
          <target state="translated">예를 들어 : &lt;a href=&quot;net#net_class_net_server&quot;&gt; &lt;code&gt;net.Server&lt;/code&gt; &lt;/a&gt; 객체는 피어가 연결할 때마다 이벤트를 생성합니다. &lt;a href=&quot;fs#fs_class_fs_readstream&quot;&gt; &lt;code&gt;fs.ReadStream&lt;/code&gt; 는&lt;/a&gt; 파일이 열릴 이벤트를 방출; &lt;a href=&quot;stream&quot;&gt;스트림&lt;/a&gt; 데이터를 읽을 수 있습니다 때마다 이벤트를 방출한다.</target>
        </trans-unit>
        <trans-unit id="bf4e14aa8f189b1217ccf2fcdbe7850069d1b53a" translate="yes" xml:space="preserve">
          <source>For key bindings related to the reverse-i-search, see &lt;a href=&quot;#repl_reverse_i_search&quot;&gt;&lt;code&gt;reverse-i-search&lt;/code&gt;&lt;/a&gt;. For all other key bindings, see &lt;a href=&quot;readline#readline_tty_keybindings&quot;&gt;TTY keybindings&lt;/a&gt;.</source>
          <target state="translated">역 I-검색 관련 키 바인딩을 참조 &lt;a href=&quot;#repl_reverse_i_search&quot;&gt; &lt;code&gt;reverse-i-search&lt;/code&gt; &lt;/a&gt; . 다른 모든 키 바인딩에 대해서는 &lt;a href=&quot;readline#readline_tty_keybindings&quot;&gt;TTY&lt;/a&gt; 키 바인딩을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90d4f2fe0ce5674f5975d3a9b7f2e779132cdc4d" translate="yes" xml:space="preserve">
          <source>For listeners attached using &lt;code&gt;.once()&lt;/code&gt; this returns the original listeners instead of wrapper functions now.</source>
          <target state="translated">&lt;code&gt;.once()&lt;/code&gt; 사용하여 연결된 리스너의 경우 이제 래퍼 함수 대신 원래 리스너를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12dd976275742ec5690cbcff1b48498bba5c82e7" translate="yes" xml:space="preserve">
          <source>For listeners attached using &lt;code&gt;.once()&lt;/code&gt;, the &lt;code&gt;listener&lt;/code&gt; argument now yields the original listener function.</source>
          <target state="translated">&lt;code&gt;.once()&lt;/code&gt; 사용하여 연결된 리스너의 경우 &lt;code&gt;listener&lt;/code&gt; 인수는 이제 원래 리스너 함수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5390feeb439b25ef7d23bf7036f6e833b5328267" translate="yes" xml:space="preserve">
          <source>For many simple cases, it is possible to construct a stream without relying on inheritance. This can be accomplished by directly creating instances of the &lt;code&gt;stream.Writable&lt;/code&gt;, &lt;code&gt;stream.Readable&lt;/code&gt;, &lt;code&gt;stream.Duplex&lt;/code&gt; or &lt;code&gt;stream.Transform&lt;/code&gt; objects and passing appropriate methods as constructor options.</source>
          <target state="translated">많은 간단한 경우에 상속에 의존하지 않고 스트림을 구성 할 수 있습니다. 이것은 직접 인스턴스를 생성하여 수행 할 수 있습니다 &lt;code&gt;stream.Writable&lt;/code&gt; , &lt;code&gt;stream.Readable&lt;/code&gt; , &lt;code&gt;stream.Duplex&lt;/code&gt; 또는 &lt;code&gt;stream.Transform&lt;/code&gt; 객체와 생성자 옵션으로 적절한 방법을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="38eb5cdac3322c36228aaedf283dbc3ef735948d" translate="yes" xml:space="preserve">
          <source>For many simple cases, it is possible to create a stream without relying on inheritance. This can be accomplished by directly creating instances of the &lt;code&gt;stream.Writable&lt;/code&gt;, &lt;code&gt;stream.Readable&lt;/code&gt;, &lt;code&gt;stream.Duplex&lt;/code&gt; or &lt;code&gt;stream.Transform&lt;/code&gt; objects and passing appropriate methods as constructor options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf6b17b8b3c132991ca261367a85c345bb8add2" translate="yes" xml:space="preserve">
          <source>For more details on building addon modules in general, refer to the existing API.</source>
          <target state="translated">일반적인 애드온 모듈 구축에 대한 자세한 내용은 기존 API를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="048f678cdb9d7b9304af334737ac3c0c98e0202e" translate="yes" xml:space="preserve">
          <source>For more details on setting properties on objects, see the section on &lt;a href=&quot;#n_api_working_with_javascript_properties&quot;&gt;Working with JavaScript Properties&lt;/a&gt;.</source>
          <target state="translated">객체의 속성 설정에 대한 자세한 내용은 &lt;a href=&quot;#n_api_working_with_javascript_properties&quot;&gt;JavaScript 속성 작업&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8219fba9950acfb6717ee1976a955e088f3627be" translate="yes" xml:space="preserve">
          <source>For more details on setting properties on objects, see the section on &lt;a href=&quot;#n_api_working_with_javascript_properties&quot;&gt;Working with JavaScript properties&lt;/a&gt;.</source>
          <target state="translated">객체의 속성 설정에 대한 자세한 내용은 &lt;a href=&quot;#n_api_working_with_javascript_properties&quot;&gt;JavaScript 속성 작업&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62febcf03c89fd8d13fb23c6c4f7af2e73d21726" translate="yes" xml:space="preserve">
          <source>For more details, review the &lt;a href=&quot;#n_api_object_lifetime_management&quot;&gt;Object Lifetime Management&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#n_api_object_lifetime_management&quot;&gt;객체 수명 관리를&lt;/a&gt; 검토하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d94baa4f22fb332eedc9418de44e0d1477591cb" translate="yes" xml:space="preserve">
          <source>For more details, review the &lt;a href=&quot;#n_api_object_lifetime_management&quot;&gt;Object lifetime management&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#n_api_object_lifetime_management&quot;&gt;개체 수명 관리를&lt;/a&gt; 검토하세요 .</target>
        </trans-unit>
        <trans-unit id="d65bf55841fd0a63bcc09c56c4b126efd1c94332" translate="yes" xml:space="preserve">
          <source>For more info about &lt;code&gt;node inspect&lt;/code&gt;, see the &lt;a href=&quot;debugger&quot;&gt;debugger&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;node inspect&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;debugger&quot;&gt;디버거&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="4b4362c9db6fa952f739e6dd9663dfe4a36d653f" translate="yes" xml:space="preserve">
          <source>For more information on the serialization and deserialization mechanisms behind this API, see the &lt;a href=&quot;v8#v8_serialization_api&quot;&gt;serialization API of the &lt;code&gt;v8&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">이 API의 직렬화 및 역 직렬화 메커니즘에 대한 자세한 정보 &lt;a href=&quot;v8#v8_serialization_api&quot;&gt;는 &lt;code&gt;v8&lt;/code&gt; 모듈&lt;/a&gt; 의 직렬화 API를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e952f5b7997183488314ca0ac63d1a60975dc542" translate="yes" xml:space="preserve">
          <source>For more verbose tests for &lt;code&gt;Intl&lt;/code&gt; support, the following resources may be found to be helpful:</source>
          <target state="translated">&lt;code&gt;Intl&lt;/code&gt; 지원에 대한보다 자세한 테스트를 위해 다음 리소스가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecd2609711f87d3a858227a0c7f59cff0e8ea6a1" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;fs&lt;/code&gt; module functions, the &lt;code&gt;path&lt;/code&gt; or &lt;code&gt;filename&lt;/code&gt; argument may be passed as a WHATWG &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; object. Only &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; objects using the &lt;code&gt;file:&lt;/code&gt; protocol are supported.</source>
          <target state="translated">대부분의 &lt;code&gt;fs&lt;/code&gt; 모듈 함수의 경우 &lt;code&gt;path&lt;/code&gt; 또는 &lt;code&gt;filename&lt;/code&gt; 인수가 WHATWG &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 객체 로 전달 될 수 있습니다 . &lt;code&gt;file:&lt;/code&gt; 프로토콜을 사용하는 &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 객체 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d0aee94b121d9c05cc7446b9819d27a13b48f781" translate="yes" xml:space="preserve">
          <source>For now, only modules using the &lt;code&gt;file:&lt;/code&gt; protocol can be loaded.</source>
          <target state="translated">현재는 &lt;code&gt;file:&lt;/code&gt; 프로토콜을 사용하는 모듈 만 로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d3837a578ca8fc06375081c29c6859c0119cb9" translate="yes" xml:space="preserve">
          <source>For objects that support &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;, returns &lt;code&gt;Buffer.from(object[Symbol.toPrimitive]('string'), offsetOrEncoding)&lt;/code&gt;.</source>
          <target state="translated">지원하는 개체의 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 반환 &lt;code&gt;Buffer.from(object[Symbol.toPrimitive]('string'), offsetOrEncoding)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4ab566ef7a83d33b552404e3d4411d9267581f" translate="yes" xml:space="preserve">
          <source>For objects that support &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;, returns &lt;code&gt;Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 를 지원하는 객체의 경우 &lt;code&gt;Buffer.from(object[Symbol.toPrimitive](), offsetOrEncoding, length)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="39a3ab913b459b47836eb75d147bf2460ed81971" translate="yes" xml:space="preserve">
          <source>For objects whose &lt;code&gt;valueOf()&lt;/code&gt; function returns a value not strictly equal to &lt;code&gt;object&lt;/code&gt;, returns &lt;code&gt;Buffer.from(object.valueOf(), offsetOrEncoding, length)&lt;/code&gt;.</source>
          <target state="translated">그 객체 &lt;code&gt;valueOf()&lt;/code&gt; 함수의 리턴 값이 엄격하게 동일한 &lt;code&gt;object&lt;/code&gt; 반품 &lt;code&gt;Buffer.from(object.valueOf(), offsetOrEncoding, length)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d27b2b2f9bee7e6af8345826cc4bafbe24351894" translate="yes" xml:space="preserve">
          <source>For other LTS Release Codenames, see &lt;a href=&quot;https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_ARCHIVE.md&quot;&gt;Node.js Changelog Archive&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2b1b1cde7b3e65cf44d7b42ab3295a7c2a5ff9" translate="yes" xml:space="preserve">
          <source>For packages with a small number of exports or imports, we recommend explicitly listing each exports subpath entry. But for packages that have large numbers of subpaths, this might cause &lt;code&gt;package.json&lt;/code&gt; bloat and maintenance issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196376ca4658d4a04273a684e12bfd5930516772" translate="yes" xml:space="preserve">
          <source>For private keys, the following encoding options can be used:</source>
          <target state="translated">개인 키의 경우 다음 인코딩 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c31e69fc6ccede8b8e14bfc7cbefe3fb86771aea" translate="yes" xml:space="preserve">
          <source>For public keys, the following encoding options can be used:</source>
          <target state="translated">공개 키의 경우 다음 인코딩 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12757b9f92a1aa99a7a1d18244e653d9f9e551d" translate="yes" xml:space="preserve">
          <source>For secret keys, this property represents the size of the key in bytes. This property is &lt;code&gt;undefined&lt;/code&gt; for asymmetric keys.</source>
          <target state="translated">비밀 키의 경우이 속성은 키 크기를 바이트 단위로 나타냅니다. 이 속성은 비대칭 키에 대해서는 &lt;code&gt;undefined&lt;/code&gt; 되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0d2efe942d5607b891af1a56f27f96d135db39" translate="yes" xml:space="preserve">
          <source>For some headers, such as &lt;code&gt;Authorization&lt;/code&gt; and short &lt;code&gt;Cookie&lt;/code&gt; headers, this flag is set automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9641c5ddc18ec715361923bbf6bb46c068e3f6a" translate="yes" xml:space="preserve">
          <source>For streams not operating in object mode, if the &lt;code&gt;chunk&lt;/code&gt; parameter of &lt;code&gt;readable.push()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, it will be treated as empty string or buffer. See &lt;a href=&quot;#stream_readable_push&quot;&gt;&lt;code&gt;readable.push('')&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">객체 모드에서 작동하지 않는 스트림의 경우 &lt;code&gt;readable.push()&lt;/code&gt; 의 &lt;code&gt;chunk&lt;/code&gt; 매개 변수 가 &lt;code&gt;undefined&lt;/code&gt; 인 경우 빈 문자열 또는 버퍼로 처리됩니다. 자세한 내용은 &lt;a href=&quot;#stream_readable_push&quot;&gt; &lt;code&gt;readable.push('')&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b263c0395c776ff1e910343334f54923c680ff1" translate="yes" xml:space="preserve">
          <source>For symmetric keys, this function allocates a &lt;code&gt;Buffer&lt;/code&gt; containing the key material and ignores any options.</source>
          <target state="translated">대칭 키의 경우이 기능 은 키 자료를 포함 하는 &lt;code&gt;Buffer&lt;/code&gt; 를 할당하고 옵션을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2a8f3f3978741f8f464f09eec486ef97895e91e5" translate="yes" xml:space="preserve">
          <source>For the promisified variants of &lt;a href=&quot;timers#timers_setimmediate_callback_args&quot;&gt;&lt;code&gt;setImmediate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timers#timers_settimeout_callback_delay_args&quot;&gt;&lt;code&gt;setTimeout()&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;globals#globals_class_abortcontroller&quot;&gt;&lt;code&gt;AbortController&lt;/code&gt;&lt;/a&gt; may be used to cancel the timer. When canceled, the returned Promises will be rejected with an &lt;code&gt;'AbortError'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ddc77c7268f543a5e426ef09ac7cfb57c404d50" translate="yes" xml:space="preserve">
          <source>For these use cases, subpath export patterns can be used instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd60fbcc07ae08d935aca50b8141e2dff8f12bcc" translate="yes" xml:space="preserve">
          <source>For wrapped objects it may be difficult to distinguish between a function called on a class prototype and a function called on an instance of a class. A common pattern used to address this problem is to save a persistent reference to the class constructor for later &lt;code&gt;instanceof&lt;/code&gt; checks.</source>
          <target state="translated">랩핑 된 객체의 경우 클래스 프로토 타입에서 호출 된 함수와 클래스 인스턴스에서 호출 된 함수를 구별하기 어려울 수 있습니다. 이 문제를 해결하는 데 사용되는 일반적인 패턴은 나중에 검사 할 &lt;code&gt;instanceof&lt;/code&gt; 를 위해 클래스 생성자에 대한 지속적 참조를 저장하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fe72bacdc1a0a3fbd24699c40c550c6a0d21a15e" translate="yes" xml:space="preserve">
          <source>For zlib-based streams</source>
          <target state="translated">zlib 기반 스트림</target>
        </trans-unit>
        <trans-unit id="7758b0cb08acdedaecd144d42644989705ebf51f" translate="yes" xml:space="preserve">
          <source>Force FIPS-compliant crypto on startup. (Cannot be disabled from script code.) (Same requirements as &lt;code&gt;--enable-fips&lt;/code&gt;.)</source>
          <target state="translated">시작시 FIPS 호환 암호화를 강제 실행하십시오. (스크립트 코드에서 비활성화 할 수 없습니다.) &lt;code&gt;--enable-fips&lt;/code&gt; 와 동일한 요구 사항 입니다.</target>
        </trans-unit>
        <trans-unit id="8bdd88bbd6613f0ebc8fc2fe8651e4c3c2551856" translate="yes" xml:space="preserve">
          <source>Foreground colors</source>
          <target state="translated">전경색</target>
        </trans-unit>
        <trans-unit id="4e6e2386ff55d783bd9886b8a6560092cabcb1bf" translate="yes" xml:space="preserve">
          <source>Former use cases relying on &lt;code&gt;require.resolve&lt;/code&gt; to determine the resolved path of a module can be supported via &lt;code&gt;import.meta.resolve&lt;/code&gt;, which is experimental and supported via the &lt;code&gt;--experimental-import-meta-resolve&lt;/code&gt; flag:</source>
          <target state="translated">모듈의 확인 된 경로를 결정하기 위해 &lt;code&gt;require.resolve&lt;/code&gt; 에 의존했던 이전 사용 사례 는 &lt;code&gt;import.meta.resolve&lt;/code&gt; 를 통해 지원 될 수 있습니다 . 이는 실험적이며 &lt;code&gt;--experimental-import-meta-resolve&lt;/code&gt; 플래그 를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b4c929e366de15753f76b22420b7a35256c2ffa" translate="yes" xml:space="preserve">
          <source>Forward one character</source>
          <target state="translated">한 문자 앞으로</target>
        </trans-unit>
        <trans-unit id="3f7db64b36cb48a5ead37108e5190bb1cb147353" translate="yes" xml:space="preserve">
          <source>Frame Size Error</source>
          <target state="translated">프레임 크기 오류</target>
        </trans-unit>
        <trans-unit id="333d0c70190b8e2c3cb1c4017702839184a1fdcc" translate="yes" xml:space="preserve">
          <source>Frames are only generated for JavaScript functions. If, for example, execution synchronously passes through a C++ addon function called &lt;code&gt;cheetahify&lt;/code&gt; which itself calls a JavaScript function, the frame representing the &lt;code&gt;cheetahify&lt;/code&gt; call will not be present in the stack traces:</source>
          <target state="translated">프레임은 JavaScript 함수에 대해서만 생성됩니다. 예를 들어, 실행 이 자체적으로 JavaScript 함수를 호출하는 &lt;code&gt;cheetahify&lt;/code&gt; 라는 C ++ 애드온 함수를 동 기적으로 전달 하면 &lt;code&gt;cheetahify&lt;/code&gt; 를 나타내는 프레임 호출을 이 스택 추적에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5132d73ca8d010c5fc4d92deadcf69094f940002" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;zlib/zconf.h&lt;/code&gt;, modified for Node.js usage:</source>
          <target state="translated">에서 &lt;code&gt;zlib/zconf.h&lt;/code&gt; , Node.js를 사용에 대한 수정 :</target>
        </trans-unit>
        <trans-unit id="a76a4194d0fdb22daa95831f66851b1b3ddac7b0" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;zlib/zconf.h&lt;/code&gt;, modified to Node.js's usage:</source>
          <target state="translated">에서 &lt;code&gt;zlib/zconf.h&lt;/code&gt; , Node.js를의 사용과 수정 :</target>
        </trans-unit>
        <trans-unit id="c74409dbf97fc00637d09c29d6300330ac26ce15" translate="yes" xml:space="preserve">
          <source>From the perspective of a native addon this means that the bindings it provides may be called multiple times, from multiple contexts, and even concurrently from multiple threads.</source>
          <target state="translated">네이티브 애드온의 관점에서 이것은 바인딩이 제공하는 바인딩이 여러 번, 여러 컨텍스트에서, 심지어 여러 스레드에서 동시에 호출 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7a605a56e2cdcdebd5e329a93e319622341b36f7" translate="yes" xml:space="preserve">
          <source>Function arguments</source>
          <target state="translated">함수 인수</target>
        </trans-unit>
        <trans-unit id="993dd96d93bbdf9a74fd4898e6fcf68d7b3f10bb" translate="yes" xml:space="preserve">
          <source>Function factory</source>
          <target state="translated">기능 공장</target>
        </trans-unit>
        <trans-unit id="ec5a7f09a1e8ef3b422abd91ceca943a4a3ab7df" translate="yes" xml:space="preserve">
          <source>Function pointer type for add-on provided functions that allow the user to be notified when externally-owned data is ready to be cleaned up because the object with which it was associated with, has been garbage-collected. The user must provide a function satisfying the following signature which would get called upon the object's collection. Currently, &lt;code&gt;napi_finalize&lt;/code&gt; can be used for finding out when objects that have external data are collected.</source>
          <target state="translated">추가 기능에 대한 함수 포인터 유형은 연결된 개체가 가비지 수집되어 외부 소유 데이터를 정리할 준비가되었을 때 사용자에게 알릴 수있는 기능을 제공했습니다. 사용자는 오브젝트의 콜렉션에서 호출 될 다음 서명을 만족시키는 기능을 제공해야합니다. 현재 &lt;code&gt;napi_finalize&lt;/code&gt; 는 외부 데이터가있는 개체가 수집되는시기를 찾는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f6bbd08fb84a42ff48f50954929b61f3a27bdd1" translate="yes" xml:space="preserve">
          <source>Function pointer type for user-provided native functions which are to be exposed to JavaScript via N-API. Callback functions should satisfy the following signature:</source>
          <target state="translated">N-API를 통해 JavaScript에 노출되는 사용자 제공 원시 함수에 대한 함수 포인터 유형입니다. 콜백 함수는 다음 서명을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="64bc8def25592142360181bc180b51628e1a2ec6" translate="yes" xml:space="preserve">
          <source>Function pointer used with &lt;a href=&quot;#n_api_napi_add_async_cleanup_hook&quot;&gt;&lt;code&gt;napi_add_async_cleanup_hook&lt;/code&gt;&lt;/a&gt;. It will be called when the environment is being torn down.</source>
          <target state="translated">&lt;a href=&quot;#n_api_napi_add_async_cleanup_hook&quot;&gt; &lt;code&gt;napi_add_async_cleanup_hook&lt;/code&gt; &lt;/a&gt; 과 함께 사용되는 함수 포인터 . 환경이 파괴 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc492b0639005eacef46c445e2cbda28e7bde17" translate="yes" xml:space="preserve">
          <source>Function pointer used with asynchronous thread-safe function calls. The callback will be called on the main thread. Its purpose is to use a data item arriving via the queue from one of the secondary threads to construct the parameters necessary for a call into JavaScript, usually via &lt;code&gt;napi_call_function&lt;/code&gt;, and then make the call into JavaScript.</source>
          <target state="translated">비동기 스레드 안전 함수 호출과 함께 사용되는 함수 포인터. 기본 스레드에서 콜백이 호출됩니다. 그 목적은 보조 스레드 중 하나에서 큐를 통해 도착하는 데이터 항목을 사용하여 JavaScript 호출에 필요한 매개 변수를 구성하는 것입니다 (보통 &lt;code&gt;napi_call_function&lt;/code&gt; 사용). 다음 호출을 JavaScript로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="599595a9fdcd3063f28e8ae0d1e237aa707ed504" translate="yes" xml:space="preserve">
          <source>Function pointer used with functions that support asynchronous operations. Callback functions must satisfy the following signature:</source>
          <target state="translated">비동기 작업을 지원하는 함수와 함께 사용되는 함수 포인터. 콜백 함수는 다음 서명을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="37eb1cf9b1611f8cdc3c660067c4a09fc1e21c31" translate="yes" xml:space="preserve">
          <source>Function was called within a &lt;a href=&quot;process#Event:-%60'exit'%60&quot;&gt;&lt;code&gt;process.on('exit')&lt;/code&gt;&lt;/a&gt; handler that shouldn't be called within &lt;a href=&quot;process#Event:-%60'exit'%60&quot;&gt;&lt;code&gt;process.on('exit')&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">기능은 내에서 호출 된 &lt;a href=&quot;process#Event:-%60'exit'%60&quot;&gt; &lt;code&gt;process.on('exit')&lt;/code&gt; &lt;/a&gt; 내에서 호출 할 수 없습니다 핸들러 &lt;a href=&quot;process#Event:-%60'exit'%60&quot;&gt; &lt;code&gt;process.on('exit')&lt;/code&gt; &lt;/a&gt; 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="7964d22a59f5fcc5efede2d81c68f063b79d7282" translate="yes" xml:space="preserve">
          <source>Functionalities that only require the ICU library itself, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize&quot;&gt;&lt;code&gt;String.prototype.normalize()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;WHATWG URL parser&lt;/a&gt;, are fully supported under &lt;code&gt;small-icu&lt;/code&gt;. Features that require ICU locale data in addition, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat&quot;&gt;&lt;code&gt;Intl.DateTimeFormat&lt;/code&gt;&lt;/a&gt;, generally only work with the English locale:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize&quot;&gt; &lt;code&gt;String.prototype.normalize()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;WHATWG URL 파서&lt;/a&gt; 와 같이 ICU 라이브러리 자체 만 필요한 기능은 &lt;code&gt;small-icu&lt;/code&gt; 에서 완전히 지원됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat&quot;&gt; &lt;code&gt;Intl.DateTimeFormat&lt;/code&gt; &lt;/a&gt; 과 같이 ICU 로캘 데이터가 필요한 기능 일반적으로 영어 로캘에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3af5b7dcf7212050b3c0d6a9cc548227069312e0" translate="yes" xml:space="preserve">
          <source>Functionalities that only require the ICU library itself, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize&quot;&gt;&lt;code&gt;String.prototype.normalize()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;WHATWG URL parser&lt;/a&gt;, are fully supported under &lt;code&gt;system-icu&lt;/code&gt;. Features that require ICU locale data in addition, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat&quot;&gt;&lt;code&gt;Intl.DateTimeFormat&lt;/code&gt;&lt;/a&gt;&lt;em&gt;may&lt;/em&gt; be fully or partially supported, depending on the completeness of the ICU data installed on the system.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize&quot;&gt; &lt;code&gt;String.prototype.normalize()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;WHATWG URL 파서&lt;/a&gt; 와 같이 ICU 라이브러리 자체 만 필요한 기능은 &lt;code&gt;system-icu&lt;/code&gt; 에서 완전히 지원됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat&quot;&gt; &lt;code&gt;Intl.DateTimeFormat&lt;/code&gt; &lt;/a&gt; 과 같이 ICU 로캘 데이터가 추가로 필요한 기능 은 시스템에 설치된 ICU 데이터의 완전성에 따라 완전히 또는 부분적으로 지원 &lt;em&gt;될 수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="af4222c3289bb32c1f1824b1c43727481175c73d" translate="yes" xml:space="preserve">
          <source>Functions based on &lt;code&gt;fs.open()&lt;/code&gt; exhibit this behavior as well: &lt;code&gt;fs.writeFile()&lt;/code&gt;, &lt;code&gt;fs.readFile()&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;fs.open()&lt;/code&gt; 기반 함수 는이 동작도 나타냅니다 : &lt;code&gt;fs.writeFile()&lt;/code&gt; , &lt;code&gt;fs.readFile()&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="d639d5948d45cf53034fa5bb18a5e3f51824cdfe" translate="yes" xml:space="preserve">
          <source>Functions to convert from C types to N-API</source>
          <target state="translated">C 타입에서 N-API로 변환하는 함수</target>
        </trans-unit>
        <trans-unit id="6b2d12745e2e915ec380d5a20817a9e69c8f53b1" translate="yes" xml:space="preserve">
          <source>Functions to convert from N-API to C types</source>
          <target state="translated">N-API에서 C 유형으로 변환하는 함수</target>
        </trans-unit>
        <trans-unit id="cb1aa769905304dd687caa842e65229bd0139a1f" translate="yes" xml:space="preserve">
          <source>Functions to get global instances</source>
          <target state="translated">전역 인스턴스를 가져 오는 함수</target>
        </trans-unit>
        <trans-unit id="3f8f8fa4da509ca87fe1fc6ab145d779f586910f" translate="yes" xml:space="preserve">
          <source>Fundamentally, these APIs are used to do one of the following:</source>
          <target state="translated">기본적으로 이러한 API는 다음 중 하나를 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b70f7f5f0e5e2c6bebca28cd6a14886b0ba34dad" translate="yes" xml:space="preserve">
          <source>Fundamentally, these APIs are used to do one of the following: 1. Create a new JavaScript object 2. Convert from a primitive C type to an N-API value 3. Convert from N-API value to a primitive C type 4. Get global instances including &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">기본적으로이 API는 다음 중 하나를 수행하는 데 사용됩니다. 1. 새 JavaScript 객체 생성 2. 기본 C 유형에서 N-API 값으로 변환 3. N-API 값에서 기본 C 유형으로 변환 4. 가져 오기 &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 을 포함한 전역 인스턴스</target>
        </trans-unit>
        <trans-unit id="9431231cf63ba365f4794647b56c6dc1799c5188" translate="yes" xml:space="preserve">
          <source>Furthermore, to make the module lookup process even more optimal, rather than putting packages directly in &lt;code&gt;/usr/lib/node&lt;/code&gt;, we could put them in &lt;code&gt;/usr/lib/node_modules/&amp;lt;name&amp;gt;/&amp;lt;version&amp;gt;&lt;/code&gt;. Then Node.js will not bother looking for missing dependencies in &lt;code&gt;/usr/node_modules&lt;/code&gt; or &lt;code&gt;/node_modules&lt;/code&gt;.</source>
          <target state="translated">또한 패키지를 &lt;code&gt;/usr/lib/node&lt;/code&gt; 에 직접 넣지 않고 모듈 조회 프로세스를 더욱 최적화하기 위해 &lt;code&gt;/usr/lib/node_modules/&amp;lt;name&amp;gt;/&amp;lt;version&amp;gt;&lt;/code&gt; 에 넣을 수 있습니다 . 그러면 Node.js는 &lt;code&gt;/usr/node_modules&lt;/code&gt; 또는 &lt;code&gt;/node_modules&lt;/code&gt; 에서 누락 된 종속성을 찾지 않아도됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="00c4921f2442905582c51174e07820023b7887b4" translate="yes" xml:space="preserve">
          <source>Generally, an &lt;code&gt;ArrayBuffer&lt;/code&gt; is non-detachable if it has been detached before. The engine may impose additional conditions on whether an &lt;code&gt;ArrayBuffer&lt;/code&gt; is detachable. For example, V8 requires that the &lt;code&gt;ArrayBuffer&lt;/code&gt; be external, that is, created with &lt;a href=&quot;#n_api_napi_create_external_arraybuffer&quot;&gt;&lt;code&gt;napi_create_external_arraybuffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;ArrayBuffer&lt;/code&gt; 는 이전에 분리 된 경우 분리 할 수 ​​없습니다. 엔진은 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 분리 가능한지 여부에 대한 추가 조건을 부과 할 수 있습니다 . 예를 들어, V8에서는 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 외부, 즉 napi_create_external_arraybuffer 로 생성 &lt;a href=&quot;#n_api_napi_create_external_arraybuffer&quot;&gt; &lt;code&gt;napi_create_external_arraybuffer&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bcde9c22c0f6fcf332c79f17237db4140e32e18b" translate="yes" xml:space="preserve">
          <source>Generate V8 profiler output.</source>
          <target state="translated">V8 프로파일 러 출력을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="28e72539a254b50376120d97739ce35acef6675a" translate="yes" xml:space="preserve">
          <source>Generates a heap snapshot each time the process receives the specified signal. &lt;code&gt;signal&lt;/code&gt; must be a valid signal name. Disabled by default.</source>
          <target state="translated">프로세스가 지정된 신호를 수신 할 때마다 힙 스냅 샷을 생성합니다. &lt;code&gt;signal&lt;/code&gt; 은 유효한 신호 이름이어야합니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8414494901013cf6abd1e8bca004e06c01bbf9" translate="yes" xml:space="preserve">
          <source>Generates a new asymmetric key pair of the given &lt;code&gt;type&lt;/code&gt;. RSA, DSA, EC, Ed25519 and Ed448 are currently supported.</source>
          <target state="translated">지정된 &lt;code&gt;type&lt;/code&gt; 의 새로운 비대칭 키 페어를 생성합니다 . RSA, DSA, EC, Ed25519 및 Ed448이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="537dba8df51eb92cfa8ee1f469fc8ec225e058a5" translate="yes" xml:space="preserve">
          <source>Generates a new asymmetric key pair of the given &lt;code&gt;type&lt;/code&gt;. RSA, DSA, EC, Ed25519, Ed448, X25519, X448, and DH are currently supported.</source>
          <target state="translated">지정된 &lt;code&gt;type&lt;/code&gt; 의 새 비대칭 키 쌍을 생성합니다 . RSA, DSA, EC, Ed25519, Ed448, X25519, X448 및 DH가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="83b586516a8c546d7c129a26589b417da1bdfc1f" translate="yes" xml:space="preserve">
          <source>Generates a snapshot of the current V8 heap and returns a Readable Stream that may be used to read the JSON serialized representation. This JSON stream format is intended to be used with tools such as Chrome DevTools. The JSON schema is undocumented and specific to the V8 engine, and may change from one version of V8 to the next.</source>
          <target state="translated">현재 V8 힙의 스냅 샷을 생성하고 JSON 직렬화 된 표현을 읽는 데 사용할 수있는 읽기 가능한 스트림을 리턴합니다. 이 JSON 스트림 형식은 Chrome DevTools와 같은 도구와 함께 사용하기위한 것입니다. JSON 스키마는 문서화되지 않았으며 V8 엔진에 따라 다르며 V8 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91905a4b57c336d66d2bdf1b26e5dac8937b997" translate="yes" xml:space="preserve">
          <source>Generates a snapshot of the current V8 heap and returns a Readable Stream that may be used to read the JSON serialized representation. This JSON stream format is intended to be used with tools such as Chrome DevTools. The JSON schema is undocumented and specific to the V8 engine. Therefore, the schema may change from one version of V8 to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9252ad8696289e2a967e228e69921690ca5d2b80" translate="yes" xml:space="preserve">
          <source>Generates a snapshot of the current V8 heap and writes it to a JSON file. This file is intended to be used with tools such as Chrome DevTools. The JSON schema is undocumented and specific to the V8 engine, and may change from one version of V8 to the next.</source>
          <target state="translated">현재 V8 힙의 스냅 샷을 생성하여 JSON 파일에 씁니다. 이 파일은 Chrome DevTools와 같은 도구와 함께 사용하기위한 것입니다. JSON 스키마는 문서화되지 않았으며 V8 엔진에 따라 다르며 V8 버전마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8042318054979101a6bb3a3e52a4426bd1a01e8e" translate="yes" xml:space="preserve">
          <source>Generates cryptographically strong pseudo-random data. The &lt;code&gt;size&lt;/code&gt; argument is a number indicating the number of bytes to generate.</source>
          <target state="translated">암호화 적으로 강력한 의사 난수 데이터를 생성합니다. &lt;code&gt;size&lt;/code&gt; 인수는 생성하는 바이트 수를 나타내는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="4db498c2251f09e2ab090049609182fdaab60067" translate="yes" xml:space="preserve">
          <source>Generates cryptographically strong random values. The given &lt;code&gt;typedArray&lt;/code&gt; is filled with random values, and a reference to &lt;code&gt;typedArray&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1def4238b0303604ad14681f55ec2c047a99ea" translate="yes" xml:space="preserve">
          <source>Generates private and public Diffie-Hellman key values, and returns the public key in the specified &lt;code&gt;encoding&lt;/code&gt;. This key should be transferred to the other party. If &lt;code&gt;encoding&lt;/code&gt; is provided a string is returned; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">개인 및 공개 Diffie-Hellman 키 값을 생성하고 지정된 &lt;code&gt;encoding&lt;/code&gt; 공개 키를 리턴합니다 . 이 키는 상대방에게 양도해야합니다. 경우 &lt;code&gt;encoding&lt;/code&gt; 제공되는 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1c46f03d5b840f015caf47a97b09bb9a6d45e875" translate="yes" xml:space="preserve">
          <source>Generates private and public EC Diffie-Hellman key values, and returns the public key in the specified &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt;. This key should be transferred to the other party.</source>
          <target state="translated">개인 및 공개 EC Diffie-Hellman 키 값을 생성하고 지정된 &lt;code&gt;format&lt;/code&gt; 및 &lt;code&gt;encoding&lt;/code&gt; 으로 공개 키를 반환합니다 . 이 키는 상대방에게 양도해야합니다.</target>
        </trans-unit>
        <trans-unit id="112ec9f89c94053c72eaeec02eadd15823d03a79" translate="yes" xml:space="preserve">
          <source>Generates six random characters to be appended behind a required &lt;code&gt;prefix&lt;/code&gt; to create a unique temporary directory. Due to platform inconsistencies, avoid trailing &lt;code&gt;X&lt;/code&gt; characters in &lt;code&gt;prefix&lt;/code&gt;. Some platforms, notably the BSDs, can return more than six random characters, and replace trailing &lt;code&gt;X&lt;/code&gt; characters in &lt;code&gt;prefix&lt;/code&gt; with random characters.</source>
          <target state="translated">고유 한 임시 디렉토리를 작성하기 위해 필수 &lt;code&gt;prefix&lt;/code&gt; 뒤에 6 개의 임의 문자를 추가합니다 . 플랫폼 불일치로 인해 &lt;code&gt;prefix&lt;/code&gt; 뒤에 &lt;code&gt;X&lt;/code&gt; 문자를 사용 하지 마십시오 . BSD와 같은 일부 플랫폼은 6 개 이상의 임의 문자를 반환 하고 &lt;code&gt;prefix&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 문자 를 임의 문자로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50b6838f4aa9e4602c905096a32cfb19bcd8173a" translate="yes" xml:space="preserve">
          <source>Generating V8 snapshots takes time and memory (both memory managed by the V8 heap and native memory outside the V8 heap). The bigger the heap is, the more resources it needs. Node.js will adjust the V8 heap to accommondate the additional V8 heap memory overhead, and try its best to avoid using up all the memory avialable to the process. When the process uses more memory than the system deems appropriate, the process may be terminated abruptly by the system, depending on the system configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df38ba113791510e02f0b0272cda55269e8b1c3" translate="yes" xml:space="preserve">
          <source>Generating keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761f1a9e4f4d22dd8635a8dbf3a5cf7ac00d865b" translate="yes" xml:space="preserve">
          <source>Get a unique name for a set of request options, to determine whether a connection can be reused. For an HTTP agent, this returns &lt;code&gt;host:port:localAddress&lt;/code&gt; or &lt;code&gt;host:port:localAddress:family&lt;/code&gt;. For an HTTPS agent, the name includes the CA, cert, ciphers, and other HTTPS/TLS-specific options that determine socket reusability.</source>
          <target state="translated">연결을 재사용 할 수 있는지 여부를 판별하기 위해 요청 옵션 세트의 고유 이름을 가져옵니다. HTTP 에이전트의 경우 &lt;code&gt;host:port:localAddress&lt;/code&gt; 또는 &lt;code&gt;host:port:localAddress:family&lt;/code&gt; 를 리턴 합니다 . HTTPS 에이전트의 경우이 이름에는 소켓 재사용 성을 결정하는 CA, 인증서, 암호 및 기타 HTTPS / TLS 관련 옵션이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3780aac9665f60eae1f37cf32bf67978da6ceb" translate="yes" xml:space="preserve">
          <source>Get global instances including &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 을 포함한 전역 인스턴스 가져 오기</target>
        </trans-unit>
        <trans-unit id="b09eeb13f193e3ae59b33a0b658953d55cdb9b4b" translate="yes" xml:space="preserve">
          <source>Get information about the context in which the callback was invoked.</source>
          <target state="translated">콜백이 호출 된 컨텍스트에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a118bb6557c8f257122a10913093f916497c2c2a" translate="yes" xml:space="preserve">
          <source>Get the arguments passed into the callback.</source>
          <target state="translated">콜백에 전달 된 인수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8f60d44bd72ead1d05680199b7cc03269a3750b0" translate="yes" xml:space="preserve">
          <source>Gets and sets the fragment portion of the URL.</source>
          <target state="translated">URL의 조각 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="125c6d7b1d082be21dbcac6f3d4cb94a4b42c7eb" translate="yes" xml:space="preserve">
          <source>Gets and sets the host name portion of the URL. The key difference between &lt;code&gt;url.host&lt;/code&gt; and &lt;code&gt;url.hostname&lt;/code&gt; is that &lt;code&gt;url.hostname&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; include the port.</source>
          <target state="translated">URL의 호스트 이름 부분을 가져오고 설정합니다. 주요 차이점 &lt;code&gt;url.host&lt;/code&gt; 및 &lt;code&gt;url.hostname&lt;/code&gt; 는 점이다 &lt;code&gt;url.hostname&lt;/code&gt; 가 않습니다 &lt;em&gt;하지&lt;/em&gt; 포트를 포함한다.</target>
        </trans-unit>
        <trans-unit id="869f7a80c02184fc0dca0832b3a470dc1aefb8a1" translate="yes" xml:space="preserve">
          <source>Gets and sets the host portion of the URL.</source>
          <target state="translated">URL의 호스트 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d91766529908cc65cdc84cce450a51bb66b9825e" translate="yes" xml:space="preserve">
          <source>Gets and sets the hostname portion of the URL. The key difference between &lt;code&gt;url.host&lt;/code&gt; and &lt;code&gt;url.hostname&lt;/code&gt; is that &lt;code&gt;url.hostname&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; include the port.</source>
          <target state="translated">URL의 호스트 이름 부분을 가져오고 설정합니다. 주요 차이점 &lt;code&gt;url.host&lt;/code&gt; 및 &lt;code&gt;url.hostname&lt;/code&gt; 는 점이다 &lt;code&gt;url.hostname&lt;/code&gt; 가 않습니다 &lt;em&gt;하지&lt;/em&gt; 포트를 포함한다.</target>
        </trans-unit>
        <trans-unit id="435bf65c246a2f6d454ee3b74918f156c257edc9" translate="yes" xml:space="preserve">
          <source>Gets and sets the password portion of the URL.</source>
          <target state="translated">URL의 비밀번호 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="549880df821aadf8b2109c55bc62b773d21f658f" translate="yes" xml:space="preserve">
          <source>Gets and sets the path portion of the URL.</source>
          <target state="translated">URL의 경로 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9e66f4502bfc4d266ba11a26208355dd8dee1fc5" translate="yes" xml:space="preserve">
          <source>Gets and sets the port portion of the URL.</source>
          <target state="translated">URL의 포트 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9c6f5f9722f21599fb9d10d2b13bf6afe12c0be8" translate="yes" xml:space="preserve">
          <source>Gets and sets the protocol portion of the URL.</source>
          <target state="translated">URL의 프로토콜 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e2a068947ada10ff8415b1f0a99c1458d7e8ac42" translate="yes" xml:space="preserve">
          <source>Gets and sets the serialized URL.</source>
          <target state="translated">직렬화 된 URL을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="38a5d7386ed10cf65f072100b54a680fe0f9fd33" translate="yes" xml:space="preserve">
          <source>Gets and sets the serialized query portion of the URL.</source>
          <target state="translated">URL의 직렬화 된 쿼리 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f34ab704a12cd0ef99be499eda1ab1ec475f9e1a" translate="yes" xml:space="preserve">
          <source>Gets and sets the username portion of the URL.</source>
          <target state="translated">URL의 사용자 이름 부분을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="237f51c60347aa23bb031bf940d888d31190dcf7" translate="yes" xml:space="preserve">
          <source>Gets the &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt;&lt;code&gt;URLSearchParams&lt;/code&gt;&lt;/a&gt; object representing the query parameters of the URL. This property is read-only but the &lt;code&gt;URLSearchParams&lt;/code&gt; object it provides can be used to mutate the URL instance; to replace the entirety of query parameters of the URL, use the &lt;a href=&quot;#url_url_search&quot;&gt;&lt;code&gt;url.search&lt;/code&gt;&lt;/a&gt; setter. See &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt;&lt;code&gt;URLSearchParams&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">URL의 쿼리 매개 변수를 나타내는 &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt; &lt;code&gt;URLSearchParams&lt;/code&gt; &lt;/a&gt; 개체를 가져옵니다 . 이 속성은 읽기 전용이지만 제공하는 &lt;code&gt;URLSearchParams&lt;/code&gt; 개체를 사용하여 URL 인스턴스를 변경할 수 있습니다. URL의 전체 쿼리 매개 변수를 바꾸려면 &lt;a href=&quot;#url_url_search&quot;&gt; &lt;code&gt;url.search&lt;/code&gt; &lt;/a&gt; setter를 사용하십시오 . 자세한 내용은 &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt; &lt;code&gt;URLSearchParams&lt;/code&gt; &lt;/a&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="7aa696bbcdcc43a3b4597525214bd5ca86861c90" translate="yes" xml:space="preserve">
          <source>Gets the &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt;&lt;code&gt;URLSearchParams&lt;/code&gt;&lt;/a&gt; object representing the query parameters of the URL. This property is read-only; to replace the entirety of query parameters of the URL, use the &lt;a href=&quot;#url_url_search&quot;&gt;&lt;code&gt;url.search&lt;/code&gt;&lt;/a&gt; setter. See &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt;&lt;code&gt;URLSearchParams&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">URL의 쿼리 매개 변수를 나타내는 &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt; &lt;code&gt;URLSearchParams&lt;/code&gt; &lt;/a&gt; 개체를 가져옵니다 . 이 속성은 읽기 전용입니다. URL의 전체 쿼리 매개 변수를 바꾸려면 &lt;a href=&quot;#url_url_search&quot;&gt; &lt;code&gt;url.search&lt;/code&gt; &lt;/a&gt; setter를 사용하십시오 . 자세한 내용은 &lt;a href=&quot;#url_class_urlsearchparams&quot;&gt; &lt;code&gt;URLSearchParams&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="75998834bfd160517b383467d6db3081eea8a588" translate="yes" xml:space="preserve">
          <source>Gets the read-only serialization of the URL's origin.</source>
          <target state="translated">URL 원점의 읽기 전용 직렬화를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b0765f40c9a519f99ccc6c274fce2dad2d3633b5" translate="yes" xml:space="preserve">
          <source>Getter for the payload used to construct the &lt;a href=&quot;#module_class_module_sourcemap&quot;&gt;&lt;code&gt;SourceMap&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5348b55d35480052ed3df5fd894e6230cb855e10" translate="yes" xml:space="preserve">
          <source>Getter for the property &lt;code&gt;encoding&lt;/code&gt; of a given &lt;code&gt;Readable&lt;/code&gt; stream. The &lt;code&gt;encoding&lt;/code&gt; property can be set using the &lt;a href=&quot;#stream_readable_setencoding_encoding&quot;&gt;&lt;code&gt;readable.setEncoding()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주어진 &lt;code&gt;Readable&lt;/code&gt; 스트림 의 속성 &lt;code&gt;encoding&lt;/code&gt; 을 위한 Getter . &lt;code&gt;encoding&lt;/code&gt; 속성은 사용하여 설정할 수 &lt;a href=&quot;#stream_readable_setencoding_encoding&quot;&gt; &lt;code&gt;readable.setEncoding()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="b63484bad5ed49a9ef21b266de55ef78730b074c" translate="yes" xml:space="preserve">
          <source>Getter for the property &lt;code&gt;objectMode&lt;/code&gt; of a given &lt;code&gt;Readable&lt;/code&gt; stream.</source>
          <target state="translated">주어진 &lt;code&gt;Readable&lt;/code&gt; 스트림의 &lt;code&gt;objectMode&lt;/code&gt; 속성에 대한 Getter입니다 .</target>
        </trans-unit>
        <trans-unit id="04799911b332b0e61c7c42d5ee3d7a55aff3ffd4" translate="yes" xml:space="preserve">
          <source>Getter for the property &lt;code&gt;objectMode&lt;/code&gt; of a given &lt;code&gt;Writable&lt;/code&gt; stream.</source>
          <target state="translated">지정된 &lt;code&gt;Writable&lt;/code&gt; 스트림의 &lt;code&gt;objectMode&lt;/code&gt; 속성에 대한 Getter입니다 .</target>
        </trans-unit>
        <trans-unit id="1df26200bb8d49a249a1311c46b8cae48b1f069c" translate="yes" xml:space="preserve">
          <source>Getting the value of the &lt;code&gt;href&lt;/code&gt; property is equivalent to calling &lt;a href=&quot;#url_url_tostring&quot;&gt;&lt;code&gt;url.toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; 속성 값을 얻는 것은 &lt;a href=&quot;#url_url_tostring&quot;&gt; &lt;code&gt;url.toString()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eda80b83a6983362aa0540edf49d4ad18f1a51c3" translate="yes" xml:space="preserve">
          <source>GitHub Repo &amp;amp; Issue Tracker</source>
          <target state="translated">GitHub 리포지토리 및 이슈 트래커</target>
        </trans-unit>
        <trans-unit id="b170325808a5a3d7a22f1d97c806adb95a1b8b39" translate="yes" xml:space="preserve">
          <source>Given a line number and column number in the generated source file, returns an object representing the position in the original file. The object returned consists of the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fa5ba39f3db1e4e3025e3bb38168ee7debb652" translate="yes" xml:space="preserve">
          <source>Given the above code, the add-on can be used from JavaScript as follows:</source>
          <target state="translated">위 코드가 주어지면, 애드온은 다음과 같이 JavaScript에서 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="be3aa1dec5068fa02e91e240d40f210ae17130d7" translate="yes" xml:space="preserve">
          <source>Given the file &lt;code&gt;test.js&lt;/code&gt; below, the command &lt;code&gt;node --trace-event-categories node.perf test.js&lt;/code&gt; will print &lt;code&gt;'node.async_hooks,node.perf'&lt;/code&gt; to the console.</source>
          <target state="translated">아래 &lt;code&gt;test.js&lt;/code&gt; 파일이 주어지면 &lt;code&gt;node --trace-event-categories node.perf test.js&lt;/code&gt; 명령 이 콘솔에 &lt;code&gt;'node.async_hooks,node.perf'&lt;/code&gt; 를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="05f7f9a759c42ea233ab74999c709f6b1e876d7d" translate="yes" xml:space="preserve">
          <source>Given two modules: &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is a dependency of &lt;code&gt;a&lt;/code&gt; and there is a directory structure of:</source>
          <target state="translated">두 개의 모듈 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 주어 졌는데, 여기서 &lt;code&gt;b&lt;/code&gt; 는 a의 종속성이며 &lt;code&gt;a&lt;/code&gt; 과 같은 디렉토리 구조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5cdadeb82c625264f87984cdb7712780b8ec0e8" translate="yes" xml:space="preserve">
          <source>Global Objects</source>
          <target state="translated">글로벌 객체</target>
        </trans-unit>
        <trans-unit id="2fbfcc83f5aaca871794a502e4acc6e3f184a789" translate="yes" xml:space="preserve">
          <source>Global Uncaught Exceptions</source>
          <target state="translated">잡히지 않은 글로벌 예외</target>
        </trans-unit>
        <trans-unit id="5fb36c11e9fc0d37d09666e2af5e8441d628402a" translate="yes" xml:space="preserve">
          <source>Global and Local Scope</source>
          <target state="translated">글로벌 및 로컬 범위</target>
        </trans-unit>
        <trans-unit id="ccaef04ea4be804bccef5366669a1def24d12f2c" translate="yes" xml:space="preserve">
          <source>Global and local scope</source>
          <target state="translated">글로벌 및 로컬 범위</target>
        </trans-unit>
        <trans-unit id="4e37f490a39d54c9fbeb3fe41c5d4ea1ae177329" translate="yes" xml:space="preserve">
          <source>Global instance of &lt;a href=&quot;#https_class_https_agent&quot;&gt;&lt;code&gt;https.Agent&lt;/code&gt;&lt;/a&gt; for all HTTPS client requests.</source>
          <target state="translated">모든 HTTPS 클라이언트 요청에 대한 &lt;a href=&quot;#https_class_https_agent&quot;&gt; &lt;code&gt;https.Agent&lt;/code&gt; 의&lt;/a&gt; 글로벌 인스턴스</target>
        </trans-unit>
        <trans-unit id="0325bf31f1497d9a8e4078e8217123ef9c5d16a1" translate="yes" xml:space="preserve">
          <source>Global instance of &lt;code&gt;Agent&lt;/code&gt; which is used as the default for all HTTP client requests.</source>
          <target state="translated">모든 HTTP 클라이언트 요청의 기본값으로 사용되는 &lt;code&gt;Agent&lt;/code&gt; 글로벌 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">글로벌 객체</target>
        </trans-unit>
        <trans-unit id="4fcb376e16da79ed7bc2e12f38e3b0c37529189d" translate="yes" xml:space="preserve">
          <source>Global uncaught exceptions</source>
          <target state="translated">잡히지 않은 전역 예외</target>
        </trans-unit>
        <trans-unit id="3f827c66e7e04723ed3fa1ab0945dff3f10b9b83" translate="yes" xml:space="preserve">
          <source>Globals</source>
          <target state="translated">Globals</target>
        </trans-unit>
        <trans-unit id="648da6c1992411de134935564dd6ba6172deb006" translate="yes" xml:space="preserve">
          <source>Go to start of line</source>
          <target state="translated">줄의 시작으로 이동</target>
        </trans-unit>
        <trans-unit id="1e02451e7f35249a5e24b68a62fb7a1aa83c92b4" translate="yes" xml:space="preserve">
          <source>Go to to end of line</source>
          <target state="translated">줄 끝으로 이동</target>
        </trans-unit>
        <trans-unit id="4a04855390ce638fd14ff576f9ce989505246d79" translate="yes" xml:space="preserve">
          <source>Gracefully closes the &lt;code&gt;Http2Session&lt;/code&gt;, allowing any existing streams to complete on their own and preventing new &lt;code&gt;Http2Stream&lt;/code&gt; instances from being created. Once closed, &lt;code&gt;http2session.destroy()&lt;/code&gt;&lt;em&gt;might&lt;/em&gt; be called if there are no open &lt;code&gt;Http2Stream&lt;/code&gt; instances.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 을 정상적으로 닫아 기존 스트림을 자체적으로 완료하고 새 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스가 작성되지 않도록합니다. 폐쇄되면, &lt;code&gt;http2session.destroy()&lt;/code&gt; &lt;em&gt;수있는&lt;/em&gt; 열린이없는 경우라고 할 수 &lt;code&gt;Http2Stream&lt;/code&gt; 의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="76dde01230d81e8318645c40922a83614432919a" translate="yes" xml:space="preserve">
          <source>Gracefully closes the &lt;code&gt;QuicSocket&lt;/code&gt;. Existing &lt;code&gt;QuicSession&lt;/code&gt; instances will be permitted to close naturally. New &lt;code&gt;QuicClientSession&lt;/code&gt; and &lt;code&gt;QuicServerSession&lt;/code&gt; instances will not be allowed. The returns &lt;code&gt;Promise&lt;/code&gt; will be resolved once the &lt;code&gt;QuicSocket&lt;/code&gt; is destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="dcc9fe2b29d5c16eb1fd877bb1de7daac43d3b7b" translate="yes" xml:space="preserve">
          <source>HKDF is a simple key derivation function defined in RFC 5869. The given &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;salt&lt;/code&gt; and &lt;code&gt;info&lt;/code&gt; are used with the &lt;code&gt;digest&lt;/code&gt; to derive a key of &lt;code&gt;keylen&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d86096f13a3b618af397b1b26730cf6143f8cfe" translate="yes" xml:space="preserve">
          <source>HMAC keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa2e96a3d3268692d6f1633b35f5be17a47afc2" translate="yes" xml:space="preserve">
          <source>HPE_HEADER_OVERFLOW</source>
          <target state="translated">HPE_HEADER_OVERFLOW</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="fdb5a4b986e0dcc27ea3e57d3e4174bc376076a2" translate="yes" xml:space="preserve">
          <source>HTTP message headers are represented by an object like this:</source>
          <target state="translated">HTTP 메시지 헤더는 다음과 같은 객체로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6bedb581201b3185f91c52a099cb8493bc05da02" translate="yes" xml:space="preserve">
          <source>HTTP requests, on the client</source>
          <target state="translated">클라이언트의 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="8c27f8f8898f84f5f0e669f814562011af3abe1f" translate="yes" xml:space="preserve">
          <source>HTTP requests, on the server</source>
          <target state="translated">서버의 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="7e79e0f7231dc71d3c2aaa877778c65a5247b0d2" translate="yes" xml:space="preserve">
          <source>HTTP requires the &lt;code&gt;Trailer&lt;/code&gt; header to be sent in order to emit trailers, with a list of the header fields in its value. E.g.,</source>
          <target state="translated">HTTP에서는 &lt;code&gt;Trailer&lt;/code&gt; 려면 예고편 헤더를 보내야하며 값에 헤더 필드 목록이 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="86fcfbb15f6845bfac98cdb49edf4809f4e265ca" translate="yes" xml:space="preserve">
          <source>HTTP responses, on the client</source>
          <target state="translated">클라이언트의 HTTP 응답</target>
        </trans-unit>
        <trans-unit id="48f2266f075962126f207086a2582ec55aae30f1" translate="yes" xml:space="preserve">
          <source>HTTP responses, on the server</source>
          <target state="translated">서버의 HTTP 응답</target>
        </trans-unit>
        <trans-unit id="c8ea5ddd7ae4ea21da1ba2ad745cba902ce0e7c9" translate="yes" xml:space="preserve">
          <source>HTTP/1 connection specific headers are forbidden to be used in HTTP/2 requests and responses.</source>
          <target state="translated">HTTP / 1 연결 특정 헤더는 HTTP / 2 요청 및 응답에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c29f7b7a2556c18bd6ae0375852ab119253dde" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 Required</source>
          <target state="translated">HTTP / 1.1 필요</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="8148960d4e61716fc44450d8897a0e7b3f04fd9e" translate="yes" xml:space="preserve">
          <source>HTTP/2 &lt;code&gt;ORIGIN&lt;/code&gt; frames are limited to a length of 16382 bytes.</source>
          <target state="translated">HTTP / 2 &lt;code&gt;ORIGIN&lt;/code&gt; 프레임은 길이가 16382 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4a2dece163a07b7e6be65743d283e8755270d1ad" translate="yes" xml:space="preserve">
          <source>HTTP/2 &lt;code&gt;ORIGIN&lt;/code&gt; frames require a valid origin.</source>
          <target state="translated">HTTP / 2 &lt;code&gt;ORIGIN&lt;/code&gt; 프레임에는 유효한 원점이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9230f85593a0376299b95c5b187c2cfcd9228863" translate="yes" xml:space="preserve">
          <source>HTTP/2 ALTSVC frames are limited to a maximum of 16,382 payload bytes.</source>
          <target state="translated">HTTP / 2 ALTSVC 프레임은 최대 16,382 페이로드 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="dacf73205d74d5e87bb8aca79da96f9db3b2255e" translate="yes" xml:space="preserve">
          <source>HTTP/2 ALTSVC frames require a valid origin.</source>
          <target state="translated">HTTP / 2 ALTSVC 프레임에는 유효한 원점이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="32c063f11c9e54047fa82b0c64454229ca1c933a" translate="yes" xml:space="preserve">
          <source>HTTP/2 informational headers must only be sent &lt;em&gt;prior&lt;/em&gt; to calling the &lt;code&gt;Http2Stream.prototype.respond()&lt;/code&gt; method.</source>
          <target state="translated">HTTP / 2 정보 헤더는 &lt;code&gt;Http2Stream.prototype.respond()&lt;/code&gt; 메소드 를 호출 &lt;em&gt;하기 전에&lt;/em&gt; 만 전송해야합니다 .</target>
        </trans-unit>
        <trans-unit id="528fe308debf6ef52289c4212825715f2f7cc298" translate="yes" xml:space="preserve">
          <source>HTTP/2 is now Stable. Previously, it had been Experimental.</source>
          <target state="translated">이제 HTTP / 2가 안정적입니다. 이전에는 실험적이었습니다.</target>
        </trans-unit>
        <trans-unit id="e077df1ae49c023afc50547177431823bd0969d2" translate="yes" xml:space="preserve">
          <source>HTTP/2 ping payloads must be exactly 8 bytes in length.</source>
          <target state="translated">HTTP / 2 핑 페이로드의 길이는 정확히 8 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5870c206c31719f59b8b501ee7f225f052fa05b0" translate="yes" xml:space="preserve">
          <source>HTTP/2 requires requests to have either the &lt;code&gt;:authority&lt;/code&gt; pseudo-header or the &lt;code&gt;host&lt;/code&gt; header. Prefer &lt;code&gt;:authority&lt;/code&gt; when constructing an HTTP/2 request directly, and &lt;code&gt;host&lt;/code&gt; when converting from HTTP/1 (in proxies, for instance).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2060575b9f4a00030da60d7484909f097bc2c636" translate="yes" xml:space="preserve">
          <source>HTTP/3 is an application layer protocol that uses QUIC as the transport.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627f416e24dd2e31b07d2196d4c0019a8f40480" translate="yes" xml:space="preserve">
          <source>HTTP2 headers can be marked as sensitive, which means that the HTTP/2 header compression algorithm will never index them. This can make sense for header values with low entropy and that may be considered valuable to an attacker, for example &lt;code&gt;Cookie&lt;/code&gt; or &lt;code&gt;Authorization&lt;/code&gt;. To achieve this, add the header name to the &lt;code&gt;[http2.sensitiveHeaders]&lt;/code&gt; property as an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52698c28f0d2036450e02a85451ee4f5be02442" translate="yes" xml:space="preserve">
          <source>HTTPS</source>
          <target state="translated">HTTPS</target>
        </trans-unit>
        <trans-unit id="ef09cecaab6baa3ec4655e999ed134572f934f56" translate="yes" xml:space="preserve">
          <source>HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a separate module.</source>
          <target state="translated">HTTPS는 TLS / SSL을 통한 HTTP 프로토콜입니다. Node.js에서 이것은 별도의 모듈로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7321ba496209c1006f0503074146f8fa922604ca" translate="yes" xml:space="preserve">
          <source>HTTPS loader</source>
          <target state="translated">HTTPS 로더</target>
        </trans-unit>
        <trans-unit id="0c638f78e236c7b777e5413fb14f7ac604a42539" translate="yes" xml:space="preserve">
          <source>Half-closes the socket. i.e., it sends a FIN packet. It is possible the server will still send some data.</source>
          <target state="translated">소켓을 반쯤 닫습니다. 즉, FIN 패킷을 보냅니다. 서버가 여전히 일부 데이터를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f9e5d2b5f778fe24b47ab2ebc0290eb3118419c" translate="yes" xml:space="preserve">
          <source>Handle non-&lt;code&gt;Uint8Array&lt;/code&gt; typed arrays correctly.</source>
          <target state="translated">비 &lt;code&gt;Uint8Array&lt;/code&gt; 유형 배열을 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="fd711236f5bce407cc82e7be889f63bbf1c1e755" translate="yes" xml:space="preserve">
          <source>Handle scopes are created using &lt;a href=&quot;#n_api_napi_open_handle_scope&quot;&gt;&lt;code&gt;napi_open_handle_scope&lt;/code&gt;&lt;/a&gt; and are destroyed using &lt;a href=&quot;#n_api_napi_close_handle_scope&quot;&gt;&lt;code&gt;napi_close_handle_scope&lt;/code&gt;&lt;/a&gt;. Closing the scope can indicate to the GC that all &lt;code&gt;napi_value&lt;/code&gt;s created during the lifetime of the handle scope are no longer referenced from the current stack frame.</source>
          <target state="translated">핸들 범위는 &lt;a href=&quot;#n_api_napi_open_handle_scope&quot;&gt; &lt;code&gt;napi_open_handle_scope&lt;/code&gt; 를&lt;/a&gt; 사용하여 생성 되고 &lt;a href=&quot;#n_api_napi_close_handle_scope&quot;&gt; &lt;code&gt;napi_close_handle_scope&lt;/code&gt; 를&lt;/a&gt; 사용하여 제거 됩니다. 범위를 닫으면 핸들 범위의 수명 동안 생성 된 모든 &lt;code&gt;napi_value&lt;/code&gt; 가 더 이상 현재 스택 프레임에서 참조되지 않음을 GC에 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="228c77a4ec5ff84fa645413101166b3e93d83071" translate="yes" xml:space="preserve">
          <source>Handler functions may mutate the &lt;code&gt;event&lt;/code&gt; object.</source>
          <target state="translated">핸들러 함수는 &lt;code&gt;event&lt;/code&gt; 객체를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a64f6a82d4f450691ecd905c452070f694076286" translate="yes" xml:space="preserve">
          <source>Handlers are always invoked in the order they were added.</source>
          <target state="translated">핸들러는 항상 추가 된 순서대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4670d802dc0f8d1d8fe9b416d00a6e619d00e5" translate="yes" xml:space="preserve">
          <source>Handlers for &lt;code&gt;Promise&lt;/code&gt;s are now invoked in the domain in which the first promise of a chain was created.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 용 핸들러 는 이제 체인의 첫 번째 약속이 작성된 도메인에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4409d51e3614ba3998980937265da2facba22c2f" translate="yes" xml:space="preserve">
          <source>Handling client hello</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16ab4925704ec488726f12cbc19ee310ea09d7a" translate="yes" xml:space="preserve">
          <source>Handling events only once</source>
          <target state="translated">한 번만 이벤트 처리</target>
        </trans-unit>
        <trans-unit id="6b91098d75c32149f113553d14a234924b548a1e" translate="yes" xml:space="preserve">
          <source>Handling this event involves calling &lt;a href=&quot;#http2_response_writecontinue&quot;&gt;&lt;code&gt;response.writeContinue()&lt;/code&gt;&lt;/a&gt; if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body.</source>
          <target state="translated">이 이벤트를 처리 하려면 클라이언트가 요청 본문을 계속 보내야하는 경우 &lt;a href=&quot;#http2_response_writecontinue&quot;&gt; &lt;code&gt;response.writeContinue()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 클라이언트가 요청 본문을 계속 보내지 않아야하는 경우 적절한 HTTP 응답 (예 : 400 잘못된 요청)을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b712796f82e3fa4437c6dea3765a90d7215fbfd" translate="yes" xml:space="preserve">
          <source>Handling this event involves calling &lt;a href=&quot;#http_response_writecontinue&quot;&gt;&lt;code&gt;response.writeContinue()&lt;/code&gt;&lt;/a&gt; if the client should continue to send the request body, or generating an appropriate HTTP response (e.g. 400 Bad Request) if the client should not continue to send the request body.</source>
          <target state="translated">이 이벤트를 처리 하려면 클라이언트가 요청 본문을 계속 보내야하는 경우 &lt;a href=&quot;#http_response_writecontinue&quot;&gt; &lt;code&gt;response.writeContinue()&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 클라이언트가 요청 본문을 계속 보내지 않아야하는 경우 적절한 HTTP 응답 (예 : 400 잘못된 요청)을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="40aba275f1ef6a200de77f3a58f12fd38676ccf0" translate="yes" xml:space="preserve">
          <source>Header field names are &lt;em&gt;case-insensitive&lt;/em&gt; and are transmitted over the wire strictly as lower-case strings. The API provided by Node.js allows header names to be set as mixed-case strings (e.g. &lt;code&gt;Content-Type&lt;/code&gt;) but will convert those to lower-case (e.g. &lt;code&gt;content-type&lt;/code&gt;) upon transmission.</source>
          <target state="translated">헤더 필드 이름은 &lt;em&gt;대소 문자를 구분하지 않으며&lt;/em&gt; 소문자 문자열로 엄격하게 전송됩니다. Node.js가 제공하는 API를 사용하면 헤더 이름을 대소 문자 혼합 문자열 (예 : &lt;code&gt;Content-Type&lt;/code&gt; ) 로 설정할 수 있지만 전송시이를 소문자 (예 : &lt;code&gt;content-type&lt;/code&gt; ) 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="88b12fc1e888c0c5168ce6494ea0eeffcfbfa675" translate="yes" xml:space="preserve">
          <source>Header field values are handled with more leniency but &lt;em&gt;should&lt;/em&gt; not contain new-line or carriage return characters and &lt;em&gt;should&lt;/em&gt; be limited to US-ASCII characters, per the requirements of the HTTP specification.</source>
          <target state="translated">헤더 필드 값은 더 관용으로 취급되지만 &lt;em&gt;한다&lt;/em&gt; 새로운 라인 또는 캐리지 리턴 문자를 포함하고 &lt;em&gt;있어야&lt;/em&gt; HTTP 사양의 요구 사항에 따라, US-ASCII 문자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec8b1892d59bd2c1b2abd7acb2f186730da0aaa" translate="yes" xml:space="preserve">
          <source>Header field-names &lt;em&gt;must only&lt;/em&gt; contain one or more of the following ASCII characters: &lt;code&gt;a&lt;/code&gt;-&lt;code&gt;z&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;-&lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;`&lt;/code&gt; (backtick), &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">헤더 필드 이름 &lt;em&gt;만 있어야&lt;/em&gt; 하나 이상의 다음과 같은 ASCII 문자가 들어 - &lt;code&gt;z&lt;/code&gt; , - &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;`&lt;/code&gt; (백틱), &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d9b086c13105ea35971403bf835a70d0bbb872e" translate="yes" xml:space="preserve">
          <source>Header names are not lowercased, and duplicates are not merged.</source>
          <target state="translated">헤더 이름은 소문자가 아니며 복제본은 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2511e922d77fcdc42cd4383bff0441bb6537fa5c" translate="yes" xml:space="preserve">
          <source>Header objects passed to callback functions will have a &lt;code&gt;null&lt;/code&gt; prototype. This means that normal JavaScript object methods such as &lt;code&gt;Object.prototype.toString()&lt;/code&gt; and &lt;code&gt;Object.prototype.hasOwnProperty()&lt;/code&gt; will not work.</source>
          <target state="translated">콜백 함수에 전달 된 헤더 객체에는 &lt;code&gt;null&lt;/code&gt; 프로토 타입이 있습니다. 이는 &lt;code&gt;Object.prototype.toString()&lt;/code&gt; 및 &lt;code&gt;Object.prototype.hasOwnProperty()&lt;/code&gt; 와 같은 일반적인 JavaScript 객체 메소드 가 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9e4700ad76aa91c1d67e40b3abea4c788dda8a72" translate="yes" xml:space="preserve">
          <source>Headers Object</source>
          <target state="translated">헤더 객체</target>
        </trans-unit>
        <trans-unit id="67c4b953e20f4046d4339e1ef3eb71030cdf4cff" translate="yes" xml:space="preserve">
          <source>Headers are represented as own-properties on JavaScript objects. The property keys will be serialized to lower-case. Property values should be strings (if they are not they will be coerced to strings) or an &lt;code&gt;Array&lt;/code&gt; of strings (in order to send more than one value per header field).</source>
          <target state="translated">헤더는 JavaScript 객체에서 자체 속성으로 표시됩니다. 속성 키는 소문자로 직렬화됩니다. 속성 값은 문자열 (문자열이 아닌 경우 문자열로 강제 변환 됨) 또는 문자열 &lt;code&gt;Array&lt;/code&gt; (헤더 필드 당 둘 이상의 값을 보내려면)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c4514aa5a37c87bc3e2df29a944e14644960faf" translate="yes" xml:space="preserve">
          <source>Headers object</source>
          <target state="translated">헤더 객체</target>
        </trans-unit>
        <trans-unit id="c27c007a96dfa358dbc61fd4c0845a6951498148" translate="yes" xml:space="preserve">
          <source>Heap Profiler</source>
          <target state="translated">힙 프로파일 러</target>
        </trans-unit>
        <trans-unit id="cdc2c9201585ad7e95a0e9ddac7816f7f88d5cea" translate="yes" xml:space="preserve">
          <source>Heap profiler</source>
          <target state="translated">힙 프로파일 러</target>
        </trans-unit>
        <trans-unit id="d141de50f82ee3e0ba92d0bdde5b5f7cd2e0f464" translate="yes" xml:space="preserve">
          <source>Heap-allocate an instance of this class in the addon initializer. This can be accomplished using the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">애드온 이니셜 라이저에서이 클래스의 인스턴스를 힙 할당합니다. 이것은 &lt;code&gt;new&lt;/code&gt; 키워드를 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b502c3a1f48c8609ae212cdfb639dee39673f5e" translate="yes" xml:space="preserve">
          <source>Hello world</source>
          <target state="translated">안녕하세요 세계</target>
        </trans-unit>
        <trans-unit id="1d23f19a7e4063e7c60c0e18d73117c9b921e19a" translate="yes" xml:space="preserve">
          <source>Helpers for interacting with the source map cache. This cache is populated when source map parsing is enabled and &lt;a href=&quot;https://sourcemaps.info/spec.html#h.lmz475t4mvbx&quot;&gt;source map include directives&lt;/a&gt; are found in a modules' footer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c6cab4071321fb2d749352736fd5b32cfb564f" translate="yes" xml:space="preserve">
          <source>Here are the contents of &lt;code&gt;circle.js&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;circle.js&lt;/code&gt; 의 내용은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ad2137a56ebf15e23f0b386430b270eb5b5bd497" translate="yes" xml:space="preserve">
          <source>Here is an example below:</source>
          <target state="translated">아래에 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="08b02063a09fd208f0e5d16954f0cb86868b6df8" translate="yes" xml:space="preserve">
          <source>Here is an example of an TCP echo server which listens for connections on port 8124:</source>
          <target state="translated">다음은 포트 8124의 연결을 수신 대기하는 TCP 에코 서버의 예입니다.</target>
        </trans-unit>
        <trans-unit id="650d7a34601ecbfc556318f1e1d6fb2cc04c920d" translate="yes" xml:space="preserve">
          <source>Here is an example of the &lt;code&gt;ret&lt;/code&gt; object passed to the callback:</source>
          <target state="translated">다음은 콜백에 전달 된 &lt;code&gt;ret&lt;/code&gt; 객체 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4d067608386a71a40cf2ed3a4efd12148eb6d04d" translate="yes" xml:space="preserve">
          <source>Here is an example of the result object:</source>
          <target state="translated">결과 객체의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a605b24ae485b7b7ebfaac5e6d6801a86626a08" translate="yes" xml:space="preserve">
          <source>Here is an example using the message system. It keeps a count in the master process of the number of HTTP requests received by the workers:</source>
          <target state="translated">다음은 메시지 시스템을 사용하는 예입니다. 작업자가 수신 한 HTTP 요청 수의 마스터 프로세스에 카운트를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="da970d32241bd4accf1d4a727aee19b70f849a64" translate="yes" xml:space="preserve">
          <source>Here's an example showing how to use the &lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/v8/HeapProfiler&quot;&gt;Heap Profiler&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/v8/HeapProfiler&quot;&gt;힙 프로파일 러&lt;/a&gt; 를 사용하는 방법을 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="26838d9f3d94b6ddd2817d8b544156b68bf25304" translate="yes" xml:space="preserve">
          <source>Here's an example showing how to use the &lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/v8/Profiler&quot;&gt;CPU Profiler&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://chromedevtools.github.io/devtools-protocol/v8/Profiler&quot;&gt;CPU 프로파일 러&lt;/a&gt; 를 사용하는 방법을 보여주는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="6674c137d260d9630d25a2f4d17e1afaa452b935" translate="yes" xml:space="preserve">
          <source>High Resolution Time</source>
          <target state="translated">고해상도 시간</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="c784383bf299a785b32f45ad58b42343eea5b02e" translate="yes" xml:space="preserve">
          <source>Historically, node-gyp has been the tool of choice for building native addons. It has widespread adoption and documentation. However, some developers have run into limitations in node-gyp.</source>
          <target state="translated">역사적으로 node-gyp은 네이티브 애드온을 구축하기 위해 선택한 도구였습니다. 널리 채택되고 문서화되었습니다. 그러나 일부 개발자는 node-gyp에서 제한을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="cc4a71065ff8ca97a2cf841b164f030229d81b91" translate="yes" xml:space="preserve">
          <source>Hmac</source>
          <target state="translated">Hmac</target>
        </trans-unit>
        <trans-unit id="f3d2ec6b4a586d95b5d4f5d2adbc69eebe706a88" translate="yes" xml:space="preserve">
          <source>Hook Callbacks</source>
          <target state="translated">훅 콜백</target>
        </trans-unit>
        <trans-unit id="06c885773a4d617d8c66c519780bba0fda08f693" translate="yes" xml:space="preserve">
          <source>Hook callbacks</source>
          <target state="translated">후크 콜백</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="8cecc82d72d68f9151cb0901cfe40eeac15bfca6" translate="yes" xml:space="preserve">
          <source>How It Works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="b8b013bb14afa30043c795cf70fba96d444186a1" translate="yes" xml:space="preserve">
          <source>However, changing from &lt;code&gt;http&lt;/code&gt; to a hypothetical &lt;code&gt;fish&lt;/code&gt; protocol does not because the new protocol is not special.</source>
          <target state="translated">그러나 &lt;code&gt;http&lt;/code&gt; 에서 가상 &lt;code&gt;fish&lt;/code&gt; 프로토콜 로 변경 한다고 해서 새로운 프로토콜이 특별하지 않기 때문은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="217dafda23837f885d1064b5c21d68c773e81068" translate="yes" xml:space="preserve">
          <source>However, if this function succeeded, further calls to this function after the initial instantiation will be no-ops, to be consistent with the ECMAScript specification.</source>
          <target state="translated">그러나이 함수가 성공하면 ECMAScript 사양과 일치하도록 초기 인스턴스화 후이 함수를 추가로 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1b7ad14a7be7d7e22cd04a62b5f23338533302a" translate="yes" xml:space="preserve">
          <source>However, in the case where a developer may need to retain a small chunk of memory from a pool for an indeterminate amount of time, it may be appropriate to create an un-pooled &lt;code&gt;Buffer&lt;/code&gt; instance using &lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt; and then copying out the relevant bits.</source>
          <target state="translated">그러나 개발자가 결정되지 않은 시간 동안 풀에서 작은 메모리 청크를 유지해야하는 경우에는 &lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt; 사용하여 풀링되지 않은 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스를 만든 다음 복사하는 것이 좋습니다 . 관련 비트.</target>
        </trans-unit>
        <trans-unit id="9d6916e44f35441e32746ea7fedd004805bfa6e2" translate="yes" xml:space="preserve">
          <source>However, the created &lt;code&gt;MessagePort&lt;/code&gt; no longer inherits from &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;&lt;code&gt;EventTarget&lt;/code&gt;&lt;/a&gt;, and only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage&quot;&gt;&lt;code&gt;port.onmessage()&lt;/code&gt;&lt;/a&gt; can be used to receive events using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371f9ed83922bcd4b3843ce103949d80056a0911" translate="yes" xml:space="preserve">
          <source>However, the created &lt;code&gt;MessagePort&lt;/code&gt; will no longer inherit from &lt;a href=&quot;events&quot;&gt;&lt;code&gt;EventEmitter&lt;/code&gt;&lt;/a&gt;, and only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage&quot;&gt;&lt;code&gt;port.onmessage()&lt;/code&gt;&lt;/a&gt; can be used to receive events using it.</source>
          <target state="translated">그러나 작성된 &lt;code&gt;MessagePort&lt;/code&gt; 는 더 이상 &lt;a href=&quot;events&quot;&gt; &lt;code&gt;EventEmitter&lt;/code&gt; &lt;/a&gt; 에서 상속되지 않으며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage&quot;&gt; &lt;code&gt;port.onmessage()&lt;/code&gt; &lt;/a&gt; 만 사용하여 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa28c2a213a024d7d1a0c438ecbc7bbfec1b88d" translate="yes" xml:space="preserve">
          <source>However, the following will result in an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; with the message 'Got unwanted exception...':</source>
          <target state="translated">그러나 다음은 '원치 않는 예외가 있습니다 ...'라는 메시지와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d38fc251c7926f79e6e726b8ee8e35076886e90" translate="yes" xml:space="preserve">
          <source>However, the following will result in an &lt;code&gt;AssertionError&lt;/code&gt; with the message 'Got unwanted exception...':</source>
          <target state="translated">그러나 다음은 'Gon 원하지 않는 예외 ...'메시지와 함께 &lt;code&gt;AssertionError&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d9c0426790856f8e44b351f9e4917ce4ccb29974" translate="yes" xml:space="preserve">
          <source>However, this format is not a full superset of JSON, and e.g. properties set on objects of such built-in types will not be passed on through the serialization step. Additionally, performance may not be equivalent to that of JSON, depending on the structure of the passed data. Therefore, this feature requires opting in by setting the &lt;code&gt;serialization&lt;/code&gt; option to &lt;code&gt;'advanced'&lt;/code&gt; when calling &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나이 형식은 JSON의 전체 상위 집합이 아니며, 예를 들어 이러한 내장 유형의 개체에 설정된 속성은 직렬화 단계를 통해 전달되지 않습니다. 또한 전달 된 데이터의 구조에 따라 성능이 JSON과 동일하지 않을 수 있습니다. 따라서이 기능을 사용하려면 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; 호출 할 때 &lt;code&gt;serialization&lt;/code&gt; 옵션을 &lt;code&gt;'advanced'&lt;/code&gt; 로 설정하여 옵트 인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4f31e79d484e6bad0399f3831ddb8f4f71d4b70" translate="yes" xml:space="preserve">
          <source>Http2SecureServer</source>
          <target state="translated">Http2SecureServer</target>
        </trans-unit>
        <trans-unit id="69e173fd39778ed04b13acb1e3cb6b95259bc29b" translate="yes" xml:space="preserve">
          <source>Http2Server</source>
          <target state="translated">Http2Server</target>
        </trans-unit>
        <trans-unit id="e07e208f0d559a077e5ff88cdf452db14558d01d" translate="yes" xml:space="preserve">
          <source>Http2Session</source>
          <target state="translated">Http2Session</target>
        </trans-unit>
        <trans-unit id="c5163621c30ca50884bfc415eac2ea0ee630b513" translate="yes" xml:space="preserve">
          <source>Http2Session and Sockets</source>
          <target state="translated">Http2Session 및 소켓</target>
        </trans-unit>
        <trans-unit id="0ab6c9fdd17eeadb81f558be7086b2bf5a839c48" translate="yes" xml:space="preserve">
          <source>Http2Stream</source>
          <target state="translated">Http2Stream</target>
        </trans-unit>
        <trans-unit id="e488ff3925f9c2b81a0fc61328b3e3ca7adb034e" translate="yes" xml:space="preserve">
          <source>Http2Stream Lifecycle</source>
          <target state="translated">Http2Stream 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="8fdf25d549e82b325ad178006258a8719d41ecfb" translate="yes" xml:space="preserve">
          <source>ICU is able to automatically find and load a variety of data formats, but the data must be appropriate for the ICU version, and the file correctly named. The most common name for the data file is &lt;code&gt;icudt6X[bl].dat&lt;/code&gt;, where &lt;code&gt;6X&lt;/code&gt; denotes the intended ICU version, and &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; indicates the system's endianness. Check &lt;a href=&quot;http://userguide.icu-project.org/icudata&quot;&gt;&quot;ICU Data&quot;&lt;/a&gt; article in the ICU User Guide for other supported formats and more details on ICU data in general.</source>
          <target state="translated">ICU는 다양한 데이터 형식을 자동으로 찾아서로드 할 수 있지만 데이터는 ICU 버전에 적합해야하며 파일 이름은 올바르게 지정해야합니다. 데이터 파일의 가장 일반적인 이름은 &lt;code&gt;icudt6X[bl].dat&lt;/code&gt; . 여기서 &lt;code&gt;6X&lt;/code&gt; 는 의도 한 ICU 버전을 나타내고 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;l&lt;/code&gt; 은 시스템의 엔디안을 나타냅니다. 지원되는 다른 형식과 일반적인 ICU 데이터에 대한 자세한 내용은 ICU 사용 설명서의 &lt;a href=&quot;http://userguide.icu-project.org/icudata&quot;&gt;&quot;ICU 데이터&quot;&lt;/a&gt; 기사를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="324af4da694d68f4b7d517af8a91fe505f93074c" translate="yes" xml:space="preserve">
          <source>IPC Support</source>
          <target state="translated">IPC 지원</target>
        </trans-unit>
        <trans-unit id="cd07613e18fd2980e850dc35cf7b7b6aa2c0cde7" translate="yes" xml:space="preserve">
          <source>IPC channels from parent processes are not accessible.</source>
          <target state="translated">상위 프로세스의 IPC 채널에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="839086e14a333a353919df42d137e10c3a768a71" translate="yes" xml:space="preserve">
          <source>IPC support</source>
          <target state="translated">IPC 지원</target>
        </trans-unit>
        <trans-unit id="c55c70f459a62763619af9f57cf5850cd15f474f" translate="yes" xml:space="preserve">
          <source>IPv4 addresses (default)</source>
          <target state="translated">IPv4 주소 (기본값)</target>
        </trans-unit>
        <trans-unit id="6c0afb2bb01117b0e08d467de866f58f12c8ad23" translate="yes" xml:space="preserve">
          <source>IPv6 addresses</source>
          <target state="translated">IPv6 주소</target>
        </trans-unit>
        <trans-unit id="4025174d38891a7c19336433fdedd242a1eeb261" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#buffer_buf_indexof_value_byteoffset_encoding&quot;&gt;&lt;code&gt;buf.indexOf()&lt;/code&gt;&lt;/a&gt;, except the last occurrence of &lt;code&gt;value&lt;/code&gt; is found rather than the first occurrence.</source>
          <target state="translated">동일 &lt;a href=&quot;#buffer_buf_indexof_value_byteoffset_encoding&quot;&gt; &lt;code&gt;buf.indexOf()&lt;/code&gt; &lt;/a&gt; 의 최후의 발생을 제외한 &lt;code&gt;value&lt;/code&gt; 보다는 처음 나타나는보다 발견된다.</target>
        </trans-unit>
        <trans-unit id="99807e48005beb9afb928c593a1736f90716a5cf" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;-e&lt;/code&gt; but prints the result.</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 와 동일 하지만 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="eff66c38c482071129bb47b8b0514c9ef9980f78" translate="yes" xml:space="preserve">
          <source>Identifying paths for IPC connections</source>
          <target state="translated">IPC 연결 경로 식별</target>
        </trans-unit>
        <trans-unit id="1eb8242c3d7f4981b86f02d871e9facba25b76e8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#http2_response_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;response.write()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; are called before calling this, the implicit/mutable headers will be calculated and call this function.</source>
          <target state="translated">경우 &lt;a href=&quot;#http2_response_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;response.write()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 이를 호출하기 전에 호출, 암시 적 / 가변 헤더는 계산이 함수를 호출한다.</target>
        </trans-unit>
        <trans-unit id="1f5db519e046b3f5c079931debb7310f19546987" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#http_response_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;response.write()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; are called before calling this, the implicit/mutable headers will be calculated and call this function.</source>
          <target state="translated">경우 &lt;a href=&quot;#http_response_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;response.write()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 이를 호출하기 전에 호출, 암시 적 / 가변 헤더는 계산이 함수를 호출한다.</target>
        </trans-unit>
        <trans-unit id="13c1d4abaa2e24db688c942bc44506eecb997ffd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt; method is called and this method has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the &lt;a href=&quot;#http_response_getheader_name&quot;&gt;&lt;code&gt;response.getHeader()&lt;/code&gt;&lt;/a&gt; on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt;&lt;code&gt;response.setHeader()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하고,이 메소드가 호출되어 있지 않은, 직접적 내부 캐시 않고 네트워크 채널 상에 제공된 헤더 값을 쓸 것이고, &lt;a href=&quot;#http_response_getheader_name&quot;&gt; &lt;code&gt;response.getHeader()&lt;/code&gt; &lt;/a&gt; 헤더에 예상 결과를 얻을 수 없다. 향후 검색 및 수정이 가능한 점진적인 헤더 채우기가 필요한 경우 &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt; &lt;code&gt;response.setHeader()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c39f6015a6de86ba481a03db4cf0b880b07f9b9" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;s are used, each thread has an independent &lt;code&gt;async_hooks&lt;/code&gt; interface, and each thread will use a new set of async IDs.</source>
          <target state="translated">경우 &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 의를 사용하는 각 스레드는 독립적가 &lt;code&gt;async_hooks&lt;/code&gt; 의 인터페이스를, 각 스레드는 비동기 ID의 새로운 세트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c956ea5d54c56e56d6447ad458f6b0f837d61a41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cpu-prof-dir&lt;/code&gt; is not specified, the generated profile is placed in the current working directory.</source>
          <target state="translated">경우 &lt;code&gt;--cpu-prof-dir&lt;/code&gt; 지정하지 않으면 생성 된 프로파일은 현재 작업 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0871e8ec0ac48a52952a27247e63cbf0113f285d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cpu-prof-dir&lt;/code&gt; is not specified, the generated profile will be placed in the current working directory.</source>
          <target state="translated">경우 &lt;code&gt;--cpu-prof-dir&lt;/code&gt; 지정하지 않으면 생성 된 프로파일은 현재 작업 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b328bd1e7b2c1624919a595e7ae91f7636d4a889" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cpu-prof-name&lt;/code&gt; is not specified, the generated profile is named &lt;code&gt;CPU.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.cpuprofile&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--cpu-prof-name&lt;/code&gt; 지정되지 않은, 생성 된 프로파일은 이름이 &lt;code&gt;CPU.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.cpuprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f06f2cbbef2e0fb250e543666453b867b0203fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cpu-prof-name&lt;/code&gt; is not specified, the generated profile will be named &lt;code&gt;CPU.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.cpuprofile&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--cpu-prof-name&lt;/code&gt; 지정되지 않은, 생성 된 프로파일이 지정됩니다 &lt;code&gt;CPU.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.cpuprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="252f256b679b33839de5451abb1450ca761612a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--experimental-exports&lt;/code&gt; is enabled, Node.js allows packages loaded via &lt;code&gt;LOAD_NODE_MODULES&lt;/code&gt; to explicitly declare which file paths to expose and how they should be interpreted. This expands on the control packages already had using the &lt;code&gt;main&lt;/code&gt; field.</source>
          <target state="translated">경우 &lt;code&gt;--experimental-exports&lt;/code&gt; 활성화되어, Node.js를이를 통해로드 패키지 수 &lt;code&gt;LOAD_NODE_MODULES&lt;/code&gt; 명시 적으로 노출하고, 그들이 어떻게 해석해야하는 파일 경로 선언에 있습니다. 이것은 이미 &lt;code&gt;main&lt;/code&gt; 필드를 사용했던 제어 패키지에서 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="46808db73a3f4a6eed12baed7fabb79cceca0198" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--heap-prof-dir&lt;/code&gt; is not specified, the generated profile is placed in the current working directory.</source>
          <target state="translated">경우 &lt;code&gt;--heap-prof-dir&lt;/code&gt; 지정하지 않으면 생성 된 프로파일은 현재 작업 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="eb76738d0d5b293cfa7a0ef70a7b9988c388ff9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--heap-prof-dir&lt;/code&gt; is not specified, the generated profile will be placed in the current working directory.</source>
          <target state="translated">경우 &lt;code&gt;--heap-prof-dir&lt;/code&gt; 지정하지 않으면 생성 된 프로파일은 현재 작업 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="076f4fd015725cda7188f51c19f4dcbee4c431b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--heap-prof-name&lt;/code&gt; is not specified, the generated profile is named &lt;code&gt;Heap.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.heapprofile&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--heap-prof-name&lt;/code&gt; 지정되지 않은, 생성 된 프로파일은 이름이 &lt;code&gt;Heap.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.heapprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46da7a20ea57b72f58b0fe3ec3917cf72b3a7d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--heap-prof-name&lt;/code&gt; is not specified, the generated profile will be named &lt;code&gt;Heap.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.heapprofile&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--heap-prof-name&lt;/code&gt; 지정되지 않은, 생성 된 프로파일이 지정됩니다 &lt;code&gt;Heap.${yyyymmdd}.${hhmmss}.${pid}.${tid}.${seq}.heapprofile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a980a9bd1025b824afd68b7411862ede9f40818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--use-openssl-ca&lt;/code&gt; is enabled, this overrides and sets OpenSSL's directory containing trusted certificates.</source>
          <target state="translated">경우 &lt;code&gt;--use-openssl-ca&lt;/code&gt; 활성화되어,이 오버라이드 (override)과 세트에는 OpenSSL의 디렉토리 신뢰할 수있는 인증서를 포함.</target>
        </trans-unit>
        <trans-unit id="2fb80a9ef49b333f19355375aacc43b97c24f1e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--use-openssl-ca&lt;/code&gt; is enabled, this overrides and sets OpenSSL's file containing trusted certificates.</source>
          <target state="translated">경우 &lt;code&gt;--use-openssl-ca&lt;/code&gt; 활성화되어,이 오버라이드 (override)과 세트에는 OpenSSL의 파일을 신뢰할 수있는 인증서를 포함.</target>
        </trans-unit>
        <trans-unit id="7e11b3232ffd9dab8c9348cab833faebe15ef6ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;address&lt;/code&gt; is not a valid IP address, a &lt;code&gt;TypeError&lt;/code&gt; will be thrown. The &lt;code&gt;port&lt;/code&gt; will be coerced to a number. If it is not a legal port, a &lt;code&gt;TypeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;address&lt;/code&gt; 가 유효한 IP 주소 가 아닌 경우 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다. &lt;code&gt;port&lt;/code&gt; 숫자로 강제됩니다. 유효한 포트가 아닌 경우 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06237a5cef98b7f52bc3e886d3ada2f6638389c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;algorithm&lt;/code&gt; is provided as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt;, it must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f000879e89ab14159b880cd8a642ceb5bc654f91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;algorithm&lt;/code&gt; is provided as an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;&amp;lt;Object&amp;gt;&lt;/a&gt;, it must have a &lt;code&gt;name&lt;/code&gt; property whose value is one of the above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd8be5407b5fb181647c0388b364a8265244634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowHalfOpen&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, when the other end of the socket sends a FIN packet, the server will only send a FIN packet back when &lt;a href=&quot;#net_socket_end_data_encoding_callback&quot;&gt;&lt;code&gt;socket.end()&lt;/code&gt;&lt;/a&gt; is explicitly called, until then the connection is half-closed (non-readable but still writable). See &lt;a href=&quot;#net_event_end&quot;&gt;&lt;code&gt;'end'&lt;/code&gt;&lt;/a&gt; event and &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;RFC 1122&lt;/a&gt; (section 4.2.2.13) for more information.</source>
          <target state="translated">경우 &lt;code&gt;allowHalfOpen&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; 소켓의 다른 쪽 끝은 FIN 패킷을 전송하면, 서버는 단지 FIN 패킷 다시 보내드립니다 &lt;a href=&quot;#net_socket_end_data_encoding_callback&quot;&gt; &lt;code&gt;socket.end()&lt;/code&gt; &lt;/a&gt; 연결이 (비 읽을 반 닫혀 그때까지, 명시 적으로 호출된다 여전히 쓸 수 있음). 자세한 내용은 &lt;a href=&quot;#net_event_end&quot;&gt; &lt;code&gt;'end'&lt;/code&gt; &lt;/a&gt; 이벤트 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc1122&quot;&gt;RFC 1122&lt;/a&gt; (섹션 4.2.2.13)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6058ee035a415370db1a3db640b04683644860b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;asyncFn&lt;/code&gt; is a function and it throws an error synchronously, &lt;code&gt;assert.doesNotReject()&lt;/code&gt; will return a rejected &lt;code&gt;Promise&lt;/code&gt; with that error. If the function does not return a promise, &lt;code&gt;assert.doesNotReject()&lt;/code&gt; will return a rejected &lt;code&gt;Promise&lt;/code&gt; with an &lt;a href=&quot;errors#errors_err_invalid_return_value&quot;&gt;&lt;code&gt;ERR_INVALID_RETURN_VALUE&lt;/code&gt;&lt;/a&gt; error. In both cases the error handler is skipped.</source>
          <target state="translated">경우 &lt;code&gt;asyncFn&lt;/code&gt; 이 함수하고, 동기 에러가 발생 &lt;code&gt;assert.doesNotReject()&lt;/code&gt; 거부 반환 &lt;code&gt;Promise&lt;/code&gt; 그 오류. 함수가 약속을 반환하지 않으면 &lt;code&gt;assert.doesNotReject()&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_err_invalid_return_value&quot;&gt; &lt;code&gt;ERR_INVALID_RETURN_VALUE&lt;/code&gt; &lt;/a&gt; 오류 와 함께 거부 된 &lt;code&gt;Promise&lt;/code&gt; 을 반환합니다 . 두 경우 모두 오류 처리기를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="41ea89f36eae232beb7b436e30b4cf63aba4bfd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;asyncFn&lt;/code&gt; is a function and it throws an error synchronously, &lt;code&gt;assert.rejects()&lt;/code&gt; will return a rejected &lt;code&gt;Promise&lt;/code&gt; with that error. If the function does not return a promise, &lt;code&gt;assert.rejects()&lt;/code&gt; will return a rejected &lt;code&gt;Promise&lt;/code&gt; with an &lt;a href=&quot;errors#errors_err_invalid_return_value&quot;&gt;&lt;code&gt;ERR_INVALID_RETURN_VALUE&lt;/code&gt;&lt;/a&gt; error. In both cases the error handler is skipped.</source>
          <target state="translated">경우 &lt;code&gt;asyncFn&lt;/code&gt; 는 함수이며 동기 에러가 발생, &lt;code&gt;assert.rejects()&lt;/code&gt; 거부 반환 &lt;code&gt;Promise&lt;/code&gt; 그 오류. 함수가 약속을 반환하지 않으면 &lt;code&gt;assert.rejects()&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_err_invalid_return_value&quot;&gt; &lt;code&gt;ERR_INVALID_RETURN_VALUE&lt;/code&gt; &lt;/a&gt; 오류 와 함께 거부 된 &lt;code&gt;Promise&lt;/code&gt; 을 반환합니다 . 두 경우 모두 오류 처리기를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="59c43e5b8c09c005a303cada9f14ee3496dfd208" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autoClose&lt;/code&gt; is false, then the file descriptor won't be closed, even if there's an error. It is the application's responsibility to close it and make sure there's no file descriptor leak. If &lt;code&gt;autoClose&lt;/code&gt; is set to true (default behavior), on &lt;code&gt;'error'&lt;/code&gt; or &lt;code&gt;'end'&lt;/code&gt; the file descriptor will be closed automatically.</source>
          <target state="translated">&lt;code&gt;autoClose&lt;/code&gt; 가 false 이면 오류 가 있어도 파일 디스크립터가 닫히지 않습니다. 응용 프로그램은 응용 프로그램을 닫고 파일 디스크립터 누출이 없는지 확인해야합니다. &lt;code&gt;autoClose&lt;/code&gt; 가 true (기본 동작)로 설정 되면 &lt;code&gt;'error'&lt;/code&gt; 또는 &lt;code&gt;'end'&lt;/code&gt; 에서 파일 설명자가 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="539b14e864af1c39151389953522f5a823d83c18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autoClose&lt;/code&gt; is set to true (default behavior) on &lt;code&gt;'error'&lt;/code&gt; or &lt;code&gt;'finish'&lt;/code&gt; the file descriptor will be closed automatically. If &lt;code&gt;autoClose&lt;/code&gt; is false, then the file descriptor won't be closed, even if there's an error. It is the application's responsibility to close it and make sure there's no file descriptor leak.</source>
          <target state="translated">경우 &lt;code&gt;autoClose&lt;/code&gt; 에 참 (기본 동작)로 설정되어 &lt;code&gt;'error'&lt;/code&gt; 또는 &lt;code&gt;'finish'&lt;/code&gt; 파일 기술자가 자동으로 종료됩니다. &lt;code&gt;autoClose&lt;/code&gt; 가 false 이면 오류 가 있어도 파일 디스크립터가 닫히지 않습니다. 응용 프로그램은 응용 프로그램을 닫고 파일 디스크립터 누출이 없는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="884077a55ab26855c918c881218b89b04b494140" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;byteOffset&lt;/code&gt; is not a number, it will be coerced to a number. Any arguments that coerce to &lt;code&gt;NaN&lt;/code&gt;, like &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, will search the whole buffer. This behavior matches &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf&quot;&gt;&lt;code&gt;String#lastIndexOf()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;byteOffset&lt;/code&gt; 은 숫자가 아니라,이 숫자로 강제됩니다. &lt;code&gt;{}&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 와 같이 &lt;code&gt;NaN&lt;/code&gt; 을 강제하는 모든 인수 는 전체 버퍼를 검색합니다. 이 동작은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf&quot;&gt; &lt;code&gt;String#lastIndexOf()&lt;/code&gt; &lt;/a&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="b7b130c5da2c6867ef71cd5fe02db9d69ebd0795" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;byteOffset&lt;/code&gt; is not a number, it will be coerced to a number. If the result of coercion is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;, then the entire buffer will be searched. This behavior matches &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf&quot;&gt;&lt;code&gt;String#indexOf()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;byteOffset&lt;/code&gt; 은 숫자가 아니라,이 숫자로 강제됩니다. 강제 변환의 결과가 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 이면 전체 버퍼가 검색됩니다. 이 동작은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf&quot;&gt; &lt;code&gt;String#indexOf()&lt;/code&gt; &lt;/a&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="c590e6de95cfddb8ed4a4d519ab06c0bb835b03a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is not a function, a &lt;a href=&quot;errors#errors_class_typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 이 함수가 아닌 경우 &lt;a href=&quot;errors#errors_class_typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0f96bd4f40d4ce94291921e72da0a0dee934b282" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is provided, it is not invoked until all active sessions have been closed, although the server has already stopped allowing new sessions. See &lt;a href=&quot;net#net_server_close_callback&quot;&gt;&lt;code&gt;net.Server.close()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 제공되는 모든 활성 세션이 종료 될 때까지 서버가 이미 새로운 세션을 허용 중단했지만, 그것은, 호출되지 않습니다. 자세한 내용은 &lt;a href=&quot;net#net_server_close_callback&quot;&gt; &lt;code&gt;net.Server.close()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="598b066902e0bb1da7edca563a32a66a0b6c3b13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is provided, it is not invoked until all active sessions have been closed, although the server has already stopped allowing new sessions. See &lt;a href=&quot;tls#tls_server_close_callback&quot;&gt;&lt;code&gt;tls.Server.close()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 제공되는 모든 활성 세션이 종료 될 때까지 서버가 이미 새로운 세션을 허용 중단했지만, 그것은, 호출되지 않습니다. 자세한 내용은 &lt;a href=&quot;tls#tls_server_close_callback&quot;&gt; &lt;code&gt;tls.Server.close()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4321180d73b6506962002c0e8c30474f65569ce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is specified, it will be called when the request stream is finished.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 지정된 요청 스트림이 완료 될 때, 그것은 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="289f877647833459c9661200af57b09de3403f4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; is specified, it will be called when the response stream is finished.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 지정된 응답 스트림이 완료 될 때, 그것은 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0f682b366e2b92062347f100026ce608fcb842e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextObject&lt;/code&gt; is omitted (or passed explicitly as &lt;code&gt;undefined&lt;/code&gt;), a new, empty &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;contextified&lt;/a&gt; object will be returned.</source>
          <target state="translated">&lt;code&gt;contextObject&lt;/code&gt; 가 생략 된 경우 (또는 &lt;code&gt;undefined&lt;/code&gt; 로 명시 적으로 전달됨 ) &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;컨텍스트 화&lt;/a&gt; 된 새 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa93683434fd29bb44a881093da31d55c3a7e23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is specified, it is equivalent to calling &lt;a href=&quot;#http_request_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;request.write(data, encoding)&lt;/code&gt;&lt;/a&gt; followed by &lt;code&gt;request.end(callback)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 지정된 경우는 호출하는 것과 &lt;a href=&quot;#http_request_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;request.write(data, encoding)&lt;/code&gt; &lt;/a&gt; 하였다 &lt;code&gt;request.end(callback)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8427d4b682c9e1679aa15d985063ddcd570ecf5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is specified, it is equivalent to calling &lt;a href=&quot;http#http_response_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;response.write(data, encoding)&lt;/code&gt;&lt;/a&gt; followed by &lt;code&gt;response.end(callback)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 지정된 경우는 호출하는 것과 &lt;a href=&quot;http#http_response_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;response.write(data, encoding)&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;response.end(callback)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="229ece6c8182b142b9ec817aaf04f94cce304527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is specified, it is equivalent to calling &lt;code&gt;socket.write(data, encoding)&lt;/code&gt; followed by &lt;a href=&quot;#net_socket_end_data_encoding_callback&quot;&gt;&lt;code&gt;socket.end()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 지정되어,이 호출하는 것과 &lt;code&gt;socket.write(data, encoding)&lt;/code&gt; 하였다 &lt;a href=&quot;#net_socket_end_data_encoding_callback&quot;&gt; &lt;code&gt;socket.end()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0071baccfdde3653b128f8b8005e7668d6faf522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is specified, it is similar in effect to calling &lt;a href=&quot;#http_response_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;response.write(data, encoding)&lt;/code&gt;&lt;/a&gt; followed by &lt;code&gt;response.end(callback)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 지정되면 그 전화에 사실상 유사하다 &lt;a href=&quot;#http_response_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;response.write(data, encoding)&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;response.end(callback)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1429cd543300865d3187bd54d6de4ff5a31b2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;digest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;'sha1'&lt;/code&gt; will be used. This behavior is deprecated, please specify a &lt;code&gt;digest&lt;/code&gt; explicitly.</source>
          <target state="translated">경우 &lt;code&gt;digest&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;'sha1'&lt;/code&gt; 사용됩니다. 이 동작은 더 이상 사용되지 않습니다 . &lt;code&gt;digest&lt;/code&gt; 명시 적으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b813d6da2b0b11ab1d154cf1275755cbb847a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is &lt;code&gt;'utf8'&lt;/code&gt; and a byte sequence in the input is not valid UTF-8, then each invalid byte is replaced with the replacement character &lt;code&gt;U+FFFD&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 인 &lt;code&gt;'utf8'&lt;/code&gt; 과 입력의 바이트 순서가 유효하지 UTF-8이며, 각 무효 바이트 대체 문자로 대체 &lt;code&gt;U+FFFD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="296de98e0eac254a8d7d501b18c4e257eafcc0da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is provided a string is returned; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 제공되는 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3c255effb35f8dcbf9e574c3558ceb3e16a170" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is specified, a string is returned; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 지정하는 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="02dfbed9e2c0a8c31f6ac956adbe7f6a81882d56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exception&lt;/code&gt; is specified, an &lt;a href=&quot;#net_event_error_1&quot;&gt;&lt;code&gt;'error'&lt;/code&gt;&lt;/a&gt; event will be emitted and any listeners for that event will receive &lt;code&gt;exception&lt;/code&gt; as an argument.</source>
          <target state="translated">경우 &lt;code&gt;exception&lt;/code&gt; 지정되어, &lt;a href=&quot;#net_event_error_1&quot;&gt; &lt;code&gt;'error'&lt;/code&gt; &lt;/a&gt; 이벤트가 방출되며, 해당 이벤트에 대한 리스너가 나타납니다 &lt;code&gt;exception&lt;/code&gt; 인수로.</target>
        </trans-unit>
        <trans-unit id="299ba421d8d3b42b4b24e019249c38c9a00df27b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (default), then cluster workers will use the same underlying handle, allowing connection handling duties to be shared. When &lt;code&gt;exclusive&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the handle is not shared, and attempted port sharing results in an error. An example which listens on an exclusive port is shown below.</source>
          <target state="translated">경우 &lt;code&gt;exclusive&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; (기본), 다음 클러스터 근로자가 업무를 처리하는 연결을 공유 할 수 있도록, 동일한 기본 핸들을 사용합니다. 때 &lt;code&gt;exclusive&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 핸들 공유하고, 오류가 포트 공유 결과를 시도되지 않습니다. 전용 포트에서 수신 대기하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8d2e28ac1ebbc4f0807dc298e38f7537f901ffe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fd&lt;/code&gt; is specified, &lt;code&gt;ReadStream&lt;/code&gt; will ignore the &lt;code&gt;path&lt;/code&gt; argument and will use the specified file descriptor. This means that no &lt;code&gt;'open'&lt;/code&gt; event will be emitted. &lt;code&gt;fd&lt;/code&gt; should be blocking; non-blocking &lt;code&gt;fd&lt;/code&gt;s should be passed to &lt;a href=&quot;net#net_class_net_socket&quot;&gt;&lt;code&gt;net.Socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fd&lt;/code&gt; 지정되어, &lt;code&gt;ReadStream&lt;/code&gt; 는 무시됩니다 &lt;code&gt;path&lt;/code&gt; 인수를 지정된 파일 기술자를 사용합니다. 이것은 &lt;code&gt;'open'&lt;/code&gt; 이벤트가 발생 하지 않음을 의미합니다 . &lt;code&gt;fd&lt;/code&gt; 는 차단해야합니다. 비 블로킹 &lt;code&gt;fd&lt;/code&gt; 는 &lt;a href=&quot;net#net_class_net_socket&quot;&gt; &lt;code&gt;net.Socket&lt;/code&gt; &lt;/a&gt; 으로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c06cb9ca6ab1bd04773000c7b74c88e6ca5c2f4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fd&lt;/code&gt; points to a character device that only supports blocking reads (such as keyboard or sound card), read operations do not finish until data is available. This can prevent the process from exiting and the stream from closing naturally.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; 가 키보드 또는 사운드 카드와 같은 읽기 차단 만 지원하는 문자 장치를 가리키는 경우 데이터를 사용할 수있을 때까지 읽기 작업이 완료되지 않습니다. 이로 인해 프로세스가 종료되고 스트림이 자연스럽게 닫히지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be4332a701df441e4c063382aa8feb5526f88ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fill&lt;/code&gt; is specified, the allocated &lt;code&gt;Buffer&lt;/code&gt; will be initialized by calling &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt;&lt;code&gt;buf.fill(fill)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fill&lt;/code&gt; 지정, 할당 된 &lt;code&gt;Buffer&lt;/code&gt; 호출에 의해 초기화됩니다 &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt; &lt;code&gt;buf.fill(fill)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3be97fb9c90af79625c081ca884c9f352b0b66b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not specified the point will be returned in &lt;code&gt;'uncompressed'&lt;/code&gt; format.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 지정되지 않은 점에 반환됩니다 &lt;code&gt;'uncompressed'&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="211c8e7cb128633f9dd54be0102b93101df16008" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generatorEncoding&lt;/code&gt; is specified, &lt;code&gt;generator&lt;/code&gt; is expected to be a string; otherwise a number, &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt; is expected.</source>
          <target state="translated">경우 &lt;code&gt;generatorEncoding&lt;/code&gt; 가 지정되어, &lt;code&gt;generator&lt;/code&gt; 문자열 것으로 예상된다; 그렇지 않으면 숫자, &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;TypedArray&lt;/code&gt; 또는 &lt;code&gt;DataView&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ee915a37cf5a4e8d149f7db663f7692db584ed38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;host&lt;/code&gt; is omitted, the server will accept connections on the &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;unspecified IPv6 address&lt;/a&gt; (&lt;code&gt;::&lt;/code&gt;) when IPv6 is available, or the &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;unspecified IPv4 address&lt;/a&gt; (&lt;code&gt;0.0.0.0&lt;/code&gt;) otherwise.</source>
          <target state="translated">경우 &lt;code&gt;host&lt;/code&gt; 생략되고, 서버가에 대한 연결을 받아 &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;지정되지 않은 IPv6 주소를&lt;/a&gt; ( &lt;code&gt;::&lt;/code&gt; ) IPv6를 사용할 수있는, 또는 경우에 &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;지정되지 않은 IPv4 주소&lt;/a&gt; ( &lt;code&gt;0.0.0.0&lt;/code&gt; 기타).</target>
        </trans-unit>
        <trans-unit id="327688667cc4714ad942e8a15185ccc1e19c6211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialize()&lt;/code&gt; is called more than once, an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719ee6233d43eb6f4cfa33ac467d8a54df639b11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;key&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the following additional properties can be passed:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수는 마치 &lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 전달 된 것처럼 동작 합니다. 객체 인 경우 다음과 같은 추가 속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fc09dc2e7135ef58e69c84b714e24c8a051eadf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;key&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the &lt;code&gt;padding&lt;/code&gt; property can be passed. Otherwise, this function uses &lt;code&gt;RSA_PKCS1_OAEP_PADDING&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수는 마치 &lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 건네진 것처럼 동작 합니다. 객체 인 경우 &lt;code&gt;padding&lt;/code&gt; 속성을 전달할 수 있습니다. 그렇지 않으면이 함수는 &lt;code&gt;RSA_PKCS1_OAEP_PADDING&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="25511a88834e5e5b625f424cd7943dcdd0e90291" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;key&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the &lt;code&gt;padding&lt;/code&gt; property can be passed. Otherwise, this function uses &lt;code&gt;RSA_PKCS1_PADDING&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수는 마치 &lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 건네진 것처럼 동작 합니다. 객체 인 경우 &lt;code&gt;padding&lt;/code&gt; 속성을 전달할 수 있습니다. 그렇지 않으면이 함수는 &lt;code&gt;RSA_PKCS1_PADDING&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="977d93db6bb5497a6e85df4c62341e37909f95ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;key&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the following additional properties can be passed:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수는 마치 &lt;code&gt;key&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 건네진 것처럼 동작 합니다. 객체 인 경우 다음과 같은 추가 속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed062de2af3cd39b12412e99a474c3e9d61d8c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is specified, &lt;code&gt;data&lt;/code&gt; is ignored.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 지정되고, &lt;code&gt;data&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b27055bc56379296ff853efbb8b5e12f047e7e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;message&lt;/code&gt; is falsy, the error message is set as the values of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; separated by the provided &lt;code&gt;operator&lt;/code&gt;. If just the two &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; arguments are provided, &lt;code&gt;operator&lt;/code&gt; will default to &lt;code&gt;'!='&lt;/code&gt;. If &lt;code&gt;message&lt;/code&gt; is provided as third argument it will be used as the error message and the other arguments will be stored as properties on the thrown object. If &lt;code&gt;stackStartFn&lt;/code&gt; is provided, all stack frames above that function will be removed from stacktrace (see &lt;a href=&quot;errors#errors_error_capturestacktrace_targetobject_constructoropt&quot;&gt;&lt;code&gt;Error.captureStackTrace&lt;/code&gt;&lt;/a&gt;). If no arguments are given, the default message &lt;code&gt;Failed&lt;/code&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;message&lt;/code&gt; falsy되면, 에러 메시지의 값으로 설정되고 &lt;code&gt;actual&lt;/code&gt; 와 &lt;code&gt;expected&lt;/code&gt; 제공된 의해 분리 &lt;code&gt;operator&lt;/code&gt; . 두 개의 &lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;expected&lt;/code&gt; 인수 만 제공되는 경우 &lt;code&gt;operator&lt;/code&gt; 는 기본적으로 &lt;code&gt;'!='&lt;/code&gt; 입니다. 경우 &lt;code&gt;message&lt;/code&gt; 세 번째 인수로 제공됩니다 그것은 오류 메시지로 사용되며, 다른 인수는 던져 객체에 속성으로 저장됩니다. 경우 &lt;code&gt;stackStartFn&lt;/code&gt; 가 제공되고, 그 기능 모두 상기 스택 프레임이 스택 트레이스 (참조에서 삭제 &lt;a href=&quot;errors#errors_error_capturestacktrace_targetobject_constructoropt&quot;&gt; &lt;code&gt;Error.captureStackTrace&lt;/code&gt; 을&lt;/a&gt; ). 인수가 없으면 기본 메시지 &lt;code&gt;Failed&lt;/code&gt; 으로 사용될 것.</target>
        </trans-unit>
        <trans-unit id="a18434d4349cf91c980feeaf73d4500129ed008e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;multicastInterface&lt;/code&gt; can not be parsed into an IP then an &lt;em&gt;EINVAL&lt;/em&gt;&lt;a href=&quot;errors#errors_class_systemerror&quot;&gt;&lt;code&gt;System Error&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;multicastInterface&lt;/code&gt; 이 다음 IP로 해석 할 수없는 &lt;em&gt;EINVAL &lt;/em&gt;&lt;a href=&quot;errors#errors_class_systemerror&quot;&gt; &lt;code&gt;System Error&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="635a5a9f736b1a79cca9c640330c3981e6630269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;multicastInterface&lt;/code&gt; is not specified, the operating system will attempt to drop membership on all valid interfaces.</source>
          <target state="translated">경우 &lt;code&gt;multicastInterface&lt;/code&gt; 가 지정되지 않은 운영 체제는 유효한 모든 인터페이스에 회원을 드롭을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a04eb70c5e8fdd2359e97890a6ec4806a1c90780" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is equal to &lt;code&gt;Http2Session&lt;/code&gt;, the &lt;code&gt;PerformanceEntry&lt;/code&gt; will contain the following additional properties:</source>
          <target state="translated">경우 &lt;code&gt;name&lt;/code&gt; 동일 &lt;code&gt;Http2Session&lt;/code&gt; 의 &lt;code&gt;PerformanceEntry&lt;/code&gt; 는 다음과 같은 추가 속성을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="1c0c762bb6f101345ae8084fe010dead16e44a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is equal to &lt;code&gt;Http2Stream&lt;/code&gt;, the &lt;code&gt;PerformanceEntry&lt;/code&gt; will contain the following additional properties:</source>
          <target state="translated">경우 &lt;code&gt;name&lt;/code&gt; 동일 &lt;code&gt;Http2Stream&lt;/code&gt; 의 &lt;code&gt;PerformanceEntry&lt;/code&gt; 는 다음과 같은 추가 속성을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="74804bac51eaf2ff8552dfa185b4e1083041d783" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not provided, removes all &lt;code&gt;PerformanceMark&lt;/code&gt; objects from the Performance Timeline. If &lt;code&gt;name&lt;/code&gt; is provided, removes only the named mark.</source>
          <target state="translated">경우 &lt;code&gt;name&lt;/code&gt; 제공되지 않으며, 모든 제거 &lt;code&gt;PerformanceMark&lt;/code&gt; 의 성능 타임 라인에서 개체를. &lt;code&gt;name&lt;/code&gt; 이 제공 되면 이름 이 지정된 마크 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ff70118da58af5946e19a41a79f8faa2f7cc7721" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is from a different &lt;code&gt;vm.Context&lt;/code&gt; now, a custom inspection function on it will not receive context-specific arguments anymore.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 가 다른 &lt;code&gt;vm.Context&lt;/code&gt; 에서 가져온 경우 개체 에 대한 사용자 지정 검사 함수는 더 이상 컨텍스트 별 인수를 수신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="943eaf90edddd945e52ae31efebbc68f45ee6623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;object&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the following additional properties can be passed:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수는 마치 &lt;code&gt;object&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 건네진 것처럼 동작 합니다 . 객체 인 경우 다음과 같은 추가 속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0100c981edb805a108cdf076550a8ed70a08660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;offset&lt;/code&gt; is set to a non-negative number, reading starts from that position and the file offset will not be advanced. If &lt;code&gt;length&lt;/code&gt; is set to a non-negative number, it gives the maximum number of bytes that are read from the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868e2ef584eeb787a1b334b2b183edf477e0a4fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options.withFileTypes&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;files&lt;/code&gt; array will contain &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt;&lt;code&gt;fs.Dirent&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">경우 &lt;code&gt;options.withFileTypes&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; 의 &lt;code&gt;files&lt;/code&gt; 배열이 포함됩니다 &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt; &lt;code&gt;fs.Dirent&lt;/code&gt; 의&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="a36bfe70b4e433d3db03a6c9e94c12be8a171a8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options.withFileTypes&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the resolved array will contain &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt;&lt;code&gt;fs.Dirent&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">경우 &lt;code&gt;options.withFileTypes&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 해결 된 배열이 포함됩니다 &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt; &lt;code&gt;fs.Dirent&lt;/code&gt; 의&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="5e10e67408633d0ca404f3c048655c9f70ee664b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options.withFileTypes&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the result will contain &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt;&lt;code&gt;fs.Dirent&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">경우 &lt;code&gt;options.withFileTypes&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; , 결과는 포함 &lt;a href=&quot;#fs_class_fs_dirent&quot;&gt; &lt;code&gt;fs.Dirent&lt;/code&gt; 의&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="e345c64383dd053537ed6dbbf388ab57f2c56df5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is a string, then it specifies the encoding.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열이며, 다음은 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6ec565c6cdab6a8fe531bbf0a08728c7aaf43c9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is a string, then it specifies the encoding:</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열이며, 다음은 인코딩을 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="04daf1ad0c06f14a3e99c3afe2f811ebcde82a21" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is a string, then it specifies the filename.</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열이며, 다음은 파일 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="36b1ebb69a8523459611eb6b3154f41b194ea1b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is a string, then it specifies the input prompt:</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열이며, 그것은 입력 프롬프트를 지정합니다</target>
        </trans-unit>
        <trans-unit id="cedfd7167d9901968bba2de2300e68c96a571770" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputEncoding&lt;/code&gt; is given a string is returned; otherwise, a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;outputEncoding&lt;/code&gt; 이 부여 된 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb535f2bf23a7a6abbc7421b6d41c55bac4089c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputEncoding&lt;/code&gt; is given a string will be returned; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;outputEncoding&lt;/code&gt; 가 주어진 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="747ef625cb7ae2fc9d560c16586c896d5916b26d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputEncoding&lt;/code&gt; is provided a string is returned; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;outputEncoding&lt;/code&gt; 가 제공되는 문자열이 반환됩니다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6830ad9459746cf99d5ab30887459bdffee5b757" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; resolves to a socket or a pipe, the function will return a system dependent name for that object.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 소켓이나 파이프로 확인 함수는 객체의 시스템에 의존 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="666e07665c3e510f0678f95aa14068f16e22257c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pauseOnConnect&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then the socket associated with each incoming connection will be paused, and no data will be read from its handle. This allows connections to be passed between processes without any data being read by the original process. To begin reading data from a paused socket, call &lt;a href=&quot;#net_socket_resume&quot;&gt;&lt;code&gt;socket.resume()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pauseOnConnect&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 들어오는 각 연결과 관련된 소켓이 일시 중지되고 핸들에서 데이터를 읽지 않습니다. 이를 통해 원래 프로세스에서 데이터를 읽지 않고도 프로세스간에 연결을 전달할 수 있습니다. 일시 정지 된 소켓에서 데이터 읽기를 시작하려면 &lt;a href=&quot;#net_socket_resume&quot;&gt; &lt;code&gt;socket.resume()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f034544fed923247a1488a920237881dd61ef658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;port&lt;/code&gt; is omitted or is 0, the operating system will assign an arbitrary unused port, which can be retrieved by using &lt;code&gt;server.address().port&lt;/code&gt; after the &lt;a href=&quot;#net_event_listening&quot;&gt;&lt;code&gt;'listening'&lt;/code&gt;&lt;/a&gt; event has been emitted.</source>
          <target state="translated">경우 &lt;code&gt;port&lt;/code&gt; 생략되거나 0되는 운영 체제를 사용하여 검색 될 수있는 임의의 사용되지 않은 포트를 할당한다 &lt;code&gt;server.address().port&lt;/code&gt; 애프터 &lt;a href=&quot;#net_event_listening&quot;&gt; &lt;code&gt;'listening'&lt;/code&gt; &lt;/a&gt; 이벤트가 방출되었습니다.</target>
        </trans-unit>
        <trans-unit id="ad78f5857180aa52600cb852f3aab07932e36ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;port&lt;/code&gt; is specified, it behaves the same as &lt;a href=&quot;#net_server_listen_port_host_backlog_callback&quot;&gt; &lt;code&gt;server.listen([port[, host[, backlog]]][, callback])&lt;/code&gt;&lt;/a&gt;. Otherwise, if &lt;code&gt;path&lt;/code&gt; is specified, it behaves the same as &lt;a href=&quot;#net_server_listen_path_backlog_callback&quot;&gt;&lt;code&gt;server.listen(path[, backlog][, callback])&lt;/code&gt;&lt;/a&gt;. If none of them is specified, an error will be thrown.</source>
          <target state="translated">경우 &lt;code&gt;port&lt;/code&gt; 지정된 경우는 동일하게 동작 &lt;a href=&quot;#net_server_listen_port_host_backlog_callback&quot;&gt; &lt;code&gt;server.listen([port[, host[, backlog]]][, callback])&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면 &lt;code&gt;path&lt;/code&gt; 가 지정되면 &lt;a href=&quot;#net_server_listen_path_backlog_callback&quot;&gt; &lt;code&gt;server.listen(path[, backlog][, callback])&lt;/code&gt; &lt;/a&gt; 과 동일하게 작동합니다 . 이들 중 아무것도 지정되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19d2f74a2410539462b318a30f46eab23a8b33a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primeEncoding&lt;/code&gt; is specified, &lt;code&gt;prime&lt;/code&gt; is expected to be a string; otherwise a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt; is expected.</source>
          <target state="translated">경우 &lt;code&gt;primeEncoding&lt;/code&gt; 가 지정되어, &lt;code&gt;prime&lt;/code&gt; 문자열 것으로 예상된다; 그렇지 않으면 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;TypedArray&lt;/code&gt; 또는 &lt;code&gt;DataView&lt;/code&gt; 가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="d34f6ef5137207bf0272e051955badd1a1d8351e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;privateKey&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;privateKey&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the &lt;code&gt;padding&lt;/code&gt; property can be passed. Otherwise, this function uses &lt;code&gt;RSA_PKCS1_OAEP_PADDING&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수 는 &lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 전달 된 것처럼 동작 합니다. 객체 인 경우 &lt;code&gt;padding&lt;/code&gt; 속성을 전달할 수 있습니다. 그렇지 않으면이 함수는 &lt;code&gt;RSA_PKCS1_OAEP_PADDING&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="9ca7f1fd906e365d91374bb378b7368f3fa4dc5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;privateKey&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;privateKey&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the &lt;code&gt;padding&lt;/code&gt; property can be passed. Otherwise, this function uses &lt;code&gt;RSA_PKCS1_PADDING&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수 는 &lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 전달 된 것처럼 동작 합니다. 객체 인 경우 &lt;code&gt;padding&lt;/code&gt; 속성을 전달할 수 있습니다. 그렇지 않으면이 함수는 &lt;code&gt;RSA_PKCS1_PADDING&lt;/code&gt; 을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="b64f75f0f7790d158f233d338846a09cef8678a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;privateKey&lt;/code&gt; is not a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;, this function behaves as if &lt;code&gt;privateKey&lt;/code&gt; had been passed to &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt;. If it is an object, the following additional properties can be passed:</source>
          <target state="translated">&lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 ,이 함수 는 &lt;code&gt;privateKey&lt;/code&gt; 가 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 전달 된 것처럼 동작 합니다. 객체 인 경우 다음과 같은 추가 속성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed5ccaf3341448b5d6583d34e4187e903653d1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;privateKey&lt;/code&gt; is not valid for the curve specified when the &lt;code&gt;ECDH&lt;/code&gt; object was created, an error is thrown. Upon setting the private key, the associated public point (key) is also generated and set in the &lt;code&gt;ECDH&lt;/code&gt; object.</source>
          <target state="translated">경우 &lt;code&gt;privateKey&lt;/code&gt; 때 지정된 곡선 유효하지 않습니다 &lt;code&gt;ECDH&lt;/code&gt; 의 객체가 생성 된 오류가 발생합니다. 개인 키를 설정하면 관련 공개 지점 (키)도 생성되어 &lt;code&gt;ECDH&lt;/code&gt; 개체에 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e56e2d0b5e192e3b6e7c9010e1154dc149bbd03c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;promisify.custom&lt;/code&gt; is defined but is not a function, &lt;code&gt;promisify()&lt;/code&gt; will throw an error.</source>
          <target state="translated">경우 &lt;code&gt;promisify.custom&lt;/code&gt; 가 정의되어 있지만, 함수가 아닙니다 &lt;code&gt;promisify()&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb86b835f195413e40bda1bb6ce9230cbcfdcd73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;qlog&lt;/code&gt; support is enabled for &lt;code&gt;QuicSession&lt;/code&gt;, the &lt;code&gt;quicsession.qlog&lt;/code&gt; property provides a &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;stream.Readable&lt;/code&gt;&lt;/a&gt; that may be used to access the &lt;code&gt;qlog&lt;/code&gt; event data according to the &lt;a href=&quot;https://tools.ietf.org/id/draft-marx-qlog-event-definitions-quic-h3-00.html&quot;&gt;qlog standard&lt;/a&gt;. For client &lt;code&gt;QuicSessions&lt;/code&gt;, the &lt;code&gt;quicsession.qlog&lt;/code&gt; property will be &lt;code&gt;undefined&lt;/code&gt; until the &lt;code&gt;'qlog'&lt;/code&gt; event is emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d900a6909580365131a8cdb6404205f1322b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quicendpoint.bind()&lt;/code&gt; is called again while a previously returned &lt;code&gt;Promise&lt;/code&gt; is still pending or has already successfully resolved, the previously returned pending &lt;code&gt;Promise&lt;/code&gt; will be returned. If the additional call to &lt;code&gt;quicendpoint.bind()&lt;/code&gt; contains an &lt;code&gt;AbortSignal&lt;/code&gt;, the &lt;code&gt;signal&lt;/code&gt; will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd43992f7d8a465a7ae1f17ab5cdd802e52d216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quicsession.authenticated&lt;/code&gt; is false, returns an &lt;code&gt;Error&lt;/code&gt; object representing the reason the peer certificate verification failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a428e5685a1eecd77b073b8d2143177ae423a02d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handle&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, an opaque value will be stored in it that must later be passed to &lt;a href=&quot;#n_api_napi_remove_async_cleanup_hook&quot;&gt;&lt;code&gt;napi_remove_async_cleanup_hook&lt;/code&gt;&lt;/a&gt;, regardless of whether the hook has already been invoked. Typically, that happens when the resource for which this hook was added is being torn down anyway.</source>
          <target state="translated">경우 &lt;code&gt;remove_handle&lt;/code&gt; 이 아닌 &lt;code&gt;NULL&lt;/code&gt; , 불투명 한 값은 이후에 전달해야 그 안에 저장됩니다 &lt;a href=&quot;#n_api_napi_remove_async_cleanup_hook&quot;&gt; &lt;code&gt;napi_remove_async_cleanup_hook&lt;/code&gt; &lt;/a&gt; 에 관계없이 후크가 이미 호출되었는지 여부. 일반적으로이 후크가 추가 된 리소스가 어쨌든 해체 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76d38c015ea70b86473f47208435ce10352c8cb7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.abort()&lt;/code&gt; is called after the response is received, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.abort()&lt;/code&gt; 응답을 수신 한 후 호출, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="ac39dd7a83d0438046abda60d7ebba2f164ba86f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.abort()&lt;/code&gt; is called before a socket is assigned, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.abort()&lt;/code&gt; 소켓이 할당되기 전에 호출되고, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="20fd599f5dc57b9bcf900426d809a999de12a6ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.abort()&lt;/code&gt; is called before the connection succeeds, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.abort()&lt;/code&gt; 연결이 성공하기 전에 호출, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="7e61006bf873b21175e0a7655ab4c8c9155d0f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.destroy()&lt;/code&gt; is called after the response is received, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.destroy()&lt;/code&gt; 응답을 수신 한 후 호출, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="52b442b5e12efeace0497cdb8a49e08b15aa7132" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.destroy()&lt;/code&gt; is called before a socket is assigned, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.destroy()&lt;/code&gt; 소켓이 할당되기 전에 호출되고, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="474ac3eed3560f7a4ecd75c3a1f21b7db6d67ea5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;req.destroy()&lt;/code&gt; is called before the connection succeeds, the following events will be emitted in the following order:</source>
          <target state="translated">경우 &lt;code&gt;req.destroy()&lt;/code&gt; 연결이 성공하기 전에 호출, 다음 이벤트는 다음과 같은 순서로 방출 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="64979e154ec2e18ac52da0c320fc458853136631" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sandbox&lt;/code&gt; is omitted (or passed explicitly as &lt;code&gt;undefined&lt;/code&gt;), a new, empty &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;contextified&lt;/a&gt; sandbox object will be returned.</source>
          <target state="translated">경우 &lt;code&gt;sandbox&lt;/code&gt; 생략 (또는 명시 적으로 전달되는 &lt;code&gt;undefined&lt;/code&gt; ), 비어있는 새 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;contextified&lt;/a&gt; 샌드 박스 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="404036cef8a63f83edac642a2000d9fb9795c0d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is larger than &lt;a href=&quot;#buffer_buffer_constants_max_length&quot;&gt;&lt;code&gt;buffer.constants.MAX_LENGTH&lt;/code&gt;&lt;/a&gt; or smaller than 0, &lt;a href=&quot;errors#ERR_INVALID_ARG_VALUE&quot;&gt;&lt;code&gt;ERR_INVALID_ARG_VALUE&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118dd010e332cc9200cff922a212475eb1c3a38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is larger than &lt;a href=&quot;#buffer_buffer_constants_max_length&quot;&gt;&lt;code&gt;buffer.constants.MAX_LENGTH&lt;/code&gt;&lt;/a&gt; or smaller than 0, &lt;a href=&quot;errors#ERR_INVALID_OPT_VALUE&quot;&gt;&lt;code&gt;ERR_INVALID_OPT_VALUE&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 보다 큰 &lt;a href=&quot;#buffer_buffer_constants_max_length&quot;&gt; &lt;code&gt;buffer.constants.MAX_LENGTH&lt;/code&gt; &lt;/a&gt; 0보다 작은, &lt;a href=&quot;errors#ERR_INVALID_OPT_VALUE&quot;&gt; &lt;code&gt;ERR_INVALID_OPT_VALUE&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="edb4b13e975465cae50651e76011131a05d803bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is larger than &lt;a href=&quot;#buffer_buffer_constants_max_length&quot;&gt;&lt;code&gt;buffer.constants.MAX_LENGTH&lt;/code&gt;&lt;/a&gt; or smaller than 0, &lt;a href=&quot;errors#ERR_INVALID_OPT_VALUE&quot;&gt;&lt;code&gt;ERR_INVALID_OPT_VALUE&lt;/code&gt;&lt;/a&gt; is thrown. A zero-length &lt;code&gt;Buffer&lt;/code&gt; is created if &lt;code&gt;size&lt;/code&gt; is 0.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 보다 큰 &lt;a href=&quot;#buffer_buffer_constants_max_length&quot;&gt; &lt;code&gt;buffer.constants.MAX_LENGTH&lt;/code&gt; &lt;/a&gt; 0보다 작은, &lt;a href=&quot;errors#ERR_INVALID_OPT_VALUE&quot;&gt; &lt;code&gt;ERR_INVALID_OPT_VALUE&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 제로 길이 &lt;code&gt;Buffer&lt;/code&gt; 가 작성되고 &lt;code&gt;size&lt;/code&gt; 0이다.</target>
        </trans-unit>
        <trans-unit id="4fd544099a496b9d4f88c55eeb5a36cc47420cfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;socket.setTimeout()&lt;/code&gt; is called here, the timeout will be replaced with &lt;code&gt;server.keepAliveTimeout&lt;/code&gt; when the socket has served a request (if &lt;code&gt;server.keepAliveTimeout&lt;/code&gt; is non-zero).</source>
          <target state="translated">경우 &lt;code&gt;socket.setTimeout()&lt;/code&gt; 여기라고, 타임 아웃은 대체됩니다 &lt;code&gt;server.keepAliveTimeout&lt;/code&gt; (경우 소켓이 요청을 제공 한 경우 &lt;code&gt;server.keepAliveTimeout&lt;/code&gt; 이 제로가 아닌).</target>
        </trans-unit>
        <trans-unit id="97507a5ed7da468aa32a5b701f6b82666385206c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start()&lt;/code&gt; is called more than once, an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1715f20858e56c791aabf4e500684d534a453896" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stdin: true&lt;/code&gt; was passed to the &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; constructor, this is a writable stream. The data written to this stream will be made available in the worker thread as &lt;a href=&quot;process#process_process_stdin&quot;&gt;&lt;code&gt;process.stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;stdin: true&lt;/code&gt; 에 전달 된 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 생성자,이 쓰기 가능한 스트림입니다. 이 스트림에 기록 된 데이터는 작업자 스레드에서 &lt;a href=&quot;process#process_process_stdin&quot;&gt; &lt;code&gt;process.stdin&lt;/code&gt; &lt;/a&gt; 으로 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="6b5541d5cda0f172c43a1a2f0fe36d970c29c089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;terminal&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for this instance then the &lt;code&gt;output&lt;/code&gt; stream will get the best compatibility if it defines an &lt;code&gt;output.columns&lt;/code&gt; property and emits a &lt;code&gt;'resize'&lt;/code&gt; event on the &lt;code&gt;output&lt;/code&gt; if or when the columns ever change (&lt;a href=&quot;process#process_process_stdout&quot;&gt;&lt;code&gt;process.stdout&lt;/code&gt;&lt;/a&gt; does this automatically when it is a TTY).</source>
          <target state="translated">이 인스턴스에 대해 &lt;code&gt;terminal&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;output&lt;/code&gt; 스트림은 &lt;code&gt;output.columns&lt;/code&gt; 속성을 정의 하고 열이 변경 될 때 또는 &lt;code&gt;output&lt;/code&gt; 이 변경 될 때 출력 에서 &lt;code&gt;'resize'&lt;/code&gt; 이벤트를 생성하는 경우 최상의 호환성을 얻습니다 ( &lt;a href=&quot;process#process_process_stdout&quot;&gt; &lt;code&gt;process.stdout&lt;/code&gt; &lt;/a&gt; 은이를 자동으로 수행함) TTY입니다).</target>
        </trans-unit>
        <trans-unit id="5f3ead5f9fa44a9b06b19da53bb88e5fcf398933" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;textDecoder.fatal&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, decoding errors that occur will result in a &lt;code&gt;TypeError&lt;/code&gt; being thrown.</source>
          <target state="translated">경우 &lt;code&gt;textDecoder.fatal&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; 하는 발생합니다 발생하는 오류 디코딩 &lt;code&gt;TypeError&lt;/code&gt; 발생되고있다.</target>
        </trans-unit>
        <trans-unit id="93d508820720453885b3eea699f8ab0480a703ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is 0, then the existing idle timeout is disabled.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 0, 다음, 기존의 유휴 시간 제한을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ba74037670dfad528dc28eb4a0229cdb290bcbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;, the parent will send the signal identified by the &lt;code&gt;killSignal&lt;/code&gt; property (the default is &lt;code&gt;'SIGTERM'&lt;/code&gt;) if the child runs longer than &lt;code&gt;timeout&lt;/code&gt; milliseconds.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 보다 큰 경우 &lt;code&gt;0&lt;/code&gt; , 부모에 의해 확인 된 신호를 보내드립니다 &lt;code&gt;killSignal&lt;/code&gt; 의 속성을 (기본값은 &lt;code&gt;'SIGTERM'&lt;/code&gt; 자식 실행 긴 경우보다) &lt;code&gt;timeout&lt;/code&gt; (밀리 초).</target>
        </trans-unit>
        <trans-unit id="f083cc36cf6d2dd23f87ce2f8986e80017987790" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;totalLength&lt;/code&gt; is not provided, it is calculated from the &lt;code&gt;Buffer&lt;/code&gt; instances in &lt;code&gt;list&lt;/code&gt; by adding their lengths.</source>
          <target state="translated">경우 &lt;code&gt;totalLength&lt;/code&gt; 가 제공되지 않습니다, 그것은 계산됩니다 &lt;code&gt;Buffer&lt;/code&gt; 의 인스턴스 &lt;code&gt;list&lt;/code&gt; 자신의 길이를 추가하여.</target>
        </trans-unit>
        <trans-unit id="a0d2a11ef3665d165830daf663028da145311e1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;totalLength&lt;/code&gt; is not provided, it is calculated from the &lt;code&gt;Buffer&lt;/code&gt; instances in &lt;code&gt;list&lt;/code&gt;. This however causes an additional loop to be executed in order to calculate the &lt;code&gt;totalLength&lt;/code&gt;, so it is faster to provide the length explicitly if it is already known.</source>
          <target state="translated">경우 &lt;code&gt;totalLength&lt;/code&gt; 가 제공되지 않습니다, 그것은 계산됩니다 &lt;code&gt;Buffer&lt;/code&gt; 의 인스턴스 &lt;code&gt;list&lt;/code&gt; . 그러나 &lt;code&gt;totalLength&lt;/code&gt; 를 계산하기 위해 추가 루프가 실행 되므로 길이를 이미 알고있는 경우 명시 적으로 길이를 제공하는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="778776dc6e51540045fed75d9d555de635d1f580" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;totalLength&lt;/code&gt; is provided, it is coerced to an unsigned integer. If the combined length of the &lt;code&gt;Buffer&lt;/code&gt;s in &lt;code&gt;list&lt;/code&gt; exceeds &lt;code&gt;totalLength&lt;/code&gt;, the result is truncated to &lt;code&gt;totalLength&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;totalLength&lt;/code&gt; 가 제공되고, 그것은 부호없는 정수로 강제된다. &lt;code&gt;list&lt;/code&gt; 에있는 &lt;code&gt;Buffer&lt;/code&gt; 의 결합 된 길이 가 &lt;code&gt;totalLength&lt;/code&gt; 를 초과 하면 결과가 &lt;code&gt;totalLength&lt;/code&gt; 로 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="001a12b45df8df8df8cbc6ad26dda565a2635808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt;&lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt;&lt;/a&gt; was called and has not yet finished. It will stay &lt;code&gt;true&lt;/code&gt; until the socket becomes connected, then it is set to &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;'connect'&lt;/code&gt; event is emitted. Note that the &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt;&lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt;&lt;/a&gt; callback is a listener for the &lt;code&gt;'connect'&lt;/code&gt; event.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt; &lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt; &lt;/a&gt; 가 호출되었고 아직 완료되지 않았습니다. 그것은 남아있을 것입니다 &lt;code&gt;true&lt;/code&gt; 소켓이 연결 될 때까지 다음로 설정되어, &lt;code&gt;false&lt;/code&gt; 과 &lt;code&gt;'connect'&lt;/code&gt; 이벤트가 방출된다. 주의 &lt;a href=&quot;#net_socket_connect_options_connectlistener&quot;&gt; &lt;code&gt;socket.connect(options[, connectListener])&lt;/code&gt; &lt;/a&gt; 콜백을위한 수신기 인 &lt;code&gt;'connect'&lt;/code&gt; 이벤트.</target>
        </trans-unit>
        <trans-unit id="35098f3741d27d0e305679a7801e90403a66d2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, a diagnostic report is generated on fatal errors, such as out of memory errors or failed C++ assertions.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 메모리 부족 오류 또는 실패한 C ++ 어설 션과 같은 치명적인 오류에 대해 진단 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8c3d58cec5659de13c53b368f821d4eee957d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, a diagnostic report is generated on uncaught exception.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 포착되지 않은 예외에 대해 진단 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8774522e85a70aaf6c740cab69e563126d689c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, a diagnostic report is generated when the process receives the signal specified by &lt;code&gt;process.report.signal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 프로세스가 &lt;code&gt;process.report.signal&lt;/code&gt; 에 의해 지정된 신호를 수신 할 때 진단 보고서가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="55c4e19d4721950928ccbd022abbb96676eba944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;'aes'&lt;/code&gt;, the length must be one of &lt;code&gt;128&lt;/code&gt; or &lt;code&gt;256&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a1677469ba4e1018c714e40444fe2941f96222" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;'hmac'&lt;/code&gt;, the minimum is 1, and the maximum length is 2&lt;sup&gt;31&lt;/sup&gt;-1. If the value is not a multiple of 8, the generated key will be truncated to &lt;code&gt;Math.floor(length / 8)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ad7440a14c8c38b5aa0199a878d2e5c20d33da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;urlObject.protocol&lt;/code&gt; is a string, it is appended as-is to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;urlObject.protocol&lt;/code&gt; 은 문자열입니다,을 그대로 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ff8522e3efe84a8d312b1f86c69044f0485bb19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;urlObject&lt;/code&gt; is not an object or a string, &lt;code&gt;url.format()&lt;/code&gt; will throw a &lt;a href=&quot;errors#errors_class_typeerror&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject&lt;/code&gt; 가 객체 또는 문자열이 아닌 경우 url.format &lt;code&gt;url.format()&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_typeerror&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f4b9089cbca1a0526cd03331202e2c04e998f1dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utilization1&lt;/code&gt; and &lt;code&gt;utilization2&lt;/code&gt; are both passed, then the delta is calculated between the two arguments. This is a convenience option because, unlike &lt;a href=&quot;process#process_process_hrtime_time&quot;&gt;&lt;code&gt;process.hrtime()&lt;/code&gt;&lt;/a&gt;, calculating the ELU is more complex than a single subtraction.</source>
          <target state="translated">경우 &lt;code&gt;utilization1&lt;/code&gt; 및 &lt;code&gt;utilization2&lt;/code&gt; 을 모두 통과 한 후 델타는 두 인자간에 계산된다. 이것은 &lt;a href=&quot;process#process_process_hrtime_time&quot;&gt; &lt;code&gt;process.hrtime()&lt;/code&gt; &lt;/a&gt; 과 달리 ELU 계산이 단일 빼기보다 복잡 하기 때문에 편리한 옵션 입니다.</target>
        </trans-unit>
        <trans-unit id="f03d9419ffa60c8a5daf53a3a80b6e12619db62c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utilization1&lt;/code&gt; is passed, then the delta between the current call's &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;idle&lt;/code&gt; times, as well as the corresponding &lt;code&gt;utilization&lt;/code&gt; value are calculated and returned (similar to &lt;a href=&quot;process#process_process_hrtime_time&quot;&gt;&lt;code&gt;process.hrtime()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;utilization1&lt;/code&gt; 를 통과 한 후 현재 통화 사이의 델타 &lt;code&gt;active&lt;/code&gt; 및 &lt;code&gt;idle&lt;/code&gt; 시간뿐만 아니라, 대응하는 &lt;code&gt;utilization&lt;/code&gt; 가치를 산출하고 반환 (유사 &lt;a href=&quot;process#process_process_hrtime_time&quot;&gt; &lt;code&gt;process.hrtime()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05ee65a0f13ac3ad97c2a16e9d5f6c070b89b1a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; contains &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; instances, those are accessible from either thread. They cannot be listed in &lt;code&gt;transferList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02196f127d73d1d47612cd8839cddc27ad068b47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; contains &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; instances, those will be accessible from either thread. They cannot be listed in &lt;code&gt;transferList&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt; &lt;code&gt;SharedArrayBuffer&lt;/code&gt; &lt;/a&gt; 인스턴스 가 포함되어 있으면 어느 스레드에서나 액세스 할 수 있습니다. &lt;code&gt;transferList&lt;/code&gt; 에 나열 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ff85e949179dc05f61e3f86e27be58bb70b993e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; contains invalid characters, it is truncated; if no valid fill data remains, an exception is thrown:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 에 유효하지 않은 문자가 포함되어 있으면 잘립니다. 유효한 충전 데이터가 남아 있지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f3b3bb2aa4477309d57f3aa2abedd9b65e4b68a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;'0'&lt;/code&gt;, certificate validation is disabled for TLS connections. This makes TLS, and HTTPS by extension, insecure. The use of this environment variable is strongly discouraged.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 등호 &lt;code&gt;'0'&lt;/code&gt; , 인증서 유효성 검사는 TLS 연결에 사용할 수 없습니다. 이로 인해 TLS 및 확장명으로 HTTPS가 안전하지 않게됩니다. 이 환경 변수를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cec613a64adeb6a39ea2360902a0c704bd25ea80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;'1'&lt;/code&gt;, the check for a supported platform is skipped during Node.js startup. Node.js might not execute correctly. Any issues encountered on unsupported platforms will not be fixed.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 같아 &lt;code&gt;'1'&lt;/code&gt; 을 , 지원되는 플랫폼에 대한 검사는 Node.js를 시작하는 동안 건너 뜁니다. Node.js가 올바르게 실행되지 않을 수 있습니다. 지원되지 않는 플랫폼에서 발생한 문제는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ecf0a1b940c0c7066480713a76db16cc1bca7fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; has a type that is invalid, an error is returned.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 유효하지 않은 유형이 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3263c551e2bdc6058e2fe75413a98aa9283c607a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthy&lt;/a&gt;, nothing happens.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 이다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Truthy&quot;&gt;truthy&lt;/a&gt; 아무 일도 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="477a3b56d3910a570c18028c1ee0026497e1f0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is an empty string or empty &lt;code&gt;Buffer&lt;/code&gt; and &lt;code&gt;byteOffset&lt;/code&gt; is less than &lt;code&gt;buf.length&lt;/code&gt;, &lt;code&gt;byteOffset&lt;/code&gt; will be returned. If &lt;code&gt;value&lt;/code&gt; is empty and &lt;code&gt;byteOffset&lt;/code&gt; is at least &lt;code&gt;buf.length&lt;/code&gt;, &lt;code&gt;buf.length&lt;/code&gt; will be returned.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 빈 문자열 또는 빈 &lt;code&gt;Buffer&lt;/code&gt; 및 &lt;code&gt;byteOffset&lt;/code&gt; 이 적은보다 &lt;code&gt;buf.length&lt;/code&gt; , &lt;code&gt;byteOffset&lt;/code&gt; 가 반환됩니다. 경우 &lt;code&gt;value&lt;/code&gt; 비어 있고 &lt;code&gt;byteOffset&lt;/code&gt; 는 적어도이다 &lt;code&gt;buf.length&lt;/code&gt; , &lt;code&gt;buf.length&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d902facaf6d43dbe41bfb2356769d8f1ffd7b055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is an empty string or empty &lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;byteOffset&lt;/code&gt; will be returned.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 빈 문자열 또는 비어있는 &lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;byteOffset&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="610f15b12beaf1c5a62a2377f055103b964040a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is not a string, number, or &lt;code&gt;Buffer&lt;/code&gt;, this method will throw a &lt;code&gt;TypeError&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is a number, it will be coerced to a valid byte value, an integer between 0 and 255.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 문자열, 숫자가 아닌, 또는 &lt;code&gt;Buffer&lt;/code&gt; ,이 방법은 발생합니다 &lt;code&gt;TypeError&lt;/code&gt; . 경우 &lt;code&gt;value&lt;/code&gt; 숫자이고, 이것은 0과 255 사이의 유효한 바이트 값의 정수를 강제한다.</target>
        </trans-unit>
        <trans-unit id="178863efc7ea67115b5dbfa8a60b5af494bd0c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is not truthy, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is &lt;code&gt;undefined&lt;/code&gt;, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;. If no arguments are passed in at all &lt;code&gt;message&lt;/code&gt; will be set to the string: &lt;code&gt;'No value argument passed to `assert.ok()`'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 사실이 아닌 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일한 &lt;code&gt;message&lt;/code&gt; 특성 세트 와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가되고 &lt;code&gt;undefined&lt;/code&gt; , 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 . 인수가 전혀 전달되지 않으면 &lt;code&gt;message&lt;/code&gt; 는 &lt;code&gt;'No value argument passed to `assert.ok()`'&lt;/code&gt; 문자열로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c102461aece29b4f7fef8e66b2c5fbb4127e36c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is not truthy, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is &lt;code&gt;undefined&lt;/code&gt;, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;. If no arguments are passed in at all &lt;code&gt;message&lt;/code&gt; will be set to the string: &lt;code&gt;'No value argument passed to `assert.ok()`'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 진실이 아닌 경우 , &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가되고 &lt;code&gt;undefined&lt;/code&gt; , 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 . 인수가 전달되지 않으면 모든 &lt;code&gt;message&lt;/code&gt; 가 문자열로 설정됩니다 : &lt;code&gt;'No value argument passed to `assert.ok()`'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd0402e2118e34facbcfab001befd8ad7443b87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="6aef87783af7020d0cd410d7d651097e2e3c679a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;warning&lt;/code&gt; is passed as an &lt;code&gt;Error&lt;/code&gt; object, it will be passed through to the &lt;code&gt;'warning'&lt;/code&gt; event handler unmodified (and the optional &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;code&lt;/code&gt; and &lt;code&gt;ctor&lt;/code&gt; arguments will be ignored):</source>
          <target state="translated">경우 &lt;code&gt;warning&lt;/code&gt; 로 전달되는 &lt;code&gt;Error&lt;/code&gt; 객체, 그것은을 통해 전달됩니다 &lt;code&gt;'warning'&lt;/code&gt; 수정되지 않은 이벤트 핸들러 (및 옵션 &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;code&lt;/code&gt; 와 &lt;code&gt;ctor&lt;/code&gt; 인수는 무시됩니다)</target>
        </trans-unit>
        <trans-unit id="e4b82326320a632b6ceaad5f485c055d2c7e0174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;warning&lt;/code&gt; is passed as an &lt;code&gt;Error&lt;/code&gt; object, the &lt;code&gt;options&lt;/code&gt; argument is ignored.</source>
          <target state="translated">경우 &lt;code&gt;warning&lt;/code&gt; 로 전달되는 &lt;code&gt;Error&lt;/code&gt; 객체의 &lt;code&gt;options&lt;/code&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="41f93b697074a04d9a7451363fab25ce715d8e95" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expansionKey&lt;/em&gt; ends in &lt;em&gt;&quot;*&quot;&lt;/em&gt; and &lt;em&gt;matchKey&lt;/em&gt; starts with but is not equal to the substring of &lt;em&gt;expansionKey&lt;/em&gt; excluding the last &lt;em&gt;&quot;*&quot;&lt;/em&gt; character, then</source>
          <target state="translated">경우 &lt;em&gt;expansionKey의&lt;/em&gt; 의 끝 &lt;em&gt;&quot;*&quot;&lt;/em&gt; 와 &lt;em&gt;matchKey은&lt;/em&gt; 시작에 불과하다의 문자열과 동일하지 &lt;em&gt;expansionKey&lt;/em&gt; 지난 제외 &lt;em&gt;&quot;*&quot;&lt;/em&gt; 다음 문자를</target>
        </trans-unit>
        <trans-unit id="0577a7ccc05e8a587e6e7e65e0c4821ff46f2b0e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exports&lt;/em&gt; contains any index property keys, as defined in ECMA-262 &lt;a href=&quot;https://tc39.es/ecma262/#integer-index&quot;&gt;6.1.7 Array Index&lt;/a&gt;, throw an &lt;em&gt;Invalid Package Configuration&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;수출&lt;/em&gt; 로 ECMA-262에 정의 된 모든 인덱스 속성 키 포함 &lt;a href=&quot;https://tc39.es/ecma262/#integer-index&quot;&gt;6.1.7 배열 색인&lt;/a&gt; , 던져 &lt;em&gt;잘못된 패키지 구성의&lt;/em&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b375c17fa600298769d168405d944fa06cc4c1ea" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exports&lt;/em&gt; is a String or Array, or an Object containing no keys starting with &lt;em&gt;&quot;.&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;수출&lt;/em&gt; 문자열이나 배열, 또는로 시작하는 어떤 키를 포함하지 않는 객체입니다 &lt;em&gt;&quot;.&quot; &lt;/em&gt;, 다음</target>
        </trans-unit>
        <trans-unit id="e6402d3f218098d3a8e6a411b9e2375110576c0e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exports&lt;/em&gt; is an Object with both a key starting with &lt;em&gt;&quot;.&quot;&lt;/em&gt; and a key not starting with &lt;em&gt;&quot;.&quot;&lt;/em&gt;, throw an &lt;em&gt;Invalid Package Configuration&lt;/em&gt; error.</source>
          <target state="translated">&lt;em&gt;exports&lt;/em&gt; 가 &lt;em&gt;&quot;.&quot;로&lt;/em&gt; 시작하는 키가있는 객체 인 경우 &lt;em&gt;&quot;.&quot;로&lt;/em&gt; 시작하지 않는 키 , &lt;em&gt;잘못된 패키지 구성&lt;/em&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="433d836e378ef348cc420afb2d03c3f46aae06f9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exports&lt;/em&gt; is an Object, then</source>
          <target state="translated">경우 &lt;em&gt;수출은&lt;/em&gt; 다음 개체입니다</target>
        </trans-unit>
        <trans-unit id="74d40a34d800073ac93a2656a712beef1e220d10" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exports&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; or &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;수출&lt;/em&gt; 하지 &lt;strong&gt;널 (null)&lt;/strong&gt; 또는 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="2b6adbd6d2cd92f52c0dac70fce50304484b7809" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;internal&lt;/em&gt; is &lt;strong&gt;true&lt;/strong&gt; and &lt;em&gt;target&lt;/em&gt; does not start with &lt;em&gt;&quot;../&quot;&lt;/em&gt; or &lt;em&gt;&quot;/&quot;&lt;/em&gt; and is not a valid URL, then</source>
          <target state="translated">경우 &lt;em&gt;내부가&lt;/em&gt; 있다 &lt;strong&gt;진실&lt;/strong&gt; 과 &lt;em&gt;목표&lt;/em&gt; 로 시작하지 않는 &lt;em&gt;&quot;../&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 다음 유효한 URL이 아닙니다</target>
        </trans-unit>
        <trans-unit id="626b750f96645f82bd5cc543ca8f99fdf9bde94e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isMain&lt;/em&gt; is &lt;strong&gt;true&lt;/strong&gt; or &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.js&quot;&lt;/em&gt;, &lt;em&gt;&quot;.json&quot;&lt;/em&gt; or &lt;em&gt;&quot;.node&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;isMain는&lt;/em&gt; 것입니다 &lt;strong&gt;사실&lt;/strong&gt; 이나 &lt;em&gt;URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;의 .js&quot;&lt;/em&gt; , &lt;em&gt;&quot;.json&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;.node&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="538d9233728c8d6a4c6514633152fe767963d7a6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isMain&lt;/em&gt; is &lt;strong&gt;true&lt;/strong&gt; or &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.js&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;isMain는&lt;/em&gt; 것입니다 &lt;strong&gt;사실&lt;/strong&gt; 이나 &lt;em&gt;URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;의 .js&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="9da65ce5b94313859150df365b9af3be12032cd4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mainExport&lt;/em&gt; is not &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;mainExport가&lt;/em&gt; 되지 않는 &lt;strong&gt;정의되지 않은&lt;/strong&gt; , 다음</target>
        </trans-unit>
        <trans-unit id="df9d8c86bd73bcabf3bd344e3e90c8c80da2104f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;matchKey&lt;/em&gt; is a key of &lt;em&gt;matchObj&lt;/em&gt;, and does not end in &lt;em&gt;&quot;*&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;matchKey는&lt;/em&gt; 의 핵심이다 &lt;em&gt;matchObj는&lt;/em&gt; , 그리고 끝나지 않는 &lt;em&gt;&quot;*&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="d5ffe8900c958f10341671d5750b1b5c6d6997c1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;matchKey&lt;/em&gt; starts with &lt;em&gt;expansionKey&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;matchKey가&lt;/em&gt; 시작 &lt;em&gt;expansionKey&lt;/em&gt; , 다음</target>
        </trans-unit>
        <trans-unit id="0cb20b4281a114e79e240f0e1c15571acbe24e64" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;p&lt;/em&gt; equals &lt;em&gt;&quot;default&quot;&lt;/em&gt; or &lt;em&gt;conditions&lt;/em&gt; contains an entry for &lt;em&gt;p&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;p는&lt;/em&gt; 같다 &lt;em&gt;&quot;기본&quot;&lt;/em&gt; 또는 &lt;em&gt;조건&lt;/em&gt; 에 대한 항목이 포함되어 &lt;em&gt;페이지를&lt;/em&gt; 한 후,</target>
        </trans-unit>
        <trans-unit id="c57aac53f3f9fd0d62104d495804a0ae393b46fe" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageName&lt;/em&gt; starts with &lt;em&gt;&quot;.&quot;&lt;/em&gt; or contains &lt;em&gt;&quot;\&quot;&lt;/em&gt; or &lt;em&gt;&quot;%&quot;&lt;/em&gt;, then</source>
          <target state="translated">&lt;em&gt;packageName&lt;/em&gt; 이 &lt;em&gt;&quot;.&quot;로&lt;/em&gt; 시작하는 경우 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;%&quot;&lt;/em&gt; 가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="d35e5f92073bf52038791008480ed2f5c4697c50" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packagePath&lt;/em&gt; is a key of &lt;em&gt;exports&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;packagePath를는&lt;/em&gt; 의 핵심 인 &lt;em&gt;수출&lt;/em&gt; 한 후,</target>
        </trans-unit>
        <trans-unit id="f2f22aee4315b9d9b1a126b11702495290d5d799" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packagePath&lt;/em&gt; starts with &lt;em&gt;directory&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;packagePath를가&lt;/em&gt; 시작 &lt;em&gt;디렉토리&lt;/em&gt; 후,</target>
        </trans-unit>
        <trans-unit id="5b4105fb98e3182d04e974f14eeeb21f882c8130" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSpecifier&lt;/em&gt; does not contain a &lt;em&gt;&quot;/&quot;&lt;/em&gt; separator, then</source>
          <target state="translated">&lt;em&gt;packageSpecifier&lt;/em&gt; 에 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 구분 기호 가없는 경우</target>
        </trans-unit>
        <trans-unit id="7f7a0cffb3b9cc7675b70e8f76d1f2a739d49f45" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSpecifier&lt;/em&gt; does not start with &lt;em&gt;&quot;@&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;packageSpecifier이&lt;/em&gt; 시작되지 않습니다 &lt;em&gt;&quot;@&quot;&lt;/em&gt; 다음</target>
        </trans-unit>
        <trans-unit id="2f16f2a59cbdf0b5925f0cdb310548d264354720" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSpecifier&lt;/em&gt; is an empty string, then</source>
          <target state="translated">경우 &lt;em&gt;packageSpecifier은&lt;/em&gt; 다음 빈 문자열입니다</target>
        </trans-unit>
        <trans-unit id="74a4411c0f557c404fd9cac2a8f1acb42ad2bc91" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSubpath&lt;/em&gt; contains any &lt;em&gt;&quot;.&quot;&lt;/em&gt; or &lt;em&gt;&quot;..&quot;&lt;/em&gt; segments or percent encoded strings for &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; then,</source>
          <target state="translated">&lt;em&gt;packageSubpath&lt;/em&gt; 에 &lt;em&gt;&quot;.&quot;이&lt;/em&gt; 포함 된 경우 또는 &lt;em&gt;&quot;..&quot;&lt;/em&gt; 세그먼트 또는 퍼센트에 대해 문자열을 인코딩 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; 다음</target>
        </trans-unit>
        <trans-unit id="9f96edd7aac90655ac6732a8ce0fafb68b19c6bf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSubpath&lt;/em&gt; is &lt;em&gt;&quot;.&quot;&lt;/em&gt; and &lt;em&gt;packageName&lt;/em&gt; is a Node.js builtin module, then</source>
          <target state="translated">경우 &lt;em&gt;packageSubpath가&lt;/em&gt; 있다 &lt;em&gt;&quot;.&quot; &lt;/em&gt;그리고 &lt;em&gt;패키지 명은 반드시&lt;/em&gt; 그리고, Node.js를 내장 모듈</target>
        </trans-unit>
        <trans-unit id="30820a14bd44bf6838e5df3dc3dd4270f2094932" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSubpath&lt;/em&gt; is &lt;em&gt;undefined&lt;/em&gt; and &lt;em&gt;packageName&lt;/em&gt; is a Node.js builtin module, then</source>
          <target state="translated">경우 &lt;em&gt;packageSubpath가&lt;/em&gt; 된다 &lt;em&gt;미정&lt;/em&gt; 과 &lt;em&gt;패키지 명은 반드시&lt;/em&gt; 그리고, Node.js를 내장 모듈</target>
        </trans-unit>
        <trans-unit id="a2d95c17d62993ba9ee7e59cc78fb009d19362ad" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageSubpath&lt;/em&gt; is _undefined__, then</source>
          <target state="translated">경우 &lt;em&gt;packageSubpath는&lt;/em&gt; 다음 _undefined__입니다</target>
        </trans-unit>
        <trans-unit id="63775ad1ec94909e4de60abf735e817b7eef89d2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageURL&lt;/em&gt; is &lt;strong&gt;null&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;PACKAGEURL는&lt;/em&gt; 이다 &lt;strong&gt;널&lt;/strong&gt; 후,</target>
        </trans-unit>
        <trans-unit id="0f158af354e66079a188452eb9bd59654fa8a11d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;packageURL&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;PACKAGEURL가&lt;/em&gt; 아닌 &lt;strong&gt;널 (null)&lt;/strong&gt; 한 후,</target>
        </trans-unit>
        <trans-unit id="76bb7b696456cffac124879a2769029067dcb515" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is &lt;strong&gt;false&lt;/strong&gt;, &lt;em&gt;subpath&lt;/em&gt; has non-zero length and &lt;em&gt;target&lt;/em&gt; does not end with &lt;em&gt;&quot;/&quot;&lt;/em&gt;, throw an &lt;em&gt;Invalid Module Specifier&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;패턴&lt;/em&gt; 입니다 &lt;strong&gt;거짓&lt;/strong&gt; , &lt;em&gt;서브 패스는&lt;/em&gt; 비 제로의 길이가 &lt;em&gt;목표&lt;/em&gt; 로 끝나지 않습니다를 &lt;em&gt;&quot;/&quot;&lt;/em&gt; , 던져 &lt;em&gt;잘못된 모듈 지정자의&lt;/em&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2480911d63b5a76e0185c90d4572d0886914fbdd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is &lt;strong&gt;true&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;패턴&lt;/em&gt; 입니다 &lt;strong&gt;진정한&lt;/strong&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="d6b25ebdb37a2ee70dbddea2a364bfa7f4accf7a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson.imports&lt;/em&gt; is a non-null Object, then</source>
          <target state="translated">경우 &lt;em&gt;pjson.imports&lt;/em&gt; 다음, null이 아닌 개체입니다</target>
        </trans-unit>
        <trans-unit id="cac153ab7ad7d83ff26cce43a9687bb252bdf201" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson.main&lt;/em&gt; is a String, then</source>
          <target state="translated">경우 &lt;em&gt;pjson.main은&lt;/em&gt; 다음 문자열입니다</target>
        </trans-unit>
        <trans-unit id="6c8824a631f16e5ce09e9c09d16dfd5c378259ec" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson.name&lt;/em&gt; is equal to &lt;em&gt;packageName&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson.name는&lt;/em&gt; 같다 &lt;em&gt;여기서 packageName&lt;/em&gt; 이어서,</target>
        </trans-unit>
        <trans-unit id="29f00e1f0b5e9ea20d8965c2996f9b39a1a4115b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson.type&lt;/em&gt; is equal to &lt;em&gt;&quot;module&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;pjson.type은&lt;/em&gt; 동일하다 &lt;em&gt;&quot;모듈&quot;&lt;/em&gt; 이어서,</target>
        </trans-unit>
        <trans-unit id="bdc57c5d938d899f07106a15d348e470fbb0ae77" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson&lt;/em&gt; is &lt;strong&gt;null&lt;/strong&gt; or if &lt;em&gt;pjson&lt;/em&gt;.&lt;em&gt;exports&lt;/em&gt; is &lt;strong&gt;null&lt;/strong&gt; or &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson는&lt;/em&gt; 것입니다 &lt;strong&gt;null의&lt;/strong&gt; 경우 또는 &lt;em&gt;pjson&lt;/em&gt; . &lt;em&gt;exports&lt;/em&gt; 가 &lt;strong&gt;null&lt;/strong&gt; 또는 &lt;strong&gt;undefined&lt;/strong&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="cf811ae7a597b7fb485bf93caabe66eeaa852963" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson&lt;/em&gt; is &lt;strong&gt;null&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson는&lt;/em&gt; 이다 &lt;strong&gt;널&lt;/strong&gt; 후,</target>
        </trans-unit>
        <trans-unit id="4f80deadcdbf120ed3bc57ab599f9a6b579c8301" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; and &lt;em&gt;pjson&lt;/em&gt; has an &lt;em&gt;&quot;exports&quot;&lt;/em&gt; key, then</source>
          <target state="translated">경우 &lt;em&gt;pjson가&lt;/em&gt; 아닌 &lt;strong&gt;널 (null)&lt;/strong&gt; 과 &lt;em&gt;pjson는&lt;/em&gt; 가 &lt;em&gt;&quot;수출&quot;&lt;/em&gt; 다음, 키를</target>
        </trans-unit>
        <trans-unit id="18ca5859ec30047532a81d0b6f31ffafcce52235" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; and &lt;em&gt;pjson&lt;/em&gt;.&lt;em&gt;exports&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; or &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson가&lt;/em&gt; 아닌 &lt;strong&gt;널 (null)&lt;/strong&gt; 와 &lt;em&gt;pjson&lt;/em&gt; . &lt;em&gt;exports&lt;/em&gt; 가 &lt;strong&gt;null&lt;/strong&gt; 또는 &lt;strong&gt;undefined&lt;/strong&gt; 가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="924f5e7abf32f37553aa5a80dfd4cdbfc346ccc3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson가&lt;/em&gt; 아닌 &lt;strong&gt;널 (null)&lt;/strong&gt; 한 후,</target>
        </trans-unit>
        <trans-unit id="10a7fb27e5c43714c28e08125b5133fc11f467de" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pjson?.type&lt;/em&gt; exists and is &lt;em&gt;&quot;module&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;pjson? .type이&lt;/em&gt; 존재하고있다 &lt;em&gt;&quot;모듈&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="4ddabda355c14670e242f2783433e93aeed8f405" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolved&lt;/em&gt; contains any percent encodings of &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; (&lt;em&gt;&quot;%2f&quot;&lt;/em&gt; and &lt;em&gt;&quot;%5C&quot;&lt;/em&gt; respectively), then</source>
          <target state="translated">&lt;em&gt;해결&lt;/em&gt; 에 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; (각각 &lt;em&gt;&quot;% 2f&quot;&lt;/em&gt; 및 &lt;em&gt;&quot;% 5C&quot;&lt;/em&gt; )의 백분율 인코딩이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="d7449cc4d1b1031c3524ef289e3560a6a3819f1c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolved&lt;/em&gt; is &lt;strong&gt;undefined&lt;/strong&gt;, continue the loop.</source>
          <target state="translated">경우 &lt;em&gt;해결&lt;/em&gt; 되는 &lt;strong&gt;정의되지 않은&lt;/strong&gt; , 루프를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="a5474accabca7888e2d572af9dd01b3256534e50" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolved&lt;/em&gt; is contained in &lt;em&gt;resolvedTarget&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;해결&lt;/em&gt; 에 포함되어 &lt;em&gt;resolvedTarget&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="a06bbe8ab35ec10987d665ee40811625bf1745fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolved&lt;/em&gt; is equal to &lt;strong&gt;undefined&lt;/strong&gt;, continue the loop.</source>
          <target state="translated">경우 &lt;em&gt;해결&lt;/em&gt; IS가 동일 &lt;strong&gt;정의되지 않은&lt;/strong&gt; , 루프를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="309600f041fa9426b9071021af01fc01c91d21f6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolved&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; or &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;해결이&lt;/em&gt; 아닌 &lt;strong&gt;널 (null)&lt;/strong&gt; 또는 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="3d733738ae723c54901f5e599136d1956a1dce2d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolvedMatch&lt;/em&gt;.&lt;em&gt;resolve&lt;/em&gt; is not &lt;strong&gt;null&lt;/strong&gt; or &lt;strong&gt;undefined&lt;/strong&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;resolvedMatch&lt;/em&gt; . &lt;em&gt;resolve&lt;/em&gt; 가 &lt;strong&gt;null&lt;/strong&gt; 또는 &lt;strong&gt;undefined&lt;/strong&gt; 가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="d0f81aa1380f9f4733f23b21def09dcc23089d6d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolvedTarget&lt;/em&gt; is contained in &lt;em&gt;packageURL&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;resolvedTarget가&lt;/em&gt; 에 포함되어 &lt;em&gt;PACKAGEURL&lt;/em&gt; , 다음</target>
        </trans-unit>
        <trans-unit id="e5f5cc713d0076b8f8c168a8156d8890dbb2300e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolvedURL&lt;/em&gt; contains any percent encodings of &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; (&lt;em&gt;&quot;%2f&quot;&lt;/em&gt; and &lt;em&gt;&quot;%5C&quot;&lt;/em&gt; respectively), then</source>
          <target state="translated">&lt;em&gt;resolvedURL&lt;/em&gt; 에 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; (각각 &lt;em&gt;&quot;% 2f&quot;&lt;/em&gt; 및 &lt;em&gt;&quot;% 5C&quot;&lt;/em&gt; )의 퍼센트 인코딩이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="c3c5cd03aecf162fd5cc79f200bd54c85bf5ef51" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scopeURL&lt;/em&gt; ends in a &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; path segment, return &lt;strong&gt;null&lt;/strong&gt;.</source>
          <target state="translated">경우 &lt;em&gt;scopeURL는&lt;/em&gt; A의 끝 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 경로 세그먼트, 반환 &lt;strong&gt;널 (null)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="39d9dc9837fc2ce9116a9338e887f0f2b603735c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;selfUrl&lt;/em&gt; is not &lt;strong&gt;undefined&lt;/strong&gt;, return &lt;em&gt;selfUrl&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;selfUrl&lt;/em&gt; 이 &lt;strong&gt;정의&lt;/strong&gt; 되지 &lt;strong&gt;않은&lt;/strong&gt; 경우 &lt;em&gt;selfUrl을&lt;/em&gt; 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a32d8a8494066b9c331308a9de76dd6cfdb33e2c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;specifier&lt;/em&gt; is a valid URL, then</source>
          <target state="translated">경우 &lt;em&gt;지정자는&lt;/em&gt; 다음 유효한 URL입니다</target>
        </trans-unit>
        <trans-unit id="03aba3703450cb347b2baa501a774d738b8a8d87" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;specifier&lt;/em&gt; is exactly equal to &lt;em&gt;&quot;#&quot;&lt;/em&gt; or starts with &lt;em&gt;&quot;#/&quot;&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;지정이&lt;/em&gt; 정확히 같다 &lt;em&gt;&quot;#&quot;&lt;/em&gt; 또는 시작 &lt;em&gt;&quot;/ #&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="488b105d4a05d51c891376a14f3cd7430f2c0005" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subpath&lt;/em&gt; has non-zero length and &lt;em&gt;target&lt;/em&gt; does not end with &lt;em&gt;&quot;/&quot;&lt;/em&gt;, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;서브 패스가&lt;/em&gt; 아닌 제로의 길이가 &lt;em&gt;목표&lt;/em&gt; 로 끝나지 않습니다를 &lt;em&gt;&quot;/&quot;&lt;/em&gt; , 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c8ed17008df2fc9610e9cc01c424675b5fd341e1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subpath&lt;/em&gt; is equal to &lt;em&gt;&quot;.&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;서브 패스가&lt;/em&gt; 같다 &lt;em&gt;&quot;.&quot; &lt;/em&gt;, 다음</target>
        </trans-unit>
        <trans-unit id="4e90feccdd79be95ea5e54ad496d5b6e9b08c011" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subpath&lt;/em&gt; split on &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; contains any &lt;em&gt;&quot;.&quot;&lt;/em&gt;, &lt;em&gt;&quot;..&quot;&lt;/em&gt; or &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; segments, throw an &lt;em&gt;Invalid Module Specifier&lt;/em&gt; error.</source>
          <target state="translated">만약 &lt;em&gt;서브 패스&lt;/em&gt; 에 분할 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; 모든 포함이 &lt;em&gt;&quot;.&quot; &lt;/em&gt;, &lt;em&gt;&quot;..&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 세그먼트는 &lt;em&gt;잘못된 모듈 지정자&lt;/em&gt; 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b5329ff61a9ede403246a6ffa42cab4d0103af2b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; does not start with &lt;em&gt;&quot;./&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;목표&lt;/em&gt; 로 시작하지 않는 &lt;em&gt;&quot;./&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="8eac144fa46e78f012a0b80015514759addbc976" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; does not start with &lt;em&gt;&quot;./&quot;&lt;/em&gt;, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;목표&lt;/em&gt; 로 시작하지 않는 &lt;em&gt;&quot;./&quot;&lt;/em&gt; , 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c3875ce3373cebbce8bed7ea926620173bf5943b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; is a String, then</source>
          <target state="translated">경우 &lt;em&gt;대상은&lt;/em&gt; 다음 문자열입니다</target>
        </trans-unit>
        <trans-unit id="23e9d9969ad4fb7cdf18a1301ae7b5b00f519d6b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; or &lt;em&gt;subpath&lt;/em&gt; contain any &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; segments including &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; percent-encoding, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;대상&lt;/em&gt; 또는 &lt;em&gt;서브 패스가&lt;/em&gt; 모든 포함 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 를 포함하여 세그먼트 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 퍼센트 인코딩을 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="f93305c743bb5ac667b3348d3912917a71ca9577" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; split on &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; contains any &lt;em&gt;&quot;.&quot;&lt;/em&gt;, &lt;em&gt;&quot;..&quot;&lt;/em&gt; or &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; segments after the first segment, throw an &lt;em&gt;Invalid Package Target&lt;/em&gt; error.</source>
          <target state="translated">만약 &lt;em&gt;목표&lt;/em&gt; 에 분할 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; 모든 포함이 &lt;em&gt;&quot;.&quot; &lt;/em&gt;첫 번째 세그먼트 뒤에 , &lt;em&gt;&quot;..&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 세그먼트가 있으면 &lt;em&gt;잘못된 패키지 대상&lt;/em&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bddfda64499ff1f71febb28ebb761f079fbed16c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;targetValue&lt;/em&gt; is not a String, continue the loop.</source>
          <target state="translated">&lt;em&gt;targetValue&lt;/em&gt; 가 문자열이 아닌 경우 루프를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="746818083e540de70308980c76bffb23bc64c121" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.cjs&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;의 URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;.cjs&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="df5300d15907b48a70bb18f93285dda55aedb74c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.js&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;의 URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;의 .js&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="d00425f0ac5d3e619c3975396989aaeea52f6f8a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.mjs&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;의 URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;.mjs&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="2657e59e2d4c8d4505b3ca335596c032d243a675" translate="yes" xml:space="preserve">
          <source>If Node.js is spawned with an IPC channel, the &lt;code&gt;process.send()&lt;/code&gt; method can be used to send messages to the parent process. Messages will be received as a &lt;a href=&quot;child_process#child_process_event_message&quot;&gt;&lt;code&gt;'message'&lt;/code&gt;&lt;/a&gt; event on the parent's &lt;a href=&quot;child_process#child_process_class_childprocess&quot;&gt;&lt;code&gt;ChildProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Node.js가 IPC 채널과 함께 생성되면 &lt;code&gt;process.send()&lt;/code&gt; 메소드를 사용하여 상위 프로세스로 메시지를 보낼 수 있습니다. 메시지는 부모의 &lt;a href=&quot;child_process#child_process_class_childprocess&quot;&gt; &lt;code&gt;ChildProcess&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;child_process#child_process_event_message&quot;&gt; &lt;code&gt;'message'&lt;/code&gt; &lt;/a&gt; 이벤트 로 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="2546faee0b34d4ad8c17f27675b90b30ee617f3b" translate="yes" xml:space="preserve">
          <source>If Node.js was compiled &lt;em&gt;without&lt;/em&gt;&lt;a href=&quot;cli#cli_node_options_options&quot;&gt;&lt;code&gt;NODE_OPTIONS&lt;/code&gt;&lt;/a&gt; support (shown in &lt;a href=&quot;#process_process_config&quot;&gt;&lt;code&gt;process.config&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;process.allowedNodeEnvironmentFlags&lt;/code&gt; will contain what &lt;em&gt;would have&lt;/em&gt; been allowable.</source>
          <target state="translated">Node.js를 컴파일하면 &lt;em&gt;없이 &lt;/em&gt;&lt;a href=&quot;cli#cli_node_options_options&quot;&gt; &lt;code&gt;NODE_OPTIONS&lt;/code&gt; 의&lt;/a&gt; (에 표시된 지원 &lt;a href=&quot;#process_process_config&quot;&gt; &lt;code&gt;process.config&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;process.allowedNodeEnvironmentFlags&lt;/code&gt; 는 무엇을 포함 할 &lt;em&gt;것이다&lt;/em&gt; 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="70bb3d5051fa757d796c052f5fd051a2fe7444a6" translate="yes" xml:space="preserve">
          <source>If Node.js was not spawned with an IPC channel, &lt;code&gt;process.send()&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js가 IPC 채널로 생성되지 않은 경우 &lt;code&gt;process.send()&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1747032835cdecdf7d71b88af3e2ea5e107d2c74" translate="yes" xml:space="preserve">
          <source>If Node.js was not spawned with an IPC channel, &lt;code&gt;process.send&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js가 IPC 채널로 생성 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;process.send&lt;/code&gt; 는 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e3f474102746060243a977cebf87ca38ae4337f0" translate="yes" xml:space="preserve">
          <source>If _target.length is zero, return &lt;strong&gt;null&lt;/strong&gt;.</source>
          <target state="translated">_target.length가 0 &lt;strong&gt;이면 null을&lt;/strong&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c0480dd820a4caf6a7a01add9db3c1ee81d9d7d2" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#http2_event_request&quot;&gt;&lt;code&gt;'request'&lt;/code&gt;&lt;/a&gt; listener is registered or &lt;a href=&quot;#http2_http2_createsecureserver_options_onrequesthandler&quot;&gt;&lt;code&gt;http2.createSecureServer()&lt;/code&gt;&lt;/a&gt; is supplied a callback function, the &lt;code&gt;'checkContinue'&lt;/code&gt; event is emitted each time a request with an HTTP &lt;code&gt;Expect: 100-continue&lt;/code&gt; is received. If this event is not listened for, the server will automatically respond with a status &lt;code&gt;100 Continue&lt;/code&gt; as appropriate.</source>
          <target state="translated">경우 &lt;a href=&quot;#http2_event_request&quot;&gt; &lt;code&gt;'request'&lt;/code&gt; &lt;/a&gt; 리스너가 등록 또는 &lt;a href=&quot;#http2_http2_createsecureserver_options_onrequesthandler&quot;&gt; &lt;code&gt;http2.createSecureServer()&lt;/code&gt; &lt;/a&gt; 콜백 기능을 제공하는 &lt;code&gt;'checkContinue'&lt;/code&gt; 이벤트가 함께 HTTP 요청마다 출사 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 수신된다. 이 이벤트가 수신되지 않으면, 서버는 자동으로 &lt;code&gt;100 Continue&lt;/code&gt; 상태로 자동 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="3c6666474bf74c83f95eb13a8a69c877db182322" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#http2_event_request&quot;&gt;&lt;code&gt;'request'&lt;/code&gt;&lt;/a&gt; listener is registered or &lt;a href=&quot;#http2_http2_createserver_options_onrequesthandler&quot;&gt;&lt;code&gt;http2.createServer()&lt;/code&gt;&lt;/a&gt; is supplied a callback function, the &lt;code&gt;'checkContinue'&lt;/code&gt; event is emitted each time a request with an HTTP &lt;code&gt;Expect: 100-continue&lt;/code&gt; is received. If this event is not listened for, the server will automatically respond with a status &lt;code&gt;100 Continue&lt;/code&gt; as appropriate.</source>
          <target state="translated">경우 &lt;a href=&quot;#http2_event_request&quot;&gt; &lt;code&gt;'request'&lt;/code&gt; &lt;/a&gt; 리스너가 등록 또는 &lt;a href=&quot;#http2_http2_createserver_options_onrequesthandler&quot;&gt; &lt;code&gt;http2.createServer()&lt;/code&gt; &lt;/a&gt; 콜백 기능을 제공하는 &lt;code&gt;'checkContinue'&lt;/code&gt; 이벤트가 함께 HTTP 요청마다 출사 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 수신된다. 이 이벤트가 수신되지 않으면, 서버는 자동으로 &lt;code&gt;100 Continue&lt;/code&gt; 상태로 자동 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="696d38c8122ee517b2457a839a5b2713312b81a6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; is switched into flowing mode and there are no consumers available to handle the data, that data will be lost. This can occur, for instance, when the &lt;code&gt;readable.resume()&lt;/code&gt; method is called without a listener attached to the &lt;code&gt;'data'&lt;/code&gt; event, or when a &lt;code&gt;'data'&lt;/code&gt; event handler is removed from the stream.</source>
          <target state="translated">경우 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 모드를 흐르는로 전환하고 데이터를 처리 할 수없는 소비자들은 데이터가 손실됩니다, 없습니다. 예를 들어 &lt;code&gt;'data'&lt;/code&gt; 이벤트에 리스너가 연결되지 않은 상태에서 &lt;code&gt;readable.resume()&lt;/code&gt; 메서드가 호출 되거나 &lt;code&gt;'data'&lt;/code&gt; 이벤트 핸들러가 스트림에서 제거 될 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ef4d686dd3f74dcc258b05b6437e033cfca3b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FileHandle&lt;/code&gt; is not closed using the &lt;code&gt;filehandle.close()&lt;/code&gt; method, it might automatically close the file descriptor and will emit a process warning, thereby helping to prevent memory leaks. Please do not rely on this behavior because it is unreliable and the file may not be closed. Instead, always explicitly close &lt;code&gt;FileHandle&lt;/code&gt;s. Node.js may change this behavior in the future.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle&lt;/code&gt; 은 Using 닫혀 있지 않습니다 &lt;code&gt;filehandle.close()&lt;/code&gt; 메소드를 자동으로 가까운 파일 설명함으로써 메모리 누수를 방지하는 데 도움 프로세스 경고를 방출 할 수 있습니다. 이 동작은 신뢰할 수없고 파일이 닫히지 않을 수 있으므로 의존하지 마십시오. 대신 항상 명시 적으로 &lt;code&gt;FileHandle&lt;/code&gt; 을 닫으십시오 . Node.js는 향후이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76bfcfe08560cc38ebb9027a9665da61eb3fd24d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FileHandle&lt;/code&gt; is not closed using the &lt;code&gt;filehandle.close()&lt;/code&gt; method, it might automatically close the file descriptor and will emit a process warning, thereby helping to prevent memory leaks. Please do not rely on this behavior in your code because it is unreliable and your file may not be closed. Instead, always explicitly close &lt;code&gt;FileHandle&lt;/code&gt;s. Node.js may change this behavior in the future.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle&lt;/code&gt; 은 Using 닫혀 있지 않습니다 &lt;code&gt;filehandle.close()&lt;/code&gt; 메소드를 자동으로 가까운 파일 설명함으로써 메모리 누수를 방지하는 데 도움 프로세스 경고를 방출 할 수 있습니다. 신뢰할 수없고 파일이 닫히지 않을 수 있으므로 코드에서이 동작에 의존하지 마십시오. 대신, 항상 명시 적으로 &lt;code&gt;FileHandle&lt;/code&gt; 을 닫으십시오 . Node.js는 나중에이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7636f5713fef8dfdd138e0285e154aff46051a3c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Readable&lt;/code&gt; stream pipes into a &lt;code&gt;Writable&lt;/code&gt; stream when &lt;code&gt;Writable&lt;/code&gt; emits an error, the &lt;code&gt;Readable&lt;/code&gt; stream will be unpiped.</source>
          <target state="translated">경우 &lt;code&gt;Readable&lt;/code&gt; 에 스트림 파이프 &lt;code&gt;Writable&lt;/code&gt; 스트림이 때 &lt;code&gt;Writable&lt;/code&gt; 오류를 방출의 &lt;code&gt;Readable&lt;/code&gt; 스트림은 unpiped 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="78672ea6b1dc7ca181368392e827ff3e0f3423b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;callback&lt;/code&gt; function is provided, it is called with the arguments &lt;code&gt;(error, stdout, stderr)&lt;/code&gt;. On success, &lt;code&gt;error&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;. On error, &lt;code&gt;error&lt;/code&gt; will be an instance of &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;error.code&lt;/code&gt; property will be the exit code of the child process while &lt;code&gt;error.signal&lt;/code&gt; will be set to the signal that terminated the process. Any exit code other than &lt;code&gt;0&lt;/code&gt; is considered to be an error.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되는, 그것은 인수로 호출 &lt;code&gt;(error, stdout, stderr)&lt;/code&gt; . 성공하면 &lt;code&gt;error&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;error&lt;/code&gt; 가 발생하면 error 는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 됩니다 . &lt;code&gt;error.code&lt;/code&gt; 의 동안 속성은 자식 프로세스의 종료 코드가 될 것이다 &lt;code&gt;error.signal&lt;/code&gt; 이 프로세스가 종료 신호로 설정됩니다. &lt;code&gt;0&lt;/code&gt; 이외의 종료 코드 는 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f1fd1a5f0bbc36c9eb32ac42c02ad8a7115bb8" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;callback&lt;/code&gt; function is provided, it is called with the arguments &lt;code&gt;(error, stdout, stderr)&lt;/code&gt;. On success, &lt;code&gt;error&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;. On error, &lt;code&gt;error&lt;/code&gt; will be an instance of &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;error.code&lt;/code&gt; property will be the exit code of the process. By convention, any exit code other than &lt;code&gt;0&lt;/code&gt; indicates an error. &lt;code&gt;error.signal&lt;/code&gt; will be the signal that terminated the process.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되는, 그것은 인수로 호출 &lt;code&gt;(error, stdout, stderr)&lt;/code&gt; . 성공하면 &lt;code&gt;error&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 이 됩니다. 오류시 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 됩니다 . &lt;code&gt;error.code&lt;/code&gt; 의 속성은 프로세스의 종료 코드가 될 것입니다. 규칙에 따라 &lt;code&gt;0&lt;/code&gt; 이 아닌 모든 종료 코드 는 오류를 나타냅니다. &lt;code&gt;error.signal&lt;/code&gt; 은 프로세스를 종료 한 신호입니다.</target>
        </trans-unit>
        <trans-unit id="d71bf697bd9ed17929e16c7fe1ca5b3ec8d9ee88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;callback&lt;/code&gt; function is provided, the bytes are generated asynchronously and the &lt;code&gt;callback&lt;/code&gt; function is invoked with two arguments: &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;buf&lt;/code&gt;. If an error occurs, &lt;code&gt;err&lt;/code&gt; will be an &lt;code&gt;Error&lt;/code&gt; object; otherwise it is &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;buf&lt;/code&gt; argument is a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; containing the generated bytes.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되는, 바이트는 비동기 적으로 발생하고 &lt;code&gt;callback&lt;/code&gt; 함수는 두 개의 인수로 호출 : &lt;code&gt;err&lt;/code&gt; 와 &lt;code&gt;buf&lt;/code&gt; . 에러가 발생하면 &lt;code&gt;err&lt;/code&gt; 는 &lt;code&gt;Error&lt;/code&gt; 객체가됩니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;buf&lt;/code&gt; 인수는 인 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 생성 된 바이트를 포함.</target>
        </trans-unit>
        <trans-unit id="1fe1f30b4c9b95923fed5f2232de9d45764b8782" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;publicKeyEncoding&lt;/code&gt; or &lt;code&gt;privateKeyEncoding&lt;/code&gt; was specified, this function behaves as if &lt;a href=&quot;#crypto_keyobject_export_options&quot;&gt;&lt;code&gt;keyObject.export()&lt;/code&gt;&lt;/a&gt; had been called on its result. Otherwise, the respective part of the key is returned as a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;publicKeyEncoding&lt;/code&gt; 또는 &lt;code&gt;privateKeyEncoding&lt;/code&gt; 가 지정이 기능의 동작합니다는 것처럼 &lt;a href=&quot;#crypto_keyobject_export_options&quot;&gt; &lt;code&gt;keyObject.export()&lt;/code&gt; &lt;/a&gt; 의 결과라고했다. 그렇지 않으면 키의 각 부분이 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="51deb4bb79f95f2aaa6a873a1acfac78b4899391" translate="yes" xml:space="preserve">
          <source>If a call to &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;stream.write(chunk)&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;'drain'&lt;/code&gt; event will be emitted when it is appropriate to resume writing data to the stream.</source>
          <target state="translated">를 호출하면 &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;stream.write(chunk)&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;'drain'&lt;/code&gt; 이벤트는 스트림에 데이터를 기록 재개 할 적절한 때 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="19d0f4f13350bd3ee24d918da0e3399f81fec5d4" translate="yes" xml:space="preserve">
          <source>If a child process waits to read all of its input, the child will not continue until this stream has been closed via &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">자식 프로세스가 모든 입력을 읽기를 기다리는 경우 &lt;code&gt;end()&lt;/code&gt; 를 통해이 스트림이 닫힐 때까지 자식은 계속되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="716b4434ddf0060b829e790aa3148ff698f2d32a" translate="yes" xml:space="preserve">
          <source>If a client connection emits an &lt;code&gt;'error'&lt;/code&gt; event, it will be forwarded here. Listener of this event is responsible for closing/destroying the underlying socket. For example, one may wish to more gracefully close the socket with a custom HTTP response instead of abruptly severing the connection.</source>
          <target state="translated">클라이언트 연결에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트 가 발생하면 여기에 전달됩니다. 이 이벤트의 리스너는 기본 소켓을 닫거나 파기합니다. 예를 들어, 갑자기 연결을 끊는 대신 사용자 정의 HTTP 응답으로 소켓을 더 우아하게 닫으려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9eaec49bed36b6ca87fda5a245016810370aec" translate="yes" xml:space="preserve">
          <source>If a file descriptor is specified as the &lt;code&gt;path&lt;/code&gt;, it will not be closed automatically.</source>
          <target state="translated">파일 디스크립터가 &lt;code&gt;path&lt;/code&gt; 로 지정되면 자동으로 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f96071afe83eecc5cfcae2d7a7ee17d1e0affb31" translate="yes" xml:space="preserve">
          <source>If a package has no exports, setting &lt;code&gt;&quot;exports&quot;: false&lt;/code&gt; can be used instead of &lt;code&gt;&quot;exports&quot;: {}&lt;/code&gt; to indicate the package does not intend for submodules to be exposed.</source>
          <target state="translated">패키지에 내보내기가 없으면 &lt;code&gt;&quot;exports&quot;: {}&lt;/code&gt; 대신 &lt;code&gt;&quot;exports&quot;: false&lt;/code&gt; 설정을 사용 하여 패키지가 하위 모듈을 노출하지 않을 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="befb840f0c304a4ba984a452b3cf589e473513c9" translate="yes" xml:space="preserve">
          <source>If a specifier does not have a corresponding argument, it is not replaced:</source>
          <target state="translated">지정자에 해당 인수가없는 경우 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="242ed9ff0f40532cd444703af82e0f6ef23742bc" translate="yes" xml:space="preserve">
          <source>If a v4 or v6 address is not specified, it is set to the default, and the operating system will choose a local address automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8cb689864546346536757da11d32272821e8a8" translate="yes" xml:space="preserve">
          <source>If a zero-length string is passed as &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt;, the current working directory will be used instead of the zero-length strings.</source>
          <target state="translated">길이가 0 인 문자열이 &lt;code&gt;from&lt;/code&gt; 또는 &lt;code&gt;to&lt;/code&gt; 로 전달되면 길이가 0 인 문자열 대신 현재 작업 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72c0aa7997742e011b6c6546031b1bafcecaca22" translate="yes" xml:space="preserve">
          <source>If accuracy is important, use &lt;code&gt;cluster.settings&lt;/code&gt;.</source>
          <target state="translated">정확성이 중요하면 &lt;code&gt;cluster.settings&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaa668d37d6ad8ca97da96b8f2b8381c75117854" translate="yes" xml:space="preserve">
          <source>If additional information is required upon an API returning a failed status, it can be obtained by calling &lt;code&gt;napi_get_last_error_info&lt;/code&gt;.</source>
          <target state="translated">API가 실패 상태를 리턴 할 때 추가 정보가 필요한 경우 &lt;code&gt;napi_get_last_error_info&lt;/code&gt; 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71cfeeeefb7ddfea89821aaea3da4b7924a82121" translate="yes" xml:space="preserve">
          <source>If after processing all given &lt;code&gt;path&lt;/code&gt; segments an absolute path has not yet been generated, the current working directory is used.</source>
          <target state="translated">주어진 모든 &lt;code&gt;path&lt;/code&gt; 세그먼트를 처리 한 후에 절대 경로가 아직 생성되지 않은 경우 현재 작업 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3fb95e056ed158abf8fb5d11fc358a410b3a4d1" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown and a value is provided for the &lt;code&gt;message&lt;/code&gt; parameter, the value of &lt;code&gt;message&lt;/code&gt; will be appended to the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; message:</source>
          <target state="translated">는 IF &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를가&lt;/a&gt; 발생되고, 값이 제공된다 &lt;code&gt;message&lt;/code&gt; 파라미터의 값 &lt;code&gt;message&lt;/code&gt; 받는 첨부한다 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 메시지 :</target>
        </trans-unit>
        <trans-unit id="c8158143fcff0e4b6d3c4013f6abb4d504f41f45" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AbortSignal&lt;/code&gt; is specified in the &lt;code&gt;options&lt;/code&gt; and it is triggered while the &lt;code&gt;Promise&lt;/code&gt; is pending, the &lt;code&gt;Promise&lt;/code&gt; will be rejected with an &lt;code&gt;AbortError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8187873900b537e036c18f24394fdf7c2e0317c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AssertionError&lt;/code&gt; is thrown and a value is provided for the &lt;code&gt;message&lt;/code&gt; parameter, the value of &lt;code&gt;message&lt;/code&gt; will be appended to the &lt;code&gt;AssertionError&lt;/code&gt; message:</source>
          <target state="translated">는 IF &lt;code&gt;AssertionError&lt;/code&gt; 를가 발생되고, 값이 제공된다 &lt;code&gt;message&lt;/code&gt; 파라미터의 값 &lt;code&gt;message&lt;/code&gt; 받는 첨부한다 &lt;code&gt;AssertionError&lt;/code&gt; 메시지 :</target>
        </trans-unit>
        <trans-unit id="d0b02b176e8a20c608d564c5cc70e6b95982af42" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EventEmitter&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; have at least one listener registered for the &lt;code&gt;'error'&lt;/code&gt; event, and an &lt;code&gt;'error'&lt;/code&gt; event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.</source>
          <target state="translated">는 IF &lt;code&gt;EventEmitter&lt;/code&gt; 는 않습니다 &lt;em&gt;하지&lt;/em&gt; 에 등록 된 적어도 하나 개의 수신기가 &lt;code&gt;'error'&lt;/code&gt; 이벤트를, 그리고 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 방출되는 오류는 스택 추적이 인쇄되어 발생하고, Node.js를 프로세스가 종료된다.</target>
        </trans-unit>
        <trans-unit id="a9365a584afade646fe0d5b6c0c7d3bdfc0ab158" translate="yes" xml:space="preserve">
          <source>If an asynchronous operation is needed for logging, it is possible to keep track of what caused the asynchronous operation using the information provided by AsyncHooks itself. The logging should then be skipped when it was the logging itself that caused AsyncHooks callback to call. By doing this the otherwise infinite recursion is broken.</source>
          <target state="translated">로깅에 비동기 작업이 필요한 경우 AsyncHooks 자체에서 제공 한 정보를 사용하여 비동기 작업의 원인을 추적 할 수 있습니다. 그런 다음 로깅 자체가 AsyncHooks 콜백을 호출 한 원인 일 때 로깅을 건너 뛰어야합니다. 이렇게하면 무한 재귀가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8e48f1c656e862702dd245640f6418ecf40628" translate="yes" xml:space="preserve">
          <source>If an error is thrown and it is the same type as that specified by the &lt;code&gt;error&lt;/code&gt; parameter, then an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown. If the error is of a different type, or if the &lt;code&gt;error&lt;/code&gt; parameter is undefined, the error is propagated back to the caller.</source>
          <target state="translated">오류가 발생하고 &lt;code&gt;error&lt;/code&gt; 매개 변수에 지정된 유형과 동일한 경우 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 오류가 다른 유형이거나 &lt;code&gt;error&lt;/code&gt; 매개 변수가 정의되지 않은 경우 오류는 호출자에게 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="c79166257f7aba2eefa6b4c14e6926c016bcf315" translate="yes" xml:space="preserve">
          <source>If an error is thrown and it is the same type as that specified by the &lt;code&gt;error&lt;/code&gt; parameter, then an &lt;code&gt;AssertionError&lt;/code&gt; is thrown. If the error is of a different type, or if the &lt;code&gt;error&lt;/code&gt; parameter is undefined, the error is propagated back to the caller.</source>
          <target state="translated">오류가 발생하고 &lt;code&gt;error&lt;/code&gt; 매개 변수로 지정된 유형과 동일한 유형 인 경우 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생합니다. 오류가 다른 유형이거나 &lt;code&gt;error&lt;/code&gt; 매개 변수가 정의되지 않은 경우 오류는 호출자에게 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="35ce67c2f991bd2d7b89402a112bf7ff79f1656d" translate="yes" xml:space="preserve">
          <source>If an error occurs an &lt;code&gt;Error&lt;/code&gt; will be thrown, otherwise the derived key will be returned as a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에러가 발생하면 &lt;code&gt;Error&lt;/code&gt; 가 발생하고, 그렇지 않으면 파생 된 키가 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b6e1e560aaa002865abca4a1a9306578fe0ed21" translate="yes" xml:space="preserve">
          <source>If an error occurs while attempting to read the file data, the &lt;code&gt;Http2Stream&lt;/code&gt; will be closed using an &lt;code&gt;RST_STREAM&lt;/code&gt; frame using the standard &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; code. If the &lt;code&gt;onError&lt;/code&gt; callback is defined, then it will be called. Otherwise the stream will be destroyed.</source>
          <target state="translated">파일 데이터를 읽는 중 오류가 발생 하면 표준 &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; 코드 를 사용하여 &lt;code&gt;RST_STREAM&lt;/code&gt; 프레임을 사용 하여 &lt;code&gt;Http2Stream&lt;/code&gt; 이 닫힙니다 . 상기 중간 &lt;code&gt;onError&lt;/code&gt; 콜백이 정의되고, 다음 호출 할 것입니다. 그렇지 않으면 스트림이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="463518efe745a40c03960254543ea284c97ae66b" translate="yes" xml:space="preserve">
          <source>If an option that takes a single value (such as &lt;code&gt;--max-http-header-size&lt;/code&gt;) is passed more than once, then the last passed value is used. Options from the command line take precedence over options passed through the &lt;a href=&quot;#cli_node_options_options&quot;&gt;&lt;code&gt;NODE_OPTIONS&lt;/code&gt;&lt;/a&gt; environment variable.</source>
          <target state="translated">단일 값 (예 : &lt;code&gt;--max-http-header-size&lt;/code&gt; )을 사용 하는 옵션이 두 번 이상 전달되면 마지막으로 전달 된 값이 사용됩니다. 명령 줄의 옵션은 &lt;a href=&quot;#cli_node_options_options&quot;&gt; &lt;code&gt;NODE_OPTIONS&lt;/code&gt; &lt;/a&gt; 환경 변수를 통해 전달 된 옵션보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="d1a330a40cb4ac6defe3e8f84d892970fa36e7a4" translate="yes" xml:space="preserve">
          <source>If an option value contains a space, it can be escaped using double quotes:</source>
          <target state="translated">옵션 값에 공백이 포함 된 경우 큰 따옴표를 사용하여 이스케이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df9e85a9260ce43a2b0e0f5761178c04dc16852e" translate="yes" xml:space="preserve">
          <source>If an uncaught exception occurs during execution of the callback, then &lt;code&gt;after&lt;/code&gt; will run &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted or a &lt;code&gt;domain&lt;/code&gt;'s handler runs.</source>
          <target state="translated">캐치되지 않는 예외가 콜백의 실행 중에 발생하는 경우, &lt;code&gt;after&lt;/code&gt; 실행 &lt;em&gt;한 후 &lt;/em&gt; &lt;code&gt;'uncaughtException'&lt;/code&gt; 이벤트가 방출이나되는 &lt;code&gt;domain&lt;/code&gt; 의 핸들러가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9abd45ba34315ef2e5f5a8166fc8ee079e4c8bd9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;AsyncHook&lt;/code&gt; callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all &lt;code&gt;'uncaughtException'&lt;/code&gt; listeners are removed, thus forcing the process to exit. The &lt;code&gt;'exit'&lt;/code&gt; callbacks will still be called unless the application is run with &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt;, in which case a stack trace will be printed and the application exits, leaving a core file.</source>
          <target state="translated">어떤 경우 &lt;code&gt;AsyncHook&lt;/code&gt; 의 콜백 던져, 응용 프로그램이 스택 트레이스를 출력하고 프로그램을 종료합니다. 종료 경로는 포착되지 않은 예외의 경로를 따르지만 모든 &lt;code&gt;'uncaughtException'&lt;/code&gt; 리스너가 제거되므로 프로세스가 강제 종료됩니다. &lt;code&gt;'exit'&lt;/code&gt; 응용 프로그램이 실행되지 않는 콜백은 여전히 호출됩니다 &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; 스택 추적이 인쇄 될 경우에, 그리고 응용 프로그램이 종료 코어 파일을 떠나.</target>
        </trans-unit>
        <trans-unit id="a3c2fb5aeb80ff1e6a756547b4e43eebdf07b06d" translate="yes" xml:space="preserve">
          <source>If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an &lt;code&gt;'error'&lt;/code&gt; event is emitted on the returned request object. As with all &lt;code&gt;'error'&lt;/code&gt; events, if no listeners are registered the error will be thrown.</source>
          <target state="translated">요청 중에 오류가 발생하면 (DNS 확인, TCP 수준 오류 또는 실제 HTTP 구문 분석 오류 등) 반환 된 요청 개체에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 발생합니다. 모든 &lt;code&gt;'error'&lt;/code&gt; 이벤트 와 마찬가지로 리스너가 등록되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06830b91ba14a727d7329b340f5f6d345019e8ff" translate="yes" xml:space="preserve">
          <source>If any of the accessibility checks fail, an &lt;code&gt;Error&lt;/code&gt; will be thrown. Otherwise, the method will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">접근성 검사 중 하나라도 실패하면 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다. 그렇지 않으면 메소드는 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a8ed6b7de64a4dc0fb3512c0172d90c5572fb261" translate="yes" xml:space="preserve">
          <source>If asynchronous scheduling functions such as &lt;code&gt;process.nextTick()&lt;/code&gt;, &lt;code&gt;queueMicrotask()&lt;/code&gt;, &lt;code&gt;setTimeout()&lt;/code&gt;, &lt;code&gt;setImmediate()&lt;/code&gt;, etc. are made available inside a &lt;code&gt;vm.Context&lt;/code&gt;, functions passed to them will be added to global queues, which are shared by all contexts. Therefore, callbacks passed to those functions are not controllable through the timeout either.</source>
          <target state="translated">&lt;code&gt;process.nextTick()&lt;/code&gt; , &lt;code&gt;queueMicrotask()&lt;/code&gt; , &lt;code&gt;setTimeout()&lt;/code&gt; , &lt;code&gt;setImmediate()&lt;/code&gt; 등과 같은 비동기 스케줄링 함수 가 &lt;code&gt;vm.Context&lt;/code&gt; 내에서 사용 가능 해지면 전달 된 함수가 글로벌 큐에 추가되며, 모든 컨텍스트. 따라서 이러한 함수에 전달 된 콜백도 시간 제한을 통해 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f00574817cda32e310f4a196609e7e58a2faf71" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is a &lt;code&gt;TypedArray&lt;/code&gt; with more than one byte per entry, such as &lt;code&gt;Uint16Array&lt;/code&gt;, the result will be computed using the platform byte order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1c37de1fe1d451576d6332685c82c3afa01dbe" translate="yes" xml:space="preserve">
          <source>If available on the operating system, the following constants are exported in &lt;code&gt;os.constants.dlopen&lt;/code&gt;. See &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;&lt;code&gt;dlopen(3)&lt;/code&gt;&lt;/a&gt; for detailed information.</source>
          <target state="translated">운영 체제에서 사용 가능한 경우 다음 상수가 &lt;code&gt;os.constants.dlopen&lt;/code&gt; 으로 내보내집니다 . 자세한 내용은 &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt; &lt;code&gt;dlopen(3)&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="596758a71652411a2826cbd0e26ead1fd7f3fb53" translate="yes" xml:space="preserve">
          <source>If available, dynamically load a pointer to the function using &lt;code&gt;uv_dlsym()&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;uv_dlsym()&lt;/code&gt; 사용하여 함수에 대한 포인터를 동적으로로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="69820efdd034979319e195a688ede9f09c30edb5" translate="yes" xml:space="preserve">
          <source>If binding fails, an &lt;code&gt;'error'&lt;/code&gt; event is generated. In rare case (e.g. attempting to bind with a closed socket), an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">바인딩이 실패하면 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 생성됩니다. 드문 경우이지만 (예 : 닫힌 소켓으로 바인딩하려고하면) &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bd9b1569d617528476c8d627bf6c4627b7d9276" translate="yes" xml:space="preserve">
          <source>If bootstrapping has not yet finished on the main thread the properties have the value of &lt;code&gt;0&lt;/code&gt;. The ELU is immediately available on &lt;a href=&quot;worker_threads#worker_threads_worker_threads&quot;&gt;Worker threads&lt;/a&gt; since bootstrap happens within the event loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148a3b906ccba4e63b6b43ff0083706c9229c3a5" translate="yes" xml:space="preserve">
          <source>If both &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; are defined, the &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field takes precedence over &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; are not specific to ES modules or CommonJS; &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; is overridden by &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; if it exists. As such &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; cannot be used as a fallback for CommonJS but it can be used as a fallback for legacy versions of Node.js that do not support the &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68c86b6833301dfcce43bc788132f9c75a181e6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;'readable'&lt;/code&gt; and &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; are used at the same time, &lt;code&gt;'readable'&lt;/code&gt; takes precedence in controlling the flow, i.e. &lt;code&gt;'data'&lt;/code&gt; will be emitted only when &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; is called. The &lt;code&gt;readableFlowing&lt;/code&gt; property would become &lt;code&gt;false&lt;/code&gt;. If there are &lt;code&gt;'data'&lt;/code&gt; listeners when &lt;code&gt;'readable'&lt;/code&gt; is removed, the stream will start flowing, i.e. &lt;code&gt;'data'&lt;/code&gt; events will be emitted without calling &lt;code&gt;.resume()&lt;/code&gt;.</source>
          <target state="translated">경우 모두 &lt;code&gt;'readable'&lt;/code&gt; 및 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 동시에 사용되며, &lt;code&gt;'readable'&lt;/code&gt; 즉, 흐름 제어에 우선한다 &lt;code&gt;'data'&lt;/code&gt; 때만 발광한다 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 호출된다. &lt;code&gt;readableFlowing&lt;/code&gt; 속성이 될 것입니다 &lt;code&gt;false&lt;/code&gt; . 이 경우 &lt;code&gt;'data'&lt;/code&gt; 때 청취자 &lt;code&gt;'readable'&lt;/code&gt; 제거되고, 스트림이 흐르는 시작됩니다, 즉 &lt;code&gt;'data'&lt;/code&gt; 이벤트는 호출하지 않고 방출됩니다 &lt;code&gt;.resume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb11ecdf178c1cb711e0a8eae9d9fb2fb97443b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;fill&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt; are specified, the allocated &lt;code&gt;Buffer&lt;/code&gt; will be initialized by calling &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt;&lt;code&gt;buf.fill(fill, encoding)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;fill&lt;/code&gt; 과 &lt;code&gt;encoding&lt;/code&gt; 지정되며, 상기 할당 된 &lt;code&gt;Buffer&lt;/code&gt; 호출하여 초기화한다 &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt; &lt;code&gt;buf.fill(fill, encoding)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4093e8ebac89975d459aaad8fd6437be71fb3935" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; are specified, the objects are merged, with the &lt;code&gt;options&lt;/code&gt; properties taking precedence.</source>
          <target state="translated">두 경우 &lt;code&gt;url&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 지정, 객체는 함께 병합 &lt;code&gt;options&lt;/code&gt; 우선 순위를 복용 속성.</target>
        </trans-unit>
        <trans-unit id="6c4d968b22b1df3d2e79d51e79be1c024e9931b6" translate="yes" xml:space="preserve">
          <source>If both filename and error object are passed to &lt;code&gt;writeReport()&lt;/code&gt; the error object must be the second parameter.</source>
          <target state="translated">filename과 error 객체가 &lt;code&gt;writeReport()&lt;/code&gt; 전달 되면 error 객체는 두 번째 매개 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="781d2eb2d380d26e4ab2a5dfd0c0ef2dfe2b3db4" translate="yes" xml:space="preserve">
          <source>If clients advertise support for tickets, the server will send them. The server can disable tickets by supplying &lt;code&gt;require('constants').SSL_OP_NO_TICKET&lt;/code&gt; in &lt;code&gt;secureOptions&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 티켓 지원을 광고하면 서버가 티켓을 보냅니다. 서버 제공하여 비활성화 티켓을 수행 할 수 있습니다 &lt;code&gt;require('constants').SSL_OP_NO_TICKET&lt;/code&gt; 에서 &lt;code&gt;secureOptions&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="de92f9a3546d5ea09f3d735ebbcce48b7c9578b8" translate="yes" xml:space="preserve">
          <source>If domains are in use, then all &lt;strong&gt;new&lt;/strong&gt;&lt;code&gt;EventEmitter&lt;/code&gt; objects (including Stream objects, requests, responses, etc.) will be implicitly bound to the active domain at the time of their creation.</source>
          <target state="translated">도메인을 사용중인 경우 모든 &lt;strong&gt;새 &lt;/strong&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 객체 (Stream 객체, 요청, 응답 등)는 생성시 활성 도메인에 암시 적으로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3ef976ebda6d70a05ce4c354ddd516615f12d1" translate="yes" xml:space="preserve">
          <source>If either of the following conditions is true, then the literal string &lt;code&gt;//&lt;/code&gt; will be appended to &lt;code&gt;result&lt;/code&gt;:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 &lt;code&gt;//&lt;/code&gt; 리터럴 문자열 이 &lt;code&gt;result&lt;/code&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="1edb794d4a1d426d551d17375aabde00b3477150" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;--no-deprecation&lt;/code&gt; or &lt;code&gt;--no-warnings&lt;/code&gt; command line flags are used, or if the &lt;code&gt;process.noDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;&lt;em&gt;prior&lt;/em&gt; to the first deprecation warning, the &lt;code&gt;util.deprecate()&lt;/code&gt; method does nothing.</source>
          <target state="translated">두 경우 &lt;code&gt;--no-deprecation&lt;/code&gt; 또는 &lt;code&gt;--no-warnings&lt;/code&gt; 명령 행 플래그가 사용된다, 또는 경우 &lt;code&gt;process.noDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; &lt;em&gt;이전에&lt;/em&gt; 첫 번째 중단 경고 때문에, &lt;code&gt;util.deprecate()&lt;/code&gt; 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="437218400bef270fc6098e6ccd2c613f46443a5a" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;--no-deprecation&lt;/code&gt; or &lt;code&gt;--no-warnings&lt;/code&gt; command-line flags are used, or if the &lt;code&gt;process.noDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;&lt;em&gt;prior&lt;/em&gt; to the first deprecation warning, the &lt;code&gt;util.deprecate()&lt;/code&gt; method does nothing.</source>
          <target state="translated">두 경우 &lt;code&gt;--no-deprecation&lt;/code&gt; 또는 &lt;code&gt;--no-warnings&lt;/code&gt; 명령 줄 플래그 사용, 또는 경우 &lt;code&gt;process.noDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; &lt;em&gt;이전에&lt;/em&gt; 첫 번째 중단 경고 때문에, &lt;code&gt;util.deprecate()&lt;/code&gt; 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="956685bdc299adef90da52130e4b0d27fa2c297c" translate="yes" xml:space="preserve">
          <source>If emitted, the &lt;code&gt;'spawn'&lt;/code&gt; event comes before all other events and before any data is received via &lt;code&gt;stdout&lt;/code&gt; or &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98aa649de478c0f47590b643bddfcf1f1c12b6e6" translate="yes" xml:space="preserve">
          <source>If formatting elements (e.g. &lt;code&gt;%d&lt;/code&gt;) are not found in the first string then &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;&lt;code&gt;util.inspect()&lt;/code&gt;&lt;/a&gt; is called on each argument and the resulting string values are concatenated. See &lt;a href=&quot;util#util_util_format_format_args&quot;&gt;&lt;code&gt;util.format()&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">첫 번째 문자열에서 서식 지정 요소 (예 : &lt;code&gt;%d&lt;/code&gt; )를 찾지 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt; &lt;code&gt;util.inspect()&lt;/code&gt; &lt;/a&gt; 각 인수에서 util.inspect () 가 호출되고 결과 문자열 값이 연결됩니다. 자세한 내용은 &lt;a href=&quot;util#util_util_format_format_args&quot;&gt; &lt;code&gt;util.format()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fcd1cb474c4645e8085aa1a3dfd6acd452a0e5c6" translate="yes" xml:space="preserve">
          <source>If found, source map data is appended to the top-level key &lt;code&gt;source-map-cache&lt;/code&gt; on the JSON coverage object.</source>
          <target state="translated">발견되면 소스 맵 데이터가 JSON 커버리지 객체의 최상위 키 &lt;code&gt;source-map-cache&lt;/code&gt; 에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="eac4547e7fbaee4e63b524e438980acdf8e44d28" translate="yes" xml:space="preserve">
          <source>If given a &lt;code&gt;contextObject&lt;/code&gt;, the &lt;code&gt;vm.createContext()&lt;/code&gt; method will &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;prepare that object&lt;/a&gt; so that it can be used in calls to &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedobject_options&quot;&gt;&lt;code&gt;vm.runInContext()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#vm_script_runincontext_contextifiedobject_options&quot;&gt;&lt;code&gt;script.runInContext()&lt;/code&gt;&lt;/a&gt;. Inside such scripts, the &lt;code&gt;contextObject&lt;/code&gt; will be the global object, retaining all of its existing properties but also having the built-in objects and functions any standard &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;global object&lt;/a&gt; has. Outside of scripts run by the vm module, global variables will remain unchanged.</source>
          <target state="translated">주어진 경우 &lt;code&gt;contextObject&lt;/code&gt; 를 상기 &lt;code&gt;vm.createContext()&lt;/code&gt; 메소드는 것이다 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;객체 준비&lt;/a&gt; 가 호출에 사용될 수있다 그래서 &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedobject_options&quot;&gt; &lt;code&gt;vm.runInContext()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#vm_script_runincontext_contextifiedobject_options&quot;&gt; &lt;code&gt;script.runInContext()&lt;/code&gt; &lt;/a&gt; . 이러한 스크립트 내에서 &lt;code&gt;contextObject&lt;/code&gt; 는 기존의 모든 속성을 유지하면서 표준 &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;전역 개체에&lt;/a&gt; 내장 된 개체와 함수를 갖는 전역 개체 가됩니다. vm 모듈에 의해 실행되는 스크립트 외부에서 전역 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef6daec57d79612028ad2d0945f9175e3244f8b8" translate="yes" xml:space="preserve">
          <source>If given a &lt;code&gt;sandbox&lt;/code&gt; object, the &lt;code&gt;vm.createContext()&lt;/code&gt; method will &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;prepare that sandbox&lt;/a&gt; so that it can be used in calls to &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedsandbox_options&quot;&gt;&lt;code&gt;vm.runInContext()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#vm_script_runincontext_contextifiedsandbox_options&quot;&gt;&lt;code&gt;script.runInContext()&lt;/code&gt;&lt;/a&gt;. Inside such scripts, the &lt;code&gt;sandbox&lt;/code&gt; object will be the global object, retaining all of its existing properties but also having the built-in objects and functions any standard &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;global object&lt;/a&gt; has. Outside of scripts run by the vm module, global variables will remain unchanged.</source>
          <target state="translated">주어진 경우 &lt;code&gt;sandbox&lt;/code&gt; 객체를 상기 &lt;code&gt;vm.createContext()&lt;/code&gt; 메소드는 것 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;즉 샌드 준비&lt;/a&gt; 가로 통화에 사용될 수 있도록 &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedsandbox_options&quot;&gt; &lt;code&gt;vm.runInContext()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#vm_script_runincontext_contextifiedsandbox_options&quot;&gt; &lt;code&gt;script.runInContext()&lt;/code&gt; &lt;/a&gt; . 이러한 스크립트 내부의 &lt;code&gt;sandbox&lt;/code&gt; 객체는 기존의 모든 속성을 유지뿐만 아니라 내장 객체 및 표준 기능을 가진, 전역 객체가 될 것이다 &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;전역 객체가&lt;/a&gt; 있다. vm 모듈에서 실행하는 스크립트 외부에서는 전역 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0224f657dc067d60f107db3f7b9acbd276a22bc9" translate="yes" xml:space="preserve">
          <source>If headers are supported by the application protocol in use for a given &lt;code&gt;QuicSession&lt;/code&gt;, the &lt;code&gt;'initialHeaders'&lt;/code&gt;, &lt;code&gt;'informationalHeaders'&lt;/code&gt;, and &lt;code&gt;'trailingHeaders'&lt;/code&gt; events will be emitted by the &lt;code&gt;QuicStream&lt;/code&gt; object when headers are received; and the &lt;code&gt;submitInformationalHeaders()&lt;/code&gt;, &lt;code&gt;submitInitialHeaders()&lt;/code&gt;, and &lt;code&gt;submitTrailingHeaders()&lt;/code&gt; methods can be used to send headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf19ec31a54f53d6dbad913afdb80c5c013e023" translate="yes" xml:space="preserve">
          <source>If importing a &lt;code&gt;'PBKDF2'&lt;/code&gt; key, &lt;code&gt;extractable&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79789a5254327b894116d434ddd2c5bab864e280" translate="yes" xml:space="preserve">
          <source>If it is necessary to terminate the Node.js process due to an error condition, throwing an &lt;em&gt;uncaught&lt;/em&gt; error and allowing the process to terminate accordingly is safer than calling &lt;code&gt;process.exit()&lt;/code&gt;.</source>
          <target state="translated">오류 조건으로 인해 Node.js 프로세스를 종료해야하는 경우 &lt;em&gt;catch되지 않은&lt;/em&gt; 오류가 발생하여 프로세스가 종료되도록 허용하는 것이 &lt;code&gt;process.exit()&lt;/code&gt; 호출하는 것보다 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="49d1021878ab098e47def050c750dc4a07325a5f" translate="yes" xml:space="preserve">
          <source>If it is not found there, then it moves to the parent directory, and so on, until the root of the file system is reached.</source>
          <target state="translated">찾을 수 없으면 파일 시스템의 루트에 도달 할 때까지 상위 디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="57ecbec6d9d4f38cf1822faac1b3e8d1f4214263" translate="yes" xml:space="preserve">
          <source>If listeners are attached or removed using &lt;code&gt;.on('message')&lt;/code&gt;, the port is &lt;code&gt;ref()&lt;/code&gt;ed and &lt;code&gt;unref()&lt;/code&gt;ed automatically depending on whether listeners for the event exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818c99e33248acd389a413f2d1a026a1130b44fa" translate="yes" xml:space="preserve">
          <source>If listeners are attached or removed using &lt;code&gt;.on('message')&lt;/code&gt;, the port will be &lt;code&gt;ref()&lt;/code&gt;ed and &lt;code&gt;unref()&lt;/code&gt;ed automatically depending on whether listeners for the event exist.</source>
          <target state="translated">&lt;code&gt;.on('message')&lt;/code&gt; 을 사용하여 리스너를 연결하거나 제거 하면 이벤트 리스너의 존재 여부에 따라 포트가 자동으로 &lt;code&gt;ref()&lt;/code&gt; 및 &lt;code&gt;unref()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad034aac2c274cf31ed92eba6269a2ff5528a593" translate="yes" xml:space="preserve">
          <source>If multicastInterface can not be parsed into an IP then an &lt;code&gt;EINVAL&lt;/code&gt; System Error is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaf9326eed1511be3e79d3268fda1e5de037c83" translate="yes" xml:space="preserve">
          <source>If necessary, there is an additional pair of &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; and &lt;code&gt;RemoveEnvironmentCleanupHook()&lt;/code&gt; overloads, where the cleanup hook takes a callback function. This can be used for shutting down asynchronous resources, such as any libuv handles registered by the addon.</source>
          <target state="translated">필요한 경우 추가 &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; 및 &lt;code&gt;RemoveEnvironmentCleanupHook()&lt;/code&gt; 오버로드 쌍이 있으며 , 여기서 정리 후크는 콜백 함수를 사용합니다. 애드온에 의해 등록 된 libuv 핸들과 같은 비동기 리소스를 종료하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8980465e182336a46cb1cd079419daceb92d282c" translate="yes" xml:space="preserve">
          <source>If needed, a &lt;code&gt;require&lt;/code&gt; function can be constructed within an ES module using &lt;a href=&quot;module#module_module_createrequire_filename&quot;&gt;&lt;code&gt;module.createRequire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76636b0f1944e7d4d859fa8d9c5002000eb7958f" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;#http_event_response&quot;&gt;&lt;code&gt;'response'&lt;/code&gt;&lt;/a&gt; handler is added, then the response will be entirely discarded. However, if a &lt;a href=&quot;#http_event_response&quot;&gt;&lt;code&gt;'response'&lt;/code&gt;&lt;/a&gt; event handler is added, then the data from the response object &lt;strong&gt;must&lt;/strong&gt; be consumed, either by calling &lt;code&gt;response.read()&lt;/code&gt; whenever there is a &lt;code&gt;'readable'&lt;/code&gt; event, or by adding a &lt;code&gt;'data'&lt;/code&gt; handler, or by calling the &lt;code&gt;.resume()&lt;/code&gt; method. Until the data is consumed, the &lt;code&gt;'end'&lt;/code&gt; event will not fire. Also, until the data is read it will consume memory that can eventually lead to a 'process out of memory' error.</source>
          <target state="translated">&lt;a href=&quot;#http_event_response&quot;&gt; &lt;code&gt;'response'&lt;/code&gt; &lt;/a&gt; 핸들러가 추가 되지 않으면 응답이 완전히 삭제됩니다. 그러나 &lt;a href=&quot;#http_event_response&quot;&gt; &lt;code&gt;'response'&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러가 추가되면 &lt;code&gt;'readable'&lt;/code&gt; 이벤트 가있을 때마다 &lt;code&gt;response.read()&lt;/code&gt; 를 호출 하거나 &lt;code&gt;'data'&lt;/code&gt; 핸들러를 추가 하여 응답 오브젝트의 데이터를 이용 &lt;strong&gt;해야합니다&lt;/strong&gt; . &lt;code&gt;.resume()&lt;/code&gt; 메소드 를 호출하여 데이터가 소비 될 때까지 &lt;code&gt;'end'&lt;/code&gt; 이벤트가 발생하지 않습니다. 또한 데이터를 읽을 때까지 메모리를 소비하여 결국 '메모리 부족 프로세스'오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d64c66f5a93c746c93ae653644f31d6a732c37" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;'timeout'&lt;/code&gt; listener is added to the request, the response, or the server, then &lt;a href=&quot;#http2_class_http2stream&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt;s are destroyed when they time out. If a handler is assigned to the request, the response, or the server's &lt;code&gt;'timeout'&lt;/code&gt; events, timed out sockets must be handled explicitly.</source>
          <target state="translated">요청, 응답 또는 서버에 &lt;code&gt;'timeout'&lt;/code&gt; 리스너가 추가 되지 않은 경우 &lt;a href=&quot;#http2_class_http2stream&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 은 시간 초과시 삭제됩니다. 핸들러가 요청, 응답 또는 서버의 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트에 할당 된 경우 시간 초과 소켓을 명시 적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="db48c4caed0a332d402ecbd0b488c664a849a378" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;'timeout'&lt;/code&gt; listener is added to the request, the response, or the server, then &lt;a href=&quot;http2&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt;s are destroyed when they time out. If a handler is assigned to the request, the response, or the server's &lt;code&gt;'timeout'&lt;/code&gt; events, timed out sockets must be handled explicitly.</source>
          <target state="translated">요청, 응답 또는 서버에 &lt;code&gt;'timeout'&lt;/code&gt; 리스너가 추가 되지 않으면 &lt;a href=&quot;http2&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 시간 초과되면 소멸됩니다. 핸들러가 요청, 응답 또는 서버의 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트에 지정된 경우 제한 시간이 초과 된 소켓을 명시 적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dec6a027c28bdbcb29abb4bffcb70b1c450217e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;'timeout'&lt;/code&gt; listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If a handler is assigned to the request, the response, or the server's &lt;code&gt;'timeout'&lt;/code&gt; events, timed out sockets must be handled explicitly.</source>
          <target state="translated">요청, 응답 또는 서버에 &lt;code&gt;'timeout'&lt;/code&gt; 리스너가 추가 되지 않으면 소켓이 시간 초과되면 소멸됩니다. 핸들러가 요청, 응답 또는 서버의 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트에 지정된 경우 제한 시간이 초과 된 소켓을 명시 적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3355f8e5210700f25827723bdd2c6be50b786d0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;callback&lt;/code&gt; function is provided and the message cannot be sent, an &lt;code&gt;'error'&lt;/code&gt; event will be emitted by the &lt;a href=&quot;#child_process_child_process&quot;&gt;&lt;code&gt;ChildProcess&lt;/code&gt;&lt;/a&gt; object. This can happen, for instance, when the child process has already exited.</source>
          <target state="translated">어떠한 경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않고, 메시지가 전송 될 수 없다 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 방출 될 &lt;a href=&quot;#child_process_child_process&quot;&gt; &lt;code&gt;ChildProcess&lt;/code&gt; 의&lt;/a&gt; 개체. 예를 들어 자식 프로세스가 이미 종료 된 경우 이런 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ea7a606cf8671c22ba56a6c0d8af64a399a3eb" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;path&lt;/code&gt; segments are passed, &lt;code&gt;path.resolve()&lt;/code&gt; will return the absolute path of the current working directory.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 세그먼트가 전달 되지 않으면 &lt;code&gt;path.resolve()&lt;/code&gt; 는 현재 작업 디렉토리의 절대 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9c2de4f19bb732c3f0d152de8a5b8d7d4bffebf" translate="yes" xml:space="preserve">
          <source>If no encoding is specified, then the raw buffer is returned.</source>
          <target state="translated">인코딩을 지정하지 않으면 원시 버퍼가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="588b09130834e51d612150950f7d586519ce31b1" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;filehandle.read()&lt;/code&gt; calls are made on a file handle and then a &lt;code&gt;filehandle.readFile()&lt;/code&gt; call is made, the data will be read from the current position till the end of the file. It doesn't always read from the beginning of the file.</source>
          <target state="translated">&lt;code&gt;filehandle.read()&lt;/code&gt; 하나 이상의 filehandle.read () 호출이 &lt;code&gt;filehandle.readFile()&lt;/code&gt; 후 filehandle.readFile () 호출이 수행되면 파일의 끝까지 현재 위치에서 데이터를 읽습니다. 항상 파일의 처음부터 읽지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a4cdac4387721b7c6d9782075b4c0d38991bb7d" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;filehandle.write()&lt;/code&gt; calls are made on a file handle and then a &lt;code&gt;filehandle.writeFile()&lt;/code&gt; call is made, the data will be written from the current position till the end of the file. It doesn't always write from the beginning of the file.</source>
          <target state="translated">&lt;code&gt;filehandle.write()&lt;/code&gt; 하나 이상의 filehandle.write () 호출이 작성된 후 &lt;code&gt;filehandle.writeFile()&lt;/code&gt; 호출이 수행되면 데이터는 현재 위치에서 파일 끝까지 기록됩니다. 항상 파일의 처음부터 쓰지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e451e4e3dec3d1e916f8a3d903d896ecce3e5cb" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;label&lt;/code&gt;s are provided, those are printed first without the additional indentation.</source>
          <target state="translated">하나 이상의 &lt;code&gt;label&lt;/code&gt; 이 제공되면 추가 들여 쓰기없이 먼저 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="fafad16c3d8a65bb35e08a7835ca2753a62ace44" translate="yes" xml:space="preserve">
          <source>If only one argument is passed to &lt;code&gt;util.format()&lt;/code&gt;, it is returned as it is without any formatting:</source>
          <target state="translated">하나의 인수 만 &lt;code&gt;util.format()&lt;/code&gt; 전달되면 형식화없이 그대로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="956a9f098caea90b182e2b8e76db03b7380ae6a1" translate="yes" xml:space="preserve">
          <source>If possible, contain all state within an instantiated object. JavaScript&amp;rsquo;s &lt;code&gt;Date&lt;/code&gt;, for example, needs to be instantiated to contain state; if it were a package, it would be used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb9aab5f2c0420b47aca35dbc4e5131b16b281" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.address&lt;/code&gt; is a string describing the address to which a network connection failed.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.address&lt;/code&gt; 는 네트워크 연결이 실패한 주소를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="09cdb4b5fc901c93bd81eddf6470508e4d3ad573" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.dest&lt;/code&gt; is the file path destination when reporting a file system error.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.dest&lt;/code&gt; 는 파일 시스템 오류를보고 할 때 파일 경로 대상입니다.</target>
        </trans-unit>
        <trans-unit id="b4d9083b9c76cf66522d9b360b5cbacf03ff7e17" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.info&lt;/code&gt; is an object with details about the error condition.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.info&lt;/code&gt; 는 오류 조건에 대한 세부 사항이있는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="b515af4cb1d6427479831ff8c31be0200be62954" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.path&lt;/code&gt; is a string containing a relevant invalid pathname.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.path&lt;/code&gt; 는 유효하지 않은 관련 경로 이름이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8f1124d661572f078414a138f0bd00a3bb201f75" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.port&lt;/code&gt; is the network connection port that is not available.</source>
          <target state="translated">있는 경우 &lt;code&gt;error.port&lt;/code&gt; 는 사용할 수없는 네트워크 연결 포트입니다.</target>
        </trans-unit>
        <trans-unit id="4028035ae455f9d1c611d0d9611d12c32c7539df" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.</source>
          <target state="translated">존재하는 경우, 복사 작업은 COW (Copy-On-Write) 참조 링크를 작성하려고 시도합니다. 기본 플랫폼이 COW (Copy-On-Write)를 지원하지 않으면 대체 복사 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4565bcf227554bcec4fb67361b463bd0162b40c7" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then the operation will fail with an error.</source>
          <target state="translated">존재하는 경우, 복사 작업은 COW (Copy-On-Write) 참조 링크를 작성하려고 시도합니다. 기본 플랫폼이 기록 중 복사를 지원하지 않으면 작업이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="111d49a62014241bc6035d869eb1ed1d88540442" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will fail with an error if the destination path already exists.</source>
          <target state="translated">있는 경우 대상 경로가 이미 있으면 복사 작업이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="873d68575189af0d0837643c7a4f9fafeebaade7" translate="yes" xml:space="preserve">
          <source>If provided, the &lt;code&gt;payload&lt;/code&gt; must be a &lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt; containing 8 bytes of data that will be transmitted with the &lt;code&gt;PING&lt;/code&gt; and returned with the ping acknowledgment.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;payload&lt;/code&gt; 는 &lt;code&gt;PING&lt;/code&gt; 과 함께 전송되고 핑 확인과 함께 반환 될 8 바이트의 데이터를 포함 하는 &lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;TypedArray&lt;/code&gt; 또는 &lt;code&gt;DataView&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="56aab6cb73797e51a41cd25d82a216acf60351b7" translate="yes" xml:space="preserve">
          <source>If represented as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt;, the value must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2174c43999d7fe2abf0da31917df9e36a4e71e" translate="yes" xml:space="preserve">
          <source>If represented as an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;&amp;lt;Object&amp;gt;&lt;/a&gt;, the object must have a &lt;code&gt;name&lt;/code&gt; property whose value is one of the above listed values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0411c641c6a25de72690be397bf9163af37a5e95" translate="yes" xml:space="preserve">
          <source>If returned as a string, no decoding of the query string is performed. If returned as an object, both keys and values are decoded.</source>
          <target state="translated">문자열로 반환되면 쿼리 문자열의 디코딩이 수행되지 않습니다. 객체로 반환되면 키와 값이 모두 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="30f5a3d64923e554e03e9538c444b7eb6e64f821" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt; then V8 will choose an appropriate size of the thread pool based on the number of online processors.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 으로 설정하면 V8은 온라인 프로세서 수에 따라 적절한 크기의 스레드 풀을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2dbbdc2030105ff8389b56a9a53a36b9214cf5d0" translate="yes" xml:space="preserve">
          <source>If set to a non-number value, or set to a negative number, stack traces will not capture any frames.</source>
          <target state="translated">숫자가 아닌 값으로 설정하거나 음수로 설정하면 스택 추적이 프레임을 캡처하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2310dc593206400dba7fbfc90d82faac7c44fa3" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; or a validation function. See &lt;a href=&quot;#assert_assert_throws_fn_error_message&quot;&gt;&lt;code&gt;assert.throws()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 또는 유효성 검증 함수일 수 있습니다. 자세한 내용은 &lt;a href=&quot;#assert_assert_throws_fn_error_message&quot;&gt; &lt;code&gt;assert.throws()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8bb4684775cedbd549e8f47ef9575c77e254eab8" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable &lt;code&gt;message&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; , 유효성 검증 함수, 각 특성이 엄격한 완전 동등성을 테스트하는 유효성 검증 오브젝트 또는 각 특성을 열거 할 수없는 &lt;code&gt;message&lt;/code&gt; 포함하여 엄격한 완전 동등성을 테스트하는 오류 인스턴스 일 수 있습니다. 그리고 &lt;code&gt;name&lt;/code&gt; 속성. 객체를 사용할 때 문자열 속성에 대해 유효성을 검사 할 때 정규식을 사용할 수도 있습니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca540d2d12b0a2843f6e0a3a615df4b350d599e5" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable &lt;code&gt;message&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; properties.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; , 유효성 검증 함수, 각 특성을 테스트 할 오브젝트 또는 열거 불가능한 &lt;code&gt;message&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 특성 을 포함하여 각 특성을 테스트 할 오류 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e483ef4da139406d2cb5576248f8f8dab3da0123" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;message&lt;/code&gt; will be appended to the message provided by the &lt;code&gt;AssertionError&lt;/code&gt; if the &lt;code&gt;fn&lt;/code&gt; call fails to throw or in case the error validation fails.</source>
          <target state="translated">지정된 경우, &lt;code&gt;fn&lt;/code&gt; 호출이 실패하거나 오류 유효성 검증에 실패하는 경우 &lt;code&gt;AssertionError&lt;/code&gt; 에서 제공 한 메시지에 &lt;code&gt;message&lt;/code&gt; 가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="f20cbcc956f20e1dcb21c6b278a74288a4a44ed7" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;message&lt;/code&gt; will be the message provided by the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if the &lt;code&gt;asyncFn&lt;/code&gt; fails to reject.</source>
          <target state="translated">지정된 경우, &lt;code&gt;message&lt;/code&gt; 에 의해 제공되는 메시지가 될 것입니다 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를&lt;/a&gt; 경우 &lt;code&gt;asyncFn&lt;/code&gt; 이 거부되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40ef9cb0ba617de6594c16374723716ca8364dd8" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;message&lt;/code&gt; will be the message provided by the &lt;code&gt;AssertionError&lt;/code&gt; if the &lt;code&gt;asyncFn&lt;/code&gt; fails to reject.</source>
          <target state="translated">지정된 경우, &lt;code&gt;message&lt;/code&gt; 에 의해 제공되는 메시지가 될 것입니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 경우 &lt;code&gt;asyncFn&lt;/code&gt; 이 거부되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25e438c74edb89edb96e2a5ee192d899ce1fcd06" translate="yes" xml:space="preserve">
          <source>If specified, the &lt;code&gt;callback&lt;/code&gt; function is registered as a handler for the &lt;code&gt;'close'&lt;/code&gt; event.</source>
          <target state="translated">지정된 경우 &lt;code&gt;callback&lt;/code&gt; 함수는 &lt;code&gt;'close'&lt;/code&gt; 이벤트에 대한 핸들러로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bce9baa7c1873a9e07cf0b4362eae06b10124e8" translate="yes" xml:space="preserve">
          <source>If specifying a host, make sure that either:</source>
          <target state="translated">호스트를 지정하는 경우 다음 중 하나를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c4567e4aed2ed0a0fa93fe7a5c794ed41d3147b1" translate="yes" xml:space="preserve">
          <source>If still valid, this API returns the &lt;code&gt;napi_value&lt;/code&gt; representing the JavaScript &lt;code&gt;Object&lt;/code&gt; associated with the &lt;code&gt;napi_ref&lt;/code&gt;. Otherwise, result will be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">계속 유효 경우,이 API는 반환 &lt;code&gt;napi_value&lt;/code&gt; 자바 스크립트 나타내는 &lt;code&gt;Object&lt;/code&gt; 과 관련된 &lt;code&gt;napi_ref&lt;/code&gt; 을 . 그렇지 않으면 결과는 &lt;code&gt;NULL&lt;/code&gt; 이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="10e41fd1ae4bbc18c802e9daabd5fdc153bddbd3" translate="yes" xml:space="preserve">
          <source>If still valid, this API returns the &lt;code&gt;napi_value&lt;/code&gt; representing the JavaScript &lt;code&gt;Object&lt;/code&gt; associated with the &lt;code&gt;napi_ref&lt;/code&gt;. Otherwise, result will be NULL.</source>
          <target state="translated">계속 유효 경우,이 API는 반환 &lt;code&gt;napi_value&lt;/code&gt; 자바 스크립트 나타내는 &lt;code&gt;Object&lt;/code&gt; 과 관련된 &lt;code&gt;napi_ref&lt;/code&gt; 을 . 그렇지 않으면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="32cb3625f10ae48bf6481f39f73a30285a56adfb" translate="yes" xml:space="preserve">
          <source>If such a function is set, the &lt;a href=&quot;#process_event_uncaughtexception&quot;&gt;&lt;code&gt;'uncaughtException'&lt;/code&gt;&lt;/a&gt; event will not be emitted. If &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; was passed from the command line or set through &lt;a href=&quot;v8#v8_v8_setflagsfromstring_flags&quot;&gt;&lt;code&gt;v8.setFlagsFromString()&lt;/code&gt;&lt;/a&gt;, the process will not abort.</source>
          <target state="translated">이러한 기능이 설정되면 &lt;a href=&quot;#process_event_uncaughtexception&quot;&gt; &lt;code&gt;'uncaughtException'&lt;/code&gt; &lt;/a&gt; 이벤트가 생성되지 않습니다. 경우 &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; 를 통해 커맨드 라인 또는 세트로부터 전달 된 &lt;a href=&quot;v8#v8_v8_setflagsfromstring_flags&quot;&gt; &lt;code&gt;v8.setFlagsFromString()&lt;/code&gt; &lt;/a&gt; , 처리를 중단하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="379ffa8a90ad7ebcb06b079cf6a7ba8d57c16f69" translate="yes" xml:space="preserve">
          <source>If such a function is set, the &lt;a href=&quot;#process_event_uncaughtexception&quot;&gt;&lt;code&gt;'uncaughtException'&lt;/code&gt;&lt;/a&gt; event will not be emitted. If &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; was passed from the command line or set through &lt;a href=&quot;v8#v8_v8_setflagsfromstring_flags&quot;&gt;&lt;code&gt;v8.setFlagsFromString()&lt;/code&gt;&lt;/a&gt;, the process will not abort. Actions configured to take place on exceptions such as report generations will be affected too</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bf9ca2a5da8cc7d9983f311f9ed193864dab2c" translate="yes" xml:space="preserve">
          <source>If support for older versions is required but a worker object is not required, it is possible to work around the discrepancy by checking the number of arguments:</source>
          <target state="translated">이전 버전에 대한 지원이 필요하지만 작업자 개체가 필요하지 않은 경우 인수 수를 확인하여 불일치를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fb44ec0e8892750cd1ebc11186c5c22676779e1" translate="yes" xml:space="preserve">
          <source>If that string is invalid but it begins with a number, the leading number is assigned to &lt;code&gt;port&lt;/code&gt;. If the number lies outside the range denoted above, it is ignored.</source>
          <target state="translated">해당 문자열이 유효하지 않지만 숫자로 시작하면 선행 번호가 &lt;code&gt;port&lt;/code&gt; 에 지정됩니다 . 숫자가 위에 표시된 범위를 벗어나면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="30817db3d7e89f5a81f3f1220a7022495364630f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#cli_openssl_config_file&quot;&gt;&lt;code&gt;--openssl-config&lt;/code&gt;&lt;/a&gt; command line option is used, the environment variable is ignored.</source>
          <target state="translated">는 IF &lt;a href=&quot;#cli_openssl_config_file&quot;&gt; &lt;code&gt;--openssl-config&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션을 사용, 환경 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3033e472b66c01ecfaa5bbb90b707ebf2914c1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#cli_openssl_config_file&quot;&gt;&lt;code&gt;--openssl-config&lt;/code&gt;&lt;/a&gt; command-line option is used, the environment variable is ignored.</source>
          <target state="translated">는 IF &lt;a href=&quot;#cli_openssl_config_file&quot;&gt; &lt;code&gt;--openssl-config&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션을 사용, 환경 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="224cfce345ee060f6c60aaa0a95c75b09e0194c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#stream_writable_cork&quot;&gt;&lt;code&gt;writable.cork()&lt;/code&gt;&lt;/a&gt; method is called multiple times on a stream, the same number of calls to &lt;code&gt;writable.uncork()&lt;/code&gt; must be called to flush the buffered data.</source>
          <target state="translated">스트림 에서 &lt;a href=&quot;#stream_writable_cork&quot;&gt; &lt;code&gt;writable.cork()&lt;/code&gt; &lt;/a&gt; 메소드를 여러 번 호출하는 경우 버퍼링 된 데이터를 플러시 하기 위해 동일한 수의 &lt;code&gt;writable.uncork()&lt;/code&gt; 호출을 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="6df3d69b18c57ef7ae8296df201d5872052ab5c2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;webcrypto#webcrypto_class_cryptokey&quot;&gt;&amp;lt;CryptoKey&amp;gt;&lt;/a&gt; is not extractable, the returned promise will reject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c9afde2fa7ee641e5638e52372934349eec5bc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;.&quot;&lt;/code&gt; export has a fallback array or string value, then the &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field can be set to this value directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcabc5bc51b94600ae9120e53323e1fc1be1f84" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;.&quot;&lt;/code&gt; export is the only export, the &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field provides sugar for this case being the direct &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5b3f12b63f281645322fde5f6167806a56f1ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'frameError'&lt;/code&gt; event is associated with a stream, the stream will be closed and destroyed immediately following the &lt;code&gt;'frameError'&lt;/code&gt; event. If the event is not associated with a stream, the &lt;code&gt;Http2Session&lt;/code&gt; will be shut down immediately following the &lt;code&gt;'frameError'&lt;/code&gt; event.</source>
          <target state="translated">는 IF &lt;code&gt;'frameError'&lt;/code&gt; 이벤트 스트림과 관련된 스트림은 다음과 같은 폐쇄 즉시 파괴됩니다 &lt;code&gt;'frameError'&lt;/code&gt; 이벤트입니다. 이벤트가 스트림과 연결되어 있지 않으면 &lt;code&gt;'frameError'&lt;/code&gt; 이벤트 직후에 &lt;code&gt;Http2Session&lt;/code&gt; 이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="61283ecdf185d229d3b74d7275c9a41649b6719b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'session'&lt;/code&gt; event handler throws an error, or if it returns a &lt;code&gt;Promise&lt;/code&gt; that is rejected, the error will be handled by destroying the &lt;code&gt;QuicServerSession&lt;/code&gt; automatically and emitting a &lt;code&gt;'sessionError'&lt;/code&gt; event on the &lt;code&gt;QuicSocket&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9d357aaf801d9f4a8827e4487d8d5454ed7da2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--no-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is suppressed.</source>
          <target state="translated">경우 &lt;code&gt;--no-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고가 억제된다.</target>
        </trans-unit>
        <trans-unit id="006f0ef98faed2225296f7b925e4b65b6d84cc50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--throw-deprecation&lt;/code&gt; command line flag is set, or the &lt;code&gt;process.throwDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, then an exception will be thrown when the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 설정하거나 &lt;code&gt;process.throwDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; 중단 된 함수가 호출 될 때, 다음 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38489b308fe17ec9f58d0e620b07ded24fcfd3c1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--throw-deprecation&lt;/code&gt; command-line flag is set, or the &lt;code&gt;process.throwDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, then an exception will be thrown when the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 설정하거나 &lt;code&gt;process.throwDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; 중단 된 함수가 호출 될 때, 다음 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b278313ccedc83446c93058abbe7d110d43e12d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--throw-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is thrown as an exception rather than being emitted as an event.</source>
          <target state="translated">는 IF &lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고가 아니라 이벤트로 방출되지 않고 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1706a10a4933ed7aef53391f01f86b49fd1f1a47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--trace-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is printed to &lt;code&gt;stderr&lt;/code&gt; along with the full stack trace.</source>
          <target state="translated">는 IF &lt;code&gt;--trace-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고하는 인쇄 &lt;code&gt;stderr&lt;/code&gt; 에 전체 스택 추적과 함께.</target>
        </trans-unit>
        <trans-unit id="9e05861e85bd6ab01a00f4754a98487ae45fddc5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--trace-deprecation&lt;/code&gt; or &lt;code&gt;--trace-warnings&lt;/code&gt; command line flags are set, or the &lt;code&gt;process.traceDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, a warning and a stack trace are printed to &lt;code&gt;stderr&lt;/code&gt; the first time the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--trace-deprecation&lt;/code&gt; 또는 &lt;code&gt;--trace-warnings&lt;/code&gt; 행 플래그가 설정하거나 명령 &lt;code&gt;process.traceDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; , 경고 및 스택 추적을 인쇄 &lt;code&gt;stderr&lt;/code&gt; 에 중단 된 함수가 호출 처음.</target>
        </trans-unit>
        <trans-unit id="417298c3e592091e16cca459b04186f92ee8383e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--trace-deprecation&lt;/code&gt; or &lt;code&gt;--trace-warnings&lt;/code&gt; command-line flags are set, or the &lt;code&gt;process.traceDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, a warning and a stack trace are printed to &lt;code&gt;stderr&lt;/code&gt; the first time the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--trace-deprecation&lt;/code&gt; 또는 &lt;code&gt;--trace-warnings&lt;/code&gt; 명령 줄 플래그 설정, 또는 &lt;code&gt;process.traceDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; , 경고 및 스택 추적을 인쇄 &lt;code&gt;stderr&lt;/code&gt; 에 중단 된 함수가 호출 처음.</target>
        </trans-unit>
        <trans-unit id="7f1727f3bb0330be161d5fae1f1aeea291145a6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Http2Session&lt;/code&gt; is connected to a &lt;code&gt;TLSSocket&lt;/code&gt;, the &lt;code&gt;originSet&lt;/code&gt; property will return an &lt;code&gt;Array&lt;/code&gt; of origins for which the &lt;code&gt;Http2Session&lt;/code&gt; may be considered authoritative.</source>
          <target state="translated">경우] &lt;code&gt;Http2Session&lt;/code&gt; 는 (A)에 접속된다 &lt;code&gt;TLSSocket&lt;/code&gt; 상기 &lt;code&gt;originSet&lt;/code&gt; 의 속성은 반환 &lt;code&gt;Array&lt;/code&gt; 하는 기원 &lt;code&gt;Http2Session&lt;/code&gt; 가 정식으로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c0455b2b9b3fae766e068922a9250208e4c2af45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NODE_PATH&lt;/code&gt; environment variable is set to a colon-delimited list of absolute paths, then Node.js will search those paths for modules if they are not found elsewhere.</source>
          <target state="translated">는 IF &lt;code&gt;NODE_PATH&lt;/code&gt; 의 환경 변수가 절대 경로의 콜론으로 구분 된 목록으로 설정되어 그들이 다른 곳에서 찾을 수없는 경우, 다음 Node.js를 모듈에 대한 그 경로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="7dc67d61ad9cef9eaca701d02f9bb2c663b10ff3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;QuicEndpoint&lt;/code&gt; has been destroyed, or is destroyed while the &lt;code&gt;Promise&lt;/code&gt; is pending, the &lt;code&gt;Promise&lt;/code&gt; will be rejected with an &lt;code&gt;ERR_INVALID_STATE&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e79ad3d0a8607f13e2c7d77cdcf20954aa878cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;QuicEndpoint&lt;/code&gt; is not bound, &lt;code&gt;quicendpoint.address&lt;/code&gt; is an empty object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="700474149520ec279c7f2339f334a3fbdcf3ac10" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer&lt;/code&gt; argument is provided, one final call to &lt;code&gt;stringDecoder.write()&lt;/code&gt; is performed before returning the remaining input.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 인수가 제공되고, 마지막으로 호출 &lt;code&gt;stringDecoder.write()&lt;/code&gt; 나머지 입력을 반환하기 전에 수행된다.</target>
        </trans-unit>
        <trans-unit id="39a149317204d260dcf57a300bd48c787fb097f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer&lt;/code&gt; argument is provided, one final call to &lt;code&gt;stringDecoder.write()&lt;/code&gt; is performed before returning the remaining input. After &lt;code&gt;end()&lt;/code&gt; is called, the &lt;code&gt;stringDecoder&lt;/code&gt; object can be reused for new input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b698c9ff7e5dfbf0331a5b293d26fbbc739efc5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ca&lt;/code&gt; option is not given, then Node.js will default to using &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt&quot;&gt;Mozilla's publicly trusted list of CAs&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;ca&lt;/code&gt; 옵션이 지정되어 있지 않은 경우, Node.js를 사용하여 기본값으로 사용됩니다 &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt&quot;&gt;수있는 CA의 모질라의 공개적으로 신뢰할 수있는 목록을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac092c034da270f1131edac11ccf7582acc156f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; function is not provided, an error will be thrown.</source>
          <target state="translated">경우] &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않는 오류가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="a9daebaf2c04786e5b28ab1e89a86e818076b4d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; function is not provided, the random bytes are generated synchronously and returned as a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;. An error will be thrown if there is a problem generating the bytes.</source>
          <target state="translated">경우] &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않고, 임의의 바이트 동기하여 생성되고 반환되는 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; . 바이트 생성에 문제가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a2b2aa24c9c15a7927b77b32a5cf5894f1a5ae6a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; function is not provided, the random integer is generated synchronously.</source>
          <target state="translated">경우] &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않고, 임의의 정수 기적으로 생성된다.</target>
        </trans-unit>
        <trans-unit id="fec34b8e1e977f8ce019a960434cc75d2f42505d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decodeStrings&lt;/code&gt; property is explicitly set to &lt;code&gt;false&lt;/code&gt; in the constructor options, then &lt;code&gt;chunk&lt;/code&gt; will remain the same object that is passed to &lt;code&gt;.write()&lt;/code&gt;, and may be a string rather than a &lt;code&gt;Buffer&lt;/code&gt;. This is to support implementations that have an optimized handling for certain string data encodings. In that case, the &lt;code&gt;encoding&lt;/code&gt; argument will indicate the character encoding of the string. Otherwise, the &lt;code&gt;encoding&lt;/code&gt; argument can be safely ignored.</source>
          <target state="translated">는 IF &lt;code&gt;decodeStrings&lt;/code&gt; 의 속성을 명시 적으로 설정되어 &lt;code&gt;false&lt;/code&gt; 생성자 옵션에서 다음 &lt;code&gt;chunk&lt;/code&gt; 에 전달되는 동일한 개체 유지됩니다 &lt;code&gt;.write()&lt;/code&gt; 하고, 오히려보다 문자열이 될 수 있습니다 &lt;code&gt;Buffer&lt;/code&gt; . 이는 특정 문자열 데이터 인코딩에 대해 최적화 된 처리 기능이있는 구현을 지원하기위한 것입니다. 이 경우 &lt;code&gt;encoding&lt;/code&gt; 인수는 문자열의 문자 인코딩을 나타냅니다. 그렇지 않으면 &lt;code&gt;encoding&lt;/code&gt; 인수를 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="1295a8b2430b9ea40a28497169df9f00a2e30e2f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;destination&lt;/code&gt; is not specified, then &lt;em&gt;all&lt;/em&gt; pipes are detached.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 지정되어 있지 않은 경우, &lt;em&gt;모든&lt;/em&gt; 파이프가 분리된다.</target>
        </trans-unit>
        <trans-unit id="f61354dd4c096ff86d2604bd1f201639b5280cce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;destination&lt;/code&gt; is specified, but no pipe is set up for it, then the method does nothing.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 지정되어 있지만 파이프가 그것을 위해 설정되어 있지 않은, 다음 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9993188edbda0e084b782c4aa4a76c9d01b6aa7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; option is specified then this function returns a string. Otherwise it returns a buffer.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 옵션이 지정되고이 함수는 문자열을 반환합니다. 그렇지 않으면 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff21d446a3ab3fe55f4acc6ff2c436094f676d4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is not a format string, the output string's formatting is no longer dependent on the type of the first argument. This change removes previously present quotes from strings that were being output when the first argument was not a string.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 인수가 형식 문자열이 아닌, 출력 문자열의 형식은 첫 번째 인수의 종류에 더 이상 의존하지 않습니다. 이 변경은 첫 번째 인수가 문자열이 아닐 때 출력되었던 문자열에서 이전에 존재하는 따옴표를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b9e1b37b11483fa26d2a4ffd951d8693136223e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fs.Stats&lt;/code&gt; object was obtained from &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt;&lt;code&gt;fs.lstat()&lt;/code&gt;&lt;/a&gt;, this method will always return &lt;code&gt;false&lt;/code&gt;. This is because &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt;&lt;code&gt;fs.lstat()&lt;/code&gt;&lt;/a&gt; returns information about a symbolic link itself and not the path it resolves to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d308fd83eda74dcf99237973ddacf4e7ec8a2f56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;input&lt;/code&gt; stream was paused &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;SIGTSTP&lt;/code&gt; request, this event will not be emitted.</source>
          <target state="translated">경우] &lt;code&gt;input&lt;/code&gt; 스트림을 일시 중지 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;SIGTSTP&lt;/code&gt; 의 요청이 이벤트가 방출되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="30f38c1cd9e3b259bd034f504426ea5d58e45d76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inputEncoding&lt;/code&gt; is not provided, &lt;code&gt;key&lt;/code&gt; is expected to be a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;inputEncoding&lt;/code&gt; 가 제공되지 않는, &lt;code&gt;key&lt;/code&gt; 것으로 예상된다 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;TypedArray&lt;/code&gt; , 또는 &lt;code&gt;DataView&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="9f18955efde58f4d26c872da376a7f9e3385d261" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; option is an array, individual entries do not need a &lt;code&gt;passphrase&lt;/code&gt; property anymore. &lt;code&gt;Array&lt;/code&gt; entries can also just be &lt;code&gt;string&lt;/code&gt;s or &lt;code&gt;Buffer&lt;/code&gt;s now.</source>
          <target state="translated">는 IF &lt;code&gt;key&lt;/code&gt; 옵션은 배열, 개별 항목은 필요하지 않습니다 &lt;code&gt;passphrase&lt;/code&gt; 더 이상 속성을. &lt;code&gt;Array&lt;/code&gt; 항목은 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;Buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d7c9ccb6d11a43cf334112f22066ada11047f33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;module.status&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt;, this property contains the exception thrown by the module during evaluation. If the status is anything else, accessing this property will result in a thrown exception.</source>
          <target state="translated">경우 &lt;code&gt;module.status&lt;/code&gt; 가 되어 &lt;code&gt;'errored'&lt;/code&gt; 이 속성은 평가시 모듈에 의해 던져진 예외를 포함합니다. 상태가 다른 경우이 속성에 액세스하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf37dd1b51403923bcd466d830080d91ad10e133" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;napi_status&lt;/code&gt; returned by a function is &lt;code&gt;napi_ok&lt;/code&gt; then no exception is pending and no additional action is required. If the &lt;code&gt;napi_status&lt;/code&gt; returned is anything other than &lt;code&gt;napi_ok&lt;/code&gt; or &lt;code&gt;napi_pending_exception&lt;/code&gt;, in order to try to recover and continue instead of simply returning immediately, &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt;&lt;code&gt;napi_is_exception_pending&lt;/code&gt;&lt;/a&gt; must be called in order to determine if an exception is pending or not.</source>
          <target state="translated">는 IF &lt;code&gt;napi_status&lt;/code&gt; 함수에 의해 반환이 &lt;code&gt;napi_ok&lt;/code&gt; 다음 예외 보류되지 않고 추가 조치가 필요하지 않습니다. 반환 된 &lt;code&gt;napi_status&lt;/code&gt; 가 &lt;code&gt;napi_ok&lt;/code&gt; 또는 &lt;code&gt;napi_pending_exception&lt;/code&gt; 이외의 값인 경우 , 단순히 즉시 반환하는 대신 복구하고 계속 진행 하려면 예외가 보류 중인지 여부를 판별하기 위해 &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt; &lt;code&gt;napi_is_exception_pending&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4e650377d72da10446c3017b0383db45d2e5bdb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;once&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;listener&lt;/code&gt; is removed after the next time a &lt;code&gt;type&lt;/code&gt; event is dispatched.</source>
          <target state="translated">경우 &lt;code&gt;once&lt;/code&gt; 옵션은 &lt;code&gt;true&lt;/code&gt; 의 &lt;code&gt;listener&lt;/code&gt; a를 다음 시간 이후에 제거 &lt;code&gt;type&lt;/code&gt; 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="edc8d76112ea7024d3371b71a0a23d16ae790953" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;package.json&lt;/code&gt;&lt;code&gt;&quot;type&quot;&lt;/code&gt; field is omitted, a &lt;code&gt;.js&lt;/code&gt; file in &lt;code&gt;&quot;main&quot;&lt;/code&gt; will be interpreted as CommonJS.</source>
          <target state="translated">는 IF &lt;code&gt;package.json&lt;/code&gt; &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드를 생략하는 &lt;code&gt;.js&lt;/code&gt; 에서 파일을 &lt;code&gt;&quot;main&quot;&lt;/code&gt; CommonJS로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="caa3feef5b60811f6f8ebc29d870eae549b34115" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;path&lt;/code&gt; is a zero-length string, &lt;code&gt;'.'&lt;/code&gt; is returned, representing the current working directory.</source>
          <target state="translated">는 IF &lt;code&gt;path&lt;/code&gt; 길이가 0 인 문자열이다 &lt;code&gt;'.'&lt;/code&gt; 현재 작업 디렉토리를 나타내는가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caefa5d65799f6063d04ea3b55a098cbb95b16f1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;payload&lt;/code&gt; argument is not specified, the default payload will be the 64-bit timestamp (little endian) marking the start of the &lt;code&gt;PING&lt;/code&gt; duration.</source>
          <target state="translated">경우 &lt;code&gt;payload&lt;/code&gt; 인수를 지정하지, 기본 페이로드의 시작 표시 64 비트 타임 스탬프 (리틀 엔디안)입니다 &lt;code&gt;PING&lt;/code&gt; 의 시간을.</target>
        </trans-unit>
        <trans-unit id="0a081c5a11aa40b34615e3cce298d430f402bf1f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readable.read()&lt;/code&gt; method returns a chunk of data, a &lt;code&gt;'data'&lt;/code&gt; event will also be emitted.</source>
          <target state="translated">경우] &lt;code&gt;readable.read()&lt;/code&gt; 메소드는 데이터 청크를 반환하는 &lt;code&gt;'data'&lt;/code&gt; 이벤트는 발광한다.</target>
        </trans-unit>
        <trans-unit id="91fa64dbbc3f8f47eda565fe9f322b381a972060" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; are not written.</source>
          <target state="translated">경우] &lt;code&gt;readline.Interface&lt;/code&gt; 를 사용하여 만든 &lt;code&gt;output&lt;/code&gt; 으로 설정된 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;key&lt;/code&gt; 기록되어있다.</target>
        </trans-unit>
        <trans-unit id="06f06f1032594fee7846b4022ca4197486666d19" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the &lt;code&gt;query&lt;/code&gt; is not written.</source>
          <target state="translated">는 IF &lt;code&gt;readline.Interface&lt;/code&gt; 을 사용하여 만든 &lt;code&gt;output&lt;/code&gt; 으로 설정 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fea07f7457e9a5cfe604444ae829144970387f4e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the prompt is not written.</source>
          <target state="translated">&lt;code&gt;readline.Interface&lt;/code&gt; 가 &lt;code&gt;output&lt;/code&gt; 을 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 로 설정하여 만든 경우 프롬프트가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca11505c60d44e44b2be746154c32a786c9f3107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serialization&lt;/code&gt; option was set to &lt;code&gt;'advanced'&lt;/code&gt; used when spawning the child process, the &lt;code&gt;message&lt;/code&gt; argument can contain data that JSON is not able to represent. See &lt;a href=&quot;#child_process_advanced_serialization&quot;&gt;Advanced serialization&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;code&gt;serialization&lt;/code&gt; 옵션이 설정되었습니다 &lt;code&gt;'advanced'&lt;/code&gt; 자식 프로세스를 생성 할 때 사용의 &lt;code&gt;message&lt;/code&gt; 인수는 JSON 대표 할 수 없다는 것을 데이터를 포함 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#child_process_advanced_serialization&quot;&gt;고급 직렬화&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="f56a2a2f4c0e53d8c45d58f22f36c484befea2a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;serialization&lt;/code&gt; option was set to &lt;code&gt;advanced&lt;/code&gt; used when spawning the process, the &lt;code&gt;message&lt;/code&gt; argument can contain data that JSON is not able to represent. See &lt;a href=&quot;child_process#child_process_advanced_serialization&quot;&gt;Advanced serialization for &lt;code&gt;child_process&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;code&gt;serialization&lt;/code&gt; 옵션으로 설정되어 &lt;code&gt;advanced&lt;/code&gt; 과정을 산란 할 때 사용의 &lt;code&gt;message&lt;/code&gt; 인수는 JSON 대표 할 수 없다는 것을 데이터를 포함 할 수 있습니다. 자세한 내용 &lt;a href=&quot;child_process#child_process_advanced_serialization&quot;&gt;은 &lt;code&gt;child_process&lt;/code&gt; 에&lt;/a&gt; 대한 고급 직렬화를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="34eeb81afad165bb1c78bab7242da5c92ced035c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;signal&lt;/code&gt; option is enabled, calling &lt;code&gt;.abort()&lt;/code&gt; on the corresponding &lt;code&gt;AbortController&lt;/code&gt; is similar to calling &lt;code&gt;.kill()&lt;/code&gt; on the child process except the error passed to the callback will be an &lt;code&gt;AbortError&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba79ac22562343c78ffca177acce56493df85de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; argument is not specified, all of the data contained in the internal buffer will be returned.</source>
          <target state="translated">상기 중간 &lt;code&gt;size&lt;/code&gt; 인수가 지정되지 않고 내부 버퍼에 포함 된 모든 데이터가 리턴 될 것이다.</target>
        </trans-unit>
        <trans-unit id="70594489f12159c87f362c4ae69f4758215eb7f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;small-icu&lt;/code&gt; option is used, one can still provide additional locale data at runtime so that the JS methods would work for all ICU locales. Assuming the data file is stored at &lt;code&gt;/some/directory&lt;/code&gt;, it can be made available to ICU through either:</source>
          <target state="translated">는 IF &lt;code&gt;small-icu&lt;/code&gt; 옵션이 사용되는 JS 방법은 모든 ICU 로케일에 대해 작동 할 수 있도록, 하나는 여전히 런타임에 추가 로케일 데이터를 제공 할 수 있습니다. 데이터 파일이 &lt;code&gt;/some/directory&lt;/code&gt; 에 저장되어 있다고 가정하면 다음 중 하나를 통해 ICU에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba838b5589301149a5649376c001bb8fe7dc3b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is a &lt;a href=&quot;tty&quot;&gt;TTY&lt;/a&gt;, then it must be in raw mode.</source>
          <target state="translated">는 IF &lt;code&gt;stream&lt;/code&gt; A는 &lt;a href=&quot;tty&quot;&gt;TTY는&lt;/a&gt; , 그것은 원시 모드에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1276a263a11dfdba0d780253f069d70f3b07760" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;type&lt;/code&gt; argument is left undefined, Node will autodetect &lt;code&gt;target&lt;/code&gt; type and automatically select &lt;code&gt;dir&lt;/code&gt; or &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;type&lt;/code&gt; 인수가 정의되지 않은 왼쪽되어, 노드는 자동으로 감지합니다 &lt;code&gt;target&lt;/code&gt; 유형 자동 선택 &lt;code&gt;dir&lt;/code&gt; 나 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a730bfb6fcf2424a685238cdef11143c9ba909b1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;type&lt;/code&gt; argument is left undefined, Node will autodetect &lt;code&gt;target&lt;/code&gt; type and automatically select &lt;code&gt;dir&lt;/code&gt; or &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;type&lt;/code&gt; 인수가 정의되지 않은 왼쪽되어, 노드는 자동으로 감지합니다 &lt;code&gt;target&lt;/code&gt; 유형 자동 선택 &lt;code&gt;dir&lt;/code&gt; 나 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="641da75986b0d3dd6bb805434236735b6993a166" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.hash&lt;/code&gt; property is a string:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.hash&lt;/code&gt; 속성은 문자열입니다 :</target>
        </trans-unit>
        <trans-unit id="dfb858e55085a16c94af20594b643c53b5b10f40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.host&lt;/code&gt; property is &lt;code&gt;undefined&lt;/code&gt; then:</source>
          <target state="translated">경우] &lt;code&gt;urlObject.host&lt;/code&gt; 의 속성이되어 &lt;code&gt;undefined&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="5b5dce93f29b648ece229c6c340c77b112847288" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.hostname&lt;/code&gt; is a string, it is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.hostname&lt;/code&gt; 는 문자열, 그것은 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6379b09c4b00ec95bd4b96e589e7705fbb8d936e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.pathname&lt;/code&gt; property is a string that is not an empty string:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.pathname&lt;/code&gt; 의 속성은 빈 문자열이 아닌 문자열입니다 :</target>
        </trans-unit>
        <trans-unit id="cca80e3e9a84bf98df702fab84776425b14d0b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.pathname&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with an ASCII forward slash (&lt;code&gt;/&lt;/code&gt;), then the literal string &lt;code&gt;'/'&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.pathname&lt;/code&gt; 이&lt;em&gt;시작되지 않습니다&lt;/em&gt; 아스키 슬래시 (과 &lt;code&gt;/&lt;/code&gt; ), 다음 리터럴 문자열 &lt;code&gt;'/'&lt;/code&gt; 에 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d3af2d3b60b1f8ba28c24cc690ad1da17edcb49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.port&lt;/code&gt; property value is truthy, and &lt;code&gt;urlObject.hostname&lt;/code&gt; is not &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.port&lt;/code&gt; 의 속성 값은 truthy이며, &lt;code&gt;urlObject.hostname&lt;/code&gt; 가 아닌 &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f7b1873a47a5cccbbcaf141e8099ba0a23f167af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.search&lt;/code&gt; property is &lt;code&gt;undefined&lt;/code&gt; and if the &lt;code&gt;urlObject.query&lt;/code&gt; property is an &lt;code&gt;Object&lt;/code&gt;, the literal string &lt;code&gt;?&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt; followed by the output of calling the &lt;a href=&quot;querystring&quot;&gt;&lt;code&gt;querystring&lt;/code&gt;&lt;/a&gt; module's &lt;code&gt;stringify()&lt;/code&gt; method passing the value of &lt;code&gt;urlObject.query&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.search&lt;/code&gt; 의 속성입니다 &lt;code&gt;undefined&lt;/code&gt; 및 경우 &lt;code&gt;urlObject.query&lt;/code&gt; 의 속성이있다 &lt;code&gt;Object&lt;/code&gt; , 리터럴 문자열 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;urlObject.query&lt;/code&gt; 의 값을 전달하는 &lt;a href=&quot;querystring&quot;&gt; &lt;code&gt;querystring&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;code&gt;stringify()&lt;/code&gt; 메소드를 호출 한 &lt;code&gt;result&lt;/code&gt; 가 결과에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6c7d9851a36c60f4fede5c50c0daefebfda6c63" translate="yes" xml:space="preserve">
          <source>If the Chrome browser is older than 66.0.3345.0, use &lt;code&gt;inspector.html&lt;/code&gt; instead of &lt;code&gt;js_app.html&lt;/code&gt; in the above URL.</source>
          <target state="translated">Chrome 브라우저가 66.0.3345.0보다 오래된 경우 위 URL에서 &lt;code&gt;js_app.html&lt;/code&gt; 대신 &lt;code&gt;inspector.html&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2ee6d4306a883909c0a1794605af868e4cc47a" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;'disconnect'&lt;/code&gt; event will be emitted when the IPC channel is closed.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성되면 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조) IPC 채널이 닫힐 때 &lt;code&gt;'disconnect'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac963e7d4525abb2736d0e62cf6c19d77ecc05c0" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;'message'&lt;/code&gt; event is emitted whenever a message sent by a parent process using &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt;&lt;code&gt;childprocess.send()&lt;/code&gt;&lt;/a&gt; is received by the child process.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성되면 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조), 자식 프로세스 가 &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt; &lt;code&gt;childprocess.send()&lt;/code&gt; &lt;/a&gt; 사용하여 부모 프로세스가 보낸 메시지를받을 때마다 &lt;code&gt;'message'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0f656d281b0270653c917de8907695d4af188c" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;process.connected&lt;/code&gt; property will return &lt;code&gt;true&lt;/code&gt; so long as the IPC channel is connected and will return &lt;code&gt;false&lt;/code&gt; after &lt;code&gt;process.disconnect()&lt;/code&gt; is called.</source>
          <target state="translated">Node.js를 프로세스가 IPC 채널과 양산되면합니다 (참조 &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 와 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; , 문서)를 &lt;code&gt;process.connected&lt;/code&gt; 속성이 반환됩니다 &lt;code&gt;true&lt;/code&gt; IPC의 채널이 연결되어 너무 오래 및 반환 &lt;code&gt;false&lt;/code&gt; 후 &lt;code&gt;process.disconnect()&lt;/code&gt; 라고 .</target>
        </trans-unit>
        <trans-unit id="cde62fe89a34a0451adb24c7df715d4ac04255b2" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;process.disconnect()&lt;/code&gt; method will close the IPC channel to the parent process, allowing the child process to exit gracefully once there are no other connections keeping it alive.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성 된 경우 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조) &lt;code&gt;process.disconnect()&lt;/code&gt; 메소드는 IPC 채널을 상위 프로세스로 닫아서 하위 프로세스가 없으면 정상적으로 종료되도록합니다. 다른 연결을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f1535633e9356c88e44a5953c4a93db18cf738ad" translate="yes" xml:space="preserve">
          <source>If the Node.js process was not spawned with an IPC channel, &lt;code&gt;process.disconnect()&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널로 생성 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;process.disconnect()&lt;/code&gt; 는 undefined 입니다.</target>
        </trans-unit>
        <trans-unit id="fc3cb24c470cc8f1c846968b69afb26cb137c284" translate="yes" xml:space="preserve">
          <source>If the Node.js process was spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; documentation), the &lt;code&gt;process.channel&lt;/code&gt; property is a reference to the IPC channel. If no IPC channel exists, this property is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성 된 경우 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 문서 참조 ) &lt;code&gt;process.channel&lt;/code&gt; 속성은 IPC 채널에 대한 참조입니다. IPC 채널이 없으면이 속성은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43857629c05db580aaa4aaa5f6033f044e6c6ced" translate="yes" xml:space="preserve">
          <source>If the REPL is run as standalone program, it is also possible to change the REPL's &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;inspection defaults&lt;/a&gt; from inside the REPL by using the &lt;code&gt;inspect.replDefaults&lt;/code&gt; property which mirrors the &lt;code&gt;defaultOptions&lt;/code&gt; from &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;&lt;code&gt;util.inspect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">REPL이 독립형 프로그램으로 실행 되는 경우 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt; &lt;code&gt;util.inspect()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;defaultOptions&lt;/code&gt; 를 미러링하는 &lt;code&gt;inspect.replDefaults&lt;/code&gt; 속성을 사용하여 REPL 내부에서 REPL의 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;검사 기본값&lt;/a&gt; 을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23a67121ef3a61432b20d90cd8e0ab29a6212306" translate="yes" xml:space="preserve">
          <source>If the Timer or &lt;code&gt;EventEmitter&lt;/code&gt; was already bound to a domain, it is removed from that one, and bound to this one instead.</source>
          <target state="translated">Timer 또는 &lt;code&gt;EventEmitter&lt;/code&gt; 가 이미 도메인에 바인딩 된 경우 해당 도메인에서 제거되고 대신이 도메인에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="64dddc2f822a88286ad4464a37619dd0ebb42999" translate="yes" xml:space="preserve">
          <source>If the Worker thread is no longer running, which may occur before the &lt;a href=&quot;#worker_threads_event_exit&quot;&gt;&lt;code&gt;'exit'&lt;/code&gt; event&lt;/a&gt; is emitted, the returned &lt;code&gt;Promise&lt;/code&gt; is rejected immediately with an &lt;a href=&quot;errors#ERR_WORKER_NOT_RUNNING&quot;&gt;&lt;code&gt;ERR_WORKER_NOT_RUNNING&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0a4b093f139ed3f4d2f9097604b6126d70f4ae" translate="yes" xml:space="preserve">
          <source>If the Worker thread is no longer running, which may occur before the &lt;a href=&quot;#worker_threads_event_exit&quot;&gt;&lt;code&gt;'exit'&lt;/code&gt; event&lt;/a&gt; is emitted, the returned &lt;code&gt;Promise&lt;/code&gt; will be rejected immediately with an &lt;a href=&quot;errors#ERR_WORKER_NOT_RUNNING&quot;&gt;&lt;code&gt;ERR_WORKER_NOT_RUNNING&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">작업자 스레드가 더 이상 실행되지 않는 경우 ( &lt;a href=&quot;#worker_threads_event_exit&quot;&gt; &lt;code&gt;'exit'&lt;/code&gt; 이벤트&lt;/a&gt; 가 발생하기 전에 발생할 수 있음) 반환 된 &lt;code&gt;Promise&lt;/code&gt; 는 &lt;a href=&quot;errors#ERR_WORKER_NOT_RUNNING&quot;&gt; &lt;code&gt;ERR_WORKER_NOT_RUNNING&lt;/code&gt; &lt;/a&gt; 오류 와 함께 즉시 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c562e1358dbc4b2fc2fd9fd83e9076c18598405" translate="yes" xml:space="preserve">
          <source>If the accessibility check is successful, the &lt;code&gt;Promise&lt;/code&gt; is resolved with no value. If any of the accessibility checks fail, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;code&gt;Error&lt;/code&gt; object. The following example checks if the file &lt;code&gt;/etc/passwd&lt;/code&gt; can be read and written by the current process.</source>
          <target state="translated">접근성 검사에 성공하면 &lt;code&gt;Promise&lt;/code&gt; 이 값없이 해결됩니다. 접근성 검사 중 하나라도 실패 하면 &lt;code&gt;Error&lt;/code&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다 . 다음 예제는 현재 프로세스에서 &lt;code&gt;/etc/passwd&lt;/code&gt; 파일을 읽고 쓸 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3799c67bbd23d79044be232fe53a7cba31d56f55" translate="yes" xml:space="preserve">
          <source>If the callback function throws an error, it will be thrown by &lt;code&gt;exit&lt;/code&gt; too. The stacktrace will not be impacted by this call and the context will be re-entered.</source>
          <target state="translated">콜백 함수에서 오류가 발생하면, 그것은에 의해 발생합니다 &lt;code&gt;exit&lt;/code&gt; 너무. 스택 추적은이 호출의 영향을받지 않으며 컨텍스트가 다시 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="780b3ea859c2257014a14dd59e9b7b22d4dffa2c" translate="yes" xml:space="preserve">
          <source>If the callback function throws an error, it will be thrown by &lt;code&gt;run&lt;/code&gt; too. The stacktrace will not be impacted by this call and the context will be exited.</source>
          <target state="translated">콜백 함수에서 오류가 발생하면 &lt;code&gt;run&lt;/code&gt; 에도 발생합니다 . 스택 트레이스는이 호출의 영향을받지 않으며 컨텍스트가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b610dfa520e94a9fdf2b30dda8919b3eebe300" translate="yes" xml:space="preserve">
          <source>If the child process intercepts and handles the &lt;code&gt;SIGTERM&lt;/code&gt; signal and does not exit, the parent process will still wait until the child process has exited.</source>
          <target state="translated">하위 프로세스가 &lt;code&gt;SIGTERM&lt;/code&gt; 신호를 가로 채서 처리하고 종료하지 않으면 상위 프로세스는 하위 프로세스가 종료 될 때까지 계속 대기합니다.</target>
        </trans-unit>
        <trans-unit id="13b740fc3fb496e053111a8c519d9ac732b0ce92" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[0]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[0]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b39b748847e4c67b790f33ece88c22fff5bd35" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[1]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[1]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29ee59da22385decb4ae9026bc663f921fbe54b3" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[2]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[2]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07c35b549870c6ce2889f6cf4da37865237a1b7f" translate="yes" xml:space="preserve">
          <source>If the code needs more advanced &lt;code&gt;require&lt;/code&gt; features, it has to construct its own &lt;code&gt;require&lt;/code&gt; using &lt;code&gt;module.createRequire()&lt;/code&gt;.</source>
          <target state="translated">코드에 고급 &lt;code&gt;require&lt;/code&gt; 기능이 &lt;code&gt;require&lt;/code&gt; &lt;code&gt;module.createRequire()&lt;/code&gt; 사용하여 자체 요구 사항 을 구성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="da188d4f2c13854a7aa73240ff25eb0ff7f7df83" translate="yes" xml:space="preserve">
          <source>If the data to be written can be generated or fetched on demand, it is recommended to encapsulate the logic into a &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#stream_readable_pipe_destination_options&quot;&gt;&lt;code&gt;stream.pipe()&lt;/code&gt;&lt;/a&gt;. However, if calling &lt;code&gt;write()&lt;/code&gt; is preferred, it is possible to respect backpressure and avoid memory issues using the &lt;a href=&quot;#stream_event_drain&quot;&gt;&lt;code&gt;'drain'&lt;/code&gt;&lt;/a&gt; event:</source>
          <target state="translated">작성 될 데이터가 요청시 생성되거나 페치 될 수있는 경우 로직을 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 으로 캡슐화하고 &lt;a href=&quot;#stream_readable_pipe_destination_options&quot;&gt; &lt;code&gt;stream.pipe()&lt;/code&gt; &lt;/a&gt; 사용 하는 것이 좋습니다 . 그러나 &lt;code&gt;write()&lt;/code&gt; 호출 이 선호되는 경우 배압을 존중하고 &lt;a href=&quot;#stream_event_drain&quot;&gt; &lt;code&gt;'drain'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용하여 메모리 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61145810afb5945c541a709b46cbd9081fc8c5a0" translate="yes" xml:space="preserve">
          <source>If the exact filename is not found, then Node.js will attempt to load the required filename with the added extensions: &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.json&lt;/code&gt;, and finally &lt;code&gt;.node&lt;/code&gt;.</source>
          <target state="translated">정확한 파일 이름을 찾을 수 없으면 Node.js는 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.json&lt;/code&gt; 및 마지막으로 &lt;code&gt;.node&lt;/code&gt; 확장자가 추가 된 필수 파일 이름을로드하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2258fb88100a5f7eff8cc7faff56de080446a859" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;packageURL&lt;/em&gt; does not parse as valid JSON, then</source>
          <target state="translated">&lt;em&gt;packageURL&lt;/em&gt; 의 파일이 유효한 JSON으로 구문 분석되지 않으면</target>
        </trans-unit>
        <trans-unit id="bdeb3f1ca2d8b92cbd0a1be61e5a215e42cd48a6" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;pjsonURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;pjsonURL에&lt;/em&gt; 파일 이 존재하지 않으면</target>
        </trans-unit>
        <trans-unit id="aecb5a1502adf792d817b06219b4ea3a85f521fc" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolved&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;해결&lt;/em&gt; 된 파일 이 존재하지 않으면</target>
        </trans-unit>
        <trans-unit id="b04ae966e4e6108c91fe53b75de378ab723d38f2" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolved&lt;/em&gt; is a directory, then</source>
          <target state="translated">&lt;em&gt;해결&lt;/em&gt; 된 파일 이 디렉토리이면</target>
        </trans-unit>
        <trans-unit id="5da2c4a4757077189503883db4e6e527ad0ac53c" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolvedMain&lt;/em&gt; exists, then</source>
          <target state="translated">&lt;em&gt;resolvedMain에&lt;/em&gt; 파일 이 존재하면</target>
        </trans-unit>
        <trans-unit id="515992658a030cb2361fa29326a06b3cc8b741f2" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolvedURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;resolvedURL에&lt;/em&gt; 파일 이 존재하지 않으면</target>
        </trans-unit>
        <trans-unit id="aa9ce6de4cab577476c2c552264e45a090b35d7b" translate="yes" xml:space="preserve">
          <source>If the file is not modified concurrently, the end-of-file is reached when the number of bytes read is zero.</source>
          <target state="translated">파일이 동시에 수정되지 않으면 읽은 바이트 수가 0 일 때 파일 끝에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="9cd28ea88a40c2bd663df8d30e3acd434308cc86" translate="yes" xml:space="preserve">
          <source>If the file previously was shorter than &lt;code&gt;len&lt;/code&gt; bytes, it is extended, and the extended part is filled with null bytes (&lt;code&gt;'\0'&lt;/code&gt;):</source>
          <target state="translated">파일이 이전에 &lt;code&gt;len&lt;/code&gt; 바이트 보다 짧은 경우 확장되고 확장 된 부분은 널 바이트 ( &lt;code&gt;'\0'&lt;/code&gt; )로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="f95ff524435a90bae8bf6af198f46ee202155faf" translate="yes" xml:space="preserve">
          <source>If the file referred to by the file descriptor was larger than &lt;code&gt;len&lt;/code&gt; bytes, only the first &lt;code&gt;len&lt;/code&gt; bytes will be retained in the file.</source>
          <target state="translated">파일 디스크립터가 참조한 파일이 &lt;code&gt;len&lt;/code&gt; 바이트 보다 크면 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 만 파일에 보유됩니다.</target>
        </trans-unit>
        <trans-unit id="4496f3dce2ffd4403c03b2fc30701caf9fb83647" translate="yes" xml:space="preserve">
          <source>If the file was larger than &lt;code&gt;len&lt;/code&gt; bytes, only the first &lt;code&gt;len&lt;/code&gt; bytes will be retained in the file.</source>
          <target state="translated">파일이 &lt;code&gt;len&lt;/code&gt; 바이트 보다 크면 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 만 파일에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a9e0f0d83d0baa5625a952fe8bc081211ede0c9c" translate="yes" xml:space="preserve">
          <source>If the final write of a &lt;code&gt;fill()&lt;/code&gt; operation falls on a multi-byte character, then only the bytes of that character that fit into &lt;code&gt;buf&lt;/code&gt; are written:</source>
          <target state="translated">&lt;code&gt;fill()&lt;/code&gt; 연산 의 최종 쓰기가 멀티 바이트 문자에 해당되면 &lt;code&gt;buf&lt;/code&gt; 에 맞는 해당 문자의 바이트 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="43bfae18f785239e10de241385230fcb58569d05" translate="yes" xml:space="preserve">
          <source>If the first argument does not contain a valid format specifier, &lt;code&gt;util.format()&lt;/code&gt; returns a string that is the concatenation of all arguments separated by spaces:</source>
          <target state="translated">첫 번째 인수에 유효한 형식 지정 &lt;code&gt;util.format()&lt;/code&gt; 은 공백으로 구분 된 모든 인수가 연결된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="757a2bf0797ec25c73b79618040a87cf69150154" translate="yes" xml:space="preserve">
          <source>If the folder at &lt;em&gt;packageURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;packageURL에&lt;/em&gt; 폴더 가 없으면</target>
        </trans-unit>
        <trans-unit id="818763c6083260346cbce59d04afb4c3653559bd" translate="yes" xml:space="preserve">
          <source>If the format is &lt;code&gt;'pem'&lt;/code&gt;, the &lt;code&gt;'key'&lt;/code&gt; may also be an X.509 certificate.</source>
          <target state="translated">형식이 &lt;code&gt;'pem'&lt;/code&gt; 이면 &lt;code&gt;'key'&lt;/code&gt; 는 X.509 인증서 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc26a1cbd3fee89ad0dc952d290b03d615d0af8" translate="yes" xml:space="preserve">
          <source>If the full certificate chain was requested (&lt;code&gt;details&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;), each certificate will include an &lt;code&gt;issuerCertificate&lt;/code&gt; property containing an object representing the issuer's certificate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146a422b15c52df2fe42a2ad9ffc62b28c5857bf" translate="yes" xml:space="preserve">
          <source>If the full certificate chain was requested, each certificate will include an &lt;code&gt;issuerCertificate&lt;/code&gt; property containing an object representing its issuer's certificate.</source>
          <target state="translated">전체 인증서 체인이 요청 된 경우 각 인증서에는 발급자의 인증서를 나타내는 개체 가 포함 된 &lt;code&gt;issuerCertificate&lt;/code&gt; 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a0387fb588dc77347f4082fa56c7b681a051b0ff" translate="yes" xml:space="preserve">
          <source>If the function is not available, provide an alternate implementation that does not use the function.</source>
          <target state="translated">기능을 사용할 수없는 경우 기능을 사용하지 않는 대체 구현을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d53cf262095ac45fa556dab4e32bb6ff3d6e6375" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;path&lt;/code&gt; is a zero-length string, &lt;code&gt;false&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 가 길이가 0 인 문자열이면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e3d776630cc8905c1ff9df803e1e77bcd6232c" translate="yes" xml:space="preserve">
          <source>If the given path does not exist, &lt;code&gt;require()&lt;/code&gt; will throw an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; with its &lt;code&gt;code&lt;/code&gt; property set to &lt;code&gt;'MODULE_NOT_FOUND'&lt;/code&gt;.</source>
          <target state="translated">주어진 경로가 존재하지 않으면 &lt;code&gt;require()&lt;/code&gt; 는 &lt;code&gt;code&lt;/code&gt; 속성이 &lt;code&gt;'MODULE_NOT_FOUND'&lt;/code&gt; 로 설정된 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7ea6180b6690cd9c141dea7ea55172dbbbd3d0da" translate="yes" xml:space="preserve">
          <source>If the internal read buffer is below the &lt;code&gt;highWaterMark&lt;/code&gt;, and the stream is not currently reading, then calling &lt;code&gt;stream.read(0)&lt;/code&gt; will trigger a low-level &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt;&lt;code&gt;stream._read()&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">내부 읽기 버퍼가 &lt;code&gt;highWaterMark&lt;/code&gt; 아래에 있고 스트림이 현재 읽지 않는 경우 &lt;code&gt;stream.read(0)&lt;/code&gt; 을 호출 하면 하위 수준의 &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt; &lt;code&gt;stream._read()&lt;/code&gt; &lt;/a&gt; 호출 이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="94623dec42ca41e55b62b9990af5e5333283824a" translate="yes" xml:space="preserve">
          <source>If the length of &lt;em&gt;packageSpecifier&lt;/em&gt; is greater than the length of &lt;em&gt;packageName&lt;/em&gt;, then</source>
          <target state="translated">의 길이 경우 &lt;em&gt;packageSpecifier는&lt;/em&gt; 의 길이보다 큰 &lt;em&gt;packageName 여기서&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="17178a0e608fa47d68854e07ee706e59b8601df4" translate="yes" xml:space="preserve">
          <source>If the list has no items, or if the &lt;code&gt;totalLength&lt;/code&gt; is 0, then a new zero-length &lt;code&gt;Buffer&lt;/code&gt; is returned.</source>
          <target state="translated">목록에 항목이 없거나 &lt;code&gt;totalLength&lt;/code&gt; 가 0이면 새로운 길이 가 0 인 &lt;code&gt;Buffer&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="69a7cfdcf2ecac620e067b3903c7f336b3b1a1ef" translate="yes" xml:space="preserve">
          <source>If the loop is terminated with &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;return&lt;/code&gt;, &lt;a href=&quot;#readline_rl_close&quot;&gt;&lt;code&gt;rl.close()&lt;/code&gt;&lt;/a&gt; will be called. In other words, iterating over a &lt;code&gt;readline.Interface&lt;/code&gt; will always consume the input stream fully.</source>
          <target state="translated">루프가 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; 으로 종료 되면 &lt;a href=&quot;#readline_rl_close&quot;&gt; &lt;code&gt;rl.close()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 즉, &lt;code&gt;readline.Interface&lt;/code&gt; 를 반복 하면 항상 입력 스트림이 완전히 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="12d2b5b93dc5b3368355319b6a41e0a1b7e89c51" translate="yes" xml:space="preserve">
          <source>If the loop terminates with a &lt;code&gt;break&lt;/code&gt; or a &lt;code&gt;throw&lt;/code&gt;, the stream will be destroyed. In other terms, iterating over a stream will consume the stream fully. The stream will be read in chunks of size equal to the &lt;code&gt;highWaterMark&lt;/code&gt; option. In the code example above, data will be in a single chunk if the file has less then 64KB of data because no &lt;code&gt;highWaterMark&lt;/code&gt; option is provided to &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt;&lt;code&gt;fs.createReadStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루프가 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 로 종료 되면 스트림이 파괴됩니다. 즉, 스트림을 반복하면 스트림이 완전히 소비됩니다. 스트림은 &lt;code&gt;highWaterMark&lt;/code&gt; 옵션 과 동일한 크기의 청크로 읽 힙니다 . 위의 코드 예제 에서 &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt; &lt;code&gt;fs.createReadStream()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;highWaterMark&lt;/code&gt; 옵션이 제공 되지 않았기 때문에 파일의 데이터가 64KB 미만인 경우 데이터는 단일 청크에 있습니다.</target>
        </trans-unit>
        <trans-unit id="bceba7bdffad615ad25d0a02fc1ae50546e463d9" translate="yes" xml:space="preserve">
          <source>If the loop terminates with a &lt;code&gt;break&lt;/code&gt; or a &lt;code&gt;throw&lt;/code&gt;, the stream will be destroyed. In other terms, iterating over a stream will consume the stream fully. The stream will be read in chunks of size equal to the &lt;code&gt;highWaterMark&lt;/code&gt; option. In the code example above, data will be in a single chunk if the file has less then 64kb of data because no &lt;code&gt;highWaterMark&lt;/code&gt; option is provided to &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt;&lt;code&gt;fs.createReadStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루프가 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 로 종료 되면 스트림이 삭제됩니다. 즉, 스트림을 반복하면 스트림이 완전히 소비됩니다. 스트림은 &lt;code&gt;highWaterMark&lt;/code&gt; 옵션 과 동일한 크기의 청크로 읽 힙니다 . 위의 코드 예제 에서 &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt; &lt;code&gt;fs.createReadStream()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;highWaterMark&lt;/code&gt; 옵션이 제공 되지 않아 파일에 64kb 미만의 데이터가 있으면 데이터가 단일 청크에있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="60414babd277d857761204aae2ce5c56f1d8a898" translate="yes" xml:space="preserve">
          <source>If the module can not be found, a &lt;code&gt;MODULE_NOT_FOUND&lt;/code&gt; error is thrown.</source>
          <target state="translated">모듈을 찾을 수없는 경우 &lt;code&gt;MODULE_NOT_FOUND&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b818f0c6afbca493ff9a19fa9609c515ca828403" translate="yes" xml:space="preserve">
          <source>If the module identifier passed to &lt;code&gt;require()&lt;/code&gt; is not a &lt;a href=&quot;#modules_core_modules&quot;&gt;core&lt;/a&gt; module, and does not begin with &lt;code&gt;'/'&lt;/code&gt;, &lt;code&gt;'../'&lt;/code&gt;, or &lt;code&gt;'./'&lt;/code&gt;, then Node.js starts at the parent directory of the current module, and adds &lt;code&gt;/node_modules&lt;/code&gt;, and attempts to load the module from that location. Node.js will not append &lt;code&gt;node_modules&lt;/code&gt; to a path already ending in &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 전달 된 모듈 식별자 가 &lt;a href=&quot;#modules_core_modules&quot;&gt;핵심&lt;/a&gt; 모듈이 아니며 &lt;code&gt;'/'&lt;/code&gt; , &lt;code&gt;'../'&lt;/code&gt; 또는 &lt;code&gt;'./'&lt;/code&gt; 로 시작하지 않으면 Node.js가 현재 모듈의 상위 디렉토리에서 시작됩니다. &lt;code&gt;/node_modules&lt;/code&gt; 를 추가 하고 해당 위치에서 모듈을로드하려고 시도합니다. Node.js를가 추가되지 않습니다 &lt;code&gt;node_modules&lt;/code&gt; 을 경로가 이미 종료에 &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="379eefaaf07f8660cfce2f127e33572a7b16f44a" translate="yes" xml:space="preserve">
          <source>If the module is not simply a list of named exports, but rather contains a unique function or object export like &lt;code&gt;module.exports = function () { ... }&lt;/code&gt;, or if support in the wrapper for the &lt;code&gt;import pkg from 'pkg'&lt;/code&gt; pattern is desired, then the wrapper would instead be written to export the default optionally along with any named exports as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5890e21cec685ed58fcf1519311a188e9030c9ce" translate="yes" xml:space="preserve">
          <source>If the module will be loaded multiple times during the lifetime of the Node.js process, use the &lt;code&gt;NAPI_MODULE_INIT&lt;/code&gt; macro to initialize the module:</source>
          <target state="translated">Node.js 프로세스의 수명 동안 모듈이 여러 번로드되면 &lt;code&gt;NAPI_MODULE_INIT&lt;/code&gt; 매크로를 사용 하여 모듈을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5564d329338abc7579a9543732ac9bf046e01b3" translate="yes" xml:space="preserve">
          <source>If the nearest parent &lt;code&gt;package.json&lt;/code&gt; lacks a &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or contains &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt;, &lt;code&gt;.js&lt;/code&gt; files are treated as &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt;. If the volume root is reached and no &lt;code&gt;package.json&lt;/code&gt; is found, &lt;code&gt;.js&lt;/code&gt; files are treated as &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0add70a68c352ca1f1ff5b2c44879360ea5a65e7" translate="yes" xml:space="preserve">
          <source>If the nearest parent &lt;code&gt;package.json&lt;/code&gt; lacks a &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or contains &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt;, extensionless and &lt;code&gt;.js&lt;/code&gt; files are treated as CommonJS. If the volume root is reached and no &lt;code&gt;package.json&lt;/code&gt; is found, Node.js defers to the default, a &lt;code&gt;package.json&lt;/code&gt; with no &lt;code&gt;&quot;type&quot;&lt;/code&gt; field.</source>
          <target state="translated">가장 가까운 상위 &lt;code&gt;package.json&lt;/code&gt; 에 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드가 없거나 &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt; 경우 확장명 및 &lt;code&gt;.js&lt;/code&gt; 파일은 CommonJS로 처리됩니다. 볼륨 루트에 도달하고 &lt;code&gt;package.json&lt;/code&gt; 을 찾을 수 없으면 Node.js는 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드 가없는 &lt;code&gt;package.json&lt;/code&gt; 을 기본값으로 연기 합니다.</target>
        </trans-unit>
        <trans-unit id="23f21def50c65eb59310ea59a81bc8fd8fcc061e" translate="yes" xml:space="preserve">
          <source>If the number exceeds the range of the 32 bit integer, then the result is truncated to the equivalent of the bottom 32 bits. This can result in a large positive number becoming a negative number if the value is &amp;gt; 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="translated">숫자가 32 비트 정수 범위를 초과하는 경우 결과는 하위 32 비트에 해당하는 값으로 잘립니다. 이로 인해 값이&amp;gt; 2 &lt;sup&gt;31-1&lt;/sup&gt; 인 경우 큰 양수가 음수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a879f054c5d68d376a9ec6f0087a480eedd3cce6" translate="yes" xml:space="preserve">
          <source>If the number exceeds the range of the 32 bit integer, then the result is truncated to the equivalent of the bottom 32 bits. This can result in a large positive number becoming a negative number if the value is &amp;gt; 2^31 -1.</source>
          <target state="translated">숫자가 32 비트 정수 범위를 초과하면 결과는 맨 아래 32 비트와 동일하게 잘립니다. 값이 2 ^ 31 -1이면 큰 양수가 음수가됩니다.</target>
        </trans-unit>
        <trans-unit id="5c43b23c7b44006babf5eb04fd420a50be7a5bad" translate="yes" xml:space="preserve">
          <source>If the object already has an associated type tag, this API will return &lt;code&gt;napi_invalid_arg&lt;/code&gt;.</source>
          <target state="translated">객체에 이미 연결된 유형 태그가있는 경우이 API는 &lt;code&gt;napi_invalid_arg&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e897c2b05d260b0b8e93ea4b285545b463fa7585" translate="yes" xml:space="preserve">
          <source>If the object cannot be serialized, an exception should be thrown.</source>
          <target state="translated">객체를 직렬화 할 수 없으면 예외가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c1bbfd2c1a6332de40c11ef9f3e9fb9d7bc7ed9" translate="yes" xml:space="preserve">
          <source>If the package main export is a constructor, an &lt;code&gt;instanceof&lt;/code&gt; comparison of instances created by the two versions returns &lt;code&gt;false&lt;/code&gt;, and if the export is an object, properties added to one (like &lt;code&gt;pkgInstance.foo = 3&lt;/code&gt;) are not present on the other. This differs from how &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements work in all-CommonJS or all-ES module environments, respectively, and therefore is surprising to users. It also differs from the behavior users are familiar with when using transpilation via tools like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; or &lt;a href=&quot;https://github.com/standard-things/esm#readme&quot;&gt;&lt;code&gt;esm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6442a98f87242a39ce04a31ab601184ec0f676c" translate="yes" xml:space="preserve">
          <source>If the private key is encrypted, a &lt;code&gt;passphrase&lt;/code&gt; must be specified. The length of the passphrase is limited to 1024 bytes.</source>
          <target state="translated">개인 키가 암호화 된 경우 &lt;code&gt;passphrase&lt;/code&gt; 를 지정해야합니다. 암호의 길이는 1024 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae9b624e6a4cc8658387bd2cdd003cae8d4f7da" translate="yes" xml:space="preserve">
          <source>If the process times out or has a non-zero exit code, this method will throw an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; that will include the full result of the underlying &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스가 시간 초과되거나 종료 코드가 0이 아닌 경우이 메소드는 기본 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; 의 전체 결과를 포함 하는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="98fbfb27e02d409cf17783265e877eb2aec63754" translate="yes" xml:space="preserve">
          <source>If the process times out or has a non-zero exit code, this method will throw. The &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object will contain the entire result from &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스 시간이 초과되거나 종료 코드가 0이 아닌 경우이 메소드가 발생합니다. &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체의 전체 결과 포함 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ac036a75e1c80eaeb6589cc2f6c7d6f88f1b96" translate="yes" xml:space="preserve">
          <source>If the returned &lt;code&gt;Module&lt;/code&gt;'s &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'unlinked'&lt;/code&gt;, this method will be recursively called on the returned &lt;code&gt;Module&lt;/code&gt; with the same provided &lt;code&gt;linker&lt;/code&gt; function.</source>
          <target state="translated">리턴 된 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;linkingStatus&lt;/code&gt; 가 &lt;code&gt;'unlinked'&lt;/code&gt; unlinked '인 경우 ,이 메소드는 제공된 동일한 &lt;code&gt;linker&lt;/code&gt; 사용하여 리턴 된 &lt;code&gt;Module&lt;/code&gt; 에서 재귀 적으로 호출됩니다. 함수 .</target>
        </trans-unit>
        <trans-unit id="f47fa4a693379619e2862831ffe0e33bc5857271" translate="yes" xml:space="preserve">
          <source>If the returned &lt;code&gt;Module&lt;/code&gt;'s &lt;code&gt;status&lt;/code&gt; is &lt;code&gt;'unlinked'&lt;/code&gt;, this method will be recursively called on the returned &lt;code&gt;Module&lt;/code&gt; with the same provided &lt;code&gt;linker&lt;/code&gt; function.</source>
          <target state="translated">반환 된 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;status&lt;/code&gt; 가 &lt;code&gt;'unlinked'&lt;/code&gt; 이면이 메서드는 제공된 동일한 &lt;code&gt;linker&lt;/code&gt; 함수 를 사용하여 반환 된 &lt;code&gt;Module&lt;/code&gt; 에서 재귀 적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a9c8f5a9405be2773921d9bcb73c378bf6e3921" translate="yes" xml:space="preserve">
          <source>If the same optional &lt;code&gt;code&lt;/code&gt; is supplied in multiple calls to &lt;code&gt;util.deprecate()&lt;/code&gt;, the warning will be emitted only once for that &lt;code&gt;code&lt;/code&gt;.</source>
          <target state="translated">동일한 선택적 &lt;code&gt;code&lt;/code&gt; 가 &lt;code&gt;util.deprecate()&lt;/code&gt; 에 대한 여러 호출에서 제공 되면 해당 &lt;code&gt;code&lt;/code&gt; 대해 경고가 한 번만 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="77507334a12fcf0ff10a4c927bc16b8473d0704a" translate="yes" xml:space="preserve">
          <source>If the selected QUIC application protocol does not support push streams, an error will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053de0467bbed8ee60b4eeda37751c45ad19520c" translate="yes" xml:space="preserve">
          <source>If the selected QUIC application protocol supports push streams, then the &lt;code&gt;pushStream()&lt;/code&gt; method will initiate a new push promise and create a new unidirectional &lt;code&gt;QuicStream&lt;/code&gt; object used to fulfill that push.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d45b9459a85646bf2862e34f3076974fe78efd" translate="yes" xml:space="preserve">
          <source>If the socket has not been previously bound with a call to &lt;code&gt;bind&lt;/code&gt;, the socket is assigned a random port number and is bound to the &quot;all interfaces&quot; address (&lt;code&gt;'0.0.0.0'&lt;/code&gt; for &lt;code&gt;udp4&lt;/code&gt; sockets, &lt;code&gt;'::0'&lt;/code&gt; for &lt;code&gt;udp6&lt;/code&gt; sockets.)</source>
          <target state="translated">소켓이 이전의 호출에 연결되지 않은 경우 &lt;code&gt;bind&lt;/code&gt; , 소켓은 임의의 포트 번호를 할당하고 &quot;모든 인터페이스&quot;주소 (바인딩되는 &lt;code&gt;'0.0.0.0'&lt;/code&gt; 에 대한 &lt;code&gt;udp4&lt;/code&gt; 의 소켓, &lt;code&gt;'::0'&lt;/code&gt; 에 대한 &lt;code&gt;udp6&lt;/code&gt; 소켓 .)</target>
        </trans-unit>
        <trans-unit id="100b945d9d84485689651adf59b8ec4b61995064" translate="yes" xml:space="preserve">
          <source>If the source address of the incoming packet is an IPv6 link-local address, the interface name is added to the &lt;code&gt;address&lt;/code&gt;. For example, a packet received on the &lt;code&gt;en0&lt;/code&gt; interface might have the address field set to &lt;code&gt;'fe80::2618:1234:ab11:3b9c%en0'&lt;/code&gt;, where &lt;code&gt;'%en0'&lt;/code&gt; is the interface name as a zone ID suffix.</source>
          <target state="translated">수신 패킷의 소스 주소가 IPv6 링크 로컬 주소 인 경우 인터페이스 이름이 &lt;code&gt;address&lt;/code&gt; 추가됩니다 . 예를 들어 &lt;code&gt;en0&lt;/code&gt; 인터페이스 에서 수신 된 패킷 의 주소 필드가 &lt;code&gt;'fe80::2618:1234:ab11:3b9c%en0'&lt;/code&gt; 설정되어있을 수 있습니다. 여기서 &lt;code&gt;'%en0'&lt;/code&gt; 은 영역 ID 접미사 인 인터페이스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="46492c576efdd4f1790db38181ba945ea7cf73d4" translate="yes" xml:space="preserve">
          <source>If the stream is connecting &lt;code&gt;socket.readyState&lt;/code&gt; is &lt;code&gt;opening&lt;/code&gt;.</source>
          <target state="translated">스트림이 연결되면 &lt;code&gt;socket.readyState&lt;/code&gt; 를 이다 &lt;code&gt;opening&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4afe3a03dccc50f186d91e3cffcd9e5b80230df7" translate="yes" xml:space="preserve">
          <source>If the stream is not readable and writable, it is &lt;code&gt;writeOnly&lt;/code&gt;.</source>
          <target state="translated">스트림을 읽고 쓸 수없는 경우 &lt;code&gt;writeOnly&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e09ce348f6dbf571342db2c09fc61334ae0e87ec" translate="yes" xml:space="preserve">
          <source>If the stream is readable and not writable, it is &lt;code&gt;readOnly&lt;/code&gt;.</source>
          <target state="translated">스트림을 읽을 수 있고 쓸 수없는 경우 &lt;code&gt;readOnly&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25e52195fba67f6fb50c98cef5978c591e453ad0" translate="yes" xml:space="preserve">
          <source>If the stream is readable and writable, it is &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="translated">스트림이 읽고 쓸 수 있다면, 그것은이다 &lt;code&gt;open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75c6a8b07a563abb32426fd418fe170dc48b8de5" translate="yes" xml:space="preserve">
          <source>If the third argument is a number, then it specifies &lt;code&gt;flags&lt;/code&gt;:</source>
          <target state="translated">세 번째 인수가 숫자이면 &lt;code&gt;flags&lt;/code&gt; 지정 합니다. .</target>
        </trans-unit>
        <trans-unit id="8be3058f7fe15dd98c0f339d7b14daeae146deee" translate="yes" xml:space="preserve">
          <source>If the timeout expires, the server responds with status 408 without forwarding the request to the request listener and then closes the connection.</source>
          <target state="translated">시간 초과가 만료되면 서버는 요청을 요청 수신기에 전달하지 않고 상태 408로 응답 한 다음 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="626defb6cd97e8925106c19e6385f50800621781" translate="yes" xml:space="preserve">
          <source>If the underlying functionality is not available for some reason, then &lt;code&gt;fs.watch()&lt;/code&gt; will not be able to function and may thrown an exception. For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc) or host file systems when using virtualization software such as Vagrant or Docker.</source>
          <target state="translated">어떤 이유로 기본 기능을 사용할 수없는 경우 &lt;code&gt;fs.watch()&lt;/code&gt; 가 작동하지 않고 예외가 발생할 수 있습니다. 예를 들어 Vagrant 또는 Docker와 같은 가상화 소프트웨어를 사용하는 경우 네트워크 파일 시스템 (NFS, SMB 등) 또는 호스트 파일 시스템에서 파일 또는 디렉터리를 감시하는 것은 신뢰할 수없고 경우에 따라 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71076ea98f3be098c307fc8cb0dfd8e11760e9ca" translate="yes" xml:space="preserve">
          <source>If the underlying functionality is not available for some reason, then &lt;code&gt;fs.watch&lt;/code&gt; will not be able to function. For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.</source>
          <target state="translated">어떤 이유로 기본 기능을 사용할 수없는 경우 &lt;code&gt;fs.watch&lt;/code&gt; 가 작동하지 않습니다. 예를 들어 네트워크 파일 시스템 (NFS, SMB 등) 또는 Vagrant, Docker 등과 같은 가상화 소프트웨어를 사용할 때 호스트 파일 시스템에서 파일 또는 디렉토리를 보는 것은 신뢰할 수없고 경우에 따라 불가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3ff204ad926a2c406374c6beb30edbec4c9766" translate="yes" xml:space="preserve">
          <source>If the value assigned to the &lt;code&gt;href&lt;/code&gt; property is not a valid URL, a &lt;code&gt;TypeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; 속성에 할당 된 값 이 유효한 URL이 아닌 경우 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d90c5e203932eeac8e47f38ad8c3558ce56bbc29" translate="yes" xml:space="preserve">
          <source>If the value can not be converted to a number, or is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt; or &lt;code&gt;-Infinity&lt;/code&gt;, an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">값은 숫자로 변환, 또는이다 할 수없는 경우 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;Infinity&lt;/code&gt; 또는 &lt;code&gt;-Infinity&lt;/code&gt; , &lt;code&gt;Error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28e83e66ed225563a93b5f2e19b29f3cc812a630" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;urlObject.hash&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with the ASCII hash (&lt;code&gt;#&lt;/code&gt;) character, the literal string &lt;code&gt;#&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.hash&lt;/code&gt; 의 값이 ASCII 해시 ( &lt;code&gt;#&lt;/code&gt; ) 문자로 &lt;em&gt;시작하지 않으면&lt;/em&gt; 리터럴 문자열 &lt;code&gt;#&lt;/code&gt; 이 &lt;code&gt;result&lt;/code&gt; 추가됩니다. .</target>
        </trans-unit>
        <trans-unit id="354b6656744ff8bd4e88e85fb2306a95eb8ab63e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;urlObject.search&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with the ASCII question mark (&lt;code&gt;?&lt;/code&gt;) character, the literal string &lt;code&gt;?&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.search&lt;/code&gt; 의 값이 ASCII 물음표 ( &lt;code&gt;?&lt;/code&gt; ) 문자로 &lt;em&gt;시작하지 않으면&lt;/em&gt; 리터럴 문자열 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4697b6330115dae4c26d7a6e08df799526336ff3" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;urlObject.auth&lt;/code&gt; property is truthy, and either &lt;code&gt;urlObject.host&lt;/code&gt; or &lt;code&gt;urlObject.hostname&lt;/code&gt; are not &lt;code&gt;undefined&lt;/code&gt;, the value of &lt;code&gt;urlObject.auth&lt;/code&gt; will be coerced into a string and appended to &lt;code&gt;result&lt;/code&gt; followed by the literal string &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.auth&lt;/code&gt; 특성 의 값 이 진실이고 &lt;code&gt;urlObject.host&lt;/code&gt; 또는 &lt;code&gt;urlObject.hostname&lt;/code&gt; 이 &lt;code&gt;undefined&lt;/code&gt; 되지 않은 경우 &lt;code&gt;urlObject.auth&lt;/code&gt; 의 값이 문자열로 강제 변환되고 &lt;code&gt;result&lt;/code&gt; 에 리터럴 문자열 &lt;code&gt;@&lt;/code&gt; 이 추가됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="456254174b08d43308fd7afd472a34a1dd26ab6c" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is &lt;code&gt;true&lt;/code&gt; the default searching algorithms are used to find the module.</source>
          <target state="translated">리디렉션 값이 &lt;code&gt;true&lt;/code&gt; 모듈을 찾는 데 기본 검색 알고리즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="982c7fbef3736e828821d5101501a8b60a1d8d1f" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is &lt;code&gt;true&lt;/code&gt; the default searching algorithms will be used to find the module.</source>
          <target state="translated">리디렉션 값이 &lt;code&gt;true&lt;/code&gt; 이면 기본 검색 알고리즘을 사용하여 모듈을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2e11ada87c9591e197663cb2fdd4cdce368e18ed" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is a string, it is resolved relative to the manifest and then immediately used without searching.</source>
          <target state="translated">리디렉션의 값이 문자열이면 매니페스트를 기준으로 확인 된 다음 검색없이 즉시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1f9f5955d6e364ca71ad55b75bc35cbe0c3b38b" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is a string, it will be resolved relative to the manifest and then immediately be used without searching.</source>
          <target state="translated">리디렉션 값이 문자열 인 경우 매니페스트와 관련하여 확인 된 다음 검색하지 않고 즉시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c8c0c616296b45074943e0b708b25c1e5487f9d" translate="yes" xml:space="preserve">
          <source>If the value provided is larger than V8's maximum, then the largest value will be chosen.</source>
          <target state="translated">제공된 값이 V8의 최대 값보다 큰 경우 가장 큰 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b038c7b128978d09ecafa8a22c053af444ab7daa" translate="yes" xml:space="preserve">
          <source>If the values are deeply and strictly equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값이 완전히 같으면 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일한 &lt;code&gt;message&lt;/code&gt; 특성 세트 와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3c44d16087d66714415a16ae315be1645f738f6" translate="yes" xml:space="preserve">
          <source>If the values are deeply and strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 깊고 엄격 하면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="638a301b16f2859c51f7f2523e666e1667de4a20" translate="yes" xml:space="preserve">
          <source>If the values are deeply equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 매우 같으면 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일한 &lt;code&gt;message&lt;/code&gt; 특성 세트 와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3feda4cbb8c69da0787d3c4d0edc4afedfe6d516" translate="yes" xml:space="preserve">
          <source>If the values are deeply equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 매우 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5cba9dae04c3af0fed24d4023f5323acdff109b8" translate="yes" xml:space="preserve">
          <source>If the values are equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 같으면 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일한 &lt;code&gt;message&lt;/code&gt; 특성 세트 와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="191272d17c26c51430c4e20e797f1caf915bd356" translate="yes" xml:space="preserve">
          <source>If the values are equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6893f9de4472be9e011072e4db13a20ecd7b4004" translate="yes" xml:space="preserve">
          <source>If the values are not equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값이 같지 않으면 &lt;code&gt;message&lt;/code&gt; 매개 변수 의 값과 동일한 &lt;code&gt;message&lt;/code&gt; 특성 세트 와 함께 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7761b6c6e6fcfe08b01fe7eba382afd1f40b9435" translate="yes" xml:space="preserve">
          <source>If the values are not equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">If the values are not equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84d94f31db81c1f973e291da465a433690b463c0" translate="yes" xml:space="preserve">
          <source>If the values are not equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 같지 않으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="bee2d75c325da0f017ac53645ce9d9efc7bbf1d2" translate="yes" xml:space="preserve">
          <source>If the values are not strictly equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the values are not strictly equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="31b2da7358e1f618e30530614396b01dadfaf51f" translate="yes" xml:space="preserve">
          <source>If the values are not strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 엄격하게 같지 않으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="654affa2fd7d0e2f6b20f810272ee15e1ecc1638" translate="yes" xml:space="preserve">
          <source>If the values are strictly equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">If the values are strictly equal, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ff0a2446e1cfa20e6d7e26d965437d954f3efc4" translate="yes" xml:space="preserve">
          <source>If the values are strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 완전히 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="255dba9961a2ad02519c950d53ecca7c14eb2112" translate="yes" xml:space="preserve">
          <source>If the values do match, or if the &lt;code&gt;string&lt;/code&gt; argument is of another type than &lt;code&gt;string&lt;/code&gt;, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the values do match, or if the &lt;code&gt;string&lt;/code&gt; argument is of another type than &lt;code&gt;string&lt;/code&gt; , an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5cfb6dd9f5eca78b33930d2e38d454d514eb582f" translate="yes" xml:space="preserve">
          <source>If the values do not match, or if the &lt;code&gt;string&lt;/code&gt; argument is of another type than &lt;code&gt;string&lt;/code&gt;, an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the values do not match, or if the &lt;code&gt;string&lt;/code&gt; argument is of another type than &lt;code&gt;string&lt;/code&gt; , an &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; then it will be thrown instead of the &lt;a href=&quot;#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e05dba99c6a0fea21f35e050285f2b6c393e3295" translate="yes" xml:space="preserve">
          <source>If the worker has stopped, the return value is an empty object.</source>
          <target state="translated">If the worker has stopped, the return value is an empty object.</target>
        </trans-unit>
        <trans-unit id="da602dad1348c5515a5368e54eed719f37be707a" translate="yes" xml:space="preserve">
          <source>If there are any remaining open &lt;code&gt;Http2Streams&lt;/code&gt; associated with the &lt;code&gt;Http2Session&lt;/code&gt;, those will also be destroyed.</source>
          <target state="translated">남아있는 열려있는 경우 &lt;code&gt;Http2Streams&lt;/code&gt; 과 관련된 &lt;code&gt;Http2Session&lt;/code&gt; , 사람들은 파괴 될 것이다.</target>
        </trans-unit>
        <trans-unit id="45b740bcc2b16e4bb9b682fe0bd542a05605c049" translate="yes" xml:space="preserve">
          <source>If there are more arguments passed to the &lt;code&gt;util.format()&lt;/code&gt; method than the number of specifiers, the extra arguments are concatenated to the returned string, separated by spaces:</source>
          <target state="translated">지정자 수보다 &lt;code&gt;util.format()&lt;/code&gt; 메소드에 전달 된 인수가 더 많은 경우 추가 인수는 공백으로 구분되어 리턴 된 문자열에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="698579d27a4ddffd0cd3fee0cd725708e9b8c0c0" translate="yes" xml:space="preserve">
          <source>If there are multiple, nested domains bound to the current execution context, &lt;code&gt;exit()&lt;/code&gt; will exit any domains nested within this domain.</source>
          <target state="translated">현재 실행 컨텍스트에 바인딩 된 중첩 된 도메인이 여러 개인 경우 &lt;code&gt;exit()&lt;/code&gt; 는이 도메인 내에 중첩 된 모든 도메인을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e1df8284a9b0df51b3cefbe17157c6029fc2b0bf" translate="yes" xml:space="preserve">
          <source>If there are no more directory entries to read, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">If there are no more directory entries to read, &lt;code&gt;null&lt;/code&gt; will be returned.</target>
        </trans-unit>
        <trans-unit id="dc6b904b20e2c573a6f4d896aa8a2fa420127eee" translate="yes" xml:space="preserve">
          <source>If there are no pipe destinations, by calling the &lt;a href=&quot;#stream_readable_pause&quot;&gt;&lt;code&gt;stream.pause()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파이프 대상이없는 경우 &lt;a href=&quot;#stream_readable_pause&quot;&gt; &lt;code&gt;stream.pause()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여</target>
        </trans-unit>
        <trans-unit id="53903dbbffb3efe8650a918ab139a66c8a9d7384" translate="yes" xml:space="preserve">
          <source>If there are pipe destinations, by removing all pipe destinations. Multiple pipe destinations may be removed by calling the &lt;a href=&quot;#stream_readable_unpipe_destination&quot;&gt;&lt;code&gt;stream.unpipe()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파이프 대상이있는 경우 모든 파이프 대상을 제거하여 파이프 대상을 제거하십시오. &lt;a href=&quot;#stream_readable_unpipe_destination&quot;&gt; &lt;code&gt;stream.unpipe()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 여러 파이프 대상을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="808ed805596f02baf1205d0104edc17496833e97" translate="yes" xml:space="preserve">
          <source>If there are specific reasons to use &lt;code&gt;process.dlopen()&lt;/code&gt; (for instance, to specify dlopen flags), it's often useful to use &lt;a href=&quot;modules#modules_require_resolve_request_options&quot;&gt;&lt;code&gt;require.resolve()&lt;/code&gt;&lt;/a&gt; to look up the module's path.</source>
          <target state="translated">&lt;code&gt;process.dlopen()&lt;/code&gt; 을 사용해야하는 특정 이유가있는 경우 ( 예 : dlopen 플래그 지정) &lt;a href=&quot;modules#modules_require_resolve_request_options&quot;&gt; &lt;code&gt;require.resolve()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 모듈의 경로를 찾는 것이 종종 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="afc44255b34b29834468d6a2fcd2f10d21a794e9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;'timeout'&lt;/code&gt; event listener on the Server object, then it will be called with the timed-out socket as an argument.</source>
          <target state="translated">가있는 경우 &lt;code&gt;'timeout'&lt;/code&gt; 서버 객체에 이벤트 리스너가, 다음은 인수로 시간이 만료 소켓 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="85fc1803c513e97d473fe51f97314f53ca219f6c" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;original[util.promisify.custom]&lt;/code&gt; property present, &lt;code&gt;promisify&lt;/code&gt; will return its value, see &lt;a href=&quot;#util_custom_promisified_functions&quot;&gt;Custom promisified functions&lt;/a&gt;.</source>
          <target state="translated">이 생길 경우 &lt;code&gt;original[util.promisify.custom]&lt;/code&gt; 속성 존재는 &lt;code&gt;promisify&lt;/code&gt; 은 그 값을 반환 볼 &lt;a href=&quot;#util_custom_promisified_functions&quot;&gt;사용자 정의 기능 promisified&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="119a2151456635e90a77f1336a58bdca2900be5b" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; file present in the directory, or if the &lt;a href=&quot;packages#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; entry is missing or cannot be resolved, then Node.js will attempt to load an &lt;code&gt;index.js&lt;/code&gt; or &lt;code&gt;index.node&lt;/code&gt; file out of that directory. For example, if there was no &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; file in the previous example, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load:</source>
          <target state="translated">If there is no &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; &lt;/a&gt; file present in the directory, or if the &lt;a href=&quot;packages#packages_main&quot;&gt; &lt;code&gt;&quot;main&quot;&lt;/code&gt; &lt;/a&gt; entry is missing or cannot be resolved, then Node.js will attempt to load an &lt;code&gt;index.js&lt;/code&gt; or &lt;code&gt;index.node&lt;/code&gt; file out of that directory. For example, if there was no &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; &lt;/a&gt; file in the previous example, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load:</target>
        </trans-unit>
        <trans-unit id="43f0364f8de171c5fc72a4af4e61f0c6915879a3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;package.json&lt;/code&gt; file present in the directory, or if the &lt;code&gt;'main'&lt;/code&gt; entry is missing or cannot be resolved, then Node.js will attempt to load an &lt;code&gt;index.js&lt;/code&gt; or &lt;code&gt;index.node&lt;/code&gt; file out of that directory. For example, if there was no &lt;code&gt;package.json&lt;/code&gt; file in the above example, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load:</source>
          <target state="translated">어떤이없는 경우 &lt;code&gt;package.json&lt;/code&gt; 의 디렉토리에 파일 존재가 있다면, 또는 &lt;code&gt;'main'&lt;/code&gt; 항목이 없거나 해결할 수없는, 다음 Node.js를가로드하려고 시도 &lt;code&gt;index.js&lt;/code&gt; 또는 &lt;code&gt;index.node&lt;/code&gt; 의 디렉토리에서 파일을. 예를 들어, 위 예제에 &lt;code&gt;package.json&lt;/code&gt; 파일 이 없으면 &lt;code&gt;require('./some-library')&lt;/code&gt; 가로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7e0cb8b2e9ee0148b30bf42005c017e69093ae44" translate="yes" xml:space="preserve">
          <source>If there is no local certificate, an empty object will be returned. If the socket has been destroyed, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">로컬 인증서가 없으면 빈 개체가 반환됩니다. 소켓이 파괴 된 경우는 &lt;code&gt;null&lt;/code&gt; 을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="fac7e10c7ee4c185adcdea481447e11e04726d41" translate="yes" xml:space="preserve">
          <source>If there is no local certificate, or if the &lt;code&gt;QuicSession&lt;/code&gt; has been destroyed, an empty object will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d88cc35a1e5f4ab2434014beef29a6b8b2436e3" translate="yes" xml:space="preserve">
          <source>If these attempts fail, then Node.js will report the entire module as missing with the default error:</source>
          <target state="translated">이러한 시도가 실패하면 Node.js는 기본 오류와 함께 전체 모듈이 누락 된 것으로보고합니다.</target>
        </trans-unit>
        <trans-unit id="01e89fda5beccddb8f1c71631aaa97e426bae7a5" translate="yes" xml:space="preserve">
          <source>If this flag is passed, the behavior can still be set to not abort through &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt;&lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt;&lt;/a&gt; (and through usage of the &lt;code&gt;domain&lt;/code&gt; module that uses it).</source>
          <target state="translated">이 플래그가 전달되면 &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt; &lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt; &lt;/a&gt; 및이를 사용하는 &lt;code&gt;domain&lt;/code&gt; 모듈 사용을 통해 동작이 중단되지 않도록 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8426e9ec3e8a8ad46000e461f3a11d6c18b908f9" translate="yes" xml:space="preserve">
          <source>If this hook is used to convert unknown-to-Node.js file types into executable JavaScript, a resolve hook is also necessary in order to register any unknown-to-Node.js file extensions. See the &lt;a href=&quot;#esm_transpiler_loader&quot;&gt;transpiler loader example&lt;/a&gt; below.</source>
          <target state="translated">If this hook is used to convert unknown-to-Node.js file types into executable JavaScript, a resolve hook is also necessary in order to register any unknown-to-Node.js file extensions. See the &lt;a href=&quot;#esm_transpiler_loader&quot;&gt;transpiler loader example&lt;/a&gt; below.</target>
        </trans-unit>
        <trans-unit id="a155d60f93780a23e7f931df52c38c0f6fd72e4c" translate="yes" xml:space="preserve">
          <source>If this is used in the main thread, its value is an empty object.</source>
          <target state="translated">If this is used in the main thread, its value is an empty object.</target>
        </trans-unit>
        <trans-unit id="f39b5b9c13b1ddf3e432e4ec5ca8712b07563b19" translate="yes" xml:space="preserve">
          <source>If this method is &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesWritten&lt;/code&gt; and &lt;code&gt;buffers&lt;/code&gt; properties.</source>
          <target state="translated">이 메소드가 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;bytesWritten&lt;/code&gt; 및 &lt;code&gt;buffers&lt;/code&gt; 특성을 가진 &lt;code&gt;Object&lt;/code&gt; 대한 &lt;code&gt;Promise&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="848ee8754e17695db5eea6ee56dc831672698103" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http2_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt; has not been called, it will switch to implicit header mode and flush the implicit headers.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http2_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 암시 적 헤더 모드로 전환하고 암시 적 헤더를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="863ede4dd3d457c897371e8202fbec82f0818194" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt;&lt;code&gt;response.setHeader()&lt;/code&gt;&lt;/a&gt; has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the &lt;a href=&quot;#http_response_getheader_name&quot;&gt;&lt;code&gt;response.getHeader()&lt;/code&gt;&lt;/a&gt; on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt;&lt;code&gt;response.setHeader()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt; &lt;code&gt;response.setHeader()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 내부적으로 캐싱하지 않고 제공된 헤더 값을 네트워크 채널에 직접 쓰며 헤더의 &lt;a href=&quot;#http_response_getheader_name&quot;&gt; &lt;code&gt;response.getHeader()&lt;/code&gt; &lt;/a&gt; 는 예상 된 결과를 산출하지 않습니다. 향후 검색 및 수정이 가능한 점진적인 헤더 모집이 필요한 경우 &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt; &lt;code&gt;response.setHeader()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f8bf717520bed1a535f84bb455286f68447c2d06" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt; has not been called, it will switch to implicit header mode and flush the implicit headers.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 암시 적 헤더 모드로 전환하고 암시 적 헤더를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="59b52c6bec23c453cf6476176e31528205155635" translate="yes" xml:space="preserve">
          <source>If this method is called without a label, the most recently started profile is stopped.</source>
          <target state="translated">레이블없이이 메소드를 호출하면 가장 최근에 시작된 프로파일이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="da8ccda14c2d5edd4fce7c787763bcd45d9f4a10" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, and &lt;code&gt;all&lt;/code&gt; is not set to &lt;code&gt;true&lt;/code&gt;, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;family&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에디션 버전, &lt;code&gt;all&lt;/code&gt; 로 설정되지 않은 &lt;code&gt;true&lt;/code&gt; , 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;family&lt;/code&gt; 특성.</target>
        </trans-unit>
        <trans-unit id="fc491ff668f0ad005b523fb4afb065a33fd0ce04" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesRead&lt;/code&gt; and &lt;code&gt;buffer&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;bytesRead&lt;/code&gt; 및 &lt;code&gt;buffer&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="7185c658579d422e7eba6cdc07f4b4cbe8004f1d" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesRead&lt;/code&gt; and &lt;code&gt;buffers&lt;/code&gt; properties.</source>
          <target state="translated">If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesRead&lt;/code&gt; and &lt;code&gt;buffers&lt;/code&gt; properties.</target>
        </trans-unit>
        <trans-unit id="d137547d5ca92dc63e7c2007a92f1e7211e167ad" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesWritten&lt;/code&gt; and &lt;code&gt;buffer&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;bytesWritten&lt;/code&gt; 및 &lt;code&gt;buffer&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="fd5bb143ee298fdd24e036558635695a1e0cd676" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;hostname&lt;/code&gt; and &lt;code&gt;service&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;hostname&lt;/code&gt; 및 &lt;code&gt;service&lt;/code&gt; 특성.</target>
        </trans-unit>
        <trans-unit id="603337fd667fc9ebe65d8742a13478c7c173636d" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;publicKey&lt;/code&gt; and &lt;code&gt;privateKey&lt;/code&gt; properties.</source>
          <target state="translated">이 메소드가 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 버전 으로 호출되면 &lt;code&gt;publicKey&lt;/code&gt; 및 &lt;code&gt;privateKey&lt;/code&gt; 특성을 가진 &lt;code&gt;Object&lt;/code&gt; 대한 &lt;code&gt;Promise&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="e3f19615a76df308a4eaaa08102fe8029d4cd7da" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; properties. The returned &lt;code&gt;ChildProcess&lt;/code&gt; instance is attached to the &lt;code&gt;Promise&lt;/code&gt; as a &lt;code&gt;child&lt;/code&gt; property. In case of an error (including any error resulting in an exit code other than 0), a rejected promise is returned, with the same &lt;code&gt;error&lt;/code&gt; object given in the callback, but with two additional properties &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;stdout&lt;/code&gt; 과 &lt;code&gt;stderr&lt;/code&gt; 속성. 반환 된 &lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스는 &lt;code&gt;Promise&lt;/code&gt; 에 &lt;code&gt;child&lt;/code&gt; 속성으로 연결됩니다. 오류 (0 이외의 종료 코드를 초래하는 오류 포함)의 경우, 콜백에 제공된 동일한 &lt;code&gt;error&lt;/code&gt; 오브젝트와 함께 두 개의 추가 특성 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 과 함께 거부 된 약속이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="325b0754bdd6596fd481b9c1fd1a89b41adcb29d" translate="yes" xml:space="preserve">
          <source>If this option is chosen, ICU is disabled and most internationalization features mentioned above will be &lt;strong&gt;unavailable&lt;/strong&gt; in the resulting &lt;code&gt;node&lt;/code&gt; binary.</source>
          <target state="translated">If this option is chosen, ICU is disabled and most internationalization features mentioned above will be &lt;strong&gt;unavailable&lt;/strong&gt; in the resulting &lt;code&gt;node&lt;/code&gt; binary.</target>
        </trans-unit>
        <trans-unit id="a19ad792e4d182ce79c59a9ca23b96f01cbba405" translate="yes" xml:space="preserve">
          <source>If this option is chosen, most internationalization features mentioned above will be &lt;strong&gt;unavailable&lt;/strong&gt; in the resulting &lt;code&gt;node&lt;/code&gt; binary.</source>
          <target state="translated">이 옵션을 선택하면 위에서 언급 한 대부분의 국제화 기능을 결과 &lt;code&gt;node&lt;/code&gt; 2 진 에서 &lt;strong&gt;사용할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="500c44aa740b1f808b7a0f2ab5d42a89495c80b0" translate="yes" xml:space="preserve">
          <source>If this program is run with &lt;code&gt;NODE_DEBUG=foo&lt;/code&gt; in the environment, then it will output something like:</source>
          <target state="translated">이 프로그램이 환경에서 &lt;code&gt;NODE_DEBUG=foo&lt;/code&gt; 로 실행 되면 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb2d2d9aab2e6cdd4053fd254b4acb41df11a8c" translate="yes" xml:space="preserve">
          <source>If this thread is a &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, this is a &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt; allowing communication with the parent thread. Messages sent using &lt;code&gt;parentPort.postMessage()&lt;/code&gt; are available in the parent thread using &lt;code&gt;worker.on('message')&lt;/code&gt;, and messages sent from the parent thread using &lt;code&gt;worker.postMessage()&lt;/code&gt; are available in this thread using &lt;code&gt;parentPort.on('message')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae04778b2127a4288d498c5fee83b1c180563316" translate="yes" xml:space="preserve">
          <source>If this thread was spawned as a &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, this will be a &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt; allowing communication with the parent thread. Messages sent using &lt;code&gt;parentPort.postMessage()&lt;/code&gt; will be available in the parent thread using &lt;code&gt;worker.on('message')&lt;/code&gt;, and messages sent from the parent thread using &lt;code&gt;worker.postMessage()&lt;/code&gt; will be available in this thread using &lt;code&gt;parentPort.on('message')&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 으로 생성 된 경우 상위 스레드와의 통신을 허용 하는 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 가됩니다 . &lt;code&gt;parentPort.postMessage()&lt;/code&gt; 를 사용하여 전송 된 메시지는 &lt;code&gt;worker.on('message')&lt;/code&gt; 를 사용하여 상위 스레드 에서 사용할 수 있으며 &lt;code&gt;worker.postMessage()&lt;/code&gt; 를 사용하여 상위 스레드에서 전송 된 메시지는 &lt;code&gt;parentPort.on('message')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc56c6fa0ffaae3cb37166a046e6a592fac511fd" translate="yes" xml:space="preserve">
          <source>If this was in a folder at &lt;code&gt;./some-library&lt;/code&gt;, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load &lt;code&gt;./some-library/lib/some-library.js&lt;/code&gt;.</source>
          <target state="translated">이에 폴더에있는 경우 &lt;code&gt;./some-library&lt;/code&gt; , 다음 &lt;code&gt;require('./some-library')&lt;/code&gt; 부하를 시도 할 &lt;code&gt;./some-library/lib/some-library.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f24447a04296622991f6bf6fd22ce1eff8075cb0" translate="yes" xml:space="preserve">
          <source>If true, the &lt;code&gt;Immediate&lt;/code&gt; object will keep the Node.js event loop active.</source>
          <target state="translated">true 인 경우 &lt;code&gt;Immediate&lt;/code&gt; 객체는 Node.js 이벤트 루프를 활성 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6bfdfe9d5a5d4ec04917fff9485b8abe04f4523b" translate="yes" xml:space="preserve">
          <source>If true, the &lt;code&gt;Timeout&lt;/code&gt; object will keep the Node.js event loop active.</source>
          <target state="translated">true 인 경우 &lt;code&gt;Timeout&lt;/code&gt; 객체는 Node.js 이벤트 루프를 활성 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4d30f4ae940d81fef9d58173f937c6e90488a310" translate="yes" xml:space="preserve">
          <source>If using Perfect Forward Secrecy using &lt;code&gt;ECDHE&lt;/code&gt;, Diffie-Hellman parameters are not required and a default ECDHE curve will be used. The &lt;code&gt;ecdhCurve&lt;/code&gt; property can be used when creating a TLS Server to specify the list of names of supported curves to use, see &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt;&lt;code&gt;tls.createServer()&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;ECDHE&lt;/code&gt; 를 사용하여 Perfect Forward Secrecy를 사용 하는 경우 Diffie-Hellman 매개 변수가 필요하지 않으며 기본 ECDHE 곡선이 사용됩니다. &lt;code&gt;ecdhCurve&lt;/code&gt; 의 속성은 사용에 지원 곡선의 이름 목록을 지정하는 TLS 서버를 만들 때 사용할 수있는 참조 &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt; &lt;code&gt;tls.createServer()&lt;/code&gt; &lt;/a&gt; 추가 정보를 원하시면.</target>
        </trans-unit>
        <trans-unit id="7141d84e2c2fdb717376d2b2569b6326aa7d2535" translate="yes" xml:space="preserve">
          <source>If using perfect forward secrecy using &lt;code&gt;ECDHE&lt;/code&gt;, Diffie-Hellman parameters are not required and a default ECDHE curve will be used. The &lt;code&gt;ecdhCurve&lt;/code&gt; property can be used when creating a TLS Server to specify the list of names of supported curves to use, see &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt;&lt;code&gt;tls.createServer()&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">If using perfect forward secrecy using &lt;code&gt;ECDHE&lt;/code&gt; , Diffie-Hellman parameters are not required and a default ECDHE curve will be used. The &lt;code&gt;ecdhCurve&lt;/code&gt; property can be used when creating a TLS Server to specify the list of names of supported curves to use, see &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt; &lt;code&gt;tls.createServer()&lt;/code&gt; &lt;/a&gt; for more info.</target>
        </trans-unit>
        <trans-unit id="f435cf016bb3848af3be13125a0963095befa409" translate="yes" xml:space="preserve">
          <source>If wait is &lt;code&gt;true&lt;/code&gt;, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.</source>
          <target state="translated">wait가 &lt;code&gt;true&lt;/code&gt; 이면 클라이언트가 검사 포트에 연결되고 흐름 제어가 디버거 클라이언트에 전달 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec49b998fbf4e6aaa095e55b84d88c9c2f6edc6" translate="yes" xml:space="preserve">
          <source>If you intend for your module to produce diagnostics data for others to consume it is recommended that you include documentation of what named channels are used along with the shape of the message data. Channel names should generally include the module name to avoid collisions with data from other modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d91ae8c7344f438f4b68baa4585ffcdbd09f34f" translate="yes" xml:space="preserve">
          <source>If you need to keep using callback-based API, or your code assumes a custom thenable implementation, use the &lt;a href=&quot;#async_hooks_class_asyncresource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; class to associate the asynchronous operation with the correct execution context.</source>
          <target state="translated">If you need to keep using callback-based API, or your code assumes a custom thenable implementation, use the &lt;a href=&quot;#async_hooks_class_asyncresource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; class to associate the asynchronous operation with the correct execution context.</target>
        </trans-unit>
        <trans-unit id="121d2a133df529636a3133c7f19553410022ce10" translate="yes" xml:space="preserve">
          <source>If your code is callback-based, it is enough to promisify it with &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;, so it starts working with native promises.</source>
          <target state="translated">If your code is callback-based, it is enough to promisify it with &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt;, so it starts working with native promises.</target>
        </trans-unit>
        <trans-unit id="ff92bf6b6790ad5534e9adfe6cd542093ec41214" translate="yes" xml:space="preserve">
          <source>If, after processing all given &lt;code&gt;path&lt;/code&gt; segments, an absolute path has not yet been generated, the current working directory is used.</source>
          <target state="translated">If, after processing all given &lt;code&gt;path&lt;/code&gt; segments, an absolute path has not yet been generated, the current working directory is used.</target>
        </trans-unit>
        <trans-unit id="bb55778c3d32ddfa125fd33521937cb25ae4bdce" translate="yes" xml:space="preserve">
          <source>If, within an async function, only one &lt;code&gt;await&lt;/code&gt; call is to run within a context, the following pattern should be used:</source>
          <target state="translated">If, within an async function, only one &lt;code&gt;await&lt;/code&gt; call is to run within a context, the following pattern should be used:</target>
        </trans-unit>
        <trans-unit id="868930280894191b54d63d2127ac6fdebf557223" translate="yes" xml:space="preserve">
          <source>Immediate</source>
          <target state="translated">Immediate</target>
        </trans-unit>
        <trans-unit id="ef70f1951457da5e8c2ceb794366acfb2b9f1c46" translate="yes" xml:space="preserve">
          <source>Immediately close the session. All pending message callbacks will be called with an error. &lt;a href=&quot;#inspector_session_connect&quot;&gt;&lt;code&gt;session.connect()&lt;/code&gt;&lt;/a&gt; will need to be called to be able to send messages again. Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.</source>
          <target state="translated">세션을 즉시 닫습니다. 보류중인 모든 메시지 콜백은 오류와 함께 호출됩니다. 메시지를 다시 보내려면 &lt;a href=&quot;#inspector_session_connect&quot;&gt; &lt;code&gt;session.connect()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다. 다시 연결된 세션은 활성화 된 에이전트 또는 구성된 중단 점과 같은 모든 관리자 상태를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="a99a34a2338aa3ca62a62f452af4cdab32edc49b" translate="yes" xml:space="preserve">
          <source>Immediately terminates the &lt;code&gt;Http2Session&lt;/code&gt; and the associated &lt;code&gt;net.Socket&lt;/code&gt; or &lt;code&gt;tls.TLSSocket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 및 관련 &lt;code&gt;net.Socket&lt;/code&gt; 또는 &lt;code&gt;tls.TLSSocket&lt;/code&gt; 을 즉시 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="61ac561b2af3d0aa0533d990f88aeb544ebb6302" translate="yes" xml:space="preserve">
          <source>Implement conditional exports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0be27861ebce466e57894de0545769251301b3" translate="yes" xml:space="preserve">
          <source>Implement logical conditional exports ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7830d9e83bdb571cca1e50f542e8516184aeb2bf" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="translated">구현 고려 사항</target>
        </trans-unit>
        <trans-unit id="634778886a41465d653b4d3a526333668ae37b90" translate="yes" xml:space="preserve">
          <source>Implementation does not test the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots&quot;&gt;&lt;code&gt;[[Prototype]]&lt;/code&gt;&lt;/a&gt; of objects.</source>
          <target state="translated">구현은 객체 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots&quot;&gt; &lt;code&gt;[[Prototype]]&lt;/code&gt; &lt;/a&gt; 을 테스트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ebd8293192193a3da2c48647fd3b6fba3cc9add9" translate="yes" xml:space="preserve">
          <source>Implementations of this function must avoid making N-API calls that execute JavaScript or interact with JavaScript objects. N-API calls should be in the &lt;code&gt;napi_async_complete_callback&lt;/code&gt; instead. Do not use the &lt;code&gt;napi_env&lt;/code&gt; parameter as it will likely result in execution of JavaScript.</source>
          <target state="translated">Implementations of this function must avoid making N-API calls that execute JavaScript or interact with JavaScript objects. N-API calls should be in the &lt;code&gt;napi_async_complete_callback&lt;/code&gt; instead. Do not use the &lt;code&gt;napi_env&lt;/code&gt; parameter as it will likely result in execution of JavaScript.</target>
        </trans-unit>
        <trans-unit id="6b6d9cd007a22716a471f704b1a6cc1b7798fc03" translate="yes" xml:space="preserve">
          <source>Implementations of this type of function should avoid making any N-API calls that could result in the execution of JavaScript or interaction with JavaScript objects. Most often, any code that needs to make N-API calls should be made in &lt;code&gt;napi_async_complete_callback&lt;/code&gt; instead. Avoid using the &lt;code&gt;napi_env&lt;/code&gt; parameter in the execute callback as it will likely execute JavaScript.</source>
          <target state="translated">이 유형의 함수를 구현하면 JavaScript가 실행되거나 JavaScript 객체와 상호 작용할 수있는 N-API 호출을 피해야합니다. 대부분의 경우 N-API 호출이 필요한 코드는 대신 &lt;code&gt;napi_async_complete_callback&lt;/code&gt; 에서 작성 해야합니다 . JavaScript를 실행할 가능성이 있으므로 실행 콜백에서 &lt;code&gt;napi_env&lt;/code&gt; 매개 변수를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="faf48c742a3c8cab6d288870f7e9087dc4b107e3" translate="yes" xml:space="preserve">
          <source>Implementing a Duplex Stream</source>
          <target state="translated">이중 스트림 구현</target>
        </trans-unit>
        <trans-unit id="db85aacb4826a9682bbc4755f7b18287b8212229" translate="yes" xml:space="preserve">
          <source>Implementing a Readable Stream</source>
          <target state="translated">읽을 수있는 스트림 구현</target>
        </trans-unit>
        <trans-unit id="a5a17668a54393ad9d8a2818f383b3289899b323" translate="yes" xml:space="preserve">
          <source>Implementing a Transform Stream</source>
          <target state="translated">변환 스트림 구현</target>
        </trans-unit>
        <trans-unit id="03961dad0ca35871550bb64b77b7602fe30a905c" translate="yes" xml:space="preserve">
          <source>Implementing a Writable Stream</source>
          <target state="translated">쓰기 가능한 스트림 구현</target>
        </trans-unit>
        <trans-unit id="facde054e9e2d009e7af73a9afa36e32825f5448" translate="yes" xml:space="preserve">
          <source>Implementing a duplex stream</source>
          <target state="translated">Implementing a duplex stream</target>
        </trans-unit>
        <trans-unit id="9b3a6269a6abcc8faa06ed8949790459f3fb4dcb" translate="yes" xml:space="preserve">
          <source>Implementing a readable stream</source>
          <target state="translated">Implementing a readable stream</target>
        </trans-unit>
        <trans-unit id="f8937f8c725f3f756c80a6fc4c454f66ce4301e3" translate="yes" xml:space="preserve">
          <source>Implementing a transform stream</source>
          <target state="translated">Implementing a transform stream</target>
        </trans-unit>
        <trans-unit id="6ac478c96bba4b13f55b149b0bc50ffaa26643e6" translate="yes" xml:space="preserve">
          <source>Implementing a writable stream</source>
          <target state="translated">Implementing a writable stream</target>
        </trans-unit>
        <trans-unit id="24158ac8b52526396a1d846f3f7fe2a89a3207a1" translate="yes" xml:space="preserve">
          <source>Implementors should not override this method, but instead implement &lt;a href=&quot;#stream_readable_destroy_err_callback&quot;&gt;&lt;code&gt;readable._destroy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementors should not override this method, but instead implement &lt;a href=&quot;#stream_readable_destroy_err_callback&quot;&gt; &lt;code&gt;readable._destroy()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="414c6b495e83ad2649c91b0478470c80a912e404" translate="yes" xml:space="preserve">
          <source>Implementors should not override this method, but instead implement &lt;a href=&quot;#stream_writable_destroy_err_callback&quot;&gt;&lt;code&gt;writable._destroy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementors should not override this method, but instead implement &lt;a href=&quot;#stream_writable_destroy_err_callback&quot;&gt; &lt;code&gt;writable._destroy()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0b72b192149e114c030ffa08bb6d7f33fa1da0cd" translate="yes" xml:space="preserve">
          <source>Implications of ABI Stability</source>
          <target state="translated">ABI 안정성의 의미</target>
        </trans-unit>
        <trans-unit id="c58283f97ee77608c6bf6b2d12793df5d7e1d959" translate="yes" xml:space="preserve">
          <source>Implications of ABI stability</source>
          <target state="translated">Implications of ABI stability</target>
        </trans-unit>
        <trans-unit id="e5868306e35f5ed89a827d7088b357d35fdb7d9c" translate="yes" xml:space="preserve">
          <source>Implicit Binding</source>
          <target state="translated">암시 적 바인딩</target>
        </trans-unit>
        <trans-unit id="1755f85cb8b44fb3483bbcb74852f951b95f7a93" translate="yes" xml:space="preserve">
          <source>Implicit binding</source>
          <target state="translated">Implicit binding</target>
        </trans-unit>
        <trans-unit id="38c43897c9e7ad17a3fff4ee301c220a1f8ca4ce" translate="yes" xml:space="preserve">
          <source>Implicit binding routes thrown errors and &lt;code&gt;'error'&lt;/code&gt; events to the &lt;code&gt;Domain&lt;/code&gt;'s &lt;code&gt;'error'&lt;/code&gt; event, but does not register the &lt;code&gt;EventEmitter&lt;/code&gt; on the &lt;code&gt;Domain&lt;/code&gt;. Implicit binding only takes care of thrown errors and &lt;code&gt;'error'&lt;/code&gt; events.</source>
          <target state="translated">내재 된 바인딩은 &lt;code&gt;'error'&lt;/code&gt; 오류 및 '오류' 이벤트를 &lt;code&gt;Domain&lt;/code&gt; 의 &lt;code&gt;'error'&lt;/code&gt; 이벤트로 라우팅 하지만 &lt;code&gt;Domain&lt;/code&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 를 등록하지는 않습니다 . 암시 적 바인딩은 발생 된 오류 및 &lt;code&gt;'error'&lt;/code&gt; 이벤트 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7eccc8d808af7ec8041e3741f9d5bd71307f86ba" translate="yes" xml:space="preserve">
          <source>Implicit conversion of variable value to string is deprecated.</source>
          <target state="translated">변수 값을 문자열로 암시 적으로 변환하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9611babfecccecf8b0959b746b13487f172df7d" translate="yes" xml:space="preserve">
          <source>Import maps permit mapping to external packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac758850e503d7a4b5403c1e169e629ed31d72d" translate="yes" xml:space="preserve">
          <source>Importing Web Assembly modules is supported under the &lt;code&gt;--experimental-wasm-modules&lt;/code&gt; flag, allowing any &lt;code&gt;.wasm&lt;/code&gt; files to be imported as normal modules while also supporting their module imports.</source>
          <target state="translated">웹 어셈블리 모듈 가져 오기는 &lt;code&gt;--experimental-wasm-modules&lt;/code&gt; 플래그에서 지원되므로 &lt;code&gt;.wasm&lt;/code&gt; 파일을 일반 모듈로 가져올 수 있으며 모듈 가져 오기도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5d0995ca6d1b678abda226f52f7ccf1e681292bd" translate="yes" xml:space="preserve">
          <source>Importing assert directly was not recommended as the exposed functions use loose equality checks. The deprecation was revoked because use of the &lt;code&gt;assert&lt;/code&gt; module is not discouraged, and the deprecation caused developer confusion.</source>
          <target state="translated">Importing assert directly was not recommended as the exposed functions use loose equality checks. The deprecation was revoked because use of the &lt;code&gt;assert&lt;/code&gt; module is not discouraged, and the deprecation caused developer confusion.</target>
        </trans-unit>
        <trans-unit id="7345227f7378a415d72e584bcb83fb5f70dfbf9d" translate="yes" xml:space="preserve">
          <source>Importing assert directly was not recommended as the exposed functions use loose equality checks. The deprecation was revoked because use of the &lt;code&gt;assert&lt;/code&gt; module is not discouraged, and the deprecation caused end user confusion.</source>
          <target state="translated">노출 된 함수가 느슨한 동등성 검사를 사용하므로 어설 션을 직접 가져 오는 것은 권장되지 않습니다. &lt;code&gt;assert&lt;/code&gt; 모듈의 사용을 권장하지 않아 폐기가 취소되었으며 폐기시 최종 사용자 혼란이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="719f27a57e84457bcd0681fc9a845a1f86dcefe3" translate="yes" xml:space="preserve">
          <source>Impose new restrictions on &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, throwing more appropriate errors in cases when we cannot reasonably handle the input values.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 에 새로운 제한을 적용 하여 입력 값을 합리적으로 처리 할 수없는 경우 더 적절한 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fc0a6a13b4155e379d15b548250d87be9841ca3e" translate="yes" xml:space="preserve">
          <source>In &quot;old&quot; streams mode the &lt;code&gt;stdin&lt;/code&gt; stream is paused by default, so one must call &lt;code&gt;process.stdin.resume()&lt;/code&gt; to read from it. Note also that calling &lt;code&gt;process.stdin.resume()&lt;/code&gt; itself would switch stream to &quot;old&quot; mode.</source>
          <target state="translated">&quot;오래된&quot;스트림 모드에서는 &lt;code&gt;stdin&lt;/code&gt; 스트림이 기본적으로 일시 중지되므로 &lt;code&gt;process.stdin.resume()&lt;/code&gt; 을 호출 하여 읽어야합니다. &lt;code&gt;process.stdin.resume()&lt;/code&gt; 자체 를 호출 하면 스트림이 &quot;old&quot;모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="83410f354c55a4241f9c563148181123808a776c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads, &lt;code&gt;process.umask(mask)&lt;/code&gt; will throw an exception.</source>
          <target state="translated">In &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; threads, &lt;code&gt;process.umask(mask)&lt;/code&gt; will throw an exception.</target>
        </trans-unit>
        <trans-unit id="27679f0db56c1c9325293a60e2506baf9182ffc5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads, this function stops the current thread rather than the current process.</source>
          <target state="translated">에서는 &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드,이 기능은 현재 스레드보다는 현재의 처리를 정지한다.</target>
        </trans-unit>
        <trans-unit id="2b5b31a009a869ce0f6f2aa3aa25bde8d5d67b27" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;entry.js&lt;/code&gt; script:</source>
          <target state="translated">에서 &lt;code&gt;entry.js&lt;/code&gt; 스크립트 :</target>
        </trans-unit>
        <trans-unit id="83ea6fb909458a63c93528b9278d2aea405239a1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.cc&lt;/code&gt;, implement the various methods that are to be exposed. Below, the method &lt;code&gt;plusOne()&lt;/code&gt; is exposed by adding it to the constructor's prototype:</source>
          <target state="translated">에서 &lt;code&gt;myobject.cc&lt;/code&gt; 노출 될 수있는 다양한 방법을 구현한다. 아래에서 &lt;code&gt;plusOne()&lt;/code&gt; 메소드 는 생성자의 프로토 타입에 추가하여 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="b569f0f01f808badd954c94c4b5ec2b3df4219a8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.h&lt;/code&gt;, a new public method is added to allow access to private values after unwrapping the object.</source>
          <target state="translated">에서는 &lt;code&gt;myobject.h&lt;/code&gt; 새로운 공용 방법은 대상물을 언 래핑 된 후 개인 값에 액세스 할 수 있도록 첨가된다.</target>
        </trans-unit>
        <trans-unit id="0bd614b7bbedcda99d367f704661d8a38b80d19b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.h&lt;/code&gt;, the static method &lt;code&gt;NewInstance()&lt;/code&gt; is added to handle instantiating the object. This method takes the place of using &lt;code&gt;new&lt;/code&gt; in JavaScript:</source>
          <target state="translated">에서는 &lt;code&gt;myobject.h&lt;/code&gt; 정적 메소드 &lt;code&gt;NewInstance()&lt;/code&gt; 객체를 인스턴스화하기 위해 추가 처리된다. 이 방법은 JavaScript에서 &lt;code&gt;new&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8b7f16901fb8e1d9d147d2658de11399ce8f4cc3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;recursive&lt;/code&gt; mode, the callback now receives the first created path as an argument.</source>
          <target state="translated">In &lt;code&gt;recursive&lt;/code&gt; mode, the callback now receives the first created path as an argument.</target>
        </trans-unit>
        <trans-unit id="5f7911bdacbc7cdb4fd6e24333b5a68b6b0e94c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;recursive&lt;/code&gt; mode, the first created path is returned now.</source>
          <target state="translated">In &lt;code&gt;recursive&lt;/code&gt; mode, the first created path is returned now.</target>
        </trans-unit>
        <trans-unit id="13a521caf867f14b672bcba06c835d82f3666953" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;strict&lt;/code&gt; mode, &lt;code&gt;assert&lt;/code&gt; functions use the comparison in the corresponding strict functions. For example, &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepEqual()&lt;/code&gt;&lt;/a&gt; will behave like &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepStrictEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;code&gt;strict&lt;/code&gt; 모드, &lt;code&gt;assert&lt;/code&gt; 기능은 해당 엄격한 기능의 비교를 사용합니다. 예를 들어 &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepEqual()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepStrictEqual()&lt;/code&gt; &lt;/a&gt; 과 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cbda2fb906abaf4d990f04c00aee85dda9e4e31b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;strict&lt;/code&gt; mode, error messages for objects display a diff. In legacy mode, error messages for objects display the objects, often truncated.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; 모드 에서는 객체의 오류 메시지에 차이가 표시됩니다. 레거시 모드에서 개체에 대한 오류 메시지는 종종 잘린 개체를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="43a752735db76822b3df812a4e23e21c8db8bd00" translate="yes" xml:space="preserve">
          <source>In HTTP/2, the request path, host name, protocol, and method are represented as special headers prefixed with the &lt;code&gt;:&lt;/code&gt; character (e.g. &lt;code&gt;':path'&lt;/code&gt;). These special headers will be included in the &lt;code&gt;request.headers&lt;/code&gt; object. Care must be taken not to inadvertently modify these special headers or errors may occur. For instance, removing all headers from the request will cause errors to occur:</source>
          <target state="translated">In HTTP/2, the request path, host name, protocol, and method are represented as special headers prefixed with the &lt;code&gt;:&lt;/code&gt; character (e.g. &lt;code&gt;':path'&lt;/code&gt; ). These special headers will be included in the &lt;code&gt;request.headers&lt;/code&gt; object. Care must be taken not to inadvertently modify these special headers or errors may occur. For instance, removing all headers from the request will cause errors to occur:</target>
        </trans-unit>
        <trans-unit id="1cedb49bba43339d6f4d8ab4643cc70bc8770d4d" translate="yes" xml:space="preserve">
          <source>In HTTP/2, the request path, hostname, protocol, and method are represented as special headers prefixed with the &lt;code&gt;:&lt;/code&gt; character (e.g. &lt;code&gt;':path'&lt;/code&gt;). These special headers will be included in the &lt;code&gt;request.headers&lt;/code&gt; object. Care must be taken not to inadvertently modify these special headers or errors may occur. For instance, removing all headers from the request will cause errors to occur:</source>
          <target state="translated">HTTP / 2에서 요청 경로, 호스트 이름, 프로토콜 및 메소드는 &lt;code&gt;:&lt;/code&gt; 문자 (예 : &lt;code&gt;':path'&lt;/code&gt; )로 시작하는 특수 헤더로 표시됩니다 . 이러한 특수 헤더는 &lt;code&gt;request.headers&lt;/code&gt; 객체에 포함됩니다 . 이러한 특수 헤더를 실수로 수정하지 않도록주의해야합니다. 그렇지 않으면 오류가 발생할 수 있습니다. 예를 들어 요청에서 모든 헤더를 제거하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2cd10f4ffa78b420a67631c95f5747ddf8e5371" translate="yes" xml:space="preserve">
          <source>In Node.js 0.10, the &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; class was added. For backward compatibility with older Node.js programs, &lt;code&gt;Readable&lt;/code&gt; streams switch into &quot;flowing mode&quot; when a &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; event handler is added, or when the &lt;a href=&quot;#stream_readable_resume&quot;&gt;&lt;code&gt;stream.resume()&lt;/code&gt;&lt;/a&gt; method is called. The effect is that, even when not using the new &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; method and &lt;a href=&quot;#stream_event_readable&quot;&gt;&lt;code&gt;'readable'&lt;/code&gt;&lt;/a&gt; event, it is no longer necessary to worry about losing &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; chunks.</source>
          <target state="translated">Node.js 0.10에서 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 클래스가 추가되었습니다. 이전 Node.js 프로그램과의 호환성을 위해 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러가 추가되거나 &lt;a href=&quot;#stream_readable_resume&quot;&gt; &lt;code&gt;stream.resume()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때 &lt;code&gt;Readable&lt;/code&gt; 스트림이 &quot;흐르는 모드&quot;로 전환됩니다 . 결과적으로 새로운 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 메소드와 &lt;a href=&quot;#stream_event_readable&quot;&gt; &lt;code&gt;'readable'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용하지 않더라도 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 청크 손실에 대해 더 이상 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6ec913d843e5ce0486a69aa4f80f551326e2892c" translate="yes" xml:space="preserve">
          <source>In Node.js versions prior to v15.0.0, the error code being used here was &lt;a href=&quot;#ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST&quot;&gt;&lt;code&gt;ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST&lt;/code&gt;&lt;/a&gt;. However, the set of transferable object types has been expanded to cover more types than &lt;code&gt;MessagePort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2907f0887fd67060d1c8b859ffab65821bd5c8a" translate="yes" xml:space="preserve">
          <source>In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8. You must explicitly specify the context in which you want any JavaScript code to be run.</source>
          <target state="translated">V8에서 컨텍스트는 별도의 관련되지 않은 JavaScript 애플리케이션이 단일 V8 인스턴스에서 실행될 수있는 실행 환경입니다. JavaScript 코드를 실행할 컨텍스트를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3d8bc4ddec331ca5a88314794e8687bdb713403" translate="yes" xml:space="preserve">
          <source>In a package&amp;rsquo;s &lt;code&gt;package.json&lt;/code&gt; file, two fields can define entry points for a package: &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#packages_main&quot;&gt;&lt;code&gt;&quot;main&quot;&lt;/code&gt;&lt;/a&gt; field is supported in all versions of Node.js, but its capabilities are limited: it only defines the main entry point of the package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f608ecc99c06cfa50baaffc2c3cd8fff338f4fc" translate="yes" xml:space="preserve">
          <source>In a successful request, the following events will be emitted in the following order:</source>
          <target state="translated">요청이 성공하면 다음과 같은 순서로 다음 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf790810b2507f884c03af267a9c95a2dbc7ba26" translate="yes" xml:space="preserve">
          <source>In a worker this sends a message to the master. It is identical to &lt;code&gt;process.send()&lt;/code&gt;.</source>
          <target state="translated">작업자는 마스터에게 메시지를 보냅니다. &lt;code&gt;process.send()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="89f9cefb5509de84f4d3b8e9ae50db89a7da0b91" translate="yes" xml:space="preserve">
          <source>In a worker, &lt;code&gt;process.disconnect&lt;/code&gt; exists, but it is not this function; it is &lt;a href=&quot;child_process#child_process_subprocess_disconnect&quot;&gt;&lt;code&gt;disconnect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자에게는 &lt;code&gt;process.disconnect&lt;/code&gt; 가 존재하지만이 기능은 아닙니다. 그것은 &lt;a href=&quot;child_process#child_process_subprocess_disconnect&quot;&gt; &lt;code&gt;disconnect()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6635bab64752609670a0d11b7b0ac6ba30c036b1" translate="yes" xml:space="preserve">
          <source>In a worker, &lt;code&gt;process.kill()&lt;/code&gt; exists, but it is not this function; it is &lt;a href=&quot;process#process_process_kill_pid_signal&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자에는 &lt;code&gt;process.kill()&lt;/code&gt; 이 있지만이 함수는 아닙니다. 그것이 &lt;a href=&quot;process#process_process_kill_pid_signal&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="188dc51b267f1ce409fcd61f18bf1777940cfa1c" translate="yes" xml:space="preserve">
          <source>In a worker, this function will close all servers, wait for the &lt;code&gt;'close'&lt;/code&gt; event on those servers, and then disconnect the IPC channel.</source>
          <target state="translated">작업자의 경우이 기능은 모든 서버를 &lt;code&gt;'close'&lt;/code&gt; 해당 서버 에서 '닫기' 이벤트를 기다린 다음 IPC 채널의 연결을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="c45585efffb25f706fc168893be3eee9fb3732c3" translate="yes" xml:space="preserve">
          <source>In accordance with browser conventions, all properties of &lt;code&gt;URL&lt;/code&gt; objects are implemented as getters and setters on the class prototype, rather than as data properties on the object itself. Thus, unlike &lt;a href=&quot;#url_legacy_urlobject&quot;&gt;legacy &lt;code&gt;urlObject&lt;/code&gt;&lt;/a&gt;s, using the &lt;code&gt;delete&lt;/code&gt; keyword on any properties of &lt;code&gt;URL&lt;/code&gt; objects (e.g. &lt;code&gt;delete myURL.protocol&lt;/code&gt;, &lt;code&gt;delete myURL.pathname&lt;/code&gt;, etc) has no effect but will still return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">브라우저 규칙에 따라 &lt;code&gt;URL&lt;/code&gt; 객체 의 모든 속성은 객체 자체의 데이터 속성이 아니라 클래스 프로토 타입에서 getter 및 setter로 구현됩니다. 따라서 &lt;a href=&quot;#url_legacy_urlobject&quot;&gt;레거시 &lt;code&gt;urlObject&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;URL&lt;/code&gt; 객체의 속성에 &lt;code&gt;delete&lt;/code&gt; 키워드를 사용하면 (예 : &lt;code&gt;delete myURL.protocol&lt;/code&gt; , &lt;code&gt;delete myURL.pathname&lt;/code&gt; 등) 아무런 영향이 없지만 여전히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7734f0b3567b3c7b9193631a31766ec4ead09b" translate="yes" xml:space="preserve">
          <source>In addition to being accessible through &lt;code&gt;util.inspect.custom&lt;/code&gt;, this symbol is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;registered globally&lt;/a&gt; and can be accessed in any environment as &lt;code&gt;Symbol.for('nodejs.util.inspect.custom')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;util.inspect.custom&lt;/code&gt; 을 통해 액세스 할 수있을뿐만 &lt;code&gt;Symbol.for('nodejs.util.inspect.custom')&lt;/code&gt; 기호는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;전체적으로 등록&lt;/a&gt; 되며 모든 환경에서 Symbol.for ( 'nodejs.util.inspect.custom') 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb42d431dbb8dd60cb5da5552ac7c99e0c05dcb2" translate="yes" xml:space="preserve">
          <source>In addition to being accessible through &lt;code&gt;util.promisify.custom&lt;/code&gt;, this symbol is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;registered globally&lt;/a&gt; and can be accessed in any environment as &lt;code&gt;Symbol.for('nodejs.util.promisify.custom')&lt;/code&gt;.</source>
          <target state="translated">In addition to being accessible through &lt;code&gt;util.promisify.custom&lt;/code&gt; , this symbol is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;registered globally&lt;/a&gt; and can be accessed in any environment as &lt;code&gt;Symbol.for('nodejs.util.promisify.custom')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a017a14a50b8af7f35bbfe35a7128002e7b0433" translate="yes" xml:space="preserve">
          <source>In addition to defining an alias, subpaths not defined by &lt;code&gt;&quot;exports&quot;&lt;/code&gt; will throw when an attempt is made to import them:</source>
          <target state="translated">별명을 정의하는 것 외에도, &lt;code&gt;&quot;exports&quot;&lt;/code&gt; 에 의해 정의되지 않은 서브 패스 는 그것들을 가져 오려고 시도 할 때 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="ec37922ca0e62e70ed6bb763b482389137379290" translate="yes" xml:space="preserve">
          <source>In addition to direct mappings, Node.js also supports nested condition objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87788a1c64b835765d4d327b936fd17de0ba8095" translate="yes" xml:space="preserve">
          <source>In addition to new &lt;code&gt;Readable&lt;/code&gt; streams switching into flowing mode, pre-0.10 style streams can be wrapped in a &lt;code&gt;Readable&lt;/code&gt; class using the &lt;a href=&quot;#stream_readable_wrap_stream&quot;&gt;&lt;code&gt;readable.wrap()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유동 모드로 전환되는 새로운 &lt;code&gt;Readable&lt;/code&gt; 스트림 외에도 , 10.10 이전 스타일의 스트림은 &lt;a href=&quot;#stream_readable_wrap_stream&quot;&gt; &lt;code&gt;readable.wrap()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;Readable&lt;/code&gt; 클래스 로 래핑 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="531fe4364b08e0a91d004f6c008a9907fd321d5e" translate="yes" xml:space="preserve">
          <source>In addition to returning the resolved file URL value, the resolve hook also returns a &lt;code&gt;format&lt;/code&gt; property specifying the module format of the resolved module. This can be one of the following:</source>
          <target state="translated">확인 된 파일 URL 값을 반환하는 것 외에도 확인 후크는 확인 된 모듈의 모듈 형식을 지정 하는 &lt;code&gt;format&lt;/code&gt; 속성 도 반환 합니다. 이것은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9073ec95fdd950b7d180fdae1aaadb4dc002b4" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field, it is possible to define internal package import maps that only apply to import specifiers from within the package itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b72f820929e77bac018c0ca5b3cc4d77951c0c" translate="yes" xml:space="preserve">
          <source>In addition to wrapping and returning C++ objects, it is possible to pass wrapped objects around by unwrapping them with the Node.js helper function &lt;code&gt;node::ObjectWrap::Unwrap&lt;/code&gt;. The following examples shows a function &lt;code&gt;add()&lt;/code&gt; that can take two &lt;code&gt;MyObject&lt;/code&gt; objects as input arguments:</source>
          <target state="translated">C ++ 객체를 래핑하고 반환하는 것 외에도 Node.js 도우미 함수 &lt;code&gt;node::ObjectWrap::Unwrap&lt;/code&gt; 으로 래핑하여 래핑 된 객체를 전달할 수 있습니다 . 다음 예제는 두 개의 &lt;code&gt;MyObject&lt;/code&gt; 객체를 입력 인수로 사용할 수있는 &lt;code&gt;add()&lt;/code&gt; 함수를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3250b3c9156a53b11995d8b61bc7651346b38dd6" translate="yes" xml:space="preserve">
          <source>In an earlier version of the Node.js &lt;code&gt;cluster&lt;/code&gt;, a boolean property with the name &lt;code&gt;suicide&lt;/code&gt; was added to the &lt;code&gt;Worker&lt;/code&gt; object. The intent of this property was to provide an indication of how and why the &lt;code&gt;Worker&lt;/code&gt; instance exited. In Node.js 6.0.0, the old property was deprecated and replaced with a new &lt;a href=&quot;cluster#cluster_worker_exitedafterdisconnect&quot;&gt;&lt;code&gt;worker.exitedAfterDisconnect&lt;/code&gt;&lt;/a&gt; property. The old property name did not precisely describe the actual semantics and was unnecessarily emotion-laden.</source>
          <target state="translated">Node.js &lt;code&gt;cluster&lt;/code&gt; 의 이전 버전 에서는 이름이 &lt;code&gt;suicide&lt;/code&gt; 부울 속성 이 &lt;code&gt;Worker&lt;/code&gt; 객체 에 추가되었습니다 . 이 특성의 목적은 &lt;code&gt;Worker&lt;/code&gt; 인스턴스가 어떻게, 왜 종료 했는지 표시하는 것입니다 . Node.js 6.0.0에서는 이전 속성이 더 이상 사용되지 않고 새로운 &lt;a href=&quot;cluster#cluster_worker_exitedafterdisconnect&quot;&gt; &lt;code&gt;worker.exitedAfterDisconnect&lt;/code&gt; &lt;/a&gt; 속성으로 대체되었습니다 . 오래된 속성 이름은 실제 의미를 정확하게 설명하지 않았으며 불필요하게 감정이 가득했습니다.</target>
        </trans-unit>
        <trans-unit id="45f34b6c8dddeb170b4ea2c2a91a4f0f3bf29b30" translate="yes" xml:space="preserve">
          <source>In asynchronous code, the &lt;code&gt;'unhandledRejection'&lt;/code&gt; event is emitted when the list of unhandled rejections grows, and the &lt;code&gt;'rejectionHandled'&lt;/code&gt; event is emitted when the list of unhandled rejections shrinks.</source>
          <target state="translated">비동기 코드에서 처리되지 않은 거부 목록이 커지면 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트가 생성되고 처리되지 않은 거부 목록이 줄어들 면 &lt;code&gt;'rejectionHandled'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="30fe6e0dbb3ad0e70ec0d1b125ead1922456d17e" translate="yes" xml:space="preserve">
          <source>In browsers, the top-level scope is the global scope. This means that within the browser &lt;code&gt;var something&lt;/code&gt; will define a new global variable. In Node.js this is different. The top-level scope is not the global scope; &lt;code&gt;var something&lt;/code&gt; inside a Node.js module will be local to that module.</source>
          <target state="translated">브라우저에서 최상위 범위는 전역 범위입니다. 이것은 브라우저 &lt;code&gt;var something&lt;/code&gt; 내에서 새로운 전역 변수를 정의 한다는 것을 의미 합니다. Node.js에서 이것은 다릅니다. 최상위 범위는 전역 범위가 아닙니다. Node.js 모듈 내부의 &lt;code&gt;var something&lt;/code&gt; 는 해당 모듈에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="6d0d858774c88480d91a106fadc1779bc8dd52cc" translate="yes" xml:space="preserve">
          <source>In busy processes, use the asynchronous versions of these calls. The synchronous versions will block the entire process until they complete, halting all connections.</source>
          <target state="translated">사용중인 프로세스에서는 이러한 호출의 비동기 버전을 사용하십시오. 동기식 버전은 완료 될 때까지 전체 프로세스를 차단하여 모든 연결을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="a6dde02e444feeff7342a6c14a7993d14efd44e6" translate="yes" xml:space="preserve">
          <source>In case an option value happens to contain a space (for example a path listed in &lt;code&gt;--require&lt;/code&gt;), it must be escaped using double quotes. For example:</source>
          <target state="translated">옵션 값에 공백이 포함 된 경우 (예 : &lt;code&gt;--require&lt;/code&gt; 에 나열된 경로 ) 큰 따옴표를 사용하여 이스케이프해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15c9b09b7cd71bda560724b30fa35f7d291b25b6" translate="yes" xml:space="preserve">
          <source>In case if &lt;code&gt;callback&lt;/code&gt; is not a function, a new &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; error will be thrown.</source>
          <target state="translated">In case if &lt;code&gt;callback&lt;/code&gt; is not a function, a new &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; error will be thrown.</target>
        </trans-unit>
        <trans-unit id="a549d05af2ccfc0ca015a5a981e3076d4f98a52b" translate="yes" xml:space="preserve">
          <source>In case of an error status code, additional information can be obtained using &lt;code&gt;napi_get_last_error_info&lt;/code&gt;. More information can be found in the error handling section &lt;a href=&quot;#n_api_error_handling&quot;&gt;Error Handling&lt;/a&gt;.</source>
          <target state="translated">오류 상태 코드의 경우 &lt;code&gt;napi_get_last_error_info&lt;/code&gt; 를 사용하여 추가 정보를 얻을 수 있습니다 . 자세한 정보는 오류 처리 섹션에서 찾을 수 있습니다 &lt;a href=&quot;#n_api_error_handling&quot;&gt;오류 처리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9788bf70d68a70d51e5e80b5a843e841d7c07e6d" translate="yes" xml:space="preserve">
          <source>In case of an error status code, additional information can be obtained using &lt;code&gt;napi_get_last_error_info&lt;/code&gt;. More information can be found in the error handling section &lt;a href=&quot;#n_api_error_handling&quot;&gt;Error handling&lt;/a&gt;.</source>
          <target state="translated">In case of an error status code, additional information can be obtained using &lt;code&gt;napi_get_last_error_info&lt;/code&gt; . More information can be found in the error handling section &lt;a href=&quot;#n_api_error_handling&quot;&gt;Error handling&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="60a7a3354fb49e4ea54bdc9ce39be38347f08d3e" translate="yes" xml:space="preserve">
          <source>In case of an error, the &lt;code&gt;err.code&lt;/code&gt; will be one of &lt;a href=&quot;errors#errors_common_system_errors&quot;&gt;Common System Errors&lt;/a&gt;.</source>
          <target state="translated">오류가 발생한 경우 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_common_system_errors&quot;&gt;공통 시스템 오류&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="83638801ee92420c039136960543463b06296385" translate="yes" xml:space="preserve">
          <source>In case of inactivity, the rules defined in &lt;a href=&quot;#http_server_timeout&quot;&gt;&lt;code&gt;server.timeout&lt;/code&gt;&lt;/a&gt; apply. However, that inactivity based timeout would still allow the connection to be kept open if the headers are being sent very slowly (by default, up to a byte per 2 minutes). In order to prevent this, whenever header data arrives an additional check is made that more than &lt;code&gt;server.headersTimeout&lt;/code&gt; milliseconds has not passed since the connection was established. If the check fails, a &lt;code&gt;'timeout'&lt;/code&gt; event is emitted on the server object, and (by default) the socket is destroyed. See &lt;a href=&quot;#http_server_timeout&quot;&gt;&lt;code&gt;server.timeout&lt;/code&gt;&lt;/a&gt; for more information on how timeout behavior can be customized.</source>
          <target state="translated">비활성 상태 인 경우 &lt;a href=&quot;#http_server_timeout&quot;&gt; &lt;code&gt;server.timeout&lt;/code&gt; 에&lt;/a&gt; 정의 된 규칙이 적용됩니다. 그러나 비 활동 기반 시간 초과는 헤더가 매우 느리게 전송되는 경우 (기본적으로 최대 2 분당 바이트) 연결을 계속 열어 둘 수 있습니다. 이를 방지하기 위해 헤더 데이터가 도착할 때마다 연결이 설정된 후 &lt;code&gt;server.headersTimeout&lt;/code&gt; 밀리 초 이상이 지나지 않았는지 추가 확인이 이루어집니다 . 확인에 실패하면 서버 개체에서 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트가 생성되고 기본적으로 소켓이 손상됩니다. 시간 초과 동작을 사용자 지정할 수있는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#http_server_timeout&quot;&gt; &lt;code&gt;server.timeout&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fe24f759353e3c9ef13728cf5d98486ed424be5" translate="yes" xml:space="preserve">
          <source>In case of no callback function were assigned, a new &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; error will be thrown.</source>
          <target state="translated">콜백 함수가 할당되지 않은 경우 새로운 &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6d18d7e0676cf5071ee5c355fa6cde45cfbf4f6" translate="yes" xml:space="preserve">
          <source>In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either &lt;code&gt;'1.1'&lt;/code&gt; or &lt;code&gt;'1.0'&lt;/code&gt;.</source>
          <target state="translated">서버 요청의 경우 클라이언트가 보낸 HTTP 버전입니다. 클라이언트 응답의 경우 연결된 서버의 HTTP 버전입니다. 아마도 &lt;code&gt;'1.1'&lt;/code&gt; 또는 &lt;code&gt;'1.0'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="288453ee826f1533d87079e6da5e8a9939a1c3c7" translate="yes" xml:space="preserve">
          <source>In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Returns &lt;code&gt;'2.0'&lt;/code&gt;.</source>
          <target state="translated">서버 요청의 경우 클라이언트가 보낸 HTTP 버전입니다. 클라이언트 응답의 경우 연결된 서버의 HTTP 버전입니다. &lt;code&gt;'2.0'&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8a083755276d9eeea7f1c7589a28aafc0f42f80d" translate="yes" xml:space="preserve">
          <source>In cases where a return value other than &lt;code&gt;napi_ok&lt;/code&gt; or &lt;code&gt;napi_pending_exception&lt;/code&gt; is returned, &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt;&lt;code&gt;napi_is_exception_pending&lt;/code&gt;&lt;/a&gt; must be called to check if an exception is pending. See the section on exceptions for more details.</source>
          <target state="translated">&lt;code&gt;napi_ok&lt;/code&gt; 또는 &lt;code&gt;napi_pending_exception&lt;/code&gt; 이외의 반환 값 이 반환 되는 경우 예외가 보류 중인지 확인하기 위해 &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt; &lt;code&gt;napi_is_exception_pending&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다. 자세한 내용은 예외에 관한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3352c4c1cafe79135726b64a02a391ead0f41a7a" translate="yes" xml:space="preserve">
          <source>In cases where it is not known in advance if &lt;code&gt;input&lt;/code&gt; is an absolute URL and a &lt;code&gt;base&lt;/code&gt; is provided, it is advised to validate that the &lt;code&gt;origin&lt;/code&gt; of the &lt;code&gt;URL&lt;/code&gt; object is what is expected.</source>
          <target state="translated">경우 사전에 공지되지 않은 경우에 &lt;code&gt;input&lt;/code&gt; 절대 URL 인 및 &lt;code&gt;base&lt;/code&gt; 제공되는데, 확인하는 것이 권장 &lt;code&gt;origin&lt;/code&gt; 의 &lt;code&gt;URL&lt;/code&gt; 의 개체가 예상되는 어떤.</target>
        </trans-unit>
        <trans-unit id="64ee0f45e9598117687157f2af97b1b0166cabde" translate="yes" xml:space="preserve">
          <source>In cases where there is more than one &lt;code&gt;.cc&lt;/code&gt; file, simply add the additional filename to the &lt;code&gt;sources&lt;/code&gt; array:</source>
          <target state="translated">&lt;code&gt;.cc&lt;/code&gt; 파일 이 둘 이상인 경우 추가 파일 이름을 &lt;code&gt;sources&lt;/code&gt; 배열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a54ba662593323ae67f27f49552b1bb4dbd0fd34" translate="yes" xml:space="preserve">
          <source>In certain cases, &lt;code&gt;require('.')&lt;/code&gt; could resolve outside the package directory. This behavior has been removed.</source>
          <target state="translated">어떤 경우에는 &lt;code&gt;require('.')&lt;/code&gt; 가 패키지 디렉토리 외부에서 분석 될 수 있습니다. 이 동작은 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="6bf7779b67ab0aad41f5916dd6b3a65b83dcba67" translate="yes" xml:space="preserve">
          <source>In contrast, the following example turns off the default warning output and adds a custom handler to the &lt;code&gt;'warning'&lt;/code&gt; event:</source>
          <target state="translated">반대로, 다음 예제는 기본 경고 출력을 끄고 &lt;code&gt;'warning'&lt;/code&gt; 이벤트에 사용자 정의 핸들러를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="34bc31b96f714b0e14d2f04bc73e790c177f0030" translate="yes" xml:space="preserve">
          <source>In cryptography, &quot;wrapping a key&quot; refers to exporting and then encrypting the keying material. The &lt;code&gt;subtle.unwrapKey()&lt;/code&gt; method attempts to decrypt a wrapped key and create a &lt;a href=&quot;webcrypto#webcrypto_class_cryptokey&quot;&gt;&amp;lt;CryptoKey&amp;gt;&lt;/a&gt; instance. It is equivalent to calling &lt;code&gt;subtle.decrypt()&lt;/code&gt; first on the encrypted key data (using the &lt;code&gt;wrappedKey&lt;/code&gt;, &lt;code&gt;unwrapAlgo&lt;/code&gt;, and &lt;code&gt;unwrappingKey&lt;/code&gt; arguments as input) then passing the results in to the &lt;code&gt;subtle.importKey()&lt;/code&gt; method using the &lt;code&gt;unwrappedKeyAlgo&lt;/code&gt;, &lt;code&gt;extractable&lt;/code&gt;, and &lt;code&gt;keyUsages&lt;/code&gt; arguments as inputs. If successful, the returned promise is resolved with a &lt;a href=&quot;webcrypto#webcrypto_class_cryptokey&quot;&gt;&amp;lt;CryptoKey&amp;gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f0907a39eb8eb75ec80d3428fd907be73a4a3d" translate="yes" xml:space="preserve">
          <source>In cryptography, &quot;wrapping a key&quot; refers to exporting and then encrypting the keying material. The &lt;code&gt;subtle.wrapKey()&lt;/code&gt; method exports the keying material into the format identified by &lt;code&gt;format&lt;/code&gt;, then encrypts it using the method and parameters specified by &lt;code&gt;wrapAlgo&lt;/code&gt; and the keying material provided by &lt;code&gt;wrappingKey&lt;/code&gt;. It is the equivalent to calling &lt;code&gt;subtle.exportKey()&lt;/code&gt; using &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as the arguments, then passing the result to the &lt;code&gt;subtle.encrypt()&lt;/code&gt; method using &lt;code&gt;wrappingKey&lt;/code&gt; and &lt;code&gt;wrapAlgo&lt;/code&gt; as inputs. If successful, the returned promise will be resolved with an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer&quot;&gt;&amp;lt;ArrayBuffer&amp;gt;&lt;/a&gt; containing the encrypted key data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd982c8835710e676f97498aa2a426f67aae0d05" translate="yes" xml:space="preserve">
          <source>In current Node.js, specifiers starting with &lt;code&gt;https://&lt;/code&gt; are unsupported. The loader below registers hooks to enable rudimentary support for such specifiers. While this may seem like a significant improvement to Node.js core functionality, there are substantial downsides to actually using this loader: performance is much slower than loading files from disk, there is no caching, and there is no security.</source>
          <target state="translated">In current Node.js, specifiers starting with &lt;code&gt;https://&lt;/code&gt; are unsupported. The loader below registers hooks to enable rudimentary support for such specifiers. While this may seem like a significant improvement to Node.js core functionality, there are substantial downsides to actually using this loader: performance is much slower than loading files from disk, there is no caching, and there is no security.</target>
        </trans-unit>
        <trans-unit id="bd3587bc97949af37236db6b9a0a1d14eae323d5" translate="yes" xml:space="preserve">
          <source>In custom builds from non-release versions of the source tree, only the &lt;code&gt;name&lt;/code&gt; property may be present. The additional properties should not be relied upon to exist.</source>
          <target state="translated">릴리스되지 않은 소스 트리 버전의 사용자 정의 빌드에는 &lt;code&gt;name&lt;/code&gt; 특성 만 존재할 수 있습니다. 추가 특성이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="327449f48d0f91fc55b3b3b7eb5d0b9b76cc0b33" translate="yes" xml:space="preserve">
          <source>In each module, the &lt;code&gt;module&lt;/code&gt; free variable is a reference to the object representing the current module. For convenience, &lt;code&gt;module.exports&lt;/code&gt; is also accessible via the &lt;code&gt;exports&lt;/code&gt; module-global. &lt;code&gt;module&lt;/code&gt; is not actually a global but rather local to each module.</source>
          <target state="translated">각 모듈에서 &lt;code&gt;module&lt;/code&gt; 자유 변수는 현재 모듈을 나타내는 객체에 대한 참조입니다. 편의를 위해, &lt;code&gt;module.exports&lt;/code&gt; 은 또한을 통해 액세스 &lt;code&gt;exports&lt;/code&gt; 모듈 - 글로벌. &lt;code&gt;module&lt;/code&gt; 은 실제로는 전역이 아니라 각 모듈에 대해 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="37db4cd4b343ff7b0d4d0a02ce9acc6d525c6d68" translate="yes" xml:space="preserve">
          <source>In each of the previous examples, an &lt;code&gt;Error&lt;/code&gt; object is generated internally by &lt;code&gt;process.emitWarning()&lt;/code&gt; and passed through to the &lt;a href=&quot;#process_event_warning&quot;&gt;&lt;code&gt;'warning'&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이전의 각 예에서 &lt;code&gt;Error&lt;/code&gt; 객체는 &lt;code&gt;process.emitWarning()&lt;/code&gt; 의해 내부적으로 생성 되어 &lt;a href=&quot;#process_event_warning&quot;&gt; &lt;code&gt;'warning'&lt;/code&gt; &lt;/a&gt; 처리기로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="820400607edfb4a60ac510c205956515ea9fa75c" translate="yes" xml:space="preserve">
          <source>In either case, the handler function is invoked with the &lt;code&gt;event&lt;/code&gt; argument passed to the &lt;code&gt;eventTarget.dispatchEvent()&lt;/code&gt; function.</source>
          <target state="translated">In either case, the handler function is invoked with the &lt;code&gt;event&lt;/code&gt; argument passed to the &lt;code&gt;eventTarget.dispatchEvent()&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="6707c880c79f3eb01db7774cdf36344d80a74bb4" translate="yes" xml:space="preserve">
          <source>In flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the &lt;a href=&quot;events#events_class_eventemitter&quot;&gt;&lt;code&gt;EventEmitter&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">유동 모드에서는 기본 시스템에서 데이터를 자동으로 읽고 &lt;a href=&quot;events#events_class_eventemitter&quot;&gt; &lt;code&gt;EventEmitter&lt;/code&gt; &lt;/a&gt; 인터페이스 를 통해 이벤트를 사용하여 가능한 한 빨리 응용 프로그램에 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ae82f246808400841098c679191185dab7d9015c" translate="yes" xml:space="preserve">
          <source>In future versions of Node.js, &lt;code&gt;fs.rmdir(path, { recursive: true })&lt;/code&gt; will throw if &lt;code&gt;path&lt;/code&gt; does not exist or is a file. Use &lt;code&gt;fs.rm(path, { recursive: true, force: true })&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409446af31735d46729e6eb84ac5244d78721628" translate="yes" xml:space="preserve">
          <source>In future versions of Node.js, &lt;code&gt;fs.rmdir(path, { recursive: true })&lt;/code&gt; will throw on nonexistent paths, or when given a file as a target. Use &lt;code&gt;fs.rm(path, { recursive: true, force: true })&lt;/code&gt; instead.</source>
          <target state="translated">In future versions of Node.js, &lt;code&gt;fs.rmdir(path, { recursive: true })&lt;/code&gt; will throw on nonexistent paths, or when given a file as a target. Use &lt;code&gt;fs.rm(path, { recursive: true, force: true })&lt;/code&gt; instead.</target>
        </trans-unit>
        <trans-unit id="dd353fe48ae2599b92caa0441615c03958d5543e" translate="yes" xml:space="preserve">
          <source>In general, check for the accessibility of a file only if the file will not be used directly, for example when its accessibility is a signal from another process.</source>
          <target state="translated">일반적으로 액세스 가능성이 다른 프로세스의 신호 인 경우와 같이 파일을 직접 사용하지 않는 경우에만 파일의 액세스 가능성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="087f71387196c21047e8de00ada98ef5f02eb85e" translate="yes" xml:space="preserve">
          <source>In general, check for the existence of a file only if the file won&amp;rsquo;t be used directly, for example when its existence is a signal from another process.</source>
          <target state="translated">일반적으로 파일이 존재하지 않는 경우 (예 : 다른 프로세스의 신호 인 경우)에만 파일이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0780a6d7f3a8d6f30bfe170e7ebcad79382accb5" translate="yes" xml:space="preserve">
          <source>In general, greater memory usage options will mean that Node.js has to make fewer calls to &lt;code&gt;zlib&lt;/code&gt; because it will be able to process more data on each &lt;code&gt;write&lt;/code&gt; operation. So, this is another factor that affects the speed, at the cost of memory usage.</source>
          <target state="translated">일반적으로 메모리 사용량이 많을수록 Node.js는 각 &lt;code&gt;write&lt;/code&gt; 작업 에서 더 많은 데이터를 처리 할 수 ​​있기 때문에 &lt;code&gt;zlib&lt;/code&gt; 를 더 적게 호출해야 합니다. 따라서 이것은 메모리 사용 비용으로 속도에 영향을 미치는 또 다른 요소입니다.</target>
        </trans-unit>
        <trans-unit id="45a19be887817fbe3d3f39ecc27f73a30b8611a2" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;readable.pipe()&lt;/code&gt; and &lt;code&gt;'data'&lt;/code&gt; event mechanisms are easier to understand than the &lt;code&gt;'readable'&lt;/code&gt; event. However, handling &lt;code&gt;'readable'&lt;/code&gt; might result in increased throughput.</source>
          <target state="translated">일반적으로 &lt;code&gt;readable.pipe()&lt;/code&gt; 및 &lt;code&gt;'data'&lt;/code&gt; 이벤트 메커니즘은 &lt;code&gt;'readable'&lt;/code&gt; 이벤트 보다 이해하기 쉽습니다 . 그러나 &lt;code&gt;'readable'&lt;/code&gt; 처리 하면 처리량이 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29f7ea80cfdc8edcce7cf9808c9e14cd5f2e801" translate="yes" xml:space="preserve">
          <source>In line with OpenSSL's recommendation to use a more modern algorithm instead of &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt;&lt;code&gt;EVP_BytesToKey&lt;/code&gt;&lt;/a&gt; it is recommended that developers derive a key and IV on their own using &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt;&lt;code&gt;crypto.scrypt()&lt;/code&gt;&lt;/a&gt; and to use &lt;a href=&quot;#crypto_crypto_createcipheriv_algorithm_key_iv_options&quot;&gt;&lt;code&gt;crypto.createCipheriv()&lt;/code&gt;&lt;/a&gt; to create the &lt;code&gt;Cipher&lt;/code&gt; object. Users should not use ciphers with counter mode (e.g. CTR, GCM, or CCM) in &lt;code&gt;crypto.createCipher()&lt;/code&gt;. A warning is emitted when they are used in order to avoid the risk of IV reuse that causes vulnerabilities. For the case when IV is reused in GCM, see &lt;a href=&quot;https://github.com/nonce-disrespect/nonce-disrespect&quot;&gt;Nonce-Disrespecting Adversaries&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt; &lt;code&gt;EVP_BytesToKey&lt;/code&gt; &lt;/a&gt; 대신 최신 알고리즘을 사용하는 OpenSSL의 권장 사항에 따라 개발자는 &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt; &lt;code&gt;crypto.scrypt()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자체적으로 키와 IV를 파생시키고 &lt;a href=&quot;#crypto_crypto_createcipheriv_algorithm_key_iv_options&quot;&gt; &lt;code&gt;crypto.createCipheriv()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Cipher&lt;/code&gt; 오브젝트 를 작성하는 것이 좋습니다. 사용자는 &lt;code&gt;crypto.createCipher()&lt;/code&gt; 에서 카운터 모드 (예 : CTR, GCM 또는 CCM)를 가진 암호를 사용하지 않아야합니다 . 취약점을 유발하는 IV 재사용의 위험을 피하기 위해 사용될 때 경고가 발생합니다. IV가 GCM에서 재사용되는 경우 &lt;a href=&quot;https://github.com/nonce-disrespect/nonce-disrespect&quot;&gt;Nonce-Disrespecting Adversaries&lt;/a&gt; 에서 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4427809c2da46e37a477a14b3a6dae947f069aba" translate="yes" xml:space="preserve">
          <source>In line with OpenSSL's recommendation to use a more modern algorithm instead of &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt;&lt;code&gt;EVP_BytesToKey&lt;/code&gt;&lt;/a&gt; it is recommended that developers derive a key and IV on their own using &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt;&lt;code&gt;crypto.scrypt()&lt;/code&gt;&lt;/a&gt; and to use &lt;a href=&quot;#crypto_crypto_createdecipheriv_algorithm_key_iv_options&quot;&gt;&lt;code&gt;crypto.createDecipheriv()&lt;/code&gt;&lt;/a&gt; to create the &lt;code&gt;Decipher&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt; &lt;code&gt;EVP_BytesToKey&lt;/code&gt; &lt;/a&gt; 대신 최신 알고리즘을 사용하는 OpenSSL의 권장 사항에 따라 개발자는 &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt; &lt;code&gt;crypto.scrypt()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자체적으로 키와 IV를 파생하고 &lt;a href=&quot;#crypto_crypto_createdecipheriv_algorithm_key_iv_options&quot;&gt; &lt;code&gt;crypto.createDecipheriv()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Decipher&lt;/code&gt; 객체 를 생성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f16244b364da53115174b4fd4f6aa18f7d9fb44a" translate="yes" xml:space="preserve">
          <source>In many cases when an N-API function is called and an exception is already pending, the function will return immediately with a &lt;code&gt;napi_status&lt;/code&gt; of &lt;code&gt;napi_pending_exception&lt;/code&gt;. However, this is not the case for all functions. N-API allows a subset of the functions to be called to allow for some minimal cleanup before returning to JavaScript. In that case, &lt;code&gt;napi_status&lt;/code&gt; will reflect the status for the function. It will not reflect previous pending exceptions. To avoid confusion, check the error status after every function call.</source>
          <target state="translated">대부분의 경우는 N-API 함수가 호출되고 예외가 이미 함수가 즉시 반환합니다 중일 때는 &lt;code&gt;napi_status&lt;/code&gt; 의 &lt;code&gt;napi_pending_exception&lt;/code&gt; . 그러나 이것이 모든 기능에 해당되는 것은 아닙니다. N-API를 사용하면 JavaScript로 돌아 가기 전에 최소한의 정리를 수행 할 수 있도록 함수의 서브 세트를 호출 할 수 있습니다. 이 경우 &lt;code&gt;napi_status&lt;/code&gt; 는 함수의 상태를 반영합니다. 이전에 보류중인 예외는 반영하지 않습니다. 혼동을 피하기 위해 모든 함수 호출 후 오류 상태를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4d4aeb489e9e86e74a64fc02a38fd7bd2ebbd390" translate="yes" xml:space="preserve">
          <source>In many cases, however, it is necessary that the handles remain valid for either a shorter or longer lifespan than that of the native method. The sections which follow describe the N-API functions that can be used to change the handle lifespan from the default.</source>
          <target state="translated">그러나 대부분의 경우 핸들이 기본 메소드보다 짧거나 더 긴 수명 동안 유효해야합니다. 다음 섹션에서는 핸들 수명을 기본값에서 변경하는 데 사용할 수있는 N-API 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4b34bf1445c109117747980b5d96ac739f8c0f64" translate="yes" xml:space="preserve">
          <source>In most cases your application or library code should have no issues with &lt;code&gt;AsyncLocalStorage&lt;/code&gt;. But in rare cases you may face situations when the current store is lost in one of asynchronous operations. In those cases, consider the following options.</source>
          <target state="translated">In most cases your application or library code should have no issues with &lt;code&gt;AsyncLocalStorage&lt;/code&gt; . But in rare cases you may face situations when the current store is lost in one of asynchronous operations. In those cases, consider the following options.</target>
        </trans-unit>
        <trans-unit id="39ad6cea5c8da673dfb8d0d33d34ec8391a32abb" translate="yes" xml:space="preserve">
          <source>In most cases, the ES module &lt;code&gt;import&lt;/code&gt; can be used to load CommonJS modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd8e7e54f1e17d20c23615bc834dee206f45159" translate="yes" xml:space="preserve">
          <source>In most cases, there should be little to no reason for an application to manually create instances of the &lt;code&gt;tty.ReadStream&lt;/code&gt; and &lt;code&gt;tty.WriteStream&lt;/code&gt; classes.</source>
          <target state="translated">대부분의 경우, 응용 프로그램이 &lt;code&gt;tty.ReadStream&lt;/code&gt; 및 &lt;code&gt;tty.WriteStream&lt;/code&gt; 클래스의 인스턴스를 수동으로 작성해야 할 이유가 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5bc3a0789b533753ef17917c6e76c2314768199f" translate="yes" xml:space="preserve">
          <source>In most operating systems, listening to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;unspecified IPv6 address&lt;/a&gt; (&lt;code&gt;::&lt;/code&gt;) may cause the &lt;code&gt;net.Server&lt;/code&gt; to also listen on the &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;unspecified IPv4 address&lt;/a&gt; (&lt;code&gt;0.0.0.0&lt;/code&gt;).</source>
          <target state="translated">대부분의 운영 체제에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;지정되지 않은 IPv6 주소&lt;/a&gt; ( &lt;code&gt;::&lt;/code&gt; &lt;code&gt;net.Server&lt;/code&gt; 를 수신 하면 net.Server 가 &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;지정되지 않은 IPv4 주소&lt;/a&gt; ( &lt;code&gt;0.0.0.0&lt;/code&gt; )를 수신 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a9fa045058fbc4f76eea96849e5ca18e4b0477e" translate="yes" xml:space="preserve">
          <source>In most situations, it is not actually necessary to call &lt;code&gt;process.exit()&lt;/code&gt; explicitly. The Node.js process will exit on its own &lt;em&gt;if there is no additional work pending&lt;/em&gt; in the event loop. The &lt;code&gt;process.exitCode&lt;/code&gt; property can be set to tell the process which exit code to use when the process exits gracefully.</source>
          <target state="translated">대부분의 경우 실제로 &lt;code&gt;process.exit()&lt;/code&gt; 명시 적으로 호출 할 필요는 없습니다 . 이벤트 루프에 &lt;em&gt;보류중인 추가 작업이없는 경우&lt;/em&gt; Node.js 프로세스가 자체적으로 종료됩니다 . &lt;code&gt;process.exitCode&lt;/code&gt; 의 속성은 종료 코드가 때 프로세스가 종료 정상적으로 사용하는 과정을 말하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba73ffda62f255ad07619c0e3bdc1d844b17d1f" translate="yes" xml:space="preserve">
          <source>In order to avoid the garbage collection overhead of creating many individually allocated &lt;code&gt;Buffer&lt;/code&gt; instances, by default allocations under 4KB are sliced from a single larger allocated object.</source>
          <target state="translated">개별적으로 할당 된 많은 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스 를 생성하는 가비지 수집 오버 헤드를 피하기 위해 기본적으로 4KB 미만의 할당은 하나의 더 큰 할당 된 객체에서 슬라이스됩니다.</target>
        </trans-unit>
        <trans-unit id="07817ef1abfbcf964409ae72ee3eff00eaa052ac" translate="yes" xml:space="preserve">
          <source>In order to be loaded from multiple Node.js environments, such as a main thread and a Worker thread, an add-on needs to either:</source>
          <target state="translated">기본 스레드 및 작업자 스레드와 같은 여러 Node.js 환경에서로드하려면 애드온에서 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="30b26d492c1627fc6654e900f98b2c495fce1ecb" translate="yes" xml:space="preserve">
          <source>In order to create a mixed &lt;a href=&quot;https&quot;&gt;HTTPS&lt;/a&gt; and HTTP/2 server, refer to the &lt;a href=&quot;#http2_alpn_negotiation&quot;&gt;ALPN negotiation&lt;/a&gt; section. Upgrading from non-tls HTTP/1 servers is not supported.</source>
          <target state="translated">혼합 &lt;a href=&quot;https&quot;&gt;HTTPS&lt;/a&gt; 및 HTTP / 2 서버를 작성하려면 &lt;a href=&quot;#http2_alpn_negotiation&quot;&gt;ALPN 협상&lt;/a&gt; 섹션을 참조하십시오 . 비 tls HTTP / 1 서버에서 업그레이드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9608ef8288365a7cade4d998db1fc0243461174f" translate="yes" xml:space="preserve">
          <source>In order to do this, it is necessary to get a reference to the &lt;code&gt;module&lt;/code&gt; object. Since &lt;code&gt;require()&lt;/code&gt; returns the &lt;code&gt;module.exports&lt;/code&gt;, and the &lt;code&gt;module&lt;/code&gt; is typically &lt;em&gt;only&lt;/em&gt; available within a specific module's code, it must be explicitly exported in order to be used.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;module&lt;/code&gt; 객체에 대한 참조를 가져와야 합니다. 이후 &lt;code&gt;require()&lt;/code&gt; 수익률 &lt;code&gt;module.exports&lt;/code&gt; 을 하고, &lt;code&gt;module&lt;/code&gt; 일반적으로 &lt;em&gt;단지&lt;/em&gt; 특정 모듈의 코드 내에서 사용할 수, 명시 적으로 사용하기 위해 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="34523f8cc30ff0b87b5cd5c6314ffe804fe892b1" translate="yes" xml:space="preserve">
          <source>In order to expose a function as part of the add-on's module exports, set the newly created function on the exports object. A sample module might look as follows:</source>
          <target state="translated">애드온 모듈 내보내기의 일부로 함수를 노출하려면 내보내기 개체에서 새로 만든 함수를 설정하십시오. 샘플 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5be94aad2d7524c4d29b1665cfabd8e1b693ef9b" translate="yes" xml:space="preserve">
          <source>In order to make modules available to the Node.js REPL, it might be useful to also add the &lt;code&gt;/usr/lib/node_modules&lt;/code&gt; folder to the &lt;code&gt;$NODE_PATH&lt;/code&gt; environment variable. Since the module lookups using &lt;code&gt;node_modules&lt;/code&gt; folders are all relative, and based on the real path of the files making the calls to &lt;code&gt;require()&lt;/code&gt;, the packages themselves can be anywhere.</source>
          <target state="translated">Node.js REPL에서 모듈을 사용 가능하게하려면 &lt;code&gt;/usr/lib/node_modules&lt;/code&gt; 폴더를 &lt;code&gt;$NODE_PATH&lt;/code&gt; 환경 변수에 추가하는 것이 유용 할 수 있습니다 . &lt;code&gt;node_modules&lt;/code&gt; 폴더를 사용하는 모듈 검색 은 모두 상대적이며 &lt;code&gt;require()&lt;/code&gt; 호출하는 파일의 실제 경로를 기반으로하기 때문에 패키지 자체는 어디에나있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34fc5ed6a9101bb04240e52968cc6d46716398a6" translate="yes" xml:space="preserve">
          <source>In order to prevent excessive memory usage, &lt;code&gt;Domain&lt;/code&gt; objects themselves are not implicitly added as children of the active domain. If they were, then it would be too easy to prevent request and response objects from being properly garbage collected.</source>
          <target state="translated">과도한 메모리 사용을 방지하기 위해 &lt;code&gt;Domain&lt;/code&gt; 오브젝트 자체는 내재적으로 활성 도메인의 하위로 추가되지 않습니다. 만약 그렇다면 요청과 응답 객체가 올바르게 가비지 수집되는 것을 방지하기가 너무 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0d96a80c80037641a2b7ed11d9c8516d07755e88" translate="yes" xml:space="preserve">
          <source>In order to retain ABI compatibility with previous versions, passing &lt;code&gt;NULL&lt;/code&gt; for &lt;code&gt;async_resource&lt;/code&gt; does not result in an error. However, this is not recommended as this will result poor results with &lt;code&gt;async_hooks&lt;/code&gt;&lt;a href=&quot;async_hooks#async_hooks_init_asyncid_type_triggerasyncid_resource&quot;&gt;&lt;code&gt;init&lt;/code&gt; hooks&lt;/a&gt; and &lt;code&gt;async_hooks.executionAsyncResource()&lt;/code&gt; as the resource is now required by the underlying &lt;code&gt;async_hooks&lt;/code&gt; implementation in order to provide the linkage between async callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1872d37dd99da69f48fff6e8ea85d653766d0af1" translate="yes" xml:space="preserve">
          <source>In order to retrieve this information &lt;a href=&quot;#n_api_napi_get_last_error_info&quot;&gt;&lt;code&gt;napi_get_last_error_info&lt;/code&gt;&lt;/a&gt; is provided which returns a &lt;code&gt;napi_extended_error_info&lt;/code&gt; structure. The format of the &lt;code&gt;napi_extended_error_info&lt;/code&gt; structure is as follows:</source>
          <target state="translated">이 정보를 검색하기 위해 &lt;a href=&quot;#n_api_napi_get_last_error_info&quot;&gt; &lt;code&gt;napi_get_last_error_info&lt;/code&gt; &lt;/a&gt; 반환 제공 &lt;code&gt;napi_extended_error_info&lt;/code&gt; 의 구조. &lt;code&gt;napi_extended_error_info&lt;/code&gt; 구조 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ba193044958a2078ac8148d7933406e9ff8c99a" translate="yes" xml:space="preserve">
          <source>In order to run a simple web server using the &lt;code&gt;http&lt;/code&gt; module the code passed to the context must either call &lt;code&gt;require('http')&lt;/code&gt; on its own, or have a reference to the &lt;code&gt;http&lt;/code&gt; module passed to it. For instance:</source>
          <target state="translated">&lt;code&gt;http&lt;/code&gt; 모듈을 사용하여 간단한 웹 서버를 실행 하려면 컨텍스트에 전달 된 코드 가 자체적으로 &lt;code&gt;require('http')&lt;/code&gt; 를 호출 하거나 전달 된 &lt;code&gt;http&lt;/code&gt; 모듈에 대한 참조가 있어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="90f2e2db8a43d295cc2c537970470ccdaed26c6e" translate="yes" xml:space="preserve">
          <source>In order to set up a &lt;code&gt;v8::Isolate&lt;/code&gt;, an &lt;code&gt;v8::ArrayBuffer::Allocator&lt;/code&gt; needs to be provided. One possible choice is the default Node.js allocator, which can be created through &lt;code&gt;node::ArrayBufferAllocator::Create()&lt;/code&gt;. Using the Node.js allocator allows minor performance optimizations when addons use the Node.js C++ &lt;code&gt;Buffer&lt;/code&gt; API, and is required in order to track &lt;code&gt;ArrayBuffer&lt;/code&gt; memory in &lt;a href=&quot;process#process_process_memoryusage&quot;&gt;&lt;code&gt;process.memoryUsage()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb69e44c062ea7704f38e703e2936582cc9f855" translate="yes" xml:space="preserve">
          <source>In order to support &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads, addons need to clean up any resources they may have allocated when such a thread exists. This can be achieved through the usage of the &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; function:</source>
          <target state="translated">&lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드 를 지원하려면 애드온은 해당 스레드가 존재할 때 할당했을 수있는 모든 리소스를 정리해야합니다. &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; 함수를 사용하면 됩니다 :</target>
        </trans-unit>
        <trans-unit id="6e43ad63b79dd141d986e828eceee78812aec282" translate="yes" xml:space="preserve">
          <source>In order to support the full spectrum of possible HTTP applications, Node.js's HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.</source>
          <target state="translated">가능한 모든 HTTP 응용 프로그램을 지원하기 위해 Node.js의 HTTP API는 매우 저수준입니다. 스트림 처리 및 메시지 구문 분석 만 처리합니다. 메시지를 헤더와 본문으로 구문 분석하지만 실제 헤더 또는 본문을 구문 분석하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cacbbe490b57fd8bf29c6d4c231226a0b14306b9" translate="yes" xml:space="preserve">
          <source>In order to support the full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.</source>
          <target state="translated">In order to support the full spectrum of possible HTTP applications, the Node.js HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.</target>
        </trans-unit>
        <trans-unit id="ff3632f1db32bf01741e5bbea082ca20145fb38f" translate="yes" xml:space="preserve">
          <source>In order to use the N-API functions, include the file &lt;a href=&quot;https://github.com/nodejs/node/blob/master/src/node_api.h&quot;&gt;&lt;code&gt;node_api.h&lt;/code&gt;&lt;/a&gt; which is located in the src directory in the node development tree:</source>
          <target state="translated">N-API 함수를 사용 하려면 노드 개발 트리의 src 디렉토리에있는 &lt;a href=&quot;https://github.com/nodejs/node/blob/master/src/node_api.h&quot;&gt; &lt;code&gt;node_api.h&lt;/code&gt; &lt;/a&gt; 파일을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ac594a0cf5cfa895ed35f6b2ef04dc94e26df89" translate="yes" xml:space="preserve">
          <source>In particular, the significant differences to &lt;code&gt;JSON&lt;/code&gt; are:</source>
          <target state="translated">특히 &lt;code&gt;JSON&lt;/code&gt; 과 의 중요한 차이점 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f2a5459c07d70896c8081dfc8b2f3407dcb02df" translate="yes" xml:space="preserve">
          <source>In particular, this makes sense for objects that can be cloned, rather than transferred, and which are used by other objects on the sending side. For example, Node.js marks the &lt;code&gt;ArrayBuffer&lt;/code&gt;s it uses for its &lt;a href=&quot;buffer#buffer_static_method_buffer_allocunsafe_size&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt; pool&lt;/a&gt; with this.</source>
          <target state="translated">In particular, this makes sense for objects that can be cloned, rather than transferred, and which are used by other objects on the sending side. For example, Node.js marks the &lt;code&gt;ArrayBuffer&lt;/code&gt; s it uses for its &lt;a href=&quot;buffer#buffer_static_method_buffer_allocunsafe_size&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; pool&lt;/a&gt; with this.</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">특히:</target>
        </trans-unit>
        <trans-unit id="d252f3d1a06c3b2a3ae5ad98ef71487c919a9c51" translate="yes" xml:space="preserve">
          <source>In paused mode, the &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; method must be called explicitly to read chunks of data from the stream.</source>
          <target state="translated">일시 정지 모드에서는 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 메소드를 명시 적으로 호출하여 스트림에서 데이터 청크를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9a5c41117e426ba3a059f25450d02c56bbffe674" translate="yes" xml:space="preserve">
          <source>In recent versions of Node.js, there is no difference between &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt;. The latter is deprecated along with the undocumented aliases &lt;code&gt;crypto.prng()&lt;/code&gt; and &lt;code&gt;crypto.rng()&lt;/code&gt; in favor of &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and may be removed in a future release.</source>
          <target state="translated">최신 버전의 Node.js에서는 &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt; 사이에 차이가 없습니다 . 후자는 문서화되지 않은 별칭과 함께 사용되지 &lt;code&gt;crypto.prng()&lt;/code&gt; 와 &lt;code&gt;crypto.rng()&lt;/code&gt; 찬성 &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482c092668220dab66fd94c51463dcf51a819a39" translate="yes" xml:space="preserve">
          <source>In recent versions of Node.js, there is no difference between &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt;. The latter is deprecated along with the undocumented aliases &lt;code&gt;crypto.prng()&lt;/code&gt; and &lt;code&gt;crypto.rng()&lt;/code&gt; in favor of &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and might be removed in a future release.</source>
          <target state="translated">In recent versions of Node.js, there is no difference between &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt; . The latter is deprecated along with the undocumented aliases &lt;code&gt;crypto.prng()&lt;/code&gt; and &lt;code&gt;crypto.rng()&lt;/code&gt; in favor of &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; and might be removed in a future release.</target>
        </trans-unit>
        <trans-unit id="177049c3930ff3f87e8368c6c3d05d129ef44094" translate="yes" xml:space="preserve">
          <source>In some cases an addon will need to be able to create and reference objects with a lifespan longer than that of a single native method invocation. For example, to create a constructor and later use that constructor in a request to creates instances, it must be possible to reference the constructor object across many different instance creation requests. This would not be possible with a normal handle returned as a &lt;code&gt;napi_value&lt;/code&gt; as described in the earlier section. The lifespan of a normal handle is managed by scopes and all scopes must be closed before the end of a native method.</source>
          <target state="translated">경우에 따라 애드온은 단일 고유 메소드 호출보다 수명이 긴 오브젝트를 작성하고 참조 할 수 있어야합니다. 예를 들어 생성자를 생성하고 나중에 요청에 생성자를 사용하여 인스턴스를 생성하려면 여러 인스턴스 생성 요청에서 생성자 객체를 참조 할 수 있어야합니다. 이전 섹션에서 설명한 것처럼 &lt;code&gt;napi_value&lt;/code&gt; 로 반환 된 일반 핸들로는 불가능 합니다. 일반 핸들의 수명은 범위별로 관리되며 기본 범위가 끝나기 전에 모든 범위를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e22a93062d451b249b9309c60af8192dbe28ccd1" translate="yes" xml:space="preserve">
          <source>In some cases the resource object is reused for performance reasons, it is thus not safe to use it as a key in a &lt;code&gt;WeakMap&lt;/code&gt; or add properties to it.</source>
          <target state="translated">경우에 따라 성능상의 이유로 리소스 개체를 재사용하기 때문에 &lt;code&gt;WeakMap&lt;/code&gt; 에서 키로 사용 하거나 속성을 추가 하는 것이 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ad5e1a1929b5b0a41cfc844642f2414d2f858a5" translate="yes" xml:space="preserve">
          <source>In some cases, a &lt;code&gt;Sign&lt;/code&gt; instance can be created using the name of a signature algorithm, such as &lt;code&gt;'RSA-SHA256'&lt;/code&gt;, instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt;, so it is best to always use digest algorithm names.</source>
          <target state="translated">경우 에 따라 다이제스트 알고리즘 대신 &lt;code&gt;'RSA-SHA256'&lt;/code&gt; 과 같은 서명 알고리즘의 이름을 사용하여 &lt;code&gt;Sign&lt;/code&gt; 인스턴스를 만들 수 있습니다 . 해당 다이제스트 알고리즘을 사용합니다. &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt; 과 같은 모든 서명 알고리즘에는 작동하지 않으므로 항상 다이제스트 알고리즘 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e37ebca3d8b767295ac2a49a166fe5a6bbb405cb" translate="yes" xml:space="preserve">
          <source>In some cases, a &lt;code&gt;Verify&lt;/code&gt; instance can be created using the name of a signature algorithm, such as &lt;code&gt;'RSA-SHA256'&lt;/code&gt;, instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt;, so it is best to always use digest algorithm names.</source>
          <target state="translated">경우 에 따라 다이제스트 알고리즘 대신 &lt;code&gt;'RSA-SHA256'&lt;/code&gt; 과 같은 서명 알고리즘의 이름을 사용하여 &lt;code&gt;Verify&lt;/code&gt; 인스턴스를 만들 수 있습니다 . 해당 다이제스트 알고리즘을 사용합니다. &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt; 과 같은 모든 서명 알고리즘에는 작동하지 않으므로 항상 다이제스트 알고리즘 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="715189038eeefcaa56acee7c2e2873a2e151a84e" translate="yes" xml:space="preserve">
          <source>In some cases, a transform operation may need to emit an additional bit of data at the end of the stream. For example, a &lt;code&gt;zlib&lt;/code&gt; compression stream will store an amount of internal state used to optimally compress the output. When the stream ends, however, that additional data needs to be flushed so that the compressed data will be complete.</source>
          <target state="translated">어떤 경우에는 변환 작업이 스트림의 끝에서 추가 비트의 데이터를 방출해야 할 수도 있습니다. 예를 들어 &lt;code&gt;zlib&lt;/code&gt; 압축 스트림은 출력을 최적으로 압축하는 데 사용되는 내부 상태를 저장합니다. 그러나 스트림이 종료되면 압축 된 데이터가 완료되도록 추가 데이터를 비워야합니다.</target>
        </trans-unit>
        <trans-unit id="60c6c3683d6de9acfc87a92e7bab5fb89fe40cef" translate="yes" xml:space="preserve">
          <source>In some cases, the client has already received the response and/or the socket has already been destroyed, like in case of &lt;code&gt;ECONNRESET&lt;/code&gt; errors. Before trying to send data to the socket, it is better to check that it is still writable.</source>
          <target state="translated">In some cases, the client has already received the response and/or the socket has already been destroyed, like in case of &lt;code&gt;ECONNRESET&lt;/code&gt; errors. Before trying to send data to the socket, it is better to check that it is still writable.</target>
        </trans-unit>
        <trans-unit id="449c40eda8a931307bfa01c725cde16111359434" translate="yes" xml:space="preserve">
          <source>In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error messages for objects display the objects, often truncated.</source>
          <target state="translated">In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error messages for objects display the objects, often truncated.</target>
        </trans-unit>
        <trans-unit id="25f6b941385c959247bdc6909616b44376b1d8ef" translate="yes" xml:space="preserve">
          <source>In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example, &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepEqual()&lt;/code&gt;&lt;/a&gt; will behave like &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepStrictEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example, &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepEqual()&lt;/code&gt; &lt;/a&gt; will behave like &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepStrictEqual()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e0648c6c88ba0416f92bbc79ff87e571aa792e5c" translate="yes" xml:space="preserve">
          <source>In synchronous code, the &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted when the list of unhandled exceptions grows.</source>
          <target state="translated">동기 코드에서 처리되지 않은 예외 목록이 커지면 &lt;code&gt;'uncaughtException'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="621f9ba64d0f93481000b51697b0e8e212cfe125" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;hello.cc&lt;/code&gt; example, then, the initialization function is &lt;code&gt;Initialize&lt;/code&gt; and the addon module name is &lt;code&gt;addon&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;hello.cc&lt;/code&gt; 의 예, 그리고, 초기화 기능은 &lt;code&gt;Initialize&lt;/code&gt; 및 부가 모듈 이름은 &lt;code&gt;addon&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
