<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="node">
    <body>
      <group id="node">
        <trans-unit id="34a1a029b73f14872b97df7d8a65365950b239dc" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;http&lt;/code&gt; module, the response body is omitted when the request is a HEAD request. Similarly, the &lt;code&gt;204&lt;/code&gt; and &lt;code&gt;304&lt;/code&gt; responses &lt;em&gt;must not&lt;/em&gt; include a message body.</source>
          <target state="translated">에서 &lt;code&gt;http&lt;/code&gt; 요청이 HEAD 요청 모듈 인 경우, 상기 응답 체를 생략한다. 마찬가지로 &lt;code&gt;204&lt;/code&gt; 및 &lt;code&gt;304&lt;/code&gt; 응답 에는 메시지 본문이 포함 &lt;em&gt;되어서&lt;/em&gt; 는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e51ffedc5aa7b802f39e0dbd76ccacf085da1acf" translate="yes" xml:space="preserve">
          <source>In the Node.js &lt;code&gt;EventTarget&lt;/code&gt;, if an event listener is an async function or returns a &lt;code&gt;Promise&lt;/code&gt;, and the returned &lt;code&gt;Promise&lt;/code&gt; rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see &lt;a href=&quot;#events_eventtarget_error_handling&quot;&gt;&lt;code&gt;EventTarget&lt;/code&gt; error handling&lt;/a&gt; for details).</source>
          <target state="translated">In the Node.js &lt;code&gt;EventTarget&lt;/code&gt; , if an event listener is an async function or returns a &lt;code&gt;Promise&lt;/code&gt; , and the returned &lt;code&gt;Promise&lt;/code&gt; rejects, the rejection is automatically captured and handled the same way as a listener that throws synchronously (see &lt;a href=&quot;#events_eventtarget_error_handling&quot;&gt; &lt;code&gt;EventTarget&lt;/code&gt; error handling&lt;/a&gt; for details).</target>
        </trans-unit>
        <trans-unit id="ea6a5d641d8bc637062b7f84d566dcbd208d5b73" translate="yes" xml:space="preserve">
          <source>In the Node.js module system, each file is treated as a separate module. For example, consider a file named &lt;code&gt;foo.js&lt;/code&gt;:</source>
          <target state="translated">Node.js 모듈 시스템에서 각 파일은 별도의 모듈로 처리됩니다. 예를 들어, &lt;code&gt;foo.js&lt;/code&gt; 라는 파일을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="5efe8184649f8e9b88e3c4673bc7122c9bf741b4" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;myAddon.queryHasRecords()&lt;/code&gt; is a method that accepts two arguments. The first is a database handle and the second is a query handle. Internally, it unwraps the first argument and casts the resulting pointer to a native database handle. It then unwraps the second argument and casts the resulting pointer to a query handle. If the arguments are passed in the wrong order, the casts will work, however, there is a good chance that the underlying database operation will fail, or will even cause an invalid memory access.</source>
          <target state="translated">In the above example &lt;code&gt;myAddon.queryHasRecords()&lt;/code&gt; is a method that accepts two arguments. The first is a database handle and the second is a query handle. Internally, it unwraps the first argument and casts the resulting pointer to a native database handle. It then unwraps the second argument and casts the resulting pointer to a query handle. If the arguments are passed in the wrong order, the casts will work, however, there is a good chance that the underlying database operation will fail, or will even cause an invalid memory access.</target>
        </trans-unit>
        <trans-unit id="48e2be294d408b9afdcf261478d35f9f2c3215e8" translate="yes" xml:space="preserve">
          <source>In the above, errors on the write stream would be caught and thrown by the two &lt;code&gt;once()&lt;/code&gt; listeners, since &lt;code&gt;once()&lt;/code&gt; will also handle &lt;code&gt;'error'&lt;/code&gt; events.</source>
          <target state="translated">위의 경우, &lt;code&gt;once()&lt;/code&gt; 도 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 처리하기 때문에 쓰기 스트림의 오류는 두 번의 &lt;code&gt;once()&lt;/code&gt; 리스너에 의해 포착되어 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5261e070003e9d4318beec94c3cf4ba4e3cbd884" translate="yes" xml:space="preserve">
          <source>In the case of Promises, the &lt;code&gt;resource&lt;/code&gt; object will have an &lt;code&gt;isChainedPromise&lt;/code&gt; property, set to &lt;code&gt;true&lt;/code&gt; if the promise has a parent promise, and &lt;code&gt;false&lt;/code&gt; otherwise. For example, in the case of &lt;code&gt;b = a.then(handler)&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is considered a parent &lt;code&gt;Promise&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt;. Here, &lt;code&gt;b&lt;/code&gt; is considered a chained promise.</source>
          <target state="translated">약속의 경우 &lt;code&gt;resource&lt;/code&gt; 개체에는 &lt;code&gt;isChainedPromise&lt;/code&gt; 속성 이 있으며 , 약속에 부모 약속이 있으면 &lt;code&gt;true&lt;/code&gt; 로 설정되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 로 설정 됩니다. 예를 들어, &lt;code&gt;b = a.then(handler)&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 의 상위 &lt;code&gt;Promise&lt;/code&gt; 으로 간주됩니다 . 여기서 &lt;code&gt;b&lt;/code&gt; 는 연쇄 약속으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b68963099522536bfb9d03e74439ba262a06acfe" translate="yes" xml:space="preserve">
          <source>In the case of a connection error, the following events will be emitted:</source>
          <target state="translated">연결 오류의 경우 다음 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03a5e4309fc1c7ad9fcbe06a809e4b2569683624" translate="yes" xml:space="preserve">
          <source>In the case of a premature connection close after the response is received, the following events will be emitted in the following order:</source>
          <target state="translated">In the case of a premature connection close after the response is received, the following events will be emitted in the following order:</target>
        </trans-unit>
        <trans-unit id="d8bb0b42ce2a493aa297335691f09d8aec6a1679" translate="yes" xml:space="preserve">
          <source>In the case of a premature connection close before the response is received, the following events will be emitted in the following order:</source>
          <target state="translated">In the case of a premature connection close before the response is received, the following events will be emitted in the following order:</target>
        </trans-unit>
        <trans-unit id="918cb5bc54bb7c658a3c96576889997c72299bef" translate="yes" xml:space="preserve">
          <source>In the case where a developer may need to retain a small chunk of memory from a pool for an indeterminate amount of time, it may be appropriate to create an un-pooled &lt;code&gt;Buffer&lt;/code&gt; instance using &lt;code&gt;SlowBuffer&lt;/code&gt; then copy out the relevant bits.</source>
          <target state="translated">개발자가 결정되지 않은 시간 동안 풀에서 작은 메모리 청크를 유지해야하는 경우 &lt;code&gt;SlowBuffer&lt;/code&gt; 를 사용하여 풀링되지 않은 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스를 만든 다음 관련 비트를 복사하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ef5ea159bcc99b4a4ae1f2a88941efdfec9000" translate="yes" xml:space="preserve">
          <source>In the event of an unrecoverable error in a native module, a fatal error can be thrown to immediately terminate the process.</source>
          <target state="translated">기본 모듈에서 복구 할 수없는 오류가 발생하면 프로세스를 즉시 종료하기 위해 치명적인 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b5ef3b0128e137344ad3cbe4a5087a73a781f41" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;req.end()&lt;/code&gt; was called. With &lt;code&gt;http.request()&lt;/code&gt; one must always call &lt;code&gt;req.end()&lt;/code&gt; to signify the end of the request - even if there is no data being written to the request body.</source>
          <target state="translated">예제에서 &lt;code&gt;req.end()&lt;/code&gt; 가 호출되었습니다. 함께 &lt;code&gt;http.request()&lt;/code&gt; 하나는 항상 호출해야 &lt;code&gt;req.end()&lt;/code&gt; 데이터가 요청 본문에 기록되지되고있는 경우에도 - 요청의 끝을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4ef00df3b73a5938a813feaf72104024931ba1" translate="yes" xml:space="preserve">
          <source>In the following algorithms, all subroutine errors are propagated as errors of these top-level routines unless stated otherwise.</source>
          <target state="translated">다음 알고리즘에서 달리 명시하지 않는 한 모든 서브 루틴 오류는 이러한 최상위 루틴의 오류로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="fa725afe5295f20910c112028ae94f2b56a1a734" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;flush()&lt;/code&gt; is used to write a compressed partial HTTP response to the client:</source>
          <target state="translated">다음 예에서 &lt;code&gt;flush()&lt;/code&gt; 는 클라이언트에 압축 된 부분 HTTP 응답을 쓰는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf82ec3610a7aca0a8ed51fb8b215927e85734d4" translate="yes" xml:space="preserve">
          <source>In the following example, for instance, a new &lt;code&gt;Transform&lt;/code&gt; stream (which is a type of &lt;a href=&quot;#stream_class_stream_duplex&quot;&gt;&lt;code&gt;Duplex&lt;/code&gt;&lt;/a&gt; stream) is created that has an object mode &lt;code&gt;Writable&lt;/code&gt; side that accepts JavaScript numbers that are converted to hexadecimal strings on the &lt;code&gt;Readable&lt;/code&gt; side.</source>
          <target state="translated">예를 들어 다음 예제에서는 &lt;code&gt;Readable&lt;/code&gt; 쪽에서 16 진수 문자열로 변환되는 JavaScript 숫자를 허용 하는 개체 모드 &lt;code&gt;Writable&lt;/code&gt; 쪽이 있는 새 &lt;code&gt;Transform&lt;/code&gt; 스트림 ( &lt;a href=&quot;#stream_class_stream_duplex&quot;&gt; &lt;code&gt;Duplex&lt;/code&gt; &lt;/a&gt; 스트림 유형 )이 만들어 집니다 .</target>
        </trans-unit>
        <trans-unit id="7c0fb3c9414cf1c8a8bda6e4b07edf6163cccd34" translate="yes" xml:space="preserve">
          <source>In the following example, only the child's fd &lt;code&gt;1&lt;/code&gt; (stdout) is configured as a pipe, so only the parent's &lt;code&gt;subprocess.stdio[1]&lt;/code&gt; is a stream, all other values in the array are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 자식의 fd &lt;code&gt;1&lt;/code&gt; (stdout) 만 파이프로 구성되므로 부모의 &lt;code&gt;subprocess.stdio[1]&lt;/code&gt; 만 스트림이며 배열의 다른 모든 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0de61ebd59a8526600cd416227b8b1e35a46645a" translate="yes" xml:space="preserve">
          <source>In the following example, the three UTF-8 encoded bytes of the European Euro symbol (&lt;code&gt;&amp;euro;&lt;/code&gt;) are written over three separate operations:</source>
          <target state="translated">다음 예에서 유럽 유로 기호 ( &lt;code&gt;&amp;euro;&lt;/code&gt; ) 의 3 개의 UTF-8 인코딩 바이트는 3 개의 개별 연산으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="67b32ff656d65a26d312747226fead13fb28eaac" translate="yes" xml:space="preserve">
          <source>In the last three cases &lt;code&gt;actual&lt;/code&gt;, &lt;code&gt;expected&lt;/code&gt;, and &lt;code&gt;operator&lt;/code&gt; have no influence on the error message.</source>
          <target state="translated">마지막 세 경우 &lt;code&gt;actual&lt;/code&gt; , &lt;code&gt;expected&lt;/code&gt; 및 &lt;code&gt;operator&lt;/code&gt; 는 오류 메시지에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb96692d68fa67ba34d26bf28629f0c68833dc44" translate="yes" xml:space="preserve">
          <source>In the master this sends a message to a specific worker. It is identical to &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt;&lt;code&gt;ChildProcess.send()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스터에서 이것은 특정 작업자에게 메시지를 보냅니다. &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt; &lt;code&gt;ChildProcess.send()&lt;/code&gt; &lt;/a&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f382762e386304b924761ff709bc435737f82042" translate="yes" xml:space="preserve">
          <source>In the master, an internal message is sent to the worker causing it to call &lt;code&gt;.disconnect()&lt;/code&gt; on itself.</source>
          <target state="translated">마스터에서는 내부 메시지가 작업자에게 전송되어 자체적으로 &lt;code&gt;.disconnect()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="47d8c3363f2d2eb56cc1c395f156dd4f776263e2" translate="yes" xml:space="preserve">
          <source>In the preceding example, 30,000 deflate instances are created concurrently. Because of how some operating systems handle memory allocation and deallocation, this may lead to to significant memory fragmentation.</source>
          <target state="translated">In the preceding example, 30,000 deflate instances are created concurrently. Because of how some operating systems handle memory allocation and deallocation, this may lead to to significant memory fragmentation.</target>
        </trans-unit>
        <trans-unit id="40fb2a46c3495adde1bdbd6a72aa0fe0f5338274" translate="yes" xml:space="preserve">
          <source>In the scenario of writing to a writable stream from an async iterator, it is important to ensure the correct handling of backpressure and errors.</source>
          <target state="translated">비동기 반복기에서 쓰기 가능한 스트림에 쓰는 시나리오에서는 배압 및 오류를 올바르게 처리하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0ce5fad120b64ee42264f01dfdc44ee7b983178a" translate="yes" xml:space="preserve">
          <source>In this case the entire API surface, including any experimental APIs, will be available to the module code.</source>
          <target state="translated">이 경우 실험용 API를 포함한 전체 API 표면을 모듈 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8211aa9015b5d9d4b17ecb481815c6ab35412ee7" translate="yes" xml:space="preserve">
          <source>In this case, the microtask scheduled through &lt;code&gt;promise.then()&lt;/code&gt; will be run before returning from &lt;code&gt;vm.runInNewContext()&lt;/code&gt;, and will be interrupted by the &lt;code&gt;timeout&lt;/code&gt; functionality. This applies only to code running in a &lt;code&gt;vm.Context&lt;/code&gt;, so e.g. &lt;a href=&quot;#vm_vm_runinthiscontext_code_options&quot;&gt;&lt;code&gt;vm.runInThisContext()&lt;/code&gt;&lt;/a&gt; does not take this option.</source>
          <target state="translated">In this case, the microtask scheduled through &lt;code&gt;promise.then()&lt;/code&gt; will be run before returning from &lt;code&gt;vm.runInNewContext()&lt;/code&gt; , and will be interrupted by the &lt;code&gt;timeout&lt;/code&gt; functionality. This applies only to code running in a &lt;code&gt;vm.Context&lt;/code&gt; , so e.g. &lt;a href=&quot;#vm_vm_runinthiscontext_code_options&quot;&gt; &lt;code&gt;vm.runInThisContext()&lt;/code&gt; &lt;/a&gt; does not take this option.</target>
        </trans-unit>
        <trans-unit id="3340c556f6543bec062f3b2ed6d553b3150156a1" translate="yes" xml:space="preserve">
          <source>In this example case, it is possible to track the rejection as a developer error as would typically be the case for other &lt;code&gt;'unhandledRejection'&lt;/code&gt; events. To address such failures, a non-operational &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch&quot;&gt;&lt;code&gt;.catch(() =&amp;gt; { })&lt;/code&gt;&lt;/a&gt; handler may be attached to &lt;code&gt;resource.loaded&lt;/code&gt;, which would prevent the &lt;code&gt;'unhandledRejection'&lt;/code&gt; event from being emitted.</source>
          <target state="translated">이 예제의 경우 일반적으로 다른 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트 의 경우와 같이 개발자 오류로 거부를 추적 할 수 있습니다. 이러한 실패를 해결하기 위해 비 작동 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch&quot;&gt; &lt;code&gt;.catch(() =&amp;gt; { })&lt;/code&gt; &lt;/a&gt; 핸들러가 &lt;code&gt;resource.loaded&lt;/code&gt; 에 첨부되어 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트가 생성 되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b30d924ce86ebcb8be4941fadb4d24eb63050b49" translate="yes" xml:space="preserve">
          <source>In this example, adding any actual hook function enabled the tracking of promises. There are two promises in the example above; the promise created by &lt;code&gt;Promise.resolve()&lt;/code&gt; and the promise returned by the call to &lt;code&gt;then()&lt;/code&gt;. In the example above, the first promise got the &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;6&lt;/code&gt; and the latter got &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;7&lt;/code&gt;. During the execution of the &lt;code&gt;then()&lt;/code&gt; callback, we are executing in the context of promise with &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;7&lt;/code&gt;. This promise was triggered by async resource &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">이 예에서 실제 후크 기능을 추가하면 약속 추적이 가능합니다. 위의 예에는 두 가지 약속이 있습니다. 만든 약속 &lt;code&gt;Promise.resolve()&lt;/code&gt; 과에 호출에 의해 반환 약속 &lt;code&gt;then()&lt;/code&gt; . 위의 예에서 첫 번째 약속에는 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;6&lt;/code&gt; 이 있고 후자의 약속에는 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;7&lt;/code&gt; 이 있습니다. &lt;code&gt;then()&lt;/code&gt; 콜백 을 실행하는 동안 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;7&lt;/code&gt; 로 promise 컨텍스트에서 실행 중 입니다. 이 약속은 비동기 리소스 &lt;code&gt;6&lt;/code&gt; 에 의해 시작되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f2c1f79c71778e1324e95e72ef55b00fad51c2b3" translate="yes" xml:space="preserve">
          <source>In this example, an &lt;code&gt;Error&lt;/code&gt; object is generated internally by &lt;code&gt;process.emitWarning()&lt;/code&gt; and passed through to the &lt;a href=&quot;#process_event_warning&quot;&gt;&lt;code&gt;'warning'&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Error&lt;/code&gt; 객체는 &lt;code&gt;process.emitWarning()&lt;/code&gt; 의해 내부적으로 생성 되어 &lt;a href=&quot;#process_event_warning&quot;&gt; &lt;code&gt;'warning'&lt;/code&gt; &lt;/a&gt; 처리기로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="75d63ff46a64b4f575facc6bfa8055c873dc89f8" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;d.on('error')&lt;/code&gt; handler will be triggered, rather than crashing the program.</source>
          <target state="translated">이 예제에서는 프로그램을 &lt;code&gt;d.on('error')&lt;/code&gt; 핸들러가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9125992e5a27db7323b09884626b3c07becbe5" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;name&lt;/code&gt; from &lt;code&gt;import { name } from 'pkg'&lt;/code&gt; is the same singleton as the &lt;code&gt;name&lt;/code&gt; from &lt;code&gt;const { name } = require('pkg')&lt;/code&gt;. Therefore &lt;code&gt;===&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; when comparing the two &lt;code&gt;name&lt;/code&gt;s and the divergent specifier hazard is avoided.</source>
          <target state="translated">이 예에서, &lt;code&gt;name&lt;/code&gt; 에서 &lt;code&gt;import { name } from 'pkg'&lt;/code&gt; 는 AS 같은 싱글 인 &lt;code&gt;name&lt;/code&gt; 에서 &lt;code&gt;const { name } = require('pkg')&lt;/code&gt; . 따라서 &lt;code&gt;===&lt;/code&gt; 는 두 &lt;code&gt;name&lt;/code&gt; s를 비교할 때 &lt;code&gt;true&lt;/code&gt; 반환 하고 발산 지정자 위험을 피합니다.</target>
        </trans-unit>
        <trans-unit id="4a2f4cd6b751dfe743b9e57f92471b943ba9aa8e" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;unhandledRejections&lt;/code&gt;&lt;code&gt;Map&lt;/code&gt; will grow and shrink over time, reflecting rejections that start unhandled and then become handled. It is possible to record such errors in an error log, either periodically (which is likely best for long-running application) or upon process exit (which is likely most convenient for scripts).</source>
          <target state="translated">이 예에서 &lt;code&gt;unhandledRejections&lt;/code&gt; 거부 &lt;code&gt;Map&lt;/code&gt; 은 처리되지 않은 것으로 시작된 후 처리 된 거부를 반영하여 시간이 지남에 따라 커지거나 줄어 듭니다. 주기적으로 (오래 실행되는 응용 프로그램에 가장 적합) 또는 프로세스 종료시 (스크립트에 가장 편리한) 오류 로그에 이러한 오류를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a9e0f5e7284af8b7d1cd8e4c8dee1cd1759793" translate="yes" xml:space="preserve">
          <source>In this example, the callback function is invoked synchronously.</source>
          <target state="translated">이 예제에서 콜백 함수는 동 기적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ae140087d25d149461331902a072314e871a3f" translate="yes" xml:space="preserve">
          <source>In this example, the store is only available in the callback function and the functions called by &lt;code&gt;foo&lt;/code&gt;. Outside of &lt;code&gt;run&lt;/code&gt;, calling &lt;code&gt;getStore&lt;/code&gt; will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">In this example, the store is only available in the callback function and the functions called by &lt;code&gt;foo&lt;/code&gt; . Outside of &lt;code&gt;run&lt;/code&gt; , calling &lt;code&gt;getStore&lt;/code&gt; will return &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4031e8bbffadc3eeaaece5bccec619b8b40c5fe2" translate="yes" xml:space="preserve">
          <source>In this way, &lt;code&gt;domain&lt;/code&gt; usage goes hand-in-hand with the cluster module, since the master process can fork a new worker when a worker encounters an error. For Node.js programs that scale to multiple machines, the terminating proxy or service registry can take note of the failure, and react accordingly.</source>
          <target state="translated">이러한 방식으로, 작업자 프로세스에 오류가 발생하면 마스터 프로세스가 새 작업자를 분기 할 수 있으므로 &lt;code&gt;domain&lt;/code&gt; 사용은 클러스터 모듈과 함께 사용됩니다. 여러 머신으로 확장되는 Node.js 프로그램의 경우 종료 프록시 또는 서비스 레지스트리가 실패를 기록하고 이에 따라 대응할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c8ce86c05cf45e881c8b88dcfc90bac15ce63e" translate="yes" xml:space="preserve">
          <source>In this way, the common &lt;code&gt;if (err) return callback(err);&lt;/code&gt; pattern can be replaced with a single error handler in a single place.</source>
          <target state="translated">이런 식으로 일반적인 &lt;code&gt;if (err) return callback(err);&lt;/code&gt; 단일 위치에서 패턴을 단일 오류 처리기로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1593e2fa0de1cde7649f366647211411e84269" translate="yes" xml:space="preserve">
          <source>In versions of Node.js prior to 6.0.0, &lt;code&gt;Buffer&lt;/code&gt; instances were created using the &lt;code&gt;Buffer&lt;/code&gt; constructor function, which allocates the returned &lt;code&gt;Buffer&lt;/code&gt; differently based on what arguments are provided:</source>
          <target state="translated">6.0.0 이전의 Node.js 버전에서는 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스는 &lt;code&gt;Buffer&lt;/code&gt; 생성자 함수를 사용하여 작성되었으며 , 제공되는 인수에 따라 리턴 된 &lt;code&gt;Buffer&lt;/code&gt; 를 다르게 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="832c4629f7e8996e07e8102ea0fa28b91da7e64c" translate="yes" xml:space="preserve">
          <source>Inadequate Security</source>
          <target state="translated">부적절한 보안</target>
        </trans-unit>
        <trans-unit id="a04fbe86378e32032371c210b82217db52298dd6" translate="yes" xml:space="preserve">
          <source>Increases indentation of subsequent lines by spaces for &lt;code&gt;groupIndentation&lt;/code&gt; length.</source>
          <target state="translated">Increases indentation of subsequent lines by spaces for &lt;code&gt;groupIndentation&lt;/code&gt; length.</target>
        </trans-unit>
        <trans-unit id="00695bb607f52dab548ebe840966ef926ce5e82c" translate="yes" xml:space="preserve">
          <source>Increases indentation of subsequent lines by two spaces.</source>
          <target state="translated">다음 줄의 들여 쓰기를 두 칸 늘립니다.</target>
        </trans-unit>
        <trans-unit id="1d70be8dce5ba727bab7ab54dcd1d8109b04da3a" translate="yes" xml:space="preserve">
          <source>Indexed properties can be set in a similar manner. Consider the following JavaScript snippet:</source>
          <target state="translated">인덱싱 된 속성은 비슷한 방식으로 설정할 수 있습니다. 다음 JavaScript 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6a9226b31bce95d0e64d3b93d51517a2e18a0695" translate="yes" xml:space="preserve">
          <source>Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument is used as a script filename.</source>
          <target state="translated">Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument is used as a script filename.</target>
        </trans-unit>
        <trans-unit id="cfe35ae027c5117ae3dcbc4f4499564544b6855c" translate="yes" xml:space="preserve">
          <source>Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.</source>
          <target state="translated">노드 끝 옵션을 나타냅니다. 나머지 인수는 스크립트로 전달하십시오. 이 전에 스크립트 파일 이름이나 eval / print 스크립트가 제공되지 않으면 다음 인수가 스크립트 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99d425840951d8be042af09d1dcf66a17ffc427c" translate="yes" xml:space="preserve">
          <source>Indicate whether to treat &lt;code&gt;TypedArray&lt;/code&gt; and &lt;code&gt;DataView&lt;/code&gt; objects as host objects, i.e. pass them to &lt;a href=&quot;#v8_serializer_writehostobject_object&quot;&gt;&lt;code&gt;serializer._writeHostObject()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TypedArray&lt;/code&gt; 및 &lt;code&gt;DataView&lt;/code&gt; 객체를 호스트 객체로 처리할지 여부를 나타냅니다 ( 예 : &lt;a href=&quot;#v8_serializer_writehostobject_object&quot;&gt; &lt;code&gt;serializer._writeHostObject()&lt;/code&gt; &lt;/a&gt; 전달 ). .</target>
        </trans-unit>
        <trans-unit id="fb592b621da88223e8c8eeaa77068b4a45722a59" translate="yes" xml:space="preserve">
          <source>Indicates a bad protocol option.</source>
          <target state="translated">잘못된 프로토콜 옵션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ce04c2ac7352b9f26f40319a3e76118d2aa0de4" translate="yes" xml:space="preserve">
          <source>Indicates a broken pipe.</source>
          <target state="translated">파이프가 파손되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="af50c58faad8a1bc38a6c9a13abb8207dd6be3b4" translate="yes" xml:space="preserve">
          <source>Indicates a protocol error.</source>
          <target state="translated">프로토콜 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed6600816a977d05967d85edb3fba53ca13ec802" translate="yes" xml:space="preserve">
          <source>Indicates a stale file handle reference.</source>
          <target state="translated">오래된 파일 핸들 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="970e3b5809af80329b70563fbfeafb59b12d099d" translate="yes" xml:space="preserve">
          <source>Indicates a system call failure.</source>
          <target state="translated">시스템 호출 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47f9d21b2e00f4702c7ba7173aab1e2e364d4334" translate="yes" xml:space="preserve">
          <source>Indicates an exec format error.</source>
          <target state="translated">exec 형식 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7cc6e95cd367c61b66f24c7fe172fdd4c8923fd1" translate="yes" xml:space="preserve">
          <source>Indicates an expired timer.</source>
          <target state="translated">만료 된 타이머를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c6d7b9adaac7927a8389d72c9d49641a39dfb73" translate="yes" xml:space="preserve">
          <source>Indicates an illegal byte sequence.</source>
          <target state="translated">잘못된 바이트 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2399784693d157cc9db6a7d56a6802acafd3410" translate="yes" xml:space="preserve">
          <source>Indicates an improper link.</source>
          <target state="translated">부적절한 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5096800752c0124499ffda65a06e130ca52bf58" translate="yes" xml:space="preserve">
          <source>Indicates an inappropriate I/O control operation.</source>
          <target state="translated">부적절한 I / O 제어 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47bec5da438c0efb0d77c5a830b93909367a15cd" translate="yes" xml:space="preserve">
          <source>Indicates an interrupted function call.</source>
          <target state="translated">중단 된 함수 호출을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f90c9f7ea77891094deecf8791df2b6a6f6e7be0" translate="yes" xml:space="preserve">
          <source>Indicates an invalid data message.</source>
          <target state="translated">유효하지 않은 데이터 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c88760d39d665b5ee4f2cedcdae333c06a2e638" translate="yes" xml:space="preserve">
          <source>Indicates an invalid file handle.</source>
          <target state="translated">유효하지 않은 파일 핸들을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e973fa6216cda928d3b1ff9110620c4c3f989631" translate="yes" xml:space="preserve">
          <source>Indicates an invalid pointer address.</source>
          <target state="translated">유효하지 않은 포인터 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="542f438ea8fb2199f934997e9825630c4ad77ec3" translate="yes" xml:space="preserve">
          <source>Indicates an invalid seek operation.</source>
          <target state="translated">유효하지 않은 탐색 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec1cddd818d2d11c606513689ef95576ae628a23" translate="yes" xml:space="preserve">
          <source>Indicates an invalid service provider.</source>
          <target state="translated">유효하지 않은 서비스 제공자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca69bd9871d6b4b835be2cc5b7e303a5aeb76ba5" translate="yes" xml:space="preserve">
          <source>Indicates an otherwise unspecified I/O error.</source>
          <target state="translated">지정되지 않은 I / O 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93e1ce7f1ec33ca5400e5c2d49688b755daf62ba" translate="yes" xml:space="preserve">
          <source>Indicates insufficient permissions to complete the operation.</source>
          <target state="translated">작업을 완료 할 권한이 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ea06b534d77b7af671ce8399f89fdee2b70e93d" translate="yes" xml:space="preserve">
          <source>Indicates no such device or address.</source>
          <target state="translated">그러한 장치 나 주소가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b3bb95ecdaaf6e1c491e89dc55bdf4ada5917b17" translate="yes" xml:space="preserve">
          <source>Indicates that a class type was not found.</source>
          <target state="translated">클래스 유형을 찾을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a078deb966b1f0dbb2923905efd3bfa3c6936245" translate="yes" xml:space="preserve">
          <source>Indicates that a database query was refused.</source>
          <target state="translated">데이터베이스 쿼리가 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b0136ce90dcbd9af267c4da8409264b6bd7ceca" translate="yes" xml:space="preserve">
          <source>Indicates that a destination address is required.</source>
          <target state="translated">대상 주소가 필요함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65b88689f4254cf59cbd36c90757eba4ed54d095" translate="yes" xml:space="preserve">
          <source>Indicates that a device or resource is busy.</source>
          <target state="translated">장치 또는 리소스가 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9096f517c393ffbea05056d33a410bb9d60b9052" translate="yes" xml:space="preserve">
          <source>Indicates that a file descriptor is not valid.</source>
          <target state="translated">파일 디스크립터가 유효하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="077d00dbf6c0ccd17eaf6e1e436cd24460670b70" translate="yes" xml:space="preserve">
          <source>Indicates that a function call was interrupted.</source>
          <target state="translated">함수 호출이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32434c08cff7624431ad07e73db693f189e5d592" translate="yes" xml:space="preserve">
          <source>Indicates that a function has not been implemented.</source>
          <target state="translated">기능이 구현되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74b21789e4d047a87bbefcae69e223e57c0e7bc1" translate="yes" xml:space="preserve">
          <source>Indicates that a given operation is not supported.</source>
          <target state="translated">지정된 작업이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08aa9ba556ae45765e72b0f04829db3b1e21a970" translate="yes" xml:space="preserve">
          <source>Indicates that a given protocol is not available.</source>
          <target state="translated">주어진 프로토콜을 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ccae215e314e41ad23dfb2f6f21781ee668e8a7" translate="yes" xml:space="preserve">
          <source>Indicates that a given resource is not a stream.</source>
          <target state="translated">주어진 자원이 스트림이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="922181aef7cb91ecc745d786636e602f8d8746de" translate="yes" xml:space="preserve">
          <source>Indicates that a graceful shutdown is in progress.</source>
          <target state="translated">정상 종료가 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cfcd2648b9d53561c3025491875a16bef0d4576" translate="yes" xml:space="preserve">
          <source>Indicates that a multihop was attempted.</source>
          <target state="translated">멀티 홉이 시도되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="372b49dc7ed23c93af3008079025984775b9a0a1" translate="yes" xml:space="preserve">
          <source>Indicates that a name cannot be translated.</source>
          <target state="translated">이름을 번역 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb0450ee237990615ef0438fa979bfc59059b2b2" translate="yes" xml:space="preserve">
          <source>Indicates that a name was too long.</source>
          <target state="translated">이름이 너무 길 었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b454765c5ab209985df1dbfb4d65a1bff4292245" translate="yes" xml:space="preserve">
          <source>Indicates that a network host is down.</source>
          <target state="translated">네트워크 호스트가 다운되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5bcf54d6293dc7770b625573d31b031e6f7b608c" translate="yes" xml:space="preserve">
          <source>Indicates that a program is not valid JavaScript. These errors may only be generated and propagated as a result of code evaluation. Code evaluation may happen as a result of &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, or &lt;a href=&quot;vm&quot;&gt;vm&lt;/a&gt;. These errors are almost always indicative of a broken program.</source>
          <target state="translated">Indicates that a program is not valid JavaScript. These errors may only be generated and propagated as a result of code evaluation. Code evaluation may happen as a result of &lt;code&gt;eval&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; , or &lt;a href=&quot;vm&quot;&gt;vm&lt;/a&gt;. These errors are almost always indicative of a broken program.</target>
        </trans-unit>
        <trans-unit id="830228d8de255623ef067539c11b71452b1b48e0" translate="yes" xml:space="preserve">
          <source>Indicates that a protocol is not supported.</source>
          <target state="translated">프로토콜이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb0db3310f6fa82a141f97f8c665cfadbcabb020" translate="yes" xml:space="preserve">
          <source>Indicates that a provided argument is not an allowable type. For example, passing a function to a parameter which expects a string would be a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">Indicates that a provided argument is not an allowable type. For example, passing a function to a parameter which expects a string would be a &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97014940f0f7f3168721a0513da09d5c372e74a" translate="yes" xml:space="preserve">
          <source>Indicates that a provided argument was not within the set or range of acceptable values for a function; whether that is a numeric range, or outside the set of options for a given function parameter.</source>
          <target state="translated">Indicates that a provided argument was not within the set or range of acceptable values for a function; whether that is a numeric range, or outside the set of options for a given function parameter.</target>
        </trans-unit>
        <trans-unit id="a2d0760b68dc2b9e3234f32c458f8a15a66f253a" translate="yes" xml:space="preserve">
          <source>Indicates that a resource deadlock has been avoided.</source>
          <target state="translated">리소스 교착 상태를 피했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57423d447a54dca4cdf2140de632822c67c31e39" translate="yes" xml:space="preserve">
          <source>Indicates that a resource is temporarily unavailable.</source>
          <target state="translated">리소스를 일시적으로 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c0b30d5efeba61a960acda84ef5df098d46eae0f" translate="yes" xml:space="preserve">
          <source>Indicates that a service was not found.</source>
          <target state="translated">서비스를 찾을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2128a64f48d84403ea51f2253aaedfb90b12afd6" translate="yes" xml:space="preserve">
          <source>Indicates that a text file is busy.</source>
          <target state="translated">텍스트 파일이 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3789cc087d5c8e5368437244d2068b7da97884fe" translate="yes" xml:space="preserve">
          <source>Indicates that a value is too large to be stored in a given data type.</source>
          <target state="translated">지정된 데이터 유형에 저장하기에 값이 너무 큼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="119dde472605c62e07c67fc1eb210d45a22024ad" translate="yes" xml:space="preserve">
          <source>Indicates that an argument is out of the domain of the function.</source>
          <target state="translated">인수가 함수의 도메인 외부에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ba87fc5d415a17cd82523be1ea2df374e0511f76" translate="yes" xml:space="preserve">
          <source>Indicates that an attempt is being made to access a variable that is not defined. Such errors commonly indicate typos in code, or an otherwise broken program.</source>
          <target state="translated">Indicates that an attempt is being made to access a variable that is not defined. Such errors commonly indicate typos in code, or an otherwise broken program.</target>
        </trans-unit>
        <trans-unit id="206c12d38e5f031ad2d2a6389b829af57d9dcd48" translate="yes" xml:space="preserve">
          <source>Indicates that an invalid argument was passed.</source>
          <target state="translated">유효하지 않은 인수가 전달되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="18f885333d175807022b890e71c998dfc2743f45" translate="yes" xml:space="preserve">
          <source>Indicates that an invalid argument was provided.</source>
          <target state="translated">잘못된 인수가 제공되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b66800334e222058ef0de4a3087566910745cd0d" translate="yes" xml:space="preserve">
          <source>Indicates that an operation cannot be completed due to an invalid state. For instance, an object may have already been destroyed, or may be performing another operation.</source>
          <target state="translated">잘못된 상태로 인해 작업을 완료 할 수 없음을 나타냅니다. 예를 들어, 객체가 이미 파괴되었거나 다른 작업을 수행하고있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39125118a5a05fdb14d46044b0ea226b675a9877" translate="yes" xml:space="preserve">
          <source>Indicates that an operation has been canceled.</source>
          <target state="translated">작업이 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1d4a2a79fb94045c9c939b6febc16183fe9de98" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is already in progress.</source>
          <target state="translated">작업이 이미 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="948ed5bc8d3bcef9cb214d0bff38ef1f9cbb6092" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is currently in progress.</source>
          <target state="translated">작업이 현재 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="986c5f3c1884501bbd01dbd74ec96d7ee20da1ba" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is not supported on the socket. Although &lt;code&gt;ENOTSUP&lt;/code&gt; and &lt;code&gt;EOPNOTSUPP&lt;/code&gt; have the same value on Linux, according to POSIX.1 these error values should be distinct.)</source>
          <target state="translated">Indicates that an operation is not supported on the socket. Although &lt;code&gt;ENOTSUP&lt;/code&gt; and &lt;code&gt;EOPNOTSUPP&lt;/code&gt; have the same value on Linux, according to POSIX.1 these error values should be distinct.)</target>
        </trans-unit>
        <trans-unit id="9c9fc2a88443f1bd9bcd796a3c09a586342edc14" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is not supported on the socket. Note that while &lt;code&gt;ENOTSUP&lt;/code&gt; and &lt;code&gt;EOPNOTSUPP&lt;/code&gt; have the same value on Linux, according to POSIX.1 these error values should be distinct.)</source>
          <target state="translated">소켓에서 작업이 지원되지 않음을 나타냅니다. 반면 유의 &lt;code&gt;ENOTSUP&lt;/code&gt; 및 &lt;code&gt;EOPNOTSUPP&lt;/code&gt; 는 POSIX.1에있어서, 리눅스에서 동일한 값을 가지고 이러한 에러 값은 구별되어야한다.)</target>
        </trans-unit>
        <trans-unit id="4c078047af5f70ba3758bfb52a630d790c966eef" translate="yes" xml:space="preserve">
          <source>Indicates that an operation was canceled.</source>
          <target state="translated">작업이 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e4c46f02c3fe5b062d6dee34e96956cdbf1d2ef" translate="yes" xml:space="preserve">
          <source>Indicates that data cannot be sent after the socket has been shutdown.</source>
          <target state="translated">소켓이 종료 된 후 데이터를 전송할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d4b71c7fe6eb8dcca0374a54346d6d8ee080a7d" translate="yes" xml:space="preserve">
          <source>Indicates that no buffer space is available.</source>
          <target state="translated">사용 가능한 버퍼 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb5fe0bc009a449b0c131d1b39cee3df3ec53be6" translate="yes" xml:space="preserve">
          <source>Indicates that no message is available on the stream head read queue.</source>
          <target state="translated">스트림 헤드 읽기 큐에 사용 가능한 메시지가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76b762b35b459e2a3f4130aaecebcc05d526dd1d" translate="yes" xml:space="preserve">
          <source>Indicates that successful WSAStartup has not yet been performed.</source>
          <target state="translated">성공적인 WSAStartup이 아직 수행되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48d443e903069b79fc6fc8e876cd1f59a55ab321" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;winsock.dll&lt;/code&gt; version is out of range.</source>
          <target state="translated">&lt;code&gt;winsock.dll&lt;/code&gt; 버전이 범위를 벗어 났음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8b67731347b7d3d1a2fb104a016252967ec1f8a" translate="yes" xml:space="preserve">
          <source>Indicates that the address family is not supported.</source>
          <target state="translated">주소 패밀리가 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5593d5f8a211a9b9a1628f4eb1448ba6b26682d7" translate="yes" xml:space="preserve">
          <source>Indicates that the call was canceled.</source>
          <target state="translated">통화가 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0a53ecfeb6b859c1766e6952e74ee72db93b25b" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been aborted by the network.</source>
          <target state="translated">네트워크에 의해 연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="695ee1b1d84ae237c8c3346f15676398969a0d84" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been aborted.</source>
          <target state="translated">연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8362bc4ab7de1fd6ca1112c54f2f53624fc425a" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been refused.</source>
          <target state="translated">연결이 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="757641a9b638d2123741484401860c5f6d474ad0" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been reset by the peer.</source>
          <target state="translated">피어가 연결을 재설정했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e3ae37829bc190196d8da2831b4c0f75007675de" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has timed out.</source>
          <target state="translated">연결 시간이 초과되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b4be4d3afaa2e5f45d481ca27450e687b555f25" translate="yes" xml:space="preserve">
          <source>Indicates that the connection timed out.</source>
          <target state="translated">연결 시간이 초과되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63d73aaa34d8df5ee63adbb0894f6278dfec083d" translate="yes" xml:space="preserve">
          <source>Indicates that the directory is not empty.</source>
          <target state="translated">디렉토리가 비어 있지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e46d1e52d341e3f224dfa62b18df35ba474687e5" translate="yes" xml:space="preserve">
          <source>Indicates that the disk quota has been exceeded.</source>
          <target state="translated">디스크 할당량을 초과했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="161c3595104196dd948b18febc343f1bd46f25c7" translate="yes" xml:space="preserve">
          <source>Indicates that the file already exists.</source>
          <target state="translated">파일이 이미 존재 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a60ba5dd633cddcea59d035cdabd5b096d7d3e9a" translate="yes" xml:space="preserve">
          <source>Indicates that the file handle is stale.</source>
          <target state="translated">파일 핸들이 오래되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="855b2f5e83d5f45403266942ed6a78a8e48438fd" translate="yes" xml:space="preserve">
          <source>Indicates that the file is too large.</source>
          <target state="translated">파일이 너무 크다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40663f45ce87393265672016c54db313ad1a6e64" translate="yes" xml:space="preserve">
          <source>Indicates that the file system is read only.</source>
          <target state="translated">파일 시스템이 읽기 전용임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e2436e26e43b92563a743feba4b113fa8a275c36" translate="yes" xml:space="preserve">
          <source>Indicates that the filename is too long.</source>
          <target state="translated">파일 이름이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="089cc30b91254f5c76ce11943c070ea4bb9e4ffe" translate="yes" xml:space="preserve">
          <source>Indicates that the given item is not a socket.</source>
          <target state="translated">주어진 항목이 소켓이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="55d9efc8d6c36c8b3a99098120e3624ebd4ee169" translate="yes" xml:space="preserve">
          <source>Indicates that the host is unreachable.</source>
          <target state="translated">호스트에 연결할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6deb274595ac102e6a95cf0fda8844325c2402b2" translate="yes" xml:space="preserve">
          <source>Indicates that the identifier has been removed.</source>
          <target state="translated">식별자가 제거되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16385ed77106de084d977545579771db76e25687" translate="yes" xml:space="preserve">
          <source>Indicates that the item is remote.</source>
          <target state="translated">항목이 원격임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd0453304f970d9c1105ea3bd64f4cc2e4c65c32" translate="yes" xml:space="preserve">
          <source>Indicates that the list of arguments is longer than expected.</source>
          <target state="translated">인수 목록이 예상보다 길다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfafda04ebb20ac0339f69bfb2547f21a46f2b4c" translate="yes" xml:space="preserve">
          <source>Indicates that the message size is too long.</source>
          <target state="translated">메시지 크기가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="28f8f8a59da191885b3db8e166955be99443a142" translate="yes" xml:space="preserve">
          <source>Indicates that the network address family is not supported.</source>
          <target state="translated">네트워크 주소 제품군이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1b3a54983042b769b394e9481c90955db44eede" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is already in use.</source>
          <target state="translated">네트워크 주소가 이미 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f10c1721305ff9e8e66fc7ac1a7b82f41551e9d" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is currently unavailable for use.</source>
          <target state="translated">네트워크 주소를 현재 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a794b8e798681860dc3c2cd356736564119b7aaa" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is not available.</source>
          <target state="translated">네트워크 주소를 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b452c6966555edcc5055e10c8498f2a68f0760bc" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been aborted.</source>
          <target state="translated">네트워크 연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4764d277de78c1ce7c30015888e50a4502c04cda" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been refused.</source>
          <target state="translated">네트워크 연결이 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9b9818c6db8926eb6f8490fe27a113f4e4f48bd3" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been reset.</source>
          <target state="translated">네트워크 연결이 재설정되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0e4630ae08750c7cc87ea20c36c05978a40c3365" translate="yes" xml:space="preserve">
          <source>Indicates that the network is down.</source>
          <target state="translated">네트워크가 다운되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4af29b3221c7857a372f20709460cf0cf423ed12" translate="yes" xml:space="preserve">
          <source>Indicates that the network is unreachable.</source>
          <target state="translated">네트워크에 연결할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="368c2e27b0922fb850ee9cc185aaaabf0f6f0c72" translate="yes" xml:space="preserve">
          <source>Indicates that the network subsystem is not ready.</source>
          <target state="translated">네트워크 서브 시스템이 준비되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="383ae045925743a63505cb92d9281c853dfbcc7c" translate="yes" xml:space="preserve">
          <source>Indicates that the operation did not have sufficient permissions.</source>
          <target state="translated">작업에 충분한 권한이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2bcee5ac45f4a21f13696f8ffe7c93a2d766ac8a" translate="yes" xml:space="preserve">
          <source>Indicates that the operation is not permitted.</source>
          <target state="translated">작업이 허용되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65f9f362c2c3c2f761dab77a4a911af304ad3f33" translate="yes" xml:space="preserve">
          <source>Indicates that the operation is not supported.</source>
          <target state="translated">작업이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="776c0d89c093c17f22b7b6705dc7e7960302d908" translate="yes" xml:space="preserve">
          <source>Indicates that the operation would block.</source>
          <target state="translated">작업이 차단됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e117af40033e88e685ebc9243ba8656b98dee296" translate="yes" xml:space="preserve">
          <source>Indicates that the path is a directory.</source>
          <target state="translated">경로가 디렉토리임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="701e0fe25025bc13b6c3ae1b84ed6ee66e9cf69e" translate="yes" xml:space="preserve">
          <source>Indicates that the path is not a directory.</source>
          <target state="translated">경로가 디렉토리가 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d5bc9d82c613e54c1df8c0723a4c03f1298377f" translate="yes" xml:space="preserve">
          <source>Indicates that the procedure call table is invalid.</source>
          <target state="translated">프로 시저 호출 테이블이 유효하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03a40bb10c80e6514013b0ad35fa8d777655f104" translate="yes" xml:space="preserve">
          <source>Indicates that the protocol family is not supported.</source>
          <target state="translated">프로토콜 제품군이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71af43ae58a0ce69e6cde0af5f6e86a43cb92527" translate="yes" xml:space="preserve">
          <source>Indicates that the protocol is not supported.</source>
          <target state="translated">프로토콜이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96a23e49b5ed1e325f70e865582ab8264afc3fa6" translate="yes" xml:space="preserve">
          <source>Indicates that the provided message is too long.</source>
          <target state="translated">제공된 메시지가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="74bff985c66849e5fa9d2c2e0ac7cfbb7ceeaf1f" translate="yes" xml:space="preserve">
          <source>Indicates that the resource is not a socket.</source>
          <target state="translated">자원이 소켓이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d33c873c0e43a3d1c20a25c9f226c7397de4abc4" translate="yes" xml:space="preserve">
          <source>Indicates that the results are too large.</source>
          <target state="translated">결과가 너무 크다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bcf3dc9f9254b168e5ca41afd9d2992ac56a9e00" translate="yes" xml:space="preserve">
          <source>Indicates that the service provider failed to initialized.</source>
          <target state="translated">서비스 제공 업체 초기화에 실패했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef5ae11922fe267f93483559945ea71416b14b63" translate="yes" xml:space="preserve">
          <source>Indicates that the socket already has a pending connection in progress.</source>
          <target state="translated">소켓에 이미 보류중인 연결이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="da9a9c897b5c353995793f4224f6105691fd33a8" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is already connected.</source>
          <target state="translated">소켓이 이미 연결되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d63328104df6e2b2399694396579fe9ce96abe0f" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is connected.</source>
          <target state="translated">소켓이 연결되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a4539fe8fe18ebf237948a7033f92ffe07cf5b8" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is not connected.</source>
          <target state="translated">소켓이 연결되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4574e95a6c77d72a0a44c095218843f94a28bb70" translate="yes" xml:space="preserve">
          <source>Indicates that the socket type is not supported.</source>
          <target state="translated">소켓 유형이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f8a7729a563a492b558759c17c48de2ac002c94" translate="yes" xml:space="preserve">
          <source>Indicates that the the response is completed, or its underlying connection was terminated prematurely (before the response completion).</source>
          <target state="translated">Indicates that the the response is completed, or its underlying connection was terminated prematurely (before the response completion).</target>
        </trans-unit>
        <trans-unit id="b14389542f80e2a560b89ba1bb7a23334b01d4c1" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying &lt;a href=&quot;#http2_class_http2stream&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt; was closed. Just like &lt;code&gt;'end'&lt;/code&gt;, this event occurs only once per response.</source>
          <target state="translated">기본 &lt;a href=&quot;#http2_class_http2stream&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 닫 혔음을 나타냅니다 . 마찬가지로 &lt;code&gt;'end'&lt;/code&gt; 이 이벤트는 응답 당 한 번만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dfe895c11954545a14b05bd8ad28fa8a7ef0c8b5" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying &lt;a href=&quot;#http2_class_http2stream&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt; was terminated before &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; was called or able to flush.</source>
          <target state="translated">Indicates that the underlying &lt;a href=&quot;#http2_class_http2stream&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; was terminated before &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; was called or able to flush.</target>
        </trans-unit>
        <trans-unit id="6a4be62dc021781f1f7331af72972eee9db55491" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying &lt;a href=&quot;http2&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt; was terminated before &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; was called or able to flush.</source>
          <target state="translated">&lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 가 호출되거나 플러시 되기 전에 기본 &lt;a href=&quot;http2&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 종료 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7d37a8f24a3523e9d164fbb58172c9cd00aa98d6" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying connection was closed.</source>
          <target state="translated">기본 연결이 닫 혔음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19e0d6007f4cfb102172b1f94dcbf1507928863f" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying connection was terminated.</source>
          <target state="translated">기본 연결이 종료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="260e1df33ddcd4e82330898db6a7ca89ab095d5c" translate="yes" xml:space="preserve">
          <source>Indicates that the user quota has been exceeded.</source>
          <target state="translated">사용자 할당량을 초과했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c18f1d989cebb9a5ccb0014b0a3b804ab18c29c8" translate="yes" xml:space="preserve">
          <source>Indicates that there are no child processes.</source>
          <target state="translated">자식 프로세스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89b994954e043610752ae496b165c4ad0cfacabb" translate="yes" xml:space="preserve">
          <source>Indicates that there are no locks available.</source>
          <target state="translated">사용 가능한 잠금이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6614378fd3d8db903142159b891610453273befe" translate="yes" xml:space="preserve">
          <source>Indicates that there are no more results.</source>
          <target state="translated">더 이상 결과가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c2f963abe2e3b2191a35765acbcd9088625836c" translate="yes" xml:space="preserve">
          <source>Indicates that there are no stream resources available.</source>
          <target state="translated">사용 가능한 스트림 리소스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f9a897a9242c6f8deaa685d649f1f37446fe4f32" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many hard links to a file.</source>
          <target state="translated">파일에 대한 하드 링크가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e28f98082ba14f699b932ee58bac27df4cf4769d" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many open files.</source>
          <target state="translated">열린 파일이 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f92b6f438bbbad6dd4b5c6e5240708cfc537fc1f" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many processes.</source>
          <target state="translated">프로세스가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71d85f876e9626a6491e65d612e9b483bfa7b9cd" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many references.</source>
          <target state="translated">참조가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="61082c259368a9f710adafe9a304001eb1fee6c5" translate="yes" xml:space="preserve">
          <source>Indicates that there is currently no data available and to try the operation again later.</source>
          <target state="translated">현재 사용 가능한 데이터가 없으며 나중에 작업을 다시 시도해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b83fced05951abf5691548b4cd2103feaf2c694a" translate="yes" xml:space="preserve">
          <source>Indicates that there is no buffer space available.</source>
          <target state="translated">사용 가능한 버퍼 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="82fb1de123b047874668f6b2b7144fbdb954fcea" translate="yes" xml:space="preserve">
          <source>Indicates that there is no data available and to try the operation again later.</source>
          <target state="translated">Indicates that there is no data available and to try the operation again later.</target>
        </trans-unit>
        <trans-unit id="976457834d5fc65d10eefc909f9b879b0f79e739" translate="yes" xml:space="preserve">
          <source>Indicates that there is no message of the desired type.</source>
          <target state="translated">원하는 유형의 메시지가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="22073a072089d5c0ffc9dce772a1a7ec08c2c53f" translate="yes" xml:space="preserve">
          <source>Indicates that there is no route to a network host.</source>
          <target state="translated">네트워크 호스트에 대한 경로가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ee2f6e7184bd083b8b8ad9d4456fd58b427c7808" translate="yes" xml:space="preserve">
          <source>Indicates that there is no space available on the device.</source>
          <target state="translated">장치에 사용 가능한 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7853ff79915590151db29acfe2f8a05e4231bf78" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such device.</source>
          <target state="translated">해당 장치가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="feb99cc3620ddf00d8a100209370656211892cda" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such file or directory.</source>
          <target state="translated">그러한 파일이나 디렉토리가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46c76f2198f24358bd4c816200de1fcb8af12a78" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such process.</source>
          <target state="translated">그러한 프로세스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27353c844a6a35a27649ab175b0eb68661ef531a" translate="yes" xml:space="preserve">
          <source>Indicates that there is not enough space.</source>
          <target state="translated">공간이 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="915ee7ece9b652c3f36d18624a65020ff4d4c2dc" translate="yes" xml:space="preserve">
          <source>Indicates the failure of an assertion. All errors thrown by the &lt;code&gt;assert&lt;/code&gt; module will be instances of the &lt;code&gt;AssertionError&lt;/code&gt; class.</source>
          <target state="translated">Indicates the failure of an assertion. All errors thrown by the &lt;code&gt;assert&lt;/code&gt; module will be instances of the &lt;code&gt;AssertionError&lt;/code&gt; class.</target>
        </trans-unit>
        <trans-unit id="1cff06c2c1c9eb44ded32d50b847319e14be81c0" translate="yes" xml:space="preserve">
          <source>Indicates the failure of an assertion. For details, see &lt;a href=&quot;assert#assert_class_assert_assertionerror&quot;&gt;&lt;code&gt;Class: assert.AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Indicates the failure of an assertion. For details, see &lt;a href=&quot;assert#assert_class_assert_assertionerror&quot;&gt; &lt;code&gt;Class: assert.AssertionError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="da5e1a3736d4e24ec12fb4f0df216bed85b2f1b8" translate="yes" xml:space="preserve">
          <source>Indicates the wrong protocol type for the socket.</source>
          <target state="translated">소켓에 대한 잘못된 프로토콜 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8d7594bb044a48ce5960ed97b1c5e185a94eb43" translate="yes" xml:space="preserve">
          <source>Indicates the wrong type of protocol for a socket.</source>
          <target state="translated">소켓에 대한 잘못된 프로토콜 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33cd43c392b2eaab3b1a94dfcc9ae9f8cb85a5fb" translate="yes" xml:space="preserve">
          <source>Indicates too many levels of symbolic links in a path.</source>
          <target state="translated">경로에 너무 많은 레벨의 기호 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1121a0a8baa36b282377bd118336f82d59471e5" translate="yes" xml:space="preserve">
          <source>Indicates too many open files in the system.</source>
          <target state="translated">시스템에서 열린 파일이 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f793ef295cef1dc50901d3c108997d4015097940" translate="yes" xml:space="preserve">
          <source>Indicates whether a callback has been set using &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt;&lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt; &lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt; &lt;/a&gt; 사용하여 콜백이 설정되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="84abc9bf3d68bcff752515aa207501469e0aa0e9" translate="yes" xml:space="preserve">
          <source>Indicates whether the &lt;code&gt;Http2Session&lt;/code&gt; is currently waiting for acknowledgment of a sent &lt;code&gt;SETTINGS&lt;/code&gt; frame. Will be &lt;code&gt;true&lt;/code&gt; after calling the &lt;code&gt;http2session.settings()&lt;/code&gt; method. Will be &lt;code&gt;false&lt;/code&gt; once all sent &lt;code&gt;SETTINGS&lt;/code&gt; frames have been acknowledged.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 이 현재 전송 된 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임의 승인을 기다리고 있는지 여부를 나타냅니다 . 수 있을까요 &lt;code&gt;true&lt;/code&gt; 호출 후 &lt;code&gt;http2session.settings()&lt;/code&gt; 메소드를. 있을 것인가 &lt;code&gt;false&lt;/code&gt; 모든 전송하면 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임이 인정되고있다.</target>
        </trans-unit>
        <trans-unit id="42c22cb8018104ad4a34b76968a323a00574ca11" translate="yes" xml:space="preserve">
          <source>Indications that a link has been severed.</source>
          <target state="translated">링크가 끊 겼음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="f3b4641545ee175acfc4265f97a1626ea40f907b" translate="yes" xml:space="preserve">
          <source>Information about the cipher algorithm selected for the session.</source>
          <target state="translated">세션에 대해 선택한 암호 알고리즘에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="2c6d1039846355bb3c61f905e9d3ba65581c1937" translate="yes" xml:space="preserve">
          <source>Informational HTTP status codes (&lt;code&gt;1xx&lt;/code&gt;) may not be set as the response status code on HTTP/2 responses.</source>
          <target state="translated">정보 용 HTTP 상태 코드 ( &lt;code&gt;1xx&lt;/code&gt; )는 HTTP / 2 응답에서 응답 상태 코드로 설정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d409ba6d52f3a405cf5f9a0291be6c9569d3e96" translate="yes" xml:space="preserve">
          <source>Informational Headers</source>
          <target state="translated">정보 헤더</target>
        </trans-unit>
        <trans-unit id="454bff202859695294ed0d692a79b0cd3d986d67" translate="yes" xml:space="preserve">
          <source>Informational Headers: Any response headers transmitted within a block of headers using a &lt;code&gt;1xx&lt;/code&gt; status code.</source>
          <target state="translated">정보 헤더 : &lt;code&gt;1xx&lt;/code&gt; 상태 코드를 사용하여 헤더 블록 내에서 전송되는 모든 응답 헤더 .</target>
        </trans-unit>
        <trans-unit id="10f35ea53e49802f840775c3d4b91ff4f9c6035d" translate="yes" xml:space="preserve">
          <source>Inherit the prototype methods from one &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor&quot;&gt;constructor&lt;/a&gt; into another. The prototype of &lt;code&gt;constructor&lt;/code&gt; will be set to a new object created from &lt;code&gt;superConstructor&lt;/code&gt;.</source>
          <target state="translated">한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor&quot;&gt;생성자&lt;/a&gt; 에서 다른 생성자 로 프로토 타입 메소드를 상속하십시오 . &lt;code&gt;constructor&lt;/code&gt; 의 프로토 타입은 &lt;code&gt;superConstructor&lt;/code&gt; 에서 생성 된 새 객체로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="905527bad8a55f9475f8845932d0fc433480e08e" translate="yes" xml:space="preserve">
          <source>Initial Headers</source>
          <target state="translated">초기 헤더</target>
        </trans-unit>
        <trans-unit id="b0443bd0441bc30d5c3dd2144ee4b77afc32a9f2" translate="yes" xml:space="preserve">
          <source>Initial Headers: HTTP request or response headers</source>
          <target state="translated">초기 헤더 : HTTP 요청 또는 응답 헤더</target>
        </trans-unit>
        <trans-unit id="5c8ecdfbfc1dd50dc01b89601fe8f8be9beeb66d" translate="yes" xml:space="preserve">
          <source>Initialization of an asynchronous crypto operation failed.</source>
          <target state="translated">비동기 암호화 작업 초기화에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="f5fa5412f2cf16eed186105984f1a62b5cc7c1e6" translate="yes" xml:space="preserve">
          <source>Initialization of the crypto subsystem failed.</source>
          <target state="translated">암호화 하위 시스템 초기화에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="1c605479b3766044fe5d8c5e766dca7dfa29eac8" translate="yes" xml:space="preserve">
          <source>Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; it is important to remember that an attacker must not be able to predict ahead of time what a given IV will be.</source>
          <target state="translated">초기화 벡터는 예측할 수없고 고유해야합니다. 이상적으로는 암호로 임의적입니다. 비밀 일 필요는 없습니다. IV는 일반적으로 암호화되지 않은 암호문 메시지에 추가됩니다. 무언가가 예측할 수없고 독특해야하지만 비밀 일 필요는 없다는 것이 모순 될 수 있습니다. 공격자는 주어진 IV가 무엇인지 미리 예측할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="c95e5b0cef8d79d14d3cfbaa8b47cbfec97c8155" translate="yes" xml:space="preserve">
          <source>Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; remember that an attacker must not be able to predict ahead of time what a given IV will be.</source>
          <target state="translated">Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; remember that an attacker must not be able to predict ahead of time what a given IV will be.</target>
        </trans-unit>
        <trans-unit id="a81cf0d3001b974f4ab0ead2bdb88c2f9cb54eeb" translate="yes" xml:space="preserve">
          <source>Initializes a history log file for the REPL instance. When executing the Node.js binary and using the command line REPL, a history file is initialized by default. However, this is not the case when creating a REPL programmatically. Use this method to initialize a history log file when working with REPL instances programmatically.</source>
          <target state="translated">REPL 인스턴스의 히스토리 로그 파일을 초기화합니다. Node.js 바이너리를 실행하고 명령 행 REPL을 사용하면 히스토리 파일이 기본적으로 초기화됩니다. 그러나 프로그래밍 방식으로 REPL을 작성하는 경우에는 그렇지 않습니다. 프로그래밍 방식으로 REPL 인스턴스로 작업 할 때이 방법을 사용하여 기록 로그 파일을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="424343ae6998b53b7b5197e4547912f100930a60" translate="yes" xml:space="preserve">
          <source>Initializes a history log file for the REPL instance. When executing the Node.js binary and using the command-line REPL, a history file is initialized by default. However, this is not the case when creating a REPL programmatically. Use this method to initialize a history log file when working with REPL instances programmatically.</source>
          <target state="translated">Initializes a history log file for the REPL instance. When executing the Node.js binary and using the command-line REPL, a history file is initialized by default. However, this is not the case when creating a REPL programmatically. Use this method to initialize a history log file when working with REPL instances programmatically.</target>
        </trans-unit>
        <trans-unit id="a4cdbd02ba690df84da7adc74e183f564120378f" translate="yes" xml:space="preserve">
          <source>Initiate a TCP connection on the given socket.</source>
          <target state="translated">주어진 소켓에서 TCP 연결을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="0d5479f7f1139e75134b5638b844d0e258a74f35" translate="yes" xml:space="preserve">
          <source>Initiate a connection on a given socket.</source>
          <target state="translated">주어진 소켓에서 연결을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="810ba9b70df6c10d966779b0bafa88ded886aa59" translate="yes" xml:space="preserve">
          <source>Initiate a connection on a given socket. Normally this method is not needed, the socket should be created and opened with &lt;a href=&quot;#net_net_createconnection&quot;&gt;&lt;code&gt;net.createConnection()&lt;/code&gt;&lt;/a&gt;. Use this only when implementing a custom Socket.</source>
          <target state="translated">주어진 소켓에서 연결을 시작하십시오. 일반적으로이 메소드는 필요하지 않습니다. 소켓은 &lt;a href=&quot;#net_net_createconnection&quot;&gt; &lt;code&gt;net.createConnection()&lt;/code&gt; &lt;/a&gt; 으로 작성하고 열어야 합니다. 커스텀 소켓을 구현할 때만 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6043ac861d8556db1f1186a96ea25461c657c5ba" translate="yes" xml:space="preserve">
          <source>Initiate an &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; connection on the given socket.</source>
          <target state="translated">주어진 소켓에서 &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; 연결을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="d640515b7b587180776147c1f262a31f611022ef" translate="yes" xml:space="preserve">
          <source>Initiates QuicSession key update.</source>
          <target state="translated">QuicSession 키 업데이트를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="586faf8bd3a03c92f8cb24c136ad18b37d24ab58" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection.</source>
          <target state="translated">TCP 연결을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="53a4de7eba42de63d90bb804549dc818d7f966d1" translate="yes" xml:space="preserve">
          <source>Initiates a push stream. The callback is invoked with the new &lt;code&gt;Http2Stream&lt;/code&gt; instance created for the push stream passed as the second argument, or an &lt;code&gt;Error&lt;/code&gt; passed as the first argument.</source>
          <target state="translated">푸시 스트림을 시작합니다. 콜백은 두 번째 인수로 전달 된 푸시 스트림 또는 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 대해 작성된 새 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c2bf8ae9d7cffd1a2491dca9b8c27dd7928ed38" translate="yes" xml:space="preserve">
          <source>Initiates a response whose data is read from the given file descriptor. No validation is performed on the given file descriptor. If an error occurs while attempting to read data using the file descriptor, the &lt;code&gt;Http2Stream&lt;/code&gt; will be closed using an &lt;code&gt;RST_STREAM&lt;/code&gt; frame using the standard &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; code.</source>
          <target state="translated">주어진 파일 디스크립터에서 데이터를 읽는 응답을 시작합니다. 지정된 파일 디스크립터에 대한 유효성 검증이 수행되지 않습니다. 파일 디스크립터를 사용하여 데이터를 읽는 중 오류가 발생 하면 표준 &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; 코드 를 사용하는 &lt;code&gt;RST_STREAM&lt;/code&gt; 프레임을 사용 하여 &lt;code&gt;Http2Stream&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="35fb6e9a05f63492052bc71c81678318b03c33a7" translate="yes" xml:space="preserve">
          <source>Initiates an &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; connection.</source>
          <target state="translated">&lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; 연결을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="26d4e2e6f7bc72aa1b7fe9902a5761b23f342bb5" translate="yes" xml:space="preserve">
          <source>Inodes</source>
          <target state="translated">Inodes</target>
        </trans-unit>
        <trans-unit id="720c091ce87a13844611624e3c634ce2ed5d326a" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Buffer&lt;/code&gt; and &lt;code&gt;Uint8Array&lt;/code&gt; instances passed to the &lt;code&gt;http2.getUnpackedSettings()&lt;/code&gt; API must have a length that is a multiple of six.</source>
          <target state="translated">&lt;code&gt;http2.getUnpackedSettings()&lt;/code&gt; API에 전달 된 입력 &lt;code&gt;Buffer&lt;/code&gt; 및 &lt;code&gt;Uint8Array&lt;/code&gt; 인스턴스 의 길이는 6의 배수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="08ab03b761f96fdd2c5da59a100ff5730e9c4009" translate="yes" xml:space="preserve">
          <source>Inserting the statement &lt;code&gt;debugger;&lt;/code&gt; into the source code of a script will enable a breakpoint at that position in the code:</source>
          <target state="translated">명령문 &lt;code&gt;debugger;&lt;/code&gt; 삽입 스크립트의 소스 코드에 코드의 해당 위치에서 중단 점을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="051747894e566bebff8a6f6ae4afde9c862d5e6c" translate="yes" xml:space="preserve">
          <source>Inspecting linked lists and similar objects is now possible up to the maximum call stack size.</source>
          <target state="translated">최대 연결 스택 크기까지 연결된 목록 및 유사한 객체를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8222c902ae0723e8bb352bb17ed76809e4688165" translate="yes" xml:space="preserve">
          <source>Inspector</source>
          <target state="translated">Inspector</target>
        </trans-unit>
        <trans-unit id="ad8db003f59f527184ade10382360155f5682949" translate="yes" xml:space="preserve">
          <source>Inspector only methods</source>
          <target state="translated">인스펙터 전용 방법</target>
        </trans-unit>
        <trans-unit id="d4894011e9b416e24cf4f9f064f29c68ac3eac26" translate="yes" xml:space="preserve">
          <source>Installing a listener using this symbol does not change the behavior once an &lt;code&gt;'error'&lt;/code&gt; event is emitted, therefore the process will still crash if no regular &lt;code&gt;'error'&lt;/code&gt; listener is installed.</source>
          <target state="translated">Installing a listener using this symbol does not change the behavior once an &lt;code&gt;'error'&lt;/code&gt; event is emitted, therefore the process will still crash if no regular &lt;code&gt;'error'&lt;/code&gt; listener is installed.</target>
        </trans-unit>
        <trans-unit id="31e83acb3d25252952bd8f79f736885ae0f9595f" translate="yes" xml:space="preserve">
          <source>Installing an &lt;code&gt;'uncaughtExceptionMonitor'&lt;/code&gt; listener does not change the behavior once an &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted. The process will still crash if no &lt;code&gt;'uncaughtException'&lt;/code&gt; listener is installed.</source>
          <target state="translated">Installing an &lt;code&gt;'uncaughtExceptionMonitor'&lt;/code&gt; listener does not change the behavior once an &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted. The process will still crash if no &lt;code&gt;'uncaughtException'&lt;/code&gt; listener is installed.</target>
        </trans-unit>
        <trans-unit id="a0cf2d5cc76825e10c97a10dd59da6837fcc0666" translate="yes" xml:space="preserve">
          <source>Installing async hooks via &lt;code&gt;async_hooks.createHook&lt;/code&gt; enables promise execution tracking:</source>
          <target state="translated">&lt;code&gt;async_hooks.createHook&lt;/code&gt; 을 통해 비동기 후크를 설치 하면 약속 실행 추적이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0ffd36feafce2d27574b6db79c98b71558f382af" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#repl_class_replserver&quot;&gt;&lt;code&gt;repl.REPLServer&lt;/code&gt;&lt;/a&gt; support automatic completion of inputs, completion preview, simplistic Emacs-style line editing, multi-line inputs, &lt;a href=&quot;https://en.wikipedia.org/wiki/Z_shell&quot;&gt;ZSH&lt;/a&gt;-like reverse-i-search, &lt;a href=&quot;https://en.wikipedia.org/wiki/Z_shell&quot;&gt;ZSH&lt;/a&gt;-like substring-based history search, ANSI-styled output, saving and restoring current REPL session state, error recovery, and customizable evaluation functions. Terminals that do not support ANSI styles and Emacs-style line editing automatically fall back to a limited feature set.</source>
          <target state="translated">Instances of &lt;a href=&quot;#repl_class_replserver&quot;&gt; &lt;code&gt;repl.REPLServer&lt;/code&gt; &lt;/a&gt; support automatic completion of inputs, completion preview, simplistic Emacs-style line editing, multi-line inputs, &lt;a href=&quot;https://en.wikipedia.org/wiki/Z_shell&quot;&gt;ZSH&lt;/a&gt;-like reverse-i-search, &lt;a href=&quot;https://en.wikipedia.org/wiki/Z_shell&quot;&gt;ZSH&lt;/a&gt;-like substring-based history search, ANSI-styled output, saving and restoring current REPL session state, error recovery, and customizable evaluation functions. Terminals that do not support ANSI styles and Emacs-style line editing automatically fall back to a limited feature set.</target>
        </trans-unit>
        <trans-unit id="5458ffc182cdf6836a16e2f16d8f4bd6d79f5c4e" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#repl_class_replserver&quot;&gt;&lt;code&gt;repl.REPLServer&lt;/code&gt;&lt;/a&gt; support automatic completion of inputs, simplistic Emacs-style line editing, multi-line inputs, ANSI-styled output, saving and restoring current REPL session state, error recovery, and customizable evaluation functions.</source>
          <target state="translated">&lt;a href=&quot;#repl_class_replserver&quot;&gt; &lt;code&gt;repl.REPLServer&lt;/code&gt; &lt;/a&gt; 인스턴스는 입력 자동 완성, 단순한 Emacs 스타일 라인 편집, 멀티 라인 입력, ANSI 스타일 출력, 현재 REPL 세션 상태 저장 및 복원, 오류 복구 및 사용자 정의 가능한 평가 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="94f06ec883aef342f5e087d10776f74fac5e8140" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;BroadcastChannel&lt;/code&gt; allow asynchronous one-to-many communication with all other &lt;code&gt;BroadcastChannel&lt;/code&gt; instances bound to the same channel name.</source>
          <target state="translated">의 인스턴스 &lt;code&gt;BroadcastChannel&lt;/code&gt; 는 다른 모든 비동기 일대 다 통신 할 수 &lt;code&gt;BroadcastChannel&lt;/code&gt; 의 동일한 채널 이름에 바인드 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="b89a320c3f62e6b6ba8e85b021337befc0641078" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;ChildProcess&lt;/code&gt; are not intended to be created directly. Rather, use the &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt;&lt;code&gt;child_process.exec()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#child_process_child_process_execfile_file_args_options_callback&quot;&gt;&lt;code&gt;child_process.execFile()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt; methods to create instances of &lt;code&gt;ChildProcess&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스는 직접 작성하기위한 것이 아닙니다. 대신 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt; &lt;code&gt;child_process.exec()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#child_process_child_process_execfile_file_args_options_callback&quot;&gt; &lt;code&gt;child_process.execFile()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="db1b65a0d3c2528e965754146fd9d0a86600f551" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Duplex&lt;/code&gt; now return &lt;code&gt;true&lt;/code&gt; when checking &lt;code&gt;instanceof stream.Writable&lt;/code&gt;.</source>
          <target state="translated">instance . &lt;code&gt;instanceof stream.Writable&lt;/code&gt; 확인할 때 &lt;code&gt;Duplex&lt;/code&gt; 인스턴스가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8fdd2c2c9379faa14d448a471b59a6faffffb1ed" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Http2SecureServer&lt;/code&gt; are created using the &lt;code&gt;http2.createSecureServer()&lt;/code&gt; function. The &lt;code&gt;Http2SecureServer&lt;/code&gt; class is not exported directly by the &lt;code&gt;http2&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Http2SecureServer&lt;/code&gt; 의 인스턴스는 http2.createSecureServer &lt;code&gt;http2.createSecureServer()&lt;/code&gt; 함수를 사용하여 작성 됩니다. &lt;code&gt;Http2SecureServer&lt;/code&gt; 의 클래스는 직접 내보낼 수 없습니다 &lt;code&gt;http2&lt;/code&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="e618cc6bee9611e42d99ee69ae677154195e8043" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Http2Server&lt;/code&gt; are created using the &lt;code&gt;http2.createServer()&lt;/code&gt; function. The &lt;code&gt;Http2Server&lt;/code&gt; class is not exported directly by the &lt;code&gt;http2&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Http2Server&lt;/code&gt; 인스턴스는 http2.createServer &lt;code&gt;http2.createServer()&lt;/code&gt; 함수를 사용하여 작성 됩니다. &lt;code&gt;Http2Server&lt;/code&gt; 의 클래스는 직접 내보낼 수 없습니다 &lt;code&gt;http2&lt;/code&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="800ee83c789ca3173d0e98447fc49ae8f796f1ae" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;fs.ReadStream&lt;/code&gt; are created and returned using the &lt;a href=&quot;#fs_fs_createreadstream_path_options&quot;&gt;&lt;code&gt;fs.createReadStream()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Instances of &lt;code&gt;fs.ReadStream&lt;/code&gt; are created and returned using the &lt;a href=&quot;#fs_fs_createreadstream_path_options&quot;&gt; &lt;code&gt;fs.createReadStream()&lt;/code&gt; &lt;/a&gt; function.</target>
        </trans-unit>
        <trans-unit id="7adf135f2541749ab0e6b0d183f3e69d29f0948e" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;fs.WriteStream&lt;/code&gt; are created and returned using the &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Instances of &lt;code&gt;fs.WriteStream&lt;/code&gt; are created and returned using the &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; function.</target>
        </trans-unit>
        <trans-unit id="369f68f902069850f471888346c26c220953855e" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;repl.REPLServer&lt;/code&gt; are created using the &lt;a href=&quot;#repl_repl_start_options&quot;&gt;&lt;code&gt;repl.start()&lt;/code&gt;&lt;/a&gt; method or directly using the JavaScript &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">Instances of &lt;code&gt;repl.REPLServer&lt;/code&gt; are created using the &lt;a href=&quot;#repl_repl_start_options&quot;&gt; &lt;code&gt;repl.start()&lt;/code&gt; &lt;/a&gt; method or directly using the JavaScript &lt;code&gt;new&lt;/code&gt; keyword.</target>
        </trans-unit>
        <trans-unit id="c931f1541982a4495922666b7b5bc642601cc990" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;tls.TLSSocket&lt;/code&gt; implement the duplex &lt;a href=&quot;stream#stream_stream&quot;&gt;Stream&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;tls.TLSSocket&lt;/code&gt; 의 인스턴스는 이중 &lt;a href=&quot;stream#stream_stream&quot;&gt;스트림&lt;/a&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="35783666b090e1bcb188e0ff52ae2b546eb2a159" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Buffer&lt;/code&gt; class are similar to arrays of integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; (other integers are coerced to this range by &lt;code&gt;&amp;amp; 255&lt;/code&gt; operation) but correspond to fixed-sized, raw memory allocations outside the V8 heap. The size of the &lt;code&gt;Buffer&lt;/code&gt; is established when it is created and cannot be changed.</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;255&lt;/code&gt; 까지의 정수 배열과 유사하지만 (다른 정수는 &lt;code&gt;&amp;amp; 255&lt;/code&gt; 연산 으로이 범위로 강제 변환 됨 ) V8 힙 외부의 고정 크기 원시 메모리 할당에 해당합니다. &lt;code&gt;Buffer&lt;/code&gt; 의 크기 는 생성 될 때 설정되며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dffd1ef53587360af9f4e464d4d5cf73ae045da0" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Certificate&lt;/code&gt; class can be created using the &lt;code&gt;new&lt;/code&gt; keyword or by calling &lt;code&gt;crypto.Certificate()&lt;/code&gt; as a function:</source>
          <target state="translated">&lt;code&gt;Certificate&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;new&lt;/code&gt; 키워드를 사용하거나 &lt;code&gt;crypto.Certificate()&lt;/code&gt; 를 함수로 호출 하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a67f7f0229202a5e0c59ed378df4ef19e04cdd1" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;ChildProcess&lt;/code&gt; class are &lt;a href=&quot;events#events_class_eventemitter&quot;&gt;&lt;code&gt;EventEmitters&lt;/code&gt;&lt;/a&gt; that represent spawned child processes.</source>
          <target state="translated">&lt;code&gt;ChildProcess&lt;/code&gt; 클래스의 인스턴스 는 생성 된 자식 프로세스를 나타내는 &lt;a href=&quot;events#events_class_eventemitter&quot;&gt; &lt;code&gt;EventEmitters&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9da9ac1fe02f8599e055e564d64abc742cf4f4a5" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;ChildProcess&lt;/code&gt; represent spawned child processes.</source>
          <target state="translated">Instances of the &lt;code&gt;ChildProcess&lt;/code&gt; represent spawned child processes.</target>
        </trans-unit>
        <trans-unit id="e0cc93f3328ea5a0a0adcec2dba75fe3d0516e6a" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Cipher&lt;/code&gt; class are used to encrypt data. The class can be used in one of two ways:</source>
          <target state="translated">&lt;code&gt;Cipher&lt;/code&gt; 클래스의 인스턴스는 데이터를 암호화하는 데 사용됩니다. 이 클래스는 다음 두 가지 방법 중 하나로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adadf4a8671dae9115a1b4925ff5480625d42ff5" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Decipher&lt;/code&gt; class are used to decrypt data. The class can be used in one of two ways:</source>
          <target state="translated">&lt;code&gt;Decipher&lt;/code&gt; 클래스의 인스턴스는 데이터를 해독하는 데 사용됩니다. 이 클래스는 다음 두 가지 방법 중 하나로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c29738f83796b77d7a2afe6dfa6aa91432202d54" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;DiffieHellman&lt;/code&gt; class can be created using the &lt;a href=&quot;#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding&quot;&gt;&lt;code&gt;crypto.createDiffieHellman()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DiffieHellman&lt;/code&gt; 클래스의 인스턴스는 &lt;a href=&quot;#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding&quot;&gt; &lt;code&gt;crypto.createDiffieHellman()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06629143118ba183c91662524da3d6583f95f245" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;ECDH&lt;/code&gt; class can be created using the &lt;a href=&quot;#crypto_crypto_createecdh_curvename&quot;&gt;&lt;code&gt;crypto.createECDH()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;ECDH&lt;/code&gt; 클래스의 인스턴스는 &lt;a href=&quot;#crypto_crypto_createecdh_curvename&quot;&gt; &lt;code&gt;crypto.createECDH()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e19a3efe923bf85bc8b05ac0272473f4501716f9" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;FileHandle&lt;/code&gt; object are created internally by the &lt;code&gt;fsPromises.open()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;FileHandle&lt;/code&gt; 객체의 인스턴스는 &lt;code&gt;fsPromises.open()&lt;/code&gt; 메서드에 의해 내부적으로 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="af20962e987f76605ebbac474846e378dc9efb59" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;http2.Http2Session&lt;/code&gt; class represent an active communications session between an HTTP/2 client and server. Instances of this class are &lt;em&gt;not&lt;/em&gt; intended to be constructed directly by user code.</source>
          <target state="translated">&lt;code&gt;http2.Http2Session&lt;/code&gt; 클래스의 인스턴스 는 HTTP / 2 클라이언트와 서버 간의 활성 통신 세션을 나타냅니다. 이 클래스의 인스턴스는 사용자 코드로 직접 구성 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="432d12dcbaa96cbcfdc7739ae3abf129c909c6a7" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;readline.Interface&lt;/code&gt; class are constructed using the &lt;code&gt;readline.createInterface()&lt;/code&gt; method. Every instance is associated with a single &lt;code&gt;input&lt;/code&gt;&lt;a href=&quot;stream#stream_readable_streams&quot;&gt;Readable&lt;/a&gt; stream and a single &lt;code&gt;output&lt;/code&gt;&lt;a href=&quot;stream#stream_writable_streams&quot;&gt;Writable&lt;/a&gt; stream. The &lt;code&gt;output&lt;/code&gt; stream is used to print prompts for user input that arrives on, and is read from, the &lt;code&gt;input&lt;/code&gt; stream.</source>
          <target state="translated">&lt;code&gt;readline.Interface&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;readline.createInterface()&lt;/code&gt; 메소드를 사용하여 구성됩니다 . 모든 인스턴스는 단일 &lt;code&gt;input&lt;/code&gt; &lt;a href=&quot;stream#stream_readable_streams&quot;&gt;읽기 가능&lt;/a&gt; 스트림 및 단일 &lt;code&gt;output&lt;/code&gt; &lt;a href=&quot;stream#stream_writable_streams&quot;&gt;쓰기 &lt;/a&gt;가능 스트림과 연결됩니다 . &lt;code&gt;output&lt;/code&gt; 스트림에 도착 사용자 입력 용 프롬프트를 인쇄하는 데 사용되며,로부터 판독 &lt;code&gt;input&lt;/code&gt; 스트림.</target>
        </trans-unit>
        <trans-unit id="298dfc9afa41ab353b24ce154f8859bd24d0afe2" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;vm.Script&lt;/code&gt; class contain precompiled scripts that can be executed in specific contexts.</source>
          <target state="translated">Instances of the &lt;code&gt;vm.Script&lt;/code&gt; class contain precompiled scripts that can be executed in specific contexts.</target>
        </trans-unit>
        <trans-unit id="c0a8dd21a7c8c59429281b201339a2209dc5cdab" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;vm.Script&lt;/code&gt; class contain precompiled scripts that can be executed in specific sandboxes (or &quot;contexts&quot;).</source>
          <target state="translated">&lt;code&gt;vm.Script&lt;/code&gt; 클래스의 인스턴스 에는 특정 샌드 박스 (또는 &quot;컨텍스트&quot;)에서 실행할 수있는 미리 컴파일 된 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce65dd9273ad652d638f34de4134789c3e16e945" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;worker.MessageChannel&lt;/code&gt; class represent an asynchronous, two-way communications channel. The &lt;code&gt;MessageChannel&lt;/code&gt; has no methods of its own. &lt;code&gt;new MessageChannel()&lt;/code&gt; yields an object with &lt;code&gt;port1&lt;/code&gt; and &lt;code&gt;port2&lt;/code&gt; properties, which refer to linked &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">&lt;code&gt;worker.MessageChannel&lt;/code&gt; 클래스의 인스턴스 는 비동기 양방향 통신 채널을 나타냅니다. &lt;code&gt;MessageChannel&lt;/code&gt; 은 자신의 어떤 방법이 없습니다. &lt;code&gt;new MessageChannel()&lt;/code&gt; 은 링크 된 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 인스턴스 를 참조하는 &lt;code&gt;port1&lt;/code&gt; 및 &lt;code&gt;port2&lt;/code&gt; 속성을 가진 객체를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7a38e81654aa75e50f8ac4a46d3a4444cd9d971f" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;worker.MessagePort&lt;/code&gt; class represent one end of an asynchronous, two-way communications channel. It can be used to transfer structured data, memory regions and other &lt;code&gt;MessagePort&lt;/code&gt;s between different &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;code&gt;worker.MessagePort&lt;/code&gt; 클래스의 인스턴스 는 비동기 양방향 통신 채널의 한쪽 끝을 나타냅니다. 다른 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 간에 구조화 된 데이터, 메모리 영역 및 기타 &lt;code&gt;MessagePort&lt;/code&gt; 를 전송하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81720bda68cbd9e127cd631462f662a8bd1e1fa9" translate="yes" xml:space="preserve">
          <source>Instances of this class can now be passed to worker threads using &lt;code&gt;postMessage&lt;/code&gt;.</source>
          <target state="translated">Instances of this class can now be passed to worker threads using &lt;code&gt;postMessage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c676be9a0fcb70600a6d6a66e1bc4fb7d9ad4219" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;URLSearchParams&lt;/code&gt; object with a query hash map. The key and value of each property of &lt;code&gt;obj&lt;/code&gt; are always coerced to strings.</source>
          <target state="translated">쿼리 해시 맵을 사용 하여 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화하십시오 . &lt;code&gt;obj&lt;/code&gt; 의 각 속성의 키와 값 은 항상 문자열로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="65181063e2280876fa3f8f363ffe435314f6a6cc" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;URLSearchParams&lt;/code&gt; object with an iterable map in a way that is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;'s constructor. &lt;code&gt;iterable&lt;/code&gt; can be an &lt;code&gt;Array&lt;/code&gt; or any iterable object. That means &lt;code&gt;iterable&lt;/code&gt; can be another &lt;code&gt;URLSearchParams&lt;/code&gt;, in which case the constructor will simply create a clone of the provided &lt;code&gt;URLSearchParams&lt;/code&gt;. Elements of &lt;code&gt;iterable&lt;/code&gt; are key-value pairs, and can themselves be any iterable object.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 의 생성자 와 비슷한 방식으로 반복 가능한 맵 으로 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화합니다 . &lt;code&gt;iterable&lt;/code&gt; 은 &lt;code&gt;Array&lt;/code&gt; 또는 iterable 객체 일 수 있습니다 . 이는 &lt;code&gt;iterable&lt;/code&gt; 이 다른 &lt;code&gt;URLSearchParams&lt;/code&gt; 일 수 있음을 의미하며 ,이 경우 생성자는 제공된 &lt;code&gt;URLSearchParams&lt;/code&gt; 의 복제본을 만들 것 입니다. &lt;code&gt;iterable&lt;/code&gt; 의 요소 는 키-값 쌍이며 반복 가능한 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc82e9b73a75737421b7fc3a88c424c1b841dee" translate="yes" xml:space="preserve">
          <source>Instantiate a new empty &lt;code&gt;URLSearchParams&lt;/code&gt; object.</source>
          <target state="translated">비어있는 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="b21c73c2d5f688055cfa8ed255e3120b2cccea8d" translate="yes" xml:space="preserve">
          <source>Instantiate the module. This must be called after linking has completed (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt;); otherwise it will throw an error. It may also throw an exception if one of the dependencies does not provide an export the parent module requires.</source>
          <target state="translated">모듈을 인스턴스화하십시오. 링크가 완료된 후에 호출되어야합니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; 는 &lt;code&gt;'linked'&lt;/code&gt; 입니다 ). 그렇지 않으면 오류가 발생합니다. 또한 종속 항목 중 하나가 상위 모듈에 필요한 내보내기를 제공하지 않으면 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed39324e841d37c87d9ceaf44bcca4c8c9a4e11" translate="yes" xml:space="preserve">
          <source>Instead of throwing the original error it is now wrapped into an &lt;code&gt;AssertionError&lt;/code&gt; that contains the full stack trace.</source>
          <target state="translated">원래 오류를 발생시키는 대신 이제 전체 스택 추적이 포함 된 &lt;code&gt;AssertionError&lt;/code&gt; 에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="5459a160eefe5077e9724d4e48b8c8d75dd07d82" translate="yes" xml:space="preserve">
          <source>Instead of throwing the original error it is now wrapped into an [&lt;code&gt;AssertionError&lt;/code&gt;][] that contains the full stack trace.</source>
          <target state="translated">Instead of throwing the original error it is now wrapped into an [ &lt;code&gt;AssertionError&lt;/code&gt; ][] that contains the full stack trace.</target>
        </trans-unit>
        <trans-unit id="f3cda84a60945615fb5594f83f4b9f44393ad1ff" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;code&gt;QuicStream&lt;/code&gt; as a writable stream, send data from a given file descriptor.</source>
          <target state="translated">쓰기 가능한 스트림 으로 &lt;code&gt;QuicStream&lt;/code&gt; 을 사용하는 대신 주어진 파일 설명자에서 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3ef6a163e5f0bd526a7fec7052379ef22cd69ad0" translate="yes" xml:space="preserve">
          <source>Instead of using a &lt;code&gt;QuicStream&lt;/code&gt; as a writable stream, send data from a given file path.</source>
          <target state="translated">&lt;code&gt;QuicStream&lt;/code&gt; 을 쓰기 가능한 스트림으로 사용하는 대신 주어진 파일 경로에서 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="30efab8410e00da41af04eba4012009dd72d227b" translate="yes" xml:space="preserve">
          <source>Instead, use direct &lt;a href=&quot;#packages_subpath_patterns&quot;&gt;subpath patterns&lt;/a&gt;:</source>
          <target state="translated">대신 직접 &lt;a href=&quot;#packages_subpath_patterns&quot;&gt;하위 경로 패턴을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0886c0750f47c6c020e0212835b6e14e09f31e83" translate="yes" xml:space="preserve">
          <source>Instruct &lt;code&gt;require&lt;/code&gt; on how to handle certain file extensions.</source>
          <target state="translated">지시합니다은 &lt;code&gt;require&lt;/code&gt; 특정 파일 확장자를 처리하는 방법에.</target>
        </trans-unit>
        <trans-unit id="c063ff3cdde65053663a7873bf8ab9bd399ef6b0" translate="yes" xml:space="preserve">
          <source>Instructs Node.js to error prior to running any code if the policy does not have the specified integrity. It expects a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; string as a parameter.</source>
          <target state="translated">정책에 지정된 무결성이없는 경우 코드를 실행하기 전에 Node.js에 오류가 발생하도록 지시합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 문자열을 매개 변수로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b00d1feef65ce7e33d04d315b5601124b9350a" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL server to prioritize ChaCha20Poly1305 when client does. This option has no effect if &lt;code&gt;SSL_OP_CIPHER_SERVER_PREFERENCE&lt;/code&gt; is not enabled.</source>
          <target state="translated">Instructs OpenSSL server to prioritize ChaCha20Poly1305 when client does. This option has no effect if &lt;code&gt;SSL_OP_CIPHER_SERVER_PREFERENCE&lt;/code&gt; is not enabled.</target>
        </trans-unit>
        <trans-unit id="0b2c85f8a9e409e60a7c57bb3a6180c6a74b488d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft.</source>
          <target state="translated">OpenSSL에 초기 버전의 cryptopro 초안에서 server-hello 확장을 추가하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="be2960d676515f73072f7067706d825293617492" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode for TLS v1.3</source>
          <target state="translated">Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode for TLS v1.3</target>
        </trans-unit>
        <trans-unit id="ac6c05112a017d47310f296b0041f44b75da5a87" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always create a new key when using temporary/ephemeral DH parameters.</source>
          <target state="translated">임시 / 일시적 DH 매개 변수를 사용할 때 OpenSSL이 항상 새 키를 작성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="546f5bbe97ae294c8fc5e687dae9f83654f746e8" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always create a new key when using temporary/ephemeral ECDH parameters.</source>
          <target state="translated">임시 / 일시적 ECDH 매개 변수를 사용할 때 항상 새 키를 작성하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ac0311c08a3469b8d71f9d3883a3fe4a8bf94820" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always start a new session when performing renegotiation.</source>
          <target state="translated">재협상을 수행 할 때 항상 새 세션을 시작하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ae7bb7ececabda2568352c90383393ed8f76fe08" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always use the tmp_rsa key when performing RSA operations.</source>
          <target state="translated">RSA 작업을 수행 할 때 항상 tmp_rsa 키를 사용하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="caca42fad826dd949c6335a63c6ceb14c18ab473" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d.</source>
          <target state="translated">OpenSSL 0.9.6d에 추가 된 SSL 3.0 / TLS 1.0 취약성 해결 방법을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="70a5fa003ee5c03ab6047780d6a1756112249d54" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable encrypt-then-MAC.</source>
          <target state="translated">Instructs OpenSSL to disable encrypt-then-MAC.</target>
        </trans-unit>
        <trans-unit id="b66cff55ed33dd0619fafbee8f2c1a8844db9d45" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable renegotiation.</source>
          <target state="translated">Instructs OpenSSL to disable renegotiation.</target>
        </trans-unit>
        <trans-unit id="23867858cda445617e031433f5f870ccca19e39d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable support for SSL/TLS compression.</source>
          <target state="translated">SSL / TLS 압축 지원을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0b25ca4b0affb115218bbc6dc9c81460963a1551" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable the workaround for a man-in-the-middle protocol-version vulnerability in the SSL 2.0 server implementation.</source>
          <target state="translated">SSL 2.0 서버 구현에서 중간자 프로토콜 버전 취약점에 대한 대안을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2165b961ee84bb34e7517631c063e2f2f98f243d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable use of RFC4507bis tickets.</source>
          <target state="translated">RFC4507bis 티켓 사용을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="608aeeeb5a40e2d41f521b3de5c1f59b365144e3" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable version rollback attack detection.</source>
          <target state="translated">버전 롤백 공격 탐지를 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="710ee28e0f7e59c4bcb18bce916c5f0f0d575362" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off SSL v2</source>
          <target state="translated">SSL v2를 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="4a26e814f5c329c70cc5bbf34635600b0166e139" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off SSL v3</source>
          <target state="translated">OpenSSL에 SSL v3을 끄도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="80de102aad3b8873aa476d2f44620c3de39d7a90" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1</source>
          <target state="translated">TLS v1을 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0e08471820c4afa43946e65eac375fcd772422b3" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1.1</source>
          <target state="translated">TLS v1.1을 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="55e7bd4f680213d3fc1d7f9ebf87e0706ef0e930" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1.2</source>
          <target state="translated">TLS v1.2를 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="d2577ea31fe29df8d4ee86b2f8d05d0b4c6ee9a7" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1.3</source>
          <target state="translated">Instructs OpenSSL to turn off TLS v1.3</target>
        </trans-unit>
        <trans-unit id="dfbab4e09330ea425ca00047c6c5baf5232c6ce4" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn on cookie exchange.</source>
          <target state="translated">쿠키 교환을 설정하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1e82de46cebb9eab62329940282272bfd3ba678a" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to use Cisco's &quot;speshul&quot; version of DTLS_BAD_VER.</source>
          <target state="translated">Cisco의 &quot;speshul&quot;버전 DTLS_BAD_VER를 사용하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="75031cb337e0583a13d4c7be4edb3e048cfc6d63" translate="yes" xml:space="preserve">
          <source>Instructs the kernel to leave a multicast group at &lt;code&gt;multicastAddress&lt;/code&gt; using the &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; socket option. This method is automatically called by the kernel when the socket is closed or the process terminates, so most apps will never have reason to call this.</source>
          <target state="translated">커널 지시에 멀티 캐스트 그룹을 떠날 &lt;code&gt;multicastAddress&lt;/code&gt; 은 Using &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; 의 소켓 옵션을 선택합니다. 이 메소드는 소켓이 닫히거나 프로세스가 종료 될 때 커널에 의해 자동으로 호출되므로 대부분의 앱은이를 호출 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="81933be106e68779eab34fb4514049a58d52563f" translate="yes" xml:space="preserve">
          <source>Instructs the kernel to leave a source-specific multicast channel at the given &lt;code&gt;sourceAddress&lt;/code&gt; and &lt;code&gt;groupAddress&lt;/code&gt; using the &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; socket option. This method is automatically called by the kernel when the socket is closed or the process terminates, so most apps will never have reason to call this.</source>
          <target state="translated">Instructs the kernel to leave a source-specific multicast channel at the given &lt;code&gt;sourceAddress&lt;/code&gt; and &lt;code&gt;groupAddress&lt;/code&gt; using the &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; socket option. This method is automatically called by the kernel when the socket is closed or the process terminates, so most apps will never have reason to call this.</target>
        </trans-unit>
        <trans-unit id="1144c6f61e59c74db28b6c4b9401d09107634752" translate="yes" xml:space="preserve">
          <source>Instructs the module loader to preserve symbolic links when resolving and caching modules.</source>
          <target state="translated">모듈을 해석하고 캐싱 할 때 기호 링크를 유지하도록 모듈 로더에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="6870fb28c403ee5eb0f8b0e36861a73965d25e9a" translate="yes" xml:space="preserve">
          <source>Instructs the module loader to preserve symbolic links when resolving and caching the main module (&lt;code&gt;require.main&lt;/code&gt;).</source>
          <target state="translated">메인 모듈 ( &lt;code&gt;require.main&lt;/code&gt; )을 해결하고 캐싱 할 때 심볼릭 링크를 유지하도록 모듈 로더에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="8402b4a029cc3b4cbc3fef404091dc1447dc7b5c" translate="yes" xml:space="preserve">
          <source>Integer value representing the expected input size; defaults to &lt;code&gt;0&lt;/code&gt; for an unknown input size.</source>
          <target state="translated">예상 입력 크기를 나타내는 정수 값. 알 수없는 입력 크기의 경우 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="99ab494ded4d235df6eccb37568024a22d56ee79" translate="yes" xml:space="preserve">
          <source>Integer-Indexed: an index value represented by &lt;code&gt;uint32_t&lt;/code&gt;</source>
          <target state="translated">정수 색인 : &lt;code&gt;uint32_t&lt;/code&gt; 로 표시되는 색인 값</target>
        </trans-unit>
        <trans-unit id="81bd3b466b0034894173f99f33ef569af480be3a" translate="yes" xml:space="preserve">
          <source>Integers read from a &lt;code&gt;Buffer&lt;/code&gt; are interpreted as two's complement signed values.</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; 에서 읽은 정수 는 2의 보수 부호 값으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b05fe054d228b76470ec56b7184d0bc99d39e7ba" translate="yes" xml:space="preserve">
          <source>Integral status code indicating the success or failure of a N-API call. Currently, the following status codes are supported.</source>
          <target state="translated">N-API 호출의 성공 또는 실패를 나타내는 통합 상태 코드입니다. 현재 다음 상태 코드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d3e304cd07b5bd6c7b426830429c14bc2b356ec5" translate="yes" xml:space="preserve">
          <source>Integrating &lt;code&gt;AsyncResource&lt;/code&gt; with &lt;code&gt;EventEmitter&lt;/code&gt;</source>
          <target state="translated">Integrating &lt;code&gt;AsyncResource&lt;/code&gt; with &lt;code&gt;EventEmitter&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b62f41c12ee066d13d5c86a1257925ad8861703" translate="yes" xml:space="preserve">
          <source>Integrity Checks</source>
          <target state="translated">무결성 검사</target>
        </trans-unit>
        <trans-unit id="4cb5b39c0f8028f339c4e3a11a09d7b24bb24591" translate="yes" xml:space="preserve">
          <source>Integrity can be specified as the boolean value &lt;code&gt;true&lt;/code&gt; to accept any body for the resource which can be useful for local development. It is not recommended in production since it would allow unexpected alteration of resources to be considered valid.</source>
          <target state="translated">무결성은 부울 값 &lt;code&gt;true&lt;/code&gt; 로 지정되어 로컬 개발에 유용 할 수있는 자원의 본문을 승인 할 수 있습니다. 예상치 못한 자원 변경이 유효한 것으로 간주되므로 프로덕션 환경에서는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50c9e0c5e01735529d5358e6bf00aeb5fbddb67a" translate="yes" xml:space="preserve">
          <source>Integrity checks</source>
          <target state="translated">Integrity checks</target>
        </trans-unit>
        <trans-unit id="4cf43a800950dd777641442ca904838912bd822f" translate="yes" xml:space="preserve">
          <source>Integrity using scopes</source>
          <target state="translated">Integrity using scopes</target>
        </trans-unit>
        <trans-unit id="3f7eed5af6d7877b3ba1d70d5214faa63dad25d2" translate="yes" xml:space="preserve">
          <source>Interaction with workers</source>
          <target state="translated">Interaction with workers</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="23575f35a521e9c261d274ac4cb29c2f05b261ac" translate="yes" xml:space="preserve">
          <source>Internal Error</source>
          <target state="translated">내부 오류</target>
        </trans-unit>
        <trans-unit id="95533607b2195871cdd825109cced72868daaac4" translate="yes" xml:space="preserve">
          <source>Internal Node.js libraries. Node.js itself exports C++ APIs that addons can use, the most important of which is the &lt;code&gt;node::ObjectWrap&lt;/code&gt; class.</source>
          <target state="translated">Internal Node.js libraries. Node.js itself exports C++ APIs that addons can use, the most important of which is the &lt;code&gt;node::ObjectWrap&lt;/code&gt; class.</target>
        </trans-unit>
        <trans-unit id="be2832f2017b9feac348c32119b337871f7f79ff" translate="yes" xml:space="preserve">
          <source>Internal Node.js libraries. Node.js itself exports a number of C++ APIs that Addons can use &amp;mdash; the most important of which is the &lt;code&gt;node::ObjectWrap&lt;/code&gt; class.</source>
          <target state="translated">내부 Node.js 라이브러리 Node.js 자체는 애드온이 사용할 수있는 많은 C ++ API를 내 보냅니다. 그 중 가장 중요한 것은 &lt;code&gt;node::ObjectWrap&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f4c2cebcc0952f7ae86ffbb2645ce54c5574178" translate="yes" xml:space="preserve">
          <source>Internal errors occur when an HTTP/2 session fails unexpectedly. These will be reported via an &lt;code&gt;'error'&lt;/code&gt; event on the &lt;code&gt;Http2Session&lt;/code&gt; or HTTP/2 Server objects.</source>
          <target state="translated">HTTP / 2 세션이 예기치 않게 실패하면 내부 오류가 발생합니다. 이는 &lt;code&gt;Http2Session&lt;/code&gt; 또는 HTTP / 2 Server 오브젝트 에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 통해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad90811f03e8bbaf83a345f7229936551486b928" translate="yes" xml:space="preserve">
          <source>Internal properties no longer appear in the context argument of a custom inspection function.</source>
          <target state="translated">내부 속성이 더 이상 사용자 정의 검사 기능의 컨텍스트 인수에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="845202ae0fe1a669c29ddc90a5436534b580fc96" translate="yes" xml:space="preserve">
          <source>Internationalization Support</source>
          <target state="translated">국제화 지원</target>
        </trans-unit>
        <trans-unit id="4de73a3f1e6b5deccf35f9983157dd29155946aa" translate="yes" xml:space="preserve">
          <source>Internationalization support</source>
          <target state="translated">Internationalization support</target>
        </trans-unit>
        <trans-unit id="f1c74da0c6c57362d1086bc64d6d9a5389c76829" translate="yes" xml:space="preserve">
          <source>Interoperability with CommonJS</source>
          <target state="translated">CommonJS와의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="1f06c6ea3387d2dd0326bd91120a11c32eb42186" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of 64-bit numbers and swaps byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 8.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 64 비트 숫자의 배열로 해석 하고 그 &lt;em&gt;자리에서&lt;/em&gt; 바이트 순서 &lt;em&gt;를&lt;/em&gt; 바꿉니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 8의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="e3f37cf37971ac698f0307a0849c4d8a45eaa91f" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 16-bit integers and swaps the byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 2.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 16 비트 정수의 배열로 해석 하고 바이트 순서 &lt;em&gt;를&lt;/em&gt; 교체합니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 2의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="d8b8e329633284e96f9adb1691da632260f2b83b" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 32-bit integers and swaps the byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 4.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 32 비트 정수의 배열로 해석 하고 바이트 순서 &lt;em&gt;를&lt;/em&gt; 교체합니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 4의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="c616a96a3aadb87c9d82ce10c8373a85d56ea758" translate="yes" xml:space="preserve">
          <source>Introduce &lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;code&gt;package.json&lt;/code&gt; field as a more powerful alternative to the classic &lt;code&gt;&quot;main&quot;&lt;/code&gt; field.</source>
          <target state="translated">클래식 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 필드에 대한보다 강력한 대안으로 &lt;code&gt;&quot;exports&quot;&lt;/code&gt; &lt;code&gt;package.json&lt;/code&gt; 필드를 도입하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c495326cbec001dafeaa0da9ab820a10bbe892f" translate="yes" xml:space="preserve">
          <source>Introduced &lt;code&gt;latin1&lt;/code&gt; as an alias for &lt;code&gt;binary&lt;/code&gt;.</source>
          <target state="translated">도입 &lt;code&gt;latin1&lt;/code&gt; 의 별칭으로 &lt;code&gt;binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9c92f0c550f88b8f940f3db1e7343ac28f0092f" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;hash&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 속성에 할당 된 값에 포함 된 잘못된 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트로 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1629e5ff15506fca0875d4572b9feec31e969dc3" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;password&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;password&lt;/code&gt; 특성에 지정된 값에 포함 된 유효하지 않은 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08d09dda66848238d39695ce4a7fee107a1aaf1b" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;pathname&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;pathname&lt;/code&gt; 특성에 지정된 값에 포함 된 유효하지 않은 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트로 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65f72a935bbcf546bea987da823f35b5a5e27db6" translate="yes" xml:space="preserve">
          <source>Invalid URL protocol values assigned to the &lt;code&gt;protocol&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;protocol&lt;/code&gt; 속성에 할당 된 잘못된 URL 프로토콜 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="738d6832032229b051ea3b4a368aee59f1757724" translate="yes" xml:space="preserve">
          <source>Invalid character handling in header names and values</source>
          <target state="translated">헤더 이름 및 값에서 유효하지 않은 문자 처리</target>
        </trans-unit>
        <trans-unit id="fe947aa91a35f6be8f5dcea115d7f1b3523381d5" translate="yes" xml:space="preserve">
          <source>Invalid characters were detected in headers.</source>
          <target state="translated">헤더에서 유효하지 않은 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="80cb8ebdce9f68d51276352fdbb4b36363df747a" translate="yes" xml:space="preserve">
          <source>Invalid host name values assigned to the &lt;code&gt;hostname&lt;/code&gt; property are ignored.</source>
          <target state="translated">Invalid host name values assigned to the &lt;code&gt;hostname&lt;/code&gt; property are ignored.</target>
        </trans-unit>
        <trans-unit id="52cbfcf6f98b93d30c926a6b1749b607fc691744" translate="yes" xml:space="preserve">
          <source>Invalid host values assigned to the &lt;code&gt;host&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 특성에 지정된 유효하지 않은 호스트 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eae8e79a320be525fba1c1ca46fb7bf1f890b46f" translate="yes" xml:space="preserve">
          <source>Invalid hostname values assigned to the &lt;code&gt;hostname&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;hostname&lt;/code&gt; 특성에 지정된 유효하지 않은 호스트 이름 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="13a2b99768c33644588f26fbb00fc22931cde509" translate="yes" xml:space="preserve">
          <source>Invalid scrypt algorithm parameters were provided.</source>
          <target state="translated">유효하지 않은 scrypt 알고리즘 매개 변수가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="248507b930ae47b7fe748fc4e5d1a8a49f58a393" translate="yes" xml:space="preserve">
          <source>Invalid value character error is identified by &lt;code&gt;code: 'ERR_INVALID_CHAR'&lt;/code&gt;.</source>
          <target state="translated">Invalid value character error is identified by &lt;code&gt;code: 'ERR_INVALID_CHAR'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d21c7370be790d52740a91b52fc49543cba6a787" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;stream#stream_writable_writablefinished&quot;&gt;&lt;code&gt;writable.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다 . 대신 사용하려면 &lt;a href=&quot;stream#stream_writable_writablefinished&quot;&gt; &lt;code&gt;writable.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6ed934df555246f26c85f0b0c4eb07f81f3f242" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_request_destroy_error&quot;&gt;&lt;code&gt;request.destroy()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_request_destroy_error&quot;&gt; &lt;code&gt;request.destroy()&lt;/code&gt; &lt;/a&gt; has been called.</target>
        </trans-unit>
        <trans-unit id="6b8a83f3e29a618906de053b984b4116151588fe" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_request_end_data_encoding_callback&quot;&gt;&lt;code&gt;request.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#http_request_writablefinished&quot;&gt;&lt;code&gt;request.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http_request_end_data_encoding_callback&quot;&gt; &lt;code&gt;request.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은이 사용 &lt;a href=&quot;#http_request_writablefinished&quot;&gt; &lt;code&gt;request.writableFinished&lt;/code&gt; &lt;/a&gt; 대신 데이터가 플러시되었는지 여부를 나타내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="279811758f3fc49f9271db9de98d53ac59a3a35f" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#http_response_writablefinished&quot;&gt;&lt;code&gt;response.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터를 플러시했는지 여부를 나타내지 않으므로 대신 &lt;a href=&quot;#http_response_writablefinished&quot;&gt; &lt;code&gt;response.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c457dffdf62810b5e0e74ea9f6901231788f1d26" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_readable_destroy_error&quot;&gt;&lt;code&gt;readable.destroy()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_readable_destroy_error&quot;&gt; &lt;code&gt;readable.destroy()&lt;/code&gt; &lt;/a&gt; 불려왔다.</target>
        </trans-unit>
        <trans-unit id="27ba9b336441c7b9636f805f2664a8b20332ff3a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_writable_destroy_error&quot;&gt;&lt;code&gt;writable.destroy()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_writable_destroy_error&quot;&gt; &lt;code&gt;writable.destroy()&lt;/code&gt; &lt;/a&gt; 불려왔다.</target>
        </trans-unit>
        <trans-unit id="8e457e44e34dbf6c98b053774a3a83b0eda0d06e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_writable_end_chunk_encoding_callback&quot;&gt;&lt;code&gt;writable.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#stream_writable_writablefinished&quot;&gt;&lt;code&gt;writable.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_writable_end_chunk_encoding_callback&quot;&gt; &lt;code&gt;writable.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다 . 대신 사용하려면 &lt;a href=&quot;#stream_writable_writablefinished&quot;&gt; &lt;code&gt;writable.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50e07a05ea7df0d75d37b07ce707de336d4f493d" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;cancelable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;event.preventDefault()&lt;/code&gt; has been called.</source>
          <target state="translated">Is &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;cancelable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;event.preventDefault()&lt;/code&gt; has been called.</target>
        </trans-unit>
        <trans-unit id="447e18b05fa6d326f80492387bf46993194d011e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if all data has been flushed to the underlying system, immediately before the &lt;a href=&quot;#http_event_finish&quot;&gt;&lt;code&gt;'finish'&lt;/code&gt;&lt;/a&gt; event is emitted.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 모든 데이터가 바로 전에, 기본 시스템에 플러시 된 경우 &lt;a href=&quot;#http_event_finish&quot;&gt; &lt;code&gt;'finish'&lt;/code&gt; &lt;/a&gt; 이벤트가 방출된다.</target>
        </trans-unit>
        <trans-unit id="03e591663a26db9a5ed21e408db60596066058fc" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;readable.read()&lt;/code&gt;&lt;/a&gt;, which means the stream has not been destroyed or emitted &lt;code&gt;'error'&lt;/code&gt; or &lt;code&gt;'end'&lt;/code&gt;.</source>
          <target state="translated">Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;readable.read()&lt;/code&gt; &lt;/a&gt;, which means the stream has not been destroyed or emitted &lt;code&gt;'error'&lt;/code&gt; or &lt;code&gt;'end'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e8d5a5a4a8431f9f64a806e5b6f385f45074325" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;readable.read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 은 전화를 안전한지 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;readable.read()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1e2c65bb71ef448544cac04896a09cce61abdd" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;writable.write()&lt;/code&gt;&lt;/a&gt;, which means the stream has not been destroyed, errored or ended.</source>
          <target state="translated">Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;writable.write()&lt;/code&gt; &lt;/a&gt;, which means the stream has not been destroyed, errored or ended.</target>
        </trans-unit>
        <trans-unit id="4370f01d3c96b257612ae70204203ea0a8789809" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;writable.write()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 은 전화를 안전한지 &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;writable.write()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cba112c3a24385e4a72e89be1c0898218a67a84" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if the stream's buffer has been full and stream will emit &lt;code&gt;'drain'&lt;/code&gt;.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 스트림의 버퍼가 가득했다 스트림이 방출한다면 &lt;code&gt;'drain'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a54e2373de13c6357b66bf3b96598900cda4816e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if this code is not running inside of a &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; thread.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 이 코드는 내부에 실행되고 있지 않은 경우 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드.</target>
        </trans-unit>
        <trans-unit id="5ea282d632dfbf0003030b6293ca539ecda81b32" translate="yes" xml:space="preserve">
          <source>Is set to &lt;code&gt;true&lt;/code&gt; immediately before the &lt;a href=&quot;#stream_event_finish&quot;&gt;&lt;code&gt;'finish'&lt;/code&gt;&lt;/a&gt; event is emitted.</source>
          <target state="translated">&lt;a href=&quot;#stream_event_finish&quot;&gt; &lt;code&gt;'finish'&lt;/code&gt; &lt;/a&gt; 이벤트가 생성 되기 직전 에 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="61932731dd9823ec43230a3d5c44c777698963c2" translate="yes" xml:space="preserve">
          <source>Isolate the state in one or more CommonJS files that are shared between the CommonJS and ES module versions of the package. For example, if the CommonJS and ES module entry points are &lt;code&gt;index.cjs&lt;/code&gt; and &lt;code&gt;index.mjs&lt;/code&gt;, respectively:</source>
          <target state="translated">패키지의 CommonJS 및 ES 모듈 버전간에 공유되는 하나 이상의 CommonJS 파일에서 상태를 분리하십시오. 예를 들어 CommonJS 및 ES 모듈 진입 점이 각각 &lt;code&gt;index.cjs&lt;/code&gt; 및 &lt;code&gt;index.mjs&lt;/code&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="31f54ec164d59bd1126c3d41ec9e0caa797ca9ac" translate="yes" xml:space="preserve">
          <source>It allows a shortcut, so that &lt;code&gt;module.exports.f = ...&lt;/code&gt; can be written more succinctly as &lt;code&gt;exports.f = ...&lt;/code&gt;. However, be aware that like any variable, if a new value is assigned to &lt;code&gt;exports&lt;/code&gt;, it is no longer bound to &lt;code&gt;module.exports&lt;/code&gt;:</source>
          <target state="translated">바로 가기를 허용하므로 &lt;code&gt;module.exports.f = ...&lt;/code&gt; 를 더 간결하게 &lt;code&gt;exports.f = ...&lt;/code&gt; 로 쓸 수 있습니다 . 그러나 변수와 마찬가지로 새 값이 &lt;code&gt;exports&lt;/code&gt; 에 할당되면 더 이상 &lt;code&gt;module.exports&lt;/code&gt; 에 바인딩되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9073ca8fe086c420a4962aa555b1febbd7e4eb14" translate="yes" xml:space="preserve">
          <source>It can also be created by Node.js and passed to the user when a connection is received. For example, it is passed to the listeners of a &lt;a href=&quot;#net_event_connection&quot;&gt;&lt;code&gt;'connection'&lt;/code&gt;&lt;/a&gt; event emitted on a &lt;a href=&quot;#net_class_net_server&quot;&gt;&lt;code&gt;net.Server&lt;/code&gt;&lt;/a&gt;, so the user can use it to interact with the client.</source>
          <target state="translated">Node.js에 의해 생성되어 연결이 수신 될 때 사용자에게 전달 될 수도 있습니다. 예를 들어, &lt;a href=&quot;#net_class_net_server&quot;&gt; &lt;code&gt;net.Server&lt;/code&gt; &lt;/a&gt; 에서 생성 된 &lt;a href=&quot;#net_event_connection&quot;&gt; &lt;code&gt;'connection'&lt;/code&gt; &lt;/a&gt; 이벤트 의 리스너에 전달 되므로 사용자는이를 사용하여 클라이언트와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5170688bb6d5c05e758eaa86801b72671253446e" translate="yes" xml:space="preserve">
          <source>It can be accessed using:</source>
          <target state="translated">다음을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2502aa25bb881c5a8de387f4855f38f05049a2" translate="yes" xml:space="preserve">
          <source>It creates a symbolic link named &quot;new-port&quot; that points to &quot;foo&quot;.</source>
          <target state="translated">&quot;foo&quot;를 가리키는 &quot;new-port&quot;라는 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f0450c3659d04b97d0de09b169af32ff8f617bc3" translate="yes" xml:space="preserve">
          <source>It detects &lt;code&gt;null&lt;/code&gt; as a separate type, while ECMAScript &lt;code&gt;typeof&lt;/code&gt; would detect &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">It detects &lt;code&gt;null&lt;/code&gt; as a separate type, while ECMAScript &lt;code&gt;typeof&lt;/code&gt; would detect &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d1be5b11468a8cdf73d05266cfb33d14f98a6df" translate="yes" xml:space="preserve">
          <source>It does nothing if the stream was already destroyed.</source>
          <target state="translated">스트림이 이미 파괴 된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41d9374edd67e5544a25ed3217406f608f09bce8" translate="yes" xml:space="preserve">
          <source>It has already been linked (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt;)</source>
          <target state="translated">이미 연결되었습니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="967e13c06d26edbbb18720333bfad7b741a78020" translate="yes" xml:space="preserve">
          <source>It has support for detecting an External value.</source>
          <target state="translated">It has support for detecting an External value.</target>
        </trans-unit>
        <trans-unit id="a70b0c65dc3241d0690f77cfe10d0e5c2409d02c" translate="yes" xml:space="preserve">
          <source>It helps to provide some global-looking variables that are actually specific to the module, such as:</source>
          <target state="translated">다음과 같이 실제로 모듈에 고유 한 일부 전역 변수를 제공하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0464e843f0f43c4dc6eaefcde1f38e4a3f6cc1" translate="yes" xml:space="preserve">
          <source>It implements the &lt;a href=&quot;stream#stream_class_stream_readable&quot;&gt;Readable Stream&lt;/a&gt; interface, as well as the following additional events, methods, and properties.</source>
          <target state="translated">그것은 구현 &lt;a href=&quot;stream#stream_class_stream_readable&quot;&gt;읽을 수 스트림&lt;/a&gt; 인터페이스뿐만 아니라 다음과 같은 추가 이벤트, 메서드 및 속성을.</target>
        </trans-unit>
        <trans-unit id="5d45f625dfde54e988f472dec8c49c8ac4e78699" translate="yes" xml:space="preserve">
          <source>It is also possible to compress or decompress data in a single step:</source>
          <target state="translated">단일 단계에서 데이터를 압축하거나 압축 해제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bfb3903cd859802eba53ef817be6fc4d39e1d0" translate="yes" xml:space="preserve">
          <source>It is also possible to create new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt; instances from a &lt;code&gt;Buffer&lt;/code&gt; with the following caveats:</source>
          <target state="translated">다음과 같은 경고 를 사용하여 &lt;code&gt;Buffer&lt;/code&gt; 에서 새 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94f8e04142983f13c24079e34f4c988c32e45040" translate="yes" xml:space="preserve">
          <source>It is also possible to set a breakpoint in a file (module) that is not loaded yet:</source>
          <target state="translated">아직로드되지 않은 파일 (모듈)에 중단 점을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a34d6d2cfc9e4ced2263ec4c4d2ab062b99846e3" translate="yes" xml:space="preserve">
          <source>It is also possible to set a conditional breakpoint that only breaks when a given expression evaluates to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">주어진 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가 될 때만 중단되는 조건부 중단 점을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3e7ef80ba24b9fb35096f06920755ced16718da" translate="yes" xml:space="preserve">
          <source>It is also possible to subscribe only to notifications with specific method:</source>
          <target state="translated">특정 방법으로 알림 만 구독 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36886a21b327f4efa13efb333b8085346c75732" translate="yes" xml:space="preserve">
          <source>It is also possible to wrap C++ objects/classes in a way that allows new instances to be created using the JavaScript &lt;code&gt;new&lt;/code&gt; operator:</source>
          <target state="translated">JavaScript &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 새 인스턴스를 만들 수있는 방식으로 C ++ 객체 / 클래스를 래핑 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27ace742269815d9bc53f0c5f64ced13adb5440" translate="yes" xml:space="preserve">
          <source>It is also recommended that any &lt;code&gt;'message'&lt;/code&gt; handlers in the child process verify that &lt;code&gt;socket&lt;/code&gt; exists, as the connection may have been closed during the time it takes to send the connection to the child.</source>
          <target state="translated">또한 자식 프로세스 에 연결을 보내는 데 걸리는 시간 동안 연결이 닫 혔을 수 있으므로 자식 프로세스의 모든 &lt;code&gt;'message'&lt;/code&gt; 핸들러가 &lt;code&gt;socket&lt;/code&gt; 이 존재 하는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="16c143cda1d23fdc307acaa4ab93fadca2a6f783" translate="yes" xml:space="preserve">
          <source>It is bad practice to remove listeners added elsewhere in the code, particularly when the &lt;code&gt;EventEmitter&lt;/code&gt; instance was created by some other component or module (e.g. sockets or file streams).</source>
          <target state="translated">코드의 다른 곳에 추가 된 리스너, 특히 &lt;code&gt;EventEmitter&lt;/code&gt; 인스턴스가 다른 컴포넌트 나 모듈 (예 : 소켓 또는 파일 스트림)에 의해 생성 된 경우 리스너를 제거하는 것은 좋지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9c833a8c6ebe950f983fd451c778c087cc9332c0" translate="yes" xml:space="preserve">
          <source>It is being linked (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linking'&lt;/code&gt;)</source>
          <target state="translated">연결 중입니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; 는 &lt;code&gt;'linking'&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="419d5dee627637c5194692a9f10eb64d65bcc9aa" translate="yes" xml:space="preserve">
          <source>It is common practice within Addons to pass JavaScript functions to a C++ function and execute them from there. The following example illustrates how to invoke such callbacks:</source>
          <target state="translated">애드온 내에서 JavaScript 함수를 C ++ 함수로 전달하고 거기서 실행하는 것이 일반적입니다. 다음 예제는 이러한 콜백을 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d1e8308e7f9db59899a0946a4de525aabc71fba1" translate="yes" xml:space="preserve">
          <source>It is common practice within addons to pass JavaScript functions to a C++ function and execute them from there. The following example illustrates how to invoke such callbacks:</source>
          <target state="translated">It is common practice within addons to pass JavaScript functions to a C++ function and execute them from there. The following example illustrates how to invoke such callbacks:</target>
        </trans-unit>
        <trans-unit id="3048ab55c4bb6de03bd26d55d03dc4c5facb8b7f" translate="yes" xml:space="preserve">
          <source>It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to those directories. There are three ways in which a folder may be passed to &lt;code&gt;require()&lt;/code&gt; as an argument.</source>
          <target state="translated">프로그램과 라이브러리를 독립된 디렉토리로 구성한 다음 해당 디렉토리에 단일 진입 점을 제공하는 것이 편리합니다. 폴더를 인수로 &lt;code&gt;require()&lt;/code&gt; 전달할 수있는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ae010a7f5ed72fe5c4197d82c84289cacb4988c" translate="yes" xml:space="preserve">
          <source>It is deprecated and should not be used in new code. JavaScript comes with very similar built-in functionality through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않으며 새 코드에서 사용해서는 안됩니다. JavaScript는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 통해 매우 유사한 내장 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="382706d811accf5e4830215dc1300355249bb388" translate="yes" xml:space="preserve">
          <source>It is deprecated in favor of &lt;a href=&quot;modules#modules_accessing_the_main_module&quot;&gt;&lt;code&gt;require.main&lt;/code&gt;&lt;/a&gt;, because it serves the same purpose and is only available on CommonJS environment.</source>
          <target state="translated">It is deprecated in favor of &lt;a href=&quot;modules#modules_accessing_the_main_module&quot;&gt; &lt;code&gt;require.main&lt;/code&gt; &lt;/a&gt;, because it serves the same purpose and is only available on CommonJS environment.</target>
        </trans-unit>
        <trans-unit id="937f36c6fe0ce89575bd34e56b0dfed7daac172f" translate="yes" xml:space="preserve">
          <source>It is good practice, to &lt;a href=&quot;#http_agent_destroy&quot;&gt;&lt;code&gt;destroy()&lt;/code&gt;&lt;/a&gt; an &lt;code&gt;Agent&lt;/code&gt; instance when it is no longer in use, because unused sockets consume OS resources.</source>
          <target state="translated">사용하지 않는 소켓은 OS 리소스를 소비하므로 더 이상 사용하지 않을 때 &lt;code&gt;Agent&lt;/code&gt; 인스턴스 를 &lt;a href=&quot;#http_agent_destroy&quot;&gt; &lt;code&gt;destroy()&lt;/code&gt; &lt;/a&gt; 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2bc5790e09a1d829dcaf9ede78c9a8dcb7900d48" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that spawned Node.js child processes are independent of the parent with exception of the IPC communication channel that is established between the two. Each process has its own memory, with their own V8 instances. Because of the additional resource allocations required, spawning a large number of child Node.js processes is not recommended.</source>
          <target state="translated">생성 된 Node.js 하위 프로세스는 두 프로세스간에 설정된 IPC 통신 채널을 제외하고 상위 프로세스와 무관하다는 점을 명심해야합니다. 각 프로세스에는 자체 V8 인스턴스가있는 자체 메모리가 있습니다. 추가 리소스 할당이 필요하기 때문에 많은 수의 자식 Node.js 프로세스를 생성하는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4512b8cdb5a3c36488e4bbb14fc8dde177723733" translate="yes" xml:space="preserve">
          <source>It is impossible to know in advance the MTU of each link through which a packet might travel. Sending a datagram greater than the receiver &lt;code&gt;MTU&lt;/code&gt; will not work because the packet will get silently dropped without informing the source that the data did not reach its intended recipient.</source>
          <target state="translated">패킷이 이동할 수있는 각 링크의 MTU를 미리 알 수는 없습니다. 데이터가 수신자 에게 도달하지 않았다는 소스를 알리지 않고 패킷이 자동으로 삭제되므로 수신자 &lt;code&gt;MTU&lt;/code&gt; 보다 큰 데이터 그램을 전송하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d15922f6fb49942cb495192c566614d6f960db0" translate="yes" xml:space="preserve">
          <source>It is intended that a module writer wanting to report diagnostics messages will create one or many top-level channels to report messages through. Channels may also be acquired at runtime but it is not encouraged due to the additional overhead of doing so. Channels may be exported for convenience, but as long as the name is known it can be acquired anywhere.</source>
          <target state="translated">진단 메시지를보고하려는 모듈 작성자는 메시지를보고 할 하나 이상의 최상위 채널을 만듭니다. 채널은 런타임에 획득 할 수도 있지만 추가 오버 헤드로 인해 권장되지 않습니다. 편의를 위해 채널을 내보낼 수 있지만 이름이 알려져 있으면 어디서든 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e2e4af5d5aa394246178c425f14d66e2517e6db" translate="yes" xml:space="preserve">
          <source>It is not clear whether &lt;code&gt;foo()&lt;/code&gt; or &lt;code&gt;bar()&lt;/code&gt; will be called first.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 또는 &lt;code&gt;bar()&lt;/code&gt; 가 먼저 호출 되는지는 확실하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67feb1878c776ad9fccd934e67f62317478d643e" translate="yes" xml:space="preserve">
          <source>It is not emitted in the worker.</source>
          <target state="translated">작업자에게 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187a290752482dba747ede2b91a61d535838b186" translate="yes" xml:space="preserve">
          <source>It is not necessary to call into JavaScript via &lt;code&gt;napi_make_callback()&lt;/code&gt; because N-API runs &lt;code&gt;call_js_cb&lt;/code&gt; in a context appropriate for callbacks.</source>
          <target state="translated">N-API는 콜백에 적합한 컨텍스트에서 &lt;code&gt;call_js_cb&lt;/code&gt; 를 실행하므로 &lt;code&gt;napi_make_callback()&lt;/code&gt; 통해 JavaScript를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="de78e88d2cf1c226b2cfb4eda72528bc88f2e15b" translate="yes" xml:space="preserve">
          <source>It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers.</source>
          <target state="translated">It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers.</target>
        </trans-unit>
        <trans-unit id="296a4e8488e3ee0257b7a2a2c0b7176cf79e4966" translate="yes" xml:space="preserve">
          <source>It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers. Examples:</source>
          <target state="translated">It is not necessary to use this method before passing headers to an HTTP request or response. The HTTP module will automatically validate such headers. Examples:</target>
        </trans-unit>
        <trans-unit id="3d10f2c19d8c5b37fce057d024a074f7f6dd563d" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;code&gt;require()&lt;/code&gt; files that have the &lt;code&gt;.mjs&lt;/code&gt; extension. Attempting to do so will throw &lt;a href=&quot;errors#errors_err_require_esm&quot;&gt;an error&lt;/a&gt;. The &lt;code&gt;.mjs&lt;/code&gt; extension is reserved for &lt;a href=&quot;esm&quot;&gt;ECMAScript Modules&lt;/a&gt; which cannot be loaded via &lt;code&gt;require()&lt;/code&gt;. See &lt;a href=&quot;esm&quot;&gt;ECMAScript Modules&lt;/a&gt; for more details.</source>
          <target state="translated">확장자 가 &lt;code&gt;.mjs&lt;/code&gt; 인 파일은 &lt;code&gt;require()&lt;/code&gt; 할 수 없습니다 . 그렇게하면 &lt;a href=&quot;errors#errors_err_require_esm&quot;&gt;오류가 발생&lt;/a&gt; 합니다. &lt;code&gt;.mjs&lt;/code&gt; 의 확장은 예약되어 &lt;a href=&quot;esm&quot;&gt;ECMAScript를 모듈&lt;/a&gt; 로로드 할 수없는 &lt;code&gt;require()&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;esm&quot;&gt;ECMAScript 모듈&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7b21297f31acb334dbc5d7e4654c5f95618230e" translate="yes" xml:space="preserve">
          <source>It is not possible to cancel timers that were created using the promisified variants of &lt;a href=&quot;timers#timers_setimmediate_callback_args&quot;&gt;&lt;code&gt;setImmediate()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;timers#timers_settimeout_callback_delay_args&quot;&gt;&lt;code&gt;setTimeout()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">약속 된 변형 &lt;a href=&quot;timers#timers_setimmediate_callback_args&quot;&gt; &lt;code&gt;setImmediate()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;timers#timers_settimeout_callback_delay_args&quot;&gt; &lt;code&gt;setTimeout()&lt;/code&gt; &lt;/a&gt; 사용하여 만든 타이머를 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e66357995a3753445dca09b779bcb4d762b0d211" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this option once a socket has been sent to a child with &lt;a href=&quot;child_process#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;child_process#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; 가있는 자식에게 소켓을 보낸 후에는이 옵션을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="11b99fc0673b66c9c42a80c4a0c35748194bd28e" translate="yes" xml:space="preserve">
          <source>It is often necessary to make the lifespan of handles shorter than the lifespan of a native method. For example, consider a native method that has a loop which iterates through the elements in a large array:</source>
          <target state="translated">핸들의 수명을 기본 메소드의 수명보다 짧게 만들어야하는 경우가 종종 있습니다. 예를 들어, 큰 배열에서 요소를 반복하는 루프가있는 기본 메소드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4c4c02784543cf811bfb3f1f2ca2f803b137643c" translate="yes" xml:space="preserve">
          <source>It is possible for Node.js to be built without including support for the &lt;code&gt;crypto&lt;/code&gt; module. In such cases, calling &lt;code&gt;require('crypto')&lt;/code&gt; will result in an error being thrown.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 모듈에 대한 지원을 포함하지 않고도 Node.js를 빌드 할 수 있습니다 . 이러한 경우 &lt;code&gt;require('crypto')&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ec146a36358c16fe853764f44ebbd03ad1c100e" translate="yes" xml:space="preserve">
          <source>It is possible that no output is generated from any given chunk of input data.</source>
          <target state="translated">주어진 입력 데이터 덩어리에서 출력이 생성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c05044fad35947e2b34f640cb82763b531c67e6" translate="yes" xml:space="preserve">
          <source>It is possible to abort a request with an AbortSignal.</source>
          <target state="translated">AbortSignal로 요청을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb41f4ead62c0acd100bea2cdb2db4664be791dc" translate="yes" xml:space="preserve">
          <source>It is possible to abort an ongoing &lt;code&gt;readFile&lt;/code&gt; using an &lt;code&gt;AbortSignal&lt;/code&gt;. If a request is aborted the promise returned is rejected with an &lt;code&gt;AbortError&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;AbortSignal&lt;/code&gt; 을 사용하여 진행중인 &lt;code&gt;readFile&lt;/code&gt; 을 중단 할 수 있습니다 . 요청이 중단되면 반환 된 promise는 &lt;code&gt;AbortError&lt;/code&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="8bb9372b3ea7df0e017b7e2df090f9d1d713f7f6" translate="yes" xml:space="preserve">
          <source>It is possible to abort an ongoing request using an &lt;code&gt;AbortSignal&lt;/code&gt;. If a request is aborted the callback is called with an &lt;code&gt;AbortError&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;AbortSignal&lt;/code&gt; 을 사용하여 진행중인 요청을 중단 할 수 있습니다 . 요청이 중단되면 &lt;code&gt;AbortError&lt;/code&gt; 와 함께 콜백이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="041de057d4cce3b0afd146cbb127bf4a3b681c5a" translate="yes" xml:space="preserve">
          <source>It is possible to attach multiple &lt;code&gt;Writable&lt;/code&gt; streams to a single &lt;code&gt;Readable&lt;/code&gt; stream.</source>
          <target state="translated">여러 개의 &lt;code&gt;Writable&lt;/code&gt; &lt;code&gt;Readable&lt;/code&gt; 스트림을 단일 읽기 가능 스트림 에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f756af417fbde2518c13a7c85fc18b3dac2b86" translate="yes" xml:space="preserve">
          <source>It is possible to create a new &lt;code&gt;Buffer&lt;/code&gt; that shares the same allocated memory as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt; instance by using the &lt;code&gt;TypedArray&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;.buffer&lt;/code&gt; property in the same way. &lt;a href=&quot;#buffer_static_method_buffer_from_arraybuffer_byteoffset_length&quot;&gt;&lt;code&gt;Buffer.from()&lt;/code&gt;&lt;/a&gt; behaves like &lt;code&gt;new Uint8Array()&lt;/code&gt; in this context.</source>
          <target state="translated">It is possible to create a new &lt;code&gt;Buffer&lt;/code&gt; that shares the same allocated memory as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; &lt;/a&gt; instance by using the &lt;code&gt;TypedArray&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;.buffer&lt;/code&gt; property in the same way. &lt;a href=&quot;#buffer_static_method_buffer_from_arraybuffer_byteoffset_length&quot;&gt; &lt;code&gt;Buffer.from()&lt;/code&gt; &lt;/a&gt; behaves like &lt;code&gt;new Uint8Array()&lt;/code&gt; in this context.</target>
        </trans-unit>
        <trans-unit id="9d799d5874d270cd1edf1e65682d3d92bdbd761d" translate="yes" xml:space="preserve">
          <source>It is possible to create a new &lt;code&gt;Buffer&lt;/code&gt; that shares the same allocated memory as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt; instance by using the &lt;code&gt;TypedArray&lt;/code&gt; object's &lt;code&gt;.buffer&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;TypedArray&lt;/code&gt; 객체의 &lt;code&gt;.buffer&lt;/code&gt; 속성 을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; &lt;/a&gt; 인스턴스 와 동일한 할당 메모리를 공유 하는 새 &lt;code&gt;Buffer&lt;/code&gt; 를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0425f8d11e929edaebd4ecd9966c15d540c99b06" translate="yes" xml:space="preserve">
          <source>It is possible to create and run multiple REPL instances against a single running instance of Node.js that share a single &lt;code&gt;global&lt;/code&gt; object but have separate I/O interfaces.</source>
          <target state="translated">단일 &lt;code&gt;global&lt;/code&gt; 객체 를 공유 하지만 별도의 I / O 인터페이스가 있는 Node.js의 단일 실행 인스턴스에 대해 여러 REPL 인스턴스를 작성하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aebe7a7a176eecea0791341611fe6bc21db870e1" translate="yes" xml:space="preserve">
          <source>It is possible to have type name collisions. Embedders are encouraged to use unique prefixes, such as the npm package name, to prevent collisions when listening to the hooks.</source>
          <target state="translated">유형 이름 충돌이있을 수 있습니다. 엠 베더는 후크를들을 때 충돌을 방지하기 위해 npm 패키지 이름과 같은 고유 한 접두사를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e6c6c312d474be31ba928b610b1f24972346fde4" translate="yes" xml:space="preserve">
          <source>It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads. In other words, the following example would not work:</source>
          <target state="translated">이 객체를 수정할 수는 있지만 그러한 수정은 Node.js 프로세스 외부에 반영되거나 명시 적으로 요청되지 않는 한 다른 &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드에 반영되지 않습니다 . 즉, 다음 예제는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35d16003884be438df7a1acc413175dbe0c12f8c" translate="yes" xml:space="preserve">
          <source>It is possible to monitor &lt;code&gt;'error'&lt;/code&gt; events without consuming the emitted error by installing a listener using the symbol &lt;code&gt;errorMonitor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errorMonitor&lt;/code&gt; 기호를 사용하여 리스너를 설치하면 생성 된 오류를 소비하지 않고 &lt;code&gt;'error'&lt;/code&gt; 이벤트 를 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb47b5281d45cca64650f0bdac0dc02b859e95f9" translate="yes" xml:space="preserve">
          <source>It is possible to monitor &lt;code&gt;'error'&lt;/code&gt; events without consuming the emitted error by installing a listener using the symbol &lt;code&gt;events.errorMonitor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;events.errorMonitor&lt;/code&gt; 심볼을 사용하여 리스너를 설치하면 생성 된 오류를 소비하지 않고 &lt;code&gt;'error'&lt;/code&gt; 이벤트 를 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7c50e3a0dc247c0e0d0c4d0e9566d30f009dc29" translate="yes" xml:space="preserve">
          <source>It is possible to monitor &lt;code&gt;'uncaughtException'&lt;/code&gt; events without overriding the default behavior to exit the process by installing a &lt;code&gt;'uncaughtExceptionMonitor'&lt;/code&gt; listener.</source>
          <target state="translated">&lt;code&gt;'uncaughtExceptionMonitor'&lt;/code&gt; 리스너를 설치하여 프로세스를 종료하는 기본 동작을 재정의하지 않고 &lt;code&gt;'uncaughtException'&lt;/code&gt; 이벤트 를 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86565752a73577e2315e700600c3bf0c40a3f4fd" translate="yes" xml:space="preserve">
          <source>It is possible to require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance &lt;code&gt;require('example-module/path/to/file')&lt;/code&gt; would resolve &lt;code&gt;path/to/file&lt;/code&gt; relative to where &lt;code&gt;example-module&lt;/code&gt; is located. The suffixed path follows the same module resolution semantics.</source>
          <target state="translated">모듈 이름 뒤에 경로 접미사를 포함시켜 특정 파일 또는 모듈과 함께 배포 된 하위 모듈을 요구할 수 있습니다. 예를 들어 &lt;code&gt;require('example-module/path/to/file')&lt;/code&gt; 은 &lt;code&gt;example-module&lt;/code&gt; 이있는 위치를 기준으로 &lt;code&gt;path/to/file&lt;/code&gt; 을 확인합니다 . 접미사 경로는 동일한 모듈 해상도 의미 체계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ba28385ee96435cb01e25cc4b9a932046f15c449" translate="yes" xml:space="preserve">
          <source>It is possible to use ES6 Arrow Functions as listeners, however, when doing so, the &lt;code&gt;this&lt;/code&gt; keyword will no longer reference the &lt;code&gt;EventEmitter&lt;/code&gt; instance:</source>
          <target state="translated">ES6 화살표 함수를 리스너로 사용할 수 있지만 그렇게하면 &lt;code&gt;this&lt;/code&gt; 키워드는 더 이상 &lt;code&gt;EventEmitter&lt;/code&gt; 인스턴스를 참조하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eceb970a4b280c5ebbc9381a566687448de43d03" translate="yes" xml:space="preserve">
          <source>It is possible to use an &lt;a href=&quot;globals#globals_class_abortsignal&quot;&gt;&amp;lt;AbortSignal&amp;gt;&lt;/a&gt; to cancel an &lt;code&gt;fs.writeFile()&lt;/code&gt;. Cancelation is &quot;best effort&quot;, and some amount of data is likely still to be written.</source>
          <target state="translated">&lt;a href=&quot;globals#globals_class_abortsignal&quot;&gt;&amp;lt;AbortSignal&amp;gt;&lt;/a&gt; 을 사용 하여 &lt;code&gt;fs.writeFile()&lt;/code&gt; 을 취소 할 수 있습니다. 취소는 &quot;최선의 노력&quot;이며 일부 데이터는 여전히 기록 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e733ce5ceec976b0d4043f067896f296736fc30" translate="yes" xml:space="preserve">
          <source>It is possible to use an &lt;a href=&quot;globals#globals_class_abortsignal&quot;&gt;&amp;lt;AbortSignal&amp;gt;&lt;/a&gt; to cancel an &lt;code&gt;fsPromises.writeFile()&lt;/code&gt;. Cancelation is &quot;best effort&quot;, and some amount of data is likely still to be written.</source>
          <target state="translated">&lt;a href=&quot;globals#globals_class_abortsignal&quot;&gt;&amp;lt;AbortSignal&amp;gt;&lt;/a&gt; 을 사용 하여 &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; 을 취소 할 수 있습니다. 취소는 &quot;최선의 노력&quot;이며 일부 데이터는 여전히 기록 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50f1c65fac5502c9e1814ed3537ba4589771ab5" translate="yes" xml:space="preserve">
          <source>It is possible to watch expression and variable values while debugging. On every breakpoint, each expression from the watchers list will be evaluated in the current context and displayed immediately before the breakpoint's source code listing.</source>
          <target state="translated">디버깅하는 동안 표현식과 변수 값을 볼 수 있습니다. 모든 중단 점에서 감시자 목록의 각 표현식은 현재 컨텍스트에서 평가되어 중단 점의 소스 코드 목록 바로 앞에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a28d0af67f353f363a2876505349b3688d12dbd" translate="yes" xml:space="preserve">
          <source>It is recommended that errors occurring during the processing of the &lt;code&gt;readable._read()&lt;/code&gt; method are emitted using the &lt;code&gt;'error'&lt;/code&gt; event rather than being thrown. Throwing an &lt;code&gt;Error&lt;/code&gt; from within &lt;code&gt;readable._read()&lt;/code&gt; can result in unexpected and inconsistent behavior depending on whether the stream is operating in flowing or paused mode. Using the &lt;code&gt;'error'&lt;/code&gt; event ensures consistent and predictable handling of errors.</source>
          <target state="translated">&lt;code&gt;readable._read()&lt;/code&gt; 메소드를 처리하는 동안 발생하는 오류는 발생 하지 않고 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 사용하여 생성하는 것이 좋습니다. &lt;code&gt;readable._read()&lt;/code&gt; 내 에서 &lt;code&gt;Error&lt;/code&gt; 를 발생 시키면 스트림이 흐름 모드 또는 일시 중지 모드에서 작동하는지에 따라 예기치 않은 동작이 발생할 수 있습니다. 은 Using &lt;code&gt;'error'&lt;/code&gt; 이벤트 것은 오류의 일관되고 예측 처리를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a056961ff3bdb7c76c478689117c030d14d553dd" translate="yes" xml:space="preserve">
          <source>It is recommended that errors occurring during the processing of the &lt;code&gt;writable._write()&lt;/code&gt; and &lt;code&gt;writable._writev()&lt;/code&gt; methods are reported by invoking the callback and passing the error as the first argument. This will cause an &lt;code&gt;'error'&lt;/code&gt; event to be emitted by the &lt;code&gt;Writable&lt;/code&gt;. Throwing an &lt;code&gt;Error&lt;/code&gt; from within &lt;code&gt;writable._write()&lt;/code&gt; can result in unexpected and inconsistent behavior depending on how the stream is being used. Using the callback ensures consistent and predictable handling of errors.</source>
          <target state="translated">콜백을 호출하고 오류를 첫 번째 인수로 전달하여 &lt;code&gt;writable._write()&lt;/code&gt; 및 &lt;code&gt;writable._writev()&lt;/code&gt; 메소드를 처리하는 동안 발생하는 오류를보고하는 것이 좋습니다 . 이것은 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 &lt;code&gt;Writable&lt;/code&gt; 에 의해 생성됩니다 . &lt;code&gt;writable._write()&lt;/code&gt; 내 에서 &lt;code&gt;Error&lt;/code&gt; 를 발생 시키면 스트림 사용 방법에 따라 예기치 않은 동작이 발생할 수 있습니다. 콜백을 사용하면 일관되고 예측 가능한 오류 처리가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="ea16402f95d8daded063cf513af19663455d8c99" translate="yes" xml:space="preserve">
          <source>It is recommended to encode public keys as &lt;code&gt;'spki'&lt;/code&gt; and private keys as &lt;code&gt;'pkcs8'&lt;/code&gt; with encryption for long-term storage:</source>
          <target state="translated">장기 저장을위한 암호화를 사용하여 공개 키를 &lt;code&gt;'spki'&lt;/code&gt; 로 , 개인 키를 &lt;code&gt;'pkcs8'&lt;/code&gt; 로 인코딩하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="be30c74885508dee4aa59c7f4ed4177d22aed095" translate="yes" xml:space="preserve">
          <source>It is required that &lt;code&gt;byte_length + byte_offset&lt;/code&gt; is less than or equal to the size in bytes of the array passed in. If not, a &lt;code&gt;RangeError&lt;/code&gt; exception is raised.</source>
          <target state="translated">는 것이 요구된다 &lt;code&gt;byte_length + byte_offset&lt;/code&gt; 전달 어레이의 바이트 크기 이하인 것이다.하는 그렇지 않으면 &lt;code&gt;RangeError&lt;/code&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="22b0f46e9ce955411b0e5f9b89cbb8973cf2da94" translate="yes" xml:space="preserve">
          <source>It is still possible to use &lt;code&gt;fs.watchFile()&lt;/code&gt;, which uses stat polling, but this method is slower and less reliable.</source>
          <target state="translated">통계 폴링 을 사용하는 &lt;code&gt;fs.watchFile()&lt;/code&gt; 을 계속 사용할 수 있지만이 방법은 느리고 신뢰성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="139b9846793e9d67315fbc1333aef413751a7253" translate="yes" xml:space="preserve">
          <source>It is strongly encouraged to place dependencies in the local &lt;code&gt;node_modules&lt;/code&gt; folder. These will be loaded faster, and more reliably.</source>
          <target state="translated">지역에 의존하는 것이 좋습니다 &lt;code&gt;node_modules&lt;/code&gt; 폴더에 . 이들은보다 빠르고 안정적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="022cb2f71f9ba41c057c015a1ac77f0d6fecfadd" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that the results of compression operations be cached to avoid duplication of effort.</source>
          <target state="translated">노력의 중복을 피하기 위해 압축 작업의 결과를 캐시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c57e947162fc04e3a4c5011c7abce4b05a307aa0" translate="yes" xml:space="preserve">
          <source>It is unsafe to call &lt;code&gt;writev()&lt;/code&gt; multiple times on the same file without waiting for the previous operation to complete.</source>
          <target state="translated">전화하는 것은 안전하지 않습니다 &lt;code&gt;writev()&lt;/code&gt; 이전 작업이 완료 될 때까지 기다리지 않고 동일한 파일에서 writev ()를 여러 번 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a074961b126d1ed61535ab8ccf81ae46b4f5b8c" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;filehandle.write()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected). For this scenario, use &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 때까지 기다리지 않고 동일한 파일에서 &lt;code&gt;filehandle.write()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다 . 이 시나리오에서는&lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa06e1e67ec61d886012a5ebbf346afac1c50178" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;filehandle.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected).</source>
          <target state="translated">동일한 파일에서 &lt;code&gt;filehandle.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. &lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 .</target>
        </trans-unit>
        <trans-unit id="327d5849595d0b2d3af0390f737024885e0b74a4" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.write()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt; is recommended.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.write()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는 &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; 이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3527578258e75386e719cb61809fc94de47660" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt; is recommended.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는&lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; 이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd51ed95a8e7ff9d29a46cc5b594661dab21ee9" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.writev()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, use &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.writev()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는 &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="622d7bb464ea01fd61d4419e05853d2d42f264a1" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be fulfilled (or rejected).</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 가 이행 (또는 거부) 될 때까지 기다리지 않고 동일한 파일에서 &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e32bdefd256d2a24661a921234ae0d689962bf7c" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected).</source>
          <target state="translated">동일한 파일에서 &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. &lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 .</target>
        </trans-unit>
        <trans-unit id="7e425dadb8e04b5a366c75f5e580a69b178cf54a" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to do this. However, if using an agent with &lt;code&gt;keepAlive&lt;/code&gt; enabled, then it is best to explicitly shut down the agent when it is no longer needed. Otherwise, sockets might stay open for quite a long time before the server terminates them.</source>
          <target state="translated">일반적으로이를 수행 할 필요는 없습니다. 그러나 &lt;code&gt;keepAlive&lt;/code&gt; 가 활성화 된 에이전트를 사용하는 경우 더 이상 필요하지 않을 때 에이전트를 명시 적으로 종료하는 것이 가장 좋습니다. 그렇지 않으면 서버가 소켓을 종료하기 전에 소켓이 오랫동안 열려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e339f1709056e0ab06d967b94bed7dafd547b83" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to do this. However, if using an agent with &lt;code&gt;keepAlive&lt;/code&gt; enabled, then it is best to explicitly shut down the agent when it will no longer be used. Otherwise, sockets may hang open for quite a long time before the server terminates them.</source>
          <target state="translated">일반적으로이 작업을 수행 할 필요는 없습니다. 그러나 에이전트를 &lt;code&gt;keepAlive&lt;/code&gt; 가 활성화 에이전트가 더 이상 사용되지 않을 때 명시 적으로 종료하는 것이 가장 좋습니다. 그렇지 않으면 서버가 소켓을 종료하기 전에 소켓이 꽤 오랫동안 열려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588053c04448ff48f8bf959f153ee214ac140018" translate="yes" xml:space="preserve">
          <source>It is very important for APIs to be either 100% synchronous or 100% asynchronous. Consider this example:</source>
          <target state="translated">API가 100 % 동기식이거나 100 % 비동기식이어야합니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0324495de22e85e0d134839d942c3962300cbac5" translate="yes" xml:space="preserve">
          <source>It keeps top-level variables (defined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;) scoped to the module rather than the global object.</source>
          <target state="translated">전역 변수가 아닌 모듈에 범위가 지정된 최상위 변수 ( &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 으로 정의 됨)를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="83e75e459c92e28df79b2b636a0f41ab57292e39" translate="yes" xml:space="preserve">
          <source>It may be useful for debugging.</source>
          <target state="translated">디버깅에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b653a9cb85ecaa0c5b1d834abf7d88df675e8a5" translate="yes" xml:space="preserve">
          <source>It must be set to a non-zero value (e.g. 120 seconds) to proctect against potential Denial-of-Service attacks in case the server is deployed without a reverse proxy in front.</source>
          <target state="translated">서버가 역방향 프록시없이 배포 된 경우 잠재적 인 서비스 거부 공격을 차단하려면 0이 아닌 값 (예 : 120 초)으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d4c4a6b07ad03b9db87fefb27c47016dd56d4f" translate="yes" xml:space="preserve">
          <source>It must belong to the same context as the parent &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">상위 &lt;code&gt;Module&lt;/code&gt; 과 동일한 컨텍스트에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="389a01fac4a0ef708ee83106d03f5176a5d0807c" translate="yes" xml:space="preserve">
          <source>It performs the inverse operation to &lt;a href=&quot;#url_url_domaintoascii_domain&quot;&gt;&lt;code&gt;url.domainToASCII()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#url_url_domaintoascii_domain&quot;&gt; &lt;code&gt;url.domainToASCII()&lt;/code&gt; &lt;/a&gt; 대한 역 연산을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="e1f3dc61a93c5fe87d9de7e00282a1c8432614fc" translate="yes" xml:space="preserve">
          <source>It performs the inverse operation to &lt;a href=&quot;#url_url_domaintounicode_domain&quot;&gt;&lt;code&gt;url.domainToUnicode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#url_url_domaintounicode_domain&quot;&gt; &lt;code&gt;url.domainToUnicode()&lt;/code&gt; &lt;/a&gt; 대한 역 연산을 수행합니다. .</target>
        </trans-unit>
        <trans-unit id="16ec379b732d9cc8bb302ba29e2ef8af384a9552" translate="yes" xml:space="preserve">
          <source>It serializes the following types of values passed in &lt;code&gt;obj&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean[]&amp;gt;&lt;/a&gt; Any other input values will be coerced to empty strings.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 전달 된 다음 유형의 값을 직렬화합니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;번호&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;부울&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;문자열 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;숫자 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;부울 []&amp;gt;&lt;/a&gt; 다른 입력 값은 빈 문자열로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b40068b622f5e568804f8433e1a279e68a06ec3" translate="yes" xml:space="preserve">
          <source>It serializes the following types of values passed in &lt;code&gt;obj&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;&amp;lt;bigint&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;&amp;lt;bigint[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean[]&amp;gt;&lt;/a&gt; The numeric values must be finite. Any other input values will be coerced to empty strings.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 전달 된 다음 유형의 값을 직렬화합니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;숫자&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;&amp;lt;bigint&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;부울&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;문자열 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;숫자 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt&quot;&gt;&amp;lt;bigint []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean []&amp;gt;&lt;/a&gt; 숫자 값은 유한해야합니다. 다른 입력 값은 빈 문자열로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f351f399c56b32725ac21458cab9068da78810d2" translate="yes" xml:space="preserve">
          <source>It supports the following option:</source>
          <target state="translated">다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="55a4bb7259c84af569c9b2e4d90c56c3c0ed3ef3" translate="yes" xml:space="preserve">
          <source>It will rarely be necessary to use &lt;code&gt;readable.wrap()&lt;/code&gt; but the method has been provided as a convenience for interacting with older Node.js applications and libraries.</source>
          <target state="translated">&lt;code&gt;readable.wrap()&lt;/code&gt; 을 사용할 필요는 거의 없습니다. 없지만 이전 Node.js 애플리케이션 및 라이브러리와의 상호 작용을위한 편의를 위해 메소드가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="1d542fd12f985c8768fbe8ead6923a0d00b50f32" translate="yes" xml:space="preserve">
          <source>It's required that &lt;code&gt;(length * size_of_element) + byte_offset&lt;/code&gt; should be &amp;lt;= the size in bytes of the array passed in. If not, a &lt;code&gt;RangeError&lt;/code&gt; exception is raised.</source>
          <target state="translated">그것은 필요하다는 사실 &lt;code&gt;(length * size_of_element) + byte_offset&lt;/code&gt; = 전달 된 배열의 크기 (바이트). &amp;lt;될 아니라면하는한다 &lt;code&gt;RangeError&lt;/code&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="42a3b56cedfed26ace470da3c86678970122c99f" translate="yes" xml:space="preserve">
          <source>Iterates over each name-value pair in the query and invokes the given function.</source>
          <target state="translated">쿼리에서 각 이름-값 쌍을 반복하고 지정된 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e605b560485e511ea1daf5880b375c721cd76bc2" translate="yes" xml:space="preserve">
          <source>Iterates through the list of functions passed to &lt;a href=&quot;#assert_tracker_calls_fn_exact&quot;&gt;&lt;code&gt;tracker.calls()&lt;/code&gt;&lt;/a&gt; and will throw an error for functions that have not been called the expected number of times.</source>
          <target state="translated">&lt;a href=&quot;#assert_tracker_calls_fn_exact&quot;&gt; &lt;code&gt;tracker.calls()&lt;/code&gt; &lt;/a&gt; 전달 된 함수 목록을 반복 하고 예상 횟수만큼 호출되지 않은 함수에 대해 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8b0eca1e364367b12a698606c4b171ea9cc0b251" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;linkingStatus&lt;/code&gt; must not be &lt;code&gt;'errored'&lt;/code&gt;.</source>
          <target state="translated">연결 상태 가 &lt;code&gt;'errored'&lt;/code&gt; &lt;code&gt;linkingStatus&lt;/code&gt; 는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c389cfb78c9e8ab8770625e5975f1207f9467241" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;status&lt;/code&gt; must not be &lt;code&gt;'errored'&lt;/code&gt;.</source>
          <target state="translated">그 &lt;code&gt;status&lt;/code&gt; 가 아니어야은 &lt;code&gt;'errored'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56643b463dc4ce55950dfcbbef495be7564e51fe" translate="yes" xml:space="preserve">
          <source>Its possible to get the ticket keys by calling &lt;a href=&quot;#tls_server_getticketkeys&quot;&gt;&lt;code&gt;server.getTicketKeys()&lt;/code&gt;&lt;/a&gt; on one server instance and then distribute them, but it is more reasonable to securely generate 48 bytes of secure random data and set them with the &lt;code&gt;ticketKeys&lt;/code&gt; option of &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt;&lt;code&gt;tls.createServer()&lt;/code&gt;&lt;/a&gt;. The keys should be regularly regenerated and server's keys can be reset with &lt;a href=&quot;#tls_server_setticketkeys_keys&quot;&gt;&lt;code&gt;server.setTicketKeys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 서버 인스턴스에서 &lt;a href=&quot;#tls_server_getticketkeys&quot;&gt; &lt;code&gt;server.getTicketKeys()&lt;/code&gt; &lt;/a&gt; 를 호출하여 티켓 키를 가져 와서 분배 할 수 있지만 48 바이트의 보안 임의 데이터를 안전하게 생성하고 &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt; &lt;code&gt;tls.createServer()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;ticketKeys&lt;/code&gt; 옵션으로 설정하는 것이 더 합리적 입니다. . 키는 정기적으로 재생성되어야하며 &lt;a href=&quot;#tls_server_setticketkeys_keys&quot;&gt; &lt;code&gt;server.setTicketKeys()&lt;/code&gt; &lt;/a&gt; 하여 서버 키를 재설정 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="d96b84d8240a01cb379b56b8ddafa735704cf6dc" translate="yes" xml:space="preserve">
          <source>JSON Modules</source>
          <target state="translated">JSON 모듈</target>
        </trans-unit>
        <trans-unit id="d99d73b448c0f1ffea6212a90bfd357cad49d279" translate="yes" xml:space="preserve">
          <source>JSON fetching example:</source>
          <target state="translated">JSON 가져 오기 예 :</target>
        </trans-unit>
        <trans-unit id="61f0767b1104231cbf534aea8ad3502fa4bdac54" translate="yes" xml:space="preserve">
          <source>JSON imports are still experimental and only supported via the &lt;code&gt;--experimental-json-modules&lt;/code&gt; flag.</source>
          <target state="translated">JSON 가져 오기는 아직 실험적이며 &lt;code&gt;--experimental-json-modules&lt;/code&gt; 플래그 를 통해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="985f971159c4193aaefd51184bf8e0f7c092a1a9" translate="yes" xml:space="preserve">
          <source>JSON modules</source>
          <target state="translated">JSON 모듈</target>
        </trans-unit>
        <trans-unit id="f7b9a43a2017f679eee5493180c26ed2f1e85185" translate="yes" xml:space="preserve">
          <source>JSON modules follow the &lt;a href=&quot;https://html.spec.whatwg.org/#creating-a-json-module-script&quot;&gt;WHATWG JSON modules specification&lt;/a&gt;.</source>
          <target state="translated">JSON 모듈은 &lt;a href=&quot;https://html.spec.whatwg.org/#creating-a-json-module-script&quot;&gt;WHATWG JSON 모듈 사양을&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="be23b85acb18166e5a08c5600a8d19dd96e42e39" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;Section 24.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;24.1 섹션&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="719a95a4bd9cf0b14d2f00175d73f2e6d748c5c3" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt;s are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;Section 24.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; 에 대해서는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;24.1 섹션&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8a0f0228ff639ea0dc5a1ba127ae8157e21154" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;DataView&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-dataview-objects&quot;&gt;Section 24.3&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;DataView&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-dataview-objects&quot;&gt;24.3 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1277ef9e321fb8f47bd20f93e6f1911ecebefc" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Date&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-date-objects&quot;&gt;Section 20.3&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-date-objects&quot;&gt;20.3 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4939241f55942c05d559f3a5b9a7e5d692c058d3" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Function&lt;/code&gt;s are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function-objects&quot;&gt;Section 19.2&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;Function&lt;/code&gt; 는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function-objects&quot;&gt;섹션 19.2&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9060b350cc54a90664674036d8765a0574ec82" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;TypedArray&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-typedarray-objects&quot;&gt;Section 22.2&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;TypedArray&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-typedarray-objects&quot;&gt;22.2 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="52cad7d4c62e41b12e029e3a1056b734751ff955" translate="yes" xml:space="preserve">
          <source>JavaScript Embedder API</source>
          <target state="translated">자바 스크립트 Embedder API</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="translated">자바 스크립트 표현식</target>
        </trans-unit>
        <trans-unit id="0c87a0c72e80e2b3ed246c907f512dd6657150a6" translate="yes" xml:space="preserve">
          <source>JavaScript arrays are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array-objects&quot;&gt;Section 22.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript 배열은 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array-objects&quot;&gt;섹션 22.1에&lt;/a&gt; 설명되어 있습니다. ECMAScript 언어 사양 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41362f31a71042ce6d33522241a4d37c00acbcd3" translate="yes" xml:space="preserve">
          <source>JavaScript cannot encode 64-bit integers. This method is intended for working with 64-bit floats.</source>
          <target state="translated">JavaScript는 64 비트 정수를 인코딩 할 수 없습니다. 이 방법은 64 비트 플로트 작업을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cec7f745469211f8ad0113b8267b2dbc38c96dca" translate="yes" xml:space="preserve">
          <source>JavaScript code can be compiled and run immediately or compiled, saved, and run later.</source>
          <target state="translated">JavaScript 코드는 즉시 컴파일 및 실행하거나 컴파일, 저장 및 나중에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9d606db4020d55005c50701236345ff97022d05" translate="yes" xml:space="preserve">
          <source>JavaScript embedder API</source>
          <target state="translated">JavaScript 임 베더 API</target>
        </trans-unit>
        <trans-unit id="917e1829cf18731633a9e9508396fcc748caf231" translate="yes" xml:space="preserve">
          <source>JavaScript expressions</source>
          <target state="translated">JavaScript 표현식</target>
        </trans-unit>
        <trans-unit id="50c23bb655ecc1d108ac1670bce1574ac9c38369" translate="yes" xml:space="preserve">
          <source>JavaScript functions can normally only be called from a native addon's main thread. If an addon creates additional threads, then N-API functions that require a &lt;code&gt;napi_env&lt;/code&gt;, &lt;code&gt;napi_value&lt;/code&gt;, or &lt;code&gt;napi_ref&lt;/code&gt; must not be called from those threads.</source>
          <target state="translated">JavaScript 함수는 일반적으로 기본 애드온의 메인 스레드에서만 호출 할 수 있습니다. 애드온이 추가 스레드를 작성하는 경우 해당 스레드에서 &lt;code&gt;napi_env&lt;/code&gt; , &lt;code&gt;napi_value&lt;/code&gt; 또는 &lt;code&gt;napi_ref&lt;/code&gt; 가 필요한 N-API 함수를 호출 하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f37b66a76531faf963b06cfaf86c9ef0c5a880f1" translate="yes" xml:space="preserve">
          <source>JavaScript string escaping requires paths to be specified with extra backslash escaping such as:</source>
          <target state="translated">JavaScript 문자열 이스케이프를 수행하려면 다음과 같은 추가 백 슬래시 이스케이프를 사용하여 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e07413b34ffd366886a0fb40b6c95efba1be0d7" translate="yes" xml:space="preserve">
          <source>JavaScript value: these are represented in N-API by &lt;code&gt;napi_value&lt;/code&gt;. This can be a &lt;code&gt;napi_value&lt;/code&gt; representing a &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Symbol&lt;/code&gt;.</source>
          <target state="translated">JavaScript 값 : 이들은 N-API에서 &lt;code&gt;napi_value&lt;/code&gt; 로 표시 됩니다. &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 또는 &lt;code&gt;Symbol&lt;/code&gt; 을 나타내는 &lt;code&gt;napi_value&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="2a646ce6b666ea8e7f9c939db95870c104b2926f" translate="yes" xml:space="preserve">
          <source>Keep in mind that spawned Node.js child processes are independent of the parent with exception of the IPC communication channel that is established between the two. Each process has its own memory, with their own V8 instances. Because of the additional resource allocations required, spawning a large number of child Node.js processes is not recommended.</source>
          <target state="translated">생성 된 Node.js 자식 프로세스는 둘 사이에 설정된 IPC 통신 채널을 제외하고 부모와 독립적이라는 점에 유의하십시오. 각 프로세스에는 자체 V8 인스턴스가있는 자체 메모리가 있습니다. 추가 리소스 할당이 필요하기 때문에 많은 수의 자식 Node.js 프로세스를 생성하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="85219482f1f7715085ff2a7c4d7bf2331f590d10" translate="yes" xml:space="preserve">
          <source>Key Type</source>
          <target state="translated">키 유형</target>
        </trans-unit>
        <trans-unit id="4a71118cb899549ef60707eb4c7093a6139cf8e2" translate="yes" xml:space="preserve">
          <source>Key events in the lifetime of asynchronous events have been categorized into four areas: instantiation, before/after the callback is called, and when the instance is destroyed.</source>
          <target state="translated">비동기 이벤트 수명의 주요 이벤트는 인스턴스화, 콜백 이전 / 이후 및 인스턴스가 소멸되는 4 가지 영역으로 분류되었습니다.</target>
        </trans-unit>
        <trans-unit id="42fd293e6b52b92ee891b25260a8dcb7640476d7" translate="yes" xml:space="preserve">
          <source>Key-value pairs of header names and values. Header names are lower-cased.</source>
          <target state="translated">헤더 이름과 값의 키-값 쌍. 헤더 이름은 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="0219bac0488bb0b49dd2dc78aa3d21e7f7786afc" translate="yes" xml:space="preserve">
          <source>KeyObject</source>
          <target state="translated">KeyObject</target>
        </trans-unit>
        <trans-unit id="2cc8ec97bf0278d6ea5a1e7e27f117cb103c0fd7" translate="yes" xml:space="preserve">
          <source>Keybindings</source>
          <target state="translated">Keybindings</target>
        </trans-unit>
        <trans-unit id="736612bdaab47ddf51cb2896ce71e8f600786271" translate="yes" xml:space="preserve">
          <source>Keying material is used for validations to prevent different kind of attacks in network protocols, for example in the specifications of IEEE 802.1X.</source>
          <target state="translated">키 자료는 IEEE 802.1X 사양과 같은 네트워크 프로토콜에서 다른 종류의 공격을 방지하기위한 유효성 검사에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90247e04a9ab9c31144526b27a99cafa47c9ed23" translate="yes" xml:space="preserve">
          <source>Keys are lowercased. Values are not modified.</source>
          <target state="translated">키는 소문자입니다. 값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="be4d0497bc308dc68e2b86f9d700c936ee0973b7" translate="yes" xml:space="preserve">
          <source>Launching Node.js using the &lt;code&gt;--throw-deprecation&lt;/code&gt; command line flag will cause custom deprecation warnings to be thrown as exceptions.</source>
          <target state="translated">&lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 사용하여 Node.js를 시작 하면 사용자 지정 지원 중단 경고가 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="589aa56dcb4ae2243331e70e2c456e0e3f10ee92" translate="yes" xml:space="preserve">
          <source>Launching Node.js using the &lt;code&gt;--throw-deprecation&lt;/code&gt; command-line flag will cause custom deprecation warnings to be thrown as exceptions.</source>
          <target state="translated">&lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 사용하여 Node.js를 시작 하면 사용자 지정 지원 중단 경고가 예외로 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcbad204095230ea14447be64d133cef03f50d2" translate="yes" xml:space="preserve">
          <source>Launching the Node.js process as:</source>
          <target state="translated">Node.js 프로세스를 다음과 같이 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7d3f1e7fa18067320d712dd92e8eec071149da" translate="yes" xml:space="preserve">
          <source>Left arrow</source>
          <target state="translated">왼쪽 화살표</target>
        </trans-unit>
        <trans-unit id="bc8751555a3239b7dac027ac31b93be45c7a72a5" translate="yes" xml:space="preserve">
          <source>Legacy &lt;code&gt;urlObject&lt;/code&gt;</source>
          <target state="translated">기존 &lt;code&gt;urlObject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">레거시 API</target>
        </trans-unit>
        <trans-unit id="fff0473a6005f02c6ee988eeea5c4589c0cee01e" translate="yes" xml:space="preserve">
          <source>Legacy Node.js Error Codes</source>
          <target state="translated">레거시 Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="f2f3e644bfa273f7a62a339c8c67d92c2d023797" translate="yes" xml:space="preserve">
          <source>Legacy Node.js error codes</source>
          <target state="translated">레거시 Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="2c20dd0e85aff7e0a43472ec0bd080ec8d34d100" translate="yes" xml:space="preserve">
          <source>Legacy Streams API (pre Node.js v0.10)</source>
          <target state="translated">레거시 스트림 API (Pre Node.js v0.10)</target>
        </trans-unit>
        <trans-unit id="c20be4f6f706ee94b9055b8d2bb127f7bf2f5336" translate="yes" xml:space="preserve">
          <source>Legacy URL API</source>
          <target state="translated">레거시 URL API</target>
        </trans-unit>
        <trans-unit id="c49890f6e5c25894c8780c745056d41986aa3353" translate="yes" xml:space="preserve">
          <source>Legacy assertion mode</source>
          <target state="translated">레거시 어설 션 모드</target>
        </trans-unit>
        <trans-unit id="690cbb84b7e6358f848c556655c562eb7808ca07" translate="yes" xml:space="preserve">
          <source>Legacy assertion mode uses the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;Abstract Equality Comparison&lt;/a&gt; in:</source>
          <target state="translated">레거시 어설 션 모드는 다음에서 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;추상 동등 비교&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d5edbf5c71f5ce411aa5b2426065109df221ad37" translate="yes" xml:space="preserve">
          <source>Legacy mode</source>
          <target state="translated">레거시 모드</target>
        </trans-unit>
        <trans-unit id="cd1cabfb965ba7b42cb732ed586da70b61d4573f" translate="yes" xml:space="preserve">
          <source>Legacy mode uses the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;Abstract Equality Comparison&lt;/a&gt; in:</source>
          <target state="translated">레거시 모드는 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;추상 평등 비교를&lt;/a&gt; 사용합니다 를 .</target>
        </trans-unit>
        <trans-unit id="afa63d440d39b6489812f1ff0f0264d475824636" translate="yes" xml:space="preserve">
          <source>Legacy streams API (prior to Node.js 0.10)</source>
          <target state="translated">레거시 스트림 API (Node.js 0.10 이전)</target>
        </trans-unit>
        <trans-unit id="461cb9806496bebf38f62add29762de4f9878b5d" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;directoryKeys&lt;/em&gt; be the list of keys of &lt;em&gt;exports&lt;/em&gt; ending in &lt;em&gt;&quot;/&quot;&lt;/em&gt;, sorted by length descending.</source>
          <target state="translated">하자 &lt;em&gt;directoryKeys이&lt;/em&gt; 의 키 목록이 될 &lt;em&gt;수출&lt;/em&gt; 로 끝나는 &lt;em&gt;&quot;/&quot;&lt;/em&gt; , 길이 내림차순으로 분류.</target>
        </trans-unit>
        <trans-unit id="238d8642800d4e2e91641682a42b5accc596aa90" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;expansionKeys&lt;/em&gt; be the list of keys of &lt;em&gt;matchObj&lt;/em&gt; ending in &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;*&quot;&lt;/em&gt;, sorted by length descending.</source>
          <target state="translated">하자 &lt;em&gt;expansionKeys이&lt;/em&gt; 의 키 목록이 될 &lt;em&gt;matchObj&lt;/em&gt; 로 끝나는 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;*&quot;&lt;/em&gt; , 길이 내림차순으로 분류.</target>
        </trans-unit>
        <trans-unit id="ed43a3cca8d0829c50efa33ad8a1735744b22695" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;exports&lt;/em&gt; be &lt;em&gt;pjson.exports&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;수출&lt;/em&gt; 될 &lt;em&gt;pjson.exports&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="81d341d451b4f23afb843c097d49a45ca52c1763" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;format&lt;/em&gt; be the result of &lt;strong&gt;ESM_FORMAT&lt;/strong&gt;(&lt;em&gt;resolved&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;형식&lt;/em&gt; 의 결과 &lt;strong&gt;ESM_FORMAT&lt;/strong&gt; ( &lt;em&gt;해결&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd1edf85bc7e8552161c136541aa74c4bb663ae6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;format&lt;/em&gt; be the result of &lt;strong&gt;ESM_FORMAT&lt;/strong&gt;(&lt;em&gt;resolvedURL&lt;/em&gt;, &lt;em&gt;isMain&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;형식&lt;/em&gt; 의 결과 &lt;strong&gt;ESM_FORMAT&lt;/strong&gt; ( &lt;em&gt;resolvedURL&lt;/em&gt; , &lt;em&gt;isMain&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e2049abb9ba314181946c48daedfb30d6cac2d4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;legacyMainURL&lt;/em&gt; be the result applying the legacy &lt;strong&gt;LOAD_AS_DIRECTORY&lt;/strong&gt; CommonJS resolver to &lt;em&gt;packageURL&lt;/em&gt;, throwing a &lt;em&gt;Module Not Found&lt;/em&gt; error for no resolution.</source>
          <target state="translated">하자 &lt;em&gt;legacyMainURL는&lt;/em&gt; 기존 적용한 결과 일 수 &lt;strong&gt;LOAD_AS_DIRECTORY&lt;/strong&gt; 에 CommonJS의 해결을 &lt;em&gt;PACKAGEURL&lt;/em&gt; 던지는, &lt;em&gt;모듈을 찾을 수 없습니다&lt;/em&gt; 어떤 해결을 위해 오류입니다.</target>
        </trans-unit>
        <trans-unit id="bee1b70b523ce66dc44d421b5c0494d728fae4ca" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;mainExport&lt;/em&gt; be &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">하자 &lt;em&gt;mainExport이&lt;/em&gt; 될 &lt;strong&gt;정의되지&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c81e55b25ae69be4df19f32567a31664526acb27" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;matchKey&lt;/em&gt; be the string &lt;em&gt;&quot;./&quot;&lt;/em&gt; concatenated with &lt;em&gt;subpath&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;matchKey이&lt;/em&gt; 문자열 일 &lt;em&gt;&quot;./&quot;&lt;/em&gt; 와 연결 &lt;em&gt;서브 패스&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="382b20b41c3fc6df5c3fd1360c69bcd4bdb1e7b4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageName&lt;/em&gt; be &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;여기서 packageName이&lt;/em&gt; 될 &lt;em&gt;정의되지&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="07e24d67055d0d7ff4f488268b521db51a5de6d3" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageName&lt;/em&gt; be &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">하자 &lt;em&gt;여기서 packageName이&lt;/em&gt; 될 &lt;strong&gt;정의되지&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ce1bb2436be75a438429e67d7dabfd4581d93455" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageSubpath&lt;/em&gt; be &lt;em&gt;&quot;.&quot;&lt;/em&gt; concatenated with the substring of &lt;em&gt;packageSpecifier&lt;/em&gt; from the position at the length of &lt;em&gt;packageName&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;packageSubpath가&lt;/em&gt; 될 &lt;em&gt;&quot;.&quot; &lt;/em&gt;&lt;em&gt;packageName&lt;/em&gt; 의 길이에있는 위치에서 &lt;em&gt;packageSpecifier&lt;/em&gt; 의 하위 문자열과 연결됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d816a69a606558435c2f7bf214574701cee0921" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageSubpath&lt;/em&gt; be &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;packageSubpath이&lt;/em&gt; 될 &lt;em&gt;정의되지&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3879a2c60ae8d9f31de4e2f2d3064c3f0a2e8df0" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageURL&lt;/em&gt; be the URL resolution of &lt;em&gt;&quot;node_modules/&quot;&lt;/em&gt; concatenated with &lt;em&gt;packageSpecifier&lt;/em&gt;, relative to &lt;em&gt;parentURL&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;PACKAGEURL가&lt;/em&gt; 의 URL의 해상도는 &lt;em&gt;&quot;node_modules /&quot;&lt;/em&gt; 와 연결 &lt;em&gt;packageSpecifier&lt;/em&gt; 을 기준으로, &lt;em&gt;parentURL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec862b5268642383a7fa543609b749e1b9b9ad8" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageURL&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt;(&lt;em&gt;parentURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;PACKAGEURL이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt; ( &lt;em&gt;parentURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e82e8cf4cd3d2806cefa31d11b42457fe816e03" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt;(&lt;em&gt;packageURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd3c96f5f0c598b9a6ae47e36bce4121bbd96e8" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt;(&lt;em&gt;scopeURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt; ( &lt;em&gt;scopeURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f236242b656b209b4a987cbd649a5c634a38f6f6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt;(&lt;em&gt;url&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt; ( &lt;em&gt;URL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7efdf0ad8c2e8e15cf9c24ae647213041bbfe4d" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjsonURL&lt;/em&gt; be the resolution of &lt;em&gt;&quot;package.json&quot;&lt;/em&gt; within &lt;em&gt;packageURL&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;pjsonURL이&lt;/em&gt; 의 해상도는 &lt;em&gt;&quot;package.json&quot;&lt;/em&gt; 내 &lt;em&gt;PACKAGEURL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e6e7ea60e186d1adbc7f7db3cc553716c4ddcc" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">하자 &lt;em&gt;가 해결&lt;/em&gt; 될 &lt;strong&gt;정의되지 않은&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3e85c83e3ea0b6dee0e7b7a3595ed1051fc6f538" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the URL resolution of the concatenation of &lt;em&gt;subpath&lt;/em&gt; and &lt;em&gt;resolvedTarget&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;subpath&lt;/em&gt; 와 &lt;em&gt;resolvedTarget&lt;/em&gt; 의 연결에 대한 URL 확인을 &lt;em&gt;해결&lt;/em&gt; 하자 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e2ee789e16379e2ecc056e36d8d03d2ab18d4c4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_EXPORTS_TARGET_RESOLVE&lt;/strong&gt;(&lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;targetValue&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;), continuing the loop on abrupt completion.</source>
          <target state="translated">하자 &lt;em&gt;해결&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_EXPORTS_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;em&gt;targetValue&lt;/em&gt; , &lt;em&gt;서브 패스&lt;/em&gt; ) 갑작스러운 완료에 루프를 계속.</target>
        </trans-unit>
        <trans-unit id="243345f737d47e69ad63b915c83c02e8578289f9" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;mainExport&lt;/em&gt;, &lt;em&gt;&quot;&quot;&lt;/em&gt;, &lt;strong&gt;false&lt;/strong&gt;, &lt;strong&gt;false&lt;/strong&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">&lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;packageURL&lt;/em&gt; , &lt;em&gt;mainExport&lt;/em&gt; , &lt;em&gt;&quot;&quot;&lt;/em&gt; , &lt;strong&gt;false&lt;/strong&gt; , &lt;strong&gt;false&lt;/strong&gt; , &lt;em&gt;conditions&lt;/em&gt; ) 의 결과로 &lt;em&gt;해결&lt;/em&gt; 하겠습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e3133d6b4733828af60caaae154fd26afd03ac4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;&quot;&quot;&lt;/em&gt;, &lt;strong&gt;false&lt;/strong&gt;, &lt;em&gt;isImports&lt;/em&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">&lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;packageURL&lt;/em&gt; , &lt;em&gt;target&lt;/em&gt; , &lt;em&gt;&quot;&quot;&lt;/em&gt; , &lt;strong&gt;false&lt;/strong&gt; , &lt;em&gt;isImports&lt;/em&gt; , &lt;em&gt;conditions&lt;/em&gt; ) 의 결과로 &lt;em&gt;해결&lt;/em&gt; 하겠습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c3a2de04bbe5cf6d3001d3a8d92aaf018b3eab6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;, &lt;strong&gt;false&lt;/strong&gt;, &lt;em&gt;isImports&lt;/em&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;해결&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;em&gt;대상&lt;/em&gt; , &lt;em&gt;서브 패스&lt;/em&gt; , &lt;strong&gt;거짓&lt;/strong&gt; , &lt;em&gt;isImports&lt;/em&gt; , &lt;em&gt;조건&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2acbd60ce691239185ec3a3872052a6f85a88f8" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;, &lt;strong&gt;true&lt;/strong&gt;, &lt;em&gt;isImports&lt;/em&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;해결&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;em&gt;대상&lt;/em&gt; , &lt;em&gt;서브 패스&lt;/em&gt; , &lt;strong&gt;사실&lt;/strong&gt; , &lt;em&gt;isImports&lt;/em&gt; , &lt;em&gt;조건&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d3668b83f08a9290de67e840d257b71bc618bed9" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;targetValue&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;, &lt;em&gt;pattern&lt;/em&gt;, &lt;em&gt;internal&lt;/em&gt;, &lt;em&gt;conditions&lt;/em&gt;), continuing the loop on any &lt;em&gt;Invalid Package Target&lt;/em&gt; error.</source>
          <target state="translated">하자 &lt;em&gt;해결&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;em&gt;targetValue&lt;/em&gt; , &lt;em&gt;서브 패스&lt;/em&gt; , &lt;em&gt;패턴&lt;/em&gt; , &lt;em&gt;내부&lt;/em&gt; , &lt;em&gt;조건&lt;/em&gt; 어떤에 루프 계속) &lt;em&gt;잘못된 포장 대상&lt;/em&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2f774a01f0fa2f390a53fef5b7dc928702cca0b0" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt;( &lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;targetValue&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;, &lt;em&gt;pattern&lt;/em&gt;, &lt;em&gt;internal&lt;/em&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">&lt;strong&gt;PACKAGE_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;packageURL&lt;/em&gt; , &lt;em&gt;targetValue&lt;/em&gt; , &lt;em&gt;subpath&lt;/em&gt; , &lt;em&gt;pattern&lt;/em&gt; , &lt;em&gt;internal&lt;/em&gt; , &lt;em&gt;conditions&lt;/em&gt; ) 의 결과로 &lt;em&gt;해결&lt;/em&gt; 하겠습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79e52620ed2cc63ebf756b6791942858e8a11582" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedMain&lt;/em&gt; be the URL resolution of &lt;em&gt;packageURL&lt;/em&gt;, &quot;/&quot;, and &lt;em&gt;pjson.main&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedMain가&lt;/em&gt; 의 URL의 해상도는 &lt;em&gt;PACKAGEURL&lt;/em&gt; , &quot;/&quot;, 및 &lt;em&gt;pjson.main&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f80afb0110f0ca106fa01e077ca229073f534c6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedMatch&lt;/em&gt; be result of &lt;strong&gt;PACKAGE_IMPORTS_EXPORTS_RESOLVE&lt;/strong&gt;( &lt;em&gt;matchKey&lt;/em&gt;, &lt;em&gt;exports&lt;/em&gt;, &lt;em&gt;packageURL&lt;/em&gt;, &lt;strong&gt;false&lt;/strong&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;resolvedMatch이&lt;/em&gt; 의 결과 일 수 &lt;strong&gt;PACKAGE_IMPORTS_EXPORTS_RESOLVE&lt;/strong&gt; ( &lt;em&gt;matchKey&lt;/em&gt; , &lt;em&gt;수출&lt;/em&gt; , &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;strong&gt;거짓&lt;/strong&gt; , &lt;em&gt;조건&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="b05bce46a2384c271777930978a6e81a4b6eb0ee" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedMatch&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_IMPORTS_EXPORTS_RESOLVE&lt;/strong&gt;(&lt;em&gt;specifier&lt;/em&gt;, &lt;em&gt;pjson.imports&lt;/em&gt;, &lt;em&gt;packageURL&lt;/em&gt;, &lt;strong&gt;true&lt;/strong&gt;, &lt;em&gt;conditions&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;resolvedMatch이&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_IMPORTS_EXPORTS_RESOLVE&lt;/strong&gt; ( &lt;em&gt;지정&lt;/em&gt; , &lt;em&gt;pjson.imports&lt;/em&gt; , &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;strong&gt;사실&lt;/strong&gt; , &lt;em&gt;조건&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ff7aedeb5d501d6e47d5396e51dcb3bb302bb04" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedTarget&lt;/em&gt; be the URL resolution of the concatenation of &lt;em&gt;packageURL&lt;/em&gt; and &lt;em&gt;target&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedTarget이&lt;/em&gt; 의 연결의 URL의 해상도는 &lt;em&gt;PACKAGEURL&lt;/em&gt; 및 &lt;em&gt;대상&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5df506eb548277050de9692d3004f4e6b5b2aa9c" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedURL&lt;/em&gt; be &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedURL이&lt;/em&gt; 될 &lt;strong&gt;정의되지&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="82a293d31acbcb53e85a6f620e95bc60fec4dd62" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;scopeURL&lt;/em&gt; be &lt;em&gt;url&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; scopeURL가&lt;/em&gt; 될 &lt;em&gt;URL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c9bffb2320070f980f92960ea814b81c98162c" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;selfUrl&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_SELF_RESOLVE&lt;/strong&gt;(&lt;em&gt;packageName&lt;/em&gt;, &lt;em&gt;packageSubpath&lt;/em&gt;, &lt;em&gt;parentURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;selfUrl이&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_SELF_RESOLVE&lt;/strong&gt; ( &lt;em&gt;여기서 packageName&lt;/em&gt; , &lt;em&gt;packageSubpath&lt;/em&gt; , &lt;em&gt;parentURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="08f8d35a848d41b4dfdd85e8913a79da3444f87c" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;subpath&lt;/em&gt; be the substring of &lt;em&gt;matchKey&lt;/em&gt; starting at the index of the length of &lt;em&gt;expansionKey&lt;/em&gt; minus one.</source>
          <target state="translated">하자 &lt;em&gt;서브 패스가&lt;/em&gt; 의 문자열이 될 &lt;em&gt;matchKey&lt;/em&gt; 의 길이의 인덱스에서 시작 &lt;em&gt;expansionKey&lt;/em&gt; 을 뺀.</target>
        </trans-unit>
        <trans-unit id="723920f325a1eaab25de57cc41b1807f2212eaac" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;subpath&lt;/em&gt; be the substring of &lt;em&gt;matchKey&lt;/em&gt; starting at the index of the length of &lt;em&gt;expansionKey&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;서브 패스가&lt;/em&gt; 의 문자열이 될 &lt;em&gt;matchKey&lt;/em&gt; 의 길이의 인덱스에서 시작 &lt;em&gt;expansionKey&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e7dfbc5cc254de35a61a79580bcfc017d43a648a" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;subpath&lt;/em&gt; be the substring of &lt;em&gt;target&lt;/em&gt; starting at the index of the length of &lt;em&gt;directory&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;서브 패스가&lt;/em&gt; 의 문자열을 수&lt;em&gt; 목표&lt;/em&gt; 의 길이의 인덱스로 시작되는 &lt;em&gt;디렉토리&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce6d12ce9449fc911cc9f55c4eb8f68b7cd7887" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;exports[directory]&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; 대상&lt;/em&gt; 의 값이 &lt;em&gt;수출 [디렉토리]&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="197f5bec0ba9b0be792276cfd7d785ccdea0317a" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;exports[packagePath]&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; 표적&lt;/em&gt; 의 값 &lt;em&gt;[packagePath를] 수출&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1dd4140c5c0ad8c3c5f937b4044187ed0f524d" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;matchObj&lt;/em&gt;[&lt;em&gt;expansionKey&lt;/em&gt;].</source>
          <target state="translated">하자 &lt;em&gt;표적&lt;/em&gt; 의 값 &lt;em&gt;matchObj&lt;/em&gt; [ &lt;em&gt;expansionKey&lt;/em&gt; ].</target>
        </trans-unit>
        <trans-unit id="b3ca0876445e4e9e9e2d939e4491cfec452fe09a" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;matchObj&lt;/em&gt;[&lt;em&gt;matchKey&lt;/em&gt;].</source>
          <target state="translated">하자 &lt;em&gt;표적&lt;/em&gt; 의 값 &lt;em&gt;matchObj&lt;/em&gt; [ &lt;em&gt;matchKey&lt;/em&gt; ].</target>
        </trans-unit>
        <trans-unit id="078cd06ccd80615abc8b12af507acd7c2c70e6a6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;targetValue&lt;/em&gt; be the value of the &lt;em&gt;p&lt;/em&gt; property in &lt;em&gt;target&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;targetValue가&lt;/em&gt; 의 값이 될 &lt;em&gt;페이지의&lt;/em&gt; 재산 &lt;em&gt;대상&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c05022795ff4fc80ccdb0eaa2b31a46cf687fbad" translate="yes" xml:space="preserve">
          <source>Let's say that we wanted to have the folder at &lt;code&gt;/usr/lib/node/&amp;lt;some-package&amp;gt;/&amp;lt;some-version&amp;gt;&lt;/code&gt; hold the contents of a specific version of a package.</source>
          <target state="translated">&lt;code&gt;/usr/lib/node/&amp;lt;some-package&amp;gt;/&amp;lt;some-version&amp;gt;&lt;/code&gt; 에 있는 폴더 가 특정 버전의 패키지 내용을 보유하고 싶다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="a50e6d474036a02bdd71609b13906ac7a2a3f78b" translate="yes" xml:space="preserve">
          <source>Library developers that handle their own asynchronous resources performing tasks like I/O, connection pooling, or managing callback queues may use the &lt;code&gt;AsyncResource&lt;/code&gt; JavaScript API so that all the appropriate callbacks are called.</source>
          <target state="translated">I / O, 연결 풀링 또는 콜백 대기열 관리와 같은 작업을 수행하는 자체 비동기 리소스를 처리하는 라이브러리 개발자는 모든 적절한 콜백이 호출되도록 &lt;code&gt;AsyncResource&lt;/code&gt; JavaScript API를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="494a09f021c47478da7edc0019571233304558a0" translate="yes" xml:space="preserve">
          <source>Library developers that handle their own asynchronous resources performing tasks like I/O, connection pooling, or managing callback queues may use the &lt;code&gt;AsyncWrap&lt;/code&gt; JavaScript API so that all the appropriate callbacks are called.</source>
          <target state="translated">I / O, 연결 풀링 또는 콜백 대기열 관리와 같은 작업을 수행하는 자체 비동기 리소스를 처리하는 라이브러리 개발자는 &lt;code&gt;AsyncWrap&lt;/code&gt; 을 JavaScript API를 모든 적절한 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ca7e018936674f1d60758637269700311826fef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#fs_class_fs_readstream&quot;&gt;&lt;code&gt;ReadStream&lt;/code&gt;&lt;/a&gt;, if &lt;code&gt;fd&lt;/code&gt; is specified, &lt;a href=&quot;#fs_class_fs_writestream&quot;&gt;&lt;code&gt;WriteStream&lt;/code&gt;&lt;/a&gt; will ignore the &lt;code&gt;path&lt;/code&gt; argument and will use the specified file descriptor. This means that no &lt;code&gt;'open'&lt;/code&gt; event will be emitted. &lt;code&gt;fd&lt;/code&gt; should be blocking; non-blocking &lt;code&gt;fd&lt;/code&gt;s should be passed to &lt;a href=&quot;net#net_class_net_socket&quot;&gt;&lt;code&gt;net.Socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#fs_class_fs_readstream&quot;&gt; &lt;code&gt;ReadStream&lt;/code&gt; &lt;/a&gt; 경우, &lt;code&gt;fd&lt;/code&gt; 지정되어, &lt;a href=&quot;#fs_class_fs_writestream&quot;&gt; &lt;code&gt;WriteStream&lt;/code&gt; 는&lt;/a&gt; 무시됩니다 &lt;code&gt;path&lt;/code&gt; 인수를 지정된 파일 기술자를 사용합니다. 이것은 &lt;code&gt;'open'&lt;/code&gt; 이벤트가 발생 하지 않음을 의미합니다 . &lt;code&gt;fd&lt;/code&gt; 는 차단해야합니다. 비 차단 &lt;code&gt;fd&lt;/code&gt; 는&lt;a href=&quot;net#net_class_net_socket&quot;&gt; &lt;code&gt;net.Socket&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="851f0f8a8001316f6429280c11651db02e375ab1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;http#http_http_get_options_callback&quot;&gt;&lt;code&gt;http.get()&lt;/code&gt;&lt;/a&gt; but for HTTPS.</source>
          <target state="translated">처럼 &lt;a href=&quot;http#http_http_get_options_callback&quot;&gt; &lt;code&gt;http.get()&lt;/code&gt; &lt;/a&gt; 하지만 HTTPS 용입니다.</target>
        </trans-unit>
        <trans-unit id="643276916be86da834620569b341d9177bff2e84" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Workers&lt;/a&gt; and the &lt;a href=&quot;cluster&quot;&gt;&lt;code&gt;cluster&lt;/code&gt; module&lt;/a&gt;, two-way communication can be achieved through inter-thread message passing. Internally, a &lt;code&gt;Worker&lt;/code&gt; has a built-in pair of &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt;s that are already associated with each other when the &lt;code&gt;Worker&lt;/code&gt; is created. While the &lt;code&gt;MessagePort&lt;/code&gt; object on the parent side is not directly exposed, its functionalities are exposed through &lt;a href=&quot;#worker_threads_worker_postmessage_value_transferlist&quot;&gt;&lt;code&gt;worker.postMessage()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;#worker_threads_event_message_1&quot;&gt;&lt;code&gt;worker.on('message')&lt;/code&gt;&lt;/a&gt; event on the &lt;code&gt;Worker&lt;/code&gt; object for the parent thread.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt; &lt;code&gt;cluster&lt;/code&gt; 모듈&lt;/a&gt; 과 마찬가지로 스레드 간 메시지 전달을 통해 양방향 통신을 수행 할 수 있습니다. 내부적으로 &lt;code&gt;Worker&lt;/code&gt; 에는 &lt;code&gt;Worker&lt;/code&gt; 가 만들어 질 때 이미 서로 연결된 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 쌍이 내장되어 있습니다. 부모 측 의 &lt;code&gt;MessagePort&lt;/code&gt; 객체는 직접 노출되지 않지만 그 기능은 &lt;a href=&quot;#worker_threads_worker_postmessage_value_transferlist&quot;&gt; &lt;code&gt;worker.postMessage()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#worker_threads_event_message_1&quot;&gt; &lt;code&gt;worker.on('message')&lt;/code&gt; &lt;/a&gt; 이벤트 를 통해 부모 스레드 의 &lt;code&gt;Worker&lt;/code&gt; 객체에서 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dbd9c14005cc13742bdf9a1be2f6cfdb9bd756e" translate="yes" xml:space="preserve">
          <source>Like in CommonJS, files within packages can be accessed by appending a path to the package name.</source>
          <target state="translated">CommonJS와 마찬가지로 패키지 이름에 경로를 추가하여 패키지 내의 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a306faea3518b2a195011b48f1651813064985f7" translate="yes" xml:space="preserve">
          <source>Like in CommonJS, files within packages can be accessed by appending a path to the package name; unless the package&amp;rsquo;s &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; contains an &lt;a href=&quot;packages#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field, in which case files within packages need to be accessed via the path defined in &lt;a href=&quot;packages#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CommonJS에서와 같이 패키지 이름에 경로를 추가하여 패키지 내의 파일에 액세스 할 수 있습니다. 패키지의하지 않는 한 &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; 는&lt;/a&gt; 포함 &lt;a href=&quot;packages#packages_exports&quot;&gt; &lt;code&gt;&quot;exports&quot;&lt;/code&gt; &lt;/a&gt; 패키지 내 경우 파일에 정의 된 경로를 통해 액세스해야하는 필드, &lt;a href=&quot;packages#packages_exports&quot;&gt; &lt;code&gt;&quot;exports&quot;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea34c0a5f160248cca821308caf8a5453398e4e5" translate="yes" xml:space="preserve">
          <source>Like in CommonJS, module files within packages can be accessed by appending a path to the package name unless the package&amp;rsquo;s &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; contains an &lt;a href=&quot;packages#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; field, in which case files within packages can only be accessed via the paths defined in &lt;a href=&quot;packages#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CommonJS와 마찬가지로 패키지의 &lt;a href=&quot;packages#packages_node_js_package_json_field_definitions&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;packages#packages_exports&quot;&gt; &lt;code&gt;&quot;exports&quot;&lt;/code&gt; &lt;/a&gt; 필드 가 포함되어 있지 않으면 패키지 내의 모듈 파일은 패키지 이름에 경로를 추가하여 액세스 할 수 있습니다 .이 경우 패키지 내의 파일은 &lt;a href=&quot;packages#packages_exports&quot;&gt; &lt;code&gt;&quot;exports&quot;&lt;/code&gt; 에&lt;/a&gt; 정의 된 경로를 통해서만 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="a4b5a42854b5eed52a170023a09f02fc6d959468" translate="yes" xml:space="preserve">
          <source>Likewise, changing from a non-special protocol to a special protocol is also not permitted:</source>
          <target state="translated">마찬가지로 비 특수 프로토콜에서 특수 프로토콜로 변경하는 것도 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06dd6783b6493064f30b8f1541b693a42e5ccd3c" translate="yes" xml:space="preserve">
          <source>Limit engine usage to CIPHERS</source>
          <target state="translated">CIPHERS로 엔진 사용 제한</target>
        </trans-unit>
        <trans-unit id="93986208e144b83e2c97be29664bbada85c8e0bd" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DH</source>
          <target state="translated">엔진 사용을 DH로 제한</target>
        </trans-unit>
        <trans-unit id="9f5015c701e9eb1d4dc682b1335a18b14503b0f5" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DIGESTS</source>
          <target state="translated">엔진 사용을 DIGESTS로 제한</target>
        </trans-unit>
        <trans-unit id="d78c46d774a0e75daea31d4c9cffa2c56e543091" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DSA</source>
          <target state="translated">엔진 사용을 DSA로 제한</target>
        </trans-unit>
        <trans-unit id="8732a9dbae5a0828ffbb44002b1242202da2c9de" translate="yes" xml:space="preserve">
          <source>Limit engine usage to EC</source>
          <target state="translated">엔진 사용을 EC로 제한</target>
        </trans-unit>
        <trans-unit id="cdcab6206e8a488e5549d5ec3e6b1d5da76478c8" translate="yes" xml:space="preserve">
          <source>Limit engine usage to PKEY_ASN1_METHS</source>
          <target state="translated">엔진 사용을 PKEY_ASN1_METHS로 제한</target>
        </trans-unit>
        <trans-unit id="87885cad223c9bd4e4894b1854a73b7f044844b0" translate="yes" xml:space="preserve">
          <source>Limit engine usage to PKEY_METHDS</source>
          <target state="translated">엔진 사용을 PKEY_METHDS로 제한</target>
        </trans-unit>
        <trans-unit id="4022d5e22f1d34c3d5c81034adf42f203a7574aa" translate="yes" xml:space="preserve">
          <source>Limit engine usage to RAND</source>
          <target state="translated">엔진 사용을 RAND로 제한</target>
        </trans-unit>
        <trans-unit id="9deea2b1b94be12b96f38053a33676be8cc7d149" translate="yes" xml:space="preserve">
          <source>Limit engine usage to RSA</source>
          <target state="translated">엔진 사용을 RSA로 제한</target>
        </trans-unit>
        <trans-unit id="1450afe809ec7487cbb884eaae49c4b7de1dd9ef" translate="yes" xml:space="preserve">
          <source>Limit the amount of time the parser will wait to receive the complete HTTP headers.</source>
          <target state="translated">구문 분석기가 완전한 HTTP 헤더를 수신하기 위해 대기하는 시간을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="f203cc5a857dde040cc3f179c0e2e65d49f9ce37" translate="yes" xml:space="preserve">
          <source>Limits maximum incoming headers count. If set to 0, no limit will be applied.</source>
          <target state="translated">최대 수신 헤더 수를 제한합니다. 0으로 설정하면 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9201ce577050bd27894faffcae483339dbb7b78e" translate="yes" xml:space="preserve">
          <source>Limits maximum response headers count. If set to 0, no limit will be applied.</source>
          <target state="translated">최대 응답 헤더 수를 제한합니다. 0으로 설정하면 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8830812642973350a9e42a8556343932c261db90" translate="yes" xml:space="preserve">
          <source>Link module dependencies. This method must be called before evaluation, and can only be called once per module.</source>
          <target state="translated">링크 모듈 종속성. 이 메서드는 평가 전에 호출해야하며 모듈 당 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80016ec82b8321d01a31f3c875531ddcc399155d" translate="yes" xml:space="preserve">
          <source>Link module dependencies. This method must be called before instantiation, and can only be called once per module.</source>
          <target state="translated">링크 모듈 의존성. 이 메소드는 인스턴스화 전에 호출해야하며 모듈 당 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99751c95e6330f5ee80abdd67407538e0c2ab2d7" translate="yes" xml:space="preserve">
          <source>Linking has failed for this module (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt;)</source>
          <target state="translated">이 모듈에 대한 연결에 실패했습니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt; errored ' )</target>
        </trans-unit>
        <trans-unit id="6137853119d6841cba11a0baee353a57f0a1174f" translate="yes" xml:space="preserve">
          <source>Linking to Node.js' own dependencies</source>
          <target state="translated">Node.js의 의존성에 연결</target>
        </trans-unit>
        <trans-unit id="86bcbc2266c976e9c766fb200065c8f5e6acedaf" translate="yes" xml:space="preserve">
          <source>Linking to libraries included with Node.js</source>
          <target state="translated">Node.js에 포함 된 라이브러리에 연결</target>
        </trans-unit>
        <trans-unit id="0f9e059087370a1f7ba9840dcffd7d8f1c5943ff" translate="yes" xml:space="preserve">
          <source>List of Deprecated APIs</source>
          <target state="translated">더 이상 사용되지 않는 API 목록</target>
        </trans-unit>
        <trans-unit id="9a9e45f29e1adc44c7d9102ea05ee98d0a9c3be7" translate="yes" xml:space="preserve">
          <source>List of deprecated APIs</source>
          <target state="translated">더 이상 사용되지 않는 API 목록</target>
        </trans-unit>
        <trans-unit id="65a564ffbe1b350df30a9ce29bace70db2229aaf" translate="yes" xml:space="preserve">
          <source>Listen for new peer-initiated sessions. Returns a &lt;code&gt;Promise&lt;/code&gt; that is resolved once the &lt;code&gt;QuicSocket&lt;/code&gt; is actively listening.</source>
          <target state="translated">새로운 피어 시작 세션을 수신합니다. &lt;code&gt;QuicSocket&lt;/code&gt; 이 적극적으로 청취 하면 해결 되는 &lt;code&gt;Promise&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1103e732d98418ac8b2c82f0196dadba02f7f6d0" translate="yes" xml:space="preserve">
          <source>Listener functions &lt;strong&gt;must&lt;/strong&gt; only perform &lt;strong&gt;synchronous&lt;/strong&gt; operations. The Node.js process will exit immediately after calling the &lt;code&gt;'exit'&lt;/code&gt; event listeners causing any additional work still queued in the event loop to be abandoned. In the following example, for instance, the timeout will never occur:</source>
          <target state="translated">리스너 함수 &lt;strong&gt;는 &lt;/strong&gt;&lt;strong&gt;동기&lt;/strong&gt; 조작 만 수행 &lt;strong&gt;해야합니다&lt;/strong&gt; . &lt;code&gt;'exit'&lt;/code&gt; 이벤트 리스너를 호출 한 직후 Node.js 프로세스가 종료 되어 이벤트 루프에 대기중인 추가 작업이 중단됩니다. 예를 들어 다음 예에서 시간 초과는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="966d499de3b135ab9ccb8f03b02a34e060751ecf" translate="yes" xml:space="preserve">
          <source>Listeners on this event receive a clone of the &lt;code&gt;value&lt;/code&gt; parameter as passed to &lt;code&gt;postMessage()&lt;/code&gt; and no further arguments.</source>
          <target state="translated">이 이벤트의 리스너는 &lt;code&gt;postMessage()&lt;/code&gt; 전달 된 &lt;code&gt;value&lt;/code&gt; 매개 변수 의 복제본을 수신하며 추가 인수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="77125edc2a436f1f45f34348108362e176b01cda" translate="yes" xml:space="preserve">
          <source>Listeners on this event will receive a clone of the &lt;code&gt;value&lt;/code&gt; parameter as passed to &lt;code&gt;postMessage()&lt;/code&gt; and no further arguments.</source>
          <target state="translated">이 이벤트의 리스너는 &lt;code&gt;postMessage()&lt;/code&gt; 전달 된 &lt;code&gt;value&lt;/code&gt; 매개 변수 의 복제본을 수신하며 추가 인수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f36161242db928bc51c18ea3bb01737e480dcba0" translate="yes" xml:space="preserve">
          <source>Listeners registered for the &lt;code&gt;'newListener'&lt;/code&gt; event are passed the event name and a reference to the listener being added.</source>
          <target state="translated">&lt;code&gt;'newListener'&lt;/code&gt; 이벤트에 등록 된 리스너 에는 이벤트 이름과 추가되는 리스너에 대한 참조가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c64b06f1e2a3005863a818b791661622631104ad" translate="yes" xml:space="preserve">
          <source>Listeners registered for the &lt;code&gt;'newListener'&lt;/code&gt; event will be passed the event name and a reference to the listener being added.</source>
          <target state="translated">&lt;code&gt;'newListener'&lt;/code&gt; 이벤트에 등록 된 리스너 는 이벤트 이름과 추가되는 리스너에 대한 참조를 전달받습니다.</target>
        </trans-unit>
        <trans-unit id="263ff6da0a60052822f43bf968da5510ee95e89b" translate="yes" xml:space="preserve">
          <source>Listening for this event will have an effect only on connections established after the addition of the event listener.</source>
          <target state="translated">이 이벤트를 수신하면 이벤트 리스너를 추가 한 후 설정된 연결에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0e55c3e5d75f22479bbed5d621f6f8ed741f295b" translate="yes" xml:space="preserve">
          <source>Listening on a file descriptor is not supported on Windows.</source>
          <target state="translated">Windows에서는 파일 디스크립터 청취가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6645374b89720ebff452642f3db30a36b512c936" translate="yes" xml:space="preserve">
          <source>Live binding updates or new exports added to &lt;code&gt;module.exports&lt;/code&gt; are not detected for these named exports.</source>
          <target state="translated">이러한 명명 된 내보내기에 대해 &lt;code&gt;module.exports&lt;/code&gt; 에 추가 된 라이브 바인딩 업데이트 또는 새 내보내기 가 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a934789fef476b366bfd30093d89439e844ad1e" translate="yes" xml:space="preserve">
          <source>Load &lt;em&gt;resolved&lt;/em&gt; as module format, &lt;em&gt;format&lt;/em&gt;.</source>
          <target state="translated">로드 &lt;em&gt;해결&lt;/em&gt; 모듈 형식으로 &lt;em&gt;포맷&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="efea073c6c15864c713d76af7447f0d00ffffa38" translate="yes" xml:space="preserve">
          <source>Load &lt;em&gt;resolvedURL&lt;/em&gt; as module format, &lt;em&gt;format&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;resolvedURL&lt;/em&gt; 을 모듈 형식 (format) &lt;em&gt;으로&lt;/em&gt; 로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b98d38dd9ba6d75f2dcf66b3094803bd93b8a69" translate="yes" xml:space="preserve">
          <source>Load a JSON file</source>
          <target state="translated">JSON 파일로드</target>
        </trans-unit>
        <trans-unit id="358aca8bed2102b20d329cb6c2d609fd3c90cb03" translate="yes" xml:space="preserve">
          <source>Load a Node.js CommonJS module</source>
          <target state="translated">Node.js CommonJS 모듈로드</target>
        </trans-unit>
        <trans-unit id="00177c623e9ac0d49cba30da3c54b3c977b49a06" translate="yes" xml:space="preserve">
          <source>Load a Node.js builtin module</source>
          <target state="translated">Node.js 내장 모듈로드</target>
        </trans-unit>
        <trans-unit id="b1eef931eb753eece9d6e34ced7f072cb22fcdba" translate="yes" xml:space="preserve">
          <source>Load a WebAssembly module</source>
          <target state="translated">웹 어셈블리 모듈로드</target>
        </trans-unit>
        <trans-unit id="7519ad71b3a2bfc0f580ea1764b54f66e24c2e6f" translate="yes" xml:space="preserve">
          <source>Load a standard JavaScript module</source>
          <target state="translated">표준 JavaScript 모듈로드</target>
        </trans-unit>
        <trans-unit id="88ea30e11dcebd6e84150ac5820c69a9d4afdc5f" translate="yes" xml:space="preserve">
          <source>Load an ES module</source>
          <target state="translated">ES 모듈로드</target>
        </trans-unit>
        <trans-unit id="498893670658c01dd4ac6da4786a9dc9aa6df8e5" translate="yes" xml:space="preserve">
          <source>Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with &lt;code&gt;./configure --openssl-fips&lt;/code&gt;.</source>
          <target state="translated">시작시 OpenSSL 구성 파일을로드하십시오. 다른 용도 중 Node.js가 &lt;code&gt;./configure --openssl-fips&lt;/code&gt; 로 빌드 된 경우 FIPS 호환 암호화를 활성화하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee62206d8350faeb416823dca497bcc9021efda7" translate="yes" xml:space="preserve">
          <source>Load and set the &lt;code&gt;engine&lt;/code&gt; for some or all OpenSSL functions (selected by flags).</source>
          <target state="translated">일부 또는 모든 OpenSSL 기능 (플래그로 선택)에 대한 &lt;code&gt;engine&lt;/code&gt; 을 로드하고 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f514b04ed6b877534da140af8e12cab5016f713" translate="yes" xml:space="preserve">
          <source>Loaders</source>
          <target state="translated">Loaders</target>
        </trans-unit>
        <trans-unit id="864c89092077bd29bba0c7d8aa4a1ee0ee9ad0eb" translate="yes" xml:space="preserve">
          <source>Loading Addons using require()</source>
          <target state="translated">require ()를 사용하여 애드온로드</target>
        </trans-unit>
        <trans-unit id="fb686f61ca8f80c8a2b1ea9c221dedc2bee6db94" translate="yes" xml:space="preserve">
          <source>Loading ECMAScript modules no longer requires a command-line flag.</source>
          <target state="translated">ECMAScript 모듈을로드하는 데 더 이상 명령 줄 플래그가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="461404ed97327c8f261adb66fd0741495a2c8cbb" translate="yes" xml:space="preserve">
          <source>Loading addons using &lt;code&gt;require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 사용하여 애드온로드</target>
        </trans-unit>
        <trans-unit id="f7543238941e199c9c4cd5eb05bb0366a0f0e3cf" translate="yes" xml:space="preserve">
          <source>Loading from &lt;code&gt;node_modules&lt;/code&gt; Folders</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 폴더 에서로드</target>
        </trans-unit>
        <trans-unit id="b6335ac2b9f90ba310aefcc05b66c7ffb033560f" translate="yes" xml:space="preserve">
          <source>Loading from &lt;code&gt;node_modules&lt;/code&gt; folders</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 폴더 에서로드</target>
        </trans-unit>
        <trans-unit id="679458d12984235f54fda878bb725b25ccc3fbe0" translate="yes" xml:space="preserve">
          <source>Loading from the global folders</source>
          <target state="translated">글로벌 폴더에서로드</target>
        </trans-unit>
        <trans-unit id="9cf208e413ac7eafa3a57a4178219033a764fad4" translate="yes" xml:space="preserve">
          <source>Local JSON files can be loaded relative to &lt;code&gt;import.meta.url&lt;/code&gt; with &lt;code&gt;fs&lt;/code&gt; directly:</source>
          <target state="translated">로컬 JSON 파일은 &lt;code&gt;fs&lt;/code&gt; 를 사용하여 &lt;code&gt;import.meta.url&lt;/code&gt; 을 기준으로 직접 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aab431df60aff2443055adf445c69510d18e5e54" translate="yes" xml:space="preserve">
          <source>Locale-sensitive methods like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare&quot;&gt;&lt;code&gt;String.prototype.localeCompare()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString&quot;&gt;&lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare&quot;&gt; &lt;code&gt;String.prototype.localeCompare()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString&quot;&gt; &lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt; &lt;/a&gt; 과 같은 로케일 구분 메소드</target>
        </trans-unit>
        <trans-unit id="c2ef9686a9d07af86ddb6785cca13fffd98fde0f" translate="yes" xml:space="preserve">
          <source>Locale-sensitive or Unicode-aware functions in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양의&lt;/a&gt; 로케일 구분 또는 유니 코드 인식 기능 :</target>
        </trans-unit>
        <trans-unit id="53836d61b88bc9ebe5ff04c57ab3d5e85b3ccd6f" translate="yes" xml:space="preserve">
          <source>Location at which the report will be generated.</source>
          <target state="translated">보고서가 생성 될 위치입니다.</target>
        </trans-unit>
        <trans-unit id="80bbc7111675131489bcf1c8826abc71ac116a58" translate="yes" xml:space="preserve">
          <source>Log TLS key material to a file. The key material is in NSS &lt;code&gt;SSLKEYLOGFILE&lt;/code&gt; format and can be used by software (such as Wireshark) to decrypt the TLS traffic.</source>
          <target state="translated">TLS 키 자료를 파일에 기록합니다. 키 자료는 NSS &lt;code&gt;SSLKEYLOGFILE&lt;/code&gt; 형식이며 소프트웨어 (예 : Wireshark)에서 TLS 트래픽을 해독하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e500d4d84a92a8c0603625b4b6fd77177fa0a2b3" translate="yes" xml:space="preserve">
          <source>MD5 and SHA-1 are no longer acceptable where collision resistance is required such as digital signatures.</source>
          <target state="translated">디지털 서명과 같은 충돌 저항이 필요한 경우 MD5 및 SHA-1을 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86d931caa3fae8fb2300ea8f1d2a55be58e1a3d8" translate="yes" xml:space="preserve">
          <source>MODULE_NOT_FOUND</source>
          <target state="translated">MODULE_NOT_FOUND</target>
        </trans-unit>
        <trans-unit id="e1ec46742fb947b44338032993756f78da0b54d2" translate="yes" xml:space="preserve">
          <source>Made &lt;code&gt;func&lt;/code&gt; parameter optional with custom &lt;code&gt;call_js_cb&lt;/code&gt;.</source>
          <target state="translated">제작 &lt;code&gt;func&lt;/code&gt; 정의와 매개 변수 옵션 &lt;code&gt;call_js_cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="879e0b7f75a498f58d0f97f9d4112def27a09524" translate="yes" xml:space="preserve">
          <source>Main entry point export</source>
          <target state="translated">주요 진입 점 내보내기</target>
        </trans-unit>
        <trans-unit id="fb480a8a8b26324095457c616935d3f1841b3f51" translate="yes" xml:space="preserve">
          <source>Maintains an internal counter specific to &lt;code&gt;label&lt;/code&gt; and outputs to &lt;code&gt;stdout&lt;/code&gt; the number of times &lt;code&gt;console.count()&lt;/code&gt; has been called with the given &lt;code&gt;label&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;label&lt;/code&gt; 로 &lt;code&gt;console.count()&lt;/code&gt; 가 호출 된 횟수 를 &lt;code&gt;stdout&lt;/code&gt; 하기 위해 &lt;code&gt;label&lt;/code&gt; 및 출력에 고유 한 내부 카운터를 유지 보수합니다 .</target>
        </trans-unit>
        <trans-unit id="d6c137a08d00a5877b58efdf0c01b0c1fa6533bc" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;startMark&lt;/code&gt; and &lt;code&gt;endMark&lt;/code&gt; parameters optional.</source>
          <target state="translated">&lt;code&gt;startMark&lt;/code&gt; 및 &lt;code&gt;endMark&lt;/code&gt; 매개 변수를 선택 사항으로 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="7a81028c010c15e7a86469745fd56a7b314afde0" translate="yes" xml:space="preserve">
          <source>Make a self-contained library use its own symbols in preference to symbols from previously loaded libraries.</source>
          <target state="translated">자체 포함 된 라이브러리가 이전에로드 된 라이브러리의 기호보다 고유 한 기호를 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4b7f740d6f3b43eb6e1369cd1861228eda3e73a9" translate="yes" xml:space="preserve">
          <source>Make built-in language features like &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;new Function&lt;/code&gt; that generate code from strings throw an exception instead. This does not affect the Node.js &lt;code&gt;vm&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 과 같은 기본 제공 언어 기능과 문자열에서 코드를 생성하는 &lt;code&gt;new Function&lt;/code&gt; 가 대신 예외를 발생시킵니다. 이것은 Node.js &lt;code&gt;vm&lt;/code&gt; 모듈에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="58e5fc2cf8facef6490eacd62f42219179c768b6" translate="yes" xml:space="preserve">
          <source>Makes a request to a secure web server.</source>
          <target state="translated">보안 웹 서버에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="77ef1a913ec8293839a75b3ea0986e203581e748" translate="yes" xml:space="preserve">
          <source>Making handle lifespan shorter than that of the native method</source>
          <target state="translated">기본 메소드보다 핸들 수명을 단축</target>
        </trans-unit>
        <trans-unit id="e7258012eabbd3b3ddb7a3bfafbe25922453be58" translate="yes" xml:space="preserve">
          <source>Mandatory file extensions</source>
          <target state="translated">필수 파일 확장자</target>
        </trans-unit>
        <trans-unit id="fbaafc40bfcdb2bb2c788f4fd6fa884d335b1c61" translate="yes" xml:space="preserve">
          <source>Mark an object as not transferable. If &lt;code&gt;object&lt;/code&gt; occurs in the transfer list of a &lt;a href=&quot;#worker_threads_port_postmessage_value_transferlist&quot;&gt;&lt;code&gt;port.postMessage()&lt;/code&gt;&lt;/a&gt; call, it is ignored.</source>
          <target state="translated">개체를 양도 할 수 없음으로 표시합니다. &lt;a href=&quot;#worker_threads_port_postmessage_value_transferlist&quot;&gt; &lt;code&gt;port.postMessage()&lt;/code&gt; &lt;/a&gt; 호출 의 전송 목록에 &lt;code&gt;object&lt;/code&gt; 가 발생 하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0d8dfb09236d715683d3d08dc442c2f7469f51e4" translate="yes" xml:space="preserve">
          <source>Mark an object as not transferable. If &lt;code&gt;object&lt;/code&gt; occurs in the transfer list of a &lt;a href=&quot;#worker_threads_port_postmessage_value_transferlist&quot;&gt;&lt;code&gt;port.postMessage()&lt;/code&gt;&lt;/a&gt; call, it will be ignored.</source>
          <target state="translated">개체를 양도 불가능으로 표시합니다. &lt;a href=&quot;#worker_threads_port_postmessage_value_transferlist&quot;&gt; &lt;code&gt;port.postMessage()&lt;/code&gt; &lt;/a&gt; 호출 의 전송 목록에 &lt;code&gt;object&lt;/code&gt; 가 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7517849408f94693f21294c1f40a914dd912fa2" translate="yes" xml:space="preserve">
          <source>Marks an &lt;code&gt;ArrayBuffer&lt;/code&gt; as having its contents transferred out of band. Pass the corresponding &lt;code&gt;ArrayBuffer&lt;/code&gt; in the deserializing context to &lt;a href=&quot;#v8_deserializer_transferarraybuffer_id_arraybuffer&quot;&gt;&lt;code&gt;deserializer.transferArrayBuffer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayBuffer&lt;/code&gt; 의 내용이 대역 외로 전송 된 것으로 표시합니다 . 역 직렬화 컨텍스트 의 해당 &lt;code&gt;ArrayBuffer&lt;/code&gt; 를 &lt;a href=&quot;#v8_deserializer_transferarraybuffer_id_arraybuffer&quot;&gt; &lt;code&gt;deserializer.transferArrayBuffer()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e9d92daad3190f7c23fb73a149a2e3ed5745cfd" translate="yes" xml:space="preserve">
          <source>Marks an &lt;code&gt;ArrayBuffer&lt;/code&gt; as having its contents transferred out of band. Pass the corresponding &lt;code&gt;ArrayBuffer&lt;/code&gt; in the serializing context to &lt;a href=&quot;#v8_serializer_transferarraybuffer_id_arraybuffer&quot;&gt;&lt;code&gt;serializer.transferArrayBuffer()&lt;/code&gt;&lt;/a&gt; (or return the &lt;code&gt;id&lt;/code&gt; from &lt;a href=&quot;#v8_serializer_getsharedarraybufferid_sharedarraybuffer&quot;&gt;&lt;code&gt;serializer._getSharedArrayBufferId()&lt;/code&gt;&lt;/a&gt; in the case of &lt;code&gt;SharedArrayBuffer&lt;/code&gt;s).</source>
          <target state="translated">&lt;code&gt;ArrayBuffer&lt;/code&gt; 의 내용이 대역 외로 전송 된 것으로 표시합니다 . 직렬화 컨텍스트 의 해당 &lt;code&gt;ArrayBuffer&lt;/code&gt; 를 &lt;a href=&quot;#v8_serializer_transferarraybuffer_id_arraybuffer&quot;&gt; &lt;code&gt;serializer.transferArrayBuffer()&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 의 경우 &lt;a href=&quot;#v8_serializer_getsharedarraybufferid_sharedarraybuffer&quot;&gt; &lt;code&gt;serializer._getSharedArrayBufferId()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;id&lt;/code&gt; 를 리턴 함 ).</target>
        </trans-unit>
        <trans-unit id="1e2ad0793ef76124b1034c1cea3ed4e613e126d0" translate="yes" xml:space="preserve">
          <source>Marks the request as aborting. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed.</source>
          <target state="translated">요청을 중단 된 것으로 표시합니다. 이것을 호출하면 응답의 나머지 데이터가 삭제되고 소켓이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="0f845dbfd32891203afbc6c332195efbd6298479" translate="yes" xml:space="preserve">
          <source>Max header size in &lt;code&gt;http_parser&lt;/code&gt; was set to 8KB.</source>
          <target state="translated">&lt;code&gt;http_parser&lt;/code&gt; 의 최대 헤더 크기는 8KB로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="767a965b42cd76eccbb5ffdd8ab7b02f20159af6" translate="yes" xml:space="preserve">
          <source>Measure the memory known to V8 and used by all contexts known to the current V8 isolate, or the main context.</source>
          <target state="translated">V8에 알려진 메모리를 측정하고 현재 V8 분리 또는 기본 컨텍스트에 알려진 모든 컨텍스트에서 사용하는 메모리를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="f21ff80ab9cf701ac46a3167e21f3037801508fd" translate="yes" xml:space="preserve">
          <source>Measuring how long it takes to load dependencies</source>
          <target state="translated">종속성을로드하는 데 걸리는 시간 측정</target>
        </trans-unit>
        <trans-unit id="9128f1b632621e70aa390a4486c36bb163baf0c8" translate="yes" xml:space="preserve">
          <source>Measuring the duration of async operations</source>
          <target state="translated">비동기 작업 기간 측정</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="ef1eb41c5de244b704fcf15f3bc0f13c999a4f71" translate="yes" xml:space="preserve">
          <source>Memory Usage Tuning</source>
          <target state="translated">메모리 사용량 조정</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="bb3fa3d76a937e4a81d7780c47e49272ec406513" translate="yes" xml:space="preserve">
          <source>Memory usage tuning</source>
          <target state="translated">메모리 사용량 조정</target>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="0ce120a41bf22d68c9fab53d50c8a38d4440d65a" translate="yes" xml:space="preserve">
          <source>MessagePort</source>
          <target state="translated">MessagePort</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="532bb72b545e75db867501d58fef21423a35b550" translate="yes" xml:space="preserve">
          <source>Method(s) to implement</source>
          <target state="translated">구현할 방법</target>
        </trans-unit>
        <trans-unit id="be11d28d855c168de0db39411d017ffe8e5d8b28" translate="yes" xml:space="preserve">
          <source>Methods that return TLS connection metadata (e.g. &lt;a href=&quot;#tls_tlssocket_getpeercertificate_detailed&quot;&gt;&lt;code&gt;tls.TLSSocket.getPeerCertificate()&lt;/code&gt;&lt;/a&gt; will only return data while the connection is open.</source>
          <target state="translated">TLS 연결 메타 데이터 (예 : &lt;a href=&quot;#tls_tlssocket_getpeercertificate_detailed&quot;&gt; &lt;code&gt;tls.TLSSocket.getPeerCertificate()&lt;/code&gt; &lt;/a&gt; 를 반환하는 메서드 는 연결이 열려있는 동안에 만 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e17fb7615f69e41f040e33f83d9d9ed54f866a6a" translate="yes" xml:space="preserve">
          <source>Migrates the &lt;code&gt;QuicClientSession&lt;/code&gt; to the given &lt;code&gt;QuicSocket&lt;/code&gt; instance. If the new &lt;code&gt;QuicSocket&lt;/code&gt; has not yet been bound to a local UDP port, it will be bound prior to attempting the migration.</source>
          <target state="translated">&lt;code&gt;QuicClientSession&lt;/code&gt; 을 주어진 &lt;code&gt;QuicSocket&lt;/code&gt; 인스턴스 로 마이그레이션합니다 . 새 &lt;code&gt;QuicSocket&lt;/code&gt; 이 아직 로컬 UDP 포트에 바인딩되지 않은 경우 마이그레이션을 시도하기 전에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ba3efaca5f13d398812424482d57e438a3b44995" translate="yes" xml:space="preserve">
          <source>Modern Web browsers follow the &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG Encoding Standard&lt;/a&gt; which aliases both &lt;code&gt;'latin1'&lt;/code&gt; and &lt;code&gt;'ISO-8859-1'&lt;/code&gt; to &lt;code&gt;'win-1252'&lt;/code&gt;. This means that while doing something like &lt;code&gt;http.get()&lt;/code&gt;, if the returned charset is one of those listed in the WHATWG specification it is possible that the server actually returned &lt;code&gt;'win-1252'&lt;/code&gt;-encoded data, and using &lt;code&gt;'latin1'&lt;/code&gt; encoding may incorrectly decode the characters.</source>
          <target state="translated">최신 웹 브라우저 는 &lt;code&gt;'latin1'&lt;/code&gt; 및 &lt;code&gt;'ISO-8859-1'&lt;/code&gt; 을 &lt;code&gt;'win-1252'&lt;/code&gt; 로 별칭 지정 하는 &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG 인코딩 표준&lt;/a&gt; 을 따릅니다 . 이는 &lt;code&gt;http.get()&lt;/code&gt; 과 같은 작업을 수행하는 동안 반환 된 문자 집합 이 WHATWG 사양에 나열된 문자 집합 중 하나 인 경우 서버가 실제로 &lt;code&gt;'win-1252'&lt;/code&gt; 인코딩 데이터를 반환 하고 &lt;code&gt;'latin1'&lt;/code&gt; 인코딩을 사용할 수 있음을 의미합니다 문자를 잘못 해독하십시오.</target>
        </trans-unit>
        <trans-unit id="65a15f6dfa2e4554da23919059f34e286d29b89d" translate="yes" xml:space="preserve">
          <source>Modifier support varies throughout different terminals. They will mostly be ignored, if not supported.</source>
          <target state="translated">수정 자 지원은 터미널마다 다릅니다. 지원되지 않는 경우 대부분 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="5e5ee885e59c3666b818d0a51c7fee388b17e46d" translate="yes" xml:space="preserve">
          <source>Modifies the permissions on the file. The &lt;code&gt;Promise&lt;/code&gt; is resolved with no arguments upon success.</source>
          <target state="translated">파일에 대한 권한을 수정합니다. &lt;code&gt;Promise&lt;/code&gt; 성공에 따라 인수없이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="e955b90e741d4c82b9b85c4cc9aa35c010f53aa4" translate="yes" xml:space="preserve">
          <source>Modifying a file rather than replacing it may require a flags mode of &lt;code&gt;'r+'&lt;/code&gt; rather than the default mode &lt;code&gt;'w'&lt;/code&gt;.</source>
          <target state="translated">파일을 바꾸지 않고 수정 하려면 기본 모드 &lt;code&gt;'w'&lt;/code&gt; 대신 &lt;code&gt;'r+'&lt;/code&gt; 플래그 모드가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59e3b2e3807f64b859509b97033f8b164102e074" translate="yes" xml:space="preserve">
          <source>Modifying a file rather than replacing it may require the &lt;code&gt;flag&lt;/code&gt; option to be set to &lt;code&gt;'r+'&lt;/code&gt; rather than the default &lt;code&gt;'w'&lt;/code&gt;.</source>
          <target state="translated">파일을 바꾸지 않고 수정 하려면 기본 &lt;code&gt;'w'&lt;/code&gt; 대신 &lt;code&gt;'r+'&lt;/code&gt; 로 &lt;code&gt;flag&lt;/code&gt; 옵션을 설정해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5cd669deb64182bb1486f9edc35fe42bd6d7f56" translate="yes" xml:space="preserve">
          <source>Modifying the Default TLS Cipher suite</source>
          <target state="translated">기본 TLS 암호 제품군 수정</target>
        </trans-unit>
        <trans-unit id="f731a0f634fbf6df66f86fafb91a04dc2f63b03b" translate="yes" xml:space="preserve">
          <source>Modifying the default TLS cipher suite</source>
          <target state="translated">기본 TLS 암호 그룹 수정</target>
        </trans-unit>
        <trans-unit id="386917eb344492726f971a2580c72bd0600c3297" translate="yes" xml:space="preserve">
          <source>Modifying the new &lt;code&gt;Buffer&lt;/code&gt; slice will modify the memory in the original &lt;code&gt;Buffer&lt;/code&gt; because the allocated memory of the two objects overlap.</source>
          <target state="translated">새 &lt;code&gt;Buffer&lt;/code&gt; 슬라이스를 수정 하면 두 객체의 할당 된 메모리가 겹치므로 원래 &lt;code&gt;Buffer&lt;/code&gt; 의 메모리가 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7606a01db550a47662b629f247d6367bcf7282" translate="yes" xml:space="preserve">
          <source>Module Caching Caveats</source>
          <target state="translated">모듈 캐싱주의 사항</target>
        </trans-unit>
        <trans-unit id="3d1eed928b27314ba7b9856337b096b1aba2610f" translate="yes" xml:space="preserve">
          <source>Module caching caveats</source>
          <target state="translated">모듈 캐싱주의 사항</target>
        </trans-unit>
        <trans-unit id="83624ccd7b5527bbf857a1fbcf3723edba0da40a" translate="yes" xml:space="preserve">
          <source>Module registration</source>
          <target state="translated">모듈 등록</target>
        </trans-unit>
        <trans-unit id="7575e8c6375f9ecce4bf5b77b70a45f98b8cd781" translate="yes" xml:space="preserve">
          <source>Module.createRequireFromPath() is deprecated. Please use &lt;a href=&quot;module#module_module_createrequire_filename&quot;&gt;&lt;code&gt;module.createRequire()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Module.createRequireFromPath ()는 더 이상 사용되지 않습니다. 사용하십시오 &lt;a href=&quot;module#module_module_createrequire_filename&quot;&gt; &lt;code&gt;module.createRequire()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="7939217a1ff65e34d944c1af418682a3959683e6" translate="yes" xml:space="preserve">
          <source>Module.createRequireFromPath() is deprecated. Please use &lt;a href=&quot;modules#modules_module_createrequire_filename&quot;&gt;&lt;code&gt;module.createRequire()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Module.createRequireFromPath ()는 더 이상 사용되지 않습니다. 사용하십시오 &lt;a href=&quot;modules#modules_module_createrequire_filename&quot;&gt; &lt;code&gt;module.createRequire()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="85946d17e9abcad5d8c5d7ff7e55541e63757d01" translate="yes" xml:space="preserve">
          <source>Modules are cached after the first time they are loaded. This means (among other things) that every call to &lt;code&gt;require('foo')&lt;/code&gt; will get exactly the same object returned, if it would resolve to the same file.</source>
          <target state="translated">모듈은 처음로드 된 후 캐시됩니다. 이것은 &lt;code&gt;require('foo')&lt;/code&gt; 에 대한 모든 호출 이 동일한 파일로 해석되면 정확히 동일한 객체를 반환한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9328fdb06dec7493c1ac0a3bc42b0f79daf79a03" translate="yes" xml:space="preserve">
          <source>Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from &lt;code&gt;node_modules&lt;/code&gt; folders), it is not a &lt;em&gt;guarantee&lt;/em&gt; that &lt;code&gt;require('foo')&lt;/code&gt; will always return the exact same object, if it would resolve to different files.</source>
          <target state="translated">모듈은 해결 된 파일 이름을 기반으로 캐시됩니다. 모듈이 호출 모듈의 위치 ( &lt;code&gt;node_modules&lt;/code&gt; 폴더 에서로드)의 위치에 따라 다른 파일 이름으로 해석 될 수 있기 때문에 &lt;code&gt;require('foo')&lt;/code&gt; 가 다른 파일로 해석 될 경우 항상 동일한 객체를 반환 한다는 &lt;em&gt;보장&lt;/em&gt; 은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="28e1343a6af7d08fdfab4981e72800f3eb87862a" translate="yes" xml:space="preserve">
          <source>Modules are cached in this object when they are required. By deleting a key value from this object, the next &lt;code&gt;require&lt;/code&gt; will reload the module. This does not apply to &lt;a href=&quot;addons&quot;&gt;native addons&lt;/a&gt;, for which reloading will result in an error.</source>
          <target state="translated">필요할 때이 개체에 모듈이 캐시됩니다. 이 객체에서 키 값을 삭제하면 다음 &lt;code&gt;require&lt;/code&gt; 따라 모듈이 다시로드됩니다. 다시로드하면 오류가 발생하는 &lt;a href=&quot;addons&quot;&gt;기본 애드온&lt;/a&gt; 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="edcb0ef2ab0accce5f6e12688eb452c06c2902b5" translate="yes" xml:space="preserve">
          <source>Modules are loaded multiple times if the &lt;code&gt;import&lt;/code&gt; specifier used to resolve them has a different query or fragment.</source>
          <target state="translated">모듈 을 해결하는 데 사용 된 &lt;code&gt;import&lt;/code&gt; 지정자가 다른 쿼리 또는 조각을 가진 경우 모듈이 여러 번로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="00d05571b964dddda3ae3561348588cfd26ddbfa" translate="yes" xml:space="preserve">
          <source>Modules that have an invalid &lt;code&gt;main&lt;/code&gt; entry (e.g., &lt;code&gt;./does-not-exist.js&lt;/code&gt;) and also have an &lt;code&gt;index.js&lt;/code&gt; file in the top level directory will resolve the &lt;code&gt;index.js&lt;/code&gt; file. That is deprecated and is going to throw an error in future Node.js versions.</source>
          <target state="translated">잘못이 모듈 &lt;code&gt;main&lt;/code&gt; 항목을 (예, &lt;code&gt;./does-not-exist.js&lt;/code&gt; ) 또한는이 &lt;code&gt;index.js&lt;/code&gt; 결심 할 최상위 디렉토리에있는 파일을 &lt;code&gt;index.js&lt;/code&gt; 파일을. 더 이상 사용되지 않으며 향후 Node.js 버전에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f8cb9d5d814826c94ca425c65a80591a56c453c" translate="yes" xml:space="preserve">
          <source>Modules will be loaded multiple times if the &lt;code&gt;import&lt;/code&gt; specifier used to resolve them have a different query or fragment.</source>
          <target state="translated">모듈 을 해결하는 데 사용되는 &lt;code&gt;import&lt;/code&gt; 지정자가 다른 쿼리 또는 조각을 갖는 경우 모듈이 여러 번로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="5d23e88306931082f27761862d8b5520ea16bd97" translate="yes" xml:space="preserve">
          <source>Modules: &lt;code&gt;module&lt;/code&gt; API</source>
          <target state="translated">모듈 : &lt;code&gt;module&lt;/code&gt; API</target>
        </trans-unit>
        <trans-unit id="65b4968c8aff51a834a13c32e250f01641e1418e" translate="yes" xml:space="preserve">
          <source>Modules: CommonJS modules</source>
          <target state="translated">모듈 : CommonJS 모듈</target>
        </trans-unit>
        <trans-unit id="8a0535905b5a082c8292472c944f2e1e2d049e25" translate="yes" xml:space="preserve">
          <source>Modules: ECMAScript modules</source>
          <target state="translated">모듈 : ECMAScript 모듈</target>
        </trans-unit>
        <trans-unit id="2b15f98211b2d493bfab305d048b6c3b3ba030fd" translate="yes" xml:space="preserve">
          <source>Modules: Packages</source>
          <target state="translated">모듈 : 패키지</target>
        </trans-unit>
        <trans-unit id="90fbb2012f6d47e34578586d91fdc3981db8daf4" translate="yes" xml:space="preserve">
          <source>More accurate &lt;a href=&quot;repl#repl_repl&quot;&gt;REPL&lt;/a&gt; line editing</source>
          <target state="translated">보다 정확한 &lt;a href=&quot;repl#repl_repl&quot;&gt;REPL&lt;/a&gt; 라인 편집</target>
        </trans-unit>
        <trans-unit id="0ecdbeb6845d999cf7003e1812bec6e641a5510d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;fs&lt;/code&gt; operations accept filepaths that may be specified in the form of a string, a &lt;a href=&quot;buffer#buffer_buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; object using the &lt;code&gt;file:&lt;/code&gt; protocol.</source>
          <target state="translated">대부분의 &lt;code&gt;fs&lt;/code&gt; 작업은 문자열 : &lt;a href=&quot;buffer#buffer_buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;file:&lt;/code&gt; 프로토콜을 사용하여 &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 객체 형식으로 지정할 수있는 파일 경로를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="82cff11b4bb5481a6d7ac80aec40ddd830fc32bf" translate="yes" xml:space="preserve">
          <source>Most applications should consider using the new &lt;code&gt;KeyObject&lt;/code&gt; API instead of passing keys as strings or &lt;code&gt;Buffer&lt;/code&gt;s due to improved security features.</source>
          <target state="translated">대부분의 응용 프로그램은 향상된 보안 기능으로 인해 키를 문자열 또는 &lt;code&gt;Buffer&lt;/code&gt; 로 전달하는 대신 새로운 &lt;code&gt;KeyObject&lt;/code&gt; API 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="20cb9dba8d1ec1bda32d3869a385011e92bc7b15" translate="yes" xml:space="preserve">
          <source>Most asynchronous methods exposed by the Node.js core API follow an idiomatic pattern referred to as an &lt;em&gt;error-first callback&lt;/em&gt;. With this pattern, a callback function is passed to the method as an argument. When the operation either completes or an error is raised, the callback function is called with the &lt;code&gt;Error&lt;/code&gt; object (if any) passed as the first argument. If no error was raised, the first argument will be passed as &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Node.js 핵심 API에 의해 노출되는 대부분의 비동기 메소드는 &lt;em&gt;오류 우선 콜백&lt;/em&gt; 이라는 관용적 패턴을 따릅니다 . 이 패턴을 사용하면 콜백 함수가 인수로 메소드에 전달됩니다. 작업이 완료되거나 오류가 발생 하면 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 객체 (있는 경우) 와 함께 콜백 함수가 호출됩니다 . 오류가 발생하지 않으면 첫 번째 인수가 &lt;code&gt;null&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbf34ac485339ebd83193dd184575f98649766ac" translate="yes" xml:space="preserve">
          <source>Most asynchronous methods that accept a &lt;code&gt;callback&lt;/code&gt; function will accept an &lt;code&gt;Error&lt;/code&gt; object passed as the first argument to that function. If that first argument is not &lt;code&gt;null&lt;/code&gt; and is an instance of &lt;code&gt;Error&lt;/code&gt;, then an error occurred that should be handled.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 함수 를 허용하는 대부분의 비동기 메소드는 해당 함수 의 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 객체 를 허용 합니다. 첫 번째 인수가 &lt;code&gt;null&lt;/code&gt; 이 아니고 &lt;code&gt;Error&lt;/code&gt; 인스턴스 인 경우 처리해야하는 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2b8ceb2fddd337b5e111a9cd6250634bdec17c99" translate="yes" xml:space="preserve">
          <source>Most operating systems limit the number of file descriptors that may be open at any given time so it is critical to close the descriptor when operations are completed. Failure to do so will result in a memory leak that will eventually cause an application to crash.</source>
          <target state="translated">대부분의 운영 체제는 주어진 시간에 열려있을 수있는 파일 설명자 수를 제한하므로 작업이 완료되면 설명자를 닫는 것이 중요합니다. 그렇지 않으면 메모리 누수가 발생하여 응용 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="765bf483729f04bce1c6200d45ac7f5ae7b59417" translate="yes" xml:space="preserve">
          <source>Moves running process into background. Type &lt;code&gt;fg&lt;/code&gt; and press</source>
          <target state="translated">실행중인 프로세스를 백그라운드로 이동합니다. &lt;code&gt;fg&lt;/code&gt; 를 입력 하고 누르십시오.</target>
        </trans-unit>
        <trans-unit id="9dc05d950cd4618e0efb087a5472232826d34e84" translate="yes" xml:space="preserve">
          <source>Moves running process into background. Type &lt;code&gt;fg&lt;/code&gt; and press &lt;code&gt;enter&lt;/code&gt; to return.</source>
          <target state="translated">실행중인 프로세스를 백그라운드로 이동합니다. 유형 &lt;code&gt;fg&lt;/code&gt; 하고 Enter 키를 &lt;code&gt;enter&lt;/code&gt; 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="18cebb6899365ed285fb7b9339be5b27f9d9ab5f" translate="yes" xml:space="preserve">
          <source>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called &quot;emitters&quot;) emit named events that cause &lt;code&gt;Function&lt;/code&gt; objects (&quot;listeners&quot;) to be called.</source>
          <target state="translated">대부분의 Node.js 핵심 API는 특정 종류의 객체 ( &quot;이미 터&quot;)가 &lt;code&gt;Function&lt;/code&gt; 객체 ( &quot;리스너&quot;)를 호출 하는 명명 된 이벤트를 생성하는 관용적 인 비동기 이벤트 중심 아키텍처를 기반으로 구축되었습니다 .</target>
        </trans-unit>
        <trans-unit id="51b9e9e4f853d5c9f436fb23cb6c1226b9b3c6d3" translate="yes" xml:space="preserve">
          <source>Multiple alternatives may be specified, for instance: &lt;code&gt;'h2=&quot;example.org:81&quot;, h2=&quot;:82&quot;'&lt;/code&gt;.</source>
          <target state="translated">여러 대안을 지정할 수 있습니다 (예 : &lt;code&gt;'h2=&quot;example.org:81&quot;, h2=&quot;:82&quot;'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5479027d01ceffdeaae68128ea7b4adf28374c" translate="yes" xml:space="preserve">
          <source>Multiple comma-separated &lt;code&gt;section&lt;/code&gt; names may be specified in the &lt;code&gt;NODE_DEBUG&lt;/code&gt; environment variable: &lt;code&gt;NODE_DEBUG=fs,net,tls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NODE_DEBUG&lt;/code&gt; 환경 변수 &lt;code&gt;NODE_DEBUG=fs,net,tls&lt;/code&gt; 에 쉼표로 구분 된 여러 &lt;code&gt;section&lt;/code&gt; 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27f2ab40edb60bf40787bb6edf23d36b9c543077" translate="yes" xml:space="preserve">
          <source>Multiple concatenated gzip file members are supported now.</source>
          <target state="translated">여러 개의 연결된 gzip 파일 멤버가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f4215a6b0ba9f7218f437607dda8f17b06a6cd29" translate="yes" xml:space="preserve">
          <source>Multiple empty entries are now parsed correctly (e.g. &lt;code&gt;&amp;amp;=&amp;amp;=&lt;/code&gt;).</source>
          <target state="translated">여러 개의 빈 항목이 이제 올바르게 구문 분석됩니다 (예 : &lt;code&gt;&amp;amp;=&amp;amp;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c11e7417524b09c3c63dbb1d8edf3a8d679325c8" translate="yes" xml:space="preserve">
          <source>Multiple values were provided for an HTTP/2 header field that was required to have only a single value.</source>
          <target state="translated">단일 값만 필요한 HTTP / 2 헤더 필드에 여러 값이 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="0cfd7073a743f5ff4fda510240475719d7850d63" translate="yes" xml:space="preserve">
          <source>N-API</source>
          <target state="translated">N-API</target>
        </trans-unit>
        <trans-unit id="90cbc0e18027d4869385351bdb9ade6021ccdf03" translate="yes" xml:space="preserve">
          <source>N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (for example, V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one major version to run on later major versions of Node.js without recompilation. The &lt;a href=&quot;https://nodejs.org/en/docs/guides/abi-stability/&quot;&gt;ABI Stability&lt;/a&gt; guide provides a more in-depth explanation.</source>
          <target state="translated">N-API (문자로 N으로 발음되고 API가 뒤 따름)는 기본 애드온을 빌드하기위한 API입니다. 기본 JavaScript 런타임 (예 : V8)과 독립적이며 Node.js 자체의 일부로 유지 보수됩니다. 이 API는 Node.js 버전에서 안정적인 ABI (Application Binary Interface)입니다. 기본 JavaScript 엔진의 변경 사항으로부터 애드온을 격리하고 하나의 주요 버전 용으로 컴파일 된 모듈을 재 컴파일없이 이후의 주요 버전의 Node.js에서 실행할 수 있습니다. &lt;a href=&quot;https://nodejs.org/en/docs/guides/abi-stability/&quot;&gt;ABI 안정성&lt;/a&gt; 가이드는보다 심층적 인 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="334e1de2311ffce54fb9769c28586c411d51f5fe" translate="yes" xml:space="preserve">
          <source>N-API Callback types</source>
          <target state="translated">N-API 콜백 유형</target>
        </trans-unit>
        <trans-unit id="5ada9d09ff541a5d3e10d36683dca70ab044cf65" translate="yes" xml:space="preserve">
          <source>N-API Memory Management types</source>
          <target state="translated">N-API 메모리 관리 유형</target>
        </trans-unit>
        <trans-unit id="1f918c2169b9c207f636baeefc2f5e1825de6091" translate="yes" xml:space="preserve">
          <source>N-API Version Matrix</source>
          <target state="translated">N-API 버전 매트릭스</target>
        </trans-unit>
        <trans-unit id="f8f29003d244cabc299bb893542ca04b223101d1" translate="yes" xml:space="preserve">
          <source>N-API callback types</source>
          <target state="translated">N-API 콜백 유형</target>
        </trans-unit>
        <trans-unit id="d363f5ed275336e6c49002be4a2ef6344b73275b" translate="yes" xml:space="preserve">
          <source>N-API defines the &lt;code&gt;napi_async_work&lt;/code&gt; structure which is used to manage asynchronous workers. Instances are created/deleted with &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt;&lt;code&gt;napi_create_async_work&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt;&lt;code&gt;napi_delete_async_work&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">N-API는 비동기 작업자를 관리하는 데 사용되는 &lt;code&gt;napi_async_work&lt;/code&gt; 구조를 정의합니다 . 인스턴스는 &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt; &lt;code&gt;napi_create_async_work&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt; &lt;code&gt;napi_delete_async_work&lt;/code&gt; &lt;/a&gt; 로 생성 / 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cd2329041a56e471a3596295b8fded33cd92bcd" translate="yes" xml:space="preserve">
          <source>N-API defines the &lt;code&gt;napi_work&lt;/code&gt; structure which is used to manage asynchronous workers. Instances are created/deleted with &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt;&lt;code&gt;napi_create_async_work&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt;&lt;code&gt;napi_delete_async_work&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">N-API는 비동기 작업자를 관리하는 데 사용되는 &lt;code&gt;napi_work&lt;/code&gt; 구조를 정의합니다 . &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt; &lt;code&gt;napi_create_async_work&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt; &lt;code&gt;napi_delete_async_work&lt;/code&gt; 로&lt;/a&gt; 인스턴스를 생성 / 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="88f54237d497e37e1e102b35a1c9c4125fb96d0f" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to create all types of JavaScript values. Some of these types are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values&quot;&gt;Section 6&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 모든 유형의 JavaScript 값을 만듭니다. 이러한 유형 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양&lt;/a&gt; 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values&quot;&gt;섹션 6&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5509989753e7e47a4ed4e95d74d5238fc745c6" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to get and set properties on JavaScript objects. Some of these types are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;Section 7&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 JavaScript 개체의 속성을 가져오고 설정하기 위해 API 집합을 노출합니다. 이러한 유형 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양&lt;/a&gt; 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;섹션 7&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7ee8aa91b06eb2761965bea9b3ca7d13159118" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to get and set properties on JavaScript objects. Some of these types are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-operations-on-objects&quot;&gt;Section 7&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 JavaScript 객체의 속성을 가져오고 설정합니다. 이러한 유형 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양&lt;/a&gt; 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-operations-on-objects&quot;&gt;섹션 7&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b7e76dd3e6c6d68488dbe2b8f2a01306cdd1b3" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to perform some abstract operations on JavaScript values. Some of these operations are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;Section 7&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 JavaScript 값에 대한 추상 작업을 수행합니다. 이러한 작업 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양 &lt;/a&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;섹션 7&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c61dcfa47476fc6fa41772f59614e57871819b0" translate="yes" xml:space="preserve">
          <source>N-API exposes the following fundamental datatypes as abstractions that are consumed by the various APIs. These APIs should be treated as opaque, introspectable only with other N-API calls.</source>
          <target state="translated">N-API는 다음과 같은 기본 데이터 유형을 다양한 API에서 사용하는 추상화로 표시합니다. 이러한 API는 다른 N-API 호출에서만 볼 수있는 불투명 한 것으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="561e1622d71e550f526caaa66deabdc9dfbdc3cb" translate="yes" xml:space="preserve">
          <source>N-API is an API for building native Addons. It is independent from the underlying JavaScript runtime (e.g. V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation. Addons are built/packaged with the same approach/tools outlined in this document (node-gyp, etc.). The only difference is the set of APIs that are used by the native code. Instead of using the V8 or &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Native Abstractions for Node.js&lt;/a&gt; APIs, the functions available in the N-API are used.</source>
          <target state="translated">N-API는 기본 애드온을 구축하기위한 API입니다. 기본 JavaScript 런타임 (예 : V8)과 독립적이며 Node.js 자체의 일부로 유지 관리됩니다. 이 API는 Node.js 버전에서 안정적인 ABI (Application Binary Interface)입니다. 기본 JavaScript 엔진의 변경 사항으로부터 애드온을 격리시키고 한 버전 용으로 컴파일 된 모듈이 재 컴파일없이 이후 버전의 Node.js에서 실행될 수 있도록합니다. 애드온은이 문서에 설명 된 것과 동일한 접근 방식 / 도구 (node-gyp 등)로 빌드 / 패키징됩니다. 유일한 차이점은 기본 코드에서 사용되는 API 세트입니다. &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Node.js&lt;/a&gt; API에 V8 또는 Native Abstractions를 사용하는 대신 N-API에서 사용 가능한 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89fbace17d4b56b76ef0aeff0489594e4cfa0aef" translate="yes" xml:space="preserve">
          <source>N-API is an API for building native addons. It is independent from the underlying JavaScript runtime (e.g. V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation. Addons are built/packaged with the same approach/tools outlined in this document (node-gyp, etc.). The only difference is the set of APIs that are used by the native code. Instead of using the V8 or &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Native Abstractions for Node.js&lt;/a&gt; APIs, the functions available in the N-API are used.</source>
          <target state="translated">N-API는 네이티브 애드온을 구축하기위한 API입니다. 기본 JavaScript 런타임 (예 : V8)과 독립적이며 Node.js 자체의 일부로 유지됩니다. 이 API는 Node.js 버전 전체에서 안정적인 ABI (Application Binary Interface)가 될 것입니다. 기본 JavaScript 엔진의 변경 사항으로부터 애드온을 격리하고 한 버전 용으로 컴파일 된 모듈이 재 컴파일없이 Node.js의 이후 버전에서 실행될 수 있도록합니다. 애드온은이 문서 (node-gyp 등)에 설명 된 것과 동일한 접근 방식 / 도구로 빌드 / 패키징됩니다. 유일한 차이점은 네이티브 코드에서 사용하는 API 집합입니다. &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Node.js&lt;/a&gt; API 용 V8 또는 네이티브 추상화를 사용하는 대신 N-API에서 사용할 수있는 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa01c7fdc1743fef1e453e6b6b825c139cad6a5d" translate="yes" xml:space="preserve">
          <source>N-API memory management types</source>
          <target state="translated">N-API 메모리 관리 유형</target>
        </trans-unit>
        <trans-unit id="0738955b59acf88770860528a15013618ab13c78" translate="yes" xml:space="preserve">
          <source>N-API modules are registered in a manner similar to other modules except that instead of using the &lt;code&gt;NODE_MODULE&lt;/code&gt; macro the following is used:</source>
          <target state="translated">N-API 모듈은 &lt;code&gt;NODE_MODULE&lt;/code&gt; 매크로 를 사용하는 대신 다음을 사용한다는 점을 제외하고 다른 모듈과 유사한 방식으로 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ce7ec8745b23919ab41738dc2e8d90813f2426a" translate="yes" xml:space="preserve">
          <source>N-API offers a way to &quot;wrap&quot; C++ classes and instances so that the class constructor and methods can be called from JavaScript.</source>
          <target state="translated">N-API는 C ++ 클래스와 인스턴스를 &quot;랩핑&quot;하여 클래스 생성자와 메소드를 JavaScript에서 호출 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45efbba7b6828bb6ff691538d9468098a20c4570" translate="yes" xml:space="preserve">
          <source>N-API only supports a single nested hierarchy of scopes. There is only one active scope at any time, and all new handles will be associated with that scope while it is active. Scopes must be closed in the reverse order from which they are opened. In addition, all scopes created within a native method must be closed before returning from that method.</source>
          <target state="translated">N-API는 단일 중첩 범위의 계층 구조 만 지원합니다. 언제든지 하나의 활성 범위 만 있으며 모든 새 핸들은 활성 상태 인 동안 해당 범위와 연관됩니다. 범위는 열었던 순서와 반대로 닫혀 야합니다. 또한 고유 메소드에서 작성된 모든 범위는 해당 메소드에서 리턴하기 전에 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="d7b60dab0bc992db521955215d2463d3ce27f102" translate="yes" xml:space="preserve">
          <source>N-API provides a function for getting the current event loop associated with a specific &lt;code&gt;napi_env&lt;/code&gt;.</source>
          <target state="translated">N-API는 특정 &lt;code&gt;napi_env&lt;/code&gt; 와 관련된 현재 이벤트 루프를 가져 오는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e6d292a608d795d02e9feb5215a93624719c5f3d" translate="yes" xml:space="preserve">
          <source>N-API provides a set of APIs that allow JavaScript code to call back into native code. N-API APIs that support calling back into native code take in a callback functions represented by the &lt;code&gt;napi_callback&lt;/code&gt; type. When the JavaScript VM calls back to native code, the &lt;code&gt;napi_callback&lt;/code&gt; function provided is invoked. The APIs documented in this section allow the callback function to do the following:</source>
          <target state="translated">N-API는 JavaScript 코드를 기본 코드로 다시 호출 할 수있는 API 세트를 제공합니다. 네이티브 코드로의 콜백을 지원하는 N-API API는 &lt;code&gt;napi_callback&lt;/code&gt; 유형으로 표시되는 콜백 함수를받습니다 . JavaScript VM이 원시 코드를 다시 호출하면 제공된 &lt;code&gt;napi_callback&lt;/code&gt; 함수가 호출됩니다. 이 섹션에 설명 된 API를 통해 콜백 함수는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01090223361802809df29f213e82e3b9319fcf72" translate="yes" xml:space="preserve">
          <source>N-API provides an ABI-stable interface for these supporting functions which covers the most common asynchronous use cases.</source>
          <target state="translated">N-API는 가장 일반적인 비동기 사용 사례를 다루는 이러한 지원 기능을위한 ABI 안정적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f39db522f9283fcef0c912ba468da776135f241" translate="yes" xml:space="preserve">
          <source>N-API provides an API for executing a string containing JavaScript using the underlying JavaScript engine.</source>
          <target state="translated">N-API는 기본 JavaScript 엔진을 사용하여 JavaScript가 포함 된 문자열을 실행하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2313fc0c61261c329c023f99d171fe8dbee4423c" translate="yes" xml:space="preserve">
          <source>N-API provides facilities for creating &lt;code&gt;Promise&lt;/code&gt; objects as described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-promise-objects&quot;&gt;Section 25.4&lt;/a&gt; of the ECMA specification. It implements promises as a pair of objects. When a promise is created by &lt;code&gt;napi_create_promise()&lt;/code&gt;, a &quot;deferred&quot; object is created and returned alongside the &lt;code&gt;Promise&lt;/code&gt;. The deferred object is bound to the created &lt;code&gt;Promise&lt;/code&gt; and is the only means to resolve or reject the &lt;code&gt;Promise&lt;/code&gt; using &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; or &lt;code&gt;napi_reject_deferred()&lt;/code&gt;. The deferred object that is created by &lt;code&gt;napi_create_promise()&lt;/code&gt; is freed by &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; or &lt;code&gt;napi_reject_deferred()&lt;/code&gt;. The &lt;code&gt;Promise&lt;/code&gt; object may be returned to JavaScript where it can be used in the usual fashion.</source>
          <target state="translated">N-API는 ECMA 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-promise-objects&quot;&gt;섹션 25.4&lt;/a&gt; 에 설명 된대로 &lt;code&gt;Promise&lt;/code&gt; 객체 를 생성하는 기능을 제공합니다 . 약속을 한 쌍의 객체로 구현합니다. &lt;code&gt;napi_create_promise()&lt;/code&gt; 의해 promise가 생성되면 &quot;deferred&quot;개체가 생성되어 &lt;code&gt;Promise&lt;/code&gt; 와 함께 반환 됩니다. 지연된 오브젝트는 작성된 &lt;code&gt;Promise&lt;/code&gt; 에 바인드되며 &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; 또는 &lt;code&gt;napi_reject_deferred()&lt;/code&gt; 사용 하여 &lt;code&gt;Promise&lt;/code&gt; 를 해결하거나 거부하는 유일한 수단 입니다. &lt;code&gt;napi_create_promise()&lt;/code&gt; 작성된 지연된 오브젝트는 &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; 또는 &lt;code&gt;napi_reject_deferred()&lt;/code&gt; 의해 해제됩니다.. &lt;code&gt;Promise&lt;/code&gt; 객체가 일반적인 방식으로 사용할 수있는 자바 스크립트로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d99e6c12543c037d84d75d93df6bb441b536baa" translate="yes" xml:space="preserve">
          <source>N-API provides functions for registering and un-registering such callbacks. When those callbacks are run, all resources that are being held by the addon should be freed up.</source>
          <target state="translated">N-API는 이러한 콜백을 등록 및 등록 해제하는 기능을 제공합니다. 이러한 콜백이 실행될 때 애드온이 보유하고있는 모든 리소스를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7c3cd228011e5d9137f1bb00c23394226dbfbfc" translate="yes" xml:space="preserve">
          <source>N-API provides methods to create persistent references to an object. Each persistent reference has an associated count with a value of 0 or higher. The count determines if the reference will keep the corresponding object live. References with a count of 0 do not prevent the object from being collected and are often called 'weak' references. Any count greater than 0 will prevent the object from being collected.</source>
          <target state="translated">N-API는 개체에 대한 영구 참조를 만드는 방법을 제공합니다. 각 영구 참조에는 값이 0 이상인 관련 카운트가 있습니다. 카운트는 참조가 해당 객체를 라이브로 유지할지 여부를 결정합니다. 카운트가 0 인 참조는 오브젝트가 수집되는 것을 방해하지 않으며 종종 '약한'참조라고합니다. 카운트가 0보다 크면 개체가 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21039b0e91105633cdec6fe19581a15729f4b937" translate="yes" xml:space="preserve">
          <source>N-API sets up the environment prior to calling this callback, so it is sufficient to call the JavaScript function via &lt;code&gt;napi_call_function&lt;/code&gt; rather than via &lt;code&gt;napi_make_callback&lt;/code&gt;.</source>
          <target state="translated">환경까지 이전이 콜백을 호출하는 N-API 세트, 그래서를 통해 자바 스크립트 함수를 호출하기에 충분 &lt;code&gt;napi_call_function&lt;/code&gt; 보다는 통해 &lt;code&gt;napi_make_callback&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea939312c782d8c5e666ab405635666046b5b1f" translate="yes" xml:space="preserve">
          <source>N-API uses both return values and JavaScript exceptions for error handling. The following sections explain the approach for each case.</source>
          <target state="translated">N-API는 오류 처리에 반환 값과 JavaScript 예외를 모두 사용합니다. 다음 섹션에서는 각 사례에 대한 접근 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1171e6e250c8137afa5e0b60938de57ff990d9c4" translate="yes" xml:space="preserve">
          <source>N-API values are represented by the type &lt;code&gt;napi_value&lt;/code&gt;. Any N-API call that requires a JavaScript value takes in a &lt;code&gt;napi_value&lt;/code&gt;. However, it's the caller's responsibility to make sure that the &lt;code&gt;napi_value&lt;/code&gt; in question is of the JavaScript type expected by the API.</source>
          <target state="translated">N-API 값은 &lt;code&gt;napi_value&lt;/code&gt; 유형으로 표시됩니다 . JavaScript 값이 필요한 N-API 호출은 &lt;code&gt;napi_value&lt;/code&gt; 를받습니다 . 그러나 해당 &lt;code&gt;napi_value&lt;/code&gt; 가 API에 필요한 JavaScript 유형 인지 확인하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="ed30e9f4e0aa475cc4bcf4606fa7aa3e116ab3a4" translate="yes" xml:space="preserve">
          <source>N-API values are represented by the type &lt;code&gt;napi_value&lt;/code&gt;. Any N-API call that requires a JavaScript value takes in a &lt;code&gt;napi_value&lt;/code&gt;. In some cases, the API does check the type of the &lt;code&gt;napi_value&lt;/code&gt; up-front. However, for better performance, it's better for the caller to make sure that the &lt;code&gt;napi_value&lt;/code&gt; in question is of the JavaScript type expected by the API.</source>
          <target state="translated">N-API 값은 &lt;code&gt;napi_value&lt;/code&gt; 유형으로 표시됩니다 . JavaScript 값이 필요한 N-API 호출은 &lt;code&gt;napi_value&lt;/code&gt; 를받습니다 . 경우에 따라 API는 &lt;code&gt;napi_value&lt;/code&gt; 의 유형을 사전에 확인합니다 . 그러나 성능을 향상 시키려면 호출자가 해당 &lt;code&gt;napi_value&lt;/code&gt; 가 API에서 예상하는 JavaScript 유형 인지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8d77c1ac20c6483c8f420a855abd5497053e93d5" translate="yes" xml:space="preserve">
          <source>N-API version matrix</source>
          <target state="translated">N-API 버전 매트릭스</target>
        </trans-unit>
        <trans-unit id="af583d89de0c7c4b8c0e6223b8b144c689c84cc0" translate="yes" xml:space="preserve">
          <source>N-API version: 1</source>
          <target state="translated">N-API 버전 : 1</target>
        </trans-unit>
        <trans-unit id="42eb0bf2898c4d90751141d61f3a812907fc83bc" translate="yes" xml:space="preserve">
          <source>N-API version: 4</source>
          <target state="translated">N-API 버전 : 4</target>
        </trans-unit>
        <trans-unit id="36688c47c6b67b86c616353a7b6ea5bc6ef4edce" translate="yes" xml:space="preserve">
          <source>N-API versions are additive and versioned independently from Node.js. Version 4 is an extension to version 3 in that it has all of the APIs from version 3 with some additions. This means that it is not necessary to recompile for new versions of Node.js which are listed as supporting a later version.</source>
          <target state="translated">N-API 버전은 추가되며 Node.js와 독립적으로 버전이 지정됩니다. 버전 4는 버전 3의 모든 API가 추가되어 버전 3의 확장입니다. 즉, 이후 버전을 지원하는 것으로 나열된 새 버전의 Node.js를 다시 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9c9f155bef3ac70ea5522b0c447a11486f56d68" translate="yes" xml:space="preserve">
          <source>NaN is now treated as being identical in case both sides are NaN.</source>
          <target state="translated">이제 NaN은 양쪽이 모두 NaN 인 경우 동일한 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4861f73679976cfe93d5853d1be47fcaa088f38c" translate="yes" xml:space="preserve">
          <source>Nagle's algorithm delays data before it is sent via the network. It attempts to optimize throughput at the expense of latency.</source>
          <target state="translated">Nagle의 알고리즘은 데이터가 네트워크를 통해 전송되기 전에 데이터를 지연시킵니다. 대기 시간을 희생하면서 처리량을 최적화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="5ad766507b42c419a18a1fab4a93852992d6d506" translate="yes" xml:space="preserve">
          <source>Name of the file to which the report will be written.</source>
          <target state="translated">보고서가 작성 될 파일의 ​​이름입니다.</target>
        </trans-unit>
        <trans-unit id="1048f6c8527f66e3515e900d898fe7d003e1f286" translate="yes" xml:space="preserve">
          <source>Named exports detection covers many common export patterns, reexport patterns and build tool and transpiler outputs. See &lt;a href=&quot;https://github.com/guybedford/cjs-module-lexer/tree/0.4.2&quot;&gt;cjs-module-lexer&lt;/a&gt; for the exact semantics implemented.</source>
          <target state="translated">명명 된 내보내기 감지는 많은 일반적인 내보내기 패턴, 다시 내보내기 패턴, 빌드 도구 및 트랜스 파일러 출력을 포함합니다. 구현 된 정확한 의미는 &lt;a href=&quot;https://github.com/guybedford/cjs-module-lexer/tree/0.4.2&quot;&gt;cjs-module-lexer&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8325a8327d8fb8a683bf7014a3df6f7074fc2c9e" translate="yes" xml:space="preserve">
          <source>Named exports detection covers many common export patterns, reexport patterns and build tool and transpiler outputs. See &lt;a href=&quot;https://github.com/guybedford/cjs-module-lexer/tree/1.0.0&quot;&gt;cjs-module-lexer&lt;/a&gt; for the exact semantics implemented.</source>
          <target state="translated">명명 된 내보내기 감지는 많은 일반적인 내보내기 패턴, 다시 내보내기 패턴, 빌드 도구 및 트랜스 파일러 출력을 포함합니다. 구현 된 정확한 의미는 &lt;a href=&quot;https://github.com/guybedford/cjs-module-lexer/tree/1.0.0&quot;&gt;cjs-module-lexer&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc22075ed2175ad5ccc2508aac2f833f87e45dda" translate="yes" xml:space="preserve">
          <source>Named: a simple UTF8-encoded string</source>
          <target state="translated">명명 : 간단한 UTF8 인코딩 문자열</target>
        </trans-unit>
        <trans-unit id="7137f503dc2584ea8280d497399006e247e659b7" translate="yes" xml:space="preserve">
          <source>Native Abstractions for Node.js</source>
          <target state="translated">Node.js의 기본 추상화</target>
        </trans-unit>
        <trans-unit id="5b2b42c72d18c6faa9885b4109d0dd739273361a" translate="yes" xml:space="preserve">
          <source>Native abstractions for Node.js</source>
          <target state="translated">Node.js의 기본 추상화</target>
        </trans-unit>
        <trans-unit id="edcea4b8da29480f402438959046ab2f9f368022" translate="yes" xml:space="preserve">
          <source>Native add-ons can only be loaded from multiple threads if they fulfill &lt;a href=&quot;addons#addons_worker_support&quot;&gt;certain conditions&lt;/a&gt;.</source>
          <target state="translated">기본 애드온은 &lt;a href=&quot;addons#addons_worker_support&quot;&gt;특정 조건&lt;/a&gt; 을 충족 하는 경우에만 여러 스레드에서로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6675537e94c99d143279098c166eb1d6147b5fc" translate="yes" xml:space="preserve">
          <source>Native addons may need to allocate global state of which they make use during their entire life cycle such that the state must be unique to each instance of the addon.</source>
          <target state="translated">기본 애드온은 전체 수명주기 동안 사용되는 글로벌 상태를 할당하여 상태가 애드온의 각 인스턴스에 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="5eeb4b95aa64d8fee6f596435f2844988e53b6b8" translate="yes" xml:space="preserve">
          <source>Native addons may need to allocate global state which they use during their entire life cycle such that the state must be unique to each instance of the addon.</source>
          <target state="translated">네이티브 애드온은 전체 수명주기 동안 사용하는 전역 상태를 할당해야 할 수 있으므로 상태가 애드온의 각 인스턴스에 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a998c2dc83ce627649da16d854c4244317dd6b5" translate="yes" xml:space="preserve">
          <source>Native modules are not currently supported with ES module imports.</source>
          <target state="translated">네이티브 모듈은 현재 ES 모듈 가져 오기에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="264fa17f0716888a4cd2265fb034958375c3d60e" translate="yes" xml:space="preserve">
          <source>Negative &lt;code&gt;end&lt;/code&gt; values throw an &lt;code&gt;ERR_INDEX_OUT_OF_RANGE&lt;/code&gt; error.</source>
          <target state="translated">음수 &lt;code&gt;end&lt;/code&gt; 값은 &lt;code&gt;ERR_INDEX_OUT_OF_RANGE&lt;/code&gt; 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d6bf8490f059717c8e2d09d80c5d0cd5ed5e1330" translate="yes" xml:space="preserve">
          <source>Neither does &lt;code&gt;napi_unref_threadsafe_function&lt;/code&gt; mark the thread-safe functions as able to be destroyed nor does &lt;code&gt;napi_ref_threadsafe_function&lt;/code&gt; prevent it from being destroyed.</source>
          <target state="translated">어느 쪽도하지 않습니다 &lt;code&gt;napi_unref_threadsafe_function&lt;/code&gt; 파괴 할 수와 스레드 안전 기능을 표시도하지 &lt;code&gt;napi_ref_threadsafe_function&lt;/code&gt; 파괴되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd380c71e5072703e31986beeba244ee7a164ed8" translate="yes" xml:space="preserve">
          <source>Neither does &lt;code&gt;napi_unref_threadsafe_function&lt;/code&gt; mark the thread-safe functions as able to be destroyed nor does &lt;code&gt;napi_ref_threadsafe_function&lt;/code&gt; prevent it from being destroyed. &lt;code&gt;napi_acquire_threadsafe_function&lt;/code&gt; and &lt;code&gt;napi_release_threadsafe_function&lt;/code&gt; are available for that purpose.</source>
          <target state="translated">어느 쪽도하지 않습니다 &lt;code&gt;napi_unref_threadsafe_function&lt;/code&gt; 파괴 할 수와 스레드 안전 기능을 표시도하지 &lt;code&gt;napi_ref_threadsafe_function&lt;/code&gt; 파괴되는 것을 방지 할 수 있습니다. &lt;code&gt;napi_acquire_threadsafe_function&lt;/code&gt; 위해 napi_acquire_threadsafe_function 및 &lt;code&gt;napi_release_threadsafe_function&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba80e45016258331008bc495a573c344a21c641" translate="yes" xml:space="preserve">
          <source>Neither the well known nor extra certificates are used when the &lt;code&gt;ca&lt;/code&gt; options property is explicitly specified for a TLS or HTTPS client or server.</source>
          <target state="translated">&lt;code&gt;ca&lt;/code&gt; 옵션 특성이 TLS 또는 HTTPS 클라이언트 또는 서버에 대해 명시 적으로 지정된 경우 잘 알려진 인증서 나 추가 인증서가 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b48fa14f090ac8735751585b8cfb2e0dd0a835a7" translate="yes" xml:space="preserve">
          <source>Nested conditions</source>
          <target state="translated">중첩 된 조건</target>
        </trans-unit>
        <trans-unit id="9bb81c2eccbed59ee8cbe296f1278f0ca1f364cc" translate="yes" xml:space="preserve">
          <source>Net</source>
          <target state="translated">Net</target>
        </trans-unit>
        <trans-unit id="9d926a391a10419818faebd2c569e4c93c8a271b" translate="yes" xml:space="preserve">
          <source>New HTTP/2 Streams may not be opened after the &lt;code&gt;Http2Session&lt;/code&gt; has received a &lt;code&gt;GOAWAY&lt;/code&gt; frame from the connected peer.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 이 연결된 피어로부터 &lt;code&gt;GOAWAY&lt;/code&gt; 프레임을 수신 한 후 새 HTTP / 2 스트림이 열리지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7193207627db5aaa3ebdacf110c6817d0cb0fe81" translate="yes" xml:space="preserve">
          <source>New applications should expect the default to be &lt;code&gt;'buffer'&lt;/code&gt;.</source>
          <target state="translated">새로운 응용 프로그램은 기본값이 &lt;code&gt;'buffer'&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e15548774f6f9b49b8188ccd5ba9d78c166b8e1" translate="yes" xml:space="preserve">
          <source>New instances of &lt;code&gt;QuicClientSession&lt;/code&gt; are created using the &lt;code&gt;connect()&lt;/code&gt; function on a &lt;code&gt;QuicSocket&lt;/code&gt; as in the example below:</source>
          <target state="translated">&lt;code&gt;QuicClientSession&lt;/code&gt; 의 새 인스턴스는 아래 예제와 같이 &lt;code&gt;QuicSocket&lt;/code&gt; 에서 &lt;code&gt;connect()&lt;/code&gt; 함수를 사용하여 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d2d1592c30cddf89ab767c42220616cbbac903" translate="yes" xml:space="preserve">
          <source>New instances of &lt;code&gt;QuicServerSession&lt;/code&gt; are created internally by the &lt;code&gt;QuicSocket&lt;/code&gt; if it has been configured to listen for new connections using the &lt;code&gt;listen()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;QuicServerSession&lt;/code&gt; 의 새 인스턴스 는 &lt;code&gt;listen()&lt;/code&gt; 메서드를 사용하여 새 연결을 수신하도록 구성된 경우 &lt;code&gt;QuicSocket&lt;/code&gt; 에 의해 내부적으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="868d027d188d42b401539ab7a362c36acad66bf5" translate="yes" xml:space="preserve">
          <source>New instances of &lt;code&gt;QuicSocket&lt;/code&gt; are created using the &lt;code&gt;net.createQuicSocket()&lt;/code&gt; method, and can be used as both a client and a server.</source>
          <target state="translated">새로운 &lt;code&gt;QuicSocket&lt;/code&gt; 인스턴스는 net.createQuicSocket &lt;code&gt;net.createQuicSocket()&lt;/code&gt; 메서드를 사용하여 생성 되며 클라이언트와 서버 모두로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538dbd3921c4aa1f787f750bebace3312d5e5773" translate="yes" xml:space="preserve">
          <source>New instances of &lt;code&gt;dgram.Socket&lt;/code&gt; are created using &lt;a href=&quot;#dgram_dgram_createsocket_options_callback&quot;&gt;&lt;code&gt;dgram.createSocket()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;new&lt;/code&gt; keyword is not to be used to create &lt;code&gt;dgram.Socket&lt;/code&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;#dgram_dgram_createsocket_options_callback&quot;&gt; &lt;code&gt;dgram.createSocket()&lt;/code&gt; &lt;/a&gt; 사용하여 새 &lt;code&gt;dgram.Socket&lt;/code&gt; 인스턴스를 만듭니다 . &lt;code&gt;new&lt;/code&gt; 키워드를 만드는 데 사용하지 않을 &lt;code&gt;dgram.Socket&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="8286903a3b42f30c2845be65b9063df789c12e5a" translate="yes" xml:space="preserve">
          <source>New option &lt;code&gt;withFileTypes&lt;/code&gt; was added.</source>
          <target state="translated">&lt;code&gt;withFileTypes&lt;/code&gt; 새로운 옵션 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d9b883a3b076116d662bc7a87ea12fa4ff91a952" translate="yes" xml:space="preserve">
          <source>Next history item</source>
          <target state="translated">다음 역사 항목</target>
        </trans-unit>
        <trans-unit id="dc072aabd2bae6e9c49b6e900e7612de2b36503a" translate="yes" xml:space="preserve">
          <source>Next, invoke the &lt;code&gt;node-gyp build&lt;/code&gt; command to generate the compiled &lt;code&gt;addon.node&lt;/code&gt; file. This will be put into the &lt;code&gt;build/Release/&lt;/code&gt; directory.</source>
          <target state="translated">그런 다음 &lt;code&gt;node-gyp build&lt;/code&gt; 명령을 호출하여 컴파일 된 &lt;code&gt;addon.node&lt;/code&gt; 파일 을 생성 하십시오. 이것은 &lt;code&gt;build/Release/&lt;/code&gt; 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="60c6db9ea82d2e5e907d48b09a58571de5491306" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; event listener is added.</source>
          <target state="translated">&lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 이벤트 리스너가 추가 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="7713480c15dd839650512046c796bdd1e22142e3" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;NODE_PATH&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NODE_PATH&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="7361173fb484e84aaf68d0c47d4f871c12275315" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;__filename&lt;/code&gt; or &lt;code&gt;__dirname&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__filename&lt;/code&gt; 또는 &lt;code&gt;__dirname&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="4e365ecb80d6c5e0aee9009ce4f7cb44fc85a412" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require.cache&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require.cache&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="5fdcf81df39a04935671e5f913e82a9ed67ac793" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require.extensions&lt;/code&gt;</source>
          <target state="translated">어떤 &lt;code&gt;require.extensions&lt;/code&gt; 없습니다</target>
        </trans-unit>
        <trans-unit id="b7884051283c69059211963d23c652ce9c1f43cb" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require.resolve&lt;/code&gt;</source>
          <target state="translated">어떤 &lt;code&gt;require.resolve&lt;/code&gt; 없습니다</target>
        </trans-unit>
        <trans-unit id="31d574584ee13786d014cad173cf9f70d7bcd958" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">아니 &lt;code&gt;require&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;module.exports&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="73bd086942e812ae818e7cbfbd123ebe5c91a9cf" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module.exports&lt;/code&gt;, &lt;code&gt;__filename&lt;/code&gt;, &lt;code&gt;__dirname&lt;/code&gt;</source>
          <target state="translated">아니 &lt;code&gt;require&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; , &lt;code&gt;module.exports&lt;/code&gt; , &lt;code&gt;__filename&lt;/code&gt; , &lt;code&gt;__dirname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d424da21bf8bf374cdfa3070439b63b71a40f17e" translate="yes" xml:space="preserve">
          <source>No Error</source>
          <target state="translated">오류 없음</target>
        </trans-unit>
        <trans-unit id="19446f0d45b50dbe4f0de6fb65db0a6b201e582c" translate="yes" xml:space="preserve">
          <source>No JSON Module Loading</source>
          <target state="translated">JSON 모듈로드 없음</target>
        </trans-unit>
        <trans-unit id="6fc718bbe6600d4a272a19e0ea5f974efa74df8f" translate="yes" xml:space="preserve">
          <source>No Native Module Loading</source>
          <target state="translated">네이티브 모듈로드 없음</target>
        </trans-unit>
        <trans-unit id="e2a350e3da36cf6a880449d24a7d22ab9e4027d2" translate="yes" xml:space="preserve">
          <source>No arguments other than a possible exception are given to the completion callback.</source>
          <target state="translated">가능한 예외 이외의 인수는 완료 콜백에 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d617594d209195a47bc9a68e67dac23de396ed7" translate="yes" xml:space="preserve">
          <source>No case conversion is performed on case-insensitive file systems.</source>
          <target state="translated">대소 문자를 구분하지 않는 파일 시스템에서는 대소 문자 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3331168b9cff4f62863ed956ba7c063dc1e66ff" translate="yes" xml:space="preserve">
          <source>No decoding of the &lt;code&gt;path&lt;/code&gt; is performed.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 디코딩 이 수행 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a6ddfb774d5f9c27c27174db32faeb0af1ec6da" translate="yes" xml:space="preserve">
          <source>No decoding of the path string is performed.</source>
          <target state="translated">경로 문자열의 디코딩이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13c8ff0aedccedab26b0a9cc20907ad8d12092c6" translate="yes" xml:space="preserve">
          <source>No decoding of the query string is performed.</source>
          <target state="translated">쿼리 문자열의 디코딩이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a03f0fd922f89467f81c73b168c18f01a6802039" translate="yes" xml:space="preserve">
          <source>No default extensions</source>
          <target state="translated">기본 확장명 없음</target>
        </trans-unit>
        <trans-unit id="927a7432a2380470b398b68e7bf815a0c092cf92" translate="yes" xml:space="preserve">
          <source>No folder mains</source>
          <target state="translated">폴더 메인 없음</target>
        </trans-unit>
        <trans-unit id="33721baca453ed3776b1934ed251f43df574f827" translate="yes" xml:space="preserve">
          <source>No longer experimental.</source>
          <target state="translated">더 이상 실험적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="b0b78d39dcf9723cadf7c92f189fafd553d14144" translate="yes" xml:space="preserve">
          <source>Node.js (and its underlying V8 engine) uses &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; to implement these features in native C/C++ code. However, some of them require a very large ICU data file in order to support all locales of the world. Because it is expected that most Node.js users will make use of only a small portion of ICU functionality, only a subset of the full ICU data set is provided by Node.js by default. Several options are provided for customizing and expanding the ICU data set either when building or running Node.js.</source>
          <target state="translated">Node.js (및 기본 V8 엔진)는 &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; 를 사용 하여 이러한 기능을 기본 C / C ++ 코드로 구현합니다. 그러나 일부는 전 세계 모든 로케일을 지원하기 위해 매우 큰 ICU 데이터 파일이 필요합니다. 대부분의 Node.js 사용자는 ICU 기능의 일부만 사용할 것으로 예상되므로 기본적으로 전체 ICU 데이터 세트의 서브 세트 만 Node.js에 의해 제공됩니다. Node.js를 빌드하거나 실행할 때 ICU 데이터 세트를 사용자 정의하고 확장하기위한 여러 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c539dfd29c36580c7afd3ad17f46f3f5fa46d7d7" translate="yes" xml:space="preserve">
          <source>Node.js (and its underlying V8 engine) uses &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; to implement these features in native C/C++ code. The full ICU data set is provided by Node.js by default. However, due to the size of the ICU data file, several options are provided for customizing the ICU data set either when building or running Node.js.</source>
          <target state="translated">Node.js (및 기본 V8 엔진)는 &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; 를 사용 하여 이러한 기능을 네이티브 C / C ++ 코드로 구현합니다. 전체 ICU 데이터 세트는 기본적으로 Node.js에서 제공합니다. 그러나 ICU 데이터 파일의 크기로 인해 Node.js를 빌드하거나 실행할 때 ICU 데이터 세트를 사용자 정의하기위한 몇 가지 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ea04817c5b66536ed37593c38099d256e6265d" translate="yes" xml:space="preserve">
          <source>Node.js &lt;code&gt;EventTarget&lt;/code&gt; vs. DOM &lt;code&gt;EventTarget&lt;/code&gt;</source>
          <target state="translated">Node.js &lt;code&gt;EventTarget&lt;/code&gt; 대 DOM &lt;code&gt;EventTarget&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd391461f54f5f00a9ca884b393cb0665af6364d" translate="yes" xml:space="preserve">
          <source>Node.js &lt;code&gt;package.json&lt;/code&gt; field definitions</source>
          <target state="translated">Node.js &lt;code&gt;package.json&lt;/code&gt; 필드 정의</target>
        </trans-unit>
        <trans-unit id="dc273ad6c9801813717d36e19bf7f8023b01504f" translate="yes" xml:space="preserve">
          <source>Node.js APIs might be deprecated for any of the following reasons:</source>
          <target state="translated">Node.js API는 다음과 같은 이유로 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c6ff3487c288f0b8d40123f15c094451d4d58d" translate="yes" xml:space="preserve">
          <source>Node.js Addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using the &lt;a href=&quot;modules#modules_require_id&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; function, and used just as if they were an ordinary Node.js module. They are used primarily to provide an interface between JavaScript running in Node.js and C/C++ libraries.</source>
          <target state="translated">Node.js 애드온은 C ++로 작성된 동적으로 연결된 공유 객체로 &lt;a href=&quot;modules#modules_require_id&quot;&gt; &lt;code&gt;require()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Node.js에로드 할 수 있으며 일반 Node.js 모듈처럼 사용할 수 있습니다. 주로 Node.js에서 실행되는 JavaScript와 C / C ++ 라이브러리 간의 인터페이스를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51be1c370c336ba5619c2e9080dd4bf368c9c46b" translate="yes" xml:space="preserve">
          <source>Node.js Crypto Constants</source>
          <target state="translated">Node.js 암호화 상수</target>
        </trans-unit>
        <trans-unit id="441aa6a1425f4454daa77eeba4c8ce3a18045fb8" translate="yes" xml:space="preserve">
          <source>Node.js Error Codes</source>
          <target state="translated">Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="c6d30bd2144c9d89e9803d2977bc8a87eb8771f7" translate="yes" xml:space="preserve">
          <source>Node.js also supports the following two binary-to-text encodings. For binary-to-text encodings, the naming convention is reversed: Converting a &lt;code&gt;Buffer&lt;/code&gt; into a string is typically referred to as encoding, and converting a string into a &lt;code&gt;Buffer&lt;/code&gt; as decoding.</source>
          <target state="translated">Node.js는 다음과 같은 두 가지 바이너리-텍스트 인코딩도 지원합니다. 이진-텍스트 인코딩의 경우 명명 규칙이 반대입니다. &lt;code&gt;Buffer&lt;/code&gt; 를 문자열로 변환하는 것은 일반적으로 인코딩이라고하며 문자열을 디코딩 으로 &lt;code&gt;Buffer&lt;/code&gt; 로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="179df0cc5008db133b8bc9a59310d37319853e06" translate="yes" xml:space="preserve">
          <source>Node.js can be started using the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; command line option to cause all newly allocated &lt;code&gt;Buffer&lt;/code&gt; instances to be zero-filled upon creation by default. Before Node.js 8.0.0, this included buffers allocated by &lt;code&gt;new Buffer(size)&lt;/code&gt;. Since Node.js 8.0.0, buffers allocated with &lt;code&gt;new&lt;/code&gt; are always zero-filled, whether this option is used or not. &lt;a href=&quot;#buffer_class_method_buffer_allocunsafe_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#buffer_class_method_buffer_allocunsafeslow_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;new SlowBuffer(size)&lt;/code&gt;. Use of this flag can have a significant negative impact on performance. Use of the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; option is recommended only when necessary to enforce that newly allocated &lt;code&gt;Buffer&lt;/code&gt; instances cannot contain old data that is potentially sensitive.</source>
          <target state="translated">Node.js는 &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 명령 행 옵션을 사용하여 시작하여 기본적으로 새로 할당 된 모든 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스가 0으로 채워지도록 할 수 있습니다. Node.js 8.0.0 이전에는 &lt;code&gt;new Buffer(size)&lt;/code&gt; 의해 할당 된 버퍼가 포함되었습니다 . Node.js 8.0.0부터 &lt;code&gt;new&lt;/code&gt; 로 할당 된 버퍼 는이 옵션의 사용 여부에 관계없이 항상 0으로 채워집니다. &lt;a href=&quot;#buffer_class_method_buffer_allocunsafe_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#buffer_class_method_buffer_allocunsafeslow_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;new SlowBuffer(size)&lt;/code&gt; . 이 플래그를 사용하면 성능에 상당한 부정적인 영향을 줄 수 있습니다. 의 사용 &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 옵션은 새로 할당 적용 할 경우에만 필요한 것이 좋습니다 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스는 잠재적으로 민감한 오래된 데이터를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f54ed66583f9bae1455fd00e2272f6a34ca953a" translate="yes" xml:space="preserve">
          <source>Node.js can be started using the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; command-line option to cause all newly-allocated &lt;code&gt;Buffer&lt;/code&gt; instances to be zero-filled upon creation by default. Without the option, buffers created with &lt;a href=&quot;#buffer_static_method_buffer_allocunsafe_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#buffer_static_method_buffer_allocunsafeslow_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;new SlowBuffer(size)&lt;/code&gt; are not zero-filled. Use of this flag can have a measurable negative impact on performance. Use the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; option only when necessary to enforce that newly allocated &lt;code&gt;Buffer&lt;/code&gt; instances cannot contain old data that is potentially sensitive.</source>
          <target state="translated">Node.js는 &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 명령 줄 옵션을 사용하여 시작하여 새로 할당 된 모든 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스가 기본적으로 생성시 0으로 채워지도록 할 수 있습니다. 옵션이 없으면 &lt;a href=&quot;#buffer_static_method_buffer_allocunsafe_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#buffer_static_method_buffer_allocunsafeslow_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;new SlowBuffer(size)&lt;/code&gt; 로 생성 된 버퍼 는 0으로 채워지지 않습니다. 이 플래그를 사용하면 성능에 측정 가능한 부정적인 영향을 미칠 수 있습니다. &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 옵션은 새로 할당 된 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스가 잠재적으로 민감한 이전 데이터를 포함 할 수 없도록 강제하는 데 필요한 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f1a7ae4eec5392042ce17901f72140ba89d819" translate="yes" xml:space="preserve">
          <source>Node.js can link against an ICU build already installed on the system. In fact, most Linux distributions already come with ICU installed, and this option would make it possible to reuse the same set of data used by other components in the OS.</source>
          <target state="translated">Node.js는 시스템에 이미 설치된 ICU 빌드에 연결할 수 있습니다. 실제로 대부분의 Linux 배포에는 이미 ICU가 설치되어 제공되며이 옵션을 사용하면 OS의 다른 구성 요소에서 사용하는 것과 동일한 데이터 집합을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36cc4fad1e7074ce4842d8c3aae603fd4ad5ea2" translate="yes" xml:space="preserve">
          <source>Node.js can now run ES module entry points, and a package can contain both CommonJS and ES module entry points (either via separate specifiers such as &lt;code&gt;'pkg'&lt;/code&gt; and &lt;code&gt;'pkg/es-module'&lt;/code&gt;, or both at the same specifier via &lt;a href=&quot;#packages_conditional_exports&quot;&gt;Conditional exports&lt;/a&gt;). Unlike in the scenario where &lt;code&gt;&quot;module&quot;&lt;/code&gt; is only used by bundlers, or ES module files are transpiled into CommonJS on the fly before evaluation by Node.js, the files referenced by the ES module entry point are evaluated as ES modules.</source>
          <target state="translated">Node.js는 이제 ES 모듈 진입 점을 실행할 수 있으며 패키지는 CommonJS 및 ES 모듈 진입 점을 모두 포함 할 수 있습니다 ( &lt;code&gt;'pkg'&lt;/code&gt; 및 &lt;code&gt;'pkg/es-module'&lt;/code&gt; 과 같은 별도의 지정자를 통해 또는 &lt;a href=&quot;#packages_conditional_exports&quot;&gt;조건부&lt;/a&gt; 를 통해 동일한 지정자에 둘 다 포함). 수출 ). &lt;code&gt;&quot;module&quot;&lt;/code&gt; 이 번 들러에 의해서만 사용되거나 ES 모듈 파일이 Node.js에 의해 평가되기 전에 즉석에서 CommonJS로 트랜스 파일되는 시나리오와 달리 ES 모듈 진입 점에서 참조하는 파일은 ES 모듈로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="5810ddd39bdfe4323cf379ac3f7b781e60db98e0" translate="yes" xml:space="preserve">
          <source>Node.js comes with a variety of CLI options. These options expose built-in debugging, multiple ways to execute scripts, and other helpful runtime options.</source>
          <target state="translated">Node.js는 다양한 CLI 옵션과 함께 제공됩니다. 이러한 옵션은 내장 디버깅, 스크립트를 실행하는 여러 가지 방법 및 기타 유용한 런타임 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="700f33732d1ab659fda7ca90f224da1753e7cde0" translate="yes" xml:space="preserve">
          <source>Node.js contains experimental support for creating policies on loading code.</source>
          <target state="translated">Node.js에는 코드로드에 대한 정책 작성을위한 실험적인 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994583ed9ea64b95980a99b8ac9cb934c0c8136" translate="yes" xml:space="preserve">
          <source>Node.js contains support for ES Modules based upon the &lt;a href=&quot;https://github.com/nodejs/node-eps/blob/master/002-es-modules.md&quot;&gt;Node.js EP for ES Modules&lt;/a&gt; and the &lt;a href=&quot;https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md&quot;&gt;ECMAScript-modules implementation&lt;/a&gt;.</source>
          <target state="translated">Node.js에는 &lt;a href=&quot;https://github.com/nodejs/node-eps/blob/master/002-es-modules.md&quot;&gt;Node.js EP for ES Modules&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md&quot;&gt;ECMAScript-modules 구현을&lt;/a&gt; 기반으로하는 ES Modules 지원이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c490a214340b790bb43bbfd2fa0be7c3074d0693" translate="yes" xml:space="preserve">
          <source>Node.js crypto constants</source>
          <target state="translated">Node.js 암호화 상수</target>
        </trans-unit>
        <trans-unit id="f284dbd956cb499dff05c1a4c98369975a26484c" translate="yes" xml:space="preserve">
          <source>Node.js currently overwrites &lt;code&gt;argv[0]&lt;/code&gt; with &lt;code&gt;process.execPath&lt;/code&gt; on startup, so &lt;code&gt;process.argv[0]&lt;/code&gt; in a Node.js child process will not match the &lt;code&gt;argv0&lt;/code&gt; parameter passed to &lt;code&gt;spawn&lt;/code&gt; from the parent, retrieve it with the &lt;code&gt;process.argv0&lt;/code&gt; property instead.</source>
          <target state="translated">Node.js는 현재 시작시 &lt;code&gt;process.execPath&lt;/code&gt; 로 &lt;code&gt;argv[0]&lt;/code&gt; 을 겹쳐 쓰므 로 Node.js 하위 프로세스의 &lt;code&gt;process.argv[0]&lt;/code&gt; 은 상위에서 &lt;code&gt;spawn&lt;/code&gt; 되도록 전달 된 &lt;code&gt;argv0&lt;/code&gt; 매개 변수 와 일치하지 않으므로 &lt;code&gt;process.argv0&lt;/code&gt; 으로 검색하십시오. 대신 속성.</target>
        </trans-unit>
        <trans-unit id="71f1ec4dc71d40c8c7d0a68270209a7d73533f56" translate="yes" xml:space="preserve">
          <source>Node.js does not check whether Content-Length and the length of the body which has been transmitted are equal or not.</source>
          <target state="translated">Node.js는 Content-Length와 전송 된 본문의 길이가 같은지 여부를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06e7f421afd071d9d6af3f9498e9ce444a8edad0" translate="yes" xml:space="preserve">
          <source>Node.js does not provide routing logic. It is, therefore important to design an application such that it does not rely too heavily on in-memory data objects for things like sessions and login.</source>
          <target state="translated">Node.js는 라우팅 로직을 제공하지 않습니다. 따라서 세션 및 로그인과 같은 인 메모리 데이터 개체에 너무 의존하지 않도록 응용 프로그램을 디자인하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8bc2f65bdd2e7e9164e8bd1a326d5600365b5ab6" translate="yes" xml:space="preserve">
          <source>Node.js error codes</source>
          <target state="translated">Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="59620f5a7d966f7ed19e56a82fa67f4d669f5bf7" translate="yes" xml:space="preserve">
          <source>Node.js establishes signal handlers for &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGTERM&lt;/code&gt; and Node.js processes will not terminate immediately due to receipt of those signals. Rather, Node.js will perform a sequence of cleanup actions and then will re-raise the handled signal.</source>
          <target state="translated">Node.js는 &lt;code&gt;SIGINT&lt;/code&gt; 및 &lt;code&gt;SIGTERM&lt;/code&gt; 에 대한 신호 처리기를 설정 하며 Node.js 프로세스는 이러한 신호를 수신하여 즉시 종료되지 않습니다. 오히려 Node.js는 일련의 정리 작업을 수행 한 다음 처리 된 신호를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="480b0d2dbef58c37d829b9c32965e5cf57f7057b" translate="yes" xml:space="preserve">
          <source>Node.js fully supports ECMAScript modules as they are currently specified and provides interoperability between them and its original module format, &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt;.</source>
          <target state="translated">Node.js는 현재 지정되어있는 ECMAScript 모듈을 완벽하게 지원하며 원래 모듈 형식 인 &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt; 와 상호 운용성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b03b3b5fea382e76a7a57c11964832d9a8b669da" translate="yes" xml:space="preserve">
          <source>Node.js fully supports ECMAScript modules as they are currently specified and provides limited interoperability between them and the existing module format, &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt;.</source>
          <target state="translated">Node.js는 현재 지정되어있는 ECMAScript 모듈을 완벽하게 지원하며 모듈과 기존 모듈 형식 인 &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt; 간의 제한된 상호 운용성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d9420a48ed10cc5802fa3b78bba7653131bf1a8e" translate="yes" xml:space="preserve">
          <source>Node.js generates system errors when exceptions occur within its runtime environment. These usually occur when an application violates an operating system constraint. For example, a system error will occur if an application attempts to read a file that does not exist.</source>
          <target state="translated">런타임 환경에서 예외가 발생하면 Node.js가 시스템 오류를 생성합니다. 일반적으로 응용 프로그램이 운영 체제 제약 조건을 위반할 때 발생합니다. 예를 들어, 응용 프로그램이 존재하지 않는 파일을 읽으려고하면 시스템 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="48de8cfe95796276bf63a2c8ab0ecbb060e9f9cf" translate="yes" xml:space="preserve">
          <source>Node.js has a concept of a &amp;ldquo;Node.js instance&amp;rdquo;, that is commonly being referred to as &lt;code&gt;node::Environment&lt;/code&gt;. Each &lt;code&gt;node::Environment&lt;/code&gt; is associated with:</source>
          <target state="translated">Node.js에는 일반적으로 &lt;code&gt;node::Environment&lt;/code&gt; 라고하는 &quot;Node.js 인스턴스&quot;개념이 있습니다. 각 &lt;code&gt;node::Environment&lt;/code&gt; 는 다음과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="d0cd156f333656194d6d4ee97e4372a26119bd21" translate="yes" xml:space="preserve">
          <source>Node.js has many features that make it easier to write internationalized programs. Some of them are:</source>
          <target state="translated">Node.js에는 국제화 된 프로그램을보다 쉽게 ​​작성할 수있는 많은 기능이 있습니다. 그들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195eccef86c70efe3ada3da5e4f20eea967db8b4" translate="yes" xml:space="preserve">
          <source>Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation.</source>
          <target state="translated">Node.js에는 바이너리로 컴파일 된 여러 모듈이 있습니다. 이 모듈들은이 문서의 다른 곳에서 더 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d67c8f1728279b2419e85378220842f097aa2a" translate="yes" xml:space="preserve">
          <source>Node.js includes a number of other statically linked libraries including OpenSSL. These other libraries are located in the &lt;code&gt;deps/&lt;/code&gt; directory in the Node.js source tree. Only the libuv, OpenSSL, V8 and zlib symbols are purposefully re-exported by Node.js and may be used to various extents by Addons. See &lt;a href=&quot;#addons_linking_to_node_js_own_dependencies&quot;&gt;Linking to Node.js' own dependencies&lt;/a&gt; for additional information.</source>
          <target state="translated">Node.js에는 OpenSSL을 비롯한 여러 정적으로 링크 된 라이브러리가 포함되어 있습니다. 이러한 다른 라이브러리는 Node.js 소스 트리 의 &lt;code&gt;deps/&lt;/code&gt; 디렉토리에 있습니다. libuv, OpenSSL, V8 및 zlib 기호 만 Node.js에 의해 의도적으로 다시 내보내지고 애드온에 의해 다양한 범위로 사용될 수 있습니다. 추가 정보는 &lt;a href=&quot;#addons_linking_to_node_js_own_dependencies&quot;&gt;Node.js 자체 종속성&lt;/a&gt; 에 링크를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4002058c11230c8c613d48125799d611e8e5ab90" translate="yes" xml:space="preserve">
          <source>Node.js includes an out-of-process debugging utility accessible via a &lt;a href=&quot;#debugger_v8_inspector_integration_for_node_js&quot;&gt;V8 Inspector&lt;/a&gt; and built-in debugging client. To use it, start Node.js with the &lt;code&gt;inspect&lt;/code&gt; argument followed by the path to the script to debug; a prompt will be displayed indicating successful launch of the debugger:</source>
          <target state="translated">Node.js에는 &lt;a href=&quot;#debugger_v8_inspector_integration_for_node_js&quot;&gt;V8 인스펙터&lt;/a&gt; 및 내장 디버깅 클라이언트 를 통해 액세스 할 수있는 프로세스 외부 디버깅 유틸리티가 포함되어 있습니다 . 이를 사용하려면, &lt;code&gt;inspect&lt;/code&gt; 인수 와 함께 디버깅 할 스크립트 경로로 Node.js를 시작하십시오 . 디버거가 성공적으로 시작되었음을 알리는 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="115f8d8c85f155299923066b8cd8afdf7cb6c984" translate="yes" xml:space="preserve">
          <source>Node.js includes other statically linked libraries including OpenSSL. These other libraries are located in the &lt;code&gt;deps/&lt;/code&gt; directory in the Node.js source tree. Only the libuv, OpenSSL, V8 and zlib symbols are purposefully re-exported by Node.js and may be used to various extents by addons. See &lt;a href=&quot;#addons_linking_to_libraries_included_with_node_js&quot;&gt;Linking to libraries included with Node.js&lt;/a&gt; for additional information.</source>
          <target state="translated">Node.js에는 OpenSSL을 포함한 기타 정적으로 링크 된 라이브러리가 포함되어 있습니다. 이러한 다른 라이브러리는 Node.js 소스 트리 의 &lt;code&gt;deps/&lt;/code&gt; 디렉토리에 있습니다. libuv, OpenSSL, V8 및 zlib 기호 만 Node.js에서 의도적으로 다시 내보내고 애드온을 통해 다양한 범위로 사용할 수 있습니다. 추가 정보 &lt;a href=&quot;#addons_linking_to_libraries_included_with_node_js&quot;&gt;는 Node.js&lt;/a&gt; 에 포함 된 라이브러리에 링크를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f9aede62d41177b7855358a4024583daeb12072" translate="yes" xml:space="preserve">
          <source>Node.js inspector supports all the Chrome DevTools Protocol domains declared by V8. Chrome DevTools Protocol domain provides an interface for interacting with one of the runtime agents used to inspect the application state and listen to the run-time events.</source>
          <target state="translated">Node.js 인스펙터는 V8에서 선언 한 모든 Chrome DevTools 프로토콜 도메인을 지원합니다. Chrome DevTools 프로토콜 도메인은 애플리케이션 상태를 검사하고 런타임 이벤트를 청취하는 데 사용되는 런타임 에이전트 중 하나와 상호 작용하기위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9b8c531580042ddb6a9c8b040b19ffbdbcdd1525" translate="yes" xml:space="preserve">
          <source>Node.js is a trademark of Joyent, Inc. and is used with its permission.</source>
          <target state="translated">Node.js는 Joyent, Inc.의 상표이며 허가를 받아 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f38a0ebf21cebf178508d7332d871c116478b9e4" translate="yes" xml:space="preserve">
          <source>Node.js is built with a default suite of enabled and disabled TLS ciphers. Currently, the default cipher suite is:</source>
          <target state="translated">Node.js는 활성화 및 비활성화 된 TLS 암호의 기본 제품군으로 빌드됩니다. 현재 기본 암호 제품군은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8aee71eb10933a7749912dfe5f90adbda7e60cec" translate="yes" xml:space="preserve">
          <source>Node.js is built with a default suite of enabled and disabled TLS ciphers. This default cipher list can be configured when building Node.js to allow distributions to provide their own default list.</source>
          <target state="translated">Node.js는 활성화 및 비활성화 된 TLS 암호의 기본 제품군으로 빌드됩니다. 이 기본 암호 목록은 배포판이 자체 기본 목록을 제공 할 수 있도록 Node.js를 빌드 할 때 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d419b29bddd025ae8da2d1cd92469cb932388b2a" translate="yes" xml:space="preserve">
          <source>Node.js itself uses the &lt;code&gt;repl&lt;/code&gt; module to provide its own interactive interface for executing JavaScript. This can be used by executing the Node.js binary without passing any arguments (or by passing the &lt;code&gt;-i&lt;/code&gt; argument):</source>
          <target state="translated">Node.js 자체는 &lt;code&gt;repl&lt;/code&gt; 모듈을 사용하여 JavaScript 실행을위한 자체 대화식 인터페이스를 제공합니다. 인수를 전달하지 않고 Node.js 바이너리를 실행하거나 &lt;code&gt;-i&lt;/code&gt; 인수 를 전달하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f09bc63e6e483ddf848817dae917ca441f8c70d6" translate="yes" xml:space="preserve">
          <source>Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests.</source>
          <target state="translated">Node.js는 서버 당 여러 개의 연결을 유지하여 HTTP 요청을합니다. 이 기능을 사용하면 요청을 투명하게 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef83fb721ff96281b3ffd2a1bcbc9e428f3194ea" translate="yes" xml:space="preserve">
          <source>Node.js makes no guarantees about the atomicity of the copy operation. If an error occurs after the destination file has been opened for writing, Node.js will attempt to remove the destination.</source>
          <target state="translated">Node.js는 복사 작업의 원 자성을 보증하지 않습니다. 대상 파일을 쓰기 위해 연 후 오류가 발생하면 Node.js가 대상 제거를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5a2313c41832d43d1e319cb20bebf01ebb24487d" translate="yes" xml:space="preserve">
          <source>Node.js may deprecate APIs for any of the following reasons:</source>
          <target state="translated">Node.js는 다음과 같은 이유로 API를 더 이상 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6a49596101ad1c6c0a10180ddfbbd5d2267fc0" translate="yes" xml:space="preserve">
          <source>Node.js options that are allowed are:</source>
          <target state="translated">허용되는 Node.js 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="138fea06dce092e1d24f06c81c94c22277dd9c70" translate="yes" xml:space="preserve">
          <source>Node.js processes launched with a custom &lt;code&gt;execPath&lt;/code&gt; will communicate with the parent process using the file descriptor (fd) identified using the environment variable &lt;code&gt;NODE_CHANNEL_FD&lt;/code&gt; on the child process.</source>
          <target state="translated">사용자 정의 &lt;code&gt;execPath&lt;/code&gt; 로 시작된 Node.js 프로세스는 하위 프로세스에서 환경 변수 &lt;code&gt;NODE_CHANNEL_FD&lt;/code&gt; 를 사용하여 식별 된 파일 디스크립터 (fd)를 사용하여 상위 프로세스와 통신 합니다.</target>
        </trans-unit>
        <trans-unit id="888226cda32c651713a9bdcd3c9daa6164c10743" translate="yes" xml:space="preserve">
          <source>Node.js provides a number of C++ APIs that can be used to execute JavaScript in a Node.js environment from other C++ software.</source>
          <target state="translated">Node.js는 다른 C ++ 소프트웨어의 Node.js 환경에서 JavaScript를 실행하는 데 사용할 수있는 다양한 C ++ API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44a315000fe0caec361396db2ab80cb8bd4201d2" translate="yes" xml:space="preserve">
          <source>Node.js provides an implementation of the standard &lt;a href=&quot;https://www.w3.org/TR/WebCryptoAPI/&quot;&gt;Web Crypto API&lt;/a&gt;.</source>
          <target state="translated">Node.js는 표준 &lt;a href=&quot;https://www.w3.org/TR/WebCryptoAPI/&quot;&gt;웹 암호화 API&lt;/a&gt; 의 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="af889ac9a25421872e32a7b13c8dc159bbe14926" translate="yes" xml:space="preserve">
          <source>Node.js requires some per-process state management in order to run:</source>
          <target state="translated">Node.js를 실행하려면 몇 가지 프로세스 별 상태 관리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5196287aca961808313ef47efa5a6a6078aaae9f" translate="yes" xml:space="preserve">
          <source>Node.js supports several mechanisms for propagating and handling errors that occur while an application is running. How these errors are reported and handled depends entirely on the type of &lt;code&gt;Error&lt;/code&gt; and the style of the API that is called.</source>
          <target state="translated">Node.js는 애플리케이션이 실행되는 동안 발생하는 오류를 전파하고 처리하기위한 여러 메커니즘을 지원합니다. 이러한 오류가보고되고 처리되는 방법은 전적으로 &lt;code&gt;Error&lt;/code&gt; 유형 과 호출 된 API 스타일에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e3de5308a70d674ab3ba84ce75599d95c724d3f0" translate="yes" xml:space="preserve">
          <source>Node.js supports the following &lt;a href=&quot;https://w3c.github.io/perf-timing-primer/&quot;&gt;Web Performance APIs&lt;/a&gt;:</source>
          <target state="translated">Node.js는 다음 &lt;a href=&quot;https://w3c.github.io/perf-timing-primer/&quot;&gt;웹 성능 API를&lt;/a&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="1307f3ab8da5b477eb2214e7f2dae4a93417b84a" translate="yes" xml:space="preserve">
          <source>Node.js supports the following conditions out of the box:</source>
          <target state="translated">Node.js는 기본적으로 다음 조건을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="73a27c18aed9d2957a1195a5def9fedbfaabd920" translate="yes" xml:space="preserve">
          <source>Node.js treats JavaScript code as CommonJS modules by default. Authors can tell Node.js to treat JavaScript code as ECMAScript modules via the &lt;code&gt;.mjs&lt;/code&gt; file extension, the &lt;code&gt;package.json&lt;/code&gt;&lt;a href=&quot;packages#packages_type&quot;&gt;&lt;code&gt;&quot;type&quot;&lt;/code&gt;&lt;/a&gt; field, or the &lt;code&gt;--input-type&lt;/code&gt; flag. See &lt;a href=&quot;packages#packages_determining_module_system&quot;&gt;Modules: Packages&lt;/a&gt; for more details.</source>
          <target state="translated">Node.js는 기본적으로 JavaScript 코드를 CommonJS 모듈로 취급합니다. 작성자는 Node.js에게 &lt;code&gt;.mjs&lt;/code&gt; 파일 확장자, &lt;code&gt;package.json&lt;/code&gt; &lt;a href=&quot;packages#packages_type&quot;&gt; &lt;code&gt;&quot;type&quot;&lt;/code&gt; &lt;/a&gt; 필드 또는 &lt;code&gt;--input-type&lt;/code&gt; 플래그 를 통해 JavaScript 코드를 ECMAScript 모듈로 처리하도록 지시 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;packages#packages_determining_module_system&quot;&gt;모듈 : 패키지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02f6a2adac24b09ba48add96ffd834e0b65b5a81" translate="yes" xml:space="preserve">
          <source>Node.js used to support all GCM authentication tag lengths which are accepted by OpenSSL when calling &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer&quot;&gt;&lt;code&gt;decipher.setAuthTag()&lt;/code&gt;&lt;/a&gt;. Beginning with Node.js v11.0.0, only authentication tag lengths of 128, 120, 112, 104, 96, 64, and 32 bits are allowed. Authentication tags of other lengths are invalid per &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D&lt;/a&gt;.</source>
          <target state="translated">Node.js는 &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer&quot;&gt; &lt;code&gt;decipher.setAuthTag()&lt;/code&gt; &lt;/a&gt; 호출 할 때 OpenSSL에서 허용하는 모든 GCM 인증 태그 길이를 지원하는 데 사용되었습니다 . Node.js v11.0.0부터는 128, 120, 112, 104, 96, 64 및 32 비트의 인증 태그 길이 만 허용됩니다. 다른 길이의 인증 태그는 &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D에&lt;/a&gt; 따라 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fa1e0e5f6b06e5108f789c2f13a6fbb3b3730be3" translate="yes" xml:space="preserve">
          <source>Node.js used to support all GCM authentication tag lengths which are accepted by OpenSSL when calling &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer_encoding&quot;&gt;&lt;code&gt;decipher.setAuthTag()&lt;/code&gt;&lt;/a&gt;. Beginning with Node.js v11.0.0, only authentication tag lengths of 128, 120, 112, 104, 96, 64, and 32 bits are allowed. Authentication tags of other lengths are invalid per &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D&lt;/a&gt;.</source>
          <target state="translated">Node.js는 &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer_encoding&quot;&gt; &lt;code&gt;decipher.setAuthTag()&lt;/code&gt; &lt;/a&gt; 호출시 OpenSSL에서 허용하는 모든 GCM 인증 태그 길이를 지원하는 데 사용됩니다 . Node.js v11.0.0부터 128, 120, 112, 104, 96, 64 및 32 비트의 인증 태그 길이 만 허용됩니다. 다른 길이의 인증 태그는 &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D에&lt;/a&gt; 따라 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2f9b6124a3880fa2afa106c7ef712fc837b2b911" translate="yes" xml:space="preserve">
          <source>Node.js uses a &lt;code&gt;KeyObject&lt;/code&gt; class to represent a symmetric or asymmetric key, and each kind of key exposes different functions. The &lt;a href=&quot;#crypto_crypto_createsecretkey_key&quot;&gt;&lt;code&gt;crypto.createSecretKey()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt; methods are used to create &lt;code&gt;KeyObject&lt;/code&gt; instances. &lt;code&gt;KeyObject&lt;/code&gt; objects are not to be created directly using the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">Node.js는 &lt;code&gt;KeyObject&lt;/code&gt; 클래스를 사용하여 대칭 또는 비대칭 키를 나타내며 각 키 종류는 서로 다른 기능을 제공합니다. &lt;a href=&quot;#crypto_crypto_createsecretkey_key&quot;&gt; &lt;code&gt;crypto.createSecretKey()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 메소드를 만드는 데 사용되는 &lt;code&gt;KeyObject&lt;/code&gt; 의 인스턴스. &lt;code&gt;new&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;KeyObject&lt;/code&gt; 객체를 직접 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1492c443d129898740d894768c679a1ad73f43a5" translate="yes" xml:space="preserve">
          <source>Node.js uses a &lt;code&gt;KeyObject&lt;/code&gt; class to represent a symmetric or asymmetric key, and each kind of key exposes different functions. The &lt;a href=&quot;#crypto_crypto_createsecretkey_key_encoding&quot;&gt;&lt;code&gt;crypto.createSecretKey()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt; methods are used to create &lt;code&gt;KeyObject&lt;/code&gt; instances. &lt;code&gt;KeyObject&lt;/code&gt; objects are not to be created directly using the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">Node.js는 &lt;code&gt;KeyObject&lt;/code&gt; 클래스를 사용하여 대칭 또는 비대칭 키를 나타내며 각 종류의 키는 서로 다른 기능을 노출합니다. &lt;a href=&quot;#crypto_crypto_createsecretkey_key_encoding&quot;&gt; &lt;code&gt;crypto.createSecretKey()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 메소드를 만드는 데 사용되는 &lt;code&gt;KeyObject&lt;/code&gt; 의 인스턴스. &lt;code&gt;KeyObject&lt;/code&gt; 개체는 &lt;code&gt;new&lt;/code&gt; 키워드를 사용하여 직접 만들지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38c8c1daba3fd0b1fc631a3c4423fc53da9f7c2d" translate="yes" xml:space="preserve">
          <source>Node.js uses a number of statically linked libraries such as V8, libuv and OpenSSL. All Addons are required to link to V8 and may link to any of the other dependencies as well. Typically, this is as simple as including the appropriate &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; statements (e.g. &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt;) and &lt;code&gt;node-gyp&lt;/code&gt; will locate the appropriate headers automatically. However, there are a few caveats to be aware of:</source>
          <target state="translated">Node.js는 V8, libuv 및 OpenSSL과 같은 여러 정적으로 링크 된 라이브러리를 사용합니다. 모든 애드온은 V8에 연결해야하며 다른 종속 항목에도 연결될 수 있습니다. 일반적으로 이것은 적절한 &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; 문 (예 : &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt; ) 을 포함하는 것만 큼 간단 하며 &lt;code&gt;node-gyp&lt;/code&gt; 은 적절한 헤더를 자동으로 찾습니다. 그러나 알아야 할 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fe961c6b46fc16a4675791acb6d47102a8c09d" translate="yes" xml:space="preserve">
          <source>Node.js uses statically linked libraries such as V8, libuv and OpenSSL. All addons are required to link to V8 and may link to any of the other dependencies as well. Typically, this is as simple as including the appropriate &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; statements (e.g. &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt;) and &lt;code&gt;node-gyp&lt;/code&gt; will locate the appropriate headers automatically. However, there are a few caveats to be aware of:</source>
          <target state="translated">Node.js는 V8, libuv 및 OpenSSL과 같은 정적으로 연결된 라이브러리를 사용합니다. 모든 애드온은 V8에 연결해야하며 다른 종속성에도 연결할 수 있습니다. 일반적으로 이는 적절한 &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; 문 (예 : &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt; ) 을 포함하는 것만 큼 간단 하며 &lt;code&gt;node-gyp&lt;/code&gt; 은 적절한 헤더를 자동으로 찾습니다. 그러나 다음과 같은 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62610ad899b4964920eb4169835a333ede0d47ce" translate="yes" xml:space="preserve">
          <source>Node.js uses three kinds of Deprecations:</source>
          <target state="translated">Node.js는 세 가지 유형의 지원 중단을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3cc44a7efe4f28833703418200a1bb5df5098eb3" translate="yes" xml:space="preserve">
          <source>Node.js utilizes three kinds of Deprecations:</source>
          <target state="translated">Node.js는 세 종류의 지원 중단을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a46a838b1cdedce2bf909aec9c2762a50a63df17" translate="yes" xml:space="preserve">
          <source>Node.js was compiled without &lt;code&gt;scrypt&lt;/code&gt; support. Not possible with the official release binaries but can happen with custom builds, including distro builds.</source>
          <target state="translated">Node.js는 &lt;code&gt;scrypt&lt;/code&gt; 지원 없이 컴파일되었습니다 . 공식 릴리스 바이너리로는 가능하지 않지만 배포 빌드를 포함하여 사용자 정의 빌드에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2be6c44f29011482418546ee57fd088cf4e02101" translate="yes" xml:space="preserve">
          <source>Node.js was unable to watch for the &lt;code&gt;SIGINT&lt;/code&gt; signal.</source>
          <target state="translated">Node.js가 &lt;code&gt;SIGINT&lt;/code&gt; 신호 를 감시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7aaa445f322cc3682bfe7bf5c6b4e24edfb5f0d7" translate="yes" xml:space="preserve">
          <source>Node.js will generate and throw &lt;code&gt;RangeError&lt;/code&gt; instances &lt;em&gt;immediately&lt;/em&gt; as a form of argument validation.</source>
          <target state="translated">Node.js는 &lt;code&gt;RangeError&lt;/code&gt; 인스턴스 를 인수 유효성 검사의 형태로 &lt;em&gt;즉시&lt;/em&gt; 생성하고 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="8a136533538960fd36c0a7d5584874bcb8bdd70d" translate="yes" xml:space="preserve">
          <source>Node.js will generate and throw &lt;code&gt;TypeError&lt;/code&gt; instances &lt;em&gt;immediately&lt;/em&gt; as a form of argument validation.</source>
          <target state="translated">Node.js는 인수 유효성 검사의 형태로 &lt;em&gt;즉시 &lt;/em&gt; &lt;code&gt;TypeError&lt;/code&gt; 인스턴스를 생성하고 throw 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86b0b7269fa723a49aa2197764257f8d6198ae0b" translate="yes" xml:space="preserve">
          <source>Node.js will normally exit with a &lt;code&gt;0&lt;/code&gt; status code when no more async operations are pending. The following status codes are used in other cases:</source>
          <target state="translated">더 이상 비동기 작업이 보류되지 않으면 Node.js는 일반적으로 &lt;code&gt;0&lt;/code&gt; 상태 코드로 종료됩니다 . 다른 경우에는 다음 상태 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="155db0c5b4c4ce480a51da327fc9bc6915920c76" translate="yes" xml:space="preserve">
          <source>Node.js will treat as &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt; all other forms of input, such as &lt;code&gt;.js&lt;/code&gt; files where the nearest parent &lt;code&gt;package.json&lt;/code&gt; file contains no top-level &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or string input without the flag &lt;code&gt;--input-type&lt;/code&gt;. This behavior is to preserve backward compatibility. However, now that Node.js supports both CommonJS and ES modules, it is best to be explicit whenever possible. Node.js will treat the following as CommonJS when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">Node.js는 가장 가까운 상위 &lt;code&gt;package.json&lt;/code&gt; 파일에 최상위 수준 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드 가없는 &lt;code&gt;.js&lt;/code&gt; 파일 또는 &lt;code&gt;--input-type&lt;/code&gt; 플래그가없는 문자열 입력 과 같은 다른 모든 형식의 입력 을 &lt;a href=&quot;modules&quot;&gt;CommonJS로&lt;/a&gt; 처리 합니다 . 이 동작은 이전 버전과의 호환성을 유지하기위한 것입니다. 그러나 이제 Node.js는 CommonJS 및 ES 모듈을 모두 지원하므로 가능할 때마다 명시하는 것이 가장 좋습니다. Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 CommonJS로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="6d156462ec2e4a54246399867711ae97a6c34c54" translate="yes" xml:space="preserve">
          <source>Node.js will treat as CommonJS all other forms of input, such as &lt;code&gt;.js&lt;/code&gt; files where the nearest parent &lt;code&gt;package.json&lt;/code&gt; file contains no top-level &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or string input without the flag &lt;code&gt;--input-type&lt;/code&gt;. This behavior is to preserve backward compatibility. However, now that Node.js supports both CommonJS and ES modules, it is best to be explicit whenever possible. Node.js will treat the following as CommonJS when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">Node.js는 가장 가까운 상위 &lt;code&gt;package.json&lt;/code&gt; 파일에 최상위 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드가 없거나 &lt;code&gt;--input-type&lt;/code&gt; 플래그가없는 문자열 입력이있는 &lt;code&gt;.js&lt;/code&gt; 파일 과 같은 다른 모든 유형의 입력을 CommonJS로 취급 합니다 . 이 동작은 이전 버전과의 호환성을 유지하기위한 것입니다. 그러나 Node.js는 CommonJS 및 ES 모듈을 모두 지원하므로 가능할 때마다 명시하는 것이 가장 좋습니다. Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 CommonJS로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="147e38b7dc6f7e7f835ab0bcf608d595e57a6d0d" translate="yes" xml:space="preserve">
          <source>Node.js will treat the following as &lt;a href=&quot;esm&quot;&gt;ES modules&lt;/a&gt; when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 &lt;a href=&quot;esm&quot;&gt;ES 모듈&lt;/a&gt; 로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="2745ff23353f08077c9763af60cfd72843015ebb" translate="yes" xml:space="preserve">
          <source>Node.js's debugger client is not a full-featured debugger, but simple step and inspection are possible.</source>
          <target state="translated">Node.js의 디버거 클라이언트는 모든 기능을 갖춘 디버거는 아니지만 간단한 단계 및 검사가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="60873216d1e300530ea8a2768f6ff649a8955203" translate="yes" xml:space="preserve">
          <source>Node.js-specific alias for &lt;code&gt;eventTarget.addListener()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eventTarget.addListener()&lt;/code&gt; 대한 Node.js 특정 별칭 .</target>
        </trans-unit>
        <trans-unit id="6509b24d38783cbfefe9a3a56034e3ca2386c75d" translate="yes" xml:space="preserve">
          <source>Node.js-specific alias for &lt;code&gt;eventTarget.removeListener()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eventTarget.removeListener()&lt;/code&gt; 대한 Node.js 특정 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="79171832c8c5742998fb3ce715335c31c87f30d9" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class that adds a &lt;code&gt;once&lt;/code&gt; listener for the given event &lt;code&gt;type&lt;/code&gt;. This is equivalent to calling &lt;code&gt;on&lt;/code&gt; with the &lt;code&gt;once&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주어진 이벤트 &lt;code&gt;type&lt;/code&gt; 대해 &lt;code&gt;once&lt;/code&gt; 리스너를 추가하는 &lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 관련 확장 입니다. 이것은 호출하는 것과 같습니다 &lt;code&gt;on&lt;/code&gt; 로 &lt;code&gt;once&lt;/code&gt; 에 옵션을 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45bffbe24e10e4a97eddbf0c7c114da59faf30ad" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class that emulates the equivalent &lt;code&gt;EventEmitter&lt;/code&gt; API. The only difference between &lt;code&gt;addListener()&lt;/code&gt; and &lt;code&gt;addEventListener()&lt;/code&gt; is that &lt;code&gt;addListener()&lt;/code&gt; will return a reference to the &lt;code&gt;EventTarget&lt;/code&gt;.</source>
          <target state="translated">동등한 &lt;code&gt;EventEmitter&lt;/code&gt; API 를 에뮬레이트하는 &lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 특정 확장 입니다. 유일한 차이 &lt;code&gt;addListener()&lt;/code&gt; 및 &lt;code&gt;addEventListener()&lt;/code&gt; 점이다 &lt;code&gt;addListener()&lt;/code&gt; 받는 기준 반환 &lt;code&gt;EventTarget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e64e97ca9a09285a7f734c2f63dbff7417bcebb7" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class that removes the &lt;code&gt;listener&lt;/code&gt; for the given &lt;code&gt;type&lt;/code&gt;. The only difference between &lt;code&gt;removeListener()&lt;/code&gt; and &lt;code&gt;removeEventListener()&lt;/code&gt; is that &lt;code&gt;removeListener()&lt;/code&gt; will return a reference to the &lt;code&gt;EventTarget&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;type&lt;/code&gt; 대한 &lt;code&gt;listener&lt;/code&gt; 를 제거하는 &lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 특정 확장 입니다. 유일한 차이 &lt;code&gt;removeListener()&lt;/code&gt; 및 &lt;code&gt;removeEventListener()&lt;/code&gt; 점이다 &lt;code&gt;removeListener()&lt;/code&gt; 받는 기준 반환 &lt;code&gt;EventTarget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58a3b624b039863a7cfaf372fa5f8e8793d5ecaf" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class that returns an array of event &lt;code&gt;type&lt;/code&gt; names for which event listeners are registered.</source>
          <target state="translated">이벤트 리스너가 등록 된 이벤트 &lt;code&gt;type&lt;/code&gt; 이름 의 배열을 반환하는 &lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 관련 확장 입니다.</target>
        </trans-unit>
        <trans-unit id="982b7a762cfbd11198763ac7b4757540c86749e9" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class that returns the number of event listeners registered for the &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 대해 등록 된 이벤트 리스너 수를 반환 하는 &lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 관련 확장 입니다.</target>
        </trans-unit>
        <trans-unit id="057ce1bfc2fde706a1ff2a67329d6b4077df18fa" translate="yes" xml:space="preserve">
          <source>Node.js-specific extension to the &lt;code&gt;EventTarget&lt;/code&gt; class. If &lt;code&gt;type&lt;/code&gt; is specified, removes all registered listeners for &lt;code&gt;type&lt;/code&gt;, otherwise removes all registered listeners.</source>
          <target state="translated">&lt;code&gt;EventTarget&lt;/code&gt; 클래스 에 대한 Node.js 관련 확장 입니다. 경우 &lt;code&gt;type&lt;/code&gt; 지정된 경우에 등록 된 모든 리스너 제거 &lt;code&gt;type&lt;/code&gt; 달리 등록 된 모든 리스너를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a937ec6245c951225fcd0ec58796759da4816865" translate="yes" xml:space="preserve">
          <source>Node.js-specific extensions</source>
          <target state="translated">Node.js 관련 확장</target>
        </trans-unit>
        <trans-unit id="7c0906e04d49a9c95bcb1edada2bb82cc8a7ad4c" translate="yes" xml:space="preserve">
          <source>Node.js-speciic alias for &lt;code&gt;eventTarget.removeListener()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eventTarget.removeListener()&lt;/code&gt; 대한 Node.js 특정 별칭 .</target>
        </trans-unit>
        <trans-unit id="ac1013f374841b5452514d4b8359e7422406574b" translate="yes" xml:space="preserve">
          <source>Non-finite number values (&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;+Infinity&lt;/code&gt;, or &lt;code&gt;-Infinity&lt;/code&gt;) set the result to zero.</source>
          <target state="translated">무한 수가 아닌 값 ( &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+Infinity&lt;/code&gt; 또는 &lt;code&gt;-Infinity&lt;/code&gt; )은 결과를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7d5e643747b3ffedc83ffcb3b71cbc3c5585ca03" translate="yes" xml:space="preserve">
          <source>Not all constants will be available on every operating system.</source>
          <target state="translated">모든 운영 체제에서 모든 상수를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="67c4d0506a441a717b8988584c29925382c7326c" translate="yes" xml:space="preserve">
          <source>Not applicable</source>
          <target state="translated">해당 없음</target>
        </trans-unit>
        <trans-unit id="4436debc55754f82e9d430eaa05339b900fd927e" translate="yes" xml:space="preserve">
          <source>Not every constant will be available on every operating system.</source>
          <target state="translated">모든 운영 체제에서 모든 상수를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="549ab44d98603b37017112009e5442a545e8a373" translate="yes" xml:space="preserve">
          <source>Not exported by the &lt;code&gt;zlib&lt;/code&gt; module. It is documented here because it is the base class of the compressor/decompressor classes.</source>
          <target state="translated">&lt;code&gt;zlib&lt;/code&gt; 모듈에서 내 보내지 않았습니다 . 컴프레서 / 디 컴프레서 클래스의 기본 클래스이므로 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf19ed98b0dffdc4b322b922e2a0a394c9f67eab" translate="yes" xml:space="preserve">
          <source>Not handling &lt;code&gt;Promise&lt;/code&gt; rejections is deprecated.</source>
          <target state="translated">처리하지 않음 &lt;code&gt;Promise&lt;/code&gt; 거부는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0b39022c2215221063a53f78441f94d3dba109d" translate="yes" xml:space="preserve">
          <source>Not including an integrity is the same as setting the integrity to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">무결성을 포함하지 않는 것은 무결성을 &lt;code&gt;null&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0f471ec3f86ad87114b1805cf0ff78e30f33eee3" translate="yes" xml:space="preserve">
          <source>Not listening to this event no longer causes the socket to be destroyed if a client sends an Upgrade header.</source>
          <target state="translated">이 이벤트를 수신하지 않으면 클라이언트가 Upgrade 헤더를 보내도 더 이상 소켓이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d73f792bf4588a09b4c61304ecd28cf0baf02107" translate="yes" xml:space="preserve">
          <source>Notable differences inside a Worker environment are:</source>
          <target state="translated">작업자 환경 내에서 주목할만한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="116bc38e0fa5e5ee07a1a94f2fa6f1bd37a22e34" translate="yes" xml:space="preserve">
          <source>Note about UDP datagram size</source>
          <target state="translated">UDP 데이터 그램 크기에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="580765b00e88c3ab1fc90c8c0303dbfa89b6d16c" translate="yes" xml:space="preserve">
          <source>Note it is &lt;em&gt;not&lt;/em&gt; necessary to use &lt;code&gt;napi_make_callback&lt;/code&gt; from within a &lt;code&gt;napi_async_complete_callback&lt;/code&gt;; in that situation the callback's async context has already been set up, so a direct call to &lt;code&gt;napi_call_function&lt;/code&gt; is sufficient and appropriate. Use of the &lt;code&gt;napi_make_callback&lt;/code&gt; function may be required when implementing custom async behavior that does not use &lt;code&gt;napi_create_async_work&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;napi_make_callback&lt;/code&gt; 내에서 &lt;code&gt;napi_async_complete_callback&lt;/code&gt; 을 사용할 필요 는 &lt;em&gt;없습니다&lt;/em&gt; . 이 상황에서 콜백의 비동기 컨텍스트가 이미 설정 &lt;code&gt;napi_call_function&lt;/code&gt; 대한 직접 호출 이면 충분합니다. 의 사용 &lt;code&gt;napi_make_callback&lt;/code&gt; 의 사용하지 않는 사용자 정의 비동기 동작을 구현할 때 함수가 필요할 수 있습니다 &lt;code&gt;napi_create_async_work&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a541315c3564892fb6389e50b5bf3c97adc29a5f" translate="yes" xml:space="preserve">
          <source>Note on &lt;code&gt;:authority&lt;/code&gt; and &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">참고 사항 &lt;code&gt;:authority&lt;/code&gt; 및 &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2819ecc02995f7a6240325d276ffeabbdeecff8" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;blob:&lt;/code&gt; URLs adopt their origin from the path they contain, and so a scope of &lt;code&gt;&quot;blob:https://nodejs.org&quot;&lt;/code&gt; will have no effect since no URL can have an origin of &lt;code&gt;blob:https://nodejs.org&lt;/code&gt;; URLs starting with &lt;code&gt;blob:https://nodejs.org/&lt;/code&gt; will use &lt;code&gt;https://nodejs.org&lt;/code&gt; for its origin and thus &lt;code&gt;https:&lt;/code&gt; for its protocol scope. For opaque origin &lt;code&gt;blob:&lt;/code&gt; URLs they will have &lt;code&gt;blob:&lt;/code&gt; for their protocol scope since they do not adopt origins.</source>
          <target state="translated">참고, &lt;code&gt;blob:&lt;/code&gt; 의 범위 있도록 URL을 여기에 포함 된 경로에서 자신의 기원을 채택하고 &lt;code&gt;&quot;blob:https://nodejs.org&quot;&lt;/code&gt; 효과가 없습니다 어떤 URL이의 기원 가질 수 있기 때문에 &lt;code&gt;blob:https://nodejs.org&lt;/code&gt; ; &lt;code&gt;blob:https://nodejs.org/&lt;/code&gt; 로 시작하는 URL 은 출처로 &lt;code&gt;https://nodejs.org&lt;/code&gt; 를 사용 하고 프로토콜 범위로 &lt;code&gt;https:&lt;/code&gt; 를 사용합니다. 불투명 한 원본 &lt;code&gt;blob:&lt;/code&gt; URL의 경우 원본을 채택하지 않기 때문에 프로토콜 범위에 대해 &lt;code&gt;blob:&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e41c1622948c03f6ca8311eb8aef26b223ccf0" translate="yes" xml:space="preserve">
          <source>Note, however, that using &lt;code&gt;--preserve-symlinks&lt;/code&gt; can have other side effects. Specifically, symbolically linked &lt;em&gt;native&lt;/em&gt; modules can fail to load if those are linked from more than one location in the dependency tree (Node.js would see those as two separate modules and would attempt to load the module multiple times, causing an exception to be thrown).</source>
          <target state="translated">그러나 &lt;code&gt;--preserve-symlinks&lt;/code&gt; 를 사용하면 다른 부작용이있을 수 있습니다. 특히 심볼 트리로 연결된 &lt;em&gt;네이티브&lt;/em&gt; 모듈이 종속성 트리에서 둘 이상의 위치에서 링크 된 경우로드하지 못할 수 있습니다 (Node.js는 해당 모듈을 두 개의 개별 모듈로보고 모듈을 여러 번로드하려고 시도하여 예외가 발생 함) ).</target>
        </trans-unit>
        <trans-unit id="972cb08f7fa7ede61014198194e4bb40a809cbac" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;getSession()&lt;/code&gt; works only for TLSv1.2 and below. For TLSv1.3, applications must use the &lt;a href=&quot;#tls_event_session&quot;&gt;&lt;code&gt;'session'&lt;/code&gt;&lt;/a&gt; event (it also works for TLSv1.2 and below).</source>
          <target state="translated">참고 : &lt;code&gt;getSession()&lt;/code&gt; 은 TLSv1.2 이하에서만 작동합니다. TLSv1.3의 경우 애플리케이션은 &lt;a href=&quot;#tls_event_session&quot;&gt; &lt;code&gt;'session'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용해야합니다 (TLSv1.2 이하에서도 작동 함).</target>
        </trans-unit>
        <trans-unit id="ecd844f1014ce393ccf5d8fffcaf8b96adac6bf1" translate="yes" xml:space="preserve">
          <source>Note: &lt;em&gt;specifier&lt;/em&gt; is now a bare specifier.</source>
          <target state="translated">주 : &lt;em&gt;지정&lt;/em&gt; 자는 이제 베어 지정자입니다.</target>
        </trans-unit>
        <trans-unit id="01f9d22189eec14674a459713bb8e39e51c5a5c9" translate="yes" xml:space="preserve">
          <source>Note: For TLSv1.2 and below, &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt;&lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt;&lt;/a&gt; can be called once the handshake is complete. For TLSv1.3, only ticket based resumption is allowed by the protocol, multiple tickets are sent, and the tickets aren't sent until later, after the handshake completes, so it is necessary to wait for the &lt;code&gt;'session'&lt;/code&gt; event to get a resumable session. Applications are recommended to use the &lt;code&gt;'session'&lt;/code&gt; event instead of &lt;code&gt;getSession()&lt;/code&gt; to ensure they will work for all TLS protocol versions. Applications that only expect to get or use 1 session should listen for this event only once:</source>
          <target state="translated">참고 : TLSv1.2 이하의 경우 핸드 셰이크가 완료되면 &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt; &lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다. TLSv1.3의 경우 프로토콜에서 티켓 기반 재개 만 허용하고 여러 티켓이 전송되며 핸드 셰이크가 완료된 후 나중에 티켓이 전송되지 않으므로 &lt;code&gt;'session'&lt;/code&gt; 이벤트 가 완료 될 때까지 기다려야합니다 . 재개 가능한 세션. 애플리케이션은 모든 TLS 프로토콜 버전에서 작동하도록 &lt;code&gt;getSession()&lt;/code&gt; 대신 &lt;code&gt;'session'&lt;/code&gt; 이벤트 를 사용하는 것이 좋습니다 . 1 세션 만 가져 오거나 사용할 것으로 예상되는 응용 프로그램은이 이벤트를 한 번만 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="143d66316a52090c9d94eb1ce24b88eea6b0ee08" translate="yes" xml:space="preserve">
          <source>Note: If the source value of a text-based format (i.e., &lt;code&gt;'json'&lt;/code&gt;, &lt;code&gt;'module'&lt;/code&gt;) is not a string, it is converted to a string using &lt;a href=&quot;util#util_class_util_textdecoder&quot;&gt;&lt;code&gt;util.TextDecoder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 텍스트 기반 형식 (예 : &lt;code&gt;'json'&lt;/code&gt; , &lt;code&gt;'module'&lt;/code&gt; ) 의 소스 값이 문자열이 아닌 경우 &lt;a href=&quot;util#util_class_util_textdecoder&quot;&gt; &lt;code&gt;util.TextDecoder&lt;/code&gt; 를&lt;/a&gt; 사용하여 문자열로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8cc0b60938c91b13e1400e17c52a12ff07dd161" translate="yes" xml:space="preserve">
          <source>Note: The format of the output is identical to the output of &lt;code&gt;openssl s_client -trace&lt;/code&gt; or &lt;code&gt;openssl s_server -trace&lt;/code&gt;. While it is produced by OpenSSL's &lt;code&gt;SSL_trace()&lt;/code&gt; function, the format is undocumented, can change without notice, and should not be relied on.</source>
          <target state="translated">참고 : 출력 형식은 &lt;code&gt;openssl s_client -trace&lt;/code&gt; 또는 &lt;code&gt;openssl s_server -trace&lt;/code&gt; 의 출력과 동일합니다 . OpenSSL의 &lt;code&gt;SSL_trace()&lt;/code&gt; 함수에 의해 생성되는 동안 형식은 문서화되지 않으며 예고없이 변경 될 수 있으며 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb03c3f0f36f676cbf5598bceb30b9b907caf42" translate="yes" xml:space="preserve">
          <source>Note: The loaders API is being redesigned. This hook may disappear or its signature may change. Do not rely on the API described below.</source>
          <target state="translated">참고 : 로더 API는 재 설계 중입니다. 이 후크는 사라지거나 서명이 변경 될 수 있습니다. 아래에 설명 된 API에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1137c6d126d9539fc06dcec9bc60743ec7916ed7" translate="yes" xml:space="preserve">
          <source>Note: These types all correspond to classes defined in ECMAScript.</source>
          <target state="translated">참고 : 이러한 유형은 모두 ECMAScript에 정의 된 클래스에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4616f15367371a5e06b48d2440f7200dc5d1e91b" translate="yes" xml:space="preserve">
          <source>Note: this is not a strong encapsulation as any private modules can still be loaded by absolute paths.</source>
          <target state="translated">참고 : 개인 모듈은 절대 경로로로드 할 수 있으므로 강력한 캡슐화는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="19206efecb0b7ff72417c2ea1e1677519502ef39" translate="yes" xml:space="preserve">
          <source>Now only the defined subpath in &lt;a href=&quot;#packages_exports&quot;&gt;&lt;code&gt;&quot;exports&quot;&lt;/code&gt;&lt;/a&gt; can be imported by a consumer:</source>
          <target state="translated">이제 소비자 는 &lt;a href=&quot;#packages_exports&quot;&gt; &lt;code&gt;&quot;exports&quot;&lt;/code&gt; &lt;/a&gt; 에 정의 된 하위 경로 만 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03c6fe1c5a7dfc8aba7cdb4a41e8ccd36e1826f" translate="yes" xml:space="preserve">
          <source>Now, however, passing either &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; will throw a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">그러나 이제 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 을 전달 하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="2bdc0c2afdfc8111c042201c3e20a922dbf5c7df" translate="yes" xml:space="preserve">
          <source>Number of times &lt;a href=&quot;#stream_writable_uncork&quot;&gt;&lt;code&gt;writable.uncork()&lt;/code&gt;&lt;/a&gt; needs to be called in order to fully uncork the stream.</source>
          <target state="translated">스트림을 완전히 해제하기 위해 &lt;a href=&quot;#stream_writable_uncork&quot;&gt; &lt;code&gt;writable.uncork()&lt;/code&gt; &lt;/a&gt; 를 호출해야하는 횟수 입니다.</target>
        </trans-unit>
        <trans-unit id="29e915ad9f7438f469d5fcc18ac6ba4e549838fd" translate="yes" xml:space="preserve">
          <source>Numbers which contain a decimal point, such as floating-point numbers or numbers in scientific notation, are not an exception to this rule. Leading numbers up to the decimal point will be set as the URL's port, assuming they are valid:</source>
          <target state="translated">부동 소수점 숫자 또는 과학적 표기법의 숫자와 같이 소수점이 포함 된 숫자는이 규칙에서 예외가 아닙니다. 소수점 이하의 선행 숫자는 유효하다고 가정하면 URL의 포트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="950d326ee993b3c5fd62c84949251f546e884fe5" translate="yes" xml:space="preserve">
          <source>Numeric strings, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are now allowed time specifiers.</source>
          <target state="translated">숫자 문자열, &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;Infinity&lt;/code&gt; 에는 이제 시간 지정자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b569a17c3091df771016c89c44b2ffb4e1607960" translate="yes" xml:space="preserve">
          <source>OCSPRequest event (tls.Server)</source>
          <target state="translated">OCSPRequest 이벤트 (tls.Server)</target>
        </trans-unit>
        <trans-unit id="869b3c3e713ad68da924ccf887bfa9fee9bd8b2b" translate="yes" xml:space="preserve">
          <source>OCSPResponse event (tls.TLSSocket)</source>
          <target state="translated">OCSPResponse 이벤트 (tls.TLSSocket)</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="bf4c411135eaccffeeffff0459da3c06dede6217" translate="yes" xml:space="preserve">
          <source>OS Constants</source>
          <target state="translated">OS 상수</target>
        </trans-unit>
        <trans-unit id="6965d55430bc54c35413fd5c8bf55a36f18c649b" translate="yes" xml:space="preserve">
          <source>OS constants</source>
          <target state="translated">OS 상수</target>
        </trans-unit>
        <trans-unit id="ac9cc4a542ab690808d6be64e5ca5ad4762815a8" translate="yes" xml:space="preserve">
          <source>Object &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;&amp;lt;Object&amp;gt;&lt;/a&gt;</source>
          <target state="translated">개체 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object&quot;&gt;&amp;lt;개체&amp;gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bddd1661aadc76f58c10dd21eeb8e7deaace4a15" translate="yes" xml:space="preserve">
          <source>Object Creation Functions</source>
          <target state="translated">객체 생성 기능</target>
        </trans-unit>
        <trans-unit id="802b3a5ff4c325801801b1f33c90e6aeb50581e9" translate="yes" xml:space="preserve">
          <source>Object Lifetime management</source>
          <target state="translated">객체 수명 관리</target>
        </trans-unit>
        <trans-unit id="da1a453a1b599c80407bbb5b25d54d19f9155848" translate="yes" xml:space="preserve">
          <source>Object Mode</source>
          <target state="translated">객체 모드</target>
        </trans-unit>
        <trans-unit id="0e31dc36041309eb25a82e43f179da4c384a8655" translate="yes" xml:space="preserve">
          <source>Object Mode Duplex Streams</source>
          <target state="translated">객체 모드 이중 스트림</target>
        </trans-unit>
        <trans-unit id="e00ee9265d488224abef0452c70b1277e5a83f49" translate="yes" xml:space="preserve">
          <source>Object Wrap</source>
          <target state="translated">개체 랩</target>
        </trans-unit>
        <trans-unit id="ed4585f1bf8f3e5d64756e5a2158cd6c89ec5f06" translate="yes" xml:space="preserve">
          <source>Object creation functions</source>
          <target state="translated">객체 생성 기능</target>
        </trans-unit>
        <trans-unit id="6e782d8ce1f909216afa55f0563a026fe7e818df" translate="yes" xml:space="preserve">
          <source>Object factory</source>
          <target state="translated">객체 팩토리</target>
        </trans-unit>
        <trans-unit id="ab6016ee032803e49db26c34525dd3ec5b87e864" translate="yes" xml:space="preserve">
          <source>Object lifetime management</source>
          <target state="translated">개체 수명 관리</target>
        </trans-unit>
        <trans-unit id="7f58022f766261caffba5edc95b9a9f6abe4cafe" translate="yes" xml:space="preserve">
          <source>Object mode</source>
          <target state="translated">객체 모드</target>
        </trans-unit>
        <trans-unit id="16ec0f1b0142b04e2c99de9fa13eb604badafb51" translate="yes" xml:space="preserve">
          <source>Object mode duplex streams</source>
          <target state="translated">개체 모드 이중 스트림</target>
        </trans-unit>
        <trans-unit id="eb1df3362912f24b36ee95c2e780ae5886f130ba" translate="yes" xml:space="preserve">
          <source>Object wrap</source>
          <target state="translated">개체 포장</target>
        </trans-unit>
        <trans-unit id="97d591c73dd9bade5d6e035ec1c272d3d2d914a0" translate="yes" xml:space="preserve">
          <source>Objects assigned to the exports of this instance may allow importers of the module to access information outside the specified &lt;code&gt;context&lt;/code&gt;. Use &lt;code&gt;vm.runInContext()&lt;/code&gt; to create objects in a specific context.</source>
          <target state="translated">이 인스턴스의 내보내기에 할당 된 개체를 사용하면 모듈의 수입자가 지정된 &lt;code&gt;context&lt;/code&gt; 외부의 정보에 액세스 할 수 있습니다 . 사용 &lt;code&gt;vm.runInContext()&lt;/code&gt; 특정 컨텍스트에서 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241d3fb63dae7cf76601d561abf3a990fe514c68" translate="yes" xml:space="preserve">
          <source>Objects may also define their own &lt;a href=&quot;#util_util_inspect_custom&quot;&gt;&lt;code&gt;[util.inspect.custom](depth, opts)&lt;/code&gt;&lt;/a&gt; function, which &lt;code&gt;util.inspect()&lt;/code&gt; will invoke and use the result of when inspecting the object:</source>
          <target state="translated">객체는 또한 자체 &lt;a href=&quot;#util_util_inspect_custom&quot;&gt; &lt;code&gt;[util.inspect.custom](depth, opts)&lt;/code&gt; &lt;/a&gt; 함수를 정의 할 수 있습니다.이 함수는 &lt;code&gt;util.inspect()&lt;/code&gt; 가 객체를 검사 할 때 결과를 호출하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="405e84c6a63356b689521faa0c8b25c5d64dde37" translate="yes" xml:space="preserve">
          <source>Objects returned from &lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt;&lt;code&gt;fs.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt;&lt;code&gt;fs.lstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt;&lt;code&gt;fs.fstat()&lt;/code&gt;&lt;/a&gt; and their synchronous counterparts are of this type. If &lt;code&gt;bigint&lt;/code&gt; in the &lt;code&gt;options&lt;/code&gt; passed to those methods is true, the numeric values will be &lt;code&gt;bigint&lt;/code&gt; instead of &lt;code&gt;number&lt;/code&gt;, and the object will contain additional nanosecond-precision properties suffixed with &lt;code&gt;Ns&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt; &lt;code&gt;fs.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt; &lt;code&gt;fs.lstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt; &lt;code&gt;fs.fstat()&lt;/code&gt; &lt;/a&gt; 및 해당 동기 대상에서 반환 된 객체 는이 유형입니다. 경우 &lt;code&gt;bigint&lt;/code&gt; 에서 &lt;code&gt;options&lt;/code&gt; 그 방법에 전달이 참, 숫자 값이 될 것 &lt;code&gt;bigint&lt;/code&gt; 대신에 &lt;code&gt;number&lt;/code&gt; 와 객체는 접미사 추가 나노초 정밀도 속성이 포함됩니다 &lt;code&gt;Ns&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0d2e6c538dec52ec33838e688cc3db3a4ab623" translate="yes" xml:space="preserve">
          <source>Objects returned from &lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt;&lt;code&gt;fs.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt;&lt;code&gt;fs.lstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt;&lt;code&gt;fs.fstat()&lt;/code&gt;&lt;/a&gt; and their synchronous counterparts are of this type. If &lt;code&gt;bigint&lt;/code&gt; in the &lt;code&gt;options&lt;/code&gt; passed to those methods is true, the numeric values will be &lt;code&gt;bigint&lt;/code&gt; instead of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt; &lt;code&gt;fs.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt; &lt;code&gt;fs.lstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt; &lt;code&gt;fs.fstat()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 객체 와 해당 동기 대응 항목은이 유형입니다. 경우 &lt;code&gt;bigint&lt;/code&gt; 에서 &lt;code&gt;options&lt;/code&gt; 그 방법에 전달이 참, 숫자 값이 될 것 &lt;code&gt;bigint&lt;/code&gt; 대신 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="592e8c13ea9bd4b8af95ba0ada47b20335a6e103" translate="yes" xml:space="preserve">
          <source>Objects with circular references can be used as inputs now.</source>
          <target state="translated">원형 참조가있는 객체를 이제 입력으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ea40e2b9bd257d370923337e02a0992196f54f" translate="yes" xml:space="preserve">
          <source>Observe that the &lt;code&gt;then()&lt;/code&gt; callback claims to have executed in the context of the outer scope even though there was an asynchronous hop involved. Also, the &lt;code&gt;triggerAsyncId&lt;/code&gt; value is &lt;code&gt;0&lt;/code&gt;, which means that we are missing context about the resource that caused (triggered) the &lt;code&gt;then()&lt;/code&gt; callback to be executed.</source>
          <target state="translated">관찰 &lt;code&gt;then()&lt;/code&gt; 콜백 항 관여 비동기 홉 거기에도 외 범위의 콘텍스트에서 실행될 것으로. 또한 &lt;code&gt;triggerAsyncId&lt;/code&gt; 값이 &lt;code&gt;0&lt;/code&gt; 이므로 &lt;code&gt;then()&lt;/code&gt; 콜백이 실행 된 (트리거 된) 리소스에 대한 컨텍스트가 누락되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="083bef7791cf9d1baf8a9873f071dfc52b64445d" translate="yes" xml:space="preserve">
          <source>Occasionally, the deprecation of an API may be reversed. In such situations, this document will be updated with information relevant to the decision. However, the deprecation identifier will not be modified.</source>
          <target state="translated">때때로 API 사용 중단이 취소 될 수 있습니다. 이러한 상황에서이 문서는 결정과 관련된 정보로 업데이트됩니다. 그러나 지원 중단 식별자는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="598a1ea6bb4b34df4307149358f5d4d90ab41312" translate="yes" xml:space="preserve">
          <source>Occasionally, the deprecation of an API might be reversed. In such situations, this document will be updated with information relevant to the decision. However, the deprecation identifier will not be modified.</source>
          <target state="translated">경우에 따라 API 지원 중단이 취소 될 수 있습니다. 이러한 상황에서이 문서는 결정과 관련된 정보로 업데이트됩니다. 그러나 지원 중단 식별자는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba38afb5d72c78a9ff4e1ee1598f9f9be252886d" translate="yes" xml:space="preserve">
          <source>Occurs with multiple attempts to shutdown an HTTP/2 session.</source>
          <target state="translated">HTTP / 2 세션을 여러 번 종료하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="a48963a917f62904a1e8543a2ead20c099e2eff3" translate="yes" xml:space="preserve">
          <source>Offset and length are optional but both &lt;em&gt;must&lt;/em&gt; be set if either are used. They are supported only when the first argument is a &lt;code&gt;Buffer&lt;/code&gt; or &lt;code&gt;Uint8Array&lt;/code&gt;.</source>
          <target state="translated">오프셋과 길이는 선택 사항이지만 둘 중 하나를 사용하는 경우 둘 다 설정 &lt;em&gt;해야합니다&lt;/em&gt; . 첫 번째 인수가 &lt;code&gt;Buffer&lt;/code&gt; 또는 &lt;code&gt;Uint8Array&lt;/code&gt; 인 경우에만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="8269c5428afc6a034f766b68b360ac4c01e96403" translate="yes" xml:space="preserve">
          <source>Offset and length are optional but both &lt;em&gt;must&lt;/em&gt; be set if either are used. They are supported only when the first argument is a &lt;code&gt;Buffer&lt;/code&gt;, a &lt;code&gt;TypedArray&lt;/code&gt;, or a &lt;code&gt;DataView&lt;/code&gt;.</source>
          <target state="translated">오프셋과 길이는 선택 사항이지만 둘 중 하나를 사용하는 경우 둘 다 설정 &lt;em&gt;해야합니다&lt;/em&gt; . 첫 번째 인수가 &lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;TypedArray&lt;/code&gt; 또는 &lt;code&gt;DataView&lt;/code&gt; 인 경우에만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4a4dc432f9794752f6ad30e244e3a8e720cdc69" translate="yes" xml:space="preserve">
          <source>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers (like Internet Explorer 6) cannot complete the handshaking process with the default configuration. If these clients &lt;em&gt;must&lt;/em&gt; be supported, the &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;TLS recommendations&lt;/a&gt; may offer a compatible cipher suite. For more details on the format, see the OpenSSL &lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;cipher list format&lt;/a&gt; documentation.</source>
          <target state="translated">안전하지 않고 더 이상 사용되지 않는 RC4 또는 DES 기반 암호 (예 : Internet Explorer 6)를 사용하는 이전 클라이언트는 기본 구성으로 핸드 쉐이킹 프로세스를 완료 할 수 없습니다. 이러한 클라이언트 &lt;em&gt;를&lt;/em&gt; 지원 &lt;em&gt;해야하는&lt;/em&gt; 경우 &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;TLS 권장 사항&lt;/a&gt; 은 호환 가능한 암호 제품군을 제공 할 수 있습니다. 형식에 대한 자세한 내용은 OpenSSL &lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;암호 목록 형식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39846a8f31378460759ab91e423751587cbcd672" translate="yes" xml:space="preserve">
          <source>Omitting the callback function on asynchronous fs functions is deprecated and may result in an error being thrown in the future.</source>
          <target state="translated">비동기 fs 함수에서 콜백 함수를 생략하면 더 이상 사용되지 않으며 나중에 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e37ed6c1806cbc047e27697c95f4a9f5fa450df" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures, this value currently is 2&lt;sup&gt;30&lt;/sup&gt; - 1 (~1GB). On 64-bit architectures, this value currently is 2&lt;sup&gt;31&lt;/sup&gt; - 1 (~2GB).</source>
          <target state="translated">32 비트 아키텍처에서,이 값은 현재 2 &lt;sup&gt;30&lt;/sup&gt; 1 (~ 1기가바이트) -. 64 비트 아키텍처에서이 값은 현재 2 &lt;sup&gt;31-1&lt;/sup&gt; (~ 2GB)입니다.</target>
        </trans-unit>
        <trans-unit id="6d0e0b0451c6ef174ec5a71852c7111df84bc0bf" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures, this value is &lt;code&gt;(2^30)-1&lt;/code&gt; (~1GB). On 64-bit architectures, this value is &lt;code&gt;(2^31)-1&lt;/code&gt; (~2GB).</source>
          <target state="translated">32 비트 아키텍처에서이 값은 &lt;code&gt;(2^30)-1&lt;/code&gt; (~ 1GB)입니다. 64 비트 아키텍처에서이 값은 &lt;code&gt;(2^31)-1&lt;/code&gt; (~ 2GB)입니다.</target>
        </trans-unit>
        <trans-unit id="cece5a81c61c5200f22063c4263b25c9ea0fa07a" translate="yes" xml:space="preserve">
          <source>On Aix systems, this feature depends on &lt;a href=&quot;https://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&quot;&gt;&lt;code&gt;AHAFS&lt;/code&gt;&lt;/a&gt;, which must be enabled.</source>
          <target state="translated">Aix 시스템에서이 기능은 활성화 &lt;a href=&quot;https://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&quot;&gt; &lt;code&gt;AHAFS&lt;/code&gt; &lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3287e458f7d140ce7af1d1893ae19d42b58cb150" translate="yes" xml:space="preserve">
          <source>On BSD systems, this uses &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt;&lt;code&gt;kqueue(2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">BSD 시스템에서는 &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt; &lt;code&gt;kqueue(2)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8caac710974bc62eceaa895a0fa812289ad69d07" translate="yes" xml:space="preserve">
          <source>On IBM i systems, this feature is not supported.</source>
          <target state="translated">IBM i 시스템에서는이 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cee5b68c9afac982d46719c80955c745508f033" translate="yes" xml:space="preserve">
          <source>On IPv4, if &lt;code&gt;multicastInterface&lt;/code&gt; is a valid address but does not match any interface, or if the address does not match the family then a &lt;a href=&quot;errors#errors_class_systemerror&quot;&gt;&lt;code&gt;System Error&lt;/code&gt;&lt;/a&gt; such as &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; or &lt;code&gt;EPROTONOSUP&lt;/code&gt; is thrown.</source>
          <target state="translated">IPv4에서 &lt;code&gt;multicastInterface&lt;/code&gt; 가 유효한 주소이지만 인터페이스와 일치하지 않거나 주소가 패밀리와 일치하지 않으면 &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; 또는 &lt;code&gt;EPROTONOSUP&lt;/code&gt; 과 같은 &lt;a href=&quot;errors#errors_class_systemerror&quot;&gt; &lt;code&gt;System Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a12d6ebff8b4c4e4e6eb03c5545e6ff9fb72add1" translate="yes" xml:space="preserve">
          <source>On IPv4, if &lt;code&gt;multicastInterface&lt;/code&gt; is a valid address but does not match any interface, or if the address does not match the family then a System Error such as &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; or &lt;code&gt;EPROTONOSUP&lt;/code&gt; is thrown.</source>
          <target state="translated">IPv4에서 &lt;code&gt;multicastInterface&lt;/code&gt; 가 유효한 주소이지만 인터페이스와 일치하지 않는 경우 또는 주소가 패밀리와 일치하지 않으면 &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; 또는 &lt;code&gt;EPROTONOSUP&lt;/code&gt; 와 같은 시스템 오류 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d73abdde568049652b60fdd5aaa144ebebd0fc9" translate="yes" xml:space="preserve">
          <source>On IPv6, most errors with specifying or omitting scope will result in the socket continuing to use (or returning to) the system's default interface selection.</source>
          <target state="translated">IPv6에서 범위를 지정하거나 생략 할 때 발생하는 대부분의 오류는 소켓이 시스템의 기본 인터페이스 선택을 계속 사용하거나 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0b541a8346341860cd7703b98a4352d06a66130" translate="yes" xml:space="preserve">
          <source>On Linux and macOS systems, &lt;code&gt;fs.watch()&lt;/code&gt; resolves the path to an &lt;a href=&quot;https://en.wikipedia.org/wiki/Inode&quot;&gt;inode&lt;/a&gt; and watches the inode. If the watched path is deleted and recreated, it is assigned a new inode. The watch will emit an event for the delete but will continue watching the &lt;em&gt;original&lt;/em&gt; inode. Events for the new inode will not be emitted. This is expected behavior.</source>
          <target state="translated">Linux 및 macOS 시스템에서 &lt;code&gt;fs.watch()&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inode&quot;&gt;inode&lt;/a&gt; 의 경로를 확인하고 inode 를 감시합니다. 감시 경로가 삭제되고 다시 생성되면 새로운 inode가 할당됩니다. 시계에서 삭제 이벤트가 발생하지만 &lt;em&gt;원래&lt;/em&gt; inode 는 계속 지켜 봅니다. 새로운 inode에 대한 이벤트는 생성되지 않습니다. 이것은 예상 된 동작입니다.</target>
        </trans-unit>
        <trans-unit id="08f31ae143ca922e16ce486612875e1b465fba38" translate="yes" xml:space="preserve">
          <source>On Linux systems, this uses &lt;a href=&quot;http://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt;&lt;code&gt;inotify(7)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Linux 시스템에서는 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt; &lt;code&gt;inotify(7)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d99fa13cd94d439565091aa184b49a5f8b37dff1" translate="yes" xml:space="preserve">
          <source>On Linux systems, this uses &lt;a href=&quot;https://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt;&lt;code&gt;inotify(7)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Linux 시스템에서는 &lt;a href=&quot;https://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt; &lt;code&gt;inotify(7)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b2f183efec4feb7bfa6fc109ebc4023975000344" translate="yes" xml:space="preserve">
          <source>On Linux, child processes of child processes will not be terminated when attempting to kill their parent. This is likely to happen when running a new process in a shell or with the use of the &lt;code&gt;shell&lt;/code&gt; option of &lt;code&gt;ChildProcess&lt;/code&gt;:</source>
          <target state="translated">Linux에서는 상위 프로세스를 종료하려고 할 때 하위 프로세스의 하위 프로세스가 종료되지 않습니다. 이것은 쉘에서 새 프로세스를 실행하거나 &lt;code&gt;ChildProcess&lt;/code&gt; 의 &lt;code&gt;shell&lt;/code&gt; 옵션을 사용하여 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7882f8e43f0f64c5514b81f5cfa8dcb3ff288045" translate="yes" xml:space="preserve">
          <source>On Linux, positional writes do not work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.</source>
          <target state="translated">Linux에서 파일을 추가 모드로 열면 위치 쓰기가 작동하지 않습니다. 커널은 position 인수를 무시하고 항상 파일 끝에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="58c85a79493b7491ac9088c933d8b858c448602a" translate="yes" xml:space="preserve">
          <source>On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.</source>
          <target state="translated">Linux에서 파일을 추가 모드로 열면 위치 쓰기가 작동하지 않습니다. 커널은 position 인수를 무시하고 항상 파일 끝에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9554e400419b2712320ba3378dbdb33b6ba3a586" translate="yes" xml:space="preserve">
          <source>On Linux, when Node.js is linked against musl libc, the procfs file system must be mounted on &lt;code&gt;/proc&lt;/code&gt; in order for this function to work. Glibc does not have this restriction.</source>
          <target state="translated">Linux에서 Node.js가 musl libc에 링크 된 경우이 기능이 작동 하려면 procfs 파일 시스템을 &lt;code&gt;/proc&lt;/code&gt; 에 마운트해야합니다 . Glibc에는이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="46927efa147a220d19018a44c19bb0a81a2795b4" translate="yes" xml:space="preserve">
          <source>On POSIX and Windows:</source>
          <target state="translated">POSIX 및 Windows :</target>
        </trans-unit>
        <trans-unit id="51d7bab8caccee4037b352d1dd8b48e36fb94ee8" translate="yes" xml:space="preserve">
          <source>On POSIX systems, for every process, the kernel maintains a table of currently open files and resources. Each open file is assigned a simple numeric identifier called a &lt;em&gt;file descriptor&lt;/em&gt;. At the system-level, all file system operations use these file descriptors to identify and track each specific file. Windows systems use a different but conceptually similar mechanism for tracking resources. To simplify things for users, Node.js abstracts away the specific differences between operating systems and assigns all open files a numeric file descriptor.</source>
          <target state="translated">POSIX 시스템에서 모든 프로세스에 대해 커널은 현재 열려있는 파일 및 리소스 테이블을 유지 관리합니다. 열려있는 각 파일에는 &lt;em&gt;파일 설명&lt;/em&gt; 자라는 간단한 숫자 식별자가 할당됩니다 . 시스템 레벨에서 모든 파일 시스템 조작은이 파일 디스크립터를 사용하여 각 특정 파일을 식별하고 추적합니다. Windows 시스템은 리소스를 추적하기 위해 다르지만 개념적으로 유사한 메커니즘을 사용합니다. 사용자를 위해 단순화하기 위해 Node.js는 운영 체제 간의 특정 차이점을 추상화하고 열려있는 모든 파일에 숫자 파일 설명자를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="fc406a1e7cf53219ab80c07c59e5aaa1d8a7ae6a" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the operating system release is determined by calling &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt;&lt;code&gt;uname(3)&lt;/code&gt;&lt;/a&gt;. On Windows, &lt;code&gt;GetVersionExW()&lt;/code&gt; is used. Please see &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 시스템에서 운영 체제 릴리스는 &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt; &lt;code&gt;uname(3)&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . Windows에서는 &lt;code&gt;GetVersionExW()&lt;/code&gt; 가 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="529835cf3a3fa32581d69a9d32689b9ecaa309fc" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the operating system release is determined by calling &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt;&lt;code&gt;uname(3)&lt;/code&gt;&lt;/a&gt;. On Windows, &lt;code&gt;GetVersionExW()&lt;/code&gt; is used. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 시스템에서 운영 체제 릴리스는 &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt; &lt;code&gt;uname(3)&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . Windows에서는 &lt;code&gt;GetVersionExW()&lt;/code&gt; 가 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26a3b30280dab2fdf275c399eb32f1ec5ace872a" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the operating system release is determined by calling &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt;&lt;code&gt;uname(3)&lt;/code&gt;&lt;/a&gt;. On Windows, &lt;code&gt;RtlGetVersion()&lt;/code&gt; is used, and if it is not available, &lt;code&gt;GetVersionExW()&lt;/code&gt; will be used. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 시스템에서 운영 체제 릴리스는 &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt; &lt;code&gt;uname(3)&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . Windows에서는 &lt;code&gt;RtlGetVersion()&lt;/code&gt; 이 사용되며, 사용할 수없는 경우 &lt;code&gt;GetVersionExW()&lt;/code&gt; 가 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9b0e6a082c9e5097d3e7d84e1d93e40884bd8f2" translate="yes" xml:space="preserve">
          <source>On POSIX, it uses the &lt;code&gt;$HOME&lt;/code&gt; environment variable if defined. Otherwise it uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID&quot;&gt;effective UID&lt;/a&gt; to look up the user's home directory.</source>
          <target state="translated">POSIX에서는 정의 된 경우 &lt;code&gt;$HOME&lt;/code&gt; 환경 변수를 사용합니다 . 그렇지 않으면 &lt;a href=&quot;https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID&quot;&gt;유효한 UID&lt;/a&gt; 를 사용하여 사용자의 홈 디렉토리를 조회합니다.</target>
        </trans-unit>
        <trans-unit id="43964d44f0ac16e56226d71c33bedb3c5fe5eddc" translate="yes" xml:space="preserve">
          <source>On POSIX:</source>
          <target state="translated">POSIX에서 :</target>
        </trans-unit>
        <trans-unit id="fbb774d38621fd75eb708c21854f712a9058284b" translate="yes" xml:space="preserve">
          <source>On SunOS systems (including Solaris and SmartOS), this uses &lt;a href=&quot;http://illumos.org/man/port_create&quot;&gt;&lt;code&gt;event ports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SunOS 시스템 (Solaris 및 SmartOS 포함)에서는 &lt;a href=&quot;http://illumos.org/man/port_create&quot;&gt; &lt;code&gt;event ports&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d2249ac9863c008934bf32cf468a1af5268e9ec5" translate="yes" xml:space="preserve">
          <source>On SunOS systems (including Solaris and SmartOS), this uses &lt;a href=&quot;https://illumos.org/man/port_create&quot;&gt;&lt;code&gt;event ports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SunOS 시스템 (Solaris 및 SmartOS 포함)에서는 &lt;a href=&quot;https://illumos.org/man/port_create&quot;&gt; &lt;code&gt;event ports&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="df56f9f559c9d44e41081b83b633aad4f3fae33d" translate="yes" xml:space="preserve">
          <source>On Unix, the local domain is also known as the Unix domain. The path is a filesystem pathname. It gets truncated to &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt;, which varies on different operating system between 91 and 107 bytes. The typical values are 107 on Linux and 103 on macOS. The path is subject to the same naming conventions and permissions checks as would be done on file creation. If the Unix domain socket (that is visible as a file system path) is created and used in conjunction with one of Node.js' API abstractions such as &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt;&lt;code&gt;net.createServer()&lt;/code&gt;&lt;/a&gt;, it will be unlinked as part of &lt;a href=&quot;#net_server_close_callback&quot;&gt;&lt;code&gt;server.close()&lt;/code&gt;&lt;/a&gt;. On the other hand, if it is created and used outside of these abstractions, the user will need to manually remove it. The same applies when the path was created by a Node.js API but the program crashes abruptly. In short, a Unix domain socket once successfully created will be visible in the filesystem, and will persist until unlinked.</source>
          <target state="translated">Unix에서 로컬 도메인은 Unix 도메인이라고도합니다. 경로는 파일 시스템 경로 이름입니다. &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt; 잘 리며 91-107 바이트 사이의 운영 체제에 따라 다릅니다. 일반적인 값은 Linux에서 107, macOS에서 103입니다. 경로는 파일 작성시와 동일한 이름 지정 규칙 및 권한 검사를 따릅니다. &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt; &lt;code&gt;net.createServer()&lt;/code&gt; &lt;/a&gt; 와 같은 Node.js API 추상화 중 하나와 함께 Unix 도메인 소켓 (파일 시스템 경로로 표시됨)을 작성하여 사용 하는 경우 &lt;a href=&quot;#net_server_close_callback&quot;&gt; &lt;code&gt;server.close()&lt;/code&gt; &lt;/a&gt; 일부로 연결 해제됩니다.. 반면에, 이러한 추상화 외부에서 작성하여 사용하는 경우 사용자는이를 수동으로 제거해야합니다. Node.js API에 의해 경로가 작성되었지만 프로그램이 갑자기 충돌하는 경우에도 동일하게 적용됩니다. 한마디로 성공적으로 생성 된 Unix 도메인 소켓은 파일 시스템에 표시되며 연결이 끊길 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="cd01d76d0a5be36ebb3d8172b05f7ed5b8cfd655" translate="yes" xml:space="preserve">
          <source>On Unix, the local domain is also known as the Unix domain. The path is a filesystem pathname. It gets truncated to an OS-dependent length of &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt;. Typical values are 107 bytes on Linux and 103 bytes on macOS. If a Node.js API abstraction creates the Unix domain socket, it will unlink the Unix domain socket as well. For example, &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt;&lt;code&gt;net.createServer()&lt;/code&gt;&lt;/a&gt; may create a Unix domain socket and &lt;a href=&quot;#net_server_close_callback&quot;&gt;&lt;code&gt;server.close()&lt;/code&gt;&lt;/a&gt; will unlink it. But if a user creates the Unix domain socket outside of these abstractions, the user will need to remove it. The same applies when a Node.js API creates a Unix domain socket but the program then crashes. In short, a Unix domain socket will be visible in the filesystem and will persist until unlinked.</source>
          <target state="translated">Unix에서 로컬 도메인은 Unix 도메인이라고도합니다. 경로는 파일 시스템 경로 이름입니다. OS에 따라 &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt; 길이로 잘립니다 . 일반적인 값은 Linux에서 107 바이트, macOS에서 103 바이트입니다. Node.js API 추상화가 Unix 도메인 소켓을 생성하면 Unix 도메인 소켓도 연결 해제됩니다. 예를 들어, &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt; &lt;code&gt;net.createServer()&lt;/code&gt; &lt;/a&gt; 는 Unix 도메인 소켓을 생성하고 &lt;a href=&quot;#net_server_close_callback&quot;&gt; &lt;code&gt;server.close()&lt;/code&gt; &lt;/a&gt; 는 연결을 해제합니다. 그러나 사용자가 이러한 추상화 외부에서 Unix 도메인 소켓을 생성하는 경우 사용자는이를 제거해야합니다. Node.js API가 Unix 도메인 소켓을 만들 때도 마찬가지지만 프로그램이 충돌합니다. 요컨대, Unix 도메인 소켓은 파일 시스템에 표시되며 연결 해제 될 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="3972efd510cd3bdc92bf875a4f0a2ead952896ec" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; method performs memory operations synchronously before decoupling the event loop from the child. Applications with a large memory footprint may find frequent &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; calls to be a bottleneck. For more information, see &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=7381&quot;&gt;V8 issue 7381&lt;/a&gt;.</source>
          <target state="translated">Unix와 유사한 운영 체제에서 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 메서드는 이벤트 루프를 자식에서 분리하기 전에 메모리 작업을 동 기적으로 수행합니다. 메모리 사용량이 큰 응용 프로그램은 자주 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 호출에 병목 현상이 발생할 수 있습니다. 자세한 정보는 &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=7381&quot;&gt;V8 문제 7381을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13a6509493c52e58db249370cc4c70c1b95c3182" translate="yes" xml:space="preserve">
          <source>On Windows Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example, &lt;code&gt;path.resolve('C:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;path.resolve('C:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉토리 개념을 따릅니다. 이 동작은 백 슬래시없이 드라이브 경로를 사용할 때 관찰 될 수 있습니다. 예를 들어, &lt;code&gt;path.resolve('C:\\')&lt;/code&gt; 는 잠재적으로 &lt;code&gt;path.resolve('C:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cccd5ed6fa224a3e49b57994f042004b58a3d24" translate="yes" xml:space="preserve">
          <source>On Windows Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example, &lt;code&gt;path.resolve('c:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;path.resolve('c:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉토리의 개념을 따릅니다. 백 슬래시없이 드라이브 경로를 사용할 때이 동작을 관찰 할 수 있습니다. 예를 들어 &lt;code&gt;path.resolve('c:\\')&lt;/code&gt; 는 잠재적으로 &lt;code&gt;path.resolve('c:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44da2b295d7da47cf09267ff3645f95eea8d9b81" translate="yes" xml:space="preserve">
          <source>On Windows operating systems, environment variables are case-insensitive.</source>
          <target state="translated">Windows 운영 체제에서 환경 변수는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ea919f697c12d8bddae320cb521d2942ea420cb" translate="yes" xml:space="preserve">
          <source>On Windows setting priority to &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; requires elevated user, otherwise the set priority will be silently reduced to &lt;code&gt;PRIORITY_HIGH&lt;/code&gt;.</source>
          <target state="translated">Windows에서 우선 순위를 &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; 로 설정 하려면 관리자 가 높아야 합니다. 그렇지 않으면 설정된 우선 순위가 자동으로 &lt;code&gt;PRIORITY_HIGH&lt;/code&gt; 로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="1ec6383b7c3b09150b80d42778d5cc7a98c50e48" translate="yes" xml:space="preserve">
          <source>On Windows systems only, returns an equivalent &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces&quot;&gt;namespace-prefixed path&lt;/a&gt; for the given &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;path&lt;/code&gt; is not a string, &lt;code&gt;path&lt;/code&gt; will be returned without modifications.</source>
          <target state="translated">Windows 시스템에서만 지정된 &lt;code&gt;path&lt;/code&gt; 대해 동등한 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces&quot;&gt;네임 스페이스 접두어 경로&lt;/a&gt; 를 리턴합니다 . &lt;code&gt;path&lt;/code&gt; 가 문자열이 아닌 경우 수정없이 &lt;code&gt;path&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9768705b87b168aec5ab1fa9f7b54014d3f95ac4" translate="yes" xml:space="preserve">
          <source>On Windows systems, this feature depends on &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-readdirectorychangesw&quot;&gt;&lt;code&gt;ReadDirectoryChangesW&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows 시스템에서이 기능은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-readdirectorychangesw&quot;&gt; &lt;code&gt;ReadDirectoryChangesW&lt;/code&gt; 에&lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9123970462a9a43d3561651e7ada1125be2a24b6" translate="yes" xml:space="preserve">
          <source>On Windows the error number provided by the system will be normalized by libuv.</source>
          <target state="translated">Windows에서 시스템이 제공하는 오류 번호는 libuv에 의해 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="3df2880a42d4864e454ff5c30b2f005eea801949" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;NODE_PATH&lt;/code&gt; is delimited by semicolons (&lt;code&gt;;&lt;/code&gt;) instead of colons.</source>
          <target state="translated">Windows에서 &lt;code&gt;NODE_PATH&lt;/code&gt; 는 콜론 대신 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )으로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="5931a3f0a8409d7489021967eca3c561a80a89c9" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;file:&lt;/code&gt; URLs having encoded backslash will result in a throw:</source>
          <target state="translated">Windows에서 &lt;code&gt;file:&lt;/code&gt; 백 슬래시를 인코딩 한 URL은 다음을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5dfd6792c90679bed7685f41f16795e616150055" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;file:&lt;/code&gt; URLs with a host name convert to UNC paths, while &lt;code&gt;file:&lt;/code&gt; URLs with drive letters convert to local absolute paths. &lt;code&gt;file:&lt;/code&gt; URLs without a host name nor a drive letter will result in a throw:</source>
          <target state="translated">Windows에서 &lt;code&gt;file:&lt;/code&gt; 호스트 이름이있는 URL은 UNC 경로로 변환되고 &lt;code&gt;file:&lt;/code&gt; 드라이브 문자가있는 URL은 로컬 절대 경로로 변환됩니다. &lt;code&gt;file:&lt;/code&gt; 호스트 이름이나 드라이브 문자가없는 URL은 다음 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="91506a2d47b419ea0ee01cc61a92dad8cc27411b" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;file:&lt;/code&gt; URLs with a hostname convert to UNC paths, while &lt;code&gt;file:&lt;/code&gt; URLs with drive letters convert to local absolute paths. &lt;code&gt;file:&lt;/code&gt; URLs without a hostname nor a drive letter will result in a throw:</source>
          <target state="translated">Windows에서 &lt;code&gt;file:&lt;/code&gt; 호스트 이름의 URL은 UNC 경로로 변환되고 &lt;code&gt;file:&lt;/code&gt; 드라이브 문자의 URL은 로컬 절대 경로로 변환됩니다. &lt;code&gt;file:&lt;/code&gt; 호스트 이름이없는 URL이나 드라이브 문자가 발생하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8a07e8954ce58294b7c7861b0efb21b71fd0b43" translate="yes" xml:space="preserve">
          <source>On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example &lt;code&gt;fs.readdirSync('C:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;fs.readdirSync('C:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉터리 개념을 따릅니다. 이 동작은 백 슬래시없이 드라이브 경로를 사용할 때 관찰 될 수 있습니다. 예를 들어 &lt;code&gt;fs.readdirSync('C:\\')&lt;/code&gt; 는 잠재적으로 &lt;code&gt;fs.readdirSync('C:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb13f48dbe09dfcc8c8afd1a18188c31d89c540d" translate="yes" xml:space="preserve">
          <source>On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example &lt;code&gt;fs.readdirSync('c:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;fs.readdirSync('c:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉토리의 개념을 따릅니다. 백 슬래시없이 드라이브 경로를 사용할 때이 동작을 관찰 할 수 있습니다. 예를 들어 &lt;code&gt;fs.readdirSync('c:\\')&lt;/code&gt; 는 &lt;code&gt;fs.readdirSync('c:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebe6267af9150e34384ccfb932409adc54221278" translate="yes" xml:space="preserve">
          <source>On Windows, access-control policies (ACLs) on a directory may limit access to a file or directory. The &lt;code&gt;fs.access()&lt;/code&gt; function, however, does not check the ACL and therefore may report that a path is accessible even if the ACL restricts the user from reading or writing to it.</source>
          <target state="translated">Windows에서 디렉토리의 ACL (액세스 제어 정책)은 파일 또는 디렉토리에 대한 액세스를 제한 할 수 있습니다. 그러나 &lt;code&gt;fs.access()&lt;/code&gt; 함수는 ACL을 확인하지 않으므로 ACL이 사용자가 읽거나 쓰는 것을 제한하더라도 경로에 액세스 할 수 있다고보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff139e0769d280257d0d48cf82151703507a29c" translate="yes" xml:space="preserve">
          <source>On Windows, both the forward slash (&lt;code&gt;/&lt;/code&gt;) and backward slash (&lt;code&gt;\&lt;/code&gt;) are accepted as path segment separators; however, the &lt;code&gt;path&lt;/code&gt; methods only add backward slashes (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Windows에서는 슬래시 ( &lt;code&gt;/&lt;/code&gt; )와 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )가 모두 경로 세그먼트 분리 자로 허용됩니다. 그러나 &lt;code&gt;path&lt;/code&gt; 메소드는 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 만 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1e4b11f76bee6dae9b72dd20bcc56d6c47b35cfc" translate="yes" xml:space="preserve">
          <source>On Windows, environment variables are case-insensitive. Node.js lexicographically sorts the &lt;code&gt;env&lt;/code&gt; keys and uses the first one that case-insensitively matches. Only first (in lexicographic order) entry will be passed to the subprocess. This might lead to issues on Windows when passing objects to the &lt;code&gt;env&lt;/code&gt; option that have multiple variants of the same key, such as &lt;code&gt;PATH&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">Windows에서 환경 변수는 대소 문자를 구분하지 않습니다. Node.js는 &lt;code&gt;env&lt;/code&gt; 키를 사전 순으로 정렬하고 대소 문자를 구분하지 않고 일치하는 첫 번째 키를 사용합니다. 첫 번째 (사전 식 순서로) 항목 만 하위 프로세스에 전달됩니다. 이로 인해 &lt;code&gt;PATH&lt;/code&gt; 및 &lt;code&gt;Path&lt;/code&gt; 와 같이 동일한 키의 여러 변형이 있는 &lt;code&gt;env&lt;/code&gt; 옵션에 개체를 전달할 때 Windows에서 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5e941fdda19df2837a224780f4308d95357b323" translate="yes" xml:space="preserve">
          <source>On Windows, if the file descriptor is connected to the console (e.g. &lt;code&gt;fd == 1&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt;) a string containing non-ASCII characters will not be rendered properly by default, regardless of the encoding used. It is possible to configure the console to render UTF-8 properly by changing the active codepage with the &lt;code&gt;chcp 65001&lt;/code&gt; command. See the &lt;a href=&quot;https://ss64.com/nt/chcp.html&quot;&gt;chcp&lt;/a&gt; docs for more details.</source>
          <target state="translated">Windows에서 파일 디스크립터가 콘솔에 연결된 경우 (예 : &lt;code&gt;fd == 1&lt;/code&gt; 또는 &lt;code&gt;stdout&lt;/code&gt; ) ASCII가 아닌 문자를 포함하는 문자열은 사용 된 인코딩에 관계없이 기본적으로 올바르게 렌더링되지 않습니다. &lt;code&gt;chcp 65001&lt;/code&gt; 명령으로 활성 코드 페이지를 변경하여 UTF-8을 올바르게 렌더링하도록 콘솔을 구성 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://ss64.com/nt/chcp.html&quot;&gt;chcp&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac67ee10708396162b94cc66d589c1b59dc10f64" translate="yes" xml:space="preserve">
          <source>On Windows, it is not yet possible to set up a named pipe server in a worker.</source>
          <target state="translated">Windows에서는 아직 작업자에서 명명 된 파이프 서버를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eec5600fe598ba09a7321eb984ae609eb585b3eb" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;code&gt;USERPROFILE&lt;/code&gt; environment variable if defined. Otherwise it uses the path to the profile directory of the current user.</source>
          <target state="translated">Windows에서는 정의 된 경우 &lt;code&gt;USERPROFILE&lt;/code&gt; 환경 변수를 사용합니다 . 그렇지 않으면 현재 사용자의 프로필 디렉토리 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f584f58bf19995481842b619fd8a13edfd866dd" translate="yes" xml:space="preserve">
          <source>On Windows, no events will be emitted if the watched directory is moved or renamed. An &lt;code&gt;EPERM&lt;/code&gt; error is reported when the watched directory is deleted.</source>
          <target state="translated">Windows에서는 감시 된 디렉토리가 이동되거나 이름이 변경 되어도 이벤트가 생성되지 않습니다. &lt;code&gt;EPERM&lt;/code&gt; 의 감시 디렉토리가 삭제 될 때 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="6a20253c7c4edfcb2e4f480c38f30c92cd1f24b4" translate="yes" xml:space="preserve">
          <source>On Windows, opening an existing hidden file using the &lt;code&gt;'w'&lt;/code&gt; flag (either through &lt;code&gt;fs.open()&lt;/code&gt; or &lt;code&gt;fs.writeFile()&lt;/code&gt; or &lt;code&gt;fsPromises.open()&lt;/code&gt;) will fail with &lt;code&gt;EPERM&lt;/code&gt;. Existing hidden files can be opened for writing with the &lt;code&gt;'r+'&lt;/code&gt; flag.</source>
          <target state="translated">Windows에서 &lt;code&gt;'w'&lt;/code&gt; 플래그를 사용하여 ( &lt;code&gt;fs.open()&lt;/code&gt; 또는 &lt;code&gt;fs.writeFile()&lt;/code&gt; 또는 &lt;code&gt;fsPromises.open()&lt;/code&gt; ) 기존 숨김 파일 을 열면 &lt;code&gt;EPERM&lt;/code&gt; 이 실패 합니다. 기존의 숨겨진 파일은 &lt;code&gt;'r+'&lt;/code&gt; 플래그 로 쓰기 위해 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c3c7ea68df8c4d84bf0458c22f4d8178e9c209" translate="yes" xml:space="preserve">
          <source>On Windows, setting &lt;code&gt;options.detached&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; makes it possible for the child process to continue running after the parent exits. The child will have its own console window. Once enabled for a child process, it cannot be disabled.</source>
          <target state="translated">Windows에서 &lt;code&gt;options.detached&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 상위 프로세스가 종료 된 후에 하위 프로세스를 계속 실행할 수 있습니다. 아이에게는 자체 콘솔 창이 있습니다. 하위 프로세스에 대해 활성화 된 후에는 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8dc310772d1feb0f0873c31779150a0f045c973f" translate="yes" xml:space="preserve">
          <source>On Windows, setting priority to &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; requires elevated user privileges. Otherwise the set priority will be silently reduced to &lt;code&gt;PRIORITY_HIGH&lt;/code&gt;.</source>
          <target state="translated">Windows에서 우선 순위를 &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; 로 설정 하려면 높은 사용자 권한이 필요합니다. 그렇지 않으면 설정된 우선 순위가 자동으로 &lt;code&gt;PRIORITY_HIGH&lt;/code&gt; 로 감소합니다 .</target>
        </trans-unit>
        <trans-unit id="cec484a036adf383f0cf83afa7944fb446a84f8f" translate="yes" xml:space="preserve">
          <source>On Windows, the leading slashes for UNC paths are now included in the return value.</source>
          <target state="translated">Windows에서 UNC 경로의 선행 슬래시가 이제 리턴 값에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef45d44679240b74995b77a40348470a3214c30" translate="yes" xml:space="preserve">
          <source>On Windows, the local domain is implemented using a named pipe. The path &lt;em&gt;must&lt;/em&gt; refer to an entry in &lt;code&gt;\\?\pipe\&lt;/code&gt; or &lt;code&gt;\\.\pipe\&lt;/code&gt;. Any characters are permitted, but the latter may do some processing of pipe names, such as resolving &lt;code&gt;..&lt;/code&gt; sequences. Despite how it might look, the pipe namespace is flat. Pipes will &lt;em&gt;not persist&lt;/em&gt;. They are removed when the last reference to them is closed. Unlike Unix domain sockets, Windows will close and remove the pipe when the owning process exits.</source>
          <target state="translated">Windows에서 로컬 도메인은 명명 된 파이프를 사용하여 구현됩니다. 경로 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;\\?\pipe\&lt;/code&gt; 또는 &lt;code&gt;\\.\pipe\&lt;/code&gt; 의 항목을 참조 &lt;em&gt;해야합니다&lt;/em&gt; . 모든 문자는 허용되지만 후자는 &lt;code&gt;..&lt;/code&gt; 시퀀스 해석과 같은 파이프 이름의 일부 처리를 수행 할 수 있습니다 . 모양에도 불구하고 파이프 네임 스페이스는 평평합니다. 파이프가 &lt;em&gt;지속되지 않습니다&lt;/em&gt; . 마지막 참조가 닫히면 제거됩니다. Unix 도메인 소켓과 달리 소유 프로세스가 종료되면 Windows가 파이프를 닫고 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b4d884e9df62086a09c3c39332a23060c917a2fd" translate="yes" xml:space="preserve">
          <source>On Windows, this is a &lt;code&gt;';'&lt;/code&gt;-separated list instead.</source>
          <target state="translated">Windows에서 이것은 &lt;code&gt;';'&lt;/code&gt; 입니다.대신 분리 된 목록.</target>
        </trans-unit>
        <trans-unit id="126249b93389124fc90335a9d8ca99dd0a8df116" translate="yes" xml:space="preserve">
          <source>On Windows, using &lt;code&gt;cmd.exe&lt;/code&gt; a single quote will not work correctly because it only recognizes double &lt;code&gt;&quot;&lt;/code&gt; for quoting. In Powershell or Git bash, both &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are usable.</source>
          <target state="translated">Windows에서 &lt;code&gt;cmd.exe&lt;/code&gt; 를 사용 하면 인용 부호로 큰 &lt;code&gt;&quot;&lt;/code&gt; 만 인식되므로 작은 따옴표가 올바르게 작동하지 않습니다 . Powershell 또는 Git bash에서는 &lt;code&gt;'&lt;/code&gt; 와 &lt;code&gt;&quot;&lt;/code&gt; 를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1aa8a0561e5d494303a1665e8c1c1ffaec18bdf" translate="yes" xml:space="preserve">
          <source>On Windows, using &lt;code&gt;fs.mkdir()&lt;/code&gt; on the root directory even with recursion will result in an error:</source>
          <target state="translated">Windows에서 재귀와 함께 루트 디렉토리에서 &lt;code&gt;fs.mkdir()&lt;/code&gt; 을 사용 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95a625c5b6c3cb8c2b26fa2d6baf9cb114baf0b1" translate="yes" xml:space="preserve">
          <source>On Windows, where scope format uses an interface number:</source>
          <target state="translated">범위 형식이 인터페이스 번호를 사용하는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="b657671d262ccf19050a75fb6bc55e7a42041cd0" translate="yes" xml:space="preserve">
          <source>On a machine with 2GB of memory, consider setting this to 1536 (1.5GB) to leave some memory for other uses and avoid swapping.</source>
          <target state="translated">메모리가 2GB 인 시스템에서는이를 1536 (1.5GB)으로 설정하여 다른 용도로 일부 메모리를 남겨두고 스와핑을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="2b487baf058a8e6d5b2a94e0bf8ab5ae4ec8d476" translate="yes" xml:space="preserve">
          <source>On all other platforms, &lt;code&gt;file:&lt;/code&gt; URLs with a host name are unsupported and will result in a throw:</source>
          <target state="translated">다른 모든 플랫폼에서 호스트 이름이있는 &lt;code&gt;file:&lt;/code&gt; URL은 지원되지 않으며 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a5f22e0dff9bf222d72376b8ec44283751a3201" translate="yes" xml:space="preserve">
          <source>On all other platforms, &lt;code&gt;file:&lt;/code&gt; URLs with a hostname are unsupported and will result in a throw:</source>
          <target state="translated">다른 모든 플랫폼에서 &lt;code&gt;file:&lt;/code&gt; 호스트 이름을 가진 URL은 지원되지 않으며 다음 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="358e1630770bd86b6eaadca9e6e64f99e4bb79cd" translate="yes" xml:space="preserve">
          <source>On an error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code.</source>
          <target state="translated">오류에서 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 오브젝트이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다.</target>
        </trans-unit>
        <trans-unit id="002bfab7979fd23e069b0486d57556dd50036776" translate="yes" xml:space="preserve">
          <source>On completion, &lt;code&gt;callback&lt;/code&gt; will be called with &lt;code&gt;err&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;publicKey&lt;/code&gt; / &lt;code&gt;privateKey&lt;/code&gt; representing the generated key pair.</source>
          <target state="translated">완료되면, &lt;code&gt;callback&lt;/code&gt; 은 &lt;code&gt;err&lt;/code&gt; 이 &lt;code&gt;undefined&lt;/code&gt; 로 설정 되고 &lt;code&gt;publicKey&lt;/code&gt; / &lt;code&gt;privateKey&lt;/code&gt; 는 생성 된 키 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7886649da2b50ecb04b5356e20760a1e5cb6366c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is one of the &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS error codes&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS 오류 코드&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="d1749539bce676fcc0aa4550969b6944cf6b4d32" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the host name does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류시 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체이며 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 경우 호스트 이름이 아니라 존재하지 않는 경우 등 어떤 가능한 파일 디스크립터 아닙니다.</target>
        </trans-unit>
        <trans-unit id="944278cb905faca8676573641ea322dcf7de9025" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the hostname does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 때 호스트 이름도 존재하지 않지만,없는 경우에만 그러한 측은 파일 설명한다.</target>
        </trans-unit>
        <trans-unit id="28da3a89db66c1e49e35684df5651bd41326f739" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is one of the &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS error codes&lt;/a&gt;.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체로 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS 오류 코드&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="da16732d5d9a380f16a376ff4e654c12594bd786" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다.</target>
        </trans-unit>
        <trans-unit id="b9fd4bc944366c53ef229e3870fe19b02e44ce24" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the host name does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류시 &lt;code&gt;Promise&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체 와 함께 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 경우 호스트 이름이 아니라 존재하지 않는 경우 등 어떤 가능한 파일 디스크립터 아닙니다.</target>
        </trans-unit>
        <trans-unit id="efe534a2832704d62aaa34473a2409791c2952e2" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the hostname does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 때 호스트 이름도 존재하지 않지만,없는 경우에만 그러한 측은 파일 설명한다.</target>
        </trans-unit>
        <trans-unit id="9d274e72d3eaf33ae1f5b101442303f281721deb" translate="yes" xml:space="preserve">
          <source>On macOS, this uses &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt;&lt;code&gt;kqueue(2)&lt;/code&gt;&lt;/a&gt; for files and &lt;a href=&quot;https://developer.apple.com/documentation/coreservices/file_system_events&quot;&gt;&lt;code&gt;FSEvents&lt;/code&gt;&lt;/a&gt; for directories.</source>
          <target state="translated">macOS에서는 파일에 &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt; &lt;code&gt;kqueue(2)&lt;/code&gt; &lt;/a&gt; 를 사용 하고 디렉토리에 &lt;a href=&quot;https://developer.apple.com/documentation/coreservices/file_system_events&quot;&gt; &lt;code&gt;FSEvents&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39eb6da0166d08d18888bf5d340f82d447a083bd" translate="yes" xml:space="preserve">
          <source>On most platforms, &lt;code&gt;'rename'&lt;/code&gt; is emitted whenever a filename appears or disappears in the directory.</source>
          <target state="translated">대부분의 플랫폼에서 파일 이름이 디렉토리에 나타나거나 사라질 때마다 &lt;code&gt;'rename'&lt;/code&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4558f0d2f934a695ab52b8b29e7288d194b5266" translate="yes" xml:space="preserve">
          <source>On most systems, where scope format uses the interface name:</source>
          <target state="translated">범위 형식이 인터페이스 이름을 사용하는 대부분의 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="7b8df057d113972b6e227366e919aa409563a34a" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, if &lt;code&gt;options.detached&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the child process will be made the leader of a new process group and session. Child processes may continue running after the parent exits regardless of whether they are detached or not. See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setsid.2.html&quot;&gt;&lt;code&gt;setsid(2)&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Windows 이외의 플랫폼에서 &lt;code&gt;options.detached&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 하위 프로세스가 새 프로세스 그룹 및 세션의 리더가됩니다. 하위 프로세스는 분리 여부에 관계없이 상위 종료 후 계속 실행될 수 있습니다. 자세한 내용은 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setsid.2.html&quot;&gt; &lt;code&gt;setsid(2)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e29d2951574111945c46bba862ffa9ea86d53afb" translate="yes" xml:space="preserve">
          <source>On server &lt;code&gt;QuicSession&lt;/code&gt; instances, set to &lt;code&gt;true&lt;/code&gt; on completion of the TLS handshake if early data is enabled. On client &lt;code&gt;QuicSession&lt;/code&gt; instances, set to true on handshake completion if early data is enabled &lt;em&gt;and&lt;/em&gt; was accepted by the server.</source>
          <target state="translated">서버 &lt;code&gt;QuicSession&lt;/code&gt; 인스턴스에서 초기 데이터가 활성화 된 경우 TLS 핸드 셰이크 완료시 &lt;code&gt;true&lt;/code&gt; 로 설정합니다. 클라이언트 &lt;code&gt;QuicSession&lt;/code&gt; 인스턴스에서 초기 데이터가 활성화 &lt;em&gt;되고&lt;/em&gt; 서버에서 수락 된 경우 핸드 셰이크 완료시 true로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="1643cfbf0d28d755f6e901a412963cf366b998f6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;callback&lt;/code&gt; will now be called with an &lt;code&gt;error&lt;/code&gt; argument of &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">성공시, &lt;code&gt;callback&lt;/code&gt; 이제 호출됩니다 &lt;code&gt;error&lt;/code&gt; 의 인수 &lt;code&gt;null&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b992a9b66ecf9c509977f4e79d71ce4d083dbf97" translate="yes" xml:space="preserve">
          <source>On the client side, instances of &lt;a href=&quot;#http2_class_clienthttp2stream&quot;&gt;&lt;code&gt;ClientHttp2Stream&lt;/code&gt;&lt;/a&gt; are created when the &lt;code&gt;http2session.request()&lt;/code&gt; method is called.</source>
          <target state="translated">클라이언트 측 에서 &lt;code&gt;http2session.request()&lt;/code&gt; 메소드가 호출 될 때 &lt;a href=&quot;#http2_class_clienthttp2stream&quot;&gt; &lt;code&gt;ClientHttp2Stream&lt;/code&gt; &lt;/a&gt; 인스턴스 가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac9f26bc28901e0da3bba962837c8a762d501500" translate="yes" xml:space="preserve">
          <source>On the client, the &lt;code&gt;Http2Stream&lt;/code&gt; instance returned by &lt;code&gt;http2session.request()&lt;/code&gt; may not be immediately ready for use if the parent &lt;code&gt;Http2Session&lt;/code&gt; has not yet been fully established. In such cases, operations called on the &lt;code&gt;Http2Stream&lt;/code&gt; will be buffered until the &lt;code&gt;'ready'&lt;/code&gt; event is emitted. User code should rarely, if ever, need to handle the &lt;code&gt;'ready'&lt;/code&gt; event directly. The ready status of an &lt;code&gt;Http2Stream&lt;/code&gt; can be determined by checking the value of &lt;code&gt;http2stream.id&lt;/code&gt;. If the value is &lt;code&gt;undefined&lt;/code&gt;, the stream is not yet ready for use.</source>
          <target state="translated">클라이언트 에서 부모 &lt;code&gt;Http2Session&lt;/code&gt; 이 아직 완전히 설정되지 않은 경우 &lt;code&gt;http2session.request()&lt;/code&gt; 의해 리턴 된 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스를 즉시 사용할 수 없습니다 . 이러한 경우 &lt;code&gt;Http2Stream&lt;/code&gt; 에서 호출 된 작업 은 &lt;code&gt;'ready'&lt;/code&gt; 이벤트가 생성 될 때까지 버퍼링됩니다 . 사용자 코드가 &lt;code&gt;'ready'&lt;/code&gt; 이벤트를 직접 처리 할 필요는 거의 없습니다 . 의 준비 상태 &lt;code&gt;Http2Stream&lt;/code&gt; 은 값 확인하여 판단 할 수 &lt;code&gt;http2stream.id&lt;/code&gt; 을 . 값이 &lt;code&gt;undefined&lt;/code&gt; 인 경우 스트림을 아직 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f16439cf41d36a278e3eaf44e9d440d888072b10" translate="yes" xml:space="preserve">
          <source>On the client, the &lt;code&gt;session&lt;/code&gt; can be provided to the &lt;code&gt;session&lt;/code&gt; option of &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt;&lt;code&gt;tls.connect()&lt;/code&gt;&lt;/a&gt; to resume the connection.</source>
          <target state="translated">클라이언트에서 &lt;code&gt;session&lt;/code&gt; 을 &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt; &lt;code&gt;tls.connect()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;session&lt;/code&gt; 옵션에 제공 하여 연결을 재개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df17243448ce58a6e9d8efe145f7f94cbbd06305" translate="yes" xml:space="preserve">
          <source>On the first line, &lt;code&gt;foo.js&lt;/code&gt; loads the module &lt;code&gt;circle.js&lt;/code&gt; that is in the same directory as &lt;code&gt;foo.js&lt;/code&gt;.</source>
          <target state="translated">첫 번째 행에서 &lt;code&gt;foo.js&lt;/code&gt; 는 &lt;code&gt;foo.js&lt;/code&gt; 와 동일한 디렉토리에있는 &lt;code&gt;circle.js&lt;/code&gt; 모듈을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="3b07e2e6f8a12bd63b2638139eb922d67ad2dfaf" translate="yes" xml:space="preserve">
          <source>On the main thread, values are removed from the queue associated with the thread-safe function in an idle loop. This error indicates that an error has occurred when attempting to start the loop.</source>
          <target state="translated">기본 스레드에서 유휴 루프의 스레드 안전 기능과 관련된 대기열에서 값이 제거됩니다. 이 오류는 루프를 시작하려고 할 때 오류가 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1a21df9b2f395bf348632f07253f5adab79a3235" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;node-inspect&lt;/code&gt; can be installed locally through a package manager, as it is published on the npm registry under the same name. No source code modification is necessary if that is done.</source>
          <target state="translated">반면에 &lt;code&gt;node-inspect&lt;/code&gt; 는 동일한 이름으로 npm 레지스트리에 게시되므로 패키지 관리자를 통해 로컬로 설치할 수 있습니다. 그렇게하면 소스 코드를 수정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfb69afb09660b281005b2feb90d4b1d5ba3d6e1" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;node-inspect&lt;/code&gt; may be installed locally through a package manager, as it is published on the npm registry under the same name. No source code modification is necessary if that is done.</source>
          <target state="translated">반면 &lt;code&gt;node-inspect&lt;/code&gt; 는 npm 레지스트리에 동일한 이름으로 게시되므로 패키지 관리자를 통해 로컬로 설치할 수 있습니다. 소스 코드 수정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45d01237536f26cbcba80929de5b721832402940" translate="yes" xml:space="preserve">
          <source>On the server side, instances of &lt;a href=&quot;#http2_class_serverhttp2stream&quot;&gt;&lt;code&gt;ServerHttp2Stream&lt;/code&gt;&lt;/a&gt; are created either when:</source>
          <target state="translated">서버 측에서 &lt;a href=&quot;#http2_class_serverhttp2stream&quot;&gt; &lt;code&gt;ServerHttp2Stream&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 다음과 같은 경우에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="93fbaba0c5ebedfd2d6fa15d405cceb8572a7ff1" translate="yes" xml:space="preserve">
          <source>On the server side, user code will typically not listen for this event directly, and would instead register a handler for the &lt;code&gt;'stream'&lt;/code&gt; event emitted by the &lt;code&gt;net.Server&lt;/code&gt; or &lt;code&gt;tls.Server&lt;/code&gt; instances returned by &lt;code&gt;http2.createServer()&lt;/code&gt; and &lt;code&gt;http2.createSecureServer()&lt;/code&gt;, respectively, as in the example below:</source>
          <target state="translated">서버 측에서 사용자 코드는 일반적으로이 이벤트를 직접 수신하지 않고 &lt;code&gt;http2.createServer()&lt;/code&gt; 및 &lt;code&gt;http2.createSecureServer()&lt;/code&gt; 의해 리턴 된 net.Server 또는 &lt;code&gt;tls.Server&lt;/code&gt; 인스턴스 에서 &lt;code&gt;net.Server&lt;/code&gt; 된 &lt;code&gt;'stream'&lt;/code&gt; 이벤트에 대한 핸들러를 등록합니다. 아래 예와 같이 각각 ()</target>
        </trans-unit>
        <trans-unit id="db98c36f8419db12b0191adee61e97e682faea7d" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;destroy()&lt;/code&gt; has been called any further calls will be a no-op and no further errors except from &lt;code&gt;_destroy()&lt;/code&gt; may be emitted as &lt;code&gt;'error'&lt;/code&gt;.</source>
          <target state="translated">일단 &lt;code&gt;destroy()&lt;/code&gt; 더 호출이 어떤 조합과에서를 제외하고 더 이상의 오류가 없습니다 호출 된 &lt;code&gt;_destroy()&lt;/code&gt; 로 방출 할 수있다 &lt;code&gt;'error'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea59c46dc0807588619ccf2c0d9fae3a8fddb2c" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;destroy()&lt;/code&gt; has been called, any further calls will be a no-op and no further errors except from &lt;code&gt;_destroy()&lt;/code&gt; may be emitted as &lt;code&gt;'error'&lt;/code&gt;.</source>
          <target state="translated">일단 &lt;code&gt;destroy()&lt;/code&gt; 더 호출은 무 조작과에서를 제외하고 더 이상의 오류가 없을 것, 호출 된 &lt;code&gt;_destroy()&lt;/code&gt; 로 방출 할 수있다 &lt;code&gt;'error'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28a2e0cd081287892b62dd1e0f530cc16c1da53" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;process.connected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, it is no longer possible to send messages over the IPC channel using &lt;code&gt;process.send()&lt;/code&gt;.</source>
          <target state="translated">일단 &lt;code&gt;process.connected&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 그것은 IPC 채널 사용을 통해 메시지를 보내 더 이상 가능하다 &lt;code&gt;process.send()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed86458fc1973c9f74720793889edd1cf1b298fa" translate="yes" xml:space="preserve">
          <source>Once a &lt;code&gt;QuicSession&lt;/code&gt; transitions to the &lt;code&gt;Ready&lt;/code&gt; state, &lt;code&gt;QuicStream&lt;/code&gt; instances may be created and used to exchange application data. On a general level, all &lt;code&gt;QuicStream&lt;/code&gt; instances are simply Node.js Duplex Streams that allow bidirectional data flow between the QUIC client and server. However, the application protocol negotiated for the &lt;code&gt;QuicSession&lt;/code&gt; may alter the semantics and operation of a &lt;code&gt;QuicStream&lt;/code&gt; associated with the session. Specifically, some features of the &lt;code&gt;QuicStream&lt;/code&gt; (e.g. headers) are enabled only if the application protocol selected is known by Node.js to support those features.</source>
          <target state="translated">&lt;code&gt;QuicSession&lt;/code&gt; 이 &lt;code&gt;Ready&lt;/code&gt; 상태로 전환 되면 &lt;code&gt;QuicStream&lt;/code&gt; 인스턴스가 생성되어 애플리케이션 데이터를 교환하는 데 사용될 수 있습니다. 일반적인 수준에서 모든 &lt;code&gt;QuicStream&lt;/code&gt; 인스턴스는 단순히 QUIC 클라이언트와 서버 간의 양방향 데이터 흐름을 허용하는 Node.js 이중 스트림입니다. 그러나 &lt;code&gt;QuicSession&lt;/code&gt; 을 위해 협상 된 애플리케이션 프로토콜 은 세션과 관련된 &lt;code&gt;QuicStream&lt;/code&gt; 의 의미와 작동을 변경할 수 있습니다 . 특히, &lt;code&gt;QuicStream&lt;/code&gt; 의 일부 기능 (예 : 헤더)은 선택한 애플리케이션 프로토콜이 Node.js가 해당 기능을 지원하는 것으로 알고있는 경우에만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ffa23dc4c315219e395e0590efe1a2b70ca58a09" translate="yes" xml:space="preserve">
          <source>Once a &lt;code&gt;Socket&lt;/code&gt; has been bound to an &lt;code&gt;Http2Session&lt;/code&gt;, user code should rely solely on the API of the &lt;code&gt;Http2Session&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; 이 &lt;code&gt;Http2Session&lt;/code&gt; 에 바인딩 되면 사용자 코드는 &lt;code&gt;Http2Session&lt;/code&gt; 의 API에만 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d73920c9a9f1ea9d30889c8dfb8841df2a90c168" translate="yes" xml:space="preserve">
          <source>Once a socket has been passed to a child, the parent is no longer capable of tracking when the socket is destroyed. To indicate this, the &lt;code&gt;.connections&lt;/code&gt; property becomes &lt;code&gt;null&lt;/code&gt;. It is recommended not to use &lt;code&gt;.maxConnections&lt;/code&gt; when this occurs.</source>
          <target state="translated">소켓이 자식에게 전달되면 소켓은 소켓이 파괴 될 때 더 이상 추적 할 수 없습니다. 이를 나타 내기 위해 &lt;code&gt;.connections&lt;/code&gt; 속성이 &lt;code&gt;null&lt;/code&gt; 이 됩니다. 이 경우 &lt;code&gt;.maxConnections&lt;/code&gt; 를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a692176ad95c5de300944c8834aa875a0d87f9b1" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_setkeepalive_enable_initialdelay&quot;&gt;&lt;code&gt;socket.setKeepAlive()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당되고 연결되면 &lt;a href=&quot;net#net_socket_setkeepalive_enable_initialdelay&quot;&gt; &lt;code&gt;socket.setKeepAlive()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7f52f26999bdf868260d070323acc69b57258b58" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_setnodelay_nodelay&quot;&gt;&lt;code&gt;socket.setNoDelay()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당하고 연결되면 &lt;a href=&quot;net#net_socket_setnodelay_nodelay&quot;&gt; &lt;code&gt;socket.setNoDelay()&lt;/code&gt; &lt;/a&gt; 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="33c79533c7386872c12f4b58db6859df57263cfa" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_settimeout_timeout_callback&quot;&gt;&lt;code&gt;socket.setTimeout()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당되고 연결되면 &lt;a href=&quot;net#net_socket_settimeout_timeout_callback&quot;&gt; &lt;code&gt;socket.setTimeout()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="efd079e73c7a96e390596e9440343bcb5e17ed66" translate="yes" xml:space="preserve">
          <source>Once again, to build this example, the &lt;code&gt;myobject.cc&lt;/code&gt; file must be added to the &lt;code&gt;binding.gyp&lt;/code&gt;:</source>
          <target state="translated">이 예제를 다시 작성하려면 &lt;code&gt;myobject.cc&lt;/code&gt; 파일을 &lt;code&gt;binding.gyp&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0f447123bcb9f711d107a546941eab8691f611f" translate="yes" xml:space="preserve">
          <source>Once an event has been emitted, all listeners attached to it at the time of emitting will be called in order. This implies that any &lt;code&gt;removeListener()&lt;/code&gt; or &lt;code&gt;removeAllListeners()&lt;/code&gt; calls &lt;em&gt;after&lt;/em&gt; emitting and &lt;em&gt;before&lt;/em&gt; the last listener finishes execution will not remove them from &lt;code&gt;emit()&lt;/code&gt; in progress. Subsequent events will behave as expected.</source>
          <target state="translated">이벤트가 생성되면 생성시 연결된 모든 리스너가 순서대로 호출됩니다. 이는 방출 &lt;em&gt;후&lt;/em&gt; 및 마지막 리스너 실행이 완료 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;removeListener()&lt;/code&gt; 또는 &lt;code&gt;removeAllListeners()&lt;/code&gt; 호출 이 진행중인 &lt;code&gt;emit()&lt;/code&gt; 에서 제거되지 않음을 의미합니다 . 후속 이벤트는 예상대로 작동합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f94fa29a6ba027494d2efe834bdc10a1975cff01" translate="yes" xml:space="preserve">
          <source>Once an event is emitted, all listeners attached to it at the time of emitting are called in order. This implies that any &lt;code&gt;removeListener()&lt;/code&gt; or &lt;code&gt;removeAllListeners()&lt;/code&gt; calls &lt;em&gt;after&lt;/em&gt; emitting and &lt;em&gt;before&lt;/em&gt; the last listener finishes execution will not remove them from &lt;code&gt;emit()&lt;/code&gt; in progress. Subsequent events behave as expected.</source>
          <target state="translated">이벤트가 발생하면 해당 이벤트에 연결된 모든 리스너가 순서대로 호출됩니다. 이것은 어떤 것을 의미 &lt;code&gt;removeListener()&lt;/code&gt; 또는 &lt;code&gt;removeAllListeners()&lt;/code&gt; 호출 &lt;em&gt;한 후&lt;/em&gt; 방출하고 &lt;em&gt;전에&lt;/em&gt; 마지막 리스너가 완료 실행에서 제거되지 않습니다 &lt;code&gt;emit()&lt;/code&gt; 진행. 후속 이벤트는 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e2b0e5947e0cec9da5491e6da952ace81743900d" translate="yes" xml:space="preserve">
          <source>Once built, the binary Addon can be used from within Node.js by pointing &lt;a href=&quot;modules#modules_require_id&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; to the built &lt;code&gt;addon.node&lt;/code&gt; module:</source>
          <target state="translated">빌드 된 바이너리 &lt;code&gt;addon.node&lt;/code&gt; 은 &lt;a href=&quot;modules#modules_require_id&quot;&gt; &lt;code&gt;require()&lt;/code&gt; &lt;/a&gt; 를 빌드 된 addon.node 모듈 로 지정하여 Node.js 내에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6a5e03fd76a0c9401995bf6c32afa91bc8f4c48" translate="yes" xml:space="preserve">
          <source>Once built, the binary addon can be used from within Node.js by pointing &lt;a href=&quot;modules#modules_require_id&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; to the built &lt;code&gt;addon.node&lt;/code&gt; module:</source>
          <target state="translated">빌드되면 , 빌드 된 &lt;code&gt;addon.node&lt;/code&gt; 모듈에 &lt;a href=&quot;modules#modules_require_id&quot;&gt; &lt;code&gt;require()&lt;/code&gt; &lt;/a&gt; 를 지정하여 Node.js 내에서 바이너리 애드온을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15b98e33970016f35017b9cd3f8d13b67f71f0b2" translate="yes" xml:space="preserve">
          <source>Once called, the &lt;code&gt;http2session.pendingSettingsAck&lt;/code&gt; property will be &lt;code&gt;true&lt;/code&gt; while the session is waiting for the remote peer to acknowledge the new settings.</source>
          <target state="translated">라고하면, &lt;code&gt;http2session.pendingSettingsAck&lt;/code&gt; 속성이 될 것입니다 &lt;code&gt;true&lt;/code&gt; 세션이 새 설정을 확인하는 원격 피어를 기다리는 동안.</target>
        </trans-unit>
        <trans-unit id="b7b49eb661c1323cc9c21687a30ad06fc5aca2c4" translate="yes" xml:space="preserve">
          <source>Once compiled, the example Addon can be required and used from within Node.js:</source>
          <target state="translated">컴파일되면 Addon 예제가 필요하며 Node.js 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a257431910afb0a71f29f84ab098cccf906f7a42" translate="yes" xml:space="preserve">
          <source>Once compiled, the example addon can be required and used from within Node.js:</source>
          <target state="translated">컴파일이 완료되면 예제 애드온이 필요하며 Node.js 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c860007d4d4eedf037226ad7546486c7073ead4f" translate="yes" xml:space="preserve">
          <source>Once created the async worker can be queued for execution using the &lt;a href=&quot;#n_api_napi_queue_async_work&quot;&gt;&lt;code&gt;napi_queue_async_work&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">일단 생성되면 비동기 작업자는 &lt;a href=&quot;#n_api_napi_queue_async_work&quot;&gt; &lt;code&gt;napi_queue_async_work&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 실행을 위해 대기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fde554252391956e05e5ec8e1b886df2dade9a50" translate="yes" xml:space="preserve">
          <source>Once destroyed, the &lt;code&gt;Http2Session&lt;/code&gt; will emit the &lt;code&gt;'close'&lt;/code&gt; event. If &lt;code&gt;error&lt;/code&gt; is not undefined, an &lt;code&gt;'error'&lt;/code&gt; event will be emitted immediately before the &lt;code&gt;'close'&lt;/code&gt; event.</source>
          <target state="translated">일단 &lt;code&gt;Http2Session&lt;/code&gt; 이 파괴되면 &lt;code&gt;'close'&lt;/code&gt; 이벤트가 발생합니다. &lt;code&gt;error&lt;/code&gt; 가 정의되지 않은 경우 &lt;code&gt;'close'&lt;/code&gt; 이벤트 직전에 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b2d38c26dd12cdd65c7b3c851e009727e58fdc0" translate="yes" xml:space="preserve">
          <source>Once enabled, Node.js will treat the following as ES modules when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">활성화되면 Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 ES 모듈로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="73e0f4c1adc95b4748965a8b094cee1cd3d7802c" translate="yes" xml:space="preserve">
          <source>Once no more items are left in the queue, the idle loop must be suspended. This error indicates that the idle loop has failed to stop.</source>
          <target state="translated">대기열에 더 이상 항목이 남아 있지 않으면 유휴 루프를 일시 중단해야합니다. 이 오류는 유휴 루프가 중지되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="56f48e595782eee9bf460b4ddf8f7f4ab9ce4be3" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt;&lt;code&gt;readable._read()&lt;/code&gt;&lt;/a&gt; method has been called, it will not be called again until more data is pushed through the &lt;a href=&quot;#stream_readable_push_chunk_encoding&quot;&gt;&lt;code&gt;readable.push()&lt;/code&gt;&lt;/a&gt; method. Empty data such as empty buffers and strings will not cause &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt;&lt;code&gt;readable._read()&lt;/code&gt;&lt;/a&gt; to be called.</source>
          <target state="translated">일단 &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt; &lt;code&gt;readable._read()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 한 많은 데이터를 통해 가압 될 때까지, 이는 다시 호출되지 &lt;a href=&quot;#stream_readable_push_chunk_encoding&quot;&gt; &lt;code&gt;readable.push()&lt;/code&gt; &lt;/a&gt; 방법. 빈 버퍼 및 문자열과 같은 빈 데이터는 &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt; &lt;code&gt;readable._read()&lt;/code&gt; &lt;/a&gt; 를 호출 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d3db187cb961af709196ceb21cc18d02ae92584" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;QuicSession&lt;/code&gt; is ready, a &lt;code&gt;QuicStream&lt;/code&gt; may be created by either the client or server, and may be unidirectional or bidirectional.</source>
          <target state="translated">한 번 &lt;code&gt;QuicSession&lt;/code&gt; 가 준비하는 &lt;code&gt;QuicStream&lt;/code&gt; 는 클라이언트 또는 서버에 의해 생성 될 수 있으며, 단방향 또는 양방향 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ae60722591a3b5fc366c0deb82c1caaa5403c3" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;binding.gyp&lt;/code&gt; file has been created, use &lt;code&gt;node-gyp configure&lt;/code&gt; to generate the appropriate project build files for the current platform. This will generate either a &lt;code&gt;Makefile&lt;/code&gt; (on Unix platforms) or a &lt;code&gt;vcxproj&lt;/code&gt; file (on Windows) in the &lt;code&gt;build/&lt;/code&gt; directory.</source>
          <target state="translated">한 번 &lt;code&gt;binding.gyp&lt;/code&gt; 의 파일이 생성되어, 사용 &lt;code&gt;node-gyp configure&lt;/code&gt; 현재의 플랫폼에 해당하는 프로젝트 빌드 파일을 생성합니다. 이렇게하면 &lt;code&gt;build/&lt;/code&gt; 디렉토리 에 &lt;code&gt;Makefile&lt;/code&gt; (UNIX 플랫폼) 또는 &lt;code&gt;vcxproj&lt;/code&gt; 파일 (Windows)이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="546e3d8231cb1e62063ceda275311eaa096e3438" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;binding.gyp&lt;/code&gt; file is ready, the example Addons can be configured and built using &lt;code&gt;node-gyp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;binding.gyp&lt;/code&gt; 파일이 준비 되면 &lt;code&gt;node-gyp&lt;/code&gt; 를 사용하여 애드온 예제를 구성하고 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c72da0d7dea0742ac9e442107cf2b82db83e160c" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;binding.gyp&lt;/code&gt; file is ready, the example addons can be configured and built using &lt;code&gt;node-gyp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;binding.gyp&lt;/code&gt; 파일이 준비 되면 &lt;code&gt;node-gyp&lt;/code&gt; 를 사용하여 예제 애드온을 구성하고 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9da60f44e80b948826dc67bb1bcd8aec425f7132" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;cipher.final()&lt;/code&gt; method has been called, the &lt;code&gt;Cipher&lt;/code&gt; object can no longer be used to encrypt data. Attempts to call &lt;code&gt;cipher.final()&lt;/code&gt; more than once will result in an error being thrown.</source>
          <target state="translated">한 번 &lt;code&gt;cipher.final()&lt;/code&gt; 메소드가 호출 된의 &lt;code&gt;Cipher&lt;/code&gt; 객체는 암호화 데이터를 더 이상 사용할 수 없습니다. &lt;code&gt;cipher.final()&lt;/code&gt; 두 번 이상 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6673a87b1a83c087904fc3e05640c35e0ffaa21b" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;decipher.final()&lt;/code&gt; method has been called, the &lt;code&gt;Decipher&lt;/code&gt; object can no longer be used to decrypt data. Attempts to call &lt;code&gt;decipher.final()&lt;/code&gt; more than once will result in an error being thrown.</source>
          <target state="translated">한 번 &lt;code&gt;decipher.final()&lt;/code&gt; 메소드가 호출 된의 &lt;code&gt;Decipher&lt;/code&gt; 객체는 더 이상 해독 데이터를 사용할 수 없습니다. &lt;code&gt;decipher.final()&lt;/code&gt; 두 번 이상 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52f4dfed9ec5522e12f3e2b5320ac83fe3e4216c" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;readable._read()&lt;/code&gt; method has been called, it will not be called again until the &lt;a href=&quot;#stream_readable_push_chunk_encoding&quot;&gt;&lt;code&gt;readable.push()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">한 번 &lt;code&gt;readable._read()&lt;/code&gt; 메소드가 호출 된 때까지 다시 호출되지 않습니다 &lt;a href=&quot;#stream_readable_push_chunk_encoding&quot;&gt; &lt;code&gt;readable.push()&lt;/code&gt; &lt;/a&gt; 메소드가 호출된다.</target>
        </trans-unit>
        <trans-unit id="1a22398bb64d578f5216c8a024b94cc6d8495243" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;readline.Interface&lt;/code&gt; instance is created, the most common case is to listen for the &lt;code&gt;'line'&lt;/code&gt; event:</source>
          <target state="translated">한 번 &lt;code&gt;readline.Interface&lt;/code&gt; 의 인스턴스가 생성되고, 가장 일반적인 경우는 수신하는 &lt;code&gt;'line'&lt;/code&gt; 이벤트 :</target>
        </trans-unit>
        <trans-unit id="c00e5c746b27e93abda9669983083d6308ff5915" translate="yes" xml:space="preserve">
          <source>Once the CSR file is generated, it can either be sent to a Certificate Authority for signing or used to generate a self-signed certificate.</source>
          <target state="translated">CSR 파일이 생성되면 서명을 위해 인증 기관으로 전송되거나 자체 서명 된 인증서를 생성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c814183de4ee5ac446ac54e8c1b050300c264185" translate="yes" xml:space="preserve">
          <source>Once the certificate is generated, it can be used to generate a &lt;code&gt;.pfx&lt;/code&gt; or &lt;code&gt;.p12&lt;/code&gt; file:</source>
          <target state="translated">인증서가 생성되면 &lt;code&gt;.pfx&lt;/code&gt; 또는 &lt;code&gt;.p12&lt;/code&gt; 파일 을 생성하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96a60a169bcc053e92f04ade6da11c5c2f124427" translate="yes" xml:space="preserve">
          <source>Once the client receives the &lt;code&gt;SETTINGS&lt;/code&gt; frame from the server indicating that the extended CONNECT may be used, it may send &lt;code&gt;CONNECT&lt;/code&gt; requests that use the &lt;code&gt;':protocol'&lt;/code&gt; HTTP/2 pseudo-header:</source>
          <target state="translated">클라이언트 가 확장 CONNECT를 사용할 수 있음을 나타내는 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임을 서버에서 수신하면 &lt;code&gt;':protocol'&lt;/code&gt; HTTP / 2 의사 헤더 를 사용하는 &lt;code&gt;CONNECT&lt;/code&gt; 요청을 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23163b4a5b1c314b71549df1d1817513f8d243c4" translate="yes" xml:space="preserve">
          <source>Once the debugger is run, a breakpoint will occur at line 3:</source>
          <target state="translated">디버거가 실행되면 3 번 줄에 중단 점이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06333cf16cd00d4e14a36bbf306106e9fe7a8631" translate="yes" xml:space="preserve">
          <source>Once the number of threads making use of a &lt;code&gt;napi_threadsafe_function&lt;/code&gt; reaches zero, no further threads can start making use of it by calling &lt;code&gt;napi_acquire_threadsafe_function()&lt;/code&gt;. In fact, all subsequent API calls associated with it, except &lt;code&gt;napi_release_threadsafe_function()&lt;/code&gt;, will return an error value of &lt;code&gt;napi_closing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;napi_threadsafe_function&lt;/code&gt; 을 사용하는 스레드 수가 0에 도달하면 &lt;code&gt;napi_acquire_threadsafe_function()&lt;/code&gt; 을 호출하여 더 이상 사용할 수 없습니다 . 실제로 &lt;code&gt;napi_release_threadsafe_function()&lt;/code&gt; 제외한 모든 후속 API 호출 은 오류 값 &lt;code&gt;napi_closing&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="697685409a68c8f36ef5cf0d11b15316e24adea9" translate="yes" xml:space="preserve">
          <source>Once the server is now shared between the parent and child, some connections can be handled by the parent and some by the child.</source>
          <target state="translated">서버가 이제 부모와 자식간에 공유되면 일부 연결은 부모와 자식에 의해 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c3869b5e878ba059e38cec56d8324aec191fbe" translate="yes" xml:space="preserve">
          <source>Once the socket is created, calling &lt;a href=&quot;#dgram_socket_bind_port_address_callback&quot;&gt;&lt;code&gt;socket.bind()&lt;/code&gt;&lt;/a&gt; will instruct the socket to begin listening for datagram messages. When &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are not passed to &lt;a href=&quot;#dgram_socket_bind_port_address_callback&quot;&gt;&lt;code&gt;socket.bind()&lt;/code&gt;&lt;/a&gt; the method will bind the socket to the &quot;all interfaces&quot; address on a random port (it does the right thing for both &lt;code&gt;udp4&lt;/code&gt; and &lt;code&gt;udp6&lt;/code&gt; sockets). The bound address and port can be retrieved using &lt;a href=&quot;#dgram_socket_address&quot;&gt;&lt;code&gt;socket.address().address&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#dgram_socket_address&quot;&gt;&lt;code&gt;socket.address().port&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓이 작성되면 &lt;a href=&quot;#dgram_socket_bind_port_address_callback&quot;&gt; &lt;code&gt;socket.bind()&lt;/code&gt; &lt;/a&gt; 를 호출하면 소켓이 데이터 그램 메시지 청취를 시작하도록 지시합니다. 시 &lt;code&gt;address&lt;/code&gt; 와 &lt;code&gt;port&lt;/code&gt; 전달되지 않습니다 &lt;a href=&quot;#dgram_socket_bind_port_address_callback&quot;&gt; &lt;code&gt;socket.bind()&lt;/code&gt; &lt;/a&gt; 메소드는 (그것이 모두 옳은 일을하는 임의의 포트에 &quot;모든 인터페이스&quot;주소로 소켓을 바인딩 &lt;code&gt;udp4&lt;/code&gt; 및 &lt;code&gt;udp6&lt;/code&gt; 소켓). 바인딩 된 주소와 포트는 &lt;a href=&quot;#dgram_socket_address&quot;&gt; &lt;code&gt;socket.address().address&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#dgram_socket_address&quot;&gt; &lt;code&gt;socket.address().port&lt;/code&gt; &lt;/a&gt; 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9dd7de7e1c91ec7335bd144924ed7a2032f6d8f" translate="yes" xml:space="preserve">
          <source>Once the source code has been written, it must be compiled into the binary &lt;code&gt;addon.node&lt;/code&gt; file. To do so, create a file called &lt;code&gt;binding.gyp&lt;/code&gt; in the top-level of the project describing the build configuration of the module using a JSON-like format. This file is used by &lt;a href=&quot;https://github.com/nodejs/node-gyp&quot;&gt;node-gyp&lt;/a&gt; &amp;mdash; a tool written specifically to compile Node.js Addons.</source>
          <target state="translated">소스 코드가 작성되면 바이너리 &lt;code&gt;addon.node&lt;/code&gt; 파일 로 컴파일해야 합니다. 이렇게하려면 JSON과 같은 형식을 사용하여 모듈의 빌드 구성을 설명하는 프로젝트 최상위 레벨에 &lt;code&gt;binding.gyp&lt;/code&gt; 라는 파일을 작성하십시오 . 이 파일은 Node.js 애드온을 컴파일하기 위해 특별히 작성된 도구 인 &lt;a href=&quot;https://github.com/nodejs/node-gyp&quot;&gt;node-gyp에서&lt;/a&gt; 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c1ec49d0c8b41620816e4acc922a0bb808c5323" translate="yes" xml:space="preserve">
          <source>Once the source code has been written, it must be compiled into the binary &lt;code&gt;addon.node&lt;/code&gt; file. To do so, create a file called &lt;code&gt;binding.gyp&lt;/code&gt; in the top-level of the project describing the build configuration of the module using a JSON-like format. This file is used by &lt;a href=&quot;https://github.com/nodejs/node-gyp&quot;&gt;node-gyp&lt;/a&gt;, a tool written specifically to compile Node.js addons.</source>
          <target state="translated">소스 코드가 작성되면 바이너리 &lt;code&gt;addon.node&lt;/code&gt; 파일 로 컴파일해야 합니다. 이렇게하려면 JSON과 유사한 형식을 사용하여 모듈의 빌드 구성을 설명하는 프로젝트의 최상위 수준에 &lt;code&gt;binding.gyp&lt;/code&gt; 라는 파일을 만듭니다 . 이 파일은 Node.js 애드온을 컴파일하기 위해 특별히 작성된 도구 인 &lt;a href=&quot;https://github.com/nodejs/node-gyp&quot;&gt;node-gyp&lt;/a&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcbfb2f9203bc4c118a7a189cee574fa849e67c8" translate="yes" xml:space="preserve">
          <source>Once the total size of the internal read buffer reaches the threshold specified by &lt;code&gt;highWaterMark&lt;/code&gt;, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt;&lt;code&gt;readable._read()&lt;/code&gt;&lt;/a&gt; method that is used to fill the read buffer).</source>
          <target state="translated">내부 읽기 버퍼의 총 크기가 &lt;code&gt;highWaterMark&lt;/code&gt; 에 지정된 임계 값에 도달하면 스트림은 현재 버퍼링 된 데이터를 사용할 수있을 때까지 기본 리소스에서 데이터 읽기를 일시적으로 중지합니다 (즉, 스트림이 내부 &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt; &lt;code&gt;readable._read()&lt;/code&gt; &lt;/a&gt; 호출을 중지합니다. ) 읽기 버퍼를 채우는 데 사용되는 메서드).</target>
        </trans-unit>
        <trans-unit id="3ab067988cb8464f26b4eae4e55c63ed294db10f" translate="yes" xml:space="preserve">
          <source>Once the total size of the internal read buffer reaches the threshold specified by &lt;code&gt;highWaterMark&lt;/code&gt;, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal &lt;code&gt;readable._read()&lt;/code&gt; method that is used to fill the read buffer).</source>
          <target state="translated">내부 읽기 버퍼의 총 크기가 &lt;code&gt;highWaterMark&lt;/code&gt; 로 지정된 임계 값에 도달하면 현재 버퍼링 된 데이터를 사용할 수있을 때까지 (즉, 스트림에서 내부 &lt;code&gt;readable._read()&lt;/code&gt; 호출을 중지합니다.) 스트림은 기본 리소스에서 데이터 읽기를 일시적으로 중지합니다. ) 는 읽기 버퍼를 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad2356ff474e553c5985844e65af0e12776a0075" translate="yes" xml:space="preserve">
          <source>Once this code is invoked, the Node.js application will not terminate until the &lt;code&gt;readline.Interface&lt;/code&gt; is closed because the interface waits for data to be received on the &lt;code&gt;input&lt;/code&gt; stream.</source>
          <target state="translated">이 코드가 호출되면 &lt;code&gt;readline.Interface&lt;/code&gt; 가 닫힐 때까지 Node.js 애플리케이션이 종료되지 않습니다 . 인터페이스는 &lt;code&gt;input&lt;/code&gt; 스트림 에서 데이터가 수신되기를 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="8fc3a43e7dfa64098d2c09722663a4214268b6eb" translate="yes" xml:space="preserve">
          <source>Once this has been set, all modules must conform to a policy manifest file passed to the flag:</source>
          <target state="translated">이것이 설정되면 모든 모듈은 플래그에 전달 된 정책 매니페스트 파일을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc5c3dc70f48938a8559564ae3f486a2c451dc83" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;node::IsolateData&lt;/code&gt; instance that contains information that could be shared by multiple &lt;code&gt;node::Environment&lt;/code&gt;s that use the same &lt;code&gt;v8::Isolate&lt;/code&gt;. Currently, no testing if performed for this scenario.</source>
          <target state="translated">동일한 &lt;code&gt;v8::Isolate&lt;/code&gt; 를 사용하는 여러 &lt;code&gt;node::Environment&lt;/code&gt; 가 공유 할 수있는 정보를 포함하는 하나의 &lt;code&gt;node::IsolateData&lt;/code&gt; 인스턴스입니다 . 현재이 시나리오에 대해 수행 된 경우 테스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3519b2f373a34f74cf339382a013f3959d2d1fd2" translate="yes" xml:space="preserve">
          <source>One can provide the context by &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;&quot;contextifying&quot;&lt;/a&gt; a sandbox object. The sandboxed code treats any property in the sandbox like a global variable. Any changes to global variables caused by the sandboxed code are reflected in the sandbox object.</source>
          <target state="translated">샌드 박스 객체를 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;&quot;&lt;/a&gt; 컨텍스트 화 &quot; 하여 컨텍스트를 제공 할 수 있습니다 . 샌드 박스 코드는 샌드 박스의 모든 속성을 전역 변수처럼 취급합니다. 샌드 박스 코드로 인한 전역 변수의 변경 사항은 샌드 박스 객체에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="187c68bb8a264278e9942712292d71404fc271e4" translate="yes" xml:space="preserve">
          <source>One can provide the context by &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;&lt;em&gt;contextifying&lt;/em&gt;&lt;/a&gt; an object. The invoked code treats any property in the context like a global variable. Any changes to global variables caused by the invoked code are reflected in the context object.</source>
          <target state="translated">하나는하여 컨텍스트를 제공 할 수 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;&lt;em&gt;contextifying&lt;/em&gt;&lt;/a&gt; 개체를. 호출 된 코드는 컨텍스트의 모든 속성을 전역 변수처럼 취급합니다. 호출 된 코드로 인한 전역 변수 변경 사항은 컨텍스트 개체에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="351de5baff893d4ca3128780d0df95fddb77cebd" translate="yes" xml:space="preserve">
          <source>One convenient use of &lt;code&gt;buf.swap16()&lt;/code&gt; is to perform a fast in-place conversion between UTF-16 little-endian and UTF-16 big-endian:</source>
          <target state="translated">&lt;code&gt;buf.swap16()&lt;/code&gt; 의 편리한 사용법 중 하나 는 UTF-16 리틀 엔디안과 UTF-16 빅 엔디안 사이에서 빠른 내부 변환을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d7552355d0153f8ac68346e623f5900cfc80651" translate="yes" xml:space="preserve">
          <source>One difference is that, unlike the main thread, bootstrapping within a worker is done within the event loop. So the event loop utilization is immediately available once the worker's script begins execution.</source>
          <target state="translated">한 가지 차이점은 주 스레드와 달리 작업자 내에서 부트 스트랩이 이벤트 루프 내에서 수행된다는 것입니다. 따라서 작업자의 스크립트가 실행을 시작하면 이벤트 루프 사용률을 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a507f120a673bd98a67457d61883d39ae2de1c" translate="yes" xml:space="preserve">
          <source>One important caveat is that if the &lt;code&gt;Readable&lt;/code&gt; stream emits an error during processing, the &lt;code&gt;Writable&lt;/code&gt; destination &lt;em&gt;is not closed&lt;/em&gt; automatically. If an error occurs, it will be necessary to &lt;em&gt;manually&lt;/em&gt; close each stream in order to prevent memory leaks.</source>
          <target state="translated">중요한 한 가지주의 사항은 처리 중에 &lt;code&gt;Readable&lt;/code&gt; 스트림에서 오류가 발생하면 &lt;code&gt;Writable&lt;/code&gt; 대상 &lt;em&gt;이&lt;/em&gt; 자동으로 &lt;em&gt;닫히지 않는다는 것&lt;/em&gt; 입니다. 오류가 발생 하면 메모리 누수를 방지하기 위해 각 스트림 을 &lt;em&gt;수동으로&lt;/em&gt; 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe5f45681577d4b399916698594c49e0ceea86c0" translate="yes" xml:space="preserve">
          <source>One of the most common errors raised when listening is &lt;code&gt;EADDRINUSE&lt;/code&gt;. This happens when another server is already listening on the requested &lt;code&gt;port&lt;/code&gt;/&lt;code&gt;path&lt;/code&gt;/&lt;code&gt;handle&lt;/code&gt;. One way to handle this would be to retry after a certain amount of time:</source>
          <target state="translated">청취 할 때 발생하는 가장 일반적인 오류 중 하나는 &lt;code&gt;EADDRINUSE&lt;/code&gt; 입니다. 다른 서버가 이미 요청 된 &lt;code&gt;port&lt;/code&gt; / &lt;code&gt;path&lt;/code&gt; / &lt;code&gt;handle&lt;/code&gt; 에서 수신 대기 중일 때 발생합니다 . 이를 처리하는 한 가지 방법은 특정 시간 후에 다시 시도하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa135875bf0bd9017b9a196225817756a41d1812" translate="yes" xml:space="preserve">
          <source>One or more &lt;a href=&quot;crypto#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt;&lt;code&gt;crypto.scrypt()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;crypto#crypto_crypto_scryptsync_password_salt_keylen_options&quot;&gt;&lt;code&gt;crypto.scryptSync()&lt;/code&gt;&lt;/a&gt; parameters are outside their legal range.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;crypto#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt; &lt;code&gt;crypto.scrypt()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;crypto#crypto_crypto_scryptsync_password_salt_keylen_options&quot;&gt; &lt;code&gt;crypto.scryptSync()&lt;/code&gt; &lt;/a&gt; 매개 변수가 올바른 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="6a2562b4150db0fb4119fd85c182ca57d6db6994" translate="yes" xml:space="preserve">
          <source>One possible use case would be as follows:</source>
          <target state="translated">가능한 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="802b0ff3ec61eb809530d7709928925cab0089e0" translate="yes" xml:space="preserve">
          <source>Online Certificate Status Protocol (OCSP)</source>
          <target state="translated">온라인 인증서 상태 프로토콜 (OCSP)</target>
        </trans-unit>
        <trans-unit id="bb47b123548d590aa8c68a0428d092779ba76f44" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;enumerable &quot;own&quot; properties&lt;/a&gt; are considered.</source>
          <target state="translated">만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;열거 &quot;자신의&quot;특성이&lt;/a&gt; 고려된다.</target>
        </trans-unit>
        <trans-unit id="63f3372d23540753a3045f20a2de73ac6d501f2c" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;file://&lt;/code&gt; URLs are supported. A specifier like &lt;code&gt;'https://example.com/app.js'&lt;/code&gt; may be supported by browsers but it is not supported in Node.js.</source>
          <target state="translated">만 &lt;code&gt;file://&lt;/code&gt; URL이 지원됩니다. &lt;code&gt;'https://example.com/app.js'&lt;/code&gt; 와 같은 지정자는 브라우저에서 지원 될 수 있지만 Node.js에서는 지원되지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
