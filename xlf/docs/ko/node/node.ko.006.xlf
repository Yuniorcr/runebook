<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="node">
    <body>
      <group id="node">
        <trans-unit id="d0f81aa1380f9f4733f23b21def09dcc23089d6d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolvedTarget&lt;/em&gt; is contained in &lt;em&gt;packageURL&lt;/em&gt;, then</source>
          <target state="translated">경우 &lt;em&gt;resolvedTarget가&lt;/em&gt; 에 포함되어 &lt;em&gt;PACKAGEURL&lt;/em&gt; , 다음</target>
        </trans-unit>
        <trans-unit id="e5f5cc713d0076b8f8c168a8156d8890dbb2300e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;resolvedURL&lt;/em&gt; contains any percent encodings of &lt;em&gt;&quot;/&quot;&lt;/em&gt; or &lt;em&gt;&quot;\&quot;&lt;/em&gt; (&lt;em&gt;&quot;%2f&quot;&lt;/em&gt; and &lt;em&gt;&quot;%5C&quot;&lt;/em&gt; respectively), then</source>
          <target state="translated">&lt;em&gt;resolvedURL&lt;/em&gt; 에 &lt;em&gt;&quot;/&quot;&lt;/em&gt; 또는 &lt;em&gt;&quot;\&quot;&lt;/em&gt; (각각 &lt;em&gt;&quot;% 2f&quot;&lt;/em&gt; 및 &lt;em&gt;&quot;% 5C&quot;&lt;/em&gt; )의 퍼센트 인코딩이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="c3c5cd03aecf162fd5cc79f200bd54c85bf5ef51" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scopeURL&lt;/em&gt; ends in a &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; path segment, return &lt;strong&gt;null&lt;/strong&gt;.</source>
          <target state="translated">경우 &lt;em&gt;scopeURL는&lt;/em&gt; A의 끝 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 경로 세그먼트, 반환 &lt;strong&gt;널 (null)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a32d8a8494066b9c331308a9de76dd6cfdb33e2c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;specifier&lt;/em&gt; is a valid URL, then</source>
          <target state="translated">경우 &lt;em&gt;지정자는&lt;/em&gt; 다음 유효한 URL입니다</target>
        </trans-unit>
        <trans-unit id="488b105d4a05d51c891376a14f3cd7430f2c0005" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subpath&lt;/em&gt; has non-zero length and &lt;em&gt;target&lt;/em&gt; does not end with &lt;em&gt;&quot;/&quot;&lt;/em&gt;, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;서브 패스가&lt;/em&gt; 아닌 제로의 길이가 &lt;em&gt;목표&lt;/em&gt; 로 끝나지 않습니다를 &lt;em&gt;&quot;/&quot;&lt;/em&gt; , 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="8eac144fa46e78f012a0b80015514759addbc976" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; does not start with &lt;em&gt;&quot;./&quot;&lt;/em&gt;, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;목표&lt;/em&gt; 로 시작하지 않는 &lt;em&gt;&quot;./&quot;&lt;/em&gt; , 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c3875ce3373cebbce8bed7ea926620173bf5943b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; is a String, then</source>
          <target state="translated">경우 &lt;em&gt;대상은&lt;/em&gt; 다음 문자열입니다</target>
        </trans-unit>
        <trans-unit id="23e9d9969ad4fb7cdf18a1301ae7b5b00f519d6b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;target&lt;/em&gt; or &lt;em&gt;subpath&lt;/em&gt; contain any &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; segments including &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; percent-encoding, throw a &lt;em&gt;Module Not Found&lt;/em&gt; error.</source>
          <target state="translated">경우 &lt;em&gt;대상&lt;/em&gt; 또는 &lt;em&gt;서브 패스가&lt;/em&gt; 모든 포함 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 를 포함하여 세그먼트 &lt;em&gt;&quot;node_modules&quot;&lt;/em&gt; 퍼센트 인코딩을 던져 &lt;em&gt;모듈을 찾을 수 없음&lt;/em&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="bddfda64499ff1f71febb28ebb761f079fbed16c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;targetValue&lt;/em&gt; is not a String, continue the loop.</source>
          <target state="translated">&lt;em&gt;targetValue&lt;/em&gt; 가 문자열이 아닌 경우 루프를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="746818083e540de70308980c76bffb23bc64c121" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.cjs&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;의 URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;.cjs&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="d00425f0ac5d3e619c3975396989aaeea52f6f8a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; ends in &lt;em&gt;&quot;.mjs&quot;&lt;/em&gt;, then</source>
          <target state="translated">만약 &lt;em&gt;의 URL&lt;/em&gt; 의 끝에 &lt;em&gt;&quot;.mjs&quot;&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="2657e59e2d4c8d4505b3ca335596c032d243a675" translate="yes" xml:space="preserve">
          <source>If Node.js is spawned with an IPC channel, the &lt;code&gt;process.send()&lt;/code&gt; method can be used to send messages to the parent process. Messages will be received as a &lt;a href=&quot;child_process#child_process_event_message&quot;&gt;&lt;code&gt;'message'&lt;/code&gt;&lt;/a&gt; event on the parent's &lt;a href=&quot;child_process#child_process_class_childprocess&quot;&gt;&lt;code&gt;ChildProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Node.js가 IPC 채널과 함께 생성되면 &lt;code&gt;process.send()&lt;/code&gt; 메소드를 사용하여 상위 프로세스로 메시지를 보낼 수 있습니다. 메시지는 부모의 &lt;a href=&quot;child_process#child_process_class_childprocess&quot;&gt; &lt;code&gt;ChildProcess&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;child_process#child_process_event_message&quot;&gt; &lt;code&gt;'message'&lt;/code&gt; &lt;/a&gt; 이벤트 로 수신됩니다 .</target>
        </trans-unit>
        <trans-unit id="2546faee0b34d4ad8c17f27675b90b30ee617f3b" translate="yes" xml:space="preserve">
          <source>If Node.js was compiled &lt;em&gt;without&lt;/em&gt;&lt;a href=&quot;cli#cli_node_options_options&quot;&gt;&lt;code&gt;NODE_OPTIONS&lt;/code&gt;&lt;/a&gt; support (shown in &lt;a href=&quot;#process_process_config&quot;&gt;&lt;code&gt;process.config&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;process.allowedNodeEnvironmentFlags&lt;/code&gt; will contain what &lt;em&gt;would have&lt;/em&gt; been allowable.</source>
          <target state="translated">Node.js를 컴파일하면 &lt;em&gt;없이 &lt;/em&gt;&lt;a href=&quot;cli#cli_node_options_options&quot;&gt; &lt;code&gt;NODE_OPTIONS&lt;/code&gt; 의&lt;/a&gt; (에 표시된 지원 &lt;a href=&quot;#process_process_config&quot;&gt; &lt;code&gt;process.config&lt;/code&gt; &lt;/a&gt; ), &lt;code&gt;process.allowedNodeEnvironmentFlags&lt;/code&gt; 는 무엇을 포함 할 &lt;em&gt;것이다&lt;/em&gt; 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="70bb3d5051fa757d796c052f5fd051a2fe7444a6" translate="yes" xml:space="preserve">
          <source>If Node.js was not spawned with an IPC channel, &lt;code&gt;process.send()&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js가 IPC 채널로 생성되지 않은 경우 &lt;code&gt;process.send()&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0480dd820a4caf6a7a01add9db3c1ee81d9d7d2" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#http2_event_request&quot;&gt;&lt;code&gt;'request'&lt;/code&gt;&lt;/a&gt; listener is registered or &lt;a href=&quot;#http2_http2_createsecureserver_options_onrequesthandler&quot;&gt;&lt;code&gt;http2.createSecureServer()&lt;/code&gt;&lt;/a&gt; is supplied a callback function, the &lt;code&gt;'checkContinue'&lt;/code&gt; event is emitted each time a request with an HTTP &lt;code&gt;Expect: 100-continue&lt;/code&gt; is received. If this event is not listened for, the server will automatically respond with a status &lt;code&gt;100 Continue&lt;/code&gt; as appropriate.</source>
          <target state="translated">경우 &lt;a href=&quot;#http2_event_request&quot;&gt; &lt;code&gt;'request'&lt;/code&gt; &lt;/a&gt; 리스너가 등록 또는 &lt;a href=&quot;#http2_http2_createsecureserver_options_onrequesthandler&quot;&gt; &lt;code&gt;http2.createSecureServer()&lt;/code&gt; &lt;/a&gt; 콜백 기능을 제공하는 &lt;code&gt;'checkContinue'&lt;/code&gt; 이벤트가 함께 HTTP 요청마다 출사 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 수신된다. 이 이벤트가 수신되지 않으면, 서버는 자동으로 &lt;code&gt;100 Continue&lt;/code&gt; 상태로 자동 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="3c6666474bf74c83f95eb13a8a69c877db182322" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#http2_event_request&quot;&gt;&lt;code&gt;'request'&lt;/code&gt;&lt;/a&gt; listener is registered or &lt;a href=&quot;#http2_http2_createserver_options_onrequesthandler&quot;&gt;&lt;code&gt;http2.createServer()&lt;/code&gt;&lt;/a&gt; is supplied a callback function, the &lt;code&gt;'checkContinue'&lt;/code&gt; event is emitted each time a request with an HTTP &lt;code&gt;Expect: 100-continue&lt;/code&gt; is received. If this event is not listened for, the server will automatically respond with a status &lt;code&gt;100 Continue&lt;/code&gt; as appropriate.</source>
          <target state="translated">경우 &lt;a href=&quot;#http2_event_request&quot;&gt; &lt;code&gt;'request'&lt;/code&gt; &lt;/a&gt; 리스너가 등록 또는 &lt;a href=&quot;#http2_http2_createserver_options_onrequesthandler&quot;&gt; &lt;code&gt;http2.createServer()&lt;/code&gt; &lt;/a&gt; 콜백 기능을 제공하는 &lt;code&gt;'checkContinue'&lt;/code&gt; 이벤트가 함께 HTTP 요청마다 출사 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 수신된다. 이 이벤트가 수신되지 않으면, 서버는 자동으로 &lt;code&gt;100 Continue&lt;/code&gt; 상태로 자동 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="696d38c8122ee517b2457a839a5b2713312b81a6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; is switched into flowing mode and there are no consumers available to handle the data, that data will be lost. This can occur, for instance, when the &lt;code&gt;readable.resume()&lt;/code&gt; method is called without a listener attached to the &lt;code&gt;'data'&lt;/code&gt; event, or when a &lt;code&gt;'data'&lt;/code&gt; event handler is removed from the stream.</source>
          <target state="translated">경우 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 모드를 흐르는로 전환하고 데이터를 처리 할 수없는 소비자들은 데이터가 손실됩니다, 없습니다. 예를 들어 &lt;code&gt;'data'&lt;/code&gt; 이벤트에 리스너가 연결되지 않은 상태에서 &lt;code&gt;readable.resume()&lt;/code&gt; 메서드가 호출 되거나 &lt;code&gt;'data'&lt;/code&gt; 이벤트 핸들러가 스트림에서 제거 될 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76bfcfe08560cc38ebb9027a9665da61eb3fd24d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FileHandle&lt;/code&gt; is not closed using the &lt;code&gt;filehandle.close()&lt;/code&gt; method, it might automatically close the file descriptor and will emit a process warning, thereby helping to prevent memory leaks. Please do not rely on this behavior in your code because it is unreliable and your file may not be closed. Instead, always explicitly close &lt;code&gt;FileHandle&lt;/code&gt;s. Node.js may change this behavior in the future.</source>
          <target state="translated">경우 &lt;code&gt;FileHandle&lt;/code&gt; 은 Using 닫혀 있지 않습니다 &lt;code&gt;filehandle.close()&lt;/code&gt; 메소드를 자동으로 가까운 파일 설명함으로써 메모리 누수를 방지하는 데 도움 프로세스 경고를 방출 할 수 있습니다. 신뢰할 수없고 파일이 닫히지 않을 수 있으므로 코드에서이 동작에 의존하지 마십시오. 대신, 항상 명시 적으로 &lt;code&gt;FileHandle&lt;/code&gt; 을 닫으십시오 . Node.js는 나중에이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7636f5713fef8dfdd138e0285e154aff46051a3c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Readable&lt;/code&gt; stream pipes into a &lt;code&gt;Writable&lt;/code&gt; stream when &lt;code&gt;Writable&lt;/code&gt; emits an error, the &lt;code&gt;Readable&lt;/code&gt; stream will be unpiped.</source>
          <target state="translated">경우 &lt;code&gt;Readable&lt;/code&gt; 에 스트림 파이프 &lt;code&gt;Writable&lt;/code&gt; 스트림이 때 &lt;code&gt;Writable&lt;/code&gt; 오류를 방출의 &lt;code&gt;Readable&lt;/code&gt; 스트림은 unpiped 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="78672ea6b1dc7ca181368392e827ff3e0f3423b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;callback&lt;/code&gt; function is provided, it is called with the arguments &lt;code&gt;(error, stdout, stderr)&lt;/code&gt;. On success, &lt;code&gt;error&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;. On error, &lt;code&gt;error&lt;/code&gt; will be an instance of &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;error.code&lt;/code&gt; property will be the exit code of the child process while &lt;code&gt;error.signal&lt;/code&gt; will be set to the signal that terminated the process. Any exit code other than &lt;code&gt;0&lt;/code&gt; is considered to be an error.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되는, 그것은 인수로 호출 &lt;code&gt;(error, stdout, stderr)&lt;/code&gt; . 성공하면 &lt;code&gt;error&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;error&lt;/code&gt; 가 발생하면 error 는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 됩니다 . &lt;code&gt;error.code&lt;/code&gt; 의 동안 속성은 자식 프로세스의 종료 코드가 될 것이다 &lt;code&gt;error.signal&lt;/code&gt; 이 프로세스가 종료 신호로 설정됩니다. &lt;code&gt;0&lt;/code&gt; 이외의 종료 코드 는 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d71bf697bd9ed17929e16c7fe1ca5b3ec8d9ee88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;callback&lt;/code&gt; function is provided, the bytes are generated asynchronously and the &lt;code&gt;callback&lt;/code&gt; function is invoked with two arguments: &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;buf&lt;/code&gt;. If an error occurs, &lt;code&gt;err&lt;/code&gt; will be an &lt;code&gt;Error&lt;/code&gt; object; otherwise it is &lt;code&gt;null&lt;/code&gt;. The &lt;code&gt;buf&lt;/code&gt; argument is a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt; containing the generated bytes.</source>
          <target state="translated">경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되는, 바이트는 비동기 적으로 발생하고 &lt;code&gt;callback&lt;/code&gt; 함수는 두 개의 인수로 호출 : &lt;code&gt;err&lt;/code&gt; 와 &lt;code&gt;buf&lt;/code&gt; . 에러가 발생하면 &lt;code&gt;err&lt;/code&gt; 는 &lt;code&gt;Error&lt;/code&gt; 객체가됩니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;buf&lt;/code&gt; 인수는 인 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 생성 된 바이트를 포함.</target>
        </trans-unit>
        <trans-unit id="1fe1f30b4c9b95923fed5f2232de9d45764b8782" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;publicKeyEncoding&lt;/code&gt; or &lt;code&gt;privateKeyEncoding&lt;/code&gt; was specified, this function behaves as if &lt;a href=&quot;#crypto_keyobject_export_options&quot;&gt;&lt;code&gt;keyObject.export()&lt;/code&gt;&lt;/a&gt; had been called on its result. Otherwise, the respective part of the key is returned as a &lt;a href=&quot;#crypto_class_keyobject&quot;&gt;&lt;code&gt;KeyObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;publicKeyEncoding&lt;/code&gt; 또는 &lt;code&gt;privateKeyEncoding&lt;/code&gt; 가 지정이 기능의 동작합니다는 것처럼 &lt;a href=&quot;#crypto_keyobject_export_options&quot;&gt; &lt;code&gt;keyObject.export()&lt;/code&gt; &lt;/a&gt; 의 결과라고했다. 그렇지 않으면 키의 각 부분이 &lt;a href=&quot;#crypto_class_keyobject&quot;&gt; &lt;code&gt;KeyObject&lt;/code&gt; &lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="51deb4bb79f95f2aaa6a873a1acfac78b4899391" translate="yes" xml:space="preserve">
          <source>If a call to &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;stream.write(chunk)&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;'drain'&lt;/code&gt; event will be emitted when it is appropriate to resume writing data to the stream.</source>
          <target state="translated">를 호출하면 &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;stream.write(chunk)&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;'drain'&lt;/code&gt; 이벤트는 스트림에 데이터를 기록 재개 할 적절한 때 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="19d0f4f13350bd3ee24d918da0e3399f81fec5d4" translate="yes" xml:space="preserve">
          <source>If a child process waits to read all of its input, the child will not continue until this stream has been closed via &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">자식 프로세스가 모든 입력을 읽기를 기다리는 경우 &lt;code&gt;end()&lt;/code&gt; 를 통해이 스트림이 닫힐 때까지 자식은 계속되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="716b4434ddf0060b829e790aa3148ff698f2d32a" translate="yes" xml:space="preserve">
          <source>If a client connection emits an &lt;code&gt;'error'&lt;/code&gt; event, it will be forwarded here. Listener of this event is responsible for closing/destroying the underlying socket. For example, one may wish to more gracefully close the socket with a custom HTTP response instead of abruptly severing the connection.</source>
          <target state="translated">클라이언트 연결에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트 가 발생하면 여기에 전달됩니다. 이 이벤트의 리스너는 기본 소켓을 닫거나 파기합니다. 예를 들어, 갑자기 연결을 끊는 대신 사용자 정의 HTTP 응답으로 소켓을 더 우아하게 닫으려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9eaec49bed36b6ca87fda5a245016810370aec" translate="yes" xml:space="preserve">
          <source>If a file descriptor is specified as the &lt;code&gt;path&lt;/code&gt;, it will not be closed automatically.</source>
          <target state="translated">파일 디스크립터가 &lt;code&gt;path&lt;/code&gt; 로 지정되면 자동으로 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f96071afe83eecc5cfcae2d7a7ee17d1e0affb31" translate="yes" xml:space="preserve">
          <source>If a package has no exports, setting &lt;code&gt;&quot;exports&quot;: false&lt;/code&gt; can be used instead of &lt;code&gt;&quot;exports&quot;: {}&lt;/code&gt; to indicate the package does not intend for submodules to be exposed.</source>
          <target state="translated">패키지에 내보내기가 없으면 &lt;code&gt;&quot;exports&quot;: {}&lt;/code&gt; 대신 &lt;code&gt;&quot;exports&quot;: false&lt;/code&gt; 설정을 사용 하여 패키지가 하위 모듈을 노출하지 않을 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="befb840f0c304a4ba984a452b3cf589e473513c9" translate="yes" xml:space="preserve">
          <source>If a specifier does not have a corresponding argument, it is not replaced:</source>
          <target state="translated">지정자에 해당 인수가없는 경우 대체되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c8cb689864546346536757da11d32272821e8a8" translate="yes" xml:space="preserve">
          <source>If a zero-length string is passed as &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt;, the current working directory will be used instead of the zero-length strings.</source>
          <target state="translated">길이가 0 인 문자열이 &lt;code&gt;from&lt;/code&gt; 또는 &lt;code&gt;to&lt;/code&gt; 로 전달되면 길이가 0 인 문자열 대신 현재 작업 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72c0aa7997742e011b6c6546031b1bafcecaca22" translate="yes" xml:space="preserve">
          <source>If accuracy is important, use &lt;code&gt;cluster.settings&lt;/code&gt;.</source>
          <target state="translated">정확성이 중요하면 &lt;code&gt;cluster.settings&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaa668d37d6ad8ca97da96b8f2b8381c75117854" translate="yes" xml:space="preserve">
          <source>If additional information is required upon an API returning a failed status, it can be obtained by calling &lt;code&gt;napi_get_last_error_info&lt;/code&gt;.</source>
          <target state="translated">API가 실패 상태를 리턴 할 때 추가 정보가 필요한 경우 &lt;code&gt;napi_get_last_error_info&lt;/code&gt; 를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71cfeeeefb7ddfea89821aaea3da4b7924a82121" translate="yes" xml:space="preserve">
          <source>If after processing all given &lt;code&gt;path&lt;/code&gt; segments an absolute path has not yet been generated, the current working directory is used.</source>
          <target state="translated">주어진 모든 &lt;code&gt;path&lt;/code&gt; 세그먼트를 처리 한 후에 절대 경로가 아직 생성되지 않은 경우 현재 작업 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8187873900b537e036c18f24394fdf7c2e0317c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;AssertionError&lt;/code&gt; is thrown and a value is provided for the &lt;code&gt;message&lt;/code&gt; parameter, the value of &lt;code&gt;message&lt;/code&gt; will be appended to the &lt;code&gt;AssertionError&lt;/code&gt; message:</source>
          <target state="translated">는 IF &lt;code&gt;AssertionError&lt;/code&gt; 를가 발생되고, 값이 제공된다 &lt;code&gt;message&lt;/code&gt; 파라미터의 값 &lt;code&gt;message&lt;/code&gt; 받는 첨부한다 &lt;code&gt;AssertionError&lt;/code&gt; 메시지 :</target>
        </trans-unit>
        <trans-unit id="d0b02b176e8a20c608d564c5cc70e6b95982af42" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EventEmitter&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; have at least one listener registered for the &lt;code&gt;'error'&lt;/code&gt; event, and an &lt;code&gt;'error'&lt;/code&gt; event is emitted, the error is thrown, a stack trace is printed, and the Node.js process exits.</source>
          <target state="translated">는 IF &lt;code&gt;EventEmitter&lt;/code&gt; 는 않습니다 &lt;em&gt;하지&lt;/em&gt; 에 등록 된 적어도 하나 개의 수신기가 &lt;code&gt;'error'&lt;/code&gt; 이벤트를, 그리고 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 방출되는 오류는 스택 추적이 인쇄되어 발생하고, Node.js를 프로세스가 종료된다.</target>
        </trans-unit>
        <trans-unit id="a9365a584afade646fe0d5b6c0c7d3bdfc0ab158" translate="yes" xml:space="preserve">
          <source>If an asynchronous operation is needed for logging, it is possible to keep track of what caused the asynchronous operation using the information provided by AsyncHooks itself. The logging should then be skipped when it was the logging itself that caused AsyncHooks callback to call. By doing this the otherwise infinite recursion is broken.</source>
          <target state="translated">로깅에 비동기 작업이 필요한 경우 AsyncHooks 자체에서 제공 한 정보를 사용하여 비동기 작업의 원인을 추적 할 수 있습니다. 그런 다음 로깅 자체가 AsyncHooks 콜백을 호출 한 원인 일 때 로깅을 건너 뛰어야합니다. 이렇게하면 무한 재귀가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c79166257f7aba2eefa6b4c14e6926c016bcf315" translate="yes" xml:space="preserve">
          <source>If an error is thrown and it is the same type as that specified by the &lt;code&gt;error&lt;/code&gt; parameter, then an &lt;code&gt;AssertionError&lt;/code&gt; is thrown. If the error is of a different type, or if the &lt;code&gt;error&lt;/code&gt; parameter is undefined, the error is propagated back to the caller.</source>
          <target state="translated">오류가 발생하고 &lt;code&gt;error&lt;/code&gt; 매개 변수로 지정된 유형과 동일한 유형 인 경우 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생합니다. 오류가 다른 유형이거나 &lt;code&gt;error&lt;/code&gt; 매개 변수가 정의되지 않은 경우 오류는 호출자에게 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="35ce67c2f991bd2d7b89402a112bf7ff79f1656d" translate="yes" xml:space="preserve">
          <source>If an error occurs an &lt;code&gt;Error&lt;/code&gt; will be thrown, otherwise the derived key will be returned as a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에러가 발생하면 &lt;code&gt;Error&lt;/code&gt; 가 발생하고, 그렇지 않으면 파생 된 키가 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b6e1e560aaa002865abca4a1a9306578fe0ed21" translate="yes" xml:space="preserve">
          <source>If an error occurs while attempting to read the file data, the &lt;code&gt;Http2Stream&lt;/code&gt; will be closed using an &lt;code&gt;RST_STREAM&lt;/code&gt; frame using the standard &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; code. If the &lt;code&gt;onError&lt;/code&gt; callback is defined, then it will be called. Otherwise the stream will be destroyed.</source>
          <target state="translated">파일 데이터를 읽는 중 오류가 발생 하면 표준 &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; 코드 를 사용하여 &lt;code&gt;RST_STREAM&lt;/code&gt; 프레임을 사용 하여 &lt;code&gt;Http2Stream&lt;/code&gt; 이 닫힙니다 . 상기 중간 &lt;code&gt;onError&lt;/code&gt; 콜백이 정의되고, 다음 호출 할 것입니다. 그렇지 않으면 스트림이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="df9e85a9260ce43a2b0e0f5761178c04dc16852e" translate="yes" xml:space="preserve">
          <source>If an uncaught exception occurs during execution of the callback, then &lt;code&gt;after&lt;/code&gt; will run &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted or a &lt;code&gt;domain&lt;/code&gt;'s handler runs.</source>
          <target state="translated">캐치되지 않는 예외가 콜백의 실행 중에 발생하는 경우, &lt;code&gt;after&lt;/code&gt; 실행 &lt;em&gt;한 후 &lt;/em&gt; &lt;code&gt;'uncaughtException'&lt;/code&gt; 이벤트가 방출이나되는 &lt;code&gt;domain&lt;/code&gt; 의 핸들러가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9abd45ba34315ef2e5f5a8166fc8ee079e4c8bd9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;AsyncHook&lt;/code&gt; callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all &lt;code&gt;'uncaughtException'&lt;/code&gt; listeners are removed, thus forcing the process to exit. The &lt;code&gt;'exit'&lt;/code&gt; callbacks will still be called unless the application is run with &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt;, in which case a stack trace will be printed and the application exits, leaving a core file.</source>
          <target state="translated">어떤 경우 &lt;code&gt;AsyncHook&lt;/code&gt; 의 콜백 던져, 응용 프로그램이 스택 트레이스를 출력하고 프로그램을 종료합니다. 종료 경로는 포착되지 않은 예외의 경로를 따르지만 모든 &lt;code&gt;'uncaughtException'&lt;/code&gt; 리스너가 제거되므로 프로세스가 강제 종료됩니다. &lt;code&gt;'exit'&lt;/code&gt; 응용 프로그램이 실행되지 않는 콜백은 여전히 호출됩니다 &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; 스택 추적이 인쇄 될 경우에, 그리고 응용 프로그램이 종료 코어 파일을 떠나.</target>
        </trans-unit>
        <trans-unit id="a3c2fb5aeb80ff1e6a756547b4e43eebdf07b06d" translate="yes" xml:space="preserve">
          <source>If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an &lt;code&gt;'error'&lt;/code&gt; event is emitted on the returned request object. As with all &lt;code&gt;'error'&lt;/code&gt; events, if no listeners are registered the error will be thrown.</source>
          <target state="translated">요청 중에 오류가 발생하면 (DNS 확인, TCP 수준 오류 또는 실제 HTTP 구문 분석 오류 등) 반환 된 요청 개체에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 발생합니다. 모든 &lt;code&gt;'error'&lt;/code&gt; 이벤트 와 마찬가지로 리스너가 등록되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06830b91ba14a727d7329b340f5f6d345019e8ff" translate="yes" xml:space="preserve">
          <source>If any of the accessibility checks fail, an &lt;code&gt;Error&lt;/code&gt; will be thrown. Otherwise, the method will return &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">접근성 검사 중 하나라도 실패하면 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다. 그렇지 않으면 메소드는 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7e1c37de1fe1d451576d6332685c82c3afa01dbe" translate="yes" xml:space="preserve">
          <source>If available on the operating system, the following constants are exported in &lt;code&gt;os.constants.dlopen&lt;/code&gt;. See &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;&lt;code&gt;dlopen(3)&lt;/code&gt;&lt;/a&gt; for detailed information.</source>
          <target state="translated">운영 체제에서 사용 가능한 경우 다음 상수가 &lt;code&gt;os.constants.dlopen&lt;/code&gt; 으로 내보내집니다 . 자세한 내용은 &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt; &lt;code&gt;dlopen(3)&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="596758a71652411a2826cbd0e26ead1fd7f3fb53" translate="yes" xml:space="preserve">
          <source>If available, dynamically load a pointer to the function using &lt;code&gt;uv_dlsym()&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;uv_dlsym()&lt;/code&gt; 사용하여 함수에 대한 포인터를 동적으로로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="69820efdd034979319e195a688ede9f09c30edb5" translate="yes" xml:space="preserve">
          <source>If binding fails, an &lt;code&gt;'error'&lt;/code&gt; event is generated. In rare case (e.g. attempting to bind with a closed socket), an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">바인딩이 실패하면 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 생성됩니다. 드문 경우이지만 (예 : 닫힌 소켓으로 바인딩하려고하면) &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e68c86b6833301dfcce43bc788132f9c75a181e6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;'readable'&lt;/code&gt; and &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; are used at the same time, &lt;code&gt;'readable'&lt;/code&gt; takes precedence in controlling the flow, i.e. &lt;code&gt;'data'&lt;/code&gt; will be emitted only when &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; is called. The &lt;code&gt;readableFlowing&lt;/code&gt; property would become &lt;code&gt;false&lt;/code&gt;. If there are &lt;code&gt;'data'&lt;/code&gt; listeners when &lt;code&gt;'readable'&lt;/code&gt; is removed, the stream will start flowing, i.e. &lt;code&gt;'data'&lt;/code&gt; events will be emitted without calling &lt;code&gt;.resume()&lt;/code&gt;.</source>
          <target state="translated">경우 모두 &lt;code&gt;'readable'&lt;/code&gt; 및 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 동시에 사용되며, &lt;code&gt;'readable'&lt;/code&gt; 즉, 흐름 제어에 우선한다 &lt;code&gt;'data'&lt;/code&gt; 때만 발광한다 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 호출된다. &lt;code&gt;readableFlowing&lt;/code&gt; 속성이 될 것입니다 &lt;code&gt;false&lt;/code&gt; . 이 경우 &lt;code&gt;'data'&lt;/code&gt; 때 청취자 &lt;code&gt;'readable'&lt;/code&gt; 제거되고, 스트림이 흐르는 시작됩니다, 즉 &lt;code&gt;'data'&lt;/code&gt; 이벤트는 호출하지 않고 방출됩니다 &lt;code&gt;.resume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb11ecdf178c1cb711e0a8eae9d9fb2fb97443b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;fill&lt;/code&gt; and &lt;code&gt;encoding&lt;/code&gt; are specified, the allocated &lt;code&gt;Buffer&lt;/code&gt; will be initialized by calling &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt;&lt;code&gt;buf.fill(fill, encoding)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;fill&lt;/code&gt; 과 &lt;code&gt;encoding&lt;/code&gt; 지정되며, 상기 할당 된 &lt;code&gt;Buffer&lt;/code&gt; 호출하여 초기화한다 &lt;a href=&quot;#buffer_buf_fill_value_offset_end_encoding&quot;&gt; &lt;code&gt;buf.fill(fill, encoding)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4093e8ebac89975d459aaad8fd6437be71fb3935" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;url&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; are specified, the objects are merged, with the &lt;code&gt;options&lt;/code&gt; properties taking precedence.</source>
          <target state="translated">두 경우 &lt;code&gt;url&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 지정, 객체는 함께 병합 &lt;code&gt;options&lt;/code&gt; 우선 순위를 복용 속성.</target>
        </trans-unit>
        <trans-unit id="6c4d968b22b1df3d2e79d51e79be1c024e9931b6" translate="yes" xml:space="preserve">
          <source>If both filename and error object are passed to &lt;code&gt;writeReport()&lt;/code&gt; the error object must be the second parameter.</source>
          <target state="translated">filename과 error 객체가 &lt;code&gt;writeReport()&lt;/code&gt; 전달 되면 error 객체는 두 번째 매개 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="781d2eb2d380d26e4ab2a5dfd0c0ef2dfe2b3db4" translate="yes" xml:space="preserve">
          <source>If clients advertise support for tickets, the server will send them. The server can disable tickets by supplying &lt;code&gt;require('constants').SSL_OP_NO_TICKET&lt;/code&gt; in &lt;code&gt;secureOptions&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 티켓 지원을 광고하면 서버가 티켓을 보냅니다. 서버 제공하여 비활성화 티켓을 수행 할 수 있습니다 &lt;code&gt;require('constants').SSL_OP_NO_TICKET&lt;/code&gt; 에서 &lt;code&gt;secureOptions&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="de92f9a3546d5ea09f3d735ebbcce48b7c9578b8" translate="yes" xml:space="preserve">
          <source>If domains are in use, then all &lt;strong&gt;new&lt;/strong&gt;&lt;code&gt;EventEmitter&lt;/code&gt; objects (including Stream objects, requests, responses, etc.) will be implicitly bound to the active domain at the time of their creation.</source>
          <target state="translated">도메인을 사용중인 경우 모든 &lt;strong&gt;새 &lt;/strong&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 객체 (Stream 객체, 요청, 응답 등)는 생성시 활성 도메인에 암시 적으로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3ef976ebda6d70a05ce4c354ddd516615f12d1" translate="yes" xml:space="preserve">
          <source>If either of the following conditions is true, then the literal string &lt;code&gt;//&lt;/code&gt; will be appended to &lt;code&gt;result&lt;/code&gt;:</source>
          <target state="translated">다음 조건 중 하나에 해당하면 &lt;code&gt;//&lt;/code&gt; 리터럴 문자열 이 &lt;code&gt;result&lt;/code&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="1edb794d4a1d426d551d17375aabde00b3477150" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;--no-deprecation&lt;/code&gt; or &lt;code&gt;--no-warnings&lt;/code&gt; command line flags are used, or if the &lt;code&gt;process.noDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;&lt;em&gt;prior&lt;/em&gt; to the first deprecation warning, the &lt;code&gt;util.deprecate()&lt;/code&gt; method does nothing.</source>
          <target state="translated">두 경우 &lt;code&gt;--no-deprecation&lt;/code&gt; 또는 &lt;code&gt;--no-warnings&lt;/code&gt; 명령 행 플래그가 사용된다, 또는 경우 &lt;code&gt;process.noDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; &lt;em&gt;이전에&lt;/em&gt; 첫 번째 중단 경고 때문에, &lt;code&gt;util.deprecate()&lt;/code&gt; 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98aa649de478c0f47590b643bddfcf1f1c12b6e6" translate="yes" xml:space="preserve">
          <source>If formatting elements (e.g. &lt;code&gt;%d&lt;/code&gt;) are not found in the first string then &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;&lt;code&gt;util.inspect()&lt;/code&gt;&lt;/a&gt; is called on each argument and the resulting string values are concatenated. See &lt;a href=&quot;util#util_util_format_format_args&quot;&gt;&lt;code&gt;util.format()&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">첫 번째 문자열에서 서식 지정 요소 (예 : &lt;code&gt;%d&lt;/code&gt; )를 찾지 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt; &lt;code&gt;util.inspect()&lt;/code&gt; &lt;/a&gt; 각 인수에서 util.inspect () 가 호출되고 결과 문자열 값이 연결됩니다. 자세한 내용은 &lt;a href=&quot;util#util_util_format_format_args&quot;&gt; &lt;code&gt;util.format()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef6daec57d79612028ad2d0945f9175e3244f8b8" translate="yes" xml:space="preserve">
          <source>If given a &lt;code&gt;sandbox&lt;/code&gt; object, the &lt;code&gt;vm.createContext()&lt;/code&gt; method will &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;prepare that sandbox&lt;/a&gt; so that it can be used in calls to &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedsandbox_options&quot;&gt;&lt;code&gt;vm.runInContext()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#vm_script_runincontext_contextifiedsandbox_options&quot;&gt;&lt;code&gt;script.runInContext()&lt;/code&gt;&lt;/a&gt;. Inside such scripts, the &lt;code&gt;sandbox&lt;/code&gt; object will be the global object, retaining all of its existing properties but also having the built-in objects and functions any standard &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;global object&lt;/a&gt; has. Outside of scripts run by the vm module, global variables will remain unchanged.</source>
          <target state="translated">주어진 경우 &lt;code&gt;sandbox&lt;/code&gt; 객체를 상기 &lt;code&gt;vm.createContext()&lt;/code&gt; 메소드는 것 &lt;a href=&quot;#vm_what_does_it_mean_to_contextify_an_object&quot;&gt;즉 샌드 준비&lt;/a&gt; 가로 통화에 사용될 수 있도록 &lt;a href=&quot;#vm_vm_runincontext_code_contextifiedsandbox_options&quot;&gt; &lt;code&gt;vm.runInContext()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#vm_script_runincontext_contextifiedsandbox_options&quot;&gt; &lt;code&gt;script.runInContext()&lt;/code&gt; &lt;/a&gt; . 이러한 스크립트 내부의 &lt;code&gt;sandbox&lt;/code&gt; 객체는 기존의 모든 속성을 유지뿐만 아니라 내장 객체 및 표준 기능을 가진, 전역 객체가 될 것이다 &lt;a href=&quot;https://es5.github.io/#x15.1&quot;&gt;전역 객체가&lt;/a&gt; 있다. vm 모듈에서 실행하는 스크립트 외부에서는 전역 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79789a5254327b894116d434ddd2c5bab864e280" translate="yes" xml:space="preserve">
          <source>If it is necessary to terminate the Node.js process due to an error condition, throwing an &lt;em&gt;uncaught&lt;/em&gt; error and allowing the process to terminate accordingly is safer than calling &lt;code&gt;process.exit()&lt;/code&gt;.</source>
          <target state="translated">오류 조건으로 인해 Node.js 프로세스를 종료해야하는 경우 &lt;em&gt;catch되지 않은&lt;/em&gt; 오류가 발생하여 프로세스가 종료되도록 허용하는 것이 &lt;code&gt;process.exit()&lt;/code&gt; 호출하는 것보다 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="49d1021878ab098e47def050c750dc4a07325a5f" translate="yes" xml:space="preserve">
          <source>If it is not found there, then it moves to the parent directory, and so on, until the root of the file system is reached.</source>
          <target state="translated">찾을 수 없으면 파일 시스템의 루트에 도달 할 때까지 상위 디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="818c99e33248acd389a413f2d1a026a1130b44fa" translate="yes" xml:space="preserve">
          <source>If listeners are attached or removed using &lt;code&gt;.on('message')&lt;/code&gt;, the port will be &lt;code&gt;ref()&lt;/code&gt;ed and &lt;code&gt;unref()&lt;/code&gt;ed automatically depending on whether listeners for the event exist.</source>
          <target state="translated">&lt;code&gt;.on('message')&lt;/code&gt; 을 사용하여 리스너를 연결하거나 제거 하면 이벤트 리스너의 존재 여부에 따라 포트가 자동으로 &lt;code&gt;ref()&lt;/code&gt; 및 &lt;code&gt;unref()&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="76636b0f1944e7d4d859fa8d9c5002000eb7958f" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;#http_event_response&quot;&gt;&lt;code&gt;'response'&lt;/code&gt;&lt;/a&gt; handler is added, then the response will be entirely discarded. However, if a &lt;a href=&quot;#http_event_response&quot;&gt;&lt;code&gt;'response'&lt;/code&gt;&lt;/a&gt; event handler is added, then the data from the response object &lt;strong&gt;must&lt;/strong&gt; be consumed, either by calling &lt;code&gt;response.read()&lt;/code&gt; whenever there is a &lt;code&gt;'readable'&lt;/code&gt; event, or by adding a &lt;code&gt;'data'&lt;/code&gt; handler, or by calling the &lt;code&gt;.resume()&lt;/code&gt; method. Until the data is consumed, the &lt;code&gt;'end'&lt;/code&gt; event will not fire. Also, until the data is read it will consume memory that can eventually lead to a 'process out of memory' error.</source>
          <target state="translated">&lt;a href=&quot;#http_event_response&quot;&gt; &lt;code&gt;'response'&lt;/code&gt; &lt;/a&gt; 핸들러가 추가 되지 않으면 응답이 완전히 삭제됩니다. 그러나 &lt;a href=&quot;#http_event_response&quot;&gt; &lt;code&gt;'response'&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러가 추가되면 &lt;code&gt;'readable'&lt;/code&gt; 이벤트 가있을 때마다 &lt;code&gt;response.read()&lt;/code&gt; 를 호출 하거나 &lt;code&gt;'data'&lt;/code&gt; 핸들러를 추가 하여 응답 오브젝트의 데이터를 이용 &lt;strong&gt;해야합니다&lt;/strong&gt; . &lt;code&gt;.resume()&lt;/code&gt; 메소드 를 호출하여 데이터가 소비 될 때까지 &lt;code&gt;'end'&lt;/code&gt; 이벤트가 발생하지 않습니다. 또한 데이터를 읽을 때까지 메모리를 소비하여 결국 '메모리 부족 프로세스'오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db48c4caed0a332d402ecbd0b488c664a849a378" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;'timeout'&lt;/code&gt; listener is added to the request, the response, or the server, then &lt;a href=&quot;http2&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt;s are destroyed when they time out. If a handler is assigned to the request, the response, or the server's &lt;code&gt;'timeout'&lt;/code&gt; events, timed out sockets must be handled explicitly.</source>
          <target state="translated">요청, 응답 또는 서버에 &lt;code&gt;'timeout'&lt;/code&gt; 리스너가 추가 되지 않으면 &lt;a href=&quot;http2&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 시간 초과되면 소멸됩니다. 핸들러가 요청, 응답 또는 서버의 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트에 지정된 경우 제한 시간이 초과 된 소켓을 명시 적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dec6a027c28bdbcb29abb4bffcb70b1c450217e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;'timeout'&lt;/code&gt; listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If a handler is assigned to the request, the response, or the server's &lt;code&gt;'timeout'&lt;/code&gt; events, timed out sockets must be handled explicitly.</source>
          <target state="translated">요청, 응답 또는 서버에 &lt;code&gt;'timeout'&lt;/code&gt; 리스너가 추가 되지 않으면 소켓이 시간 초과되면 소멸됩니다. 핸들러가 요청, 응답 또는 서버의 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트에 지정된 경우 제한 시간이 초과 된 소켓을 명시 적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3355f8e5210700f25827723bdd2c6be50b786d0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;callback&lt;/code&gt; function is provided and the message cannot be sent, an &lt;code&gt;'error'&lt;/code&gt; event will be emitted by the &lt;a href=&quot;#child_process_child_process&quot;&gt;&lt;code&gt;ChildProcess&lt;/code&gt;&lt;/a&gt; object. This can happen, for instance, when the child process has already exited.</source>
          <target state="translated">어떠한 경우 &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않고, 메시지가 전송 될 수 없다 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 방출 될 &lt;a href=&quot;#child_process_child_process&quot;&gt; &lt;code&gt;ChildProcess&lt;/code&gt; 의&lt;/a&gt; 개체. 예를 들어 자식 프로세스가 이미 종료 된 경우 이런 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ea7a606cf8671c22ba56a6c0d8af64a399a3eb" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;path&lt;/code&gt; segments are passed, &lt;code&gt;path.resolve()&lt;/code&gt; will return the absolute path of the current working directory.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 세그먼트가 전달 되지 않으면 &lt;code&gt;path.resolve()&lt;/code&gt; 는 현재 작업 디렉토리의 절대 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9c2de4f19bb732c3f0d152de8a5b8d7d4bffebf" translate="yes" xml:space="preserve">
          <source>If no encoding is specified, then the raw buffer is returned.</source>
          <target state="translated">인코딩을 지정하지 않으면 원시 버퍼가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="588b09130834e51d612150950f7d586519ce31b1" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;filehandle.read()&lt;/code&gt; calls are made on a file handle and then a &lt;code&gt;filehandle.readFile()&lt;/code&gt; call is made, the data will be read from the current position till the end of the file. It doesn't always read from the beginning of the file.</source>
          <target state="translated">&lt;code&gt;filehandle.read()&lt;/code&gt; 하나 이상의 filehandle.read () 호출이 &lt;code&gt;filehandle.readFile()&lt;/code&gt; 후 filehandle.readFile () 호출이 수행되면 파일의 끝까지 현재 위치에서 데이터를 읽습니다. 항상 파일의 처음부터 읽지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a4cdac4387721b7c6d9782075b4c0d38991bb7d" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;filehandle.write()&lt;/code&gt; calls are made on a file handle and then a &lt;code&gt;filehandle.writeFile()&lt;/code&gt; call is made, the data will be written from the current position till the end of the file. It doesn't always write from the beginning of the file.</source>
          <target state="translated">&lt;code&gt;filehandle.write()&lt;/code&gt; 하나 이상의 filehandle.write () 호출이 작성된 후 &lt;code&gt;filehandle.writeFile()&lt;/code&gt; 호출이 수행되면 데이터는 현재 위치에서 파일 끝까지 기록됩니다. 항상 파일의 처음부터 쓰지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e451e4e3dec3d1e916f8a3d903d896ecce3e5cb" translate="yes" xml:space="preserve">
          <source>If one or more &lt;code&gt;label&lt;/code&gt;s are provided, those are printed first without the additional indentation.</source>
          <target state="translated">하나 이상의 &lt;code&gt;label&lt;/code&gt; 이 제공되면 추가 들여 쓰기없이 먼저 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="fafad16c3d8a65bb35e08a7835ca2753a62ace44" translate="yes" xml:space="preserve">
          <source>If only one argument is passed to &lt;code&gt;util.format()&lt;/code&gt;, it is returned as it is without any formatting:</source>
          <target state="translated">하나의 인수 만 &lt;code&gt;util.format()&lt;/code&gt; 전달되면 형식화없이 그대로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="65eb9aab5f2c0420b47aca35dbc4e5131b16b281" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.address&lt;/code&gt; is a string describing the address to which a network connection failed.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.address&lt;/code&gt; 는 네트워크 연결이 실패한 주소를 설명하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="09cdb4b5fc901c93bd81eddf6470508e4d3ad573" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.dest&lt;/code&gt; is the file path destination when reporting a file system error.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.dest&lt;/code&gt; 는 파일 시스템 오류를보고 할 때 파일 경로 대상입니다.</target>
        </trans-unit>
        <trans-unit id="b4d9083b9c76cf66522d9b360b5cbacf03ff7e17" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.info&lt;/code&gt; is an object with details about the error condition.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.info&lt;/code&gt; 는 오류 조건에 대한 세부 사항이있는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="b515af4cb1d6427479831ff8c31be0200be62954" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.path&lt;/code&gt; is a string containing a relevant invalid pathname.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;error.path&lt;/code&gt; 는 유효하지 않은 관련 경로 이름이 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8f1124d661572f078414a138f0bd00a3bb201f75" translate="yes" xml:space="preserve">
          <source>If present, &lt;code&gt;error.port&lt;/code&gt; is the network connection port that is not available.</source>
          <target state="translated">있는 경우 &lt;code&gt;error.port&lt;/code&gt; 는 사용할 수없는 네트워크 연결 포트입니다.</target>
        </trans-unit>
        <trans-unit id="4028035ae455f9d1c611d0d9611d12c32c7539df" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.</source>
          <target state="translated">존재하는 경우, 복사 작업은 COW (Copy-On-Write) 참조 링크를 작성하려고 시도합니다. 기본 플랫폼이 COW (Copy-On-Write)를 지원하지 않으면 대체 복사 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4565bcf227554bcec4fb67361b463bd0162b40c7" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will attempt to create a copy-on-write reflink. If the underlying platform does not support copy-on-write, then the operation will fail with an error.</source>
          <target state="translated">존재하는 경우, 복사 작업은 COW (Copy-On-Write) 참조 링크를 작성하려고 시도합니다. 기본 플랫폼이 기록 중 복사를 지원하지 않으면 작업이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="111d49a62014241bc6035d869eb1ed1d88540442" translate="yes" xml:space="preserve">
          <source>If present, the copy operation will fail with an error if the destination path already exists.</source>
          <target state="translated">있는 경우 대상 경로가 이미 있으면 복사 작업이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="873d68575189af0d0837643c7a4f9fafeebaade7" translate="yes" xml:space="preserve">
          <source>If provided, the &lt;code&gt;payload&lt;/code&gt; must be a &lt;code&gt;Buffer&lt;/code&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt; containing 8 bytes of data that will be transmitted with the &lt;code&gt;PING&lt;/code&gt; and returned with the ping acknowledgment.</source>
          <target state="translated">제공되는 경우 &lt;code&gt;payload&lt;/code&gt; 는 &lt;code&gt;PING&lt;/code&gt; 과 함께 전송되고 핑 확인과 함께 반환 될 8 바이트의 데이터를 포함 하는 &lt;code&gt;Buffer&lt;/code&gt; , &lt;code&gt;TypedArray&lt;/code&gt; 또는 &lt;code&gt;DataView&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0411c641c6a25de72690be397bf9163af37a5e95" translate="yes" xml:space="preserve">
          <source>If returned as a string, no decoding of the query string is performed. If returned as an object, both keys and values are decoded.</source>
          <target state="translated">문자열로 반환되면 쿼리 문자열의 디코딩이 수행되지 않습니다. 객체로 반환되면 키와 값이 모두 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="30f5a3d64923e554e03e9538c444b7eb6e64f821" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt; then V8 will choose an appropriate size of the thread pool based on the number of online processors.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 으로 설정하면 V8은 온라인 프로세서 수에 따라 적절한 크기의 스레드 풀을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2dbbdc2030105ff8389b56a9a53a36b9214cf5d0" translate="yes" xml:space="preserve">
          <source>If set to a non-number value, or set to a negative number, stack traces will not capture any frames.</source>
          <target state="translated">숫자가 아닌 값으로 설정하거나 음수로 설정하면 스택 추적이 프레임을 캡처하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2310dc593206400dba7fbfc90d82faac7c44fa3" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt; or a validation function. See &lt;a href=&quot;#assert_assert_throws_fn_error_message&quot;&gt;&lt;code&gt;assert.throws()&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; 또는 유효성 검증 함수일 수 있습니다. 자세한 내용은 &lt;a href=&quot;#assert_assert_throws_fn_error_message&quot;&gt; &lt;code&gt;assert.throws()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8bb4684775cedbd549e8f47ef9575c77e254eab8" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, a validation function, a validation object where each property will be tested for strict deep equality, or an instance of error where each property will be tested for strict deep equality including the non-enumerable &lt;code&gt;message&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; properties. When using an object, it is also possible to use a regular expression, when validating against a string property. See below for examples.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; , 유효성 검증 함수, 각 특성이 엄격한 완전 동등성을 테스트하는 유효성 검증 오브젝트 또는 각 특성을 열거 할 수없는 &lt;code&gt;message&lt;/code&gt; 포함하여 엄격한 완전 동등성을 테스트하는 오류 인스턴스 일 수 있습니다. 그리고 &lt;code&gt;name&lt;/code&gt; 속성. 객체를 사용할 때 문자열 속성에 대해 유효성을 검사 할 때 정규식을 사용할 수도 있습니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca540d2d12b0a2843f6e0a3a615df4b350d599e5" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;error&lt;/code&gt; can be a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt;&lt;code&gt;RegExp&lt;/code&gt;&lt;/a&gt;, a validation function, an object where each property will be tested for, or an instance of error where each property will be tested for including the non-enumerable &lt;code&gt;message&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; properties.</source>
          <target state="translated">지정된 경우 &lt;code&gt;error&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt; &lt;code&gt;Class&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions&quot;&gt; &lt;code&gt;RegExp&lt;/code&gt; &lt;/a&gt; , 유효성 검증 함수, 각 특성을 테스트 할 오브젝트 또는 열거 불가능한 &lt;code&gt;message&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 특성 을 포함하여 각 특성을 테스트 할 오류 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e483ef4da139406d2cb5576248f8f8dab3da0123" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;message&lt;/code&gt; will be appended to the message provided by the &lt;code&gt;AssertionError&lt;/code&gt; if the &lt;code&gt;fn&lt;/code&gt; call fails to throw or in case the error validation fails.</source>
          <target state="translated">지정된 경우, &lt;code&gt;fn&lt;/code&gt; 호출이 실패하거나 오류 유효성 검증에 실패하는 경우 &lt;code&gt;AssertionError&lt;/code&gt; 에서 제공 한 메시지에 &lt;code&gt;message&lt;/code&gt; 가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="40ef9cb0ba617de6594c16374723716ca8364dd8" translate="yes" xml:space="preserve">
          <source>If specified, &lt;code&gt;message&lt;/code&gt; will be the message provided by the &lt;code&gt;AssertionError&lt;/code&gt; if the &lt;code&gt;asyncFn&lt;/code&gt; fails to reject.</source>
          <target state="translated">지정된 경우, &lt;code&gt;message&lt;/code&gt; 에 의해 제공되는 메시지가 될 것입니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 경우 &lt;code&gt;asyncFn&lt;/code&gt; 이 거부되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25e438c74edb89edb96e2a5ee192d899ce1fcd06" translate="yes" xml:space="preserve">
          <source>If specified, the &lt;code&gt;callback&lt;/code&gt; function is registered as a handler for the &lt;code&gt;'close'&lt;/code&gt; event.</source>
          <target state="translated">지정된 경우 &lt;code&gt;callback&lt;/code&gt; 함수는 &lt;code&gt;'close'&lt;/code&gt; 이벤트에 대한 핸들러로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bce9baa7c1873a9e07cf0b4362eae06b10124e8" translate="yes" xml:space="preserve">
          <source>If specifying a host, make sure that either:</source>
          <target state="translated">호스트를 지정하는 경우 다음 중 하나를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10e41fd1ae4bbc18c802e9daabd5fdc153bddbd3" translate="yes" xml:space="preserve">
          <source>If still valid, this API returns the &lt;code&gt;napi_value&lt;/code&gt; representing the JavaScript &lt;code&gt;Object&lt;/code&gt; associated with the &lt;code&gt;napi_ref&lt;/code&gt;. Otherwise, result will be NULL.</source>
          <target state="translated">계속 유효 경우,이 API는 반환 &lt;code&gt;napi_value&lt;/code&gt; 자바 스크립트 나타내는 &lt;code&gt;Object&lt;/code&gt; 과 관련된 &lt;code&gt;napi_ref&lt;/code&gt; 을 . 그렇지 않으면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="32cb3625f10ae48bf6481f39f73a30285a56adfb" translate="yes" xml:space="preserve">
          <source>If such a function is set, the &lt;a href=&quot;#process_event_uncaughtexception&quot;&gt;&lt;code&gt;'uncaughtException'&lt;/code&gt;&lt;/a&gt; event will not be emitted. If &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; was passed from the command line or set through &lt;a href=&quot;v8#v8_v8_setflagsfromstring_flags&quot;&gt;&lt;code&gt;v8.setFlagsFromString()&lt;/code&gt;&lt;/a&gt;, the process will not abort.</source>
          <target state="translated">이러한 기능이 설정되면 &lt;a href=&quot;#process_event_uncaughtexception&quot;&gt; &lt;code&gt;'uncaughtException'&lt;/code&gt; &lt;/a&gt; 이벤트가 생성되지 않습니다. 경우 &lt;code&gt;--abort-on-uncaught-exception&lt;/code&gt; 를 통해 커맨드 라인 또는 세트로부터 전달 된 &lt;a href=&quot;v8#v8_v8_setflagsfromstring_flags&quot;&gt; &lt;code&gt;v8.setFlagsFromString()&lt;/code&gt; &lt;/a&gt; , 처리를 중단하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="83bf9ca2a5da8cc7d9983f311f9ed193864dab2c" translate="yes" xml:space="preserve">
          <source>If support for older versions is required but a worker object is not required, it is possible to work around the discrepancy by checking the number of arguments:</source>
          <target state="translated">이전 버전에 대한 지원이 필요하지만 작업자 개체가 필요하지 않은 경우 인수 수를 확인하여 불일치를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fb44ec0e8892750cd1ebc11186c5c22676779e1" translate="yes" xml:space="preserve">
          <source>If that string is invalid but it begins with a number, the leading number is assigned to &lt;code&gt;port&lt;/code&gt;. If the number lies outside the range denoted above, it is ignored.</source>
          <target state="translated">해당 문자열이 유효하지 않지만 숫자로 시작하면 선행 번호가 &lt;code&gt;port&lt;/code&gt; 에 지정됩니다 . 숫자가 위에 표시된 범위를 벗어나면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="30817db3d7e89f5a81f3f1220a7022495364630f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#cli_openssl_config_file&quot;&gt;&lt;code&gt;--openssl-config&lt;/code&gt;&lt;/a&gt; command line option is used, the environment variable is ignored.</source>
          <target state="translated">는 IF &lt;a href=&quot;#cli_openssl_config_file&quot;&gt; &lt;code&gt;--openssl-config&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션을 사용, 환경 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="224cfce345ee060f6c60aaa0a95c75b09e0194c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#stream_writable_cork&quot;&gt;&lt;code&gt;writable.cork()&lt;/code&gt;&lt;/a&gt; method is called multiple times on a stream, the same number of calls to &lt;code&gt;writable.uncork()&lt;/code&gt; must be called to flush the buffered data.</source>
          <target state="translated">스트림 에서 &lt;a href=&quot;#stream_writable_cork&quot;&gt; &lt;code&gt;writable.cork()&lt;/code&gt; &lt;/a&gt; 메소드를 여러 번 호출하는 경우 버퍼링 된 데이터를 플러시 하기 위해 동일한 수의 &lt;code&gt;writable.uncork()&lt;/code&gt; 호출을 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a5b3f12b63f281645322fde5f6167806a56f1ee" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'frameError'&lt;/code&gt; event is associated with a stream, the stream will be closed and destroyed immediately following the &lt;code&gt;'frameError'&lt;/code&gt; event. If the event is not associated with a stream, the &lt;code&gt;Http2Session&lt;/code&gt; will be shut down immediately following the &lt;code&gt;'frameError'&lt;/code&gt; event.</source>
          <target state="translated">는 IF &lt;code&gt;'frameError'&lt;/code&gt; 이벤트 스트림과 관련된 스트림은 다음과 같은 폐쇄 즉시 파괴됩니다 &lt;code&gt;'frameError'&lt;/code&gt; 이벤트입니다. 이벤트가 스트림과 연결되어 있지 않으면 &lt;code&gt;'frameError'&lt;/code&gt; 이벤트 직후에 &lt;code&gt;Http2Session&lt;/code&gt; 이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc9d357aaf801d9f4a8827e4487d8d5454ed7da2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--no-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is suppressed.</source>
          <target state="translated">경우 &lt;code&gt;--no-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고가 억제된다.</target>
        </trans-unit>
        <trans-unit id="006f0ef98faed2225296f7b925e4b65b6d84cc50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--throw-deprecation&lt;/code&gt; command line flag is set, or the &lt;code&gt;process.throwDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, then an exception will be thrown when the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 설정하거나 &lt;code&gt;process.throwDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; 중단 된 함수가 호출 될 때, 다음 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b278313ccedc83446c93058abbe7d110d43e12d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--throw-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is thrown as an exception rather than being emitted as an event.</source>
          <target state="translated">는 IF &lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고가 아니라 이벤트로 방출되지 않고 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1706a10a4933ed7aef53391f01f86b49fd1f1a47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--trace-deprecation&lt;/code&gt; command-line flag is used, the deprecation warning is printed to &lt;code&gt;stderr&lt;/code&gt; along with the full stack trace.</source>
          <target state="translated">는 IF &lt;code&gt;--trace-deprecation&lt;/code&gt; 명령 줄 플래그를 사용, 사용 중단 경고하는 인쇄 &lt;code&gt;stderr&lt;/code&gt; 에 전체 스택 추적과 함께.</target>
        </trans-unit>
        <trans-unit id="9e05861e85bd6ab01a00f4754a98487ae45fddc5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--trace-deprecation&lt;/code&gt; or &lt;code&gt;--trace-warnings&lt;/code&gt; command line flags are set, or the &lt;code&gt;process.traceDeprecation&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, a warning and a stack trace are printed to &lt;code&gt;stderr&lt;/code&gt; the first time the deprecated function is called.</source>
          <target state="translated">는 IF &lt;code&gt;--trace-deprecation&lt;/code&gt; 또는 &lt;code&gt;--trace-warnings&lt;/code&gt; 행 플래그가 설정하거나 명령 &lt;code&gt;process.traceDeprecation&lt;/code&gt; 의 속성이 설정되어 &lt;code&gt;true&lt;/code&gt; , 경고 및 스택 추적을 인쇄 &lt;code&gt;stderr&lt;/code&gt; 에 중단 된 함수가 호출 처음.</target>
        </trans-unit>
        <trans-unit id="7f1727f3bb0330be161d5fae1f1aeea291145a6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Http2Session&lt;/code&gt; is connected to a &lt;code&gt;TLSSocket&lt;/code&gt;, the &lt;code&gt;originSet&lt;/code&gt; property will return an &lt;code&gt;Array&lt;/code&gt; of origins for which the &lt;code&gt;Http2Session&lt;/code&gt; may be considered authoritative.</source>
          <target state="translated">경우] &lt;code&gt;Http2Session&lt;/code&gt; 는 (A)에 접속된다 &lt;code&gt;TLSSocket&lt;/code&gt; 상기 &lt;code&gt;originSet&lt;/code&gt; 의 속성은 반환 &lt;code&gt;Array&lt;/code&gt; 하는 기원 &lt;code&gt;Http2Session&lt;/code&gt; 가 정식으로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c0455b2b9b3fae766e068922a9250208e4c2af45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NODE_PATH&lt;/code&gt; environment variable is set to a colon-delimited list of absolute paths, then Node.js will search those paths for modules if they are not found elsewhere.</source>
          <target state="translated">는 IF &lt;code&gt;NODE_PATH&lt;/code&gt; 의 환경 변수가 절대 경로의 콜론으로 구분 된 목록으로 설정되어 그들이 다른 곳에서 찾을 수없는 경우, 다음 Node.js를 모듈에 대한 그 경로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="700474149520ec279c7f2339f334a3fbdcf3ac10" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;buffer&lt;/code&gt; argument is provided, one final call to &lt;code&gt;stringDecoder.write()&lt;/code&gt; is performed before returning the remaining input.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 인수가 제공되고, 마지막으로 호출 &lt;code&gt;stringDecoder.write()&lt;/code&gt; 나머지 입력을 반환하기 전에 수행된다.</target>
        </trans-unit>
        <trans-unit id="b698c9ff7e5dfbf0331a5b293d26fbbc739efc5a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ca&lt;/code&gt; option is not given, then Node.js will default to using &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt&quot;&gt;Mozilla's publicly trusted list of CAs&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;ca&lt;/code&gt; 옵션이 지정되어 있지 않은 경우, Node.js를 사용하여 기본값으로 사용됩니다 &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt&quot;&gt;수있는 CA의 모질라의 공개적으로 신뢰할 수있는 목록을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac092c034da270f1131edac11ccf7582acc156f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; function is not provided, an error will be thrown.</source>
          <target state="translated">경우] &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않는 오류가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="a9daebaf2c04786e5b28ab1e89a86e818076b4d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;callback&lt;/code&gt; function is not provided, the random bytes are generated synchronously and returned as a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;. An error will be thrown if there is a problem generating the bytes.</source>
          <target state="translated">경우] &lt;code&gt;callback&lt;/code&gt; 기능이 제공되지 않고, 임의의 바이트 동기하여 생성되고 반환되는 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; . 바이트 생성에 문제가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fec34b8e1e977f8ce019a960434cc75d2f42505d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decodeStrings&lt;/code&gt; property is explicitly set to &lt;code&gt;false&lt;/code&gt; in the constructor options, then &lt;code&gt;chunk&lt;/code&gt; will remain the same object that is passed to &lt;code&gt;.write()&lt;/code&gt;, and may be a string rather than a &lt;code&gt;Buffer&lt;/code&gt;. This is to support implementations that have an optimized handling for certain string data encodings. In that case, the &lt;code&gt;encoding&lt;/code&gt; argument will indicate the character encoding of the string. Otherwise, the &lt;code&gt;encoding&lt;/code&gt; argument can be safely ignored.</source>
          <target state="translated">는 IF &lt;code&gt;decodeStrings&lt;/code&gt; 의 속성을 명시 적으로 설정되어 &lt;code&gt;false&lt;/code&gt; 생성자 옵션에서 다음 &lt;code&gt;chunk&lt;/code&gt; 에 전달되는 동일한 개체 유지됩니다 &lt;code&gt;.write()&lt;/code&gt; 하고, 오히려보다 문자열이 될 수 있습니다 &lt;code&gt;Buffer&lt;/code&gt; . 이는 특정 문자열 데이터 인코딩에 대해 최적화 된 처리 기능이있는 구현을 지원하기위한 것입니다. 이 경우 &lt;code&gt;encoding&lt;/code&gt; 인수는 문자열의 문자 인코딩을 나타냅니다. 그렇지 않으면 &lt;code&gt;encoding&lt;/code&gt; 인수를 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="1295a8b2430b9ea40a28497169df9f00a2e30e2f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;destination&lt;/code&gt; is not specified, then &lt;em&gt;all&lt;/em&gt; pipes are detached.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 지정되어 있지 않은 경우, &lt;em&gt;모든&lt;/em&gt; 파이프가 분리된다.</target>
        </trans-unit>
        <trans-unit id="f61354dd4c096ff86d2604bd1f201639b5280cce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;destination&lt;/code&gt; is specified, but no pipe is set up for it, then the method does nothing.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 지정되어 있지만 파이프가 그것을 위해 설정되어 있지 않은, 다음 메소드는 아무것도 실시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9993188edbda0e084b782c4aa4a76c9d01b6aa7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; option is specified then this function returns a string. Otherwise it returns a buffer.</source>
          <target state="translated">경우 &lt;code&gt;encoding&lt;/code&gt; 옵션이 지정되고이 함수는 문자열을 반환합니다. 그렇지 않으면 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff21d446a3ab3fe55f4acc6ff2c436094f676d4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is not a format string, the output string's formatting is no longer dependent on the type of the first argument. This change removes previously present quotes from strings that were being output when the first argument was not a string.</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 인수가 형식 문자열이 아닌, 출력 문자열의 형식은 첫 번째 인수의 종류에 더 이상 의존하지 않습니다. 이 변경은 첫 번째 인수가 문자열이 아닐 때 출력되었던 문자열에서 이전에 존재하는 따옴표를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d308fd83eda74dcf99237973ddacf4e7ec8a2f56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;input&lt;/code&gt; stream was paused &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;SIGTSTP&lt;/code&gt; request, this event will not be emitted.</source>
          <target state="translated">경우] &lt;code&gt;input&lt;/code&gt; 스트림을 일시 중지 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;SIGTSTP&lt;/code&gt; 의 요청이 이벤트가 방출되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="30f38c1cd9e3b259bd034f504426ea5d58e45d76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inputEncoding&lt;/code&gt; is not provided, &lt;code&gt;key&lt;/code&gt; is expected to be a &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TypedArray&lt;/code&gt;, or &lt;code&gt;DataView&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;inputEncoding&lt;/code&gt; 가 제공되지 않는, &lt;code&gt;key&lt;/code&gt; 것으로 예상된다 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;TypedArray&lt;/code&gt; , 또는 &lt;code&gt;DataView&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="9f18955efde58f4d26c872da376a7f9e3385d261" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; option is an array, individual entries do not need a &lt;code&gt;passphrase&lt;/code&gt; property anymore. &lt;code&gt;Array&lt;/code&gt; entries can also just be &lt;code&gt;string&lt;/code&gt;s or &lt;code&gt;Buffer&lt;/code&gt;s now.</source>
          <target state="translated">는 IF &lt;code&gt;key&lt;/code&gt; 옵션은 배열, 개별 항목은 필요하지 않습니다 &lt;code&gt;passphrase&lt;/code&gt; 더 이상 속성을. &lt;code&gt;Array&lt;/code&gt; 항목은 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;Buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d7c9ccb6d11a43cf334112f22066ada11047f33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;module.status&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt;, this property contains the exception thrown by the module during evaluation. If the status is anything else, accessing this property will result in a thrown exception.</source>
          <target state="translated">경우 &lt;code&gt;module.status&lt;/code&gt; 가 되어 &lt;code&gt;'errored'&lt;/code&gt; 이 속성은 평가시 모듈에 의해 던져진 예외를 포함합니다. 상태가 다른 경우이 속성에 액세스하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf37dd1b51403923bcd466d830080d91ad10e133" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;napi_status&lt;/code&gt; returned by a function is &lt;code&gt;napi_ok&lt;/code&gt; then no exception is pending and no additional action is required. If the &lt;code&gt;napi_status&lt;/code&gt; returned is anything other than &lt;code&gt;napi_ok&lt;/code&gt; or &lt;code&gt;napi_pending_exception&lt;/code&gt;, in order to try to recover and continue instead of simply returning immediately, &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt;&lt;code&gt;napi_is_exception_pending&lt;/code&gt;&lt;/a&gt; must be called in order to determine if an exception is pending or not.</source>
          <target state="translated">는 IF &lt;code&gt;napi_status&lt;/code&gt; 함수에 의해 반환이 &lt;code&gt;napi_ok&lt;/code&gt; 다음 예외 보류되지 않고 추가 조치가 필요하지 않습니다. 반환 된 &lt;code&gt;napi_status&lt;/code&gt; 가 &lt;code&gt;napi_ok&lt;/code&gt; 또는 &lt;code&gt;napi_pending_exception&lt;/code&gt; 이외의 값인 경우 , 단순히 즉시 반환하는 대신 복구하고 계속 진행 하려면 예외가 보류 중인지 여부를 판별하기 위해 &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt; &lt;code&gt;napi_is_exception_pending&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="edc8d76112ea7024d3371b71a0a23d16ae790953" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;package.json&lt;/code&gt;&lt;code&gt;&quot;type&quot;&lt;/code&gt; field is omitted, a &lt;code&gt;.js&lt;/code&gt; file in &lt;code&gt;&quot;main&quot;&lt;/code&gt; will be interpreted as CommonJS.</source>
          <target state="translated">는 IF &lt;code&gt;package.json&lt;/code&gt; &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드를 생략하는 &lt;code&gt;.js&lt;/code&gt; 에서 파일을 &lt;code&gt;&quot;main&quot;&lt;/code&gt; CommonJS로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="caa3feef5b60811f6f8ebc29d870eae549b34115" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;path&lt;/code&gt; is a zero-length string, &lt;code&gt;'.'&lt;/code&gt; is returned, representing the current working directory.</source>
          <target state="translated">는 IF &lt;code&gt;path&lt;/code&gt; 길이가 0 인 문자열이다 &lt;code&gt;'.'&lt;/code&gt; 현재 작업 디렉토리를 나타내는가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caefa5d65799f6063d04ea3b55a098cbb95b16f1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;payload&lt;/code&gt; argument is not specified, the default payload will be the 64-bit timestamp (little endian) marking the start of the &lt;code&gt;PING&lt;/code&gt; duration.</source>
          <target state="translated">경우 &lt;code&gt;payload&lt;/code&gt; 인수를 지정하지, 기본 페이로드의 시작 표시 64 비트 타임 스탬프 (리틀 엔디안)입니다 &lt;code&gt;PING&lt;/code&gt; 의 시간을.</target>
        </trans-unit>
        <trans-unit id="0a081c5a11aa40b34615e3cce298d430f402bf1f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readable.read()&lt;/code&gt; method returns a chunk of data, a &lt;code&gt;'data'&lt;/code&gt; event will also be emitted.</source>
          <target state="translated">경우] &lt;code&gt;readable.read()&lt;/code&gt; 메소드는 데이터 청크를 반환하는 &lt;code&gt;'data'&lt;/code&gt; 이벤트는 발광한다.</target>
        </trans-unit>
        <trans-unit id="91fa64dbbc3f8f47eda565fe9f322b381a972060" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; are not written.</source>
          <target state="translated">경우] &lt;code&gt;readline.Interface&lt;/code&gt; 를 사용하여 만든 &lt;code&gt;output&lt;/code&gt; 으로 설정된 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;key&lt;/code&gt; 기록되어있다.</target>
        </trans-unit>
        <trans-unit id="06f06f1032594fee7846b4022ca4197486666d19" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the &lt;code&gt;query&lt;/code&gt; is not written.</source>
          <target state="translated">는 IF &lt;code&gt;readline.Interface&lt;/code&gt; 을 사용하여 만든 &lt;code&gt;output&lt;/code&gt; 으로 설정 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fea07f7457e9a5cfe604444ae829144970387f4e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;readline.Interface&lt;/code&gt; was created with &lt;code&gt;output&lt;/code&gt; set to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the prompt is not written.</source>
          <target state="translated">&lt;code&gt;readline.Interface&lt;/code&gt; 가 &lt;code&gt;output&lt;/code&gt; 을 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 로 설정하여 만든 경우 프롬프트가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ba79ac22562343c78ffca177acce56493df85de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; argument is not specified, all of the data contained in the internal buffer will be returned.</source>
          <target state="translated">상기 중간 &lt;code&gt;size&lt;/code&gt; 인수가 지정되지 않고 내부 버퍼에 포함 된 모든 데이터가 리턴 될 것이다.</target>
        </trans-unit>
        <trans-unit id="70594489f12159c87f362c4ae69f4758215eb7f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;small-icu&lt;/code&gt; option is used, one can still provide additional locale data at runtime so that the JS methods would work for all ICU locales. Assuming the data file is stored at &lt;code&gt;/some/directory&lt;/code&gt;, it can be made available to ICU through either:</source>
          <target state="translated">는 IF &lt;code&gt;small-icu&lt;/code&gt; 옵션이 사용되는 JS 방법은 모든 ICU 로케일에 대해 작동 할 수 있도록, 하나는 여전히 런타임에 추가 로케일 데이터를 제공 할 수 있습니다. 데이터 파일이 &lt;code&gt;/some/directory&lt;/code&gt; 에 저장되어 있다고 가정하면 다음 중 하나를 통해 ICU에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba838b5589301149a5649376c001bb8fe7dc3b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is a &lt;a href=&quot;tty&quot;&gt;TTY&lt;/a&gt;, then it must be in raw mode.</source>
          <target state="translated">는 IF &lt;code&gt;stream&lt;/code&gt; A는 &lt;a href=&quot;tty&quot;&gt;TTY는&lt;/a&gt; , 그것은 원시 모드에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1276a263a11dfdba0d780253f069d70f3b07760" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;type&lt;/code&gt; argument is left undefined, Node will autodetect &lt;code&gt;target&lt;/code&gt; type and automatically select &lt;code&gt;dir&lt;/code&gt; or &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;code&gt;type&lt;/code&gt; 인수가 정의되지 않은 왼쪽되어, 노드는 자동으로 감지합니다 &lt;code&gt;target&lt;/code&gt; 유형 자동 선택 &lt;code&gt;dir&lt;/code&gt; 나 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="641da75986b0d3dd6bb805434236735b6993a166" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.hash&lt;/code&gt; property is a string:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.hash&lt;/code&gt; 속성은 문자열입니다 :</target>
        </trans-unit>
        <trans-unit id="dfb858e55085a16c94af20594b643c53b5b10f40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.host&lt;/code&gt; property is &lt;code&gt;undefined&lt;/code&gt; then:</source>
          <target state="translated">경우] &lt;code&gt;urlObject.host&lt;/code&gt; 의 속성이되어 &lt;code&gt;undefined&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="5b5dce93f29b648ece229c6c340c77b112847288" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.hostname&lt;/code&gt; is a string, it is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.hostname&lt;/code&gt; 는 문자열, 그것은 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6379b09c4b00ec95bd4b96e589e7705fbb8d936e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.pathname&lt;/code&gt; property is a string that is not an empty string:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.pathname&lt;/code&gt; 의 속성은 빈 문자열이 아닌 문자열입니다 :</target>
        </trans-unit>
        <trans-unit id="cca80e3e9a84bf98df702fab84776425b14d0b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.pathname&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with an ASCII forward slash (&lt;code&gt;/&lt;/code&gt;), then the literal string &lt;code&gt;'/'&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.pathname&lt;/code&gt; 이&lt;em&gt;시작되지 않습니다&lt;/em&gt; 아스키 슬래시 (과 &lt;code&gt;/&lt;/code&gt; ), 다음 리터럴 문자열 &lt;code&gt;'/'&lt;/code&gt; 에 추가됩니다 &lt;code&gt;result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d3af2d3b60b1f8ba28c24cc690ad1da17edcb49" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.port&lt;/code&gt; property value is truthy, and &lt;code&gt;urlObject.hostname&lt;/code&gt; is not &lt;code&gt;undefined&lt;/code&gt;:</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.port&lt;/code&gt; 의 속성 값은 truthy이며, &lt;code&gt;urlObject.hostname&lt;/code&gt; 가 아닌 &lt;code&gt;undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f7b1873a47a5cccbbcaf141e8099ba0a23f167af" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;urlObject.search&lt;/code&gt; property is &lt;code&gt;undefined&lt;/code&gt; and if the &lt;code&gt;urlObject.query&lt;/code&gt; property is an &lt;code&gt;Object&lt;/code&gt;, the literal string &lt;code&gt;?&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt; followed by the output of calling the &lt;a href=&quot;querystring&quot;&gt;&lt;code&gt;querystring&lt;/code&gt;&lt;/a&gt; module's &lt;code&gt;stringify()&lt;/code&gt; method passing the value of &lt;code&gt;urlObject.query&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;urlObject.search&lt;/code&gt; 의 속성입니다 &lt;code&gt;undefined&lt;/code&gt; 및 경우 &lt;code&gt;urlObject.query&lt;/code&gt; 의 속성이있다 &lt;code&gt;Object&lt;/code&gt; , 리터럴 문자열 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;urlObject.query&lt;/code&gt; 의 값을 전달하는 &lt;a href=&quot;querystring&quot;&gt; &lt;code&gt;querystring&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;code&gt;stringify()&lt;/code&gt; 메소드를 호출 한 &lt;code&gt;result&lt;/code&gt; 가 결과에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6c7d9851a36c60f4fede5c50c0daefebfda6c63" translate="yes" xml:space="preserve">
          <source>If the Chrome browser is older than 66.0.3345.0, use &lt;code&gt;inspector.html&lt;/code&gt; instead of &lt;code&gt;js_app.html&lt;/code&gt; in the above URL.</source>
          <target state="translated">Chrome 브라우저가 66.0.3345.0보다 오래된 경우 위 URL에서 &lt;code&gt;js_app.html&lt;/code&gt; 대신 &lt;code&gt;inspector.html&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2ee6d4306a883909c0a1794605af868e4cc47a" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;'disconnect'&lt;/code&gt; event will be emitted when the IPC channel is closed.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성되면 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조) IPC 채널이 닫힐 때 &lt;code&gt;'disconnect'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ac963e7d4525abb2736d0e62cf6c19d77ecc05c0" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;'message'&lt;/code&gt; event is emitted whenever a message sent by a parent process using &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt;&lt;code&gt;childprocess.send()&lt;/code&gt;&lt;/a&gt; is received by the child process.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성되면 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조), 자식 프로세스 가 &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt; &lt;code&gt;childprocess.send()&lt;/code&gt; &lt;/a&gt; 사용하여 부모 프로세스가 보낸 메시지를받을 때마다 &lt;code&gt;'message'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0f656d281b0270653c917de8907695d4af188c" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;process.connected&lt;/code&gt; property will return &lt;code&gt;true&lt;/code&gt; so long as the IPC channel is connected and will return &lt;code&gt;false&lt;/code&gt; after &lt;code&gt;process.disconnect()&lt;/code&gt; is called.</source>
          <target state="translated">Node.js를 프로세스가 IPC 채널과 양산되면합니다 (참조 &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 와 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; , 문서)를 &lt;code&gt;process.connected&lt;/code&gt; 속성이 반환됩니다 &lt;code&gt;true&lt;/code&gt; IPC의 채널이 연결되어 너무 오래 및 반환 &lt;code&gt;false&lt;/code&gt; 후 &lt;code&gt;process.disconnect()&lt;/code&gt; 라고 .</target>
        </trans-unit>
        <trans-unit id="cde62fe89a34a0451adb24c7df715d4ac04255b2" translate="yes" xml:space="preserve">
          <source>If the Node.js process is spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; and &lt;a href=&quot;cluster&quot;&gt;Cluster&lt;/a&gt; documentation), the &lt;code&gt;process.disconnect()&lt;/code&gt; method will close the IPC channel to the parent process, allowing the child process to exit gracefully once there are no other connections keeping it alive.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성 된 경우 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt;클러스터&lt;/a&gt; 설명서 참조) &lt;code&gt;process.disconnect()&lt;/code&gt; 메소드는 IPC 채널을 상위 프로세스로 닫아서 하위 프로세스가 없으면 정상적으로 종료되도록합니다. 다른 연결을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f1535633e9356c88e44a5953c4a93db18cf738ad" translate="yes" xml:space="preserve">
          <source>If the Node.js process was not spawned with an IPC channel, &lt;code&gt;process.disconnect()&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널로 생성 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;process.disconnect()&lt;/code&gt; 는 undefined 입니다.</target>
        </trans-unit>
        <trans-unit id="fc3cb24c470cc8f1c846968b69afb26cb137c284" translate="yes" xml:space="preserve">
          <source>If the Node.js process was spawned with an IPC channel (see the &lt;a href=&quot;child_process&quot;&gt;Child Process&lt;/a&gt; documentation), the &lt;code&gt;process.channel&lt;/code&gt; property is a reference to the IPC channel. If no IPC channel exists, this property is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Node.js 프로세스가 IPC 채널과 함께 생성 된 경우 ( &lt;a href=&quot;child_process&quot;&gt;자식 프로세스&lt;/a&gt; 문서 참조 ) &lt;code&gt;process.channel&lt;/code&gt; 속성은 IPC 채널에 대한 참조입니다. IPC 채널이 없으면이 속성은 &lt;code&gt;undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43857629c05db580aaa4aaa5f6033f044e6c6ced" translate="yes" xml:space="preserve">
          <source>If the REPL is run as standalone program, it is also possible to change the REPL's &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;inspection defaults&lt;/a&gt; from inside the REPL by using the &lt;code&gt;inspect.replDefaults&lt;/code&gt; property which mirrors the &lt;code&gt;defaultOptions&lt;/code&gt; from &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;&lt;code&gt;util.inspect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">REPL이 독립형 프로그램으로 실행 되는 경우 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt; &lt;code&gt;util.inspect()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;defaultOptions&lt;/code&gt; 를 미러링하는 &lt;code&gt;inspect.replDefaults&lt;/code&gt; 속성을 사용하여 REPL 내부에서 REPL의 &lt;a href=&quot;util#util_util_inspect_object_options&quot;&gt;검사 기본값&lt;/a&gt; 을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23a67121ef3a61432b20d90cd8e0ab29a6212306" translate="yes" xml:space="preserve">
          <source>If the Timer or &lt;code&gt;EventEmitter&lt;/code&gt; was already bound to a domain, it is removed from that one, and bound to this one instead.</source>
          <target state="translated">Timer 또는 &lt;code&gt;EventEmitter&lt;/code&gt; 가 이미 도메인에 바인딩 된 경우 해당 도메인에서 제거되고 대신이 도메인에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8c562e1358dbc4b2fc2fd9fd83e9076c18598405" translate="yes" xml:space="preserve">
          <source>If the accessibility check is successful, the &lt;code&gt;Promise&lt;/code&gt; is resolved with no value. If any of the accessibility checks fail, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;code&gt;Error&lt;/code&gt; object. The following example checks if the file &lt;code&gt;/etc/passwd&lt;/code&gt; can be read and written by the current process.</source>
          <target state="translated">접근성 검사에 성공하면 &lt;code&gt;Promise&lt;/code&gt; 이 값없이 해결됩니다. 접근성 검사 중 하나라도 실패 하면 &lt;code&gt;Error&lt;/code&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다 . 다음 예제는 현재 프로세스에서 &lt;code&gt;/etc/passwd&lt;/code&gt; 파일을 읽고 쓸 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a6b610dfa520e94a9fdf2b30dda8919b3eebe300" translate="yes" xml:space="preserve">
          <source>If the child process intercepts and handles the &lt;code&gt;SIGTERM&lt;/code&gt; signal and does not exit, the parent process will still wait until the child process has exited.</source>
          <target state="translated">하위 프로세스가 &lt;code&gt;SIGTERM&lt;/code&gt; 신호를 가로 채서 처리하고 종료하지 않으면 상위 프로세스는 하위 프로세스가 종료 될 때까지 계속 대기합니다.</target>
        </trans-unit>
        <trans-unit id="13b740fc3fb496e053111a8c519d9ac732b0ce92" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[0]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[0]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b39b748847e4c67b790f33ece88c22fff5bd35" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[1]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[1]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29ee59da22385decb4ae9026bc663f921fbe54b3" translate="yes" xml:space="preserve">
          <source>If the child was spawned with &lt;code&gt;stdio[2]&lt;/code&gt; set to anything other than &lt;code&gt;'pipe'&lt;/code&gt;, then this will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">아이가 함께 양산 된 경우 &lt;code&gt;stdio[2]&lt;/code&gt; 이외의 다른 설정 &lt;code&gt;'pipe'&lt;/code&gt; , 다음이 될 것 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da188d4f2c13854a7aa73240ff25eb0ff7f7df83" translate="yes" xml:space="preserve">
          <source>If the data to be written can be generated or fetched on demand, it is recommended to encapsulate the logic into a &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#stream_readable_pipe_destination_options&quot;&gt;&lt;code&gt;stream.pipe()&lt;/code&gt;&lt;/a&gt;. However, if calling &lt;code&gt;write()&lt;/code&gt; is preferred, it is possible to respect backpressure and avoid memory issues using the &lt;a href=&quot;#stream_event_drain&quot;&gt;&lt;code&gt;'drain'&lt;/code&gt;&lt;/a&gt; event:</source>
          <target state="translated">작성 될 데이터가 요청시 생성되거나 페치 될 수있는 경우 로직을 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 으로 캡슐화하고 &lt;a href=&quot;#stream_readable_pipe_destination_options&quot;&gt; &lt;code&gt;stream.pipe()&lt;/code&gt; &lt;/a&gt; 사용 하는 것이 좋습니다 . 그러나 &lt;code&gt;write()&lt;/code&gt; 호출 이 선호되는 경우 배압을 존중하고 &lt;a href=&quot;#stream_event_drain&quot;&gt; &lt;code&gt;'drain'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용하여 메모리 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61145810afb5945c541a709b46cbd9081fc8c5a0" translate="yes" xml:space="preserve">
          <source>If the exact filename is not found, then Node.js will attempt to load the required filename with the added extensions: &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.json&lt;/code&gt;, and finally &lt;code&gt;.node&lt;/code&gt;.</source>
          <target state="translated">정확한 파일 이름을 찾을 수 없으면 Node.js는 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.json&lt;/code&gt; 및 마지막으로 &lt;code&gt;.node&lt;/code&gt; 확장자가 추가 된 필수 파일 이름을로드하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2258fb88100a5f7eff8cc7faff56de080446a859" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;packageURL&lt;/em&gt; does not parse as valid JSON, then</source>
          <target state="translated">&lt;em&gt;packageURL&lt;/em&gt; 의 파일이 유효한 JSON으로 구문 분석되지 않으면</target>
        </trans-unit>
        <trans-unit id="bdeb3f1ca2d8b92cbd0a1be61e5a215e42cd48a6" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;pjsonURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;pjsonURL에&lt;/em&gt; 파일 이 존재하지 않으면</target>
        </trans-unit>
        <trans-unit id="5da2c4a4757077189503883db4e6e527ad0ac53c" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolvedMain&lt;/em&gt; exists, then</source>
          <target state="translated">&lt;em&gt;resolvedMain에&lt;/em&gt; 파일 이 존재하면</target>
        </trans-unit>
        <trans-unit id="515992658a030cb2361fa29326a06b3cc8b741f2" translate="yes" xml:space="preserve">
          <source>If the file at &lt;em&gt;resolvedURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;resolvedURL에&lt;/em&gt; 파일 이 존재하지 않으면</target>
        </trans-unit>
        <trans-unit id="9cd28ea88a40c2bd663df8d30e3acd434308cc86" translate="yes" xml:space="preserve">
          <source>If the file previously was shorter than &lt;code&gt;len&lt;/code&gt; bytes, it is extended, and the extended part is filled with null bytes (&lt;code&gt;'\0'&lt;/code&gt;):</source>
          <target state="translated">파일이 이전에 &lt;code&gt;len&lt;/code&gt; 바이트 보다 짧은 경우 확장되고 확장 된 부분은 널 바이트 ( &lt;code&gt;'\0'&lt;/code&gt; )로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="f95ff524435a90bae8bf6af198f46ee202155faf" translate="yes" xml:space="preserve">
          <source>If the file referred to by the file descriptor was larger than &lt;code&gt;len&lt;/code&gt; bytes, only the first &lt;code&gt;len&lt;/code&gt; bytes will be retained in the file.</source>
          <target state="translated">파일 디스크립터가 참조한 파일이 &lt;code&gt;len&lt;/code&gt; 바이트 보다 크면 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 만 파일에 보유됩니다.</target>
        </trans-unit>
        <trans-unit id="4496f3dce2ffd4403c03b2fc30701caf9fb83647" translate="yes" xml:space="preserve">
          <source>If the file was larger than &lt;code&gt;len&lt;/code&gt; bytes, only the first &lt;code&gt;len&lt;/code&gt; bytes will be retained in the file.</source>
          <target state="translated">파일이 &lt;code&gt;len&lt;/code&gt; 바이트 보다 크면 첫 번째 &lt;code&gt;len&lt;/code&gt; 바이트 만 파일에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a9e0f0d83d0baa5625a952fe8bc081211ede0c9c" translate="yes" xml:space="preserve">
          <source>If the final write of a &lt;code&gt;fill()&lt;/code&gt; operation falls on a multi-byte character, then only the bytes of that character that fit into &lt;code&gt;buf&lt;/code&gt; are written:</source>
          <target state="translated">&lt;code&gt;fill()&lt;/code&gt; 연산 의 최종 쓰기가 멀티 바이트 문자에 해당되면 &lt;code&gt;buf&lt;/code&gt; 에 맞는 해당 문자의 바이트 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="43bfae18f785239e10de241385230fcb58569d05" translate="yes" xml:space="preserve">
          <source>If the first argument does not contain a valid format specifier, &lt;code&gt;util.format()&lt;/code&gt; returns a string that is the concatenation of all arguments separated by spaces:</source>
          <target state="translated">첫 번째 인수에 유효한 형식 지정 &lt;code&gt;util.format()&lt;/code&gt; 은 공백으로 구분 된 모든 인수가 연결된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="757a2bf0797ec25c73b79618040a87cf69150154" translate="yes" xml:space="preserve">
          <source>If the folder at &lt;em&gt;packageURL&lt;/em&gt; does not exist, then</source>
          <target state="translated">&lt;em&gt;packageURL에&lt;/em&gt; 폴더 가 없으면</target>
        </trans-unit>
        <trans-unit id="818763c6083260346cbce59d04afb4c3653559bd" translate="yes" xml:space="preserve">
          <source>If the format is &lt;code&gt;'pem'&lt;/code&gt;, the &lt;code&gt;'key'&lt;/code&gt; may also be an X.509 certificate.</source>
          <target state="translated">형식이 &lt;code&gt;'pem'&lt;/code&gt; 이면 &lt;code&gt;'key'&lt;/code&gt; 는 X.509 인증서 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="146a422b15c52df2fe42a2ad9ffc62b28c5857bf" translate="yes" xml:space="preserve">
          <source>If the full certificate chain was requested, each certificate will include an &lt;code&gt;issuerCertificate&lt;/code&gt; property containing an object representing its issuer's certificate.</source>
          <target state="translated">전체 인증서 체인이 요청 된 경우 각 인증서에는 발급자의 인증서를 나타내는 개체 가 포함 된 &lt;code&gt;issuerCertificate&lt;/code&gt; 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a0387fb588dc77347f4082fa56c7b681a051b0ff" translate="yes" xml:space="preserve">
          <source>If the function is not available, provide an alternate implementation that does not use the function.</source>
          <target state="translated">기능을 사용할 수없는 경우 기능을 사용하지 않는 대체 구현을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="d53cf262095ac45fa556dab4e32bb6ff3d6e6375" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;path&lt;/code&gt; is a zero-length string, &lt;code&gt;false&lt;/code&gt; will be returned.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 가 길이가 0 인 문자열이면 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e3d776630cc8905c1ff9df803e1e77bcd6232c" translate="yes" xml:space="preserve">
          <source>If the given path does not exist, &lt;code&gt;require()&lt;/code&gt; will throw an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; with its &lt;code&gt;code&lt;/code&gt; property set to &lt;code&gt;'MODULE_NOT_FOUND'&lt;/code&gt;.</source>
          <target state="translated">주어진 경로가 존재하지 않으면 &lt;code&gt;require()&lt;/code&gt; 는 &lt;code&gt;code&lt;/code&gt; 속성이 &lt;code&gt;'MODULE_NOT_FOUND'&lt;/code&gt; 로 설정된 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7ea6180b6690cd9c141dea7ea55172dbbbd3d0da" translate="yes" xml:space="preserve">
          <source>If the internal read buffer is below the &lt;code&gt;highWaterMark&lt;/code&gt;, and the stream is not currently reading, then calling &lt;code&gt;stream.read(0)&lt;/code&gt; will trigger a low-level &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt;&lt;code&gt;stream._read()&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">내부 읽기 버퍼가 &lt;code&gt;highWaterMark&lt;/code&gt; 아래에 있고 스트림이 현재 읽지 않는 경우 &lt;code&gt;stream.read(0)&lt;/code&gt; 을 호출 하면 하위 수준의 &lt;a href=&quot;#stream_readable_read_size_1&quot;&gt; &lt;code&gt;stream._read()&lt;/code&gt; &lt;/a&gt; 호출 이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="94623dec42ca41e55b62b9990af5e5333283824a" translate="yes" xml:space="preserve">
          <source>If the length of &lt;em&gt;packageSpecifier&lt;/em&gt; is greater than the length of &lt;em&gt;packageName&lt;/em&gt;, then</source>
          <target state="translated">의 길이 경우 &lt;em&gt;packageSpecifier는&lt;/em&gt; 의 길이보다 큰 &lt;em&gt;packageName 여기서&lt;/em&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="17178a0e608fa47d68854e07ee706e59b8601df4" translate="yes" xml:space="preserve">
          <source>If the list has no items, or if the &lt;code&gt;totalLength&lt;/code&gt; is 0, then a new zero-length &lt;code&gt;Buffer&lt;/code&gt; is returned.</source>
          <target state="translated">목록에 항목이 없거나 &lt;code&gt;totalLength&lt;/code&gt; 가 0이면 새로운 길이 가 0 인 &lt;code&gt;Buffer&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="69a7cfdcf2ecac620e067b3903c7f336b3b1a1ef" translate="yes" xml:space="preserve">
          <source>If the loop is terminated with &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, or &lt;code&gt;return&lt;/code&gt;, &lt;a href=&quot;#readline_rl_close&quot;&gt;&lt;code&gt;rl.close()&lt;/code&gt;&lt;/a&gt; will be called. In other words, iterating over a &lt;code&gt;readline.Interface&lt;/code&gt; will always consume the input stream fully.</source>
          <target state="translated">루프가 &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; 또는 &lt;code&gt;return&lt;/code&gt; 으로 종료 되면 &lt;a href=&quot;#readline_rl_close&quot;&gt; &lt;code&gt;rl.close()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 즉, &lt;code&gt;readline.Interface&lt;/code&gt; 를 반복 하면 항상 입력 스트림이 완전히 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="bceba7bdffad615ad25d0a02fc1ae50546e463d9" translate="yes" xml:space="preserve">
          <source>If the loop terminates with a &lt;code&gt;break&lt;/code&gt; or a &lt;code&gt;throw&lt;/code&gt;, the stream will be destroyed. In other terms, iterating over a stream will consume the stream fully. The stream will be read in chunks of size equal to the &lt;code&gt;highWaterMark&lt;/code&gt; option. In the code example above, data will be in a single chunk if the file has less then 64kb of data because no &lt;code&gt;highWaterMark&lt;/code&gt; option is provided to &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt;&lt;code&gt;fs.createReadStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">루프가 &lt;code&gt;break&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 로 종료 되면 스트림이 삭제됩니다. 즉, 스트림을 반복하면 스트림이 완전히 소비됩니다. 스트림은 &lt;code&gt;highWaterMark&lt;/code&gt; 옵션 과 동일한 크기의 청크로 읽 힙니다 . 위의 코드 예제 에서 &lt;a href=&quot;fs#fs_fs_createreadstream_path_options&quot;&gt; &lt;code&gt;fs.createReadStream()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;highWaterMark&lt;/code&gt; 옵션이 제공 되지 않아 파일에 64kb 미만의 데이터가 있으면 데이터가 단일 청크에있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="b818f0c6afbca493ff9a19fa9609c515ca828403" translate="yes" xml:space="preserve">
          <source>If the module identifier passed to &lt;code&gt;require()&lt;/code&gt; is not a &lt;a href=&quot;#modules_core_modules&quot;&gt;core&lt;/a&gt; module, and does not begin with &lt;code&gt;'/'&lt;/code&gt;, &lt;code&gt;'../'&lt;/code&gt;, or &lt;code&gt;'./'&lt;/code&gt;, then Node.js starts at the parent directory of the current module, and adds &lt;code&gt;/node_modules&lt;/code&gt;, and attempts to load the module from that location. Node.js will not append &lt;code&gt;node_modules&lt;/code&gt; to a path already ending in &lt;code&gt;node_modules&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 전달 된 모듈 식별자 가 &lt;a href=&quot;#modules_core_modules&quot;&gt;핵심&lt;/a&gt; 모듈이 아니며 &lt;code&gt;'/'&lt;/code&gt; , &lt;code&gt;'../'&lt;/code&gt; 또는 &lt;code&gt;'./'&lt;/code&gt; 로 시작하지 않으면 Node.js가 현재 모듈의 상위 디렉토리에서 시작됩니다. &lt;code&gt;/node_modules&lt;/code&gt; 를 추가 하고 해당 위치에서 모듈을로드하려고 시도합니다. Node.js를가 추가되지 않습니다 &lt;code&gt;node_modules&lt;/code&gt; 을 경로가 이미 종료에 &lt;code&gt;node_modules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5890e21cec685ed58fcf1519311a188e9030c9ce" translate="yes" xml:space="preserve">
          <source>If the module will be loaded multiple times during the lifetime of the Node.js process, use the &lt;code&gt;NAPI_MODULE_INIT&lt;/code&gt; macro to initialize the module:</source>
          <target state="translated">Node.js 프로세스의 수명 동안 모듈이 여러 번로드되면 &lt;code&gt;NAPI_MODULE_INIT&lt;/code&gt; 매크로를 사용 하여 모듈을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="0add70a68c352ca1f1ff5b2c44879360ea5a65e7" translate="yes" xml:space="preserve">
          <source>If the nearest parent &lt;code&gt;package.json&lt;/code&gt; lacks a &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or contains &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt;, extensionless and &lt;code&gt;.js&lt;/code&gt; files are treated as CommonJS. If the volume root is reached and no &lt;code&gt;package.json&lt;/code&gt; is found, Node.js defers to the default, a &lt;code&gt;package.json&lt;/code&gt; with no &lt;code&gt;&quot;type&quot;&lt;/code&gt; field.</source>
          <target state="translated">가장 가까운 상위 &lt;code&gt;package.json&lt;/code&gt; 에 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드가 없거나 &lt;code&gt;&quot;type&quot;: &quot;commonjs&quot;&lt;/code&gt; 경우 확장명 및 &lt;code&gt;.js&lt;/code&gt; 파일은 CommonJS로 처리됩니다. 볼륨 루트에 도달하고 &lt;code&gt;package.json&lt;/code&gt; 을 찾을 수 없으면 Node.js는 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드 가없는 &lt;code&gt;package.json&lt;/code&gt; 을 기본값으로 연기 합니다.</target>
        </trans-unit>
        <trans-unit id="a879f054c5d68d376a9ec6f0087a480eedd3cce6" translate="yes" xml:space="preserve">
          <source>If the number exceeds the range of the 32 bit integer, then the result is truncated to the equivalent of the bottom 32 bits. This can result in a large positive number becoming a negative number if the value is &amp;gt; 2^31 -1.</source>
          <target state="translated">숫자가 32 비트 정수 범위를 초과하면 결과는 맨 아래 32 비트와 동일하게 잘립니다. 값이 2 ^ 31 -1이면 큰 양수가 음수가됩니다.</target>
        </trans-unit>
        <trans-unit id="e897c2b05d260b0b8e93ea4b285545b463fa7585" translate="yes" xml:space="preserve">
          <source>If the object cannot be serialized, an exception should be thrown.</source>
          <target state="translated">객체를 직렬화 할 수 없으면 예외가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6442a98f87242a39ce04a31ab601184ec0f676c" translate="yes" xml:space="preserve">
          <source>If the private key is encrypted, a &lt;code&gt;passphrase&lt;/code&gt; must be specified. The length of the passphrase is limited to 1024 bytes.</source>
          <target state="translated">개인 키가 암호화 된 경우 &lt;code&gt;passphrase&lt;/code&gt; 를 지정해야합니다. 암호의 길이는 1024 바이트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae9b624e6a4cc8658387bd2cdd003cae8d4f7da" translate="yes" xml:space="preserve">
          <source>If the process times out or has a non-zero exit code, this method will throw an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; that will include the full result of the underlying &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스가 시간 초과되거나 종료 코드가 0이 아닌 경우이 메소드는 기본 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; 의 전체 결과를 포함 하는 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다. .</target>
        </trans-unit>
        <trans-unit id="98fbfb27e02d409cf17783265e877eb2aec63754" translate="yes" xml:space="preserve">
          <source>If the process times out or has a non-zero exit code, this method will throw. The &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object will contain the entire result from &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt;&lt;code&gt;child_process.spawnSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스 시간이 초과되거나 종료 코드가 0이 아닌 경우이 메소드가 발생합니다. &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체의 전체 결과 포함 &lt;a href=&quot;#child_process_child_process_spawnsync_command_args_options&quot;&gt; &lt;code&gt;child_process.spawnSync()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ac036a75e1c80eaeb6589cc2f6c7d6f88f1b96" translate="yes" xml:space="preserve">
          <source>If the returned &lt;code&gt;Module&lt;/code&gt;'s &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'unlinked'&lt;/code&gt;, this method will be recursively called on the returned &lt;code&gt;Module&lt;/code&gt; with the same provided &lt;code&gt;linker&lt;/code&gt; function.</source>
          <target state="translated">리턴 된 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;linkingStatus&lt;/code&gt; 가 &lt;code&gt;'unlinked'&lt;/code&gt; unlinked '인 경우 ,이 메소드는 제공된 동일한 &lt;code&gt;linker&lt;/code&gt; 사용하여 리턴 된 &lt;code&gt;Module&lt;/code&gt; 에서 재귀 적으로 호출됩니다. 함수 .</target>
        </trans-unit>
        <trans-unit id="3a9c8f5a9405be2773921d9bcb73c378bf6e3921" translate="yes" xml:space="preserve">
          <source>If the same optional &lt;code&gt;code&lt;/code&gt; is supplied in multiple calls to &lt;code&gt;util.deprecate()&lt;/code&gt;, the warning will be emitted only once for that &lt;code&gt;code&lt;/code&gt;.</source>
          <target state="translated">동일한 선택적 &lt;code&gt;code&lt;/code&gt; 가 &lt;code&gt;util.deprecate()&lt;/code&gt; 에 대한 여러 호출에서 제공 되면 해당 &lt;code&gt;code&lt;/code&gt; 대해 경고가 한 번만 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="69d45b9459a85646bf2862e34f3076974fe78efd" translate="yes" xml:space="preserve">
          <source>If the socket has not been previously bound with a call to &lt;code&gt;bind&lt;/code&gt;, the socket is assigned a random port number and is bound to the &quot;all interfaces&quot; address (&lt;code&gt;'0.0.0.0'&lt;/code&gt; for &lt;code&gt;udp4&lt;/code&gt; sockets, &lt;code&gt;'::0'&lt;/code&gt; for &lt;code&gt;udp6&lt;/code&gt; sockets.)</source>
          <target state="translated">소켓이 이전의 호출에 연결되지 않은 경우 &lt;code&gt;bind&lt;/code&gt; , 소켓은 임의의 포트 번호를 할당하고 &quot;모든 인터페이스&quot;주소 (바인딩되는 &lt;code&gt;'0.0.0.0'&lt;/code&gt; 에 대한 &lt;code&gt;udp4&lt;/code&gt; 의 소켓, &lt;code&gt;'::0'&lt;/code&gt; 에 대한 &lt;code&gt;udp6&lt;/code&gt; 소켓 .)</target>
        </trans-unit>
        <trans-unit id="75c6a8b07a563abb32426fd418fe170dc48b8de5" translate="yes" xml:space="preserve">
          <source>If the third argument is a number, then it specifies &lt;code&gt;flags&lt;/code&gt;:</source>
          <target state="translated">세 번째 인수가 숫자이면 &lt;code&gt;flags&lt;/code&gt; 지정 합니다. .</target>
        </trans-unit>
        <trans-unit id="71076ea98f3be098c307fc8cb0dfd8e11760e9ca" translate="yes" xml:space="preserve">
          <source>If the underlying functionality is not available for some reason, then &lt;code&gt;fs.watch&lt;/code&gt; will not be able to function. For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.</source>
          <target state="translated">어떤 이유로 기본 기능을 사용할 수없는 경우 &lt;code&gt;fs.watch&lt;/code&gt; 가 작동하지 않습니다. 예를 들어 네트워크 파일 시스템 (NFS, SMB 등) 또는 Vagrant, Docker 등과 같은 가상화 소프트웨어를 사용할 때 호스트 파일 시스템에서 파일 또는 디렉토리를 보는 것은 신뢰할 수없고 경우에 따라 불가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3ff204ad926a2c406374c6beb30edbec4c9766" translate="yes" xml:space="preserve">
          <source>If the value assigned to the &lt;code&gt;href&lt;/code&gt; property is not a valid URL, a &lt;code&gt;TypeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; 속성에 할당 된 값 이 유효한 URL이 아닌 경우 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d90c5e203932eeac8e47f38ad8c3558ce56bbc29" translate="yes" xml:space="preserve">
          <source>If the value can not be converted to a number, or is &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt; or &lt;code&gt;-Infinity&lt;/code&gt;, an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">값은 숫자로 변환, 또는이다 할 수없는 경우 &lt;code&gt;NaN&lt;/code&gt; 이 , &lt;code&gt;Infinity&lt;/code&gt; 또는 &lt;code&gt;-Infinity&lt;/code&gt; , &lt;code&gt;Error&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="28e83e66ed225563a93b5f2e19b29f3cc812a630" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;urlObject.hash&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with the ASCII hash (&lt;code&gt;#&lt;/code&gt;) character, the literal string &lt;code&gt;#&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.hash&lt;/code&gt; 의 값이 ASCII 해시 ( &lt;code&gt;#&lt;/code&gt; ) 문자로 &lt;em&gt;시작하지 않으면&lt;/em&gt; 리터럴 문자열 &lt;code&gt;#&lt;/code&gt; 이 &lt;code&gt;result&lt;/code&gt; 추가됩니다. .</target>
        </trans-unit>
        <trans-unit id="354b6656744ff8bd4e88e85fb2306a95eb8ab63e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;urlObject.search&lt;/code&gt;&lt;em&gt;does not start&lt;/em&gt; with the ASCII question mark (&lt;code&gt;?&lt;/code&gt;) character, the literal string &lt;code&gt;?&lt;/code&gt; is appended to &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.search&lt;/code&gt; 의 값이 ASCII 물음표 ( &lt;code&gt;?&lt;/code&gt; ) 문자로 &lt;em&gt;시작하지 않으면&lt;/em&gt; 리터럴 문자열 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4697b6330115dae4c26d7a6e08df799526336ff3" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;urlObject.auth&lt;/code&gt; property is truthy, and either &lt;code&gt;urlObject.host&lt;/code&gt; or &lt;code&gt;urlObject.hostname&lt;/code&gt; are not &lt;code&gt;undefined&lt;/code&gt;, the value of &lt;code&gt;urlObject.auth&lt;/code&gt; will be coerced into a string and appended to &lt;code&gt;result&lt;/code&gt; followed by the literal string &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;urlObject.auth&lt;/code&gt; 특성 의 값 이 진실이고 &lt;code&gt;urlObject.host&lt;/code&gt; 또는 &lt;code&gt;urlObject.hostname&lt;/code&gt; 이 &lt;code&gt;undefined&lt;/code&gt; 되지 않은 경우 &lt;code&gt;urlObject.auth&lt;/code&gt; 의 값이 문자열로 강제 변환되고 &lt;code&gt;result&lt;/code&gt; 에 리터럴 문자열 &lt;code&gt;@&lt;/code&gt; 이 추가됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="982c7fbef3736e828821d5101501a8b60a1d8d1f" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is &lt;code&gt;true&lt;/code&gt; the default searching algorithms will be used to find the module.</source>
          <target state="translated">리디렉션 값이 &lt;code&gt;true&lt;/code&gt; 이면 기본 검색 알고리즘을 사용하여 모듈을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e1f9f5955d6e364ca71ad55b75bc35cbe0c3b38b" translate="yes" xml:space="preserve">
          <source>If the value of the redirection is a string, it will be resolved relative to the manifest and then immediately be used without searching.</source>
          <target state="translated">리디렉션 값이 문자열 인 경우 매니페스트와 관련하여 확인 된 다음 검색하지 않고 즉시 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c8c0c616296b45074943e0b708b25c1e5487f9d" translate="yes" xml:space="preserve">
          <source>If the value provided is larger than V8's maximum, then the largest value will be chosen.</source>
          <target state="translated">제공된 값이 V8의 최대 값보다 큰 경우 가장 큰 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e3c44d16087d66714415a16ae315be1645f738f6" translate="yes" xml:space="preserve">
          <source>If the values are deeply and strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 깊고 엄격 하면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="3feda4cbb8c69da0787d3c4d0edc4afedfe6d516" translate="yes" xml:space="preserve">
          <source>If the values are deeply equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 매우 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="191272d17c26c51430c4e20e797f1caf915bd356" translate="yes" xml:space="preserve">
          <source>If the values are equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="84d94f31db81c1f973e291da465a433690b463c0" translate="yes" xml:space="preserve">
          <source>If the values are not equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 같지 않으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="31b2da7358e1f618e30530614396b01dadfaf51f" translate="yes" xml:space="preserve">
          <source>If the values are not strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 엄격하게 같지 않으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7ff0a2446e1cfa20e6d7e26d965437d954f3efc4" translate="yes" xml:space="preserve">
          <source>If the values are strictly equal, an &lt;code&gt;AssertionError&lt;/code&gt; is thrown with a &lt;code&gt;message&lt;/code&gt; property set equal to the value of the &lt;code&gt;message&lt;/code&gt; parameter. If the &lt;code&gt;message&lt;/code&gt; parameter is undefined, a default error message is assigned. If the &lt;code&gt;message&lt;/code&gt; parameter is an instance of an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; then it will be thrown instead of the &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">값이 완전히 같으면 &lt;code&gt;message&lt;/code&gt; 속성이 &lt;code&gt;message&lt;/code&gt; 매개 변수 값과 동일하게 설정 되어 &lt;code&gt;AssertionError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가 정의되어 있지, 기본 오류 메시지가 할당됩니다. 경우 &lt;code&gt;message&lt;/code&gt; 매개 변수가의 인스턴스 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 다음은 대신의 슬로우됩니다 &lt;code&gt;AssertionError&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="da602dad1348c5515a5368e54eed719f37be707a" translate="yes" xml:space="preserve">
          <source>If there are any remaining open &lt;code&gt;Http2Streams&lt;/code&gt; associated with the &lt;code&gt;Http2Session&lt;/code&gt;, those will also be destroyed.</source>
          <target state="translated">남아있는 열려있는 경우 &lt;code&gt;Http2Streams&lt;/code&gt; 과 관련된 &lt;code&gt;Http2Session&lt;/code&gt; , 사람들은 파괴 될 것이다.</target>
        </trans-unit>
        <trans-unit id="45b740bcc2b16e4bb9b682fe0bd542a05605c049" translate="yes" xml:space="preserve">
          <source>If there are more arguments passed to the &lt;code&gt;util.format()&lt;/code&gt; method than the number of specifiers, the extra arguments are concatenated to the returned string, separated by spaces:</source>
          <target state="translated">지정자 수보다 &lt;code&gt;util.format()&lt;/code&gt; 메소드에 전달 된 인수가 더 많은 경우 추가 인수는 공백으로 구분되어 리턴 된 문자열에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="698579d27a4ddffd0cd3fee0cd725708e9b8c0c0" translate="yes" xml:space="preserve">
          <source>If there are multiple, nested domains bound to the current execution context, &lt;code&gt;exit()&lt;/code&gt; will exit any domains nested within this domain.</source>
          <target state="translated">현재 실행 컨텍스트에 바인딩 된 중첩 된 도메인이 여러 개인 경우 &lt;code&gt;exit()&lt;/code&gt; 는이 도메인 내에 중첩 된 모든 도메인을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="dc6b904b20e2c573a6f4d896aa8a2fa420127eee" translate="yes" xml:space="preserve">
          <source>If there are no pipe destinations, by calling the &lt;a href=&quot;#stream_readable_pause&quot;&gt;&lt;code&gt;stream.pause()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파이프 대상이없는 경우 &lt;a href=&quot;#stream_readable_pause&quot;&gt; &lt;code&gt;stream.pause()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여</target>
        </trans-unit>
        <trans-unit id="53903dbbffb3efe8650a918ab139a66c8a9d7384" translate="yes" xml:space="preserve">
          <source>If there are pipe destinations, by removing all pipe destinations. Multiple pipe destinations may be removed by calling the &lt;a href=&quot;#stream_readable_unpipe_destination&quot;&gt;&lt;code&gt;stream.unpipe()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파이프 대상이있는 경우 모든 파이프 대상을 제거하여 파이프 대상을 제거하십시오. &lt;a href=&quot;#stream_readable_unpipe_destination&quot;&gt; &lt;code&gt;stream.unpipe()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 여러 파이프 대상을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="808ed805596f02baf1205d0104edc17496833e97" translate="yes" xml:space="preserve">
          <source>If there are specific reasons to use &lt;code&gt;process.dlopen()&lt;/code&gt; (for instance, to specify dlopen flags), it's often useful to use &lt;a href=&quot;modules#modules_require_resolve_request_options&quot;&gt;&lt;code&gt;require.resolve()&lt;/code&gt;&lt;/a&gt; to look up the module's path.</source>
          <target state="translated">&lt;code&gt;process.dlopen()&lt;/code&gt; 을 사용해야하는 특정 이유가있는 경우 ( 예 : dlopen 플래그 지정) &lt;a href=&quot;modules#modules_require_resolve_request_options&quot;&gt; &lt;code&gt;require.resolve()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 모듈의 경로를 찾는 것이 종종 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="afc44255b34b29834468d6a2fcd2f10d21a794e9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;'timeout'&lt;/code&gt; event listener on the Server object, then it will be called with the timed-out socket as an argument.</source>
          <target state="translated">가있는 경우 &lt;code&gt;'timeout'&lt;/code&gt; 서버 객체에 이벤트 리스너가, 다음은 인수로 시간이 만료 소켓 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="85fc1803c513e97d473fe51f97314f53ca219f6c" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;original[util.promisify.custom]&lt;/code&gt; property present, &lt;code&gt;promisify&lt;/code&gt; will return its value, see &lt;a href=&quot;#util_custom_promisified_functions&quot;&gt;Custom promisified functions&lt;/a&gt;.</source>
          <target state="translated">이 생길 경우 &lt;code&gt;original[util.promisify.custom]&lt;/code&gt; 속성 존재는 &lt;code&gt;promisify&lt;/code&gt; 은 그 값을 반환 볼 &lt;a href=&quot;#util_custom_promisified_functions&quot;&gt;사용자 정의 기능 promisified&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43f0364f8de171c5fc72a4af4e61f0c6915879a3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;package.json&lt;/code&gt; file present in the directory, or if the &lt;code&gt;'main'&lt;/code&gt; entry is missing or cannot be resolved, then Node.js will attempt to load an &lt;code&gt;index.js&lt;/code&gt; or &lt;code&gt;index.node&lt;/code&gt; file out of that directory. For example, if there was no &lt;code&gt;package.json&lt;/code&gt; file in the above example, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load:</source>
          <target state="translated">어떤이없는 경우 &lt;code&gt;package.json&lt;/code&gt; 의 디렉토리에 파일 존재가 있다면, 또는 &lt;code&gt;'main'&lt;/code&gt; 항목이 없거나 해결할 수없는, 다음 Node.js를가로드하려고 시도 &lt;code&gt;index.js&lt;/code&gt; 또는 &lt;code&gt;index.node&lt;/code&gt; 의 디렉토리에서 파일을. 예를 들어, 위 예제에 &lt;code&gt;package.json&lt;/code&gt; 파일 이 없으면 &lt;code&gt;require('./some-library')&lt;/code&gt; 가로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="7e0cb8b2e9ee0148b30bf42005c017e69093ae44" translate="yes" xml:space="preserve">
          <source>If there is no local certificate, an empty object will be returned. If the socket has been destroyed, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">로컬 인증서가 없으면 빈 개체가 반환됩니다. 소켓이 파괴 된 경우는 &lt;code&gt;null&lt;/code&gt; 을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="8d88cc35a1e5f4ab2434014beef29a6b8b2436e3" translate="yes" xml:space="preserve">
          <source>If these attempts fail, then Node.js will report the entire module as missing with the default error:</source>
          <target state="translated">이러한 시도가 실패하면 Node.js는 기본 오류와 함께 전체 모듈이 누락 된 것으로보고합니다.</target>
        </trans-unit>
        <trans-unit id="01e89fda5beccddb8f1c71631aaa97e426bae7a5" translate="yes" xml:space="preserve">
          <source>If this flag is passed, the behavior can still be set to not abort through &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt;&lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt;&lt;/a&gt; (and through usage of the &lt;code&gt;domain&lt;/code&gt; module that uses it).</source>
          <target state="translated">이 플래그가 전달되면 &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt; &lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt; &lt;/a&gt; 및이를 사용하는 &lt;code&gt;domain&lt;/code&gt; 모듈 사용을 통해 동작이 중단되지 않도록 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f39b5b9c13b1ddf3e432e4ec5ca8712b07563b19" translate="yes" xml:space="preserve">
          <source>If this method is &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesWritten&lt;/code&gt; and &lt;code&gt;buffers&lt;/code&gt; properties.</source>
          <target state="translated">이 메소드가 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;bytesWritten&lt;/code&gt; 및 &lt;code&gt;buffers&lt;/code&gt; 특성을 가진 &lt;code&gt;Object&lt;/code&gt; 대한 &lt;code&gt;Promise&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="848ee8754e17695db5eea6ee56dc831672698103" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http2_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt; has not been called, it will switch to implicit header mode and flush the implicit headers.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http2_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 암시 적 헤더 모드로 전환하고 암시 적 헤더를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="863ede4dd3d457c897371e8202fbec82f0818194" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt;&lt;code&gt;response.setHeader()&lt;/code&gt;&lt;/a&gt; has not been called, it will directly write the supplied header values onto the network channel without caching internally, and the &lt;a href=&quot;#http_response_getheader_name&quot;&gt;&lt;code&gt;response.getHeader()&lt;/code&gt;&lt;/a&gt; on the header will not yield the expected result. If progressive population of headers is desired with potential future retrieval and modification, use &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt;&lt;code&gt;response.setHeader()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt; &lt;code&gt;response.setHeader()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 내부적으로 캐싱하지 않고 제공된 헤더 값을 네트워크 채널에 직접 쓰며 헤더의 &lt;a href=&quot;#http_response_getheader_name&quot;&gt; &lt;code&gt;response.getHeader()&lt;/code&gt; &lt;/a&gt; 는 예상 된 결과를 산출하지 않습니다. 향후 검색 및 수정이 가능한 점진적인 헤더 모집이 필요한 경우 &lt;a href=&quot;#http_response_setheader_name_value&quot;&gt; &lt;code&gt;response.setHeader()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f8bf717520bed1a535f84bb455286f68447c2d06" translate="yes" xml:space="preserve">
          <source>If this method is called and &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt;&lt;code&gt;response.writeHead()&lt;/code&gt;&lt;/a&gt; has not been called, it will switch to implicit header mode and flush the implicit headers.</source>
          <target state="translated">이 메소드가 호출되고 &lt;a href=&quot;#http_response_writehead_statuscode_statusmessage_headers&quot;&gt; &lt;code&gt;response.writeHead()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않은 경우 암시 적 헤더 모드로 전환하고 암시 적 헤더를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="59b52c6bec23c453cf6476176e31528205155635" translate="yes" xml:space="preserve">
          <source>If this method is called without a label, the most recently started profile is stopped.</source>
          <target state="translated">레이블없이이 메소드를 호출하면 가장 최근에 시작된 프로파일이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="da8ccda14c2d5edd4fce7c787763bcd45d9f4a10" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, and &lt;code&gt;all&lt;/code&gt; is not set to &lt;code&gt;true&lt;/code&gt;, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;family&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에디션 버전, &lt;code&gt;all&lt;/code&gt; 로 설정되지 않은 &lt;code&gt;true&lt;/code&gt; , 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;address&lt;/code&gt; 및 &lt;code&gt;family&lt;/code&gt; 특성.</target>
        </trans-unit>
        <trans-unit id="fc491ff668f0ad005b523fb4afb065a33fd0ce04" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesRead&lt;/code&gt; and &lt;code&gt;buffer&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;bytesRead&lt;/code&gt; 및 &lt;code&gt;buffer&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="d137547d5ca92dc63e7c2007a92f1e7211e167ad" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;bytesWritten&lt;/code&gt; and &lt;code&gt;buffer&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;bytesWritten&lt;/code&gt; 및 &lt;code&gt;buffer&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="fd5bb143ee298fdd24e036558635695a1e0cd676" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;hostname&lt;/code&gt; and &lt;code&gt;service&lt;/code&gt; properties.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;hostname&lt;/code&gt; 및 &lt;code&gt;service&lt;/code&gt; 특성.</target>
        </trans-unit>
        <trans-unit id="603337fd667fc9ebe65d8742a13478c7c173636d" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;publicKey&lt;/code&gt; and &lt;code&gt;privateKey&lt;/code&gt; properties.</source>
          <target state="translated">이 메소드가 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 버전 으로 호출되면 &lt;code&gt;publicKey&lt;/code&gt; 및 &lt;code&gt;privateKey&lt;/code&gt; 특성을 가진 &lt;code&gt;Object&lt;/code&gt; 대한 &lt;code&gt;Promise&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="e3f19615a76df308a4eaaa08102fe8029d4cd7da" translate="yes" xml:space="preserve">
          <source>If this method is invoked as its &lt;a href=&quot;util#util_util_promisify_original&quot;&gt;&lt;code&gt;util.promisify()&lt;/code&gt;&lt;/a&gt;ed version, it returns a &lt;code&gt;Promise&lt;/code&gt; for an &lt;code&gt;Object&lt;/code&gt; with &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; properties. The returned &lt;code&gt;ChildProcess&lt;/code&gt; instance is attached to the &lt;code&gt;Promise&lt;/code&gt; as a &lt;code&gt;child&lt;/code&gt; property. In case of an error (including any error resulting in an exit code other than 0), a rejected promise is returned, with the same &lt;code&gt;error&lt;/code&gt; object given in the callback, but with two additional properties &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">이 방법은 그것으로 호출되면 &lt;a href=&quot;util#util_util_promisify_original&quot;&gt; &lt;code&gt;util.promisify()&lt;/code&gt; &lt;/a&gt; 에드 버전, 그것은 반환 &lt;code&gt;Promise&lt;/code&gt; 에 대한 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;stdout&lt;/code&gt; 과 &lt;code&gt;stderr&lt;/code&gt; 속성. 반환 된 &lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스는 &lt;code&gt;Promise&lt;/code&gt; 에 &lt;code&gt;child&lt;/code&gt; 속성으로 연결됩니다. 오류 (0 이외의 종료 코드를 초래하는 오류 포함)의 경우, 콜백에 제공된 동일한 &lt;code&gt;error&lt;/code&gt; 오브젝트와 함께 두 개의 추가 특성 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 과 함께 거부 된 약속이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="a19ad792e4d182ce79c59a9ca23b96f01cbba405" translate="yes" xml:space="preserve">
          <source>If this option is chosen, most internationalization features mentioned above will be &lt;strong&gt;unavailable&lt;/strong&gt; in the resulting &lt;code&gt;node&lt;/code&gt; binary.</source>
          <target state="translated">이 옵션을 선택하면 위에서 언급 한 대부분의 국제화 기능을 결과 &lt;code&gt;node&lt;/code&gt; 2 진 에서 &lt;strong&gt;사용할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="500c44aa740b1f808b7a0f2ab5d42a89495c80b0" translate="yes" xml:space="preserve">
          <source>If this program is run with &lt;code&gt;NODE_DEBUG=foo&lt;/code&gt; in the environment, then it will output something like:</source>
          <target state="translated">이 프로그램이 환경에서 &lt;code&gt;NODE_DEBUG=foo&lt;/code&gt; 로 실행 되면 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ae04778b2127a4288d498c5fee83b1c180563316" translate="yes" xml:space="preserve">
          <source>If this thread was spawned as a &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, this will be a &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt; allowing communication with the parent thread. Messages sent using &lt;code&gt;parentPort.postMessage()&lt;/code&gt; will be available in the parent thread using &lt;code&gt;worker.on('message')&lt;/code&gt;, and messages sent from the parent thread using &lt;code&gt;worker.postMessage()&lt;/code&gt; will be available in this thread using &lt;code&gt;parentPort.on('message')&lt;/code&gt;.</source>
          <target state="translated">이 스레드가 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 으로 생성 된 경우 상위 스레드와의 통신을 허용 하는 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 가됩니다 . &lt;code&gt;parentPort.postMessage()&lt;/code&gt; 를 사용하여 전송 된 메시지는 &lt;code&gt;worker.on('message')&lt;/code&gt; 를 사용하여 상위 스레드 에서 사용할 수 있으며 &lt;code&gt;worker.postMessage()&lt;/code&gt; 를 사용하여 상위 스레드에서 전송 된 메시지는 &lt;code&gt;parentPort.on('message')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc56c6fa0ffaae3cb37166a046e6a592fac511fd" translate="yes" xml:space="preserve">
          <source>If this was in a folder at &lt;code&gt;./some-library&lt;/code&gt;, then &lt;code&gt;require('./some-library')&lt;/code&gt; would attempt to load &lt;code&gt;./some-library/lib/some-library.js&lt;/code&gt;.</source>
          <target state="translated">이에 폴더에있는 경우 &lt;code&gt;./some-library&lt;/code&gt; , 다음 &lt;code&gt;require('./some-library')&lt;/code&gt; 부하를 시도 할 &lt;code&gt;./some-library/lib/some-library.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f24447a04296622991f6bf6fd22ce1eff8075cb0" translate="yes" xml:space="preserve">
          <source>If true, the &lt;code&gt;Immediate&lt;/code&gt; object will keep the Node.js event loop active.</source>
          <target state="translated">true 인 경우 &lt;code&gt;Immediate&lt;/code&gt; 객체는 Node.js 이벤트 루프를 활성 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6bfdfe9d5a5d4ec04917fff9485b8abe04f4523b" translate="yes" xml:space="preserve">
          <source>If true, the &lt;code&gt;Timeout&lt;/code&gt; object will keep the Node.js event loop active.</source>
          <target state="translated">true 인 경우 &lt;code&gt;Timeout&lt;/code&gt; 객체는 Node.js 이벤트 루프를 활성 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4d30f4ae940d81fef9d58173f937c6e90488a310" translate="yes" xml:space="preserve">
          <source>If using Perfect Forward Secrecy using &lt;code&gt;ECDHE&lt;/code&gt;, Diffie-Hellman parameters are not required and a default ECDHE curve will be used. The &lt;code&gt;ecdhCurve&lt;/code&gt; property can be used when creating a TLS Server to specify the list of names of supported curves to use, see &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt;&lt;code&gt;tls.createServer()&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">&lt;code&gt;ECDHE&lt;/code&gt; 를 사용하여 Perfect Forward Secrecy를 사용 하는 경우 Diffie-Hellman 매개 변수가 필요하지 않으며 기본 ECDHE 곡선이 사용됩니다. &lt;code&gt;ecdhCurve&lt;/code&gt; 의 속성은 사용에 지원 곡선의 이름 목록을 지정하는 TLS 서버를 만들 때 사용할 수있는 참조 &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt; &lt;code&gt;tls.createServer()&lt;/code&gt; &lt;/a&gt; 추가 정보를 원하시면.</target>
        </trans-unit>
        <trans-unit id="f435cf016bb3848af3be13125a0963095befa409" translate="yes" xml:space="preserve">
          <source>If wait is &lt;code&gt;true&lt;/code&gt;, will block until a client has connected to the inspect port and flow control has been passed to the debugger client.</source>
          <target state="translated">wait가 &lt;code&gt;true&lt;/code&gt; 이면 클라이언트가 검사 포트에 연결되고 흐름 제어가 디버거 클라이언트에 전달 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="868930280894191b54d63d2127ac6fdebf557223" translate="yes" xml:space="preserve">
          <source>Immediate</source>
          <target state="translated">Immediate</target>
        </trans-unit>
        <trans-unit id="ef70f1951457da5e8c2ceb794366acfb2b9f1c46" translate="yes" xml:space="preserve">
          <source>Immediately close the session. All pending message callbacks will be called with an error. &lt;a href=&quot;#inspector_session_connect&quot;&gt;&lt;code&gt;session.connect()&lt;/code&gt;&lt;/a&gt; will need to be called to be able to send messages again. Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.</source>
          <target state="translated">세션을 즉시 닫습니다. 보류중인 모든 메시지 콜백은 오류와 함께 호출됩니다. 메시지를 다시 보내려면 &lt;a href=&quot;#inspector_session_connect&quot;&gt; &lt;code&gt;session.connect()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다. 다시 연결된 세션은 활성화 된 에이전트 또는 구성된 중단 점과 같은 모든 관리자 상태를 잃게됩니다.</target>
        </trans-unit>
        <trans-unit id="a99a34a2338aa3ca62a62f452af4cdab32edc49b" translate="yes" xml:space="preserve">
          <source>Immediately terminates the &lt;code&gt;Http2Session&lt;/code&gt; and the associated &lt;code&gt;net.Socket&lt;/code&gt; or &lt;code&gt;tls.TLSSocket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 및 관련 &lt;code&gt;net.Socket&lt;/code&gt; 또는 &lt;code&gt;tls.TLSSocket&lt;/code&gt; 을 즉시 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="7830d9e83bdb571cca1e50f542e8516184aeb2bf" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="translated">구현 고려 사항</target>
        </trans-unit>
        <trans-unit id="634778886a41465d653b4d3a526333668ae37b90" translate="yes" xml:space="preserve">
          <source>Implementation does not test the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots&quot;&gt;&lt;code&gt;[[Prototype]]&lt;/code&gt;&lt;/a&gt; of objects.</source>
          <target state="translated">구현은 객체 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots&quot;&gt; &lt;code&gt;[[Prototype]]&lt;/code&gt; &lt;/a&gt; 을 테스트하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b6d9cd007a22716a471f704b1a6cc1b7798fc03" translate="yes" xml:space="preserve">
          <source>Implementations of this type of function should avoid making any N-API calls that could result in the execution of JavaScript or interaction with JavaScript objects. Most often, any code that needs to make N-API calls should be made in &lt;code&gt;napi_async_complete_callback&lt;/code&gt; instead. Avoid using the &lt;code&gt;napi_env&lt;/code&gt; parameter in the execute callback as it will likely execute JavaScript.</source>
          <target state="translated">이 유형의 함수를 구현하면 JavaScript가 실행되거나 JavaScript 객체와 상호 작용할 수있는 N-API 호출을 피해야합니다. 대부분의 경우 N-API 호출이 필요한 코드는 대신 &lt;code&gt;napi_async_complete_callback&lt;/code&gt; 에서 작성 해야합니다 . JavaScript를 실행할 가능성이 있으므로 실행 콜백에서 &lt;code&gt;napi_env&lt;/code&gt; 매개 변수를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="faf48c742a3c8cab6d288870f7e9087dc4b107e3" translate="yes" xml:space="preserve">
          <source>Implementing a Duplex Stream</source>
          <target state="translated">이중 스트림 구현</target>
        </trans-unit>
        <trans-unit id="db85aacb4826a9682bbc4755f7b18287b8212229" translate="yes" xml:space="preserve">
          <source>Implementing a Readable Stream</source>
          <target state="translated">읽을 수있는 스트림 구현</target>
        </trans-unit>
        <trans-unit id="a5a17668a54393ad9d8a2818f383b3289899b323" translate="yes" xml:space="preserve">
          <source>Implementing a Transform Stream</source>
          <target state="translated">변환 스트림 구현</target>
        </trans-unit>
        <trans-unit id="03961dad0ca35871550bb64b77b7602fe30a905c" translate="yes" xml:space="preserve">
          <source>Implementing a Writable Stream</source>
          <target state="translated">쓰기 가능한 스트림 구현</target>
        </trans-unit>
        <trans-unit id="0b72b192149e114c030ffa08bb6d7f33fa1da0cd" translate="yes" xml:space="preserve">
          <source>Implications of ABI Stability</source>
          <target state="translated">ABI 안정성의 의미</target>
        </trans-unit>
        <trans-unit id="e5868306e35f5ed89a827d7088b357d35fdb7d9c" translate="yes" xml:space="preserve">
          <source>Implicit Binding</source>
          <target state="translated">암시 적 바인딩</target>
        </trans-unit>
        <trans-unit id="38c43897c9e7ad17a3fff4ee301c220a1f8ca4ce" translate="yes" xml:space="preserve">
          <source>Implicit binding routes thrown errors and &lt;code&gt;'error'&lt;/code&gt; events to the &lt;code&gt;Domain&lt;/code&gt;'s &lt;code&gt;'error'&lt;/code&gt; event, but does not register the &lt;code&gt;EventEmitter&lt;/code&gt; on the &lt;code&gt;Domain&lt;/code&gt;. Implicit binding only takes care of thrown errors and &lt;code&gt;'error'&lt;/code&gt; events.</source>
          <target state="translated">내재 된 바인딩은 &lt;code&gt;'error'&lt;/code&gt; 오류 및 '오류' 이벤트를 &lt;code&gt;Domain&lt;/code&gt; 의 &lt;code&gt;'error'&lt;/code&gt; 이벤트로 라우팅 하지만 &lt;code&gt;Domain&lt;/code&gt; &lt;code&gt;EventEmitter&lt;/code&gt; 를 등록하지는 않습니다 . 암시 적 바인딩은 발생 된 오류 및 &lt;code&gt;'error'&lt;/code&gt; 이벤트 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7eccc8d808af7ec8041e3741f9d5bd71307f86ba" translate="yes" xml:space="preserve">
          <source>Implicit conversion of variable value to string is deprecated.</source>
          <target state="translated">변수 값을 문자열로 암시 적으로 변환하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fac758850e503d7a4b5403c1e169e629ed31d72d" translate="yes" xml:space="preserve">
          <source>Importing Web Assembly modules is supported under the &lt;code&gt;--experimental-wasm-modules&lt;/code&gt; flag, allowing any &lt;code&gt;.wasm&lt;/code&gt; files to be imported as normal modules while also supporting their module imports.</source>
          <target state="translated">웹 어셈블리 모듈 가져 오기는 &lt;code&gt;--experimental-wasm-modules&lt;/code&gt; 플래그에서 지원되므로 &lt;code&gt;.wasm&lt;/code&gt; 파일을 일반 모듈로 가져올 수 있으며 모듈 가져 오기도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7345227f7378a415d72e584bcb83fb5f70dfbf9d" translate="yes" xml:space="preserve">
          <source>Importing assert directly was not recommended as the exposed functions use loose equality checks. The deprecation was revoked because use of the &lt;code&gt;assert&lt;/code&gt; module is not discouraged, and the deprecation caused end user confusion.</source>
          <target state="translated">노출 된 함수가 느슨한 동등성 검사를 사용하므로 어설 션을 직접 가져 오는 것은 권장되지 않습니다. &lt;code&gt;assert&lt;/code&gt; 모듈의 사용을 권장하지 않아 폐기가 취소되었으며 폐기시 최종 사용자 혼란이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="719f27a57e84457bcd0681fc9a845a1f86dcefe3" translate="yes" xml:space="preserve">
          <source>Impose new restrictions on &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, throwing more appropriate errors in cases when we cannot reasonably handle the input values.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 에 새로운 제한을 적용 하여 입력 값을 합리적으로 처리 할 수없는 경우 더 적절한 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fc0a6a13b4155e379d15b548250d87be9841ca3e" translate="yes" xml:space="preserve">
          <source>In &quot;old&quot; streams mode the &lt;code&gt;stdin&lt;/code&gt; stream is paused by default, so one must call &lt;code&gt;process.stdin.resume()&lt;/code&gt; to read from it. Note also that calling &lt;code&gt;process.stdin.resume()&lt;/code&gt; itself would switch stream to &quot;old&quot; mode.</source>
          <target state="translated">&quot;오래된&quot;스트림 모드에서는 &lt;code&gt;stdin&lt;/code&gt; 스트림이 기본적으로 일시 중지되므로 &lt;code&gt;process.stdin.resume()&lt;/code&gt; 을 호출 하여 읽어야합니다. &lt;code&gt;process.stdin.resume()&lt;/code&gt; 자체 를 호출 하면 스트림이 &quot;old&quot;모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="27679f0db56c1c9325293a60e2506baf9182ffc5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads, this function stops the current thread rather than the current process.</source>
          <target state="translated">에서는 &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드,이 기능은 현재 스레드보다는 현재의 처리를 정지한다.</target>
        </trans-unit>
        <trans-unit id="2b5b31a009a869ce0f6f2aa3aa25bde8d5d67b27" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;entry.js&lt;/code&gt; script:</source>
          <target state="translated">에서 &lt;code&gt;entry.js&lt;/code&gt; 스크립트 :</target>
        </trans-unit>
        <trans-unit id="83ea6fb909458a63c93528b9278d2aea405239a1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.cc&lt;/code&gt;, implement the various methods that are to be exposed. Below, the method &lt;code&gt;plusOne()&lt;/code&gt; is exposed by adding it to the constructor's prototype:</source>
          <target state="translated">에서 &lt;code&gt;myobject.cc&lt;/code&gt; 노출 될 수있는 다양한 방법을 구현한다. 아래에서 &lt;code&gt;plusOne()&lt;/code&gt; 메소드 는 생성자의 프로토 타입에 추가하여 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="b569f0f01f808badd954c94c4b5ec2b3df4219a8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.h&lt;/code&gt;, a new public method is added to allow access to private values after unwrapping the object.</source>
          <target state="translated">에서는 &lt;code&gt;myobject.h&lt;/code&gt; 새로운 공용 방법은 대상물을 언 래핑 된 후 개인 값에 액세스 할 수 있도록 첨가된다.</target>
        </trans-unit>
        <trans-unit id="0bd614b7bbedcda99d367f704661d8a38b80d19b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;myobject.h&lt;/code&gt;, the static method &lt;code&gt;NewInstance()&lt;/code&gt; is added to handle instantiating the object. This method takes the place of using &lt;code&gt;new&lt;/code&gt; in JavaScript:</source>
          <target state="translated">에서는 &lt;code&gt;myobject.h&lt;/code&gt; 정적 메소드 &lt;code&gt;NewInstance()&lt;/code&gt; 객체를 인스턴스화하기 위해 추가 처리된다. 이 방법은 JavaScript에서 &lt;code&gt;new&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="13a521caf867f14b672bcba06c835d82f3666953" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;strict&lt;/code&gt; mode, &lt;code&gt;assert&lt;/code&gt; functions use the comparison in the corresponding strict functions. For example, &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepEqual()&lt;/code&gt;&lt;/a&gt; will behave like &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt;&lt;code&gt;assert.deepStrictEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;code&gt;strict&lt;/code&gt; 모드, &lt;code&gt;assert&lt;/code&gt; 기능은 해당 엄격한 기능의 비교를 사용합니다. 예를 들어 &lt;a href=&quot;#assert_assert_deepequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepEqual()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#assert_assert_deepstrictequal_actual_expected_message&quot;&gt; &lt;code&gt;assert.deepStrictEqual()&lt;/code&gt; &lt;/a&gt; 과 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cbda2fb906abaf4d990f04c00aee85dda9e4e31b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;strict&lt;/code&gt; mode, error messages for objects display a diff. In legacy mode, error messages for objects display the objects, often truncated.</source>
          <target state="translated">&lt;code&gt;strict&lt;/code&gt; 모드 에서는 객체의 오류 메시지에 차이가 표시됩니다. 레거시 모드에서 개체에 대한 오류 메시지는 종종 잘린 개체를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1cedb49bba43339d6f4d8ab4643cc70bc8770d4d" translate="yes" xml:space="preserve">
          <source>In HTTP/2, the request path, hostname, protocol, and method are represented as special headers prefixed with the &lt;code&gt;:&lt;/code&gt; character (e.g. &lt;code&gt;':path'&lt;/code&gt;). These special headers will be included in the &lt;code&gt;request.headers&lt;/code&gt; object. Care must be taken not to inadvertently modify these special headers or errors may occur. For instance, removing all headers from the request will cause errors to occur:</source>
          <target state="translated">HTTP / 2에서 요청 경로, 호스트 이름, 프로토콜 및 메소드는 &lt;code&gt;:&lt;/code&gt; 문자 (예 : &lt;code&gt;':path'&lt;/code&gt; )로 시작하는 특수 헤더로 표시됩니다 . 이러한 특수 헤더는 &lt;code&gt;request.headers&lt;/code&gt; 객체에 포함됩니다 . 이러한 특수 헤더를 실수로 수정하지 않도록주의해야합니다. 그렇지 않으면 오류가 발생할 수 있습니다. 예를 들어 요청에서 모든 헤더를 제거하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2cd10f4ffa78b420a67631c95f5747ddf8e5371" translate="yes" xml:space="preserve">
          <source>In Node.js 0.10, the &lt;a href=&quot;#stream_class_stream_readable&quot;&gt;&lt;code&gt;Readable&lt;/code&gt;&lt;/a&gt; class was added. For backward compatibility with older Node.js programs, &lt;code&gt;Readable&lt;/code&gt; streams switch into &quot;flowing mode&quot; when a &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; event handler is added, or when the &lt;a href=&quot;#stream_readable_resume&quot;&gt;&lt;code&gt;stream.resume()&lt;/code&gt;&lt;/a&gt; method is called. The effect is that, even when not using the new &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; method and &lt;a href=&quot;#stream_event_readable&quot;&gt;&lt;code&gt;'readable'&lt;/code&gt;&lt;/a&gt; event, it is no longer necessary to worry about losing &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; chunks.</source>
          <target state="translated">Node.js 0.10에서 &lt;a href=&quot;#stream_class_stream_readable&quot;&gt; &lt;code&gt;Readable&lt;/code&gt; &lt;/a&gt; 클래스가 추가되었습니다. 이전 Node.js 프로그램과의 호환성을 위해 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 이벤트 핸들러가 추가되거나 &lt;a href=&quot;#stream_readable_resume&quot;&gt; &lt;code&gt;stream.resume()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때 &lt;code&gt;Readable&lt;/code&gt; 스트림이 &quot;흐르는 모드&quot;로 전환됩니다 . 결과적으로 새로운 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 메소드와 &lt;a href=&quot;#stream_event_readable&quot;&gt; &lt;code&gt;'readable'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용하지 않더라도 &lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 청크 손실에 대해 더 이상 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d2907f0887fd67060d1c8b859ffab65821bd5c8a" translate="yes" xml:space="preserve">
          <source>In V8, a context is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of V8. You must explicitly specify the context in which you want any JavaScript code to be run.</source>
          <target state="translated">V8에서 컨텍스트는 별도의 관련되지 않은 JavaScript 애플리케이션이 단일 V8 인스턴스에서 실행될 수있는 실행 환경입니다. JavaScript 코드를 실행할 컨텍스트를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f608ecc99c06cfa50baaffc2c3cd8fff338f4fc" translate="yes" xml:space="preserve">
          <source>In a successful request, the following events will be emitted in the following order:</source>
          <target state="translated">요청이 성공하면 다음과 같은 순서로 다음 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cf790810b2507f884c03af267a9c95a2dbc7ba26" translate="yes" xml:space="preserve">
          <source>In a worker this sends a message to the master. It is identical to &lt;code&gt;process.send()&lt;/code&gt;.</source>
          <target state="translated">작업자는 마스터에게 메시지를 보냅니다. &lt;code&gt;process.send()&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="89f9cefb5509de84f4d3b8e9ae50db89a7da0b91" translate="yes" xml:space="preserve">
          <source>In a worker, &lt;code&gt;process.disconnect&lt;/code&gt; exists, but it is not this function; it is &lt;a href=&quot;child_process#child_process_subprocess_disconnect&quot;&gt;&lt;code&gt;disconnect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자에게는 &lt;code&gt;process.disconnect&lt;/code&gt; 가 존재하지만이 기능은 아닙니다. 그것은 &lt;a href=&quot;child_process#child_process_subprocess_disconnect&quot;&gt; &lt;code&gt;disconnect()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6635bab64752609670a0d11b7b0ac6ba30c036b1" translate="yes" xml:space="preserve">
          <source>In a worker, &lt;code&gt;process.kill()&lt;/code&gt; exists, but it is not this function; it is &lt;a href=&quot;process#process_process_kill_pid_signal&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자에는 &lt;code&gt;process.kill()&lt;/code&gt; 이 있지만이 함수는 아닙니다. 그것이 &lt;a href=&quot;process#process_process_kill_pid_signal&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="188dc51b267f1ce409fcd61f18bf1777940cfa1c" translate="yes" xml:space="preserve">
          <source>In a worker, this function will close all servers, wait for the &lt;code&gt;'close'&lt;/code&gt; event on those servers, and then disconnect the IPC channel.</source>
          <target state="translated">작업자의 경우이 기능은 모든 서버를 &lt;code&gt;'close'&lt;/code&gt; 해당 서버 에서 '닫기' 이벤트를 기다린 다음 IPC 채널의 연결을 끊습니다.</target>
        </trans-unit>
        <trans-unit id="c45585efffb25f706fc168893be3eee9fb3732c3" translate="yes" xml:space="preserve">
          <source>In accordance with browser conventions, all properties of &lt;code&gt;URL&lt;/code&gt; objects are implemented as getters and setters on the class prototype, rather than as data properties on the object itself. Thus, unlike &lt;a href=&quot;#url_legacy_urlobject&quot;&gt;legacy &lt;code&gt;urlObject&lt;/code&gt;&lt;/a&gt;s, using the &lt;code&gt;delete&lt;/code&gt; keyword on any properties of &lt;code&gt;URL&lt;/code&gt; objects (e.g. &lt;code&gt;delete myURL.protocol&lt;/code&gt;, &lt;code&gt;delete myURL.pathname&lt;/code&gt;, etc) has no effect but will still return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">브라우저 규칙에 따라 &lt;code&gt;URL&lt;/code&gt; 객체 의 모든 속성은 객체 자체의 데이터 속성이 아니라 클래스 프로토 타입에서 getter 및 setter로 구현됩니다. 따라서 &lt;a href=&quot;#url_legacy_urlobject&quot;&gt;레거시 &lt;code&gt;urlObject&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;URL&lt;/code&gt; 객체의 속성에 &lt;code&gt;delete&lt;/code&gt; 키워드를 사용하면 (예 : &lt;code&gt;delete myURL.protocol&lt;/code&gt; , &lt;code&gt;delete myURL.pathname&lt;/code&gt; 등) 아무런 영향이 없지만 여전히 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7734f0b3567b3c7b9193631a31766ec4ead09b" translate="yes" xml:space="preserve">
          <source>In addition to being accessible through &lt;code&gt;util.inspect.custom&lt;/code&gt;, this symbol is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;registered globally&lt;/a&gt; and can be accessed in any environment as &lt;code&gt;Symbol.for('nodejs.util.inspect.custom')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;util.inspect.custom&lt;/code&gt; 을 통해 액세스 할 수있을뿐만 &lt;code&gt;Symbol.for('nodejs.util.inspect.custom')&lt;/code&gt; 기호는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for&quot;&gt;전체적으로 등록&lt;/a&gt; 되며 모든 환경에서 Symbol.for ( 'nodejs.util.inspect.custom') 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a017a14a50b8af7f35bbfe35a7128002e7b0433" translate="yes" xml:space="preserve">
          <source>In addition to defining an alias, subpaths not defined by &lt;code&gt;&quot;exports&quot;&lt;/code&gt; will throw when an attempt is made to import them:</source>
          <target state="translated">별명을 정의하는 것 외에도, &lt;code&gt;&quot;exports&quot;&lt;/code&gt; 에 의해 정의되지 않은 서브 패스 는 그것들을 가져 오려고 시도 할 때 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="87788a1c64b835765d4d327b936fd17de0ba8095" translate="yes" xml:space="preserve">
          <source>In addition to new &lt;code&gt;Readable&lt;/code&gt; streams switching into flowing mode, pre-0.10 style streams can be wrapped in a &lt;code&gt;Readable&lt;/code&gt; class using the &lt;a href=&quot;#stream_readable_wrap_stream&quot;&gt;&lt;code&gt;readable.wrap()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유동 모드로 전환되는 새로운 &lt;code&gt;Readable&lt;/code&gt; 스트림 외에도 , 10.10 이전 스타일의 스트림은 &lt;a href=&quot;#stream_readable_wrap_stream&quot;&gt; &lt;code&gt;readable.wrap()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;Readable&lt;/code&gt; 클래스 로 래핑 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="531fe4364b08e0a91d004f6c008a9907fd321d5e" translate="yes" xml:space="preserve">
          <source>In addition to returning the resolved file URL value, the resolve hook also returns a &lt;code&gt;format&lt;/code&gt; property specifying the module format of the resolved module. This can be one of the following:</source>
          <target state="translated">확인 된 파일 URL 값을 반환하는 것 외에도 확인 후크는 확인 된 모듈의 모듈 형식을 지정 하는 &lt;code&gt;format&lt;/code&gt; 속성 도 반환 합니다. 이것은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b72f820929e77bac018c0ca5b3cc4d77951c0c" translate="yes" xml:space="preserve">
          <source>In addition to wrapping and returning C++ objects, it is possible to pass wrapped objects around by unwrapping them with the Node.js helper function &lt;code&gt;node::ObjectWrap::Unwrap&lt;/code&gt;. The following examples shows a function &lt;code&gt;add()&lt;/code&gt; that can take two &lt;code&gt;MyObject&lt;/code&gt; objects as input arguments:</source>
          <target state="translated">C ++ 객체를 래핑하고 반환하는 것 외에도 Node.js 도우미 함수 &lt;code&gt;node::ObjectWrap::Unwrap&lt;/code&gt; 으로 래핑하여 래핑 된 객체를 전달할 수 있습니다 . 다음 예제는 두 개의 &lt;code&gt;MyObject&lt;/code&gt; 객체를 입력 인수로 사용할 수있는 &lt;code&gt;add()&lt;/code&gt; 함수를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3250b3c9156a53b11995d8b61bc7651346b38dd6" translate="yes" xml:space="preserve">
          <source>In an earlier version of the Node.js &lt;code&gt;cluster&lt;/code&gt;, a boolean property with the name &lt;code&gt;suicide&lt;/code&gt; was added to the &lt;code&gt;Worker&lt;/code&gt; object. The intent of this property was to provide an indication of how and why the &lt;code&gt;Worker&lt;/code&gt; instance exited. In Node.js 6.0.0, the old property was deprecated and replaced with a new &lt;a href=&quot;cluster#cluster_worker_exitedafterdisconnect&quot;&gt;&lt;code&gt;worker.exitedAfterDisconnect&lt;/code&gt;&lt;/a&gt; property. The old property name did not precisely describe the actual semantics and was unnecessarily emotion-laden.</source>
          <target state="translated">Node.js &lt;code&gt;cluster&lt;/code&gt; 의 이전 버전 에서는 이름이 &lt;code&gt;suicide&lt;/code&gt; 부울 속성 이 &lt;code&gt;Worker&lt;/code&gt; 객체 에 추가되었습니다 . 이 특성의 목적은 &lt;code&gt;Worker&lt;/code&gt; 인스턴스가 어떻게, 왜 종료 했는지 표시하는 것입니다 . Node.js 6.0.0에서는 이전 속성이 더 이상 사용되지 않고 새로운 &lt;a href=&quot;cluster#cluster_worker_exitedafterdisconnect&quot;&gt; &lt;code&gt;worker.exitedAfterDisconnect&lt;/code&gt; &lt;/a&gt; 속성으로 대체되었습니다 . 오래된 속성 이름은 실제 의미를 정확하게 설명하지 않았으며 불필요하게 감정이 가득했습니다.</target>
        </trans-unit>
        <trans-unit id="45f34b6c8dddeb170b4ea2c2a91a4f0f3bf29b30" translate="yes" xml:space="preserve">
          <source>In asynchronous code, the &lt;code&gt;'unhandledRejection'&lt;/code&gt; event is emitted when the list of unhandled rejections grows, and the &lt;code&gt;'rejectionHandled'&lt;/code&gt; event is emitted when the list of unhandled rejections shrinks.</source>
          <target state="translated">비동기 코드에서 처리되지 않은 거부 목록이 커지면 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트가 생성되고 처리되지 않은 거부 목록이 줄어들 면 &lt;code&gt;'rejectionHandled'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="30fe6e0dbb3ad0e70ec0d1b125ead1922456d17e" translate="yes" xml:space="preserve">
          <source>In browsers, the top-level scope is the global scope. This means that within the browser &lt;code&gt;var something&lt;/code&gt; will define a new global variable. In Node.js this is different. The top-level scope is not the global scope; &lt;code&gt;var something&lt;/code&gt; inside a Node.js module will be local to that module.</source>
          <target state="translated">브라우저에서 최상위 범위는 전역 범위입니다. 이것은 브라우저 &lt;code&gt;var something&lt;/code&gt; 내에서 새로운 전역 변수를 정의 한다는 것을 의미 합니다. Node.js에서 이것은 다릅니다. 최상위 범위는 전역 범위가 아닙니다. Node.js 모듈 내부의 &lt;code&gt;var something&lt;/code&gt; 는 해당 모듈에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="6d0d858774c88480d91a106fadc1779bc8dd52cc" translate="yes" xml:space="preserve">
          <source>In busy processes, use the asynchronous versions of these calls. The synchronous versions will block the entire process until they complete, halting all connections.</source>
          <target state="translated">사용중인 프로세스에서는 이러한 호출의 비동기 버전을 사용하십시오. 동기식 버전은 완료 될 때까지 전체 프로세스를 차단하여 모든 연결을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="a6dde02e444feeff7342a6c14a7993d14efd44e6" translate="yes" xml:space="preserve">
          <source>In case an option value happens to contain a space (for example a path listed in &lt;code&gt;--require&lt;/code&gt;), it must be escaped using double quotes. For example:</source>
          <target state="translated">옵션 값에 공백이 포함 된 경우 (예 : &lt;code&gt;--require&lt;/code&gt; 에 나열된 경로 ) 큰 따옴표를 사용하여 이스케이프해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a549d05af2ccfc0ca015a5a981e3076d4f98a52b" translate="yes" xml:space="preserve">
          <source>In case of an error status code, additional information can be obtained using &lt;code&gt;napi_get_last_error_info&lt;/code&gt;. More information can be found in the error handling section &lt;a href=&quot;#n_api_error_handling&quot;&gt;Error Handling&lt;/a&gt;.</source>
          <target state="translated">오류 상태 코드의 경우 &lt;code&gt;napi_get_last_error_info&lt;/code&gt; 를 사용하여 추가 정보를 얻을 수 있습니다 . 자세한 정보는 오류 처리 섹션에서 찾을 수 있습니다 &lt;a href=&quot;#n_api_error_handling&quot;&gt;오류 처리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60a7a3354fb49e4ea54bdc9ce39be38347f08d3e" translate="yes" xml:space="preserve">
          <source>In case of an error, the &lt;code&gt;err.code&lt;/code&gt; will be one of &lt;a href=&quot;errors#errors_common_system_errors&quot;&gt;Common System Errors&lt;/a&gt;.</source>
          <target state="translated">오류가 발생한 경우 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;errors#errors_common_system_errors&quot;&gt;공통 시스템 오류&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="83638801ee92420c039136960543463b06296385" translate="yes" xml:space="preserve">
          <source>In case of inactivity, the rules defined in &lt;a href=&quot;#http_server_timeout&quot;&gt;&lt;code&gt;server.timeout&lt;/code&gt;&lt;/a&gt; apply. However, that inactivity based timeout would still allow the connection to be kept open if the headers are being sent very slowly (by default, up to a byte per 2 minutes). In order to prevent this, whenever header data arrives an additional check is made that more than &lt;code&gt;server.headersTimeout&lt;/code&gt; milliseconds has not passed since the connection was established. If the check fails, a &lt;code&gt;'timeout'&lt;/code&gt; event is emitted on the server object, and (by default) the socket is destroyed. See &lt;a href=&quot;#http_server_timeout&quot;&gt;&lt;code&gt;server.timeout&lt;/code&gt;&lt;/a&gt; for more information on how timeout behavior can be customized.</source>
          <target state="translated">비활성 상태 인 경우 &lt;a href=&quot;#http_server_timeout&quot;&gt; &lt;code&gt;server.timeout&lt;/code&gt; 에&lt;/a&gt; 정의 된 규칙이 적용됩니다. 그러나 비 활동 기반 시간 초과는 헤더가 매우 느리게 전송되는 경우 (기본적으로 최대 2 분당 바이트) 연결을 계속 열어 둘 수 있습니다. 이를 방지하기 위해 헤더 데이터가 도착할 때마다 연결이 설정된 후 &lt;code&gt;server.headersTimeout&lt;/code&gt; 밀리 초 이상이 지나지 않았는지 추가 확인이 이루어집니다 . 확인에 실패하면 서버 개체에서 &lt;code&gt;'timeout'&lt;/code&gt; 이벤트가 생성되고 기본적으로 소켓이 손상됩니다. 시간 초과 동작을 사용자 지정할 수있는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#http_server_timeout&quot;&gt; &lt;code&gt;server.timeout&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fe24f759353e3c9ef13728cf5d98486ed424be5" translate="yes" xml:space="preserve">
          <source>In case of no callback function were assigned, a new &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; error will be thrown.</source>
          <target state="translated">콜백 함수가 할당되지 않은 경우 새로운 &lt;code&gt;ERR_INVALID_CALLBACK&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6d18d7e0676cf5071ee5c355fa6cde45cfbf4f6" translate="yes" xml:space="preserve">
          <source>In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either &lt;code&gt;'1.1'&lt;/code&gt; or &lt;code&gt;'1.0'&lt;/code&gt;.</source>
          <target state="translated">서버 요청의 경우 클라이언트가 보낸 HTTP 버전입니다. 클라이언트 응답의 경우 연결된 서버의 HTTP 버전입니다. 아마도 &lt;code&gt;'1.1'&lt;/code&gt; 또는 &lt;code&gt;'1.0'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="288453ee826f1533d87079e6da5e8a9939a1c3c7" translate="yes" xml:space="preserve">
          <source>In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Returns &lt;code&gt;'2.0'&lt;/code&gt;.</source>
          <target state="translated">서버 요청의 경우 클라이언트가 보낸 HTTP 버전입니다. 클라이언트 응답의 경우 연결된 서버의 HTTP 버전입니다. &lt;code&gt;'2.0'&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8a083755276d9eeea7f1c7589a28aafc0f42f80d" translate="yes" xml:space="preserve">
          <source>In cases where a return value other than &lt;code&gt;napi_ok&lt;/code&gt; or &lt;code&gt;napi_pending_exception&lt;/code&gt; is returned, &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt;&lt;code&gt;napi_is_exception_pending&lt;/code&gt;&lt;/a&gt; must be called to check if an exception is pending. See the section on exceptions for more details.</source>
          <target state="translated">&lt;code&gt;napi_ok&lt;/code&gt; 또는 &lt;code&gt;napi_pending_exception&lt;/code&gt; 이외의 반환 값 이 반환 되는 경우 예외가 보류 중인지 확인하기 위해 &lt;a href=&quot;#n_api_napi_is_exception_pending&quot;&gt; &lt;code&gt;napi_is_exception_pending&lt;/code&gt; &lt;/a&gt; 을 호출해야합니다. 자세한 내용은 예외에 관한 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3352c4c1cafe79135726b64a02a391ead0f41a7a" translate="yes" xml:space="preserve">
          <source>In cases where it is not known in advance if &lt;code&gt;input&lt;/code&gt; is an absolute URL and a &lt;code&gt;base&lt;/code&gt; is provided, it is advised to validate that the &lt;code&gt;origin&lt;/code&gt; of the &lt;code&gt;URL&lt;/code&gt; object is what is expected.</source>
          <target state="translated">경우 사전에 공지되지 않은 경우에 &lt;code&gt;input&lt;/code&gt; 절대 URL 인 및 &lt;code&gt;base&lt;/code&gt; 제공되는데, 확인하는 것이 권장 &lt;code&gt;origin&lt;/code&gt; 의 &lt;code&gt;URL&lt;/code&gt; 의 개체가 예상되는 어떤.</target>
        </trans-unit>
        <trans-unit id="64ee0f45e9598117687157f2af97b1b0166cabde" translate="yes" xml:space="preserve">
          <source>In cases where there is more than one &lt;code&gt;.cc&lt;/code&gt; file, simply add the additional filename to the &lt;code&gt;sources&lt;/code&gt; array:</source>
          <target state="translated">&lt;code&gt;.cc&lt;/code&gt; 파일 이 둘 이상인 경우 추가 파일 이름을 &lt;code&gt;sources&lt;/code&gt; 배열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a54ba662593323ae67f27f49552b1bb4dbd0fd34" translate="yes" xml:space="preserve">
          <source>In certain cases, &lt;code&gt;require('.')&lt;/code&gt; could resolve outside the package directory. This behavior has been removed.</source>
          <target state="translated">어떤 경우에는 &lt;code&gt;require('.')&lt;/code&gt; 가 패키지 디렉토리 외부에서 분석 될 수 있습니다. 이 동작은 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="6bf7779b67ab0aad41f5916dd6b3a65b83dcba67" translate="yes" xml:space="preserve">
          <source>In contrast, the following example turns off the default warning output and adds a custom handler to the &lt;code&gt;'warning'&lt;/code&gt; event:</source>
          <target state="translated">반대로, 다음 예제는 기본 경고 출력을 끄고 &lt;code&gt;'warning'&lt;/code&gt; 이벤트에 사용자 정의 핸들러를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bd3587bc97949af37236db6b9a0a1d14eae323d5" translate="yes" xml:space="preserve">
          <source>In custom builds from non-release versions of the source tree, only the &lt;code&gt;name&lt;/code&gt; property may be present. The additional properties should not be relied upon to exist.</source>
          <target state="translated">릴리스되지 않은 소스 트리 버전의 사용자 정의 빌드에는 &lt;code&gt;name&lt;/code&gt; 특성 만 존재할 수 있습니다. 추가 특성이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="327449f48d0f91fc55b3b3b7eb5d0b9b76cc0b33" translate="yes" xml:space="preserve">
          <source>In each module, the &lt;code&gt;module&lt;/code&gt; free variable is a reference to the object representing the current module. For convenience, &lt;code&gt;module.exports&lt;/code&gt; is also accessible via the &lt;code&gt;exports&lt;/code&gt; module-global. &lt;code&gt;module&lt;/code&gt; is not actually a global but rather local to each module.</source>
          <target state="translated">각 모듈에서 &lt;code&gt;module&lt;/code&gt; 자유 변수는 현재 모듈을 나타내는 객체에 대한 참조입니다. 편의를 위해, &lt;code&gt;module.exports&lt;/code&gt; 은 또한을 통해 액세스 &lt;code&gt;exports&lt;/code&gt; 모듈 - 글로벌. &lt;code&gt;module&lt;/code&gt; 은 실제로는 전역이 아니라 각 모듈에 대해 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="37db4cd4b343ff7b0d4d0a02ce9acc6d525c6d68" translate="yes" xml:space="preserve">
          <source>In each of the previous examples, an &lt;code&gt;Error&lt;/code&gt; object is generated internally by &lt;code&gt;process.emitWarning()&lt;/code&gt; and passed through to the &lt;a href=&quot;#process_event_warning&quot;&gt;&lt;code&gt;'warning'&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이전의 각 예에서 &lt;code&gt;Error&lt;/code&gt; 객체는 &lt;code&gt;process.emitWarning()&lt;/code&gt; 의해 내부적으로 생성 되어 &lt;a href=&quot;#process_event_warning&quot;&gt; &lt;code&gt;'warning'&lt;/code&gt; &lt;/a&gt; 처리기로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6707c880c79f3eb01db7774cdf36344d80a74bb4" translate="yes" xml:space="preserve">
          <source>In flowing mode, data is read from the underlying system automatically and provided to an application as quickly as possible using events via the &lt;a href=&quot;events#events_class_eventemitter&quot;&gt;&lt;code&gt;EventEmitter&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">유동 모드에서는 기본 시스템에서 데이터를 자동으로 읽고 &lt;a href=&quot;events#events_class_eventemitter&quot;&gt; &lt;code&gt;EventEmitter&lt;/code&gt; &lt;/a&gt; 인터페이스 를 통해 이벤트를 사용하여 가능한 한 빨리 응용 프로그램에 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="dd353fe48ae2599b92caa0441615c03958d5543e" translate="yes" xml:space="preserve">
          <source>In general, check for the accessibility of a file only if the file will not be used directly, for example when its accessibility is a signal from another process.</source>
          <target state="translated">일반적으로 액세스 가능성이 다른 프로세스의 신호 인 경우와 같이 파일을 직접 사용하지 않는 경우에만 파일의 액세스 가능성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="087f71387196c21047e8de00ada98ef5f02eb85e" translate="yes" xml:space="preserve">
          <source>In general, check for the existence of a file only if the file won&amp;rsquo;t be used directly, for example when its existence is a signal from another process.</source>
          <target state="translated">일반적으로 파일이 존재하지 않는 경우 (예 : 다른 프로세스의 신호 인 경우)에만 파일이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0780a6d7f3a8d6f30bfe170e7ebcad79382accb5" translate="yes" xml:space="preserve">
          <source>In general, greater memory usage options will mean that Node.js has to make fewer calls to &lt;code&gt;zlib&lt;/code&gt; because it will be able to process more data on each &lt;code&gt;write&lt;/code&gt; operation. So, this is another factor that affects the speed, at the cost of memory usage.</source>
          <target state="translated">일반적으로 메모리 사용량이 많을수록 Node.js는 각 &lt;code&gt;write&lt;/code&gt; 작업 에서 더 많은 데이터를 처리 할 수 ​​있기 때문에 &lt;code&gt;zlib&lt;/code&gt; 를 더 적게 호출해야 합니다. 따라서 이것은 메모리 사용 비용으로 속도에 영향을 미치는 또 다른 요소입니다.</target>
        </trans-unit>
        <trans-unit id="45a19be887817fbe3d3f39ecc27f73a30b8611a2" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;readable.pipe()&lt;/code&gt; and &lt;code&gt;'data'&lt;/code&gt; event mechanisms are easier to understand than the &lt;code&gt;'readable'&lt;/code&gt; event. However, handling &lt;code&gt;'readable'&lt;/code&gt; might result in increased throughput.</source>
          <target state="translated">일반적으로 &lt;code&gt;readable.pipe()&lt;/code&gt; 및 &lt;code&gt;'data'&lt;/code&gt; 이벤트 메커니즘은 &lt;code&gt;'readable'&lt;/code&gt; 이벤트 보다 이해하기 쉽습니다 . 그러나 &lt;code&gt;'readable'&lt;/code&gt; 처리 하면 처리량이 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e29f7ea80cfdc8edcce7cf9808c9e14cd5f2e801" translate="yes" xml:space="preserve">
          <source>In line with OpenSSL's recommendation to use a more modern algorithm instead of &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt;&lt;code&gt;EVP_BytesToKey&lt;/code&gt;&lt;/a&gt; it is recommended that developers derive a key and IV on their own using &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt;&lt;code&gt;crypto.scrypt()&lt;/code&gt;&lt;/a&gt; and to use &lt;a href=&quot;#crypto_crypto_createcipheriv_algorithm_key_iv_options&quot;&gt;&lt;code&gt;crypto.createCipheriv()&lt;/code&gt;&lt;/a&gt; to create the &lt;code&gt;Cipher&lt;/code&gt; object. Users should not use ciphers with counter mode (e.g. CTR, GCM, or CCM) in &lt;code&gt;crypto.createCipher()&lt;/code&gt;. A warning is emitted when they are used in order to avoid the risk of IV reuse that causes vulnerabilities. For the case when IV is reused in GCM, see &lt;a href=&quot;https://github.com/nonce-disrespect/nonce-disrespect&quot;&gt;Nonce-Disrespecting Adversaries&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt; &lt;code&gt;EVP_BytesToKey&lt;/code&gt; &lt;/a&gt; 대신 최신 알고리즘을 사용하는 OpenSSL의 권장 사항에 따라 개발자는 &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt; &lt;code&gt;crypto.scrypt()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자체적으로 키와 IV를 파생시키고 &lt;a href=&quot;#crypto_crypto_createcipheriv_algorithm_key_iv_options&quot;&gt; &lt;code&gt;crypto.createCipheriv()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Cipher&lt;/code&gt; 오브젝트 를 작성하는 것이 좋습니다. 사용자는 &lt;code&gt;crypto.createCipher()&lt;/code&gt; 에서 카운터 모드 (예 : CTR, GCM 또는 CCM)를 가진 암호를 사용하지 않아야합니다 . 취약점을 유발하는 IV 재사용의 위험을 피하기 위해 사용될 때 경고가 발생합니다. IV가 GCM에서 재사용되는 경우 &lt;a href=&quot;https://github.com/nonce-disrespect/nonce-disrespect&quot;&gt;Nonce-Disrespecting Adversaries&lt;/a&gt; 에서 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4427809c2da46e37a477a14b3a6dae947f069aba" translate="yes" xml:space="preserve">
          <source>In line with OpenSSL's recommendation to use a more modern algorithm instead of &lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt;&lt;code&gt;EVP_BytesToKey&lt;/code&gt;&lt;/a&gt; it is recommended that developers derive a key and IV on their own using &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt;&lt;code&gt;crypto.scrypt()&lt;/code&gt;&lt;/a&gt; and to use &lt;a href=&quot;#crypto_crypto_createdecipheriv_algorithm_key_iv_options&quot;&gt;&lt;code&gt;crypto.createDecipheriv()&lt;/code&gt;&lt;/a&gt; to create the &lt;code&gt;Decipher&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;https://www.openssl.org/docs/man1.1.0/crypto/EVP_BytesToKey.html&quot;&gt; &lt;code&gt;EVP_BytesToKey&lt;/code&gt; &lt;/a&gt; 대신 최신 알고리즘을 사용하는 OpenSSL의 권장 사항에 따라 개발자는 &lt;a href=&quot;#crypto_crypto_scrypt_password_salt_keylen_options_callback&quot;&gt; &lt;code&gt;crypto.scrypt()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 자체적으로 키와 IV를 파생하고 &lt;a href=&quot;#crypto_crypto_createdecipheriv_algorithm_key_iv_options&quot;&gt; &lt;code&gt;crypto.createDecipheriv()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Decipher&lt;/code&gt; 객체 를 생성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f16244b364da53115174b4fd4f6aa18f7d9fb44a" translate="yes" xml:space="preserve">
          <source>In many cases when an N-API function is called and an exception is already pending, the function will return immediately with a &lt;code&gt;napi_status&lt;/code&gt; of &lt;code&gt;napi_pending_exception&lt;/code&gt;. However, this is not the case for all functions. N-API allows a subset of the functions to be called to allow for some minimal cleanup before returning to JavaScript. In that case, &lt;code&gt;napi_status&lt;/code&gt; will reflect the status for the function. It will not reflect previous pending exceptions. To avoid confusion, check the error status after every function call.</source>
          <target state="translated">대부분의 경우는 N-API 함수가 호출되고 예외가 이미 함수가 즉시 반환합니다 중일 때는 &lt;code&gt;napi_status&lt;/code&gt; 의 &lt;code&gt;napi_pending_exception&lt;/code&gt; . 그러나 이것이 모든 기능에 해당되는 것은 아닙니다. N-API를 사용하면 JavaScript로 돌아 가기 전에 최소한의 정리를 수행 할 수 있도록 함수의 서브 세트를 호출 할 수 있습니다. 이 경우 &lt;code&gt;napi_status&lt;/code&gt; 는 함수의 상태를 반영합니다. 이전에 보류중인 예외는 반영하지 않습니다. 혼동을 피하기 위해 모든 함수 호출 후 오류 상태를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4d4aeb489e9e86e74a64fc02a38fd7bd2ebbd390" translate="yes" xml:space="preserve">
          <source>In many cases, however, it is necessary that the handles remain valid for either a shorter or longer lifespan than that of the native method. The sections which follow describe the N-API functions that can be used to change the handle lifespan from the default.</source>
          <target state="translated">그러나 대부분의 경우 핸들이 기본 메소드보다 짧거나 더 긴 수명 동안 유효해야합니다. 다음 섹션에서는 핸들 수명을 기본값에서 변경하는 데 사용할 수있는 N-API 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2dd8e7e54f1e17d20c23615bc834dee206f45159" translate="yes" xml:space="preserve">
          <source>In most cases, there should be little to no reason for an application to manually create instances of the &lt;code&gt;tty.ReadStream&lt;/code&gt; and &lt;code&gt;tty.WriteStream&lt;/code&gt; classes.</source>
          <target state="translated">대부분의 경우, 응용 프로그램이 &lt;code&gt;tty.ReadStream&lt;/code&gt; 및 &lt;code&gt;tty.WriteStream&lt;/code&gt; 클래스의 인스턴스를 수동으로 작성해야 할 이유가 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5bc3a0789b533753ef17917c6e76c2314768199f" translate="yes" xml:space="preserve">
          <source>In most operating systems, listening to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;unspecified IPv6 address&lt;/a&gt; (&lt;code&gt;::&lt;/code&gt;) may cause the &lt;code&gt;net.Server&lt;/code&gt; to also listen on the &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;unspecified IPv4 address&lt;/a&gt; (&lt;code&gt;0.0.0.0&lt;/code&gt;).</source>
          <target state="translated">대부분의 운영 체제에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/IPv6_address#Unspecified_address&quot;&gt;지정되지 않은 IPv6 주소&lt;/a&gt; ( &lt;code&gt;::&lt;/code&gt; &lt;code&gt;net.Server&lt;/code&gt; 를 수신 하면 net.Server 가 &lt;a href=&quot;https://en.wikipedia.org/wiki/0.0.0.0&quot;&gt;지정되지 않은 IPv4 주소&lt;/a&gt; ( &lt;code&gt;0.0.0.0&lt;/code&gt; )를 수신 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a9fa045058fbc4f76eea96849e5ca18e4b0477e" translate="yes" xml:space="preserve">
          <source>In most situations, it is not actually necessary to call &lt;code&gt;process.exit()&lt;/code&gt; explicitly. The Node.js process will exit on its own &lt;em&gt;if there is no additional work pending&lt;/em&gt; in the event loop. The &lt;code&gt;process.exitCode&lt;/code&gt; property can be set to tell the process which exit code to use when the process exits gracefully.</source>
          <target state="translated">대부분의 경우 실제로 &lt;code&gt;process.exit()&lt;/code&gt; 명시 적으로 호출 할 필요는 없습니다 . 이벤트 루프에 &lt;em&gt;보류중인 추가 작업이없는 경우&lt;/em&gt; Node.js 프로세스가 자체적으로 종료됩니다 . &lt;code&gt;process.exitCode&lt;/code&gt; 의 속성은 종료 코드가 때 프로세스가 종료 정상적으로 사용하는 과정을 말하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba73ffda62f255ad07619c0e3bdc1d844b17d1f" translate="yes" xml:space="preserve">
          <source>In order to avoid the garbage collection overhead of creating many individually allocated &lt;code&gt;Buffer&lt;/code&gt; instances, by default allocations under 4KB are sliced from a single larger allocated object.</source>
          <target state="translated">개별적으로 할당 된 많은 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스 를 생성하는 가비지 수집 오버 헤드를 피하기 위해 기본적으로 4KB 미만의 할당은 하나의 더 큰 할당 된 객체에서 슬라이스됩니다.</target>
        </trans-unit>
        <trans-unit id="07817ef1abfbcf964409ae72ee3eff00eaa052ac" translate="yes" xml:space="preserve">
          <source>In order to be loaded from multiple Node.js environments, such as a main thread and a Worker thread, an add-on needs to either:</source>
          <target state="translated">기본 스레드 및 작업자 스레드와 같은 여러 Node.js 환경에서로드하려면 애드온에서 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="30b26d492c1627fc6654e900f98b2c495fce1ecb" translate="yes" xml:space="preserve">
          <source>In order to create a mixed &lt;a href=&quot;https&quot;&gt;HTTPS&lt;/a&gt; and HTTP/2 server, refer to the &lt;a href=&quot;#http2_alpn_negotiation&quot;&gt;ALPN negotiation&lt;/a&gt; section. Upgrading from non-tls HTTP/1 servers is not supported.</source>
          <target state="translated">혼합 &lt;a href=&quot;https&quot;&gt;HTTPS&lt;/a&gt; 및 HTTP / 2 서버를 작성하려면 &lt;a href=&quot;#http2_alpn_negotiation&quot;&gt;ALPN 협상&lt;/a&gt; 섹션을 참조하십시오 . 비 tls HTTP / 1 서버에서 업그레이드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9608ef8288365a7cade4d998db1fc0243461174f" translate="yes" xml:space="preserve">
          <source>In order to do this, it is necessary to get a reference to the &lt;code&gt;module&lt;/code&gt; object. Since &lt;code&gt;require()&lt;/code&gt; returns the &lt;code&gt;module.exports&lt;/code&gt;, and the &lt;code&gt;module&lt;/code&gt; is typically &lt;em&gt;only&lt;/em&gt; available within a specific module's code, it must be explicitly exported in order to be used.</source>
          <target state="translated">이렇게하려면 &lt;code&gt;module&lt;/code&gt; 객체에 대한 참조를 가져와야 합니다. 이후 &lt;code&gt;require()&lt;/code&gt; 수익률 &lt;code&gt;module.exports&lt;/code&gt; 을 하고, &lt;code&gt;module&lt;/code&gt; 일반적으로 &lt;em&gt;단지&lt;/em&gt; 특정 모듈의 코드 내에서 사용할 수, 명시 적으로 사용하기 위해 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="34523f8cc30ff0b87b5cd5c6314ffe804fe892b1" translate="yes" xml:space="preserve">
          <source>In order to expose a function as part of the add-on's module exports, set the newly created function on the exports object. A sample module might look as follows:</source>
          <target state="translated">애드온 모듈 내보내기의 일부로 함수를 노출하려면 내보내기 개체에서 새로 만든 함수를 설정하십시오. 샘플 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5be94aad2d7524c4d29b1665cfabd8e1b693ef9b" translate="yes" xml:space="preserve">
          <source>In order to make modules available to the Node.js REPL, it might be useful to also add the &lt;code&gt;/usr/lib/node_modules&lt;/code&gt; folder to the &lt;code&gt;$NODE_PATH&lt;/code&gt; environment variable. Since the module lookups using &lt;code&gt;node_modules&lt;/code&gt; folders are all relative, and based on the real path of the files making the calls to &lt;code&gt;require()&lt;/code&gt;, the packages themselves can be anywhere.</source>
          <target state="translated">Node.js REPL에서 모듈을 사용 가능하게하려면 &lt;code&gt;/usr/lib/node_modules&lt;/code&gt; 폴더를 &lt;code&gt;$NODE_PATH&lt;/code&gt; 환경 변수에 추가하는 것이 유용 할 수 있습니다 . &lt;code&gt;node_modules&lt;/code&gt; 폴더를 사용하는 모듈 검색 은 모두 상대적이며 &lt;code&gt;require()&lt;/code&gt; 호출하는 파일의 실제 경로를 기반으로하기 때문에 패키지 자체는 어디에나있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34fc5ed6a9101bb04240e52968cc6d46716398a6" translate="yes" xml:space="preserve">
          <source>In order to prevent excessive memory usage, &lt;code&gt;Domain&lt;/code&gt; objects themselves are not implicitly added as children of the active domain. If they were, then it would be too easy to prevent request and response objects from being properly garbage collected.</source>
          <target state="translated">과도한 메모리 사용을 방지하기 위해 &lt;code&gt;Domain&lt;/code&gt; 오브젝트 자체는 내재적으로 활성 도메인의 하위로 추가되지 않습니다. 만약 그렇다면 요청과 응답 객체가 올바르게 가비지 수집되는 것을 방지하기가 너무 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1872d37dd99da69f48fff6e8ea85d653766d0af1" translate="yes" xml:space="preserve">
          <source>In order to retrieve this information &lt;a href=&quot;#n_api_napi_get_last_error_info&quot;&gt;&lt;code&gt;napi_get_last_error_info&lt;/code&gt;&lt;/a&gt; is provided which returns a &lt;code&gt;napi_extended_error_info&lt;/code&gt; structure. The format of the &lt;code&gt;napi_extended_error_info&lt;/code&gt; structure is as follows:</source>
          <target state="translated">이 정보를 검색하기 위해 &lt;a href=&quot;#n_api_napi_get_last_error_info&quot;&gt; &lt;code&gt;napi_get_last_error_info&lt;/code&gt; &lt;/a&gt; 반환 제공 &lt;code&gt;napi_extended_error_info&lt;/code&gt; 의 구조. &lt;code&gt;napi_extended_error_info&lt;/code&gt; 구조 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ba193044958a2078ac8148d7933406e9ff8c99a" translate="yes" xml:space="preserve">
          <source>In order to run a simple web server using the &lt;code&gt;http&lt;/code&gt; module the code passed to the context must either call &lt;code&gt;require('http')&lt;/code&gt; on its own, or have a reference to the &lt;code&gt;http&lt;/code&gt; module passed to it. For instance:</source>
          <target state="translated">&lt;code&gt;http&lt;/code&gt; 모듈을 사용하여 간단한 웹 서버를 실행 하려면 컨텍스트에 전달 된 코드 가 자체적으로 &lt;code&gt;require('http')&lt;/code&gt; 를 호출 하거나 전달 된 &lt;code&gt;http&lt;/code&gt; 모듈에 대한 참조가 있어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="dcb69e44c062ea7704f38e703e2936582cc9f855" translate="yes" xml:space="preserve">
          <source>In order to support &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads, addons need to clean up any resources they may have allocated when such a thread exists. This can be achieved through the usage of the &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; function:</source>
          <target state="translated">&lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드 를 지원하려면 애드온은 해당 스레드가 존재할 때 할당했을 수있는 모든 리소스를 정리해야합니다. &lt;code&gt;AddEnvironmentCleanupHook()&lt;/code&gt; 함수를 사용하면 됩니다 :</target>
        </trans-unit>
        <trans-unit id="6e43ad63b79dd141d986e828eceee78812aec282" translate="yes" xml:space="preserve">
          <source>In order to support the full spectrum of possible HTTP applications, Node.js's HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the actual headers or the body.</source>
          <target state="translated">가능한 모든 HTTP 응용 프로그램을 지원하기 위해 Node.js의 HTTP API는 매우 저수준입니다. 스트림 처리 및 메시지 구문 분석 만 처리합니다. 메시지를 헤더와 본문으로 구문 분석하지만 실제 헤더 또는 본문을 구문 분석하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff3632f1db32bf01741e5bbea082ca20145fb38f" translate="yes" xml:space="preserve">
          <source>In order to use the N-API functions, include the file &lt;a href=&quot;https://github.com/nodejs/node/blob/master/src/node_api.h&quot;&gt;&lt;code&gt;node_api.h&lt;/code&gt;&lt;/a&gt; which is located in the src directory in the node development tree:</source>
          <target state="translated">N-API 함수를 사용 하려면 노드 개발 트리의 src 디렉토리에있는 &lt;a href=&quot;https://github.com/nodejs/node/blob/master/src/node_api.h&quot;&gt; &lt;code&gt;node_api.h&lt;/code&gt; &lt;/a&gt; 파일을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ac594a0cf5cfa895ed35f6b2ef04dc94e26df89" translate="yes" xml:space="preserve">
          <source>In particular, the significant differences to &lt;code&gt;JSON&lt;/code&gt; are:</source>
          <target state="translated">특히 &lt;code&gt;JSON&lt;/code&gt; 과 의 중요한 차이점 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d252f3d1a06c3b2a3ae5ad98ef71487c919a9c51" translate="yes" xml:space="preserve">
          <source>In paused mode, the &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;stream.read()&lt;/code&gt;&lt;/a&gt; method must be called explicitly to read chunks of data from the stream.</source>
          <target state="translated">일시 정지 모드에서는 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;stream.read()&lt;/code&gt; &lt;/a&gt; 메소드를 명시 적으로 호출하여 스트림에서 데이터 청크를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9a5c41117e426ba3a059f25450d02c56bbffe674" translate="yes" xml:space="preserve">
          <source>In recent versions of Node.js, there is no difference between &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt;. The latter is deprecated along with the undocumented aliases &lt;code&gt;crypto.prng()&lt;/code&gt; and &lt;code&gt;crypto.rng()&lt;/code&gt; in favor of &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt;&lt;code&gt;crypto.randomBytes()&lt;/code&gt;&lt;/a&gt; and may be removed in a future release.</source>
          <target state="translated">최신 버전의 Node.js에서는 &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;crypto.pseudoRandomBytes()&lt;/code&gt; 사이에 차이가 없습니다 . 후자는 문서화되지 않은 별칭과 함께 사용되지 &lt;code&gt;crypto.prng()&lt;/code&gt; 와 &lt;code&gt;crypto.rng()&lt;/code&gt; 찬성 &lt;a href=&quot;crypto#crypto_crypto_randombytes_size_callback&quot;&gt; &lt;code&gt;crypto.randomBytes()&lt;/code&gt; &lt;/a&gt; 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="177049c3930ff3f87e8368c6c3d05d129ef44094" translate="yes" xml:space="preserve">
          <source>In some cases an addon will need to be able to create and reference objects with a lifespan longer than that of a single native method invocation. For example, to create a constructor and later use that constructor in a request to creates instances, it must be possible to reference the constructor object across many different instance creation requests. This would not be possible with a normal handle returned as a &lt;code&gt;napi_value&lt;/code&gt; as described in the earlier section. The lifespan of a normal handle is managed by scopes and all scopes must be closed before the end of a native method.</source>
          <target state="translated">경우에 따라 애드온은 단일 고유 메소드 호출보다 수명이 긴 오브젝트를 작성하고 참조 할 수 있어야합니다. 예를 들어 생성자를 생성하고 나중에 요청에 생성자를 사용하여 인스턴스를 생성하려면 여러 인스턴스 생성 요청에서 생성자 객체를 참조 할 수 있어야합니다. 이전 섹션에서 설명한 것처럼 &lt;code&gt;napi_value&lt;/code&gt; 로 반환 된 일반 핸들로는 불가능 합니다. 일반 핸들의 수명은 범위별로 관리되며 기본 범위가 끝나기 전에 모든 범위를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e22a93062d451b249b9309c60af8192dbe28ccd1" translate="yes" xml:space="preserve">
          <source>In some cases the resource object is reused for performance reasons, it is thus not safe to use it as a key in a &lt;code&gt;WeakMap&lt;/code&gt; or add properties to it.</source>
          <target state="translated">경우에 따라 성능상의 이유로 리소스 개체를 재사용하기 때문에 &lt;code&gt;WeakMap&lt;/code&gt; 에서 키로 사용 하거나 속성을 추가 하는 것이 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ad5e1a1929b5b0a41cfc844642f2414d2f858a5" translate="yes" xml:space="preserve">
          <source>In some cases, a &lt;code&gt;Sign&lt;/code&gt; instance can be created using the name of a signature algorithm, such as &lt;code&gt;'RSA-SHA256'&lt;/code&gt;, instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt;, so it is best to always use digest algorithm names.</source>
          <target state="translated">경우 에 따라 다이제스트 알고리즘 대신 &lt;code&gt;'RSA-SHA256'&lt;/code&gt; 과 같은 서명 알고리즘의 이름을 사용하여 &lt;code&gt;Sign&lt;/code&gt; 인스턴스를 만들 수 있습니다 . 해당 다이제스트 알고리즘을 사용합니다. &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt; 과 같은 모든 서명 알고리즘에는 작동하지 않으므로 항상 다이제스트 알고리즘 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e37ebca3d8b767295ac2a49a166fe5a6bbb405cb" translate="yes" xml:space="preserve">
          <source>In some cases, a &lt;code&gt;Verify&lt;/code&gt; instance can be created using the name of a signature algorithm, such as &lt;code&gt;'RSA-SHA256'&lt;/code&gt;, instead of a digest algorithm. This will use the corresponding digest algorithm. This does not work for all signature algorithms, such as &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt;, so it is best to always use digest algorithm names.</source>
          <target state="translated">경우 에 따라 다이제스트 알고리즘 대신 &lt;code&gt;'RSA-SHA256'&lt;/code&gt; 과 같은 서명 알고리즘의 이름을 사용하여 &lt;code&gt;Verify&lt;/code&gt; 인스턴스를 만들 수 있습니다 . 해당 다이제스트 알고리즘을 사용합니다. &lt;code&gt;'ecdsa-with-SHA256'&lt;/code&gt; 과 같은 모든 서명 알고리즘에는 작동하지 않으므로 항상 다이제스트 알고리즘 이름을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="715189038eeefcaa56acee7c2e2873a2e151a84e" translate="yes" xml:space="preserve">
          <source>In some cases, a transform operation may need to emit an additional bit of data at the end of the stream. For example, a &lt;code&gt;zlib&lt;/code&gt; compression stream will store an amount of internal state used to optimally compress the output. When the stream ends, however, that additional data needs to be flushed so that the compressed data will be complete.</source>
          <target state="translated">어떤 경우에는 변환 작업이 스트림의 끝에서 추가 비트의 데이터를 방출해야 할 수도 있습니다. 예를 들어 &lt;code&gt;zlib&lt;/code&gt; 압축 스트림은 출력을 최적으로 압축하는 데 사용되는 내부 상태를 저장합니다. 그러나 스트림이 종료되면 압축 된 데이터가 완료되도록 추가 데이터를 비워야합니다.</target>
        </trans-unit>
        <trans-unit id="e0648c6c88ba0416f92bbc79ff87e571aa792e5c" translate="yes" xml:space="preserve">
          <source>In synchronous code, the &lt;code&gt;'uncaughtException'&lt;/code&gt; event is emitted when the list of unhandled exceptions grows.</source>
          <target state="translated">동기 코드에서 처리되지 않은 예외 목록이 커지면 &lt;code&gt;'uncaughtException'&lt;/code&gt; 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="621f9ba64d0f93481000b51697b0e8e212cfe125" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;hello.cc&lt;/code&gt; example, then, the initialization function is &lt;code&gt;Initialize&lt;/code&gt; and the addon module name is &lt;code&gt;addon&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;hello.cc&lt;/code&gt; 의 예, 그리고, 초기화 기능은 &lt;code&gt;Initialize&lt;/code&gt; 및 부가 모듈 이름은 &lt;code&gt;addon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a1a029b73f14872b97df7d8a65365950b239dc" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;http&lt;/code&gt; module, the response body is omitted when the request is a HEAD request. Similarly, the &lt;code&gt;204&lt;/code&gt; and &lt;code&gt;304&lt;/code&gt; responses &lt;em&gt;must not&lt;/em&gt; include a message body.</source>
          <target state="translated">에서 &lt;code&gt;http&lt;/code&gt; 요청이 HEAD 요청 모듈 인 경우, 상기 응답 체를 생략한다. 마찬가지로 &lt;code&gt;204&lt;/code&gt; 및 &lt;code&gt;304&lt;/code&gt; 응답 에는 메시지 본문이 포함 &lt;em&gt;되어서&lt;/em&gt; 는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea6a5d641d8bc637062b7f84d566dcbd208d5b73" translate="yes" xml:space="preserve">
          <source>In the Node.js module system, each file is treated as a separate module. For example, consider a file named &lt;code&gt;foo.js&lt;/code&gt;:</source>
          <target state="translated">Node.js 모듈 시스템에서 각 파일은 별도의 모듈로 처리됩니다. 예를 들어, &lt;code&gt;foo.js&lt;/code&gt; 라는 파일을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="48e2be294d408b9afdcf261478d35f9f2c3215e8" translate="yes" xml:space="preserve">
          <source>In the above, errors on the write stream would be caught and thrown by the two &lt;code&gt;once()&lt;/code&gt; listeners, since &lt;code&gt;once()&lt;/code&gt; will also handle &lt;code&gt;'error'&lt;/code&gt; events.</source>
          <target state="translated">위의 경우, &lt;code&gt;once()&lt;/code&gt; 도 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 처리하기 때문에 쓰기 스트림의 오류는 두 번의 &lt;code&gt;once()&lt;/code&gt; 리스너에 의해 포착되어 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5261e070003e9d4318beec94c3cf4ba4e3cbd884" translate="yes" xml:space="preserve">
          <source>In the case of Promises, the &lt;code&gt;resource&lt;/code&gt; object will have an &lt;code&gt;isChainedPromise&lt;/code&gt; property, set to &lt;code&gt;true&lt;/code&gt; if the promise has a parent promise, and &lt;code&gt;false&lt;/code&gt; otherwise. For example, in the case of &lt;code&gt;b = a.then(handler)&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; is considered a parent &lt;code&gt;Promise&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt;. Here, &lt;code&gt;b&lt;/code&gt; is considered a chained promise.</source>
          <target state="translated">약속의 경우 &lt;code&gt;resource&lt;/code&gt; 개체에는 &lt;code&gt;isChainedPromise&lt;/code&gt; 속성 이 있으며 , 약속에 부모 약속이 있으면 &lt;code&gt;true&lt;/code&gt; 로 설정되고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 로 설정 됩니다. 예를 들어, &lt;code&gt;b = a.then(handler)&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 의 상위 &lt;code&gt;Promise&lt;/code&gt; 으로 간주됩니다 . 여기서 &lt;code&gt;b&lt;/code&gt; 는 연쇄 약속으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b68963099522536bfb9d03e74439ba262a06acfe" translate="yes" xml:space="preserve">
          <source>In the case of a connection error, the following events will be emitted:</source>
          <target state="translated">연결 오류의 경우 다음 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="918cb5bc54bb7c658a3c96576889997c72299bef" translate="yes" xml:space="preserve">
          <source>In the case where a developer may need to retain a small chunk of memory from a pool for an indeterminate amount of time, it may be appropriate to create an un-pooled &lt;code&gt;Buffer&lt;/code&gt; instance using &lt;code&gt;SlowBuffer&lt;/code&gt; then copy out the relevant bits.</source>
          <target state="translated">개발자가 결정되지 않은 시간 동안 풀에서 작은 메모리 청크를 유지해야하는 경우 &lt;code&gt;SlowBuffer&lt;/code&gt; 를 사용하여 풀링되지 않은 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스를 만든 다음 관련 비트를 복사하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ef5ea159bcc99b4a4ae1f2a88941efdfec9000" translate="yes" xml:space="preserve">
          <source>In the event of an unrecoverable error in a native module, a fatal error can be thrown to immediately terminate the process.</source>
          <target state="translated">기본 모듈에서 복구 할 수없는 오류가 발생하면 프로세스를 즉시 종료하기 위해 치명적인 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b5ef3b0128e137344ad3cbe4a5087a73a781f41" translate="yes" xml:space="preserve">
          <source>In the example &lt;code&gt;req.end()&lt;/code&gt; was called. With &lt;code&gt;http.request()&lt;/code&gt; one must always call &lt;code&gt;req.end()&lt;/code&gt; to signify the end of the request - even if there is no data being written to the request body.</source>
          <target state="translated">예제에서 &lt;code&gt;req.end()&lt;/code&gt; 가 호출되었습니다. 함께 &lt;code&gt;http.request()&lt;/code&gt; 하나는 항상 호출해야 &lt;code&gt;req.end()&lt;/code&gt; 데이터가 요청 본문에 기록되지되고있는 경우에도 - 요청의 끝을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee4ef00df3b73a5938a813feaf72104024931ba1" translate="yes" xml:space="preserve">
          <source>In the following algorithms, all subroutine errors are propagated as errors of these top-level routines unless stated otherwise.</source>
          <target state="translated">다음 알고리즘에서 달리 명시하지 않는 한 모든 서브 루틴 오류는 이러한 최상위 루틴의 오류로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="fa725afe5295f20910c112028ae94f2b56a1a734" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;flush()&lt;/code&gt; is used to write a compressed partial HTTP response to the client:</source>
          <target state="translated">다음 예에서 &lt;code&gt;flush()&lt;/code&gt; 는 클라이언트에 압축 된 부분 HTTP 응답을 쓰는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf82ec3610a7aca0a8ed51fb8b215927e85734d4" translate="yes" xml:space="preserve">
          <source>In the following example, for instance, a new &lt;code&gt;Transform&lt;/code&gt; stream (which is a type of &lt;a href=&quot;#stream_class_stream_duplex&quot;&gt;&lt;code&gt;Duplex&lt;/code&gt;&lt;/a&gt; stream) is created that has an object mode &lt;code&gt;Writable&lt;/code&gt; side that accepts JavaScript numbers that are converted to hexadecimal strings on the &lt;code&gt;Readable&lt;/code&gt; side.</source>
          <target state="translated">예를 들어 다음 예제에서는 &lt;code&gt;Readable&lt;/code&gt; 쪽에서 16 진수 문자열로 변환되는 JavaScript 숫자를 허용 하는 개체 모드 &lt;code&gt;Writable&lt;/code&gt; 쪽이 있는 새 &lt;code&gt;Transform&lt;/code&gt; 스트림 ( &lt;a href=&quot;#stream_class_stream_duplex&quot;&gt; &lt;code&gt;Duplex&lt;/code&gt; &lt;/a&gt; 스트림 유형 )이 만들어 집니다 .</target>
        </trans-unit>
        <trans-unit id="7c0fb3c9414cf1c8a8bda6e4b07edf6163cccd34" translate="yes" xml:space="preserve">
          <source>In the following example, only the child's fd &lt;code&gt;1&lt;/code&gt; (stdout) is configured as a pipe, so only the parent's &lt;code&gt;subprocess.stdio[1]&lt;/code&gt; is a stream, all other values in the array are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서는 자식의 fd &lt;code&gt;1&lt;/code&gt; (stdout) 만 파이프로 구성되므로 부모의 &lt;code&gt;subprocess.stdio[1]&lt;/code&gt; 만 스트림이며 배열의 다른 모든 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0de61ebd59a8526600cd416227b8b1e35a46645a" translate="yes" xml:space="preserve">
          <source>In the following example, the three UTF-8 encoded bytes of the European Euro symbol (&lt;code&gt;&amp;euro;&lt;/code&gt;) are written over three separate operations:</source>
          <target state="translated">다음 예에서 유럽 유로 기호 ( &lt;code&gt;&amp;euro;&lt;/code&gt; ) 의 3 개의 UTF-8 인코딩 바이트는 3 개의 개별 연산으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="67b32ff656d65a26d312747226fead13fb28eaac" translate="yes" xml:space="preserve">
          <source>In the last three cases &lt;code&gt;actual&lt;/code&gt;, &lt;code&gt;expected&lt;/code&gt;, and &lt;code&gt;operator&lt;/code&gt; have no influence on the error message.</source>
          <target state="translated">마지막 세 경우 &lt;code&gt;actual&lt;/code&gt; , &lt;code&gt;expected&lt;/code&gt; 및 &lt;code&gt;operator&lt;/code&gt; 는 오류 메시지에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb96692d68fa67ba34d26bf28629f0c68833dc44" translate="yes" xml:space="preserve">
          <source>In the master this sends a message to a specific worker. It is identical to &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt;&lt;code&gt;ChildProcess.send()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스터에서 이것은 특정 작업자에게 메시지를 보냅니다. &lt;a href=&quot;child_process#child_process_subprocess_send_message_sendhandle_options_callback&quot;&gt; &lt;code&gt;ChildProcess.send()&lt;/code&gt; &lt;/a&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f382762e386304b924761ff709bc435737f82042" translate="yes" xml:space="preserve">
          <source>In the master, an internal message is sent to the worker causing it to call &lt;code&gt;.disconnect()&lt;/code&gt; on itself.</source>
          <target state="translated">마스터에서는 내부 메시지가 작업자에게 전송되어 자체적으로 &lt;code&gt;.disconnect()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="40fb2a46c3495adde1bdbd6a72aa0fe0f5338274" translate="yes" xml:space="preserve">
          <source>In the scenario of writing to a writable stream from an async iterator, it is important to ensure the correct handling of backpressure and errors.</source>
          <target state="translated">비동기 반복기에서 쓰기 가능한 스트림에 쓰는 시나리오에서는 배압 및 오류를 올바르게 처리하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="0ce5fad120b64ee42264f01dfdc44ee7b983178a" translate="yes" xml:space="preserve">
          <source>In this case the entire API surface, including any experimental APIs, will be available to the module code.</source>
          <target state="translated">이 경우 실험용 API를 포함한 전체 API 표면을 모듈 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3340c556f6543bec062f3b2ed6d553b3150156a1" translate="yes" xml:space="preserve">
          <source>In this example case, it is possible to track the rejection as a developer error as would typically be the case for other &lt;code&gt;'unhandledRejection'&lt;/code&gt; events. To address such failures, a non-operational &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch&quot;&gt;&lt;code&gt;.catch(() =&amp;gt; { })&lt;/code&gt;&lt;/a&gt; handler may be attached to &lt;code&gt;resource.loaded&lt;/code&gt;, which would prevent the &lt;code&gt;'unhandledRejection'&lt;/code&gt; event from being emitted.</source>
          <target state="translated">이 예제의 경우 일반적으로 다른 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트 의 경우와 같이 개발자 오류로 거부를 추적 할 수 있습니다. 이러한 실패를 해결하기 위해 비 작동 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch&quot;&gt; &lt;code&gt;.catch(() =&amp;gt; { })&lt;/code&gt; &lt;/a&gt; 핸들러가 &lt;code&gt;resource.loaded&lt;/code&gt; 에 첨부되어 &lt;code&gt;'unhandledRejection'&lt;/code&gt; 이벤트가 생성 되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b30d924ce86ebcb8be4941fadb4d24eb63050b49" translate="yes" xml:space="preserve">
          <source>In this example, adding any actual hook function enabled the tracking of promises. There are two promises in the example above; the promise created by &lt;code&gt;Promise.resolve()&lt;/code&gt; and the promise returned by the call to &lt;code&gt;then()&lt;/code&gt;. In the example above, the first promise got the &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;6&lt;/code&gt; and the latter got &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;7&lt;/code&gt;. During the execution of the &lt;code&gt;then()&lt;/code&gt; callback, we are executing in the context of promise with &lt;code&gt;asyncId&lt;/code&gt;&lt;code&gt;7&lt;/code&gt;. This promise was triggered by async resource &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">이 예에서 실제 후크 기능을 추가하면 약속 추적이 가능합니다. 위의 예에는 두 가지 약속이 있습니다. 만든 약속 &lt;code&gt;Promise.resolve()&lt;/code&gt; 과에 호출에 의해 반환 약속 &lt;code&gt;then()&lt;/code&gt; . 위의 예에서 첫 번째 약속에는 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;6&lt;/code&gt; 이 있고 후자의 약속에는 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;7&lt;/code&gt; 이 있습니다. &lt;code&gt;then()&lt;/code&gt; 콜백 을 실행하는 동안 &lt;code&gt;asyncId&lt;/code&gt; &lt;code&gt;7&lt;/code&gt; 로 promise 컨텍스트에서 실행 중 입니다. 이 약속은 비동기 리소스 &lt;code&gt;6&lt;/code&gt; 에 의해 시작되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f2c1f79c71778e1324e95e72ef55b00fad51c2b3" translate="yes" xml:space="preserve">
          <source>In this example, an &lt;code&gt;Error&lt;/code&gt; object is generated internally by &lt;code&gt;process.emitWarning()&lt;/code&gt; and passed through to the &lt;a href=&quot;#process_event_warning&quot;&gt;&lt;code&gt;'warning'&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Error&lt;/code&gt; 객체는 &lt;code&gt;process.emitWarning()&lt;/code&gt; 의해 내부적으로 생성 되어 &lt;a href=&quot;#process_event_warning&quot;&gt; &lt;code&gt;'warning'&lt;/code&gt; &lt;/a&gt; 처리기로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="75d63ff46a64b4f575facc6bfa8055c873dc89f8" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;d.on('error')&lt;/code&gt; handler will be triggered, rather than crashing the program.</source>
          <target state="translated">이 예제에서는 프로그램을 &lt;code&gt;d.on('error')&lt;/code&gt; 핸들러가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="4a2f4cd6b751dfe743b9e57f92471b943ba9aa8e" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;unhandledRejections&lt;/code&gt;&lt;code&gt;Map&lt;/code&gt; will grow and shrink over time, reflecting rejections that start unhandled and then become handled. It is possible to record such errors in an error log, either periodically (which is likely best for long-running application) or upon process exit (which is likely most convenient for scripts).</source>
          <target state="translated">이 예에서 &lt;code&gt;unhandledRejections&lt;/code&gt; 거부 &lt;code&gt;Map&lt;/code&gt; 은 처리되지 않은 것으로 시작된 후 처리 된 거부를 반영하여 시간이 지남에 따라 커지거나 줄어 듭니다. 주기적으로 (오래 실행되는 응용 프로그램에 가장 적합) 또는 프로세스 종료시 (스크립트에 가장 편리한) 오류 로그에 이러한 오류를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a9e0f5e7284af8b7d1cd8e4c8dee1cd1759793" translate="yes" xml:space="preserve">
          <source>In this example, the callback function is invoked synchronously.</source>
          <target state="translated">이 예제에서 콜백 함수는 동 기적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4031e8bbffadc3eeaaece5bccec619b8b40c5fe2" translate="yes" xml:space="preserve">
          <source>In this way, &lt;code&gt;domain&lt;/code&gt; usage goes hand-in-hand with the cluster module, since the master process can fork a new worker when a worker encounters an error. For Node.js programs that scale to multiple machines, the terminating proxy or service registry can take note of the failure, and react accordingly.</source>
          <target state="translated">이러한 방식으로, 작업자 프로세스에 오류가 발생하면 마스터 프로세스가 새 작업자를 분기 할 수 있으므로 &lt;code&gt;domain&lt;/code&gt; 사용은 클러스터 모듈과 함께 사용됩니다. 여러 머신으로 확장되는 Node.js 프로그램의 경우 종료 프록시 또는 서비스 레지스트리가 실패를 기록하고 이에 따라 대응할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c8ce86c05cf45e881c8b88dcfc90bac15ce63e" translate="yes" xml:space="preserve">
          <source>In this way, the common &lt;code&gt;if (err) return callback(err);&lt;/code&gt; pattern can be replaced with a single error handler in a single place.</source>
          <target state="translated">이런 식으로 일반적인 &lt;code&gt;if (err) return callback(err);&lt;/code&gt; 단일 위치에서 패턴을 단일 오류 처리기로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1593e2fa0de1cde7649f366647211411e84269" translate="yes" xml:space="preserve">
          <source>In versions of Node.js prior to 6.0.0, &lt;code&gt;Buffer&lt;/code&gt; instances were created using the &lt;code&gt;Buffer&lt;/code&gt; constructor function, which allocates the returned &lt;code&gt;Buffer&lt;/code&gt; differently based on what arguments are provided:</source>
          <target state="translated">6.0.0 이전의 Node.js 버전에서는 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스는 &lt;code&gt;Buffer&lt;/code&gt; 생성자 함수를 사용하여 작성되었으며 , 제공되는 인수에 따라 리턴 된 &lt;code&gt;Buffer&lt;/code&gt; 를 다르게 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="832c4629f7e8996e07e8102ea0fa28b91da7e64c" translate="yes" xml:space="preserve">
          <source>Inadequate Security</source>
          <target state="translated">부적절한 보안</target>
        </trans-unit>
        <trans-unit id="00695bb607f52dab548ebe840966ef926ce5e82c" translate="yes" xml:space="preserve">
          <source>Increases indentation of subsequent lines by two spaces.</source>
          <target state="translated">다음 줄의 들여 쓰기를 두 칸 늘립니다.</target>
        </trans-unit>
        <trans-unit id="1d70be8dce5ba727bab7ab54dcd1d8109b04da3a" translate="yes" xml:space="preserve">
          <source>Indexed properties can be set in a similar manner. Consider the following JavaScript snippet:</source>
          <target state="translated">인덱싱 된 속성은 비슷한 방식으로 설정할 수 있습니다. 다음 JavaScript 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cfe35ae027c5117ae3dcbc4f4499564544b6855c" translate="yes" xml:space="preserve">
          <source>Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.</source>
          <target state="translated">노드 끝 옵션을 나타냅니다. 나머지 인수는 스크립트로 전달하십시오. 이 전에 스크립트 파일 이름이나 eval / print 스크립트가 제공되지 않으면 다음 인수가 스크립트 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="99d425840951d8be042af09d1dcf66a17ffc427c" translate="yes" xml:space="preserve">
          <source>Indicate whether to treat &lt;code&gt;TypedArray&lt;/code&gt; and &lt;code&gt;DataView&lt;/code&gt; objects as host objects, i.e. pass them to &lt;a href=&quot;#v8_serializer_writehostobject_object&quot;&gt;&lt;code&gt;serializer._writeHostObject()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TypedArray&lt;/code&gt; 및 &lt;code&gt;DataView&lt;/code&gt; 객체를 호스트 객체로 처리할지 여부를 나타냅니다 ( 예 : &lt;a href=&quot;#v8_serializer_writehostobject_object&quot;&gt; &lt;code&gt;serializer._writeHostObject()&lt;/code&gt; &lt;/a&gt; 전달 ). .</target>
        </trans-unit>
        <trans-unit id="fb592b621da88223e8c8eeaa77068b4a45722a59" translate="yes" xml:space="preserve">
          <source>Indicates a bad protocol option.</source>
          <target state="translated">잘못된 프로토콜 옵션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8ce04c2ac7352b9f26f40319a3e76118d2aa0de4" translate="yes" xml:space="preserve">
          <source>Indicates a broken pipe.</source>
          <target state="translated">파이프가 파손되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="af50c58faad8a1bc38a6c9a13abb8207dd6be3b4" translate="yes" xml:space="preserve">
          <source>Indicates a protocol error.</source>
          <target state="translated">프로토콜 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed6600816a977d05967d85edb3fba53ca13ec802" translate="yes" xml:space="preserve">
          <source>Indicates a stale file handle reference.</source>
          <target state="translated">오래된 파일 핸들 참조를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="970e3b5809af80329b70563fbfeafb59b12d099d" translate="yes" xml:space="preserve">
          <source>Indicates a system call failure.</source>
          <target state="translated">시스템 호출 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47f9d21b2e00f4702c7ba7173aab1e2e364d4334" translate="yes" xml:space="preserve">
          <source>Indicates an exec format error.</source>
          <target state="translated">exec 형식 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7cc6e95cd367c61b66f24c7fe172fdd4c8923fd1" translate="yes" xml:space="preserve">
          <source>Indicates an expired timer.</source>
          <target state="translated">만료 된 타이머를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c6d7b9adaac7927a8389d72c9d49641a39dfb73" translate="yes" xml:space="preserve">
          <source>Indicates an illegal byte sequence.</source>
          <target state="translated">잘못된 바이트 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c2399784693d157cc9db6a7d56a6802acafd3410" translate="yes" xml:space="preserve">
          <source>Indicates an improper link.</source>
          <target state="translated">부적절한 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5096800752c0124499ffda65a06e130ca52bf58" translate="yes" xml:space="preserve">
          <source>Indicates an inappropriate I/O control operation.</source>
          <target state="translated">부적절한 I / O 제어 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47bec5da438c0efb0d77c5a830b93909367a15cd" translate="yes" xml:space="preserve">
          <source>Indicates an interrupted function call.</source>
          <target state="translated">중단 된 함수 호출을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f90c9f7ea77891094deecf8791df2b6a6f6e7be0" translate="yes" xml:space="preserve">
          <source>Indicates an invalid data message.</source>
          <target state="translated">유효하지 않은 데이터 메시지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c88760d39d665b5ee4f2cedcdae333c06a2e638" translate="yes" xml:space="preserve">
          <source>Indicates an invalid file handle.</source>
          <target state="translated">유효하지 않은 파일 핸들을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e973fa6216cda928d3b1ff9110620c4c3f989631" translate="yes" xml:space="preserve">
          <source>Indicates an invalid pointer address.</source>
          <target state="translated">유효하지 않은 포인터 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="542f438ea8fb2199f934997e9825630c4ad77ec3" translate="yes" xml:space="preserve">
          <source>Indicates an invalid seek operation.</source>
          <target state="translated">유효하지 않은 탐색 조작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec1cddd818d2d11c606513689ef95576ae628a23" translate="yes" xml:space="preserve">
          <source>Indicates an invalid service provider.</source>
          <target state="translated">유효하지 않은 서비스 제공자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca69bd9871d6b4b835be2cc5b7e303a5aeb76ba5" translate="yes" xml:space="preserve">
          <source>Indicates an otherwise unspecified I/O error.</source>
          <target state="translated">지정되지 않은 I / O 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93e1ce7f1ec33ca5400e5c2d49688b755daf62ba" translate="yes" xml:space="preserve">
          <source>Indicates insufficient permissions to complete the operation.</source>
          <target state="translated">작업을 완료 할 권한이 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1ea06b534d77b7af671ce8399f89fdee2b70e93d" translate="yes" xml:space="preserve">
          <source>Indicates no such device or address.</source>
          <target state="translated">그러한 장치 나 주소가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b3bb95ecdaaf6e1c491e89dc55bdf4ada5917b17" translate="yes" xml:space="preserve">
          <source>Indicates that a class type was not found.</source>
          <target state="translated">클래스 유형을 찾을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a078deb966b1f0dbb2923905efd3bfa3c6936245" translate="yes" xml:space="preserve">
          <source>Indicates that a database query was refused.</source>
          <target state="translated">데이터베이스 쿼리가 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5b0136ce90dcbd9af267c4da8409264b6bd7ceca" translate="yes" xml:space="preserve">
          <source>Indicates that a destination address is required.</source>
          <target state="translated">대상 주소가 필요함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65b88689f4254cf59cbd36c90757eba4ed54d095" translate="yes" xml:space="preserve">
          <source>Indicates that a device or resource is busy.</source>
          <target state="translated">장치 또는 리소스가 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9096f517c393ffbea05056d33a410bb9d60b9052" translate="yes" xml:space="preserve">
          <source>Indicates that a file descriptor is not valid.</source>
          <target state="translated">파일 디스크립터가 유효하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="077d00dbf6c0ccd17eaf6e1e436cd24460670b70" translate="yes" xml:space="preserve">
          <source>Indicates that a function call was interrupted.</source>
          <target state="translated">함수 호출이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="32434c08cff7624431ad07e73db693f189e5d592" translate="yes" xml:space="preserve">
          <source>Indicates that a function has not been implemented.</source>
          <target state="translated">기능이 구현되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74b21789e4d047a87bbefcae69e223e57c0e7bc1" translate="yes" xml:space="preserve">
          <source>Indicates that a given operation is not supported.</source>
          <target state="translated">지정된 작업이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08aa9ba556ae45765e72b0f04829db3b1e21a970" translate="yes" xml:space="preserve">
          <source>Indicates that a given protocol is not available.</source>
          <target state="translated">주어진 프로토콜을 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ccae215e314e41ad23dfb2f6f21781ee668e8a7" translate="yes" xml:space="preserve">
          <source>Indicates that a given resource is not a stream.</source>
          <target state="translated">주어진 자원이 스트림이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="922181aef7cb91ecc745d786636e602f8d8746de" translate="yes" xml:space="preserve">
          <source>Indicates that a graceful shutdown is in progress.</source>
          <target state="translated">정상 종료가 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cfcd2648b9d53561c3025491875a16bef0d4576" translate="yes" xml:space="preserve">
          <source>Indicates that a multihop was attempted.</source>
          <target state="translated">멀티 홉이 시도되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="372b49dc7ed23c93af3008079025984775b9a0a1" translate="yes" xml:space="preserve">
          <source>Indicates that a name cannot be translated.</source>
          <target state="translated">이름을 번역 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb0450ee237990615ef0438fa979bfc59059b2b2" translate="yes" xml:space="preserve">
          <source>Indicates that a name was too long.</source>
          <target state="translated">이름이 너무 길 었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b454765c5ab209985df1dbfb4d65a1bff4292245" translate="yes" xml:space="preserve">
          <source>Indicates that a network host is down.</source>
          <target state="translated">네트워크 호스트가 다운되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="830228d8de255623ef067539c11b71452b1b48e0" translate="yes" xml:space="preserve">
          <source>Indicates that a protocol is not supported.</source>
          <target state="translated">프로토콜이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a2d0760b68dc2b9e3234f32c458f8a15a66f253a" translate="yes" xml:space="preserve">
          <source>Indicates that a resource deadlock has been avoided.</source>
          <target state="translated">리소스 교착 상태를 피했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57423d447a54dca4cdf2140de632822c67c31e39" translate="yes" xml:space="preserve">
          <source>Indicates that a resource is temporarily unavailable.</source>
          <target state="translated">리소스를 일시적으로 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c0b30d5efeba61a960acda84ef5df098d46eae0f" translate="yes" xml:space="preserve">
          <source>Indicates that a service was not found.</source>
          <target state="translated">서비스를 찾을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2128a64f48d84403ea51f2253aaedfb90b12afd6" translate="yes" xml:space="preserve">
          <source>Indicates that a text file is busy.</source>
          <target state="translated">텍스트 파일이 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3789cc087d5c8e5368437244d2068b7da97884fe" translate="yes" xml:space="preserve">
          <source>Indicates that a value is too large to be stored in a given data type.</source>
          <target state="translated">지정된 데이터 유형에 저장하기에 값이 너무 큼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="119dde472605c62e07c67fc1eb210d45a22024ad" translate="yes" xml:space="preserve">
          <source>Indicates that an argument is out of the domain of the function.</source>
          <target state="translated">인수가 함수의 도메인 외부에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="206c12d38e5f031ad2d2a6389b829af57d9dcd48" translate="yes" xml:space="preserve">
          <source>Indicates that an invalid argument was passed.</source>
          <target state="translated">유효하지 않은 인수가 전달되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="18f885333d175807022b890e71c998dfc2743f45" translate="yes" xml:space="preserve">
          <source>Indicates that an invalid argument was provided.</source>
          <target state="translated">잘못된 인수가 제공되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39125118a5a05fdb14d46044b0ea226b675a9877" translate="yes" xml:space="preserve">
          <source>Indicates that an operation has been canceled.</source>
          <target state="translated">작업이 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1d4a2a79fb94045c9c939b6febc16183fe9de98" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is already in progress.</source>
          <target state="translated">작업이 이미 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="948ed5bc8d3bcef9cb214d0bff38ef1f9cbb6092" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is currently in progress.</source>
          <target state="translated">작업이 현재 진행 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c9fc2a88443f1bd9bcd796a3c09a586342edc14" translate="yes" xml:space="preserve">
          <source>Indicates that an operation is not supported on the socket. Note that while &lt;code&gt;ENOTSUP&lt;/code&gt; and &lt;code&gt;EOPNOTSUPP&lt;/code&gt; have the same value on Linux, according to POSIX.1 these error values should be distinct.)</source>
          <target state="translated">소켓에서 작업이 지원되지 않음을 나타냅니다. 반면 유의 &lt;code&gt;ENOTSUP&lt;/code&gt; 및 &lt;code&gt;EOPNOTSUPP&lt;/code&gt; 는 POSIX.1에있어서, 리눅스에서 동일한 값을 가지고 이러한 에러 값은 구별되어야한다.)</target>
        </trans-unit>
        <trans-unit id="4c078047af5f70ba3758bfb52a630d790c966eef" translate="yes" xml:space="preserve">
          <source>Indicates that an operation was canceled.</source>
          <target state="translated">작업이 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4e4c46f02c3fe5b062d6dee34e96956cdbf1d2ef" translate="yes" xml:space="preserve">
          <source>Indicates that data cannot be sent after the socket has been shutdown.</source>
          <target state="translated">소켓이 종료 된 후 데이터를 전송할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d4b71c7fe6eb8dcca0374a54346d6d8ee080a7d" translate="yes" xml:space="preserve">
          <source>Indicates that no buffer space is available.</source>
          <target state="translated">사용 가능한 버퍼 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fb5fe0bc009a449b0c131d1b39cee3df3ec53be6" translate="yes" xml:space="preserve">
          <source>Indicates that no message is available on the stream head read queue.</source>
          <target state="translated">스트림 헤드 읽기 큐에 사용 가능한 메시지가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76b762b35b459e2a3f4130aaecebcc05d526dd1d" translate="yes" xml:space="preserve">
          <source>Indicates that successful WSAStartup has not yet been performed.</source>
          <target state="translated">성공적인 WSAStartup이 아직 수행되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48d443e903069b79fc6fc8e876cd1f59a55ab321" translate="yes" xml:space="preserve">
          <source>Indicates that the &lt;code&gt;winsock.dll&lt;/code&gt; version is out of range.</source>
          <target state="translated">&lt;code&gt;winsock.dll&lt;/code&gt; 버전이 범위를 벗어 났음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8b67731347b7d3d1a2fb104a016252967ec1f8a" translate="yes" xml:space="preserve">
          <source>Indicates that the address family is not supported.</source>
          <target state="translated">주소 패밀리가 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5593d5f8a211a9b9a1628f4eb1448ba6b26682d7" translate="yes" xml:space="preserve">
          <source>Indicates that the call was canceled.</source>
          <target state="translated">통화가 취소되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0a53ecfeb6b859c1766e6952e74ee72db93b25b" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been aborted by the network.</source>
          <target state="translated">네트워크에 의해 연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="695ee1b1d84ae237c8c3346f15676398969a0d84" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been aborted.</source>
          <target state="translated">연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8362bc4ab7de1fd6ca1112c54f2f53624fc425a" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been refused.</source>
          <target state="translated">연결이 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="757641a9b638d2123741484401860c5f6d474ad0" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has been reset by the peer.</source>
          <target state="translated">피어가 연결을 재설정했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e3ae37829bc190196d8da2831b4c0f75007675de" translate="yes" xml:space="preserve">
          <source>Indicates that the connection has timed out.</source>
          <target state="translated">연결 시간이 초과되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b4be4d3afaa2e5f45d481ca27450e687b555f25" translate="yes" xml:space="preserve">
          <source>Indicates that the connection timed out.</source>
          <target state="translated">연결 시간이 초과되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63d73aaa34d8df5ee63adbb0894f6278dfec083d" translate="yes" xml:space="preserve">
          <source>Indicates that the directory is not empty.</source>
          <target state="translated">디렉토리가 비어 있지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e46d1e52d341e3f224dfa62b18df35ba474687e5" translate="yes" xml:space="preserve">
          <source>Indicates that the disk quota has been exceeded.</source>
          <target state="translated">디스크 할당량을 초과했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="161c3595104196dd948b18febc343f1bd46f25c7" translate="yes" xml:space="preserve">
          <source>Indicates that the file already exists.</source>
          <target state="translated">파일이 이미 존재 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a60ba5dd633cddcea59d035cdabd5b096d7d3e9a" translate="yes" xml:space="preserve">
          <source>Indicates that the file handle is stale.</source>
          <target state="translated">파일 핸들이 오래되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="855b2f5e83d5f45403266942ed6a78a8e48438fd" translate="yes" xml:space="preserve">
          <source>Indicates that the file is too large.</source>
          <target state="translated">파일이 너무 크다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40663f45ce87393265672016c54db313ad1a6e64" translate="yes" xml:space="preserve">
          <source>Indicates that the file system is read only.</source>
          <target state="translated">파일 시스템이 읽기 전용임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e2436e26e43b92563a743feba4b113fa8a275c36" translate="yes" xml:space="preserve">
          <source>Indicates that the filename is too long.</source>
          <target state="translated">파일 이름이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="089cc30b91254f5c76ce11943c070ea4bb9e4ffe" translate="yes" xml:space="preserve">
          <source>Indicates that the given item is not a socket.</source>
          <target state="translated">주어진 항목이 소켓이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="55d9efc8d6c36c8b3a99098120e3624ebd4ee169" translate="yes" xml:space="preserve">
          <source>Indicates that the host is unreachable.</source>
          <target state="translated">호스트에 연결할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6deb274595ac102e6a95cf0fda8844325c2402b2" translate="yes" xml:space="preserve">
          <source>Indicates that the identifier has been removed.</source>
          <target state="translated">식별자가 제거되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16385ed77106de084d977545579771db76e25687" translate="yes" xml:space="preserve">
          <source>Indicates that the item is remote.</source>
          <target state="translated">항목이 원격임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd0453304f970d9c1105ea3bd64f4cc2e4c65c32" translate="yes" xml:space="preserve">
          <source>Indicates that the list of arguments is longer than expected.</source>
          <target state="translated">인수 목록이 예상보다 길다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfafda04ebb20ac0339f69bfb2547f21a46f2b4c" translate="yes" xml:space="preserve">
          <source>Indicates that the message size is too long.</source>
          <target state="translated">메시지 크기가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="28f8f8a59da191885b3db8e166955be99443a142" translate="yes" xml:space="preserve">
          <source>Indicates that the network address family is not supported.</source>
          <target state="translated">네트워크 주소 제품군이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1b3a54983042b769b394e9481c90955db44eede" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is already in use.</source>
          <target state="translated">네트워크 주소가 이미 사용 중임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f10c1721305ff9e8e66fc7ac1a7b82f41551e9d" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is currently unavailable for use.</source>
          <target state="translated">네트워크 주소를 현재 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a794b8e798681860dc3c2cd356736564119b7aaa" translate="yes" xml:space="preserve">
          <source>Indicates that the network address is not available.</source>
          <target state="translated">네트워크 주소를 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b452c6966555edcc5055e10c8498f2a68f0760bc" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been aborted.</source>
          <target state="translated">네트워크 연결이 중단되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4764d277de78c1ce7c30015888e50a4502c04cda" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been refused.</source>
          <target state="translated">네트워크 연결이 거부되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9b9818c6db8926eb6f8490fe27a113f4e4f48bd3" translate="yes" xml:space="preserve">
          <source>Indicates that the network connection has been reset.</source>
          <target state="translated">네트워크 연결이 재설정되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0e4630ae08750c7cc87ea20c36c05978a40c3365" translate="yes" xml:space="preserve">
          <source>Indicates that the network is down.</source>
          <target state="translated">네트워크가 다운되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4af29b3221c7857a372f20709460cf0cf423ed12" translate="yes" xml:space="preserve">
          <source>Indicates that the network is unreachable.</source>
          <target state="translated">네트워크에 연결할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="368c2e27b0922fb850ee9cc185aaaabf0f6f0c72" translate="yes" xml:space="preserve">
          <source>Indicates that the network subsystem is not ready.</source>
          <target state="translated">네트워크 서브 시스템이 준비되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="383ae045925743a63505cb92d9281c853dfbcc7c" translate="yes" xml:space="preserve">
          <source>Indicates that the operation did not have sufficient permissions.</source>
          <target state="translated">작업에 충분한 권한이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2bcee5ac45f4a21f13696f8ffe7c93a2d766ac8a" translate="yes" xml:space="preserve">
          <source>Indicates that the operation is not permitted.</source>
          <target state="translated">작업이 허용되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65f9f362c2c3c2f761dab77a4a911af304ad3f33" translate="yes" xml:space="preserve">
          <source>Indicates that the operation is not supported.</source>
          <target state="translated">작업이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="776c0d89c093c17f22b7b6705dc7e7960302d908" translate="yes" xml:space="preserve">
          <source>Indicates that the operation would block.</source>
          <target state="translated">작업이 차단됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e117af40033e88e685ebc9243ba8656b98dee296" translate="yes" xml:space="preserve">
          <source>Indicates that the path is a directory.</source>
          <target state="translated">경로가 디렉토리임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="701e0fe25025bc13b6c3ae1b84ed6ee66e9cf69e" translate="yes" xml:space="preserve">
          <source>Indicates that the path is not a directory.</source>
          <target state="translated">경로가 디렉토리가 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2d5bc9d82c613e54c1df8c0723a4c03f1298377f" translate="yes" xml:space="preserve">
          <source>Indicates that the procedure call table is invalid.</source>
          <target state="translated">프로 시저 호출 테이블이 유효하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="03a40bb10c80e6514013b0ad35fa8d777655f104" translate="yes" xml:space="preserve">
          <source>Indicates that the protocol family is not supported.</source>
          <target state="translated">프로토콜 제품군이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71af43ae58a0ce69e6cde0af5f6e86a43cb92527" translate="yes" xml:space="preserve">
          <source>Indicates that the protocol is not supported.</source>
          <target state="translated">프로토콜이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96a23e49b5ed1e325f70e865582ab8264afc3fa6" translate="yes" xml:space="preserve">
          <source>Indicates that the provided message is too long.</source>
          <target state="translated">제공된 메시지가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="74bff985c66849e5fa9d2c2e0ac7cfbb7ceeaf1f" translate="yes" xml:space="preserve">
          <source>Indicates that the resource is not a socket.</source>
          <target state="translated">자원이 소켓이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d33c873c0e43a3d1c20a25c9f226c7397de4abc4" translate="yes" xml:space="preserve">
          <source>Indicates that the results are too large.</source>
          <target state="translated">결과가 너무 크다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bcf3dc9f9254b168e5ca41afd9d2992ac56a9e00" translate="yes" xml:space="preserve">
          <source>Indicates that the service provider failed to initialized.</source>
          <target state="translated">서비스 제공 업체 초기화에 실패했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef5ae11922fe267f93483559945ea71416b14b63" translate="yes" xml:space="preserve">
          <source>Indicates that the socket already has a pending connection in progress.</source>
          <target state="translated">소켓에 이미 보류중인 연결이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="da9a9c897b5c353995793f4224f6105691fd33a8" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is already connected.</source>
          <target state="translated">소켓이 이미 연결되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d63328104df6e2b2399694396579fe9ce96abe0f" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is connected.</source>
          <target state="translated">소켓이 연결되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a4539fe8fe18ebf237948a7033f92ffe07cf5b8" translate="yes" xml:space="preserve">
          <source>Indicates that the socket is not connected.</source>
          <target state="translated">소켓이 연결되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4574e95a6c77d72a0a44c095218843f94a28bb70" translate="yes" xml:space="preserve">
          <source>Indicates that the socket type is not supported.</source>
          <target state="translated">소켓 유형이 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b14389542f80e2a560b89ba1bb7a23334b01d4c1" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying &lt;a href=&quot;#http2_class_http2stream&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt; was closed. Just like &lt;code&gt;'end'&lt;/code&gt;, this event occurs only once per response.</source>
          <target state="translated">기본 &lt;a href=&quot;#http2_class_http2stream&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 닫 혔음을 나타냅니다 . 마찬가지로 &lt;code&gt;'end'&lt;/code&gt; 이 이벤트는 응답 당 한 번만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a4be62dc021781f1f7331af72972eee9db55491" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying &lt;a href=&quot;http2&quot;&gt;&lt;code&gt;Http2Stream&lt;/code&gt;&lt;/a&gt; was terminated before &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; was called or able to flush.</source>
          <target state="translated">&lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 가 호출되거나 플러시 되기 전에 기본 &lt;a href=&quot;http2&quot;&gt; &lt;code&gt;Http2Stream&lt;/code&gt; &lt;/a&gt; 이 종료 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7d37a8f24a3523e9d164fbb58172c9cd00aa98d6" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying connection was closed.</source>
          <target state="translated">기본 연결이 닫 혔음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19e0d6007f4cfb102172b1f94dcbf1507928863f" translate="yes" xml:space="preserve">
          <source>Indicates that the underlying connection was terminated.</source>
          <target state="translated">기본 연결이 종료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="260e1df33ddcd4e82330898db6a7ca89ab095d5c" translate="yes" xml:space="preserve">
          <source>Indicates that the user quota has been exceeded.</source>
          <target state="translated">사용자 할당량을 초과했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c18f1d989cebb9a5ccb0014b0a3b804ab18c29c8" translate="yes" xml:space="preserve">
          <source>Indicates that there are no child processes.</source>
          <target state="translated">자식 프로세스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89b994954e043610752ae496b165c4ad0cfacabb" translate="yes" xml:space="preserve">
          <source>Indicates that there are no locks available.</source>
          <target state="translated">사용 가능한 잠금이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6614378fd3d8db903142159b891610453273befe" translate="yes" xml:space="preserve">
          <source>Indicates that there are no more results.</source>
          <target state="translated">더 이상 결과가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c2f963abe2e3b2191a35765acbcd9088625836c" translate="yes" xml:space="preserve">
          <source>Indicates that there are no stream resources available.</source>
          <target state="translated">사용 가능한 스트림 리소스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f9a897a9242c6f8deaa685d649f1f37446fe4f32" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many hard links to a file.</source>
          <target state="translated">파일에 대한 하드 링크가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e28f98082ba14f699b932ee58bac27df4cf4769d" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many open files.</source>
          <target state="translated">열린 파일이 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f92b6f438bbbad6dd4b5c6e5240708cfc537fc1f" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many processes.</source>
          <target state="translated">프로세스가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71d85f876e9626a6491e65d612e9b483bfa7b9cd" translate="yes" xml:space="preserve">
          <source>Indicates that there are too many references.</source>
          <target state="translated">참조가 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="61082c259368a9f710adafe9a304001eb1fee6c5" translate="yes" xml:space="preserve">
          <source>Indicates that there is currently no data available and to try the operation again later.</source>
          <target state="translated">현재 사용 가능한 데이터가 없으며 나중에 작업을 다시 시도해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b83fced05951abf5691548b4cd2103feaf2c694a" translate="yes" xml:space="preserve">
          <source>Indicates that there is no buffer space available.</source>
          <target state="translated">사용 가능한 버퍼 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="976457834d5fc65d10eefc909f9b879b0f79e739" translate="yes" xml:space="preserve">
          <source>Indicates that there is no message of the desired type.</source>
          <target state="translated">원하는 유형의 메시지가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="22073a072089d5c0ffc9dce772a1a7ec08c2c53f" translate="yes" xml:space="preserve">
          <source>Indicates that there is no route to a network host.</source>
          <target state="translated">네트워크 호스트에 대한 경로가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ee2f6e7184bd083b8b8ad9d4456fd58b427c7808" translate="yes" xml:space="preserve">
          <source>Indicates that there is no space available on the device.</source>
          <target state="translated">장치에 사용 가능한 공간이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7853ff79915590151db29acfe2f8a05e4231bf78" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such device.</source>
          <target state="translated">해당 장치가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="feb99cc3620ddf00d8a100209370656211892cda" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such file or directory.</source>
          <target state="translated">그러한 파일이나 디렉토리가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="46c76f2198f24358bd4c816200de1fcb8af12a78" translate="yes" xml:space="preserve">
          <source>Indicates that there is no such process.</source>
          <target state="translated">그러한 프로세스가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27353c844a6a35a27649ab175b0eb68661ef531a" translate="yes" xml:space="preserve">
          <source>Indicates that there is not enough space.</source>
          <target state="translated">공간이 충분하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="da5e1a3736d4e24ec12fb4f0df216bed85b2f1b8" translate="yes" xml:space="preserve">
          <source>Indicates the wrong protocol type for the socket.</source>
          <target state="translated">소켓에 대한 잘못된 프로토콜 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8d7594bb044a48ce5960ed97b1c5e185a94eb43" translate="yes" xml:space="preserve">
          <source>Indicates the wrong type of protocol for a socket.</source>
          <target state="translated">소켓에 대한 잘못된 프로토콜 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33cd43c392b2eaab3b1a94dfcc9ae9f8cb85a5fb" translate="yes" xml:space="preserve">
          <source>Indicates too many levels of symbolic links in a path.</source>
          <target state="translated">경로에 너무 많은 레벨의 기호 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1121a0a8baa36b282377bd118336f82d59471e5" translate="yes" xml:space="preserve">
          <source>Indicates too many open files in the system.</source>
          <target state="translated">시스템에서 열린 파일이 너무 많음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f793ef295cef1dc50901d3c108997d4015097940" translate="yes" xml:space="preserve">
          <source>Indicates whether a callback has been set using &lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt;&lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;process#process_process_setuncaughtexceptioncapturecallback_fn&quot;&gt; &lt;code&gt;process.setUncaughtExceptionCaptureCallback()&lt;/code&gt; &lt;/a&gt; 사용하여 콜백이 설정되었는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="84abc9bf3d68bcff752515aa207501469e0aa0e9" translate="yes" xml:space="preserve">
          <source>Indicates whether the &lt;code&gt;Http2Session&lt;/code&gt; is currently waiting for acknowledgment of a sent &lt;code&gt;SETTINGS&lt;/code&gt; frame. Will be &lt;code&gt;true&lt;/code&gt; after calling the &lt;code&gt;http2session.settings()&lt;/code&gt; method. Will be &lt;code&gt;false&lt;/code&gt; once all sent &lt;code&gt;SETTINGS&lt;/code&gt; frames have been acknowledged.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 이 현재 전송 된 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임의 승인을 기다리고 있는지 여부를 나타냅니다 . 수 있을까요 &lt;code&gt;true&lt;/code&gt; 호출 후 &lt;code&gt;http2session.settings()&lt;/code&gt; 메소드를. 있을 것인가 &lt;code&gt;false&lt;/code&gt; 모든 전송하면 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임이 인정되고있다.</target>
        </trans-unit>
        <trans-unit id="42c22cb8018104ad4a34b76968a323a00574ca11" translate="yes" xml:space="preserve">
          <source>Indications that a link has been severed.</source>
          <target state="translated">링크가 끊 겼음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="2c6d1039846355bb3c61f905e9d3ba65581c1937" translate="yes" xml:space="preserve">
          <source>Informational HTTP status codes (&lt;code&gt;1xx&lt;/code&gt;) may not be set as the response status code on HTTP/2 responses.</source>
          <target state="translated">정보 용 HTTP 상태 코드 ( &lt;code&gt;1xx&lt;/code&gt; )는 HTTP / 2 응답에서 응답 상태 코드로 설정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10f35ea53e49802f840775c3d4b91ff4f9c6035d" translate="yes" xml:space="preserve">
          <source>Inherit the prototype methods from one &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor&quot;&gt;constructor&lt;/a&gt; into another. The prototype of &lt;code&gt;constructor&lt;/code&gt; will be set to a new object created from &lt;code&gt;superConstructor&lt;/code&gt;.</source>
          <target state="translated">한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor&quot;&gt;생성자&lt;/a&gt; 에서 다른 생성자 로 프로토 타입 메소드를 상속하십시오 . &lt;code&gt;constructor&lt;/code&gt; 의 프로토 타입은 &lt;code&gt;superConstructor&lt;/code&gt; 에서 생성 된 새 객체로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c605479b3766044fe5d8c5e766dca7dfa29eac8" translate="yes" xml:space="preserve">
          <source>Initialization vectors should be unpredictable and unique; ideally, they will be cryptographically random. They do not have to be secret: IVs are typically just added to ciphertext messages unencrypted. It may sound contradictory that something has to be unpredictable and unique, but does not have to be secret; it is important to remember that an attacker must not be able to predict ahead of time what a given IV will be.</source>
          <target state="translated">초기화 벡터는 예측할 수없고 고유해야합니다. 이상적으로는 암호로 임의적입니다. 비밀 일 필요는 없습니다. IV는 일반적으로 암호화되지 않은 암호문 메시지에 추가됩니다. 무언가가 예측할 수없고 독특해야하지만 비밀 일 필요는 없다는 것이 모순 될 수 있습니다. 공격자는 주어진 IV가 무엇인지 미리 예측할 수 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="a81cf0d3001b974f4ab0ead2bdb88c2f9cb54eeb" translate="yes" xml:space="preserve">
          <source>Initializes a history log file for the REPL instance. When executing the Node.js binary and using the command line REPL, a history file is initialized by default. However, this is not the case when creating a REPL programmatically. Use this method to initialize a history log file when working with REPL instances programmatically.</source>
          <target state="translated">REPL 인스턴스의 히스토리 로그 파일을 초기화합니다. Node.js 바이너리를 실행하고 명령 행 REPL을 사용하면 히스토리 파일이 기본적으로 초기화됩니다. 그러나 프로그래밍 방식으로 REPL을 작성하는 경우에는 그렇지 않습니다. 프로그래밍 방식으로 REPL 인스턴스로 작업 할 때이 방법을 사용하여 기록 로그 파일을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="a4cdbd02ba690df84da7adc74e183f564120378f" translate="yes" xml:space="preserve">
          <source>Initiate a TCP connection on the given socket.</source>
          <target state="translated">주어진 소켓에서 TCP 연결을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="0d5479f7f1139e75134b5638b844d0e258a74f35" translate="yes" xml:space="preserve">
          <source>Initiate a connection on a given socket.</source>
          <target state="translated">주어진 소켓에서 연결을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="810ba9b70df6c10d966779b0bafa88ded886aa59" translate="yes" xml:space="preserve">
          <source>Initiate a connection on a given socket. Normally this method is not needed, the socket should be created and opened with &lt;a href=&quot;#net_net_createconnection&quot;&gt;&lt;code&gt;net.createConnection()&lt;/code&gt;&lt;/a&gt;. Use this only when implementing a custom Socket.</source>
          <target state="translated">주어진 소켓에서 연결을 시작하십시오. 일반적으로이 메소드는 필요하지 않습니다. 소켓은 &lt;a href=&quot;#net_net_createconnection&quot;&gt; &lt;code&gt;net.createConnection()&lt;/code&gt; &lt;/a&gt; 으로 작성하고 열어야 합니다. 커스텀 소켓을 구현할 때만 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6043ac861d8556db1f1186a96ea25461c657c5ba" translate="yes" xml:space="preserve">
          <source>Initiate an &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; connection on the given socket.</source>
          <target state="translated">주어진 소켓에서 &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; 연결을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="586faf8bd3a03c92f8cb24c136ad18b37d24ab58" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection.</source>
          <target state="translated">TCP 연결을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="53a4de7eba42de63d90bb804549dc818d7f966d1" translate="yes" xml:space="preserve">
          <source>Initiates a push stream. The callback is invoked with the new &lt;code&gt;Http2Stream&lt;/code&gt; instance created for the push stream passed as the second argument, or an &lt;code&gt;Error&lt;/code&gt; passed as the first argument.</source>
          <target state="translated">푸시 스트림을 시작합니다. 콜백은 두 번째 인수로 전달 된 푸시 스트림 또는 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 대해 작성된 새 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c2bf8ae9d7cffd1a2491dca9b8c27dd7928ed38" translate="yes" xml:space="preserve">
          <source>Initiates a response whose data is read from the given file descriptor. No validation is performed on the given file descriptor. If an error occurs while attempting to read data using the file descriptor, the &lt;code&gt;Http2Stream&lt;/code&gt; will be closed using an &lt;code&gt;RST_STREAM&lt;/code&gt; frame using the standard &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; code.</source>
          <target state="translated">주어진 파일 디스크립터에서 데이터를 읽는 응답을 시작합니다. 지정된 파일 디스크립터에 대한 유효성 검증이 수행되지 않습니다. 파일 디스크립터를 사용하여 데이터를 읽는 중 오류가 발생 하면 표준 &lt;code&gt;INTERNAL_ERROR&lt;/code&gt; 코드 를 사용하는 &lt;code&gt;RST_STREAM&lt;/code&gt; 프레임을 사용 하여 &lt;code&gt;Http2Stream&lt;/code&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="35fb6e9a05f63492052bc71c81678318b03c33a7" translate="yes" xml:space="preserve">
          <source>Initiates an &lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; connection.</source>
          <target state="translated">&lt;a href=&quot;#net_ipc_support&quot;&gt;IPC&lt;/a&gt; 연결을 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="26d4e2e6f7bc72aa1b7fe9902a5761b23f342bb5" translate="yes" xml:space="preserve">
          <source>Inodes</source>
          <target state="translated">Inodes</target>
        </trans-unit>
        <trans-unit id="720c091ce87a13844611624e3c634ce2ed5d326a" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Buffer&lt;/code&gt; and &lt;code&gt;Uint8Array&lt;/code&gt; instances passed to the &lt;code&gt;http2.getUnpackedSettings()&lt;/code&gt; API must have a length that is a multiple of six.</source>
          <target state="translated">&lt;code&gt;http2.getUnpackedSettings()&lt;/code&gt; API에 전달 된 입력 &lt;code&gt;Buffer&lt;/code&gt; 및 &lt;code&gt;Uint8Array&lt;/code&gt; 인스턴스 의 길이는 6의 배수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="08ab03b761f96fdd2c5da59a100ff5730e9c4009" translate="yes" xml:space="preserve">
          <source>Inserting the statement &lt;code&gt;debugger;&lt;/code&gt; into the source code of a script will enable a breakpoint at that position in the code:</source>
          <target state="translated">명령문 &lt;code&gt;debugger;&lt;/code&gt; 삽입 스크립트의 소스 코드에 코드의 해당 위치에서 중단 점을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="051747894e566bebff8a6f6ae4afde9c862d5e6c" translate="yes" xml:space="preserve">
          <source>Inspecting linked lists and similar objects is now possible up to the maximum call stack size.</source>
          <target state="translated">최대 연결 스택 크기까지 연결된 목록 및 유사한 객체를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8222c902ae0723e8bb352bb17ed76809e4688165" translate="yes" xml:space="preserve">
          <source>Inspector</source>
          <target state="translated">Inspector</target>
        </trans-unit>
        <trans-unit id="ad8db003f59f527184ade10382360155f5682949" translate="yes" xml:space="preserve">
          <source>Inspector only methods</source>
          <target state="translated">인스펙터 전용 방법</target>
        </trans-unit>
        <trans-unit id="a0cf2d5cc76825e10c97a10dd59da6837fcc0666" translate="yes" xml:space="preserve">
          <source>Installing async hooks via &lt;code&gt;async_hooks.createHook&lt;/code&gt; enables promise execution tracking:</source>
          <target state="translated">&lt;code&gt;async_hooks.createHook&lt;/code&gt; 을 통해 비동기 후크를 설치 하면 약속 실행 추적이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5458ffc182cdf6836a16e2f16d8f4bd6d79f5c4e" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#repl_class_replserver&quot;&gt;&lt;code&gt;repl.REPLServer&lt;/code&gt;&lt;/a&gt; support automatic completion of inputs, simplistic Emacs-style line editing, multi-line inputs, ANSI-styled output, saving and restoring current REPL session state, error recovery, and customizable evaluation functions.</source>
          <target state="translated">&lt;a href=&quot;#repl_class_replserver&quot;&gt; &lt;code&gt;repl.REPLServer&lt;/code&gt; &lt;/a&gt; 인스턴스는 입력 자동 완성, 단순한 Emacs 스타일 라인 편집, 멀티 라인 입력, ANSI 스타일 출력, 현재 REPL 세션 상태 저장 및 복원, 오류 복구 및 사용자 정의 가능한 평가 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b89a320c3f62e6b6ba8e85b021337befc0641078" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;ChildProcess&lt;/code&gt; are not intended to be created directly. Rather, use the &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt;&lt;code&gt;child_process.exec()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#child_process_child_process_execfile_file_args_options_callback&quot;&gt;&lt;code&gt;child_process.execFile()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt; methods to create instances of &lt;code&gt;ChildProcess&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스는 직접 작성하기위한 것이 아닙니다. 대신 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#child_process_child_process_exec_command_options_callback&quot;&gt; &lt;code&gt;child_process.exec()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#child_process_child_process_execfile_file_args_options_callback&quot;&gt; &lt;code&gt;child_process.execFile()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;ChildProcess&lt;/code&gt; 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="db1b65a0d3c2528e965754146fd9d0a86600f551" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Duplex&lt;/code&gt; now return &lt;code&gt;true&lt;/code&gt; when checking &lt;code&gt;instanceof stream.Writable&lt;/code&gt;.</source>
          <target state="translated">instance . &lt;code&gt;instanceof stream.Writable&lt;/code&gt; 확인할 때 &lt;code&gt;Duplex&lt;/code&gt; 인스턴스가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8fdd2c2c9379faa14d448a471b59a6faffffb1ed" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Http2SecureServer&lt;/code&gt; are created using the &lt;code&gt;http2.createSecureServer()&lt;/code&gt; function. The &lt;code&gt;Http2SecureServer&lt;/code&gt; class is not exported directly by the &lt;code&gt;http2&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Http2SecureServer&lt;/code&gt; 의 인스턴스는 http2.createSecureServer &lt;code&gt;http2.createSecureServer()&lt;/code&gt; 함수를 사용하여 작성 됩니다. &lt;code&gt;Http2SecureServer&lt;/code&gt; 의 클래스는 직접 내보낼 수 없습니다 &lt;code&gt;http2&lt;/code&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="e618cc6bee9611e42d99ee69ae677154195e8043" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;Http2Server&lt;/code&gt; are created using the &lt;code&gt;http2.createServer()&lt;/code&gt; function. The &lt;code&gt;Http2Server&lt;/code&gt; class is not exported directly by the &lt;code&gt;http2&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;Http2Server&lt;/code&gt; 인스턴스는 http2.createServer &lt;code&gt;http2.createServer()&lt;/code&gt; 함수를 사용하여 작성 됩니다. &lt;code&gt;Http2Server&lt;/code&gt; 의 클래스는 직접 내보낼 수 없습니다 &lt;code&gt;http2&lt;/code&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="c931f1541982a4495922666b7b5bc642601cc990" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;tls.TLSSocket&lt;/code&gt; implement the duplex &lt;a href=&quot;stream#stream_stream&quot;&gt;Stream&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;tls.TLSSocket&lt;/code&gt; 의 인스턴스는 이중 &lt;a href=&quot;stream#stream_stream&quot;&gt;스트림&lt;/a&gt; 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="35783666b090e1bcb188e0ff52ae2b546eb2a159" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Buffer&lt;/code&gt; class are similar to arrays of integers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; (other integers are coerced to this range by &lt;code&gt;&amp;amp; 255&lt;/code&gt; operation) but correspond to fixed-sized, raw memory allocations outside the V8 heap. The size of the &lt;code&gt;Buffer&lt;/code&gt; is established when it is created and cannot be changed.</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;255&lt;/code&gt; 까지의 정수 배열과 유사하지만 (다른 정수는 &lt;code&gt;&amp;amp; 255&lt;/code&gt; 연산 으로이 범위로 강제 변환 됨 ) V8 힙 외부의 고정 크기 원시 메모리 할당에 해당합니다. &lt;code&gt;Buffer&lt;/code&gt; 의 크기 는 생성 될 때 설정되며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dffd1ef53587360af9f4e464d4d5cf73ae045da0" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Certificate&lt;/code&gt; class can be created using the &lt;code&gt;new&lt;/code&gt; keyword or by calling &lt;code&gt;crypto.Certificate()&lt;/code&gt; as a function:</source>
          <target state="translated">&lt;code&gt;Certificate&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;new&lt;/code&gt; 키워드를 사용하거나 &lt;code&gt;crypto.Certificate()&lt;/code&gt; 를 함수로 호출 하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a67f7f0229202a5e0c59ed378df4ef19e04cdd1" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;ChildProcess&lt;/code&gt; class are &lt;a href=&quot;events#events_class_eventemitter&quot;&gt;&lt;code&gt;EventEmitters&lt;/code&gt;&lt;/a&gt; that represent spawned child processes.</source>
          <target state="translated">&lt;code&gt;ChildProcess&lt;/code&gt; 클래스의 인스턴스 는 생성 된 자식 프로세스를 나타내는 &lt;a href=&quot;events#events_class_eventemitter&quot;&gt; &lt;code&gt;EventEmitters&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0cc93f3328ea5a0a0adcec2dba75fe3d0516e6a" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Cipher&lt;/code&gt; class are used to encrypt data. The class can be used in one of two ways:</source>
          <target state="translated">&lt;code&gt;Cipher&lt;/code&gt; 클래스의 인스턴스는 데이터를 암호화하는 데 사용됩니다. 이 클래스는 다음 두 가지 방법 중 하나로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adadf4a8671dae9115a1b4925ff5480625d42ff5" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;Decipher&lt;/code&gt; class are used to decrypt data. The class can be used in one of two ways:</source>
          <target state="translated">&lt;code&gt;Decipher&lt;/code&gt; 클래스의 인스턴스는 데이터를 해독하는 데 사용됩니다. 이 클래스는 다음 두 가지 방법 중 하나로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c29738f83796b77d7a2afe6dfa6aa91432202d54" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;DiffieHellman&lt;/code&gt; class can be created using the &lt;a href=&quot;#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding&quot;&gt;&lt;code&gt;crypto.createDiffieHellman()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;DiffieHellman&lt;/code&gt; 클래스의 인스턴스는 &lt;a href=&quot;#crypto_crypto_creatediffiehellman_prime_primeencoding_generator_generatorencoding&quot;&gt; &lt;code&gt;crypto.createDiffieHellman()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06629143118ba183c91662524da3d6583f95f245" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;ECDH&lt;/code&gt; class can be created using the &lt;a href=&quot;#crypto_crypto_createecdh_curvename&quot;&gt;&lt;code&gt;crypto.createECDH()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;ECDH&lt;/code&gt; 클래스의 인스턴스는 &lt;a href=&quot;#crypto_crypto_createecdh_curvename&quot;&gt; &lt;code&gt;crypto.createECDH()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e19a3efe923bf85bc8b05ac0272473f4501716f9" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;FileHandle&lt;/code&gt; object are created internally by the &lt;code&gt;fsPromises.open()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;FileHandle&lt;/code&gt; 객체의 인스턴스는 &lt;code&gt;fsPromises.open()&lt;/code&gt; 메서드에 의해 내부적으로 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="af20962e987f76605ebbac474846e378dc9efb59" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;http2.Http2Session&lt;/code&gt; class represent an active communications session between an HTTP/2 client and server. Instances of this class are &lt;em&gt;not&lt;/em&gt; intended to be constructed directly by user code.</source>
          <target state="translated">&lt;code&gt;http2.Http2Session&lt;/code&gt; 클래스의 인스턴스 는 HTTP / 2 클라이언트와 서버 간의 활성 통신 세션을 나타냅니다. 이 클래스의 인스턴스는 사용자 코드로 직접 구성 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="432d12dcbaa96cbcfdc7739ae3abf129c909c6a7" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;readline.Interface&lt;/code&gt; class are constructed using the &lt;code&gt;readline.createInterface()&lt;/code&gt; method. Every instance is associated with a single &lt;code&gt;input&lt;/code&gt;&lt;a href=&quot;stream#stream_readable_streams&quot;&gt;Readable&lt;/a&gt; stream and a single &lt;code&gt;output&lt;/code&gt;&lt;a href=&quot;stream#stream_writable_streams&quot;&gt;Writable&lt;/a&gt; stream. The &lt;code&gt;output&lt;/code&gt; stream is used to print prompts for user input that arrives on, and is read from, the &lt;code&gt;input&lt;/code&gt; stream.</source>
          <target state="translated">&lt;code&gt;readline.Interface&lt;/code&gt; 클래스의 인스턴스는 &lt;code&gt;readline.createInterface()&lt;/code&gt; 메소드를 사용하여 구성됩니다 . 모든 인스턴스는 단일 &lt;code&gt;input&lt;/code&gt; &lt;a href=&quot;stream#stream_readable_streams&quot;&gt;읽기 가능&lt;/a&gt; 스트림 및 단일 &lt;code&gt;output&lt;/code&gt; &lt;a href=&quot;stream#stream_writable_streams&quot;&gt;쓰기 &lt;/a&gt;가능 스트림과 연결됩니다 . &lt;code&gt;output&lt;/code&gt; 스트림에 도착 사용자 입력 용 프롬프트를 인쇄하는 데 사용되며,로부터 판독 &lt;code&gt;input&lt;/code&gt; 스트림.</target>
        </trans-unit>
        <trans-unit id="c0a8dd21a7c8c59429281b201339a2209dc5cdab" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;vm.Script&lt;/code&gt; class contain precompiled scripts that can be executed in specific sandboxes (or &quot;contexts&quot;).</source>
          <target state="translated">&lt;code&gt;vm.Script&lt;/code&gt; 클래스의 인스턴스 에는 특정 샌드 박스 (또는 &quot;컨텍스트&quot;)에서 실행할 수있는 미리 컴파일 된 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce65dd9273ad652d638f34de4134789c3e16e945" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;worker.MessageChannel&lt;/code&gt; class represent an asynchronous, two-way communications channel. The &lt;code&gt;MessageChannel&lt;/code&gt; has no methods of its own. &lt;code&gt;new MessageChannel()&lt;/code&gt; yields an object with &lt;code&gt;port1&lt;/code&gt; and &lt;code&gt;port2&lt;/code&gt; properties, which refer to linked &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">&lt;code&gt;worker.MessageChannel&lt;/code&gt; 클래스의 인스턴스 는 비동기 양방향 통신 채널을 나타냅니다. &lt;code&gt;MessageChannel&lt;/code&gt; 은 자신의 어떤 방법이 없습니다. &lt;code&gt;new MessageChannel()&lt;/code&gt; 은 링크 된 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 인스턴스 를 참조하는 &lt;code&gt;port1&lt;/code&gt; 및 &lt;code&gt;port2&lt;/code&gt; 속성을 가진 객체를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7a38e81654aa75e50f8ac4a46d3a4444cd9d971f" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;code&gt;worker.MessagePort&lt;/code&gt; class represent one end of an asynchronous, two-way communications channel. It can be used to transfer structured data, memory regions and other &lt;code&gt;MessagePort&lt;/code&gt;s between different &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">&lt;code&gt;worker.MessagePort&lt;/code&gt; 클래스의 인스턴스 는 비동기 양방향 통신 채널의 한쪽 끝을 나타냅니다. 다른 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 간에 구조화 된 데이터, 메모리 영역 및 기타 &lt;code&gt;MessagePort&lt;/code&gt; 를 전송하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c676be9a0fcb70600a6d6a66e1bc4fb7d9ad4219" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;URLSearchParams&lt;/code&gt; object with a query hash map. The key and value of each property of &lt;code&gt;obj&lt;/code&gt; are always coerced to strings.</source>
          <target state="translated">쿼리 해시 맵을 사용 하여 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화하십시오 . &lt;code&gt;obj&lt;/code&gt; 의 각 속성의 키와 값 은 항상 문자열로 강제됩니다.</target>
        </trans-unit>
        <trans-unit id="65181063e2280876fa3f8f363ffe435314f6a6cc" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;URLSearchParams&lt;/code&gt; object with an iterable map in a way that is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;'s constructor. &lt;code&gt;iterable&lt;/code&gt; can be an &lt;code&gt;Array&lt;/code&gt; or any iterable object. That means &lt;code&gt;iterable&lt;/code&gt; can be another &lt;code&gt;URLSearchParams&lt;/code&gt;, in which case the constructor will simply create a clone of the provided &lt;code&gt;URLSearchParams&lt;/code&gt;. Elements of &lt;code&gt;iterable&lt;/code&gt; are key-value pairs, and can themselves be any iterable object.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 의 생성자 와 비슷한 방식으로 반복 가능한 맵 으로 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화합니다 . &lt;code&gt;iterable&lt;/code&gt; 은 &lt;code&gt;Array&lt;/code&gt; 또는 iterable 객체 일 수 있습니다 . 이는 &lt;code&gt;iterable&lt;/code&gt; 이 다른 &lt;code&gt;URLSearchParams&lt;/code&gt; 일 수 있음을 의미하며 ,이 경우 생성자는 제공된 &lt;code&gt;URLSearchParams&lt;/code&gt; 의 복제본을 만들 것 입니다. &lt;code&gt;iterable&lt;/code&gt; 의 요소 는 키-값 쌍이며 반복 가능한 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc82e9b73a75737421b7fc3a88c424c1b841dee" translate="yes" xml:space="preserve">
          <source>Instantiate a new empty &lt;code&gt;URLSearchParams&lt;/code&gt; object.</source>
          <target state="translated">비어있는 새 &lt;code&gt;URLSearchParams&lt;/code&gt; 객체를 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="b21c73c2d5f688055cfa8ed255e3120b2cccea8d" translate="yes" xml:space="preserve">
          <source>Instantiate the module. This must be called after linking has completed (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt;); otherwise it will throw an error. It may also throw an exception if one of the dependencies does not provide an export the parent module requires.</source>
          <target state="translated">모듈을 인스턴스화하십시오. 링크가 완료된 후에 호출되어야합니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; 는 &lt;code&gt;'linked'&lt;/code&gt; 입니다 ). 그렇지 않으면 오류가 발생합니다. 또한 종속 항목 중 하나가 상위 모듈에 필요한 내보내기를 제공하지 않으면 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fed39324e841d37c87d9ceaf44bcca4c8c9a4e11" translate="yes" xml:space="preserve">
          <source>Instead of throwing the original error it is now wrapped into an &lt;code&gt;AssertionError&lt;/code&gt; that contains the full stack trace.</source>
          <target state="translated">원래 오류를 발생시키는 대신 이제 전체 스택 추적이 포함 된 &lt;code&gt;AssertionError&lt;/code&gt; 에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="0886c0750f47c6c020e0212835b6e14e09f31e83" translate="yes" xml:space="preserve">
          <source>Instruct &lt;code&gt;require&lt;/code&gt; on how to handle certain file extensions.</source>
          <target state="translated">지시합니다은 &lt;code&gt;require&lt;/code&gt; 특정 파일 확장자를 처리하는 방법에.</target>
        </trans-unit>
        <trans-unit id="c063ff3cdde65053663a7873bf8ab9bd399ef6b0" translate="yes" xml:space="preserve">
          <source>Instructs Node.js to error prior to running any code if the policy does not have the specified integrity. It expects a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; string as a parameter.</source>
          <target state="translated">정책에 지정된 무결성이없는 경우 코드를 실행하기 전에 Node.js에 오류가 발생하도록 지시합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 문자열을 매개 변수로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="0b2c85f8a9e409e60a7c57bb3a6180c6a74b488d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft.</source>
          <target state="translated">OpenSSL에 초기 버전의 cryptopro 초안에서 server-hello 확장을 추가하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ac6c05112a017d47310f296b0041f44b75da5a87" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always create a new key when using temporary/ephemeral DH parameters.</source>
          <target state="translated">임시 / 일시적 DH 매개 변수를 사용할 때 OpenSSL이 항상 새 키를 작성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="546f5bbe97ae294c8fc5e687dae9f83654f746e8" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always create a new key when using temporary/ephemeral ECDH parameters.</source>
          <target state="translated">임시 / 일시적 ECDH 매개 변수를 사용할 때 항상 새 키를 작성하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ac0311c08a3469b8d71f9d3883a3fe4a8bf94820" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always start a new session when performing renegotiation.</source>
          <target state="translated">재협상을 수행 할 때 항상 새 세션을 시작하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ae7bb7ececabda2568352c90383393ed8f76fe08" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to always use the tmp_rsa key when performing RSA operations.</source>
          <target state="translated">RSA 작업을 수행 할 때 항상 tmp_rsa 키를 사용하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="caca42fad826dd949c6335a63c6ceb14c18ab473" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d.</source>
          <target state="translated">OpenSSL 0.9.6d에 추가 된 SSL 3.0 / TLS 1.0 취약성 해결 방법을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="23867858cda445617e031433f5f870ccca19e39d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable support for SSL/TLS compression.</source>
          <target state="translated">SSL / TLS 압축 지원을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0b25ca4b0affb115218bbc6dc9c81460963a1551" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable the workaround for a man-in-the-middle protocol-version vulnerability in the SSL 2.0 server implementation.</source>
          <target state="translated">SSL 2.0 서버 구현에서 중간자 프로토콜 버전 취약점에 대한 대안을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2165b961ee84bb34e7517631c063e2f2f98f243d" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable use of RFC4507bis tickets.</source>
          <target state="translated">RFC4507bis 티켓 사용을 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="608aeeeb5a40e2d41f521b3de5c1f59b365144e3" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to disable version rollback attack detection.</source>
          <target state="translated">버전 롤백 공격 탐지를 비활성화하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="710ee28e0f7e59c4bcb18bce916c5f0f0d575362" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off SSL v2</source>
          <target state="translated">SSL v2를 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="4a26e814f5c329c70cc5bbf34635600b0166e139" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off SSL v3</source>
          <target state="translated">OpenSSL에 SSL v3을 끄도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="80de102aad3b8873aa476d2f44620c3de39d7a90" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1</source>
          <target state="translated">TLS v1을 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0e08471820c4afa43946e65eac375fcd772422b3" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1.1</source>
          <target state="translated">TLS v1.1을 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="55e7bd4f680213d3fc1d7f9ebf87e0706ef0e930" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn off TLS v1.2</source>
          <target state="translated">TLS v1.2를 끄도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="dfbab4e09330ea425ca00047c6c5baf5232c6ce4" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to turn on cookie exchange.</source>
          <target state="translated">쿠키 교환을 설정하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1e82de46cebb9eab62329940282272bfd3ba678a" translate="yes" xml:space="preserve">
          <source>Instructs OpenSSL to use Cisco's &quot;speshul&quot; version of DTLS_BAD_VER.</source>
          <target state="translated">Cisco의 &quot;speshul&quot;버전 DTLS_BAD_VER를 사용하도록 OpenSSL에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="75031cb337e0583a13d4c7be4edb3e048cfc6d63" translate="yes" xml:space="preserve">
          <source>Instructs the kernel to leave a multicast group at &lt;code&gt;multicastAddress&lt;/code&gt; using the &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; socket option. This method is automatically called by the kernel when the socket is closed or the process terminates, so most apps will never have reason to call this.</source>
          <target state="translated">커널 지시에 멀티 캐스트 그룹을 떠날 &lt;code&gt;multicastAddress&lt;/code&gt; 은 Using &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; 의 소켓 옵션을 선택합니다. 이 메소드는 소켓이 닫히거나 프로세스가 종료 될 때 커널에 의해 자동으로 호출되므로 대부분의 앱은이를 호출 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1144c6f61e59c74db28b6c4b9401d09107634752" translate="yes" xml:space="preserve">
          <source>Instructs the module loader to preserve symbolic links when resolving and caching modules.</source>
          <target state="translated">모듈을 해석하고 캐싱 할 때 기호 링크를 유지하도록 모듈 로더에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="6870fb28c403ee5eb0f8b0e36861a73965d25e9a" translate="yes" xml:space="preserve">
          <source>Instructs the module loader to preserve symbolic links when resolving and caching the main module (&lt;code&gt;require.main&lt;/code&gt;).</source>
          <target state="translated">메인 모듈 ( &lt;code&gt;require.main&lt;/code&gt; )을 해결하고 캐싱 할 때 심볼릭 링크를 유지하도록 모듈 로더에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="8402b4a029cc3b4cbc3fef404091dc1447dc7b5c" translate="yes" xml:space="preserve">
          <source>Integer value representing the expected input size; defaults to &lt;code&gt;0&lt;/code&gt; for an unknown input size.</source>
          <target state="translated">예상 입력 크기를 나타내는 정수 값. 알 수없는 입력 크기의 경우 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="99ab494ded4d235df6eccb37568024a22d56ee79" translate="yes" xml:space="preserve">
          <source>Integer-Indexed: an index value represented by &lt;code&gt;uint32_t&lt;/code&gt;</source>
          <target state="translated">정수 색인 : &lt;code&gt;uint32_t&lt;/code&gt; 로 표시되는 색인 값</target>
        </trans-unit>
        <trans-unit id="81bd3b466b0034894173f99f33ef569af480be3a" translate="yes" xml:space="preserve">
          <source>Integers read from a &lt;code&gt;Buffer&lt;/code&gt; are interpreted as two's complement signed values.</source>
          <target state="translated">&lt;code&gt;Buffer&lt;/code&gt; 에서 읽은 정수 는 2의 보수 부호 값으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b05fe054d228b76470ec56b7184d0bc99d39e7ba" translate="yes" xml:space="preserve">
          <source>Integral status code indicating the success or failure of a N-API call. Currently, the following status codes are supported.</source>
          <target state="translated">N-API 호출의 성공 또는 실패를 나타내는 통합 상태 코드입니다. 현재 다음 상태 코드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5b62f41c12ee066d13d5c86a1257925ad8861703" translate="yes" xml:space="preserve">
          <source>Integrity Checks</source>
          <target state="translated">무결성 검사</target>
        </trans-unit>
        <trans-unit id="4cb5b39c0f8028f339c4e3a11a09d7b24bb24591" translate="yes" xml:space="preserve">
          <source>Integrity can be specified as the boolean value &lt;code&gt;true&lt;/code&gt; to accept any body for the resource which can be useful for local development. It is not recommended in production since it would allow unexpected alteration of resources to be considered valid.</source>
          <target state="translated">무결성은 부울 값 &lt;code&gt;true&lt;/code&gt; 로 지정되어 로컬 개발에 유용 할 수있는 자원의 본문을 승인 할 수 있습니다. 예상치 못한 자원 변경이 유효한 것으로 간주되므로 프로덕션 환경에서는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="23575f35a521e9c261d274ac4cb29c2f05b261ac" translate="yes" xml:space="preserve">
          <source>Internal Error</source>
          <target state="translated">내부 오류</target>
        </trans-unit>
        <trans-unit id="be2832f2017b9feac348c32119b337871f7f79ff" translate="yes" xml:space="preserve">
          <source>Internal Node.js libraries. Node.js itself exports a number of C++ APIs that Addons can use &amp;mdash; the most important of which is the &lt;code&gt;node::ObjectWrap&lt;/code&gt; class.</source>
          <target state="translated">내부 Node.js 라이브러리 Node.js 자체는 애드온이 사용할 수있는 많은 C ++ API를 내 보냅니다. 그 중 가장 중요한 것은 &lt;code&gt;node::ObjectWrap&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f4c2cebcc0952f7ae86ffbb2645ce54c5574178" translate="yes" xml:space="preserve">
          <source>Internal errors occur when an HTTP/2 session fails unexpectedly. These will be reported via an &lt;code&gt;'error'&lt;/code&gt; event on the &lt;code&gt;Http2Session&lt;/code&gt; or HTTP/2 Server objects.</source>
          <target state="translated">HTTP / 2 세션이 예기치 않게 실패하면 내부 오류가 발생합니다. 이는 &lt;code&gt;Http2Session&lt;/code&gt; 또는 HTTP / 2 Server 오브젝트 에서 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 통해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad90811f03e8bbaf83a345f7229936551486b928" translate="yes" xml:space="preserve">
          <source>Internal properties no longer appear in the context argument of a custom inspection function.</source>
          <target state="translated">내부 속성이 더 이상 사용자 정의 검사 기능의 컨텍스트 인수에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="845202ae0fe1a669c29ddc90a5436534b580fc96" translate="yes" xml:space="preserve">
          <source>Internationalization Support</source>
          <target state="translated">국제화 지원</target>
        </trans-unit>
        <trans-unit id="f1c74da0c6c57362d1086bc64d6d9a5389c76829" translate="yes" xml:space="preserve">
          <source>Interoperability with CommonJS</source>
          <target state="translated">CommonJS와의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="1f06c6ea3387d2dd0326bd91120a11c32eb42186" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of 64-bit numbers and swaps byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 8.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 64 비트 숫자의 배열로 해석 하고 그 &lt;em&gt;자리에서&lt;/em&gt; 바이트 순서 &lt;em&gt;를&lt;/em&gt; 바꿉니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 8의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="e3f37cf37971ac698f0307a0849c4d8a45eaa91f" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 16-bit integers and swaps the byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 2.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 16 비트 정수의 배열로 해석 하고 바이트 순서 &lt;em&gt;를&lt;/em&gt; 교체합니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 2의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="d8b8e329633284e96f9adb1691da632260f2b83b" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 32-bit integers and swaps the byte order &lt;em&gt;in-place&lt;/em&gt;. Throws &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt;&lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#buffer_buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 4.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 32 비트 정수의 배열로 해석 하고 바이트 순서 &lt;em&gt;를&lt;/em&gt; 교체합니다 . &lt;a href=&quot;#buffer_buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 4의 배수가 아닌 경우 &lt;a href=&quot;errors#ERR_INVALID_BUFFER_SIZE&quot;&gt; &lt;code&gt;ERR_INVALID_BUFFER_SIZE&lt;/code&gt; 를&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="2c495326cbec001dafeaa0da9ab820a10bbe892f" translate="yes" xml:space="preserve">
          <source>Introduced &lt;code&gt;latin1&lt;/code&gt; as an alias for &lt;code&gt;binary&lt;/code&gt;.</source>
          <target state="translated">도입 &lt;code&gt;latin1&lt;/code&gt; 의 별칭으로 &lt;code&gt;binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="e9c92f0c550f88b8f940f3db1e7343ac28f0092f" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;hash&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;hash&lt;/code&gt; 속성에 할당 된 값에 포함 된 잘못된 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트로 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1629e5ff15506fca0875d4572b9feec31e969dc3" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;password&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;password&lt;/code&gt; 특성에 지정된 값에 포함 된 유효하지 않은 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08d09dda66848238d39695ce4a7fee107a1aaf1b" translate="yes" xml:space="preserve">
          <source>Invalid URL characters included in the value assigned to the &lt;code&gt;pathname&lt;/code&gt; property are &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;percent-encoded&lt;/a&gt;. The selection of which characters to percent-encode may vary somewhat from what the &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt;&lt;code&gt;url.parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#url_url_format_urlobject&quot;&gt;&lt;code&gt;url.format()&lt;/code&gt;&lt;/a&gt; methods would produce.</source>
          <target state="translated">&lt;code&gt;pathname&lt;/code&gt; 특성에 지정된 값에 포함 된 유효하지 않은 URL 문자 는 &lt;a href=&quot;#whatwg-percent-encoding&quot;&gt;퍼센트로 인코딩&lt;/a&gt; 됩니다. 퍼센트 인코딩 할 문자 선택은 &lt;a href=&quot;#url_url_parse_urlstring_parsequerystring_slashesdenotehost&quot;&gt; &lt;code&gt;url.parse()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#url_url_format_urlobject&quot;&gt; &lt;code&gt;url.format()&lt;/code&gt; &lt;/a&gt; 메소드가 생성 하는 문자와 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65f72a935bbcf546bea987da823f35b5a5e27db6" translate="yes" xml:space="preserve">
          <source>Invalid URL protocol values assigned to the &lt;code&gt;protocol&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;protocol&lt;/code&gt; 속성에 할당 된 잘못된 URL 프로토콜 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="738d6832032229b051ea3b4a368aee59f1757724" translate="yes" xml:space="preserve">
          <source>Invalid character handling in header names and values</source>
          <target state="translated">헤더 이름 및 값에서 유효하지 않은 문자 처리</target>
        </trans-unit>
        <trans-unit id="fe947aa91a35f6be8f5dcea115d7f1b3523381d5" translate="yes" xml:space="preserve">
          <source>Invalid characters were detected in headers.</source>
          <target state="translated">헤더에서 유효하지 않은 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="52cbfcf6f98b93d30c926a6b1749b607fc691744" translate="yes" xml:space="preserve">
          <source>Invalid host values assigned to the &lt;code&gt;host&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 특성에 지정된 유효하지 않은 호스트 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eae8e79a320be525fba1c1ca46fb7bf1f890b46f" translate="yes" xml:space="preserve">
          <source>Invalid hostname values assigned to the &lt;code&gt;hostname&lt;/code&gt; property are ignored.</source>
          <target state="translated">&lt;code&gt;hostname&lt;/code&gt; 특성에 지정된 유효하지 않은 호스트 이름 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d21c7370be790d52740a91b52fc49543cba6a787" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;stream#stream_writable_writablefinished&quot;&gt;&lt;code&gt;writable.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http2_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다 . 대신 사용하려면 &lt;a href=&quot;stream#stream_writable_writablefinished&quot;&gt; &lt;code&gt;writable.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6b8a83f3e29a618906de053b984b4116151588fe" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_request_end_data_encoding_callback&quot;&gt;&lt;code&gt;request.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#http_request_writablefinished&quot;&gt;&lt;code&gt;request.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http_request_end_data_encoding_callback&quot;&gt; &lt;code&gt;request.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은이 사용 &lt;a href=&quot;#http_request_writablefinished&quot;&gt; &lt;code&gt;request.writableFinished&lt;/code&gt; &lt;/a&gt; 대신 데이터가 플러시되었는지 여부를 나타내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="279811758f3fc49f9271db9de98d53ac59a3a35f" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt;&lt;code&gt;response.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#http_response_writablefinished&quot;&gt;&lt;code&gt;response.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#http_response_end_data_encoding_callback&quot;&gt; &lt;code&gt;response.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터를 플러시했는지 여부를 나타내지 않으므로 대신 &lt;a href=&quot;#http_response_writablefinished&quot;&gt; &lt;code&gt;response.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c457dffdf62810b5e0e74ea9f6901231788f1d26" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_readable_destroy_error&quot;&gt;&lt;code&gt;readable.destroy()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_readable_destroy_error&quot;&gt; &lt;code&gt;readable.destroy()&lt;/code&gt; &lt;/a&gt; 불려왔다.</target>
        </trans-unit>
        <trans-unit id="27ba9b336441c7b9636f805f2664a8b20332ff3a" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_writable_destroy_error&quot;&gt;&lt;code&gt;writable.destroy()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_writable_destroy_error&quot;&gt; &lt;code&gt;writable.destroy()&lt;/code&gt; &lt;/a&gt; 불려왔다.</target>
        </trans-unit>
        <trans-unit id="8e457e44e34dbf6c98b053774a3a83b0eda0d06e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;#stream_writable_end_chunk_encoding_callback&quot;&gt;&lt;code&gt;writable.end()&lt;/code&gt;&lt;/a&gt; has been called. This property does not indicate whether the data has been flushed, for this use &lt;a href=&quot;#stream_writable_writablefinished&quot;&gt;&lt;code&gt;writable.writableFinished&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 후 &lt;a href=&quot;#stream_writable_end_chunk_encoding_callback&quot;&gt; &lt;code&gt;writable.end()&lt;/code&gt; &lt;/a&gt; 불려왔다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다 . 대신 사용하려면 &lt;a href=&quot;#stream_writable_writablefinished&quot;&gt; &lt;code&gt;writable.writableFinished&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="447e18b05fa6d326f80492387bf46993194d011e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if all data has been flushed to the underlying system, immediately before the &lt;a href=&quot;#http_event_finish&quot;&gt;&lt;code&gt;'finish'&lt;/code&gt;&lt;/a&gt; event is emitted.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 모든 데이터가 바로 전에, 기본 시스템에 플러시 된 경우 &lt;a href=&quot;#http_event_finish&quot;&gt; &lt;code&gt;'finish'&lt;/code&gt; &lt;/a&gt; 이벤트가 방출된다.</target>
        </trans-unit>
        <trans-unit id="7e8d5a5a4a8431f9f64a806e5b6f385f45074325" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_readable_read_size&quot;&gt;&lt;code&gt;readable.read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 은 전화를 안전한지 &lt;a href=&quot;#stream_readable_read_size&quot;&gt; &lt;code&gt;readable.read()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4370f01d3c96b257612ae70204203ea0a8789809" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if it is safe to call &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt;&lt;code&gt;writable.write()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 은 전화를 안전한지 &lt;a href=&quot;#stream_writable_write_chunk_encoding_callback&quot;&gt; &lt;code&gt;writable.write()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a54e2373de13c6357b66bf3b96598900cda4816e" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;true&lt;/code&gt; if this code is not running inside of a &lt;a href=&quot;#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; thread.</source>
          <target state="translated">가 &lt;code&gt;true&lt;/code&gt; 이 코드는 내부에 실행되고 있지 않은 경우 &lt;a href=&quot;#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드.</target>
        </trans-unit>
        <trans-unit id="5ea282d632dfbf0003030b6293ca539ecda81b32" translate="yes" xml:space="preserve">
          <source>Is set to &lt;code&gt;true&lt;/code&gt; immediately before the &lt;a href=&quot;#stream_event_finish&quot;&gt;&lt;code&gt;'finish'&lt;/code&gt;&lt;/a&gt; event is emitted.</source>
          <target state="translated">&lt;a href=&quot;#stream_event_finish&quot;&gt; &lt;code&gt;'finish'&lt;/code&gt; &lt;/a&gt; 이벤트가 생성 되기 직전 에 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="31f54ec164d59bd1126c3d41ec9e0caa797ca9ac" translate="yes" xml:space="preserve">
          <source>It allows a shortcut, so that &lt;code&gt;module.exports.f = ...&lt;/code&gt; can be written more succinctly as &lt;code&gt;exports.f = ...&lt;/code&gt;. However, be aware that like any variable, if a new value is assigned to &lt;code&gt;exports&lt;/code&gt;, it is no longer bound to &lt;code&gt;module.exports&lt;/code&gt;:</source>
          <target state="translated">바로 가기를 허용하므로 &lt;code&gt;module.exports.f = ...&lt;/code&gt; 를 더 간결하게 &lt;code&gt;exports.f = ...&lt;/code&gt; 로 쓸 수 있습니다 . 그러나 변수와 마찬가지로 새 값이 &lt;code&gt;exports&lt;/code&gt; 에 할당되면 더 이상 &lt;code&gt;module.exports&lt;/code&gt; 에 바인딩되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9073ca8fe086c420a4962aa555b1febbd7e4eb14" translate="yes" xml:space="preserve">
          <source>It can also be created by Node.js and passed to the user when a connection is received. For example, it is passed to the listeners of a &lt;a href=&quot;#net_event_connection&quot;&gt;&lt;code&gt;'connection'&lt;/code&gt;&lt;/a&gt; event emitted on a &lt;a href=&quot;#net_class_net_server&quot;&gt;&lt;code&gt;net.Server&lt;/code&gt;&lt;/a&gt;, so the user can use it to interact with the client.</source>
          <target state="translated">Node.js에 의해 생성되어 연결이 수신 될 때 사용자에게 전달 될 수도 있습니다. 예를 들어, &lt;a href=&quot;#net_class_net_server&quot;&gt; &lt;code&gt;net.Server&lt;/code&gt; &lt;/a&gt; 에서 생성 된 &lt;a href=&quot;#net_event_connection&quot;&gt; &lt;code&gt;'connection'&lt;/code&gt; &lt;/a&gt; 이벤트 의 리스너에 전달 되므로 사용자는이를 사용하여 클라이언트와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5170688bb6d5c05e758eaa86801b72671253446e" translate="yes" xml:space="preserve">
          <source>It can be accessed using:</source>
          <target state="translated">다음을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2502aa25bb881c5a8de387f4855f38f05049a2" translate="yes" xml:space="preserve">
          <source>It creates a symbolic link named &quot;new-port&quot; that points to &quot;foo&quot;.</source>
          <target state="translated">&quot;foo&quot;를 가리키는 &quot;new-port&quot;라는 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5d1be5b11468a8cdf73d05266cfb33d14f98a6df" translate="yes" xml:space="preserve">
          <source>It does nothing if the stream was already destroyed.</source>
          <target state="translated">스트림이 이미 파괴 된 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41d9374edd67e5544a25ed3217406f608f09bce8" translate="yes" xml:space="preserve">
          <source>It has already been linked (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt;)</source>
          <target state="translated">이미 연결되었습니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linked'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a70b0c65dc3241d0690f77cfe10d0e5c2409d02c" translate="yes" xml:space="preserve">
          <source>It helps to provide some global-looking variables that are actually specific to the module, such as:</source>
          <target state="translated">다음과 같이 실제로 모듈에 고유 한 일부 전역 변수를 제공하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0464e843f0f43c4dc6eaefcde1f38e4a3f6cc1" translate="yes" xml:space="preserve">
          <source>It implements the &lt;a href=&quot;stream#stream_class_stream_readable&quot;&gt;Readable Stream&lt;/a&gt; interface, as well as the following additional events, methods, and properties.</source>
          <target state="translated">그것은 구현 &lt;a href=&quot;stream#stream_class_stream_readable&quot;&gt;읽을 수 스트림&lt;/a&gt; 인터페이스뿐만 아니라 다음과 같은 추가 이벤트, 메서드 및 속성을.</target>
        </trans-unit>
        <trans-unit id="5d45f625dfde54e988f472dec8c49c8ac4e78699" translate="yes" xml:space="preserve">
          <source>It is also possible to compress or decompress data in a single step:</source>
          <target state="translated">단일 단계에서 데이터를 압축하거나 압축 해제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bfb3903cd859802eba53ef817be6fc4d39e1d0" translate="yes" xml:space="preserve">
          <source>It is also possible to create new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt; instances from a &lt;code&gt;Buffer&lt;/code&gt; with the following caveats:</source>
          <target state="translated">다음과 같은 경고 를 사용하여 &lt;code&gt;Buffer&lt;/code&gt; 에서 새 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94f8e04142983f13c24079e34f4c988c32e45040" translate="yes" xml:space="preserve">
          <source>It is also possible to set a breakpoint in a file (module) that is not loaded yet:</source>
          <target state="translated">아직로드되지 않은 파일 (모듈)에 중단 점을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e7ef80ba24b9fb35096f06920755ced16718da" translate="yes" xml:space="preserve">
          <source>It is also possible to subscribe only to notifications with specific method:</source>
          <target state="translated">특정 방법으로 알림 만 구독 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36886a21b327f4efa13efb333b8085346c75732" translate="yes" xml:space="preserve">
          <source>It is also possible to wrap C++ objects/classes in a way that allows new instances to be created using the JavaScript &lt;code&gt;new&lt;/code&gt; operator:</source>
          <target state="translated">JavaScript &lt;code&gt;new&lt;/code&gt; 연산자를 사용하여 새 인스턴스를 만들 수있는 방식으로 C ++ 객체 / 클래스를 래핑 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27ace742269815d9bc53f0c5f64ced13adb5440" translate="yes" xml:space="preserve">
          <source>It is also recommended that any &lt;code&gt;'message'&lt;/code&gt; handlers in the child process verify that &lt;code&gt;socket&lt;/code&gt; exists, as the connection may have been closed during the time it takes to send the connection to the child.</source>
          <target state="translated">또한 자식 프로세스 에 연결을 보내는 데 걸리는 시간 동안 연결이 닫 혔을 수 있으므로 자식 프로세스의 모든 &lt;code&gt;'message'&lt;/code&gt; 핸들러가 &lt;code&gt;socket&lt;/code&gt; 이 존재 하는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="16c143cda1d23fdc307acaa4ab93fadca2a6f783" translate="yes" xml:space="preserve">
          <source>It is bad practice to remove listeners added elsewhere in the code, particularly when the &lt;code&gt;EventEmitter&lt;/code&gt; instance was created by some other component or module (e.g. sockets or file streams).</source>
          <target state="translated">코드의 다른 곳에 추가 된 리스너, 특히 &lt;code&gt;EventEmitter&lt;/code&gt; 인스턴스가 다른 컴포넌트 나 모듈 (예 : 소켓 또는 파일 스트림)에 의해 생성 된 경우 리스너를 제거하는 것은 좋지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9c833a8c6ebe950f983fd451c778c087cc9332c0" translate="yes" xml:space="preserve">
          <source>It is being linked (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'linking'&lt;/code&gt;)</source>
          <target state="translated">연결 중입니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; 는 &lt;code&gt;'linking'&lt;/code&gt; 입니다 )</target>
        </trans-unit>
        <trans-unit id="419d5dee627637c5194692a9f10eb64d65bcc9aa" translate="yes" xml:space="preserve">
          <source>It is common practice within Addons to pass JavaScript functions to a C++ function and execute them from there. The following example illustrates how to invoke such callbacks:</source>
          <target state="translated">애드온 내에서 JavaScript 함수를 C ++ 함수로 전달하고 거기서 실행하는 것이 일반적입니다. 다음 예제는 이러한 콜백을 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3048ab55c4bb6de03bd26d55d03dc4c5facb8b7f" translate="yes" xml:space="preserve">
          <source>It is convenient to organize programs and libraries into self-contained directories, and then provide a single entry point to those directories. There are three ways in which a folder may be passed to &lt;code&gt;require()&lt;/code&gt; as an argument.</source>
          <target state="translated">프로그램과 라이브러리를 독립된 디렉토리로 구성한 다음 해당 디렉토리에 단일 진입 점을 제공하는 것이 편리합니다. 폴더를 인수로 &lt;code&gt;require()&lt;/code&gt; 전달할 수있는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ae010a7f5ed72fe5c4197d82c84289cacb4988c" translate="yes" xml:space="preserve">
          <source>It is deprecated and should not be used in new code. JavaScript comes with very similar built-in functionality through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않으며 새 코드에서 사용해서는 안됩니다. JavaScript는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 통해 매우 유사한 내장 기능을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="937f36c6fe0ce89575bd34e56b0dfed7daac172f" translate="yes" xml:space="preserve">
          <source>It is good practice, to &lt;a href=&quot;#http_agent_destroy&quot;&gt;&lt;code&gt;destroy()&lt;/code&gt;&lt;/a&gt; an &lt;code&gt;Agent&lt;/code&gt; instance when it is no longer in use, because unused sockets consume OS resources.</source>
          <target state="translated">사용하지 않는 소켓은 OS 리소스를 소비하므로 더 이상 사용하지 않을 때 &lt;code&gt;Agent&lt;/code&gt; 인스턴스 를 &lt;a href=&quot;#http_agent_destroy&quot;&gt; &lt;code&gt;destroy()&lt;/code&gt; &lt;/a&gt; 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2bc5790e09a1d829dcaf9ede78c9a8dcb7900d48" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that spawned Node.js child processes are independent of the parent with exception of the IPC communication channel that is established between the two. Each process has its own memory, with their own V8 instances. Because of the additional resource allocations required, spawning a large number of child Node.js processes is not recommended.</source>
          <target state="translated">생성 된 Node.js 하위 프로세스는 두 프로세스간에 설정된 IPC 통신 채널을 제외하고 상위 프로세스와 무관하다는 점을 명심해야합니다. 각 프로세스에는 자체 V8 인스턴스가있는 자체 메모리가 있습니다. 추가 리소스 할당이 필요하기 때문에 많은 수의 자식 Node.js 프로세스를 생성하는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4512b8cdb5a3c36488e4bbb14fc8dde177723733" translate="yes" xml:space="preserve">
          <source>It is impossible to know in advance the MTU of each link through which a packet might travel. Sending a datagram greater than the receiver &lt;code&gt;MTU&lt;/code&gt; will not work because the packet will get silently dropped without informing the source that the data did not reach its intended recipient.</source>
          <target state="translated">패킷이 이동할 수있는 각 링크의 MTU를 미리 알 수는 없습니다. 데이터가 수신자 에게 도달하지 않았다는 소스를 알리지 않고 패킷이 자동으로 삭제되므로 수신자 &lt;code&gt;MTU&lt;/code&gt; 보다 큰 데이터 그램을 전송하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e2e4af5d5aa394246178c425f14d66e2517e6db" translate="yes" xml:space="preserve">
          <source>It is not clear whether &lt;code&gt;foo()&lt;/code&gt; or &lt;code&gt;bar()&lt;/code&gt; will be called first.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 또는 &lt;code&gt;bar()&lt;/code&gt; 가 먼저 호출 되는지는 확실하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67feb1878c776ad9fccd934e67f62317478d643e" translate="yes" xml:space="preserve">
          <source>It is not emitted in the worker.</source>
          <target state="translated">작업자에게 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="187a290752482dba747ede2b91a61d535838b186" translate="yes" xml:space="preserve">
          <source>It is not necessary to call into JavaScript via &lt;code&gt;napi_make_callback()&lt;/code&gt; because N-API runs &lt;code&gt;call_js_cb&lt;/code&gt; in a context appropriate for callbacks.</source>
          <target state="translated">N-API는 콜백에 적합한 컨텍스트에서 &lt;code&gt;call_js_cb&lt;/code&gt; 를 실행하므로 &lt;code&gt;napi_make_callback()&lt;/code&gt; 통해 JavaScript를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3d10f2c19d8c5b37fce057d024a074f7f6dd563d" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;code&gt;require()&lt;/code&gt; files that have the &lt;code&gt;.mjs&lt;/code&gt; extension. Attempting to do so will throw &lt;a href=&quot;errors#errors_err_require_esm&quot;&gt;an error&lt;/a&gt;. The &lt;code&gt;.mjs&lt;/code&gt; extension is reserved for &lt;a href=&quot;esm&quot;&gt;ECMAScript Modules&lt;/a&gt; which cannot be loaded via &lt;code&gt;require()&lt;/code&gt;. See &lt;a href=&quot;esm&quot;&gt;ECMAScript Modules&lt;/a&gt; for more details.</source>
          <target state="translated">확장자 가 &lt;code&gt;.mjs&lt;/code&gt; 인 파일은 &lt;code&gt;require()&lt;/code&gt; 할 수 없습니다 . 그렇게하면 &lt;a href=&quot;errors#errors_err_require_esm&quot;&gt;오류가 발생&lt;/a&gt; 합니다. &lt;code&gt;.mjs&lt;/code&gt; 의 확장은 예약되어 &lt;a href=&quot;esm&quot;&gt;ECMAScript를 모듈&lt;/a&gt; 로로드 할 수없는 &lt;code&gt;require()&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;esm&quot;&gt;ECMAScript 모듈&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7b21297f31acb334dbc5d7e4654c5f95618230e" translate="yes" xml:space="preserve">
          <source>It is not possible to cancel timers that were created using the promisified variants of &lt;a href=&quot;timers#timers_setimmediate_callback_args&quot;&gt;&lt;code&gt;setImmediate()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;timers#timers_settimeout_callback_delay_args&quot;&gt;&lt;code&gt;setTimeout()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">약속 된 변형 &lt;a href=&quot;timers#timers_setimmediate_callback_args&quot;&gt; &lt;code&gt;setImmediate()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;timers#timers_settimeout_callback_delay_args&quot;&gt; &lt;code&gt;setTimeout()&lt;/code&gt; &lt;/a&gt; 사용하여 만든 타이머를 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e66357995a3753445dca09b779bcb4d762b0d211" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this option once a socket has been sent to a child with &lt;a href=&quot;child_process#child_process_child_process_fork_modulepath_args_options&quot;&gt;&lt;code&gt;child_process.fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;child_process#child_process_child_process_fork_modulepath_args_options&quot;&gt; &lt;code&gt;child_process.fork()&lt;/code&gt; &lt;/a&gt; 가있는 자식에게 소켓을 보낸 후에는이 옵션을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="11b99fc0673b66c9c42a80c4a0c35748194bd28e" translate="yes" xml:space="preserve">
          <source>It is often necessary to make the lifespan of handles shorter than the lifespan of a native method. For example, consider a native method that has a loop which iterates through the elements in a large array:</source>
          <target state="translated">핸들의 수명을 기본 메소드의 수명보다 짧게 만들어야하는 경우가 종종 있습니다. 예를 들어, 큰 배열에서 요소를 반복하는 루프가있는 기본 메소드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4c4c02784543cf811bfb3f1f2ca2f803b137643c" translate="yes" xml:space="preserve">
          <source>It is possible for Node.js to be built without including support for the &lt;code&gt;crypto&lt;/code&gt; module. In such cases, calling &lt;code&gt;require('crypto')&lt;/code&gt; will result in an error being thrown.</source>
          <target state="translated">&lt;code&gt;crypto&lt;/code&gt; 모듈에 대한 지원을 포함하지 않고도 Node.js를 빌드 할 수 있습니다 . 이러한 경우 &lt;code&gt;require('crypto')&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ec146a36358c16fe853764f44ebbd03ad1c100e" translate="yes" xml:space="preserve">
          <source>It is possible that no output is generated from any given chunk of input data.</source>
          <target state="translated">주어진 입력 데이터 덩어리에서 출력이 생성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041de057d4cce3b0afd146cbb127bf4a3b681c5a" translate="yes" xml:space="preserve">
          <source>It is possible to attach multiple &lt;code&gt;Writable&lt;/code&gt; streams to a single &lt;code&gt;Readable&lt;/code&gt; stream.</source>
          <target state="translated">여러 개의 &lt;code&gt;Writable&lt;/code&gt; &lt;code&gt;Readable&lt;/code&gt; 스트림을 단일 읽기 가능 스트림 에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d799d5874d270cd1edf1e65682d3d92bdbd761d" translate="yes" xml:space="preserve">
          <source>It is possible to create a new &lt;code&gt;Buffer&lt;/code&gt; that shares the same allocated memory as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt;&lt;code&gt;TypedArray&lt;/code&gt;&lt;/a&gt; instance by using the &lt;code&gt;TypedArray&lt;/code&gt; object's &lt;code&gt;.buffer&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;TypedArray&lt;/code&gt; 객체의 &lt;code&gt;.buffer&lt;/code&gt; 속성 을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&quot;&gt; &lt;code&gt;TypedArray&lt;/code&gt; &lt;/a&gt; 인스턴스 와 동일한 할당 메모리를 공유 하는 새 &lt;code&gt;Buffer&lt;/code&gt; 를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0425f8d11e929edaebd4ecd9966c15d540c99b06" translate="yes" xml:space="preserve">
          <source>It is possible to create and run multiple REPL instances against a single running instance of Node.js that share a single &lt;code&gt;global&lt;/code&gt; object but have separate I/O interfaces.</source>
          <target state="translated">단일 &lt;code&gt;global&lt;/code&gt; 객체 를 공유 하지만 별도의 I / O 인터페이스가 있는 Node.js의 단일 실행 인스턴스에 대해 여러 REPL 인스턴스를 작성하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aebe7a7a176eecea0791341611fe6bc21db870e1" translate="yes" xml:space="preserve">
          <source>It is possible to have type name collisions. Embedders are encouraged to use unique prefixes, such as the npm package name, to prevent collisions when listening to the hooks.</source>
          <target state="translated">유형 이름 충돌이있을 수 있습니다. 엠 베더는 후크를들을 때 충돌을 방지하기 위해 npm 패키지 이름과 같은 고유 한 접두사를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e6c6c312d474be31ba928b610b1f24972346fde4" translate="yes" xml:space="preserve">
          <source>It is possible to modify this object, but such modifications will not be reflected outside the Node.js process, or (unless explicitly requested) to other &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt; threads. In other words, the following example would not work:</source>
          <target state="translated">이 객체를 수정할 수는 있지만 그러한 수정은 Node.js 프로세스 외부에 반영되거나 명시 적으로 요청되지 않는 한 다른 &lt;a href=&quot;worker_threads#worker_threads_class_worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; 스레드에 반영되지 않습니다 . 즉, 다음 예제는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86565752a73577e2315e700600c3bf0c40a3f4fd" translate="yes" xml:space="preserve">
          <source>It is possible to require specific files or sub modules distributed with a module by including a path suffix after the module name. For instance &lt;code&gt;require('example-module/path/to/file')&lt;/code&gt; would resolve &lt;code&gt;path/to/file&lt;/code&gt; relative to where &lt;code&gt;example-module&lt;/code&gt; is located. The suffixed path follows the same module resolution semantics.</source>
          <target state="translated">모듈 이름 뒤에 경로 접미사를 포함시켜 특정 파일 또는 모듈과 함께 배포 된 하위 모듈을 요구할 수 있습니다. 예를 들어 &lt;code&gt;require('example-module/path/to/file')&lt;/code&gt; 은 &lt;code&gt;example-module&lt;/code&gt; 이있는 위치를 기준으로 &lt;code&gt;path/to/file&lt;/code&gt; 을 확인합니다 . 접미사 경로는 동일한 모듈 해상도 의미 체계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ba28385ee96435cb01e25cc4b9a932046f15c449" translate="yes" xml:space="preserve">
          <source>It is possible to use ES6 Arrow Functions as listeners, however, when doing so, the &lt;code&gt;this&lt;/code&gt; keyword will no longer reference the &lt;code&gt;EventEmitter&lt;/code&gt; instance:</source>
          <target state="translated">ES6 화살표 함수를 리스너로 사용할 수 있지만 그렇게하면 &lt;code&gt;this&lt;/code&gt; 키워드는 더 이상 &lt;code&gt;EventEmitter&lt;/code&gt; 인스턴스를 참조하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d50f1c65fac5502c9e1814ed3537ba4589771ab5" translate="yes" xml:space="preserve">
          <source>It is possible to watch expression and variable values while debugging. On every breakpoint, each expression from the watchers list will be evaluated in the current context and displayed immediately before the breakpoint's source code listing.</source>
          <target state="translated">디버깅하는 동안 표현식과 변수 값을 볼 수 있습니다. 모든 중단 점에서 감시자 목록의 각 표현식은 현재 컨텍스트에서 평가되어 중단 점의 소스 코드 목록 바로 앞에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a28d0af67f353f363a2876505349b3688d12dbd" translate="yes" xml:space="preserve">
          <source>It is recommended that errors occurring during the processing of the &lt;code&gt;readable._read()&lt;/code&gt; method are emitted using the &lt;code&gt;'error'&lt;/code&gt; event rather than being thrown. Throwing an &lt;code&gt;Error&lt;/code&gt; from within &lt;code&gt;readable._read()&lt;/code&gt; can result in unexpected and inconsistent behavior depending on whether the stream is operating in flowing or paused mode. Using the &lt;code&gt;'error'&lt;/code&gt; event ensures consistent and predictable handling of errors.</source>
          <target state="translated">&lt;code&gt;readable._read()&lt;/code&gt; 메소드를 처리하는 동안 발생하는 오류는 발생 하지 않고 &lt;code&gt;'error'&lt;/code&gt; 이벤트를 사용하여 생성하는 것이 좋습니다. &lt;code&gt;readable._read()&lt;/code&gt; 내 에서 &lt;code&gt;Error&lt;/code&gt; 를 발생 시키면 스트림이 흐름 모드 또는 일시 중지 모드에서 작동하는지에 따라 예기치 않은 동작이 발생할 수 있습니다. 은 Using &lt;code&gt;'error'&lt;/code&gt; 이벤트 것은 오류의 일관되고 예측 처리를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a056961ff3bdb7c76c478689117c030d14d553dd" translate="yes" xml:space="preserve">
          <source>It is recommended that errors occurring during the processing of the &lt;code&gt;writable._write()&lt;/code&gt; and &lt;code&gt;writable._writev()&lt;/code&gt; methods are reported by invoking the callback and passing the error as the first argument. This will cause an &lt;code&gt;'error'&lt;/code&gt; event to be emitted by the &lt;code&gt;Writable&lt;/code&gt;. Throwing an &lt;code&gt;Error&lt;/code&gt; from within &lt;code&gt;writable._write()&lt;/code&gt; can result in unexpected and inconsistent behavior depending on how the stream is being used. Using the callback ensures consistent and predictable handling of errors.</source>
          <target state="translated">콜백을 호출하고 오류를 첫 번째 인수로 전달하여 &lt;code&gt;writable._write()&lt;/code&gt; 및 &lt;code&gt;writable._writev()&lt;/code&gt; 메소드를 처리하는 동안 발생하는 오류를보고하는 것이 좋습니다 . 이것은 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 &lt;code&gt;Writable&lt;/code&gt; 에 의해 생성됩니다 . &lt;code&gt;writable._write()&lt;/code&gt; 내 에서 &lt;code&gt;Error&lt;/code&gt; 를 발생 시키면 스트림 사용 방법에 따라 예기치 않은 동작이 발생할 수 있습니다. 콜백을 사용하면 일관되고 예측 가능한 오류 처리가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="ea16402f95d8daded063cf513af19663455d8c99" translate="yes" xml:space="preserve">
          <source>It is recommended to encode public keys as &lt;code&gt;'spki'&lt;/code&gt; and private keys as &lt;code&gt;'pkcs8'&lt;/code&gt; with encryption for long-term storage:</source>
          <target state="translated">장기 저장을위한 암호화를 사용하여 공개 키를 &lt;code&gt;'spki'&lt;/code&gt; 로 , 개인 키를 &lt;code&gt;'pkcs8'&lt;/code&gt; 로 인코딩하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="be30c74885508dee4aa59c7f4ed4177d22aed095" translate="yes" xml:space="preserve">
          <source>It is required that &lt;code&gt;byte_length + byte_offset&lt;/code&gt; is less than or equal to the size in bytes of the array passed in. If not, a &lt;code&gt;RangeError&lt;/code&gt; exception is raised.</source>
          <target state="translated">는 것이 요구된다 &lt;code&gt;byte_length + byte_offset&lt;/code&gt; 전달 어레이의 바이트 크기 이하인 것이다.하는 그렇지 않으면 &lt;code&gt;RangeError&lt;/code&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="22b0f46e9ce955411b0e5f9b89cbb8973cf2da94" translate="yes" xml:space="preserve">
          <source>It is still possible to use &lt;code&gt;fs.watchFile()&lt;/code&gt;, which uses stat polling, but this method is slower and less reliable.</source>
          <target state="translated">통계 폴링 을 사용하는 &lt;code&gt;fs.watchFile()&lt;/code&gt; 을 계속 사용할 수 있지만이 방법은 느리고 신뢰성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="139b9846793e9d67315fbc1333aef413751a7253" translate="yes" xml:space="preserve">
          <source>It is strongly encouraged to place dependencies in the local &lt;code&gt;node_modules&lt;/code&gt; folder. These will be loaded faster, and more reliably.</source>
          <target state="translated">지역에 의존하는 것이 좋습니다 &lt;code&gt;node_modules&lt;/code&gt; 폴더에 . 이들은보다 빠르고 안정적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c57e947162fc04e3a4c5011c7abce4b05a307aa0" translate="yes" xml:space="preserve">
          <source>It is unsafe to call &lt;code&gt;writev()&lt;/code&gt; multiple times on the same file without waiting for the previous operation to complete.</source>
          <target state="translated">전화하는 것은 안전하지 않습니다 &lt;code&gt;writev()&lt;/code&gt; 이전 작업이 완료 될 때까지 기다리지 않고 동일한 파일에서 writev ()를 여러 번 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a074961b126d1ed61535ab8ccf81ae46b4f5b8c" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;filehandle.write()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected). For this scenario, use &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 때까지 기다리지 않고 동일한 파일에서 &lt;code&gt;filehandle.write()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다 . 이 시나리오에서는&lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa06e1e67ec61d886012a5ebbf346afac1c50178" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;filehandle.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected).</source>
          <target state="translated">동일한 파일에서 &lt;code&gt;filehandle.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. &lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 .</target>
        </trans-unit>
        <trans-unit id="327d5849595d0b2d3af0390f737024885e0b74a4" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.write()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt; is recommended.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.write()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는 &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; 이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3527578258e75386e719cb61809fc94de47660" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt; is recommended.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는&lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; 이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd51ed95a8e7ff9d29a46cc5b594661dab21ee9" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fs.writev()&lt;/code&gt; multiple times on the same file without waiting for the callback. For this scenario, use &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt;&lt;code&gt;fs.createWriteStream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">콜백을 기다리지 않고 동일한 파일에서 &lt;code&gt;fs.writev()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. 이 시나리오에서는 &lt;a href=&quot;#fs_fs_createwritestream_path_options&quot;&gt; &lt;code&gt;fs.createWriteStream()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e32bdefd256d2a24661a921234ae0d689962bf7c" translate="yes" xml:space="preserve">
          <source>It is unsafe to use &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; multiple times on the same file without waiting for the &lt;code&gt;Promise&lt;/code&gt; to be resolved (or rejected).</source>
          <target state="translated">동일한 파일에서 &lt;code&gt;fsPromises.writeFile()&lt;/code&gt; 여러 번 사용하는 것은 안전하지 않습니다. &lt;code&gt;Promise&lt;/code&gt; 가 해결 (또는 거부) 될 .</target>
        </trans-unit>
        <trans-unit id="8e339f1709056e0ab06d967b94bed7dafd547b83" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to do this. However, if using an agent with &lt;code&gt;keepAlive&lt;/code&gt; enabled, then it is best to explicitly shut down the agent when it will no longer be used. Otherwise, sockets may hang open for quite a long time before the server terminates them.</source>
          <target state="translated">일반적으로이 작업을 수행 할 필요는 없습니다. 그러나 에이전트를 &lt;code&gt;keepAlive&lt;/code&gt; 가 활성화 에이전트가 더 이상 사용되지 않을 때 명시 적으로 종료하는 것이 가장 좋습니다. 그렇지 않으면 서버가 소켓을 종료하기 전에 소켓이 꽤 오랫동안 열려있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588053c04448ff48f8bf959f153ee214ac140018" translate="yes" xml:space="preserve">
          <source>It is very important for APIs to be either 100% synchronous or 100% asynchronous. Consider this example:</source>
          <target state="translated">API가 100 % 동기식이거나 100 % 비동기식이어야합니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0324495de22e85e0d134839d942c3962300cbac5" translate="yes" xml:space="preserve">
          <source>It keeps top-level variables (defined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;) scoped to the module rather than the global object.</source>
          <target state="translated">전역 변수가 아닌 모듈에 범위가 지정된 최상위 변수 ( &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 으로 정의 됨)를 유지 합니다.</target>
        </trans-unit>
        <trans-unit id="83e75e459c92e28df79b2b636a0f41ab57292e39" translate="yes" xml:space="preserve">
          <source>It may be useful for debugging.</source>
          <target state="translated">디버깅에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d4c4a6b07ad03b9db87fefb27c47016dd56d4f" translate="yes" xml:space="preserve">
          <source>It must belong to the same context as the parent &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">상위 &lt;code&gt;Module&lt;/code&gt; 과 동일한 컨텍스트에 속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="389a01fac4a0ef708ee83106d03f5176a5d0807c" translate="yes" xml:space="preserve">
          <source>It performs the inverse operation to &lt;a href=&quot;#url_url_domaintoascii_domain&quot;&gt;&lt;code&gt;url.domainToASCII()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#url_url_domaintoascii_domain&quot;&gt; &lt;code&gt;url.domainToASCII()&lt;/code&gt; &lt;/a&gt; 대한 역 연산을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="e1f3dc61a93c5fe87d9de7e00282a1c8432614fc" translate="yes" xml:space="preserve">
          <source>It performs the inverse operation to &lt;a href=&quot;#url_url_domaintounicode_domain&quot;&gt;&lt;code&gt;url.domainToUnicode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#url_url_domaintounicode_domain&quot;&gt; &lt;code&gt;url.domainToUnicode()&lt;/code&gt; &lt;/a&gt; 대한 역 연산을 수행합니다. .</target>
        </trans-unit>
        <trans-unit id="16ec379b732d9cc8bb302ba29e2ef8af384a9552" translate="yes" xml:space="preserve">
          <source>It serializes the following types of values passed in &lt;code&gt;obj&lt;/code&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;number[]&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;boolean[]&amp;gt;&lt;/a&gt; Any other input values will be coerced to empty strings.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 전달 된 다음 유형의 값을 직렬화합니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;string&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;번호&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;부울&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type&quot;&gt;&amp;lt;문자열 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type&quot;&gt;&amp;lt;숫자 []&amp;gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type&quot;&gt;&amp;lt;부울 []&amp;gt;&lt;/a&gt; 다른 입력 값은 빈 문자열로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="55a4bb7259c84af569c9b2e4d90c56c3c0ed3ef3" translate="yes" xml:space="preserve">
          <source>It will rarely be necessary to use &lt;code&gt;readable.wrap()&lt;/code&gt; but the method has been provided as a convenience for interacting with older Node.js applications and libraries.</source>
          <target state="translated">&lt;code&gt;readable.wrap()&lt;/code&gt; 을 사용할 필요는 거의 없습니다. 없지만 이전 Node.js 애플리케이션 및 라이브러리와의 상호 작용을위한 편의를 위해 메소드가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="1d542fd12f985c8768fbe8ead6923a0d00b50f32" translate="yes" xml:space="preserve">
          <source>It's required that &lt;code&gt;(length * size_of_element) + byte_offset&lt;/code&gt; should be &amp;lt;= the size in bytes of the array passed in. If not, a &lt;code&gt;RangeError&lt;/code&gt; exception is raised.</source>
          <target state="translated">그것은 필요하다는 사실 &lt;code&gt;(length * size_of_element) + byte_offset&lt;/code&gt; = 전달 된 배열의 크기 (바이트). &amp;lt;될 아니라면하는한다 &lt;code&gt;RangeError&lt;/code&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="42a3b56cedfed26ace470da3c86678970122c99f" translate="yes" xml:space="preserve">
          <source>Iterates over each name-value pair in the query and invokes the given function.</source>
          <target state="translated">쿼리에서 각 이름-값 쌍을 반복하고 지정된 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8b0eca1e364367b12a698606c4b171ea9cc0b251" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;linkingStatus&lt;/code&gt; must not be &lt;code&gt;'errored'&lt;/code&gt;.</source>
          <target state="translated">연결 상태 가 &lt;code&gt;'errored'&lt;/code&gt; &lt;code&gt;linkingStatus&lt;/code&gt; 는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="56643b463dc4ce55950dfcbbef495be7564e51fe" translate="yes" xml:space="preserve">
          <source>Its possible to get the ticket keys by calling &lt;a href=&quot;#tls_server_getticketkeys&quot;&gt;&lt;code&gt;server.getTicketKeys()&lt;/code&gt;&lt;/a&gt; on one server instance and then distribute them, but it is more reasonable to securely generate 48 bytes of secure random data and set them with the &lt;code&gt;ticketKeys&lt;/code&gt; option of &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt;&lt;code&gt;tls.createServer()&lt;/code&gt;&lt;/a&gt;. The keys should be regularly regenerated and server's keys can be reset with &lt;a href=&quot;#tls_server_setticketkeys_keys&quot;&gt;&lt;code&gt;server.setTicketKeys()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 서버 인스턴스에서 &lt;a href=&quot;#tls_server_getticketkeys&quot;&gt; &lt;code&gt;server.getTicketKeys()&lt;/code&gt; &lt;/a&gt; 를 호출하여 티켓 키를 가져 와서 분배 할 수 있지만 48 바이트의 보안 임의 데이터를 안전하게 생성하고 &lt;a href=&quot;#tls_tls_createserver_options_secureconnectionlistener&quot;&gt; &lt;code&gt;tls.createServer()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;ticketKeys&lt;/code&gt; 옵션으로 설정하는 것이 더 합리적 입니다. . 키는 정기적으로 재생성되어야하며 &lt;a href=&quot;#tls_server_setticketkeys_keys&quot;&gt; &lt;code&gt;server.setTicketKeys()&lt;/code&gt; &lt;/a&gt; 하여 서버 키를 재설정 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="d96b84d8240a01cb379b56b8ddafa735704cf6dc" translate="yes" xml:space="preserve">
          <source>JSON Modules</source>
          <target state="translated">JSON 모듈</target>
        </trans-unit>
        <trans-unit id="d99d73b448c0f1ffea6212a90bfd357cad49d279" translate="yes" xml:space="preserve">
          <source>JSON fetching example:</source>
          <target state="translated">JSON 가져 오기 예 :</target>
        </trans-unit>
        <trans-unit id="f7b9a43a2017f679eee5493180c26ed2f1e85185" translate="yes" xml:space="preserve">
          <source>JSON modules follow the &lt;a href=&quot;https://html.spec.whatwg.org/#creating-a-json-module-script&quot;&gt;WHATWG JSON modules specification&lt;/a&gt;.</source>
          <target state="translated">JSON 모듈은 &lt;a href=&quot;https://html.spec.whatwg.org/#creating-a-json-module-script&quot;&gt;WHATWG JSON 모듈 사양을&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="be23b85acb18166e5a08c5600a8d19dd96e42e39" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;Section 24.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;24.1 섹션&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="719a95a4bd9cf0b14d2f00175d73f2e6d748c5c3" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt;s are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;Section 24.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;ArrayBuffer&lt;/code&gt; 에 대해서는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-arraybuffer-objects&quot;&gt;24.1 섹션&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c8a0f0228ff639ea0dc5a1ba127ae8157e21154" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;DataView&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-dataview-objects&quot;&gt;Section 24.3&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;DataView&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-dataview-objects&quot;&gt;24.3 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b1277ef9e321fb8f47bd20f93e6f1911ecebefc" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Date&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-date-objects&quot;&gt;Section 20.3&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;Date&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-date-objects&quot;&gt;20.3 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4939241f55942c05d559f3a5b9a7e5d692c058d3" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;Function&lt;/code&gt;s are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function-objects&quot;&gt;Section 19.2&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;Function&lt;/code&gt; 는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function-objects&quot;&gt;섹션 19.2&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9060b350cc54a90664674036d8765a0574ec82" translate="yes" xml:space="preserve">
          <source>JavaScript &lt;code&gt;TypedArray&lt;/code&gt; objects are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-typedarray-objects&quot;&gt;Section 22.2&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript &lt;code&gt;TypedArray&lt;/code&gt; 객체는 ECMAScript 언어 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-typedarray-objects&quot;&gt;22.2 단원&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="52cad7d4c62e41b12e029e3a1056b734751ff955" translate="yes" xml:space="preserve">
          <source>JavaScript Embedder API</source>
          <target state="translated">자바 스크립트 Embedder API</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="translated">자바 스크립트 표현식</target>
        </trans-unit>
        <trans-unit id="0c87a0c72e80e2b3ed246c907f512dd6657150a6" translate="yes" xml:space="preserve">
          <source>JavaScript arrays are described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array-objects&quot;&gt;Section 22.1&lt;/a&gt; of the ECMAScript Language Specification.</source>
          <target state="translated">JavaScript 배열은 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array-objects&quot;&gt;섹션 22.1에&lt;/a&gt; 설명되어 있습니다. ECMAScript 언어 사양 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41362f31a71042ce6d33522241a4d37c00acbcd3" translate="yes" xml:space="preserve">
          <source>JavaScript cannot encode 64-bit integers. This method is intended for working with 64-bit floats.</source>
          <target state="translated">JavaScript는 64 비트 정수를 인코딩 할 수 없습니다. 이 방법은 64 비트 플로트 작업을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cec7f745469211f8ad0113b8267b2dbc38c96dca" translate="yes" xml:space="preserve">
          <source>JavaScript code can be compiled and run immediately or compiled, saved, and run later.</source>
          <target state="translated">JavaScript 코드는 즉시 컴파일 및 실행하거나 컴파일, 저장 및 나중에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c23bb655ecc1d108ac1670bce1574ac9c38369" translate="yes" xml:space="preserve">
          <source>JavaScript functions can normally only be called from a native addon's main thread. If an addon creates additional threads, then N-API functions that require a &lt;code&gt;napi_env&lt;/code&gt;, &lt;code&gt;napi_value&lt;/code&gt;, or &lt;code&gt;napi_ref&lt;/code&gt; must not be called from those threads.</source>
          <target state="translated">JavaScript 함수는 일반적으로 기본 애드온의 메인 스레드에서만 호출 할 수 있습니다. 애드온이 추가 스레드를 작성하는 경우 해당 스레드에서 &lt;code&gt;napi_env&lt;/code&gt; , &lt;code&gt;napi_value&lt;/code&gt; 또는 &lt;code&gt;napi_ref&lt;/code&gt; 가 필요한 N-API 함수를 호출 하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f37b66a76531faf963b06cfaf86c9ef0c5a880f1" translate="yes" xml:space="preserve">
          <source>JavaScript string escaping requires paths to be specified with extra backslash escaping such as:</source>
          <target state="translated">JavaScript 문자열 이스케이프를 수행하려면 다음과 같은 추가 백 슬래시 이스케이프를 사용하여 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e07413b34ffd366886a0fb40b6c95efba1be0d7" translate="yes" xml:space="preserve">
          <source>JavaScript value: these are represented in N-API by &lt;code&gt;napi_value&lt;/code&gt;. This can be a &lt;code&gt;napi_value&lt;/code&gt; representing a &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, or &lt;code&gt;Symbol&lt;/code&gt;.</source>
          <target state="translated">JavaScript 값 : 이들은 N-API에서 &lt;code&gt;napi_value&lt;/code&gt; 로 표시 됩니다. &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; 또는 &lt;code&gt;Symbol&lt;/code&gt; 을 나타내는 &lt;code&gt;napi_value&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a71118cb899549ef60707eb4c7093a6139cf8e2" translate="yes" xml:space="preserve">
          <source>Key events in the lifetime of asynchronous events have been categorized into four areas: instantiation, before/after the callback is called, and when the instance is destroyed.</source>
          <target state="translated">비동기 이벤트 수명의 주요 이벤트는 인스턴스화, 콜백 이전 / 이후 및 인스턴스가 소멸되는 4 가지 영역으로 분류되었습니다.</target>
        </trans-unit>
        <trans-unit id="42fd293e6b52b92ee891b25260a8dcb7640476d7" translate="yes" xml:space="preserve">
          <source>Key-value pairs of header names and values. Header names are lower-cased.</source>
          <target state="translated">헤더 이름과 값의 키-값 쌍. 헤더 이름은 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="0219bac0488bb0b49dd2dc78aa3d21e7f7786afc" translate="yes" xml:space="preserve">
          <source>KeyObject</source>
          <target state="translated">KeyObject</target>
        </trans-unit>
        <trans-unit id="90247e04a9ab9c31144526b27a99cafa47c9ed23" translate="yes" xml:space="preserve">
          <source>Keys are lowercased. Values are not modified.</source>
          <target state="translated">키는 소문자입니다. 값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be4d0497bc308dc68e2b86f9d700c936ee0973b7" translate="yes" xml:space="preserve">
          <source>Launching Node.js using the &lt;code&gt;--throw-deprecation&lt;/code&gt; command line flag will cause custom deprecation warnings to be thrown as exceptions.</source>
          <target state="translated">&lt;code&gt;--throw-deprecation&lt;/code&gt; 명령 줄 플래그를 사용하여 Node.js를 시작 하면 사용자 지정 지원 중단 경고가 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3dcbad204095230ea14447be64d133cef03f50d2" translate="yes" xml:space="preserve">
          <source>Launching the Node.js process as:</source>
          <target state="translated">Node.js 프로세스를 다음과 같이 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="bc8751555a3239b7dac027ac31b93be45c7a72a5" translate="yes" xml:space="preserve">
          <source>Legacy &lt;code&gt;urlObject&lt;/code&gt;</source>
          <target state="translated">기존 &lt;code&gt;urlObject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">레거시 API</target>
        </trans-unit>
        <trans-unit id="fff0473a6005f02c6ee988eeea5c4589c0cee01e" translate="yes" xml:space="preserve">
          <source>Legacy Node.js Error Codes</source>
          <target state="translated">레거시 Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="2c20dd0e85aff7e0a43472ec0bd080ec8d34d100" translate="yes" xml:space="preserve">
          <source>Legacy Streams API (pre Node.js v0.10)</source>
          <target state="translated">레거시 스트림 API (Pre Node.js v0.10)</target>
        </trans-unit>
        <trans-unit id="c20be4f6f706ee94b9055b8d2bb127f7bf2f5336" translate="yes" xml:space="preserve">
          <source>Legacy URL API</source>
          <target state="translated">레거시 URL API</target>
        </trans-unit>
        <trans-unit id="d5edbf5c71f5ce411aa5b2426065109df221ad37" translate="yes" xml:space="preserve">
          <source>Legacy mode</source>
          <target state="translated">레거시 모드</target>
        </trans-unit>
        <trans-unit id="cd1cabfb965ba7b42cb732ed586da70b61d4573f" translate="yes" xml:space="preserve">
          <source>Legacy mode uses the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;Abstract Equality Comparison&lt;/a&gt; in:</source>
          <target state="translated">레거시 모드는 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-equality-comparison&quot;&gt;추상 평등 비교를&lt;/a&gt; 사용합니다 를 .</target>
        </trans-unit>
        <trans-unit id="461cb9806496bebf38f62add29762de4f9878b5d" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;directoryKeys&lt;/em&gt; be the list of keys of &lt;em&gt;exports&lt;/em&gt; ending in &lt;em&gt;&quot;/&quot;&lt;/em&gt;, sorted by length descending.</source>
          <target state="translated">하자 &lt;em&gt;directoryKeys이&lt;/em&gt; 의 키 목록이 될 &lt;em&gt;수출&lt;/em&gt; 로 끝나는 &lt;em&gt;&quot;/&quot;&lt;/em&gt; , 길이 내림차순으로 분류.</target>
        </trans-unit>
        <trans-unit id="ed43a3cca8d0829c50efa33ad8a1735744b22695" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;exports&lt;/em&gt; be &lt;em&gt;pjson.exports&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;수출&lt;/em&gt; 될 &lt;em&gt;pjson.exports&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1edf85bc7e8552161c136541aa74c4bb663ae6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;format&lt;/em&gt; be the result of &lt;strong&gt;ESM_FORMAT&lt;/strong&gt;(&lt;em&gt;resolvedURL&lt;/em&gt;, &lt;em&gt;isMain&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;형식&lt;/em&gt; 의 결과 &lt;strong&gt;ESM_FORMAT&lt;/strong&gt; ( &lt;em&gt;resolvedURL&lt;/em&gt; , &lt;em&gt;isMain&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e2049abb9ba314181946c48daedfb30d6cac2d4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;legacyMainURL&lt;/em&gt; be the result applying the legacy &lt;strong&gt;LOAD_AS_DIRECTORY&lt;/strong&gt; CommonJS resolver to &lt;em&gt;packageURL&lt;/em&gt;, throwing a &lt;em&gt;Module Not Found&lt;/em&gt; error for no resolution.</source>
          <target state="translated">하자 &lt;em&gt;legacyMainURL는&lt;/em&gt; 기존 적용한 결과 일 수 &lt;strong&gt;LOAD_AS_DIRECTORY&lt;/strong&gt; 에 CommonJS의 해결을 &lt;em&gt;PACKAGEURL&lt;/em&gt; 던지는, &lt;em&gt;모듈을 찾을 수 없습니다&lt;/em&gt; 어떤 해결을 위해 오류입니다.</target>
        </trans-unit>
        <trans-unit id="382b20b41c3fc6df5c3fd1360c69bcd4bdb1e7b4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageName&lt;/em&gt; be &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;여기서 packageName이&lt;/em&gt; 될 &lt;em&gt;정의되지&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2d816a69a606558435c2f7bf214574701cee0921" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageSubpath&lt;/em&gt; be &lt;em&gt;undefined&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;packageSubpath이&lt;/em&gt; 될 &lt;em&gt;정의되지&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3879a2c60ae8d9f31de4e2f2d3064c3f0a2e8df0" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;packageURL&lt;/em&gt; be the URL resolution of &lt;em&gt;&quot;node_modules/&quot;&lt;/em&gt; concatenated with &lt;em&gt;packageSpecifier&lt;/em&gt;, relative to &lt;em&gt;parentURL&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;PACKAGEURL가&lt;/em&gt; 의 URL의 해상도는 &lt;em&gt;&quot;node_modules /&quot;&lt;/em&gt; 와 연결 &lt;em&gt;packageSpecifier&lt;/em&gt; 을 기준으로, &lt;em&gt;parentURL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7e82e8cf4cd3d2806cefa31d11b42457fe816e03" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt;(&lt;em&gt;packageURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd3c96f5f0c598b9a6ae47e36bce4121bbd96e8" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt;(&lt;em&gt;scopeURL&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_JSON&lt;/strong&gt; ( &lt;em&gt;scopeURL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="f236242b656b209b4a987cbd649a5c634a38f6f6" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjson&lt;/em&gt; be the result of &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt;(&lt;em&gt;url&lt;/em&gt;).</source>
          <target state="translated">하자 &lt;em&gt;pjson이&lt;/em&gt; 의 결과 &lt;strong&gt;READ_PACKAGE_SCOPE&lt;/strong&gt; ( &lt;em&gt;URL&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7efdf0ad8c2e8e15cf9c24ae647213041bbfe4d" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;pjsonURL&lt;/em&gt; be the resolution of &lt;em&gt;&quot;package.json&quot;&lt;/em&gt; within &lt;em&gt;packageURL&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;pjsonURL이&lt;/em&gt; 의 해상도는 &lt;em&gt;&quot;package.json&quot;&lt;/em&gt; 내 &lt;em&gt;PACKAGEURL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e85c83e3ea0b6dee0e7b7a3595ed1051fc6f538" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the URL resolution of the concatenation of &lt;em&gt;subpath&lt;/em&gt; and &lt;em&gt;resolvedTarget&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;subpath&lt;/em&gt; 와 &lt;em&gt;resolvedTarget&lt;/em&gt; 의 연결에 대한 URL 확인을 &lt;em&gt;해결&lt;/em&gt; 하자 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e2ee789e16379e2ecc056e36d8d03d2ab18d4c4" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolved&lt;/em&gt; be the result of &lt;strong&gt;PACKAGE_EXPORTS_TARGET_RESOLVE&lt;/strong&gt;(&lt;em&gt;packageURL&lt;/em&gt;, &lt;em&gt;targetValue&lt;/em&gt;, &lt;em&gt;subpath&lt;/em&gt;), continuing the loop on abrupt completion.</source>
          <target state="translated">하자 &lt;em&gt;해결&lt;/em&gt; 의 결과 &lt;strong&gt;PACKAGE_EXPORTS_TARGET_RESOLVE&lt;/strong&gt; ( &lt;em&gt;PACKAGEURL&lt;/em&gt; , &lt;em&gt;targetValue&lt;/em&gt; , &lt;em&gt;서브 패스&lt;/em&gt; ) 갑작스러운 완료에 루프를 계속.</target>
        </trans-unit>
        <trans-unit id="79e52620ed2cc63ebf756b6791942858e8a11582" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedMain&lt;/em&gt; be the URL resolution of &lt;em&gt;packageURL&lt;/em&gt;, &quot;/&quot;, and &lt;em&gt;pjson.main&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedMain가&lt;/em&gt; 의 URL의 해상도는 &lt;em&gt;PACKAGEURL&lt;/em&gt; , &quot;/&quot;, 및 &lt;em&gt;pjson.main&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff7aedeb5d501d6e47d5396e51dcb3bb302bb04" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedTarget&lt;/em&gt; be the URL resolution of the concatenation of &lt;em&gt;packageURL&lt;/em&gt; and &lt;em&gt;target&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedTarget이&lt;/em&gt; 의 연결의 URL의 해상도는 &lt;em&gt;PACKAGEURL&lt;/em&gt; 및 &lt;em&gt;대상&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5df506eb548277050de9692d3004f4e6b5b2aa9c" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;resolvedURL&lt;/em&gt; be &lt;strong&gt;undefined&lt;/strong&gt;.</source>
          <target state="translated">하자 &lt;em&gt;resolvedURL이&lt;/em&gt; 될 &lt;strong&gt;정의되지&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="82a293d31acbcb53e85a6f620e95bc60fec4dd62" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;scopeURL&lt;/em&gt; be &lt;em&gt;url&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; scopeURL가&lt;/em&gt; 될 &lt;em&gt;URL&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e7dfbc5cc254de35a61a79580bcfc017d43a648a" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;subpath&lt;/em&gt; be the substring of &lt;em&gt;target&lt;/em&gt; starting at the index of the length of &lt;em&gt;directory&lt;/em&gt;.</source>
          <target state="translated">하자 &lt;em&gt;서브 패스가&lt;/em&gt; 의 문자열을 수&lt;em&gt; 목표&lt;/em&gt; 의 길이의 인덱스로 시작되는 &lt;em&gt;디렉토리&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce6d12ce9449fc911cc9f55c4eb8f68b7cd7887" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;exports[directory]&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; 대상&lt;/em&gt; 의 값이 &lt;em&gt;수출 [디렉토리]&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="197f5bec0ba9b0be792276cfd7d785ccdea0317a" translate="yes" xml:space="preserve">
          <source>Let &lt;em&gt;target&lt;/em&gt; be the value of &lt;em&gt;exports[packagePath]&lt;/em&gt;.</source>
          <target state="translated">허락하다 &lt;em&gt; 표적&lt;/em&gt; 의 값 &lt;em&gt;[packagePath를] 수출&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c05022795ff4fc80ccdb0eaa2b31a46cf687fbad" translate="yes" xml:space="preserve">
          <source>Let's say that we wanted to have the folder at &lt;code&gt;/usr/lib/node/&amp;lt;some-package&amp;gt;/&amp;lt;some-version&amp;gt;&lt;/code&gt; hold the contents of a specific version of a package.</source>
          <target state="translated">&lt;code&gt;/usr/lib/node/&amp;lt;some-package&amp;gt;/&amp;lt;some-version&amp;gt;&lt;/code&gt; 에 있는 폴더 가 특정 버전의 패키지 내용을 보유하고 싶다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="494a09f021c47478da7edc0019571233304558a0" translate="yes" xml:space="preserve">
          <source>Library developers that handle their own asynchronous resources performing tasks like I/O, connection pooling, or managing callback queues may use the &lt;code&gt;AsyncWrap&lt;/code&gt; JavaScript API so that all the appropriate callbacks are called.</source>
          <target state="translated">I / O, 연결 풀링 또는 콜백 대기열 관리와 같은 작업을 수행하는 자체 비동기 리소스를 처리하는 라이브러리 개발자는 &lt;code&gt;AsyncWrap&lt;/code&gt; 을 JavaScript API를 모든 적절한 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ca7e018936674f1d60758637269700311826fef" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#fs_class_fs_readstream&quot;&gt;&lt;code&gt;ReadStream&lt;/code&gt;&lt;/a&gt;, if &lt;code&gt;fd&lt;/code&gt; is specified, &lt;a href=&quot;#fs_class_fs_writestream&quot;&gt;&lt;code&gt;WriteStream&lt;/code&gt;&lt;/a&gt; will ignore the &lt;code&gt;path&lt;/code&gt; argument and will use the specified file descriptor. This means that no &lt;code&gt;'open'&lt;/code&gt; event will be emitted. &lt;code&gt;fd&lt;/code&gt; should be blocking; non-blocking &lt;code&gt;fd&lt;/code&gt;s should be passed to &lt;a href=&quot;net#net_class_net_socket&quot;&gt;&lt;code&gt;net.Socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#fs_class_fs_readstream&quot;&gt; &lt;code&gt;ReadStream&lt;/code&gt; &lt;/a&gt; 경우, &lt;code&gt;fd&lt;/code&gt; 지정되어, &lt;a href=&quot;#fs_class_fs_writestream&quot;&gt; &lt;code&gt;WriteStream&lt;/code&gt; 는&lt;/a&gt; 무시됩니다 &lt;code&gt;path&lt;/code&gt; 인수를 지정된 파일 기술자를 사용합니다. 이것은 &lt;code&gt;'open'&lt;/code&gt; 이벤트가 발생 하지 않음을 의미합니다 . &lt;code&gt;fd&lt;/code&gt; 는 차단해야합니다. 비 차단 &lt;code&gt;fd&lt;/code&gt; 는&lt;a href=&quot;net#net_class_net_socket&quot;&gt; &lt;code&gt;net.Socket&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="851f0f8a8001316f6429280c11651db02e375ab1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;http#http_http_get_options_callback&quot;&gt;&lt;code&gt;http.get()&lt;/code&gt;&lt;/a&gt; but for HTTPS.</source>
          <target state="translated">처럼 &lt;a href=&quot;http#http_http_get_options_callback&quot;&gt; &lt;code&gt;http.get()&lt;/code&gt; &lt;/a&gt; 하지만 HTTPS 용입니다.</target>
        </trans-unit>
        <trans-unit id="643276916be86da834620569b341d9177bff2e84" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Workers&lt;/a&gt; and the &lt;a href=&quot;cluster&quot;&gt;&lt;code&gt;cluster&lt;/code&gt; module&lt;/a&gt;, two-way communication can be achieved through inter-thread message passing. Internally, a &lt;code&gt;Worker&lt;/code&gt; has a built-in pair of &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt;&lt;code&gt;MessagePort&lt;/code&gt;&lt;/a&gt;s that are already associated with each other when the &lt;code&gt;Worker&lt;/code&gt; is created. While the &lt;code&gt;MessagePort&lt;/code&gt; object on the parent side is not directly exposed, its functionalities are exposed through &lt;a href=&quot;#worker_threads_worker_postmessage_value_transferlist&quot;&gt;&lt;code&gt;worker.postMessage()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;#worker_threads_event_message_1&quot;&gt;&lt;code&gt;worker.on('message')&lt;/code&gt;&lt;/a&gt; event on the &lt;code&gt;Worker&lt;/code&gt; object for the parent thread.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 &lt;a href=&quot;cluster&quot;&gt; &lt;code&gt;cluster&lt;/code&gt; 모듈&lt;/a&gt; 과 마찬가지로 스레드 간 메시지 전달을 통해 양방향 통신을 수행 할 수 있습니다. 내부적으로 &lt;code&gt;Worker&lt;/code&gt; 에는 &lt;code&gt;Worker&lt;/code&gt; 가 만들어 질 때 이미 서로 연결된 &lt;a href=&quot;#worker_threads_class_messageport&quot;&gt; &lt;code&gt;MessagePort&lt;/code&gt; &lt;/a&gt; 쌍이 내장되어 있습니다. 부모 측 의 &lt;code&gt;MessagePort&lt;/code&gt; 객체는 직접 노출되지 않지만 그 기능은 &lt;a href=&quot;#worker_threads_worker_postmessage_value_transferlist&quot;&gt; &lt;code&gt;worker.postMessage()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#worker_threads_event_message_1&quot;&gt; &lt;code&gt;worker.on('message')&lt;/code&gt; &lt;/a&gt; 이벤트 를 통해 부모 스레드 의 &lt;code&gt;Worker&lt;/code&gt; 객체에서 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dbd9c14005cc13742bdf9a1be2f6cfdb9bd756e" translate="yes" xml:space="preserve">
          <source>Like in CommonJS, files within packages can be accessed by appending a path to the package name.</source>
          <target state="translated">CommonJS와 마찬가지로 패키지 이름에 경로를 추가하여 패키지 내의 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b5a42854b5eed52a170023a09f02fc6d959468" translate="yes" xml:space="preserve">
          <source>Likewise, changing from a non-special protocol to a special protocol is also not permitted:</source>
          <target state="translated">마찬가지로 비 특수 프로토콜에서 특수 프로토콜로 변경하는 것도 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06dd6783b6493064f30b8f1541b693a42e5ccd3c" translate="yes" xml:space="preserve">
          <source>Limit engine usage to CIPHERS</source>
          <target state="translated">CIPHERS로 엔진 사용 제한</target>
        </trans-unit>
        <trans-unit id="93986208e144b83e2c97be29664bbada85c8e0bd" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DH</source>
          <target state="translated">엔진 사용을 DH로 제한</target>
        </trans-unit>
        <trans-unit id="9f5015c701e9eb1d4dc682b1335a18b14503b0f5" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DIGESTS</source>
          <target state="translated">엔진 사용을 DIGESTS로 제한</target>
        </trans-unit>
        <trans-unit id="d78c46d774a0e75daea31d4c9cffa2c56e543091" translate="yes" xml:space="preserve">
          <source>Limit engine usage to DSA</source>
          <target state="translated">엔진 사용을 DSA로 제한</target>
        </trans-unit>
        <trans-unit id="8732a9dbae5a0828ffbb44002b1242202da2c9de" translate="yes" xml:space="preserve">
          <source>Limit engine usage to EC</source>
          <target state="translated">엔진 사용을 EC로 제한</target>
        </trans-unit>
        <trans-unit id="cdcab6206e8a488e5549d5ec3e6b1d5da76478c8" translate="yes" xml:space="preserve">
          <source>Limit engine usage to PKEY_ASN1_METHS</source>
          <target state="translated">엔진 사용을 PKEY_ASN1_METHS로 제한</target>
        </trans-unit>
        <trans-unit id="87885cad223c9bd4e4894b1854a73b7f044844b0" translate="yes" xml:space="preserve">
          <source>Limit engine usage to PKEY_METHDS</source>
          <target state="translated">엔진 사용을 PKEY_METHDS로 제한</target>
        </trans-unit>
        <trans-unit id="4022d5e22f1d34c3d5c81034adf42f203a7574aa" translate="yes" xml:space="preserve">
          <source>Limit engine usage to RAND</source>
          <target state="translated">엔진 사용을 RAND로 제한</target>
        </trans-unit>
        <trans-unit id="9deea2b1b94be12b96f38053a33676be8cc7d149" translate="yes" xml:space="preserve">
          <source>Limit engine usage to RSA</source>
          <target state="translated">엔진 사용을 RSA로 제한</target>
        </trans-unit>
        <trans-unit id="1450afe809ec7487cbb884eaae49c4b7de1dd9ef" translate="yes" xml:space="preserve">
          <source>Limit the amount of time the parser will wait to receive the complete HTTP headers.</source>
          <target state="translated">구문 분석기가 완전한 HTTP 헤더를 수신하기 위해 대기하는 시간을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="f203cc5a857dde040cc3f179c0e2e65d49f9ce37" translate="yes" xml:space="preserve">
          <source>Limits maximum incoming headers count. If set to 0, no limit will be applied.</source>
          <target state="translated">최대 수신 헤더 수를 제한합니다. 0으로 설정하면 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9201ce577050bd27894faffcae483339dbb7b78e" translate="yes" xml:space="preserve">
          <source>Limits maximum response headers count. If set to 0, no limit will be applied.</source>
          <target state="translated">최대 응답 헤더 수를 제한합니다. 0으로 설정하면 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80016ec82b8321d01a31f3c875531ddcc399155d" translate="yes" xml:space="preserve">
          <source>Link module dependencies. This method must be called before instantiation, and can only be called once per module.</source>
          <target state="translated">링크 모듈 의존성. 이 메소드는 인스턴스화 전에 호출해야하며 모듈 당 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99751c95e6330f5ee80abdd67407538e0c2ab2d7" translate="yes" xml:space="preserve">
          <source>Linking has failed for this module (&lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt;)</source>
          <target state="translated">이 모듈에 대한 연결에 실패했습니다 ( &lt;code&gt;linkingStatus&lt;/code&gt; is &lt;code&gt;'errored'&lt;/code&gt; errored ' )</target>
        </trans-unit>
        <trans-unit id="6137853119d6841cba11a0baee353a57f0a1174f" translate="yes" xml:space="preserve">
          <source>Linking to Node.js' own dependencies</source>
          <target state="translated">Node.js의 의존성에 연결</target>
        </trans-unit>
        <trans-unit id="0f9e059087370a1f7ba9840dcffd7d8f1c5943ff" translate="yes" xml:space="preserve">
          <source>List of Deprecated APIs</source>
          <target state="translated">더 이상 사용되지 않는 API 목록</target>
        </trans-unit>
        <trans-unit id="1103e732d98418ac8b2c82f0196dadba02f7f6d0" translate="yes" xml:space="preserve">
          <source>Listener functions &lt;strong&gt;must&lt;/strong&gt; only perform &lt;strong&gt;synchronous&lt;/strong&gt; operations. The Node.js process will exit immediately after calling the &lt;code&gt;'exit'&lt;/code&gt; event listeners causing any additional work still queued in the event loop to be abandoned. In the following example, for instance, the timeout will never occur:</source>
          <target state="translated">리스너 함수 &lt;strong&gt;는 &lt;/strong&gt;&lt;strong&gt;동기&lt;/strong&gt; 조작 만 수행 &lt;strong&gt;해야합니다&lt;/strong&gt; . &lt;code&gt;'exit'&lt;/code&gt; 이벤트 리스너를 호출 한 직후 Node.js 프로세스가 종료 되어 이벤트 루프에 대기중인 추가 작업이 중단됩니다. 예를 들어 다음 예에서 시간 초과는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77125edc2a436f1f45f34348108362e176b01cda" translate="yes" xml:space="preserve">
          <source>Listeners on this event will receive a clone of the &lt;code&gt;value&lt;/code&gt; parameter as passed to &lt;code&gt;postMessage()&lt;/code&gt; and no further arguments.</source>
          <target state="translated">이 이벤트의 리스너는 &lt;code&gt;postMessage()&lt;/code&gt; 전달 된 &lt;code&gt;value&lt;/code&gt; 매개 변수 의 복제본을 수신하며 추가 인수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c64b06f1e2a3005863a818b791661622631104ad" translate="yes" xml:space="preserve">
          <source>Listeners registered for the &lt;code&gt;'newListener'&lt;/code&gt; event will be passed the event name and a reference to the listener being added.</source>
          <target state="translated">&lt;code&gt;'newListener'&lt;/code&gt; 이벤트에 등록 된 리스너 는 이벤트 이름과 추가되는 리스너에 대한 참조를 전달받습니다.</target>
        </trans-unit>
        <trans-unit id="263ff6da0a60052822f43bf968da5510ee95e89b" translate="yes" xml:space="preserve">
          <source>Listening for this event will have an effect only on connections established after the addition of the event listener.</source>
          <target state="translated">이 이벤트를 수신하면 이벤트 리스너를 추가 한 후 설정된 연결에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0e55c3e5d75f22479bbed5d621f6f8ed741f295b" translate="yes" xml:space="preserve">
          <source>Listening on a file descriptor is not supported on Windows.</source>
          <target state="translated">Windows에서는 파일 디스크립터 청취가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efea073c6c15864c713d76af7447f0d00ffffa38" translate="yes" xml:space="preserve">
          <source>Load &lt;em&gt;resolvedURL&lt;/em&gt; as module format, &lt;em&gt;format&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;resolvedURL&lt;/em&gt; 을 모듈 형식 (format) &lt;em&gt;으로&lt;/em&gt; 로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b98d38dd9ba6d75f2dcf66b3094803bd93b8a69" translate="yes" xml:space="preserve">
          <source>Load a JSON file</source>
          <target state="translated">JSON 파일로드</target>
        </trans-unit>
        <trans-unit id="358aca8bed2102b20d329cb6c2d609fd3c90cb03" translate="yes" xml:space="preserve">
          <source>Load a Node.js CommonJS module</source>
          <target state="translated">Node.js CommonJS 모듈로드</target>
        </trans-unit>
        <trans-unit id="00177c623e9ac0d49cba30da3c54b3c977b49a06" translate="yes" xml:space="preserve">
          <source>Load a Node.js builtin module</source>
          <target state="translated">Node.js 내장 모듈로드</target>
        </trans-unit>
        <trans-unit id="b1eef931eb753eece9d6e34ced7f072cb22fcdba" translate="yes" xml:space="preserve">
          <source>Load a WebAssembly module</source>
          <target state="translated">웹 어셈블리 모듈로드</target>
        </trans-unit>
        <trans-unit id="7519ad71b3a2bfc0f580ea1764b54f66e24c2e6f" translate="yes" xml:space="preserve">
          <source>Load a standard JavaScript module</source>
          <target state="translated">표준 JavaScript 모듈로드</target>
        </trans-unit>
        <trans-unit id="498893670658c01dd4ac6da4786a9dc9aa6df8e5" translate="yes" xml:space="preserve">
          <source>Load an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with &lt;code&gt;./configure --openssl-fips&lt;/code&gt;.</source>
          <target state="translated">시작시 OpenSSL 구성 파일을로드하십시오. 다른 용도 중 Node.js가 &lt;code&gt;./configure --openssl-fips&lt;/code&gt; 로 빌드 된 경우 FIPS 호환 암호화를 활성화하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee62206d8350faeb416823dca497bcc9021efda7" translate="yes" xml:space="preserve">
          <source>Load and set the &lt;code&gt;engine&lt;/code&gt; for some or all OpenSSL functions (selected by flags).</source>
          <target state="translated">일부 또는 모든 OpenSSL 기능 (플래그로 선택)에 대한 &lt;code&gt;engine&lt;/code&gt; 을 로드하고 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="864c89092077bd29bba0c7d8aa4a1ee0ee9ad0eb" translate="yes" xml:space="preserve">
          <source>Loading Addons using require()</source>
          <target state="translated">require ()를 사용하여 애드온로드</target>
        </trans-unit>
        <trans-unit id="f7543238941e199c9c4cd5eb05bb0366a0f0e3cf" translate="yes" xml:space="preserve">
          <source>Loading from &lt;code&gt;node_modules&lt;/code&gt; Folders</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 폴더 에서로드</target>
        </trans-unit>
        <trans-unit id="679458d12984235f54fda878bb725b25ccc3fbe0" translate="yes" xml:space="preserve">
          <source>Loading from the global folders</source>
          <target state="translated">글로벌 폴더에서로드</target>
        </trans-unit>
        <trans-unit id="aab431df60aff2443055adf445c69510d18e5e54" translate="yes" xml:space="preserve">
          <source>Locale-sensitive methods like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare&quot;&gt;&lt;code&gt;String.prototype.localeCompare()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString&quot;&gt;&lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare&quot;&gt; &lt;code&gt;String.prototype.localeCompare()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString&quot;&gt; &lt;code&gt;Date.prototype.toLocaleString()&lt;/code&gt; &lt;/a&gt; 과 같은 로케일 구분 메소드</target>
        </trans-unit>
        <trans-unit id="c2ef9686a9d07af86ddb6785cca13fffd98fde0f" translate="yes" xml:space="preserve">
          <source>Locale-sensitive or Unicode-aware functions in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양의&lt;/a&gt; 로케일 구분 또는 유니 코드 인식 기능 :</target>
        </trans-unit>
        <trans-unit id="53836d61b88bc9ebe5ff04c57ab3d5e85b3ccd6f" translate="yes" xml:space="preserve">
          <source>Location at which the report will be generated.</source>
          <target state="translated">보고서가 생성 될 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e500d4d84a92a8c0603625b4b6fd77177fa0a2b3" translate="yes" xml:space="preserve">
          <source>MD5 and SHA-1 are no longer acceptable where collision resistance is required such as digital signatures.</source>
          <target state="translated">디지털 서명과 같은 충돌 저항이 필요한 경우 MD5 및 SHA-1을 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86d931caa3fae8fb2300ea8f1d2a55be58e1a3d8" translate="yes" xml:space="preserve">
          <source>MODULE_NOT_FOUND</source>
          <target state="translated">MODULE_NOT_FOUND</target>
        </trans-unit>
        <trans-unit id="e1ec46742fb947b44338032993756f78da0b54d2" translate="yes" xml:space="preserve">
          <source>Made &lt;code&gt;func&lt;/code&gt; parameter optional with custom &lt;code&gt;call_js_cb&lt;/code&gt;.</source>
          <target state="translated">제작 &lt;code&gt;func&lt;/code&gt; 정의와 매개 변수 옵션 &lt;code&gt;call_js_cb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb480a8a8b26324095457c616935d3f1841b3f51" translate="yes" xml:space="preserve">
          <source>Maintains an internal counter specific to &lt;code&gt;label&lt;/code&gt; and outputs to &lt;code&gt;stdout&lt;/code&gt; the number of times &lt;code&gt;console.count()&lt;/code&gt; has been called with the given &lt;code&gt;label&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;label&lt;/code&gt; 로 &lt;code&gt;console.count()&lt;/code&gt; 가 호출 된 횟수 를 &lt;code&gt;stdout&lt;/code&gt; 하기 위해 &lt;code&gt;label&lt;/code&gt; 및 출력에 고유 한 내부 카운터를 유지 보수합니다 .</target>
        </trans-unit>
        <trans-unit id="7a81028c010c15e7a86469745fd56a7b314afde0" translate="yes" xml:space="preserve">
          <source>Make a self-contained library use its own symbols in preference to symbols from previously loaded libraries.</source>
          <target state="translated">자체 포함 된 라이브러리가 이전에로드 된 라이브러리의 기호보다 고유 한 기호를 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="58e5fc2cf8facef6490eacd62f42219179c768b6" translate="yes" xml:space="preserve">
          <source>Makes a request to a secure web server.</source>
          <target state="translated">보안 웹 서버에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="77ef1a913ec8293839a75b3ea0986e203581e748" translate="yes" xml:space="preserve">
          <source>Making handle lifespan shorter than that of the native method</source>
          <target state="translated">기본 메소드보다 핸들 수명을 단축</target>
        </trans-unit>
        <trans-unit id="e7258012eabbd3b3ddb7a3bfafbe25922453be58" translate="yes" xml:space="preserve">
          <source>Mandatory file extensions</source>
          <target state="translated">필수 파일 확장자</target>
        </trans-unit>
        <trans-unit id="c7517849408f94693f21294c1f40a914dd912fa2" translate="yes" xml:space="preserve">
          <source>Marks an &lt;code&gt;ArrayBuffer&lt;/code&gt; as having its contents transferred out of band. Pass the corresponding &lt;code&gt;ArrayBuffer&lt;/code&gt; in the deserializing context to &lt;a href=&quot;#v8_deserializer_transferarraybuffer_id_arraybuffer&quot;&gt;&lt;code&gt;deserializer.transferArrayBuffer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayBuffer&lt;/code&gt; 의 내용이 대역 외로 전송 된 것으로 표시합니다 . 역 직렬화 컨텍스트 의 해당 &lt;code&gt;ArrayBuffer&lt;/code&gt; 를 &lt;a href=&quot;#v8_deserializer_transferarraybuffer_id_arraybuffer&quot;&gt; &lt;code&gt;deserializer.transferArrayBuffer()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e9d92daad3190f7c23fb73a149a2e3ed5745cfd" translate="yes" xml:space="preserve">
          <source>Marks an &lt;code&gt;ArrayBuffer&lt;/code&gt; as having its contents transferred out of band. Pass the corresponding &lt;code&gt;ArrayBuffer&lt;/code&gt; in the serializing context to &lt;a href=&quot;#v8_serializer_transferarraybuffer_id_arraybuffer&quot;&gt;&lt;code&gt;serializer.transferArrayBuffer()&lt;/code&gt;&lt;/a&gt; (or return the &lt;code&gt;id&lt;/code&gt; from &lt;a href=&quot;#v8_serializer_getsharedarraybufferid_sharedarraybuffer&quot;&gt;&lt;code&gt;serializer._getSharedArrayBufferId()&lt;/code&gt;&lt;/a&gt; in the case of &lt;code&gt;SharedArrayBuffer&lt;/code&gt;s).</source>
          <target state="translated">&lt;code&gt;ArrayBuffer&lt;/code&gt; 의 내용이 대역 외로 전송 된 것으로 표시합니다 . 직렬화 컨텍스트 의 해당 &lt;code&gt;ArrayBuffer&lt;/code&gt; 를 &lt;a href=&quot;#v8_serializer_transferarraybuffer_id_arraybuffer&quot;&gt; &lt;code&gt;serializer.transferArrayBuffer()&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 의 경우 &lt;a href=&quot;#v8_serializer_getsharedarraybufferid_sharedarraybuffer&quot;&gt; &lt;code&gt;serializer._getSharedArrayBufferId()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;id&lt;/code&gt; 를 리턴 함 ).</target>
        </trans-unit>
        <trans-unit id="1e2ad0793ef76124b1034c1cea3ed4e613e126d0" translate="yes" xml:space="preserve">
          <source>Marks the request as aborting. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed.</source>
          <target state="translated">요청을 중단 된 것으로 표시합니다. 이것을 호출하면 응답의 나머지 데이터가 삭제되고 소켓이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="0f845dbfd32891203afbc6c332195efbd6298479" translate="yes" xml:space="preserve">
          <source>Max header size in &lt;code&gt;http_parser&lt;/code&gt; was set to 8KB.</source>
          <target state="translated">&lt;code&gt;http_parser&lt;/code&gt; 의 최대 헤더 크기는 8KB로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="f21ff80ab9cf701ac46a3167e21f3037801508fd" translate="yes" xml:space="preserve">
          <source>Measuring how long it takes to load dependencies</source>
          <target state="translated">종속성을로드하는 데 걸리는 시간 측정</target>
        </trans-unit>
        <trans-unit id="9128f1b632621e70aa390a4486c36bb163baf0c8" translate="yes" xml:space="preserve">
          <source>Measuring the duration of async operations</source>
          <target state="translated">비동기 작업 기간 측정</target>
        </trans-unit>
        <trans-unit id="e0efdce50032a40b3a3914e5fc8bfa6cd4288bb5" translate="yes" xml:space="preserve">
          <source>Memory Management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="ef1eb41c5de244b704fcf15f3bc0f13c999a4f71" translate="yes" xml:space="preserve">
          <source>Memory Usage Tuning</source>
          <target state="translated">메모리 사용량 조정</target>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="0ce120a41bf22d68c9fab53d50c8a38d4440d65a" translate="yes" xml:space="preserve">
          <source>MessagePort</source>
          <target state="translated">MessagePort</target>
        </trans-unit>
        <trans-unit id="532bb72b545e75db867501d58fef21423a35b550" translate="yes" xml:space="preserve">
          <source>Method(s) to implement</source>
          <target state="translated">구현할 방법</target>
        </trans-unit>
        <trans-unit id="be11d28d855c168de0db39411d017ffe8e5d8b28" translate="yes" xml:space="preserve">
          <source>Methods that return TLS connection metadata (e.g. &lt;a href=&quot;#tls_tlssocket_getpeercertificate_detailed&quot;&gt;&lt;code&gt;tls.TLSSocket.getPeerCertificate()&lt;/code&gt;&lt;/a&gt; will only return data while the connection is open.</source>
          <target state="translated">TLS 연결 메타 데이터 (예 : &lt;a href=&quot;#tls_tlssocket_getpeercertificate_detailed&quot;&gt; &lt;code&gt;tls.TLSSocket.getPeerCertificate()&lt;/code&gt; &lt;/a&gt; 를 반환하는 메서드 는 연결이 열려있는 동안에 만 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ba3efaca5f13d398812424482d57e438a3b44995" translate="yes" xml:space="preserve">
          <source>Modern Web browsers follow the &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG Encoding Standard&lt;/a&gt; which aliases both &lt;code&gt;'latin1'&lt;/code&gt; and &lt;code&gt;'ISO-8859-1'&lt;/code&gt; to &lt;code&gt;'win-1252'&lt;/code&gt;. This means that while doing something like &lt;code&gt;http.get()&lt;/code&gt;, if the returned charset is one of those listed in the WHATWG specification it is possible that the server actually returned &lt;code&gt;'win-1252'&lt;/code&gt;-encoded data, and using &lt;code&gt;'latin1'&lt;/code&gt; encoding may incorrectly decode the characters.</source>
          <target state="translated">최신 웹 브라우저 는 &lt;code&gt;'latin1'&lt;/code&gt; 및 &lt;code&gt;'ISO-8859-1'&lt;/code&gt; 을 &lt;code&gt;'win-1252'&lt;/code&gt; 로 별칭 지정 하는 &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG 인코딩 표준&lt;/a&gt; 을 따릅니다 . 이는 &lt;code&gt;http.get()&lt;/code&gt; 과 같은 작업을 수행하는 동안 반환 된 문자 집합 이 WHATWG 사양에 나열된 문자 집합 중 하나 인 경우 서버가 실제로 &lt;code&gt;'win-1252'&lt;/code&gt; 인코딩 데이터를 반환 하고 &lt;code&gt;'latin1'&lt;/code&gt; 인코딩을 사용할 수 있음을 의미합니다 문자를 잘못 해독하십시오.</target>
        </trans-unit>
        <trans-unit id="5e5ee885e59c3666b818d0a51c7fee388b17e46d" translate="yes" xml:space="preserve">
          <source>Modifies the permissions on the file. The &lt;code&gt;Promise&lt;/code&gt; is resolved with no arguments upon success.</source>
          <target state="translated">파일에 대한 권한을 수정합니다. &lt;code&gt;Promise&lt;/code&gt; 성공에 따라 인수없이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="e955b90e741d4c82b9b85c4cc9aa35c010f53aa4" translate="yes" xml:space="preserve">
          <source>Modifying a file rather than replacing it may require a flags mode of &lt;code&gt;'r+'&lt;/code&gt; rather than the default mode &lt;code&gt;'w'&lt;/code&gt;.</source>
          <target state="translated">파일을 바꾸지 않고 수정 하려면 기본 모드 &lt;code&gt;'w'&lt;/code&gt; 대신 &lt;code&gt;'r+'&lt;/code&gt; 플래그 모드가 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5cd669deb64182bb1486f9edc35fe42bd6d7f56" translate="yes" xml:space="preserve">
          <source>Modifying the Default TLS Cipher suite</source>
          <target state="translated">기본 TLS 암호 제품군 수정</target>
        </trans-unit>
        <trans-unit id="386917eb344492726f971a2580c72bd0600c3297" translate="yes" xml:space="preserve">
          <source>Modifying the new &lt;code&gt;Buffer&lt;/code&gt; slice will modify the memory in the original &lt;code&gt;Buffer&lt;/code&gt; because the allocated memory of the two objects overlap.</source>
          <target state="translated">새 &lt;code&gt;Buffer&lt;/code&gt; 슬라이스를 수정 하면 두 객체의 할당 된 메모리가 겹치므로 원래 &lt;code&gt;Buffer&lt;/code&gt; 의 메모리가 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7606a01db550a47662b629f247d6367bcf7282" translate="yes" xml:space="preserve">
          <source>Module Caching Caveats</source>
          <target state="translated">모듈 캐싱주의 사항</target>
        </trans-unit>
        <trans-unit id="83624ccd7b5527bbf857a1fbcf3723edba0da40a" translate="yes" xml:space="preserve">
          <source>Module registration</source>
          <target state="translated">모듈 등록</target>
        </trans-unit>
        <trans-unit id="7939217a1ff65e34d944c1af418682a3959683e6" translate="yes" xml:space="preserve">
          <source>Module.createRequireFromPath() is deprecated. Please use &lt;a href=&quot;modules#modules_module_createrequire_filename&quot;&gt;&lt;code&gt;module.createRequire()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Module.createRequireFromPath ()는 더 이상 사용되지 않습니다. 사용하십시오 &lt;a href=&quot;modules#modules_module_createrequire_filename&quot;&gt; &lt;code&gt;module.createRequire()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="85946d17e9abcad5d8c5d7ff7e55541e63757d01" translate="yes" xml:space="preserve">
          <source>Modules are cached after the first time they are loaded. This means (among other things) that every call to &lt;code&gt;require('foo')&lt;/code&gt; will get exactly the same object returned, if it would resolve to the same file.</source>
          <target state="translated">모듈은 처음로드 된 후 캐시됩니다. 이것은 &lt;code&gt;require('foo')&lt;/code&gt; 에 대한 모든 호출 이 동일한 파일로 해석되면 정확히 동일한 객체를 반환한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9328fdb06dec7493c1ac0a3bc42b0f79daf79a03" translate="yes" xml:space="preserve">
          <source>Modules are cached based on their resolved filename. Since modules may resolve to a different filename based on the location of the calling module (loading from &lt;code&gt;node_modules&lt;/code&gt; folders), it is not a &lt;em&gt;guarantee&lt;/em&gt; that &lt;code&gt;require('foo')&lt;/code&gt; will always return the exact same object, if it would resolve to different files.</source>
          <target state="translated">모듈은 해결 된 파일 이름을 기반으로 캐시됩니다. 모듈이 호출 모듈의 위치 ( &lt;code&gt;node_modules&lt;/code&gt; 폴더 에서로드)의 위치에 따라 다른 파일 이름으로 해석 될 수 있기 때문에 &lt;code&gt;require('foo')&lt;/code&gt; 가 다른 파일로 해석 될 경우 항상 동일한 객체를 반환 한다는 &lt;em&gt;보장&lt;/em&gt; 은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="28e1343a6af7d08fdfab4981e72800f3eb87862a" translate="yes" xml:space="preserve">
          <source>Modules are cached in this object when they are required. By deleting a key value from this object, the next &lt;code&gt;require&lt;/code&gt; will reload the module. This does not apply to &lt;a href=&quot;addons&quot;&gt;native addons&lt;/a&gt;, for which reloading will result in an error.</source>
          <target state="translated">필요할 때이 개체에 모듈이 캐시됩니다. 이 객체에서 키 값을 삭제하면 다음 &lt;code&gt;require&lt;/code&gt; 따라 모듈이 다시로드됩니다. 다시로드하면 오류가 발생하는 &lt;a href=&quot;addons&quot;&gt;기본 애드온&lt;/a&gt; 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="00d05571b964dddda3ae3561348588cfd26ddbfa" translate="yes" xml:space="preserve">
          <source>Modules that have an invalid &lt;code&gt;main&lt;/code&gt; entry (e.g., &lt;code&gt;./does-not-exist.js&lt;/code&gt;) and also have an &lt;code&gt;index.js&lt;/code&gt; file in the top level directory will resolve the &lt;code&gt;index.js&lt;/code&gt; file. That is deprecated and is going to throw an error in future Node.js versions.</source>
          <target state="translated">잘못이 모듈 &lt;code&gt;main&lt;/code&gt; 항목을 (예, &lt;code&gt;./does-not-exist.js&lt;/code&gt; ) 또한는이 &lt;code&gt;index.js&lt;/code&gt; 결심 할 최상위 디렉토리에있는 파일을 &lt;code&gt;index.js&lt;/code&gt; 파일을. 더 이상 사용되지 않으며 향후 Node.js 버전에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f8cb9d5d814826c94ca425c65a80591a56c453c" translate="yes" xml:space="preserve">
          <source>Modules will be loaded multiple times if the &lt;code&gt;import&lt;/code&gt; specifier used to resolve them have a different query or fragment.</source>
          <target state="translated">모듈 을 해결하는 데 사용되는 &lt;code&gt;import&lt;/code&gt; 지정자가 다른 쿼리 또는 조각을 갖는 경우 모듈이 여러 번로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="90fbb2012f6d47e34578586d91fdc3981db8daf4" translate="yes" xml:space="preserve">
          <source>More accurate &lt;a href=&quot;repl#repl_repl&quot;&gt;REPL&lt;/a&gt; line editing</source>
          <target state="translated">보다 정확한 &lt;a href=&quot;repl#repl_repl&quot;&gt;REPL&lt;/a&gt; 라인 편집</target>
        </trans-unit>
        <trans-unit id="0ecdbeb6845d999cf7003e1812bec6e641a5510d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;fs&lt;/code&gt; operations accept filepaths that may be specified in the form of a string, a &lt;a href=&quot;buffer#buffer_buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt;&lt;code&gt;URL&lt;/code&gt;&lt;/a&gt; object using the &lt;code&gt;file:&lt;/code&gt; protocol.</source>
          <target state="translated">대부분의 &lt;code&gt;fs&lt;/code&gt; 작업은 문자열 : &lt;a href=&quot;buffer#buffer_buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;file:&lt;/code&gt; 프로토콜을 사용하여 &lt;a href=&quot;url#url_the_whatwg_url_api&quot;&gt; &lt;code&gt;URL&lt;/code&gt; &lt;/a&gt; 객체 형식으로 지정할 수있는 파일 경로를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="82cff11b4bb5481a6d7ac80aec40ddd830fc32bf" translate="yes" xml:space="preserve">
          <source>Most applications should consider using the new &lt;code&gt;KeyObject&lt;/code&gt; API instead of passing keys as strings or &lt;code&gt;Buffer&lt;/code&gt;s due to improved security features.</source>
          <target state="translated">대부분의 응용 프로그램은 향상된 보안 기능으로 인해 키를 문자열 또는 &lt;code&gt;Buffer&lt;/code&gt; 로 전달하는 대신 새로운 &lt;code&gt;KeyObject&lt;/code&gt; API 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="20cb9dba8d1ec1bda32d3869a385011e92bc7b15" translate="yes" xml:space="preserve">
          <source>Most asynchronous methods exposed by the Node.js core API follow an idiomatic pattern referred to as an &lt;em&gt;error-first callback&lt;/em&gt;. With this pattern, a callback function is passed to the method as an argument. When the operation either completes or an error is raised, the callback function is called with the &lt;code&gt;Error&lt;/code&gt; object (if any) passed as the first argument. If no error was raised, the first argument will be passed as &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Node.js 핵심 API에 의해 노출되는 대부분의 비동기 메소드는 &lt;em&gt;오류 우선 콜백&lt;/em&gt; 이라는 관용적 패턴을 따릅니다 . 이 패턴을 사용하면 콜백 함수가 인수로 메소드에 전달됩니다. 작업이 완료되거나 오류가 발생 하면 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 객체 (있는 경우) 와 함께 콜백 함수가 호출됩니다 . 오류가 발생하지 않으면 첫 번째 인수가 &lt;code&gt;null&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbf34ac485339ebd83193dd184575f98649766ac" translate="yes" xml:space="preserve">
          <source>Most asynchronous methods that accept a &lt;code&gt;callback&lt;/code&gt; function will accept an &lt;code&gt;Error&lt;/code&gt; object passed as the first argument to that function. If that first argument is not &lt;code&gt;null&lt;/code&gt; and is an instance of &lt;code&gt;Error&lt;/code&gt;, then an error occurred that should be handled.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 함수 를 허용하는 대부분의 비동기 메소드는 해당 함수 의 첫 번째 인수로 전달 된 &lt;code&gt;Error&lt;/code&gt; 객체 를 허용 합니다. 첫 번째 인수가 &lt;code&gt;null&lt;/code&gt; 이 아니고 &lt;code&gt;Error&lt;/code&gt; 인스턴스 인 경우 처리해야하는 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2b8ceb2fddd337b5e111a9cd6250634bdec17c99" translate="yes" xml:space="preserve">
          <source>Most operating systems limit the number of file descriptors that may be open at any given time so it is critical to close the descriptor when operations are completed. Failure to do so will result in a memory leak that will eventually cause an application to crash.</source>
          <target state="translated">대부분의 운영 체제는 주어진 시간에 열려있을 수있는 파일 설명자 수를 제한하므로 작업이 완료되면 설명자를 닫는 것이 중요합니다. 그렇지 않으면 메모리 누수가 발생하여 응용 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18cebb6899365ed285fb7b9339be5b27f9d9ab5f" translate="yes" xml:space="preserve">
          <source>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called &quot;emitters&quot;) emit named events that cause &lt;code&gt;Function&lt;/code&gt; objects (&quot;listeners&quot;) to be called.</source>
          <target state="translated">대부분의 Node.js 핵심 API는 특정 종류의 객체 ( &quot;이미 터&quot;)가 &lt;code&gt;Function&lt;/code&gt; 객체 ( &quot;리스너&quot;)를 호출 하는 명명 된 이벤트를 생성하는 관용적 인 비동기 이벤트 중심 아키텍처를 기반으로 구축되었습니다 .</target>
        </trans-unit>
        <trans-unit id="51b9e9e4f853d5c9f436fb23cb6c1226b9b3c6d3" translate="yes" xml:space="preserve">
          <source>Multiple alternatives may be specified, for instance: &lt;code&gt;'h2=&quot;example.org:81&quot;, h2=&quot;:82&quot;'&lt;/code&gt;.</source>
          <target state="translated">여러 대안을 지정할 수 있습니다 (예 : &lt;code&gt;'h2=&quot;example.org:81&quot;, h2=&quot;:82&quot;'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5479027d01ceffdeaae68128ea7b4adf28374c" translate="yes" xml:space="preserve">
          <source>Multiple comma-separated &lt;code&gt;section&lt;/code&gt; names may be specified in the &lt;code&gt;NODE_DEBUG&lt;/code&gt; environment variable: &lt;code&gt;NODE_DEBUG=fs,net,tls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NODE_DEBUG&lt;/code&gt; 환경 변수 &lt;code&gt;NODE_DEBUG=fs,net,tls&lt;/code&gt; 에 쉼표로 구분 된 여러 &lt;code&gt;section&lt;/code&gt; 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27f2ab40edb60bf40787bb6edf23d36b9c543077" translate="yes" xml:space="preserve">
          <source>Multiple concatenated gzip file members are supported now.</source>
          <target state="translated">여러 개의 연결된 gzip 파일 멤버가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f4215a6b0ba9f7218f437607dda8f17b06a6cd29" translate="yes" xml:space="preserve">
          <source>Multiple empty entries are now parsed correctly (e.g. &lt;code&gt;&amp;amp;=&amp;amp;=&lt;/code&gt;).</source>
          <target state="translated">여러 개의 빈 항목이 이제 올바르게 구문 분석됩니다 (예 : &lt;code&gt;&amp;amp;=&amp;amp;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c11e7417524b09c3c63dbb1d8edf3a8d679325c8" translate="yes" xml:space="preserve">
          <source>Multiple values were provided for an HTTP/2 header field that was required to have only a single value.</source>
          <target state="translated">단일 값만 필요한 HTTP / 2 헤더 필드에 여러 값이 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="0cfd7073a743f5ff4fda510240475719d7850d63" translate="yes" xml:space="preserve">
          <source>N-API</source>
          <target state="translated">N-API</target>
        </trans-unit>
        <trans-unit id="90cbc0e18027d4869385351bdb9ade6021ccdf03" translate="yes" xml:space="preserve">
          <source>N-API (pronounced N as in the letter, followed by API) is an API for building native Addons. It is independent from the underlying JavaScript runtime (for example, V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one major version to run on later major versions of Node.js without recompilation. The &lt;a href=&quot;https://nodejs.org/en/docs/guides/abi-stability/&quot;&gt;ABI Stability&lt;/a&gt; guide provides a more in-depth explanation.</source>
          <target state="translated">N-API (문자로 N으로 발음되고 API가 뒤 따름)는 기본 애드온을 빌드하기위한 API입니다. 기본 JavaScript 런타임 (예 : V8)과 독립적이며 Node.js 자체의 일부로 유지 보수됩니다. 이 API는 Node.js 버전에서 안정적인 ABI (Application Binary Interface)입니다. 기본 JavaScript 엔진의 변경 사항으로부터 애드온을 격리하고 하나의 주요 버전 용으로 컴파일 된 모듈을 재 컴파일없이 이후의 주요 버전의 Node.js에서 실행할 수 있습니다. &lt;a href=&quot;https://nodejs.org/en/docs/guides/abi-stability/&quot;&gt;ABI 안정성&lt;/a&gt; 가이드는보다 심층적 인 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="334e1de2311ffce54fb9769c28586c411d51f5fe" translate="yes" xml:space="preserve">
          <source>N-API Callback types</source>
          <target state="translated">N-API 콜백 유형</target>
        </trans-unit>
        <trans-unit id="5ada9d09ff541a5d3e10d36683dca70ab044cf65" translate="yes" xml:space="preserve">
          <source>N-API Memory Management types</source>
          <target state="translated">N-API 메모리 관리 유형</target>
        </trans-unit>
        <trans-unit id="1f918c2169b9c207f636baeefc2f5e1825de6091" translate="yes" xml:space="preserve">
          <source>N-API Version Matrix</source>
          <target state="translated">N-API 버전 매트릭스</target>
        </trans-unit>
        <trans-unit id="4cd2329041a56e471a3596295b8fded33cd92bcd" translate="yes" xml:space="preserve">
          <source>N-API defines the &lt;code&gt;napi_work&lt;/code&gt; structure which is used to manage asynchronous workers. Instances are created/deleted with &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt;&lt;code&gt;napi_create_async_work&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt;&lt;code&gt;napi_delete_async_work&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">N-API는 비동기 작업자를 관리하는 데 사용되는 &lt;code&gt;napi_work&lt;/code&gt; 구조를 정의합니다 . &lt;a href=&quot;#n_api_napi_create_async_work&quot;&gt; &lt;code&gt;napi_create_async_work&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#n_api_napi_delete_async_work&quot;&gt; &lt;code&gt;napi_delete_async_work&lt;/code&gt; 로&lt;/a&gt; 인스턴스를 생성 / 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="88f54237d497e37e1e102b35a1c9c4125fb96d0f" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to create all types of JavaScript values. Some of these types are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values&quot;&gt;Section 6&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 모든 유형의 JavaScript 값을 만듭니다. 이러한 유형 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양&lt;/a&gt; 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values&quot;&gt;섹션 6&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7ee8aa91b06eb2761965bea9b3ca7d13159118" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to get and set properties on JavaScript objects. Some of these types are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-operations-on-objects&quot;&gt;Section 7&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 JavaScript 객체의 속성을 가져오고 설정합니다. 이러한 유형 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양&lt;/a&gt; 의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-operations-on-objects&quot;&gt;섹션 7&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b7e76dd3e6c6d68488dbe2b8f2a01306cdd1b3" translate="yes" xml:space="preserve">
          <source>N-API exposes a set of APIs to perform some abstract operations on JavaScript values. Some of these operations are documented under &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;Section 7&lt;/a&gt; of the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript Language Specification&lt;/a&gt;.</source>
          <target state="translated">N-API는 일련의 API를 노출하여 JavaScript 값에 대한 추상 작업을 수행합니다. 이러한 작업 중 일부는 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;ECMAScript 언어 사양 &lt;/a&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-abstract-operations&quot;&gt;섹션 7&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c61dcfa47476fc6fa41772f59614e57871819b0" translate="yes" xml:space="preserve">
          <source>N-API exposes the following fundamental datatypes as abstractions that are consumed by the various APIs. These APIs should be treated as opaque, introspectable only with other N-API calls.</source>
          <target state="translated">N-API는 다음과 같은 기본 데이터 유형을 다양한 API에서 사용하는 추상화로 표시합니다. 이러한 API는 다른 N-API 호출에서만 볼 수있는 불투명 한 것으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="561e1622d71e550f526caaa66deabdc9dfbdc3cb" translate="yes" xml:space="preserve">
          <source>N-API is an API for building native Addons. It is independent from the underlying JavaScript runtime (e.g. V8) and is maintained as part of Node.js itself. This API will be Application Binary Interface (ABI) stable across versions of Node.js. It is intended to insulate Addons from changes in the underlying JavaScript engine and allow modules compiled for one version to run on later versions of Node.js without recompilation. Addons are built/packaged with the same approach/tools outlined in this document (node-gyp, etc.). The only difference is the set of APIs that are used by the native code. Instead of using the V8 or &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Native Abstractions for Node.js&lt;/a&gt; APIs, the functions available in the N-API are used.</source>
          <target state="translated">N-API는 기본 애드온을 구축하기위한 API입니다. 기본 JavaScript 런타임 (예 : V8)과 독립적이며 Node.js 자체의 일부로 유지 관리됩니다. 이 API는 Node.js 버전에서 안정적인 ABI (Application Binary Interface)입니다. 기본 JavaScript 엔진의 변경 사항으로부터 애드온을 격리시키고 한 버전 용으로 컴파일 된 모듈이 재 컴파일없이 이후 버전의 Node.js에서 실행될 수 있도록합니다. 애드온은이 문서에 설명 된 것과 동일한 접근 방식 / 도구 (node-gyp 등)로 빌드 / 패키징됩니다. 유일한 차이점은 기본 코드에서 사용되는 API 세트입니다. &lt;a href=&quot;https://github.com/nodejs/nan&quot;&gt;Node.js&lt;/a&gt; API에 V8 또는 Native Abstractions를 사용하는 대신 N-API에서 사용 가능한 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0738955b59acf88770860528a15013618ab13c78" translate="yes" xml:space="preserve">
          <source>N-API modules are registered in a manner similar to other modules except that instead of using the &lt;code&gt;NODE_MODULE&lt;/code&gt; macro the following is used:</source>
          <target state="translated">N-API 모듈은 &lt;code&gt;NODE_MODULE&lt;/code&gt; 매크로 를 사용하는 대신 다음을 사용한다는 점을 제외하고 다른 모듈과 유사한 방식으로 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ce7ec8745b23919ab41738dc2e8d90813f2426a" translate="yes" xml:space="preserve">
          <source>N-API offers a way to &quot;wrap&quot; C++ classes and instances so that the class constructor and methods can be called from JavaScript.</source>
          <target state="translated">N-API는 C ++ 클래스와 인스턴스를 &quot;랩핑&quot;하여 클래스 생성자와 메소드를 JavaScript에서 호출 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45efbba7b6828bb6ff691538d9468098a20c4570" translate="yes" xml:space="preserve">
          <source>N-API only supports a single nested hierarchy of scopes. There is only one active scope at any time, and all new handles will be associated with that scope while it is active. Scopes must be closed in the reverse order from which they are opened. In addition, all scopes created within a native method must be closed before returning from that method.</source>
          <target state="translated">N-API는 단일 중첩 범위의 계층 구조 만 지원합니다. 언제든지 하나의 활성 범위 만 있으며 모든 새 핸들은 활성 상태 인 동안 해당 범위와 연관됩니다. 범위는 열었던 순서와 반대로 닫혀 야합니다. 또한 고유 메소드에서 작성된 모든 범위는 해당 메소드에서 리턴하기 전에 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="d7b60dab0bc992db521955215d2463d3ce27f102" translate="yes" xml:space="preserve">
          <source>N-API provides a function for getting the current event loop associated with a specific &lt;code&gt;napi_env&lt;/code&gt;.</source>
          <target state="translated">N-API는 특정 &lt;code&gt;napi_env&lt;/code&gt; 와 관련된 현재 이벤트 루프를 가져 오는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e6d292a608d795d02e9feb5215a93624719c5f3d" translate="yes" xml:space="preserve">
          <source>N-API provides a set of APIs that allow JavaScript code to call back into native code. N-API APIs that support calling back into native code take in a callback functions represented by the &lt;code&gt;napi_callback&lt;/code&gt; type. When the JavaScript VM calls back to native code, the &lt;code&gt;napi_callback&lt;/code&gt; function provided is invoked. The APIs documented in this section allow the callback function to do the following:</source>
          <target state="translated">N-API는 JavaScript 코드를 기본 코드로 다시 호출 할 수있는 API 세트를 제공합니다. 네이티브 코드로의 콜백을 지원하는 N-API API는 &lt;code&gt;napi_callback&lt;/code&gt; 유형으로 표시되는 콜백 함수를받습니다 . JavaScript VM이 원시 코드를 다시 호출하면 제공된 &lt;code&gt;napi_callback&lt;/code&gt; 함수가 호출됩니다. 이 섹션에 설명 된 API를 통해 콜백 함수는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01090223361802809df29f213e82e3b9319fcf72" translate="yes" xml:space="preserve">
          <source>N-API provides an ABI-stable interface for these supporting functions which covers the most common asynchronous use cases.</source>
          <target state="translated">N-API는 가장 일반적인 비동기 사용 사례를 다루는 이러한 지원 기능을위한 ABI 안정적인 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f39db522f9283fcef0c912ba468da776135f241" translate="yes" xml:space="preserve">
          <source>N-API provides an API for executing a string containing JavaScript using the underlying JavaScript engine.</source>
          <target state="translated">N-API는 기본 JavaScript 엔진을 사용하여 JavaScript가 포함 된 문자열을 실행하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2313fc0c61261c329c023f99d171fe8dbee4423c" translate="yes" xml:space="preserve">
          <source>N-API provides facilities for creating &lt;code&gt;Promise&lt;/code&gt; objects as described in &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-promise-objects&quot;&gt;Section 25.4&lt;/a&gt; of the ECMA specification. It implements promises as a pair of objects. When a promise is created by &lt;code&gt;napi_create_promise()&lt;/code&gt;, a &quot;deferred&quot; object is created and returned alongside the &lt;code&gt;Promise&lt;/code&gt;. The deferred object is bound to the created &lt;code&gt;Promise&lt;/code&gt; and is the only means to resolve or reject the &lt;code&gt;Promise&lt;/code&gt; using &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; or &lt;code&gt;napi_reject_deferred()&lt;/code&gt;. The deferred object that is created by &lt;code&gt;napi_create_promise()&lt;/code&gt; is freed by &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; or &lt;code&gt;napi_reject_deferred()&lt;/code&gt;. The &lt;code&gt;Promise&lt;/code&gt; object may be returned to JavaScript where it can be used in the usual fashion.</source>
          <target state="translated">N-API는 ECMA 사양의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-promise-objects&quot;&gt;섹션 25.4&lt;/a&gt; 에 설명 된대로 &lt;code&gt;Promise&lt;/code&gt; 객체 를 생성하는 기능을 제공합니다 . 약속을 한 쌍의 객체로 구현합니다. &lt;code&gt;napi_create_promise()&lt;/code&gt; 의해 promise가 생성되면 &quot;deferred&quot;개체가 생성되어 &lt;code&gt;Promise&lt;/code&gt; 와 함께 반환 됩니다. 지연된 오브젝트는 작성된 &lt;code&gt;Promise&lt;/code&gt; 에 바인드되며 &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; 또는 &lt;code&gt;napi_reject_deferred()&lt;/code&gt; 사용 하여 &lt;code&gt;Promise&lt;/code&gt; 를 해결하거나 거부하는 유일한 수단 입니다. &lt;code&gt;napi_create_promise()&lt;/code&gt; 작성된 지연된 오브젝트는 &lt;code&gt;napi_resolve_deferred()&lt;/code&gt; 또는 &lt;code&gt;napi_reject_deferred()&lt;/code&gt; 의해 해제됩니다.. &lt;code&gt;Promise&lt;/code&gt; 객체가 일반적인 방식으로 사용할 수있는 자바 스크립트로 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d99e6c12543c037d84d75d93df6bb441b536baa" translate="yes" xml:space="preserve">
          <source>N-API provides functions for registering and un-registering such callbacks. When those callbacks are run, all resources that are being held by the addon should be freed up.</source>
          <target state="translated">N-API는 이러한 콜백을 등록 및 등록 해제하는 기능을 제공합니다. 이러한 콜백이 실행될 때 애드온이 보유하고있는 모든 리소스를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7c3cd228011e5d9137f1bb00c23394226dbfbfc" translate="yes" xml:space="preserve">
          <source>N-API provides methods to create persistent references to an object. Each persistent reference has an associated count with a value of 0 or higher. The count determines if the reference will keep the corresponding object live. References with a count of 0 do not prevent the object from being collected and are often called 'weak' references. Any count greater than 0 will prevent the object from being collected.</source>
          <target state="translated">N-API는 개체에 대한 영구 참조를 만드는 방법을 제공합니다. 각 영구 참조에는 값이 0 이상인 관련 카운트가 있습니다. 카운트는 참조가 해당 객체를 라이브로 유지할지 여부를 결정합니다. 카운트가 0 인 참조는 오브젝트가 수집되는 것을 방해하지 않으며 종종 '약한'참조라고합니다. 카운트가 0보다 크면 개체가 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21039b0e91105633cdec6fe19581a15729f4b937" translate="yes" xml:space="preserve">
          <source>N-API sets up the environment prior to calling this callback, so it is sufficient to call the JavaScript function via &lt;code&gt;napi_call_function&lt;/code&gt; rather than via &lt;code&gt;napi_make_callback&lt;/code&gt;.</source>
          <target state="translated">환경까지 이전이 콜백을 호출하는 N-API 세트, 그래서를 통해 자바 스크립트 함수를 호출하기에 충분 &lt;code&gt;napi_call_function&lt;/code&gt; 보다는 통해 &lt;code&gt;napi_make_callback&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea939312c782d8c5e666ab405635666046b5b1f" translate="yes" xml:space="preserve">
          <source>N-API uses both return values and JavaScript exceptions for error handling. The following sections explain the approach for each case.</source>
          <target state="translated">N-API는 오류 처리에 반환 값과 JavaScript 예외를 모두 사용합니다. 다음 섹션에서는 각 사례에 대한 접근 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1171e6e250c8137afa5e0b60938de57ff990d9c4" translate="yes" xml:space="preserve">
          <source>N-API values are represented by the type &lt;code&gt;napi_value&lt;/code&gt;. Any N-API call that requires a JavaScript value takes in a &lt;code&gt;napi_value&lt;/code&gt;. However, it's the caller's responsibility to make sure that the &lt;code&gt;napi_value&lt;/code&gt; in question is of the JavaScript type expected by the API.</source>
          <target state="translated">N-API 값은 &lt;code&gt;napi_value&lt;/code&gt; 유형으로 표시됩니다 . JavaScript 값이 필요한 N-API 호출은 &lt;code&gt;napi_value&lt;/code&gt; 를받습니다 . 그러나 해당 &lt;code&gt;napi_value&lt;/code&gt; 가 API에 필요한 JavaScript 유형 인지 확인하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="ed30e9f4e0aa475cc4bcf4606fa7aa3e116ab3a4" translate="yes" xml:space="preserve">
          <source>N-API values are represented by the type &lt;code&gt;napi_value&lt;/code&gt;. Any N-API call that requires a JavaScript value takes in a &lt;code&gt;napi_value&lt;/code&gt;. In some cases, the API does check the type of the &lt;code&gt;napi_value&lt;/code&gt; up-front. However, for better performance, it's better for the caller to make sure that the &lt;code&gt;napi_value&lt;/code&gt; in question is of the JavaScript type expected by the API.</source>
          <target state="translated">N-API 값은 &lt;code&gt;napi_value&lt;/code&gt; 유형으로 표시됩니다 . JavaScript 값이 필요한 N-API 호출은 &lt;code&gt;napi_value&lt;/code&gt; 를받습니다 . 경우에 따라 API는 &lt;code&gt;napi_value&lt;/code&gt; 의 유형을 사전에 확인합니다 . 그러나 성능을 향상 시키려면 호출자가 해당 &lt;code&gt;napi_value&lt;/code&gt; 가 API에서 예상하는 JavaScript 유형 인지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="af583d89de0c7c4b8c0e6223b8b144c689c84cc0" translate="yes" xml:space="preserve">
          <source>N-API version: 1</source>
          <target state="translated">N-API 버전 : 1</target>
        </trans-unit>
        <trans-unit id="42eb0bf2898c4d90751141d61f3a812907fc83bc" translate="yes" xml:space="preserve">
          <source>N-API version: 4</source>
          <target state="translated">N-API 버전 : 4</target>
        </trans-unit>
        <trans-unit id="36688c47c6b67b86c616353a7b6ea5bc6ef4edce" translate="yes" xml:space="preserve">
          <source>N-API versions are additive and versioned independently from Node.js. Version 4 is an extension to version 3 in that it has all of the APIs from version 3 with some additions. This means that it is not necessary to recompile for new versions of Node.js which are listed as supporting a later version.</source>
          <target state="translated">N-API 버전은 추가되며 Node.js와 독립적으로 버전이 지정됩니다. 버전 4는 버전 3의 모든 API가 추가되어 버전 3의 확장입니다. 즉, 이후 버전을 지원하는 것으로 나열된 새 버전의 Node.js를 다시 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="5ad766507b42c419a18a1fab4a93852992d6d506" translate="yes" xml:space="preserve">
          <source>Name of the file to which the report will be written.</source>
          <target state="translated">보고서가 작성 될 파일의 ​​이름입니다.</target>
        </trans-unit>
        <trans-unit id="cc22075ed2175ad5ccc2508aac2f833f87e45dda" translate="yes" xml:space="preserve">
          <source>Named: a simple UTF8-encoded string</source>
          <target state="translated">명명 : 간단한 UTF8 인코딩 문자열</target>
        </trans-unit>
        <trans-unit id="7137f503dc2584ea8280d497399006e247e659b7" translate="yes" xml:space="preserve">
          <source>Native Abstractions for Node.js</source>
          <target state="translated">Node.js의 기본 추상화</target>
        </trans-unit>
        <trans-unit id="edcea4b8da29480f402438959046ab2f9f368022" translate="yes" xml:space="preserve">
          <source>Native add-ons can only be loaded from multiple threads if they fulfill &lt;a href=&quot;addons#addons_worker_support&quot;&gt;certain conditions&lt;/a&gt;.</source>
          <target state="translated">기본 애드온은 &lt;a href=&quot;addons#addons_worker_support&quot;&gt;특정 조건&lt;/a&gt; 을 충족 하는 경우에만 여러 스레드에서로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6675537e94c99d143279098c166eb1d6147b5fc" translate="yes" xml:space="preserve">
          <source>Native addons may need to allocate global state of which they make use during their entire life cycle such that the state must be unique to each instance of the addon.</source>
          <target state="translated">기본 애드온은 전체 수명주기 동안 사용되는 글로벌 상태를 할당하여 상태가 애드온의 각 인스턴스에 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="264fa17f0716888a4cd2265fb034958375c3d60e" translate="yes" xml:space="preserve">
          <source>Negative &lt;code&gt;end&lt;/code&gt; values throw an &lt;code&gt;ERR_INDEX_OUT_OF_RANGE&lt;/code&gt; error.</source>
          <target state="translated">음수 &lt;code&gt;end&lt;/code&gt; 값은 &lt;code&gt;ERR_INDEX_OUT_OF_RANGE&lt;/code&gt; 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3ba80e45016258331008bc495a573c344a21c641" translate="yes" xml:space="preserve">
          <source>Neither the well known nor extra certificates are used when the &lt;code&gt;ca&lt;/code&gt; options property is explicitly specified for a TLS or HTTPS client or server.</source>
          <target state="translated">&lt;code&gt;ca&lt;/code&gt; 옵션 특성이 TLS 또는 HTTPS 클라이언트 또는 서버에 대해 명시 적으로 지정된 경우 잘 알려진 인증서 나 추가 인증서가 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb81c2eccbed59ee8cbe296f1278f0ca1f364cc" translate="yes" xml:space="preserve">
          <source>Net</source>
          <target state="translated">Net</target>
        </trans-unit>
        <trans-unit id="9d926a391a10419818faebd2c569e4c93c8a271b" translate="yes" xml:space="preserve">
          <source>New HTTP/2 Streams may not be opened after the &lt;code&gt;Http2Session&lt;/code&gt; has received a &lt;code&gt;GOAWAY&lt;/code&gt; frame from the connected peer.</source>
          <target state="translated">&lt;code&gt;Http2Session&lt;/code&gt; 이 연결된 피어로부터 &lt;code&gt;GOAWAY&lt;/code&gt; 프레임을 수신 한 후 새 HTTP / 2 스트림이 열리지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7193207627db5aaa3ebdacf110c6817d0cb0fe81" translate="yes" xml:space="preserve">
          <source>New applications should expect the default to be &lt;code&gt;'buffer'&lt;/code&gt;.</source>
          <target state="translated">새로운 응용 프로그램은 기본값이 &lt;code&gt;'buffer'&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="538dbd3921c4aa1f787f750bebace3312d5e5773" translate="yes" xml:space="preserve">
          <source>New instances of &lt;code&gt;dgram.Socket&lt;/code&gt; are created using &lt;a href=&quot;#dgram_dgram_createsocket_options_callback&quot;&gt;&lt;code&gt;dgram.createSocket()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;new&lt;/code&gt; keyword is not to be used to create &lt;code&gt;dgram.Socket&lt;/code&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;#dgram_dgram_createsocket_options_callback&quot;&gt; &lt;code&gt;dgram.createSocket()&lt;/code&gt; &lt;/a&gt; 사용하여 새 &lt;code&gt;dgram.Socket&lt;/code&gt; 인스턴스를 만듭니다 . &lt;code&gt;new&lt;/code&gt; 키워드를 만드는 데 사용하지 않을 &lt;code&gt;dgram.Socket&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="8286903a3b42f30c2845be65b9063df789c12e5a" translate="yes" xml:space="preserve">
          <source>New option &lt;code&gt;withFileTypes&lt;/code&gt; was added.</source>
          <target state="translated">&lt;code&gt;withFileTypes&lt;/code&gt; 새로운 옵션 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc072aabd2bae6e9c49b6e900e7612de2b36503a" translate="yes" xml:space="preserve">
          <source>Next, invoke the &lt;code&gt;node-gyp build&lt;/code&gt; command to generate the compiled &lt;code&gt;addon.node&lt;/code&gt; file. This will be put into the &lt;code&gt;build/Release/&lt;/code&gt; directory.</source>
          <target state="translated">그런 다음 &lt;code&gt;node-gyp build&lt;/code&gt; 명령을 호출하여 컴파일 된 &lt;code&gt;addon.node&lt;/code&gt; 파일 을 생성 하십시오. 이것은 &lt;code&gt;build/Release/&lt;/code&gt; 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="60c6db9ea82d2e5e907d48b09a58571de5491306" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;#stream_event_data&quot;&gt;&lt;code&gt;'data'&lt;/code&gt;&lt;/a&gt; event listener is added.</source>
          <target state="translated">&lt;a href=&quot;#stream_event_data&quot;&gt; &lt;code&gt;'data'&lt;/code&gt; &lt;/a&gt; 이벤트 리스너가 추가 되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="7713480c15dd839650512046c796bdd1e22142e3" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;NODE_PATH&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NODE_PATH&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="4e365ecb80d6c5e0aee9009ce4f7cb44fc85a412" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require.cache&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require.cache&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="5fdcf81df39a04935671e5f913e82a9ed67ac793" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require.extensions&lt;/code&gt;</source>
          <target state="translated">어떤 &lt;code&gt;require.extensions&lt;/code&gt; 없습니다</target>
        </trans-unit>
        <trans-unit id="73bd086942e812ae818e7cbfbd123ebe5c91a9cf" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module.exports&lt;/code&gt;, &lt;code&gt;__filename&lt;/code&gt;, &lt;code&gt;__dirname&lt;/code&gt;</source>
          <target state="translated">아니 &lt;code&gt;require&lt;/code&gt; , &lt;code&gt;exports&lt;/code&gt; , &lt;code&gt;module.exports&lt;/code&gt; , &lt;code&gt;__filename&lt;/code&gt; , &lt;code&gt;__dirname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d424da21bf8bf374cdfa3070439b63b71a40f17e" translate="yes" xml:space="preserve">
          <source>No Error</source>
          <target state="translated">오류 없음</target>
        </trans-unit>
        <trans-unit id="7d617594d209195a47bc9a68e67dac23de396ed7" translate="yes" xml:space="preserve">
          <source>No case conversion is performed on case-insensitive file systems.</source>
          <target state="translated">대소 문자를 구분하지 않는 파일 시스템에서는 대소 문자 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3331168b9cff4f62863ed956ba7c063dc1e66ff" translate="yes" xml:space="preserve">
          <source>No decoding of the &lt;code&gt;path&lt;/code&gt; is performed.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 디코딩 이 수행 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a6ddfb774d5f9c27c27174db32faeb0af1ec6da" translate="yes" xml:space="preserve">
          <source>No decoding of the path string is performed.</source>
          <target state="translated">경로 문자열의 디코딩이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13c8ff0aedccedab26b0a9cc20907ad8d12092c6" translate="yes" xml:space="preserve">
          <source>No decoding of the query string is performed.</source>
          <target state="translated">쿼리 문자열의 디코딩이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a03f0fd922f89467f81c73b168c18f01a6802039" translate="yes" xml:space="preserve">
          <source>No default extensions</source>
          <target state="translated">기본 확장명 없음</target>
        </trans-unit>
        <trans-unit id="927a7432a2380470b398b68e7bf815a0c092cf92" translate="yes" xml:space="preserve">
          <source>No folder mains</source>
          <target state="translated">폴더 메인 없음</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="b0b78d39dcf9723cadf7c92f189fafd553d14144" translate="yes" xml:space="preserve">
          <source>Node.js (and its underlying V8 engine) uses &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; to implement these features in native C/C++ code. However, some of them require a very large ICU data file in order to support all locales of the world. Because it is expected that most Node.js users will make use of only a small portion of ICU functionality, only a subset of the full ICU data set is provided by Node.js by default. Several options are provided for customizing and expanding the ICU data set either when building or running Node.js.</source>
          <target state="translated">Node.js (및 기본 V8 엔진)는 &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU&lt;/a&gt; 를 사용 하여 이러한 기능을 기본 C / C ++ 코드로 구현합니다. 그러나 일부는 전 세계 모든 로케일을 지원하기 위해 매우 큰 ICU 데이터 파일이 필요합니다. 대부분의 Node.js 사용자는 ICU 기능의 일부만 사용할 것으로 예상되므로 기본적으로 전체 ICU 데이터 세트의 서브 세트 만 Node.js에 의해 제공됩니다. Node.js를 빌드하거나 실행할 때 ICU 데이터 세트를 사용자 정의하고 확장하기위한 여러 옵션이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a4c6ff3487c288f0b8d40123f15c094451d4d58d" translate="yes" xml:space="preserve">
          <source>Node.js Addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using the &lt;a href=&quot;modules#modules_require_id&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; function, and used just as if they were an ordinary Node.js module. They are used primarily to provide an interface between JavaScript running in Node.js and C/C++ libraries.</source>
          <target state="translated">Node.js 애드온은 C ++로 작성된 동적으로 연결된 공유 객체로 &lt;a href=&quot;modules#modules_require_id&quot;&gt; &lt;code&gt;require()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Node.js에로드 할 수 있으며 일반 Node.js 모듈처럼 사용할 수 있습니다. 주로 Node.js에서 실행되는 JavaScript와 C / C ++ 라이브러리 간의 인터페이스를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51be1c370c336ba5619c2e9080dd4bf368c9c46b" translate="yes" xml:space="preserve">
          <source>Node.js Crypto Constants</source>
          <target state="translated">Node.js 암호화 상수</target>
        </trans-unit>
        <trans-unit id="441aa6a1425f4454daa77eeba4c8ce3a18045fb8" translate="yes" xml:space="preserve">
          <source>Node.js Error Codes</source>
          <target state="translated">Node.js 오류 코드</target>
        </trans-unit>
        <trans-unit id="179df0cc5008db133b8bc9a59310d37319853e06" translate="yes" xml:space="preserve">
          <source>Node.js can be started using the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; command line option to cause all newly allocated &lt;code&gt;Buffer&lt;/code&gt; instances to be zero-filled upon creation by default. Before Node.js 8.0.0, this included buffers allocated by &lt;code&gt;new Buffer(size)&lt;/code&gt;. Since Node.js 8.0.0, buffers allocated with &lt;code&gt;new&lt;/code&gt; are always zero-filled, whether this option is used or not. &lt;a href=&quot;#buffer_class_method_buffer_allocunsafe_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#buffer_class_method_buffer_allocunsafeslow_size&quot;&gt;&lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;new SlowBuffer(size)&lt;/code&gt;. Use of this flag can have a significant negative impact on performance. Use of the &lt;code&gt;--zero-fill-buffers&lt;/code&gt; option is recommended only when necessary to enforce that newly allocated &lt;code&gt;Buffer&lt;/code&gt; instances cannot contain old data that is potentially sensitive.</source>
          <target state="translated">Node.js는 &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 명령 행 옵션을 사용하여 시작하여 기본적으로 새로 할당 된 모든 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스가 0으로 채워지도록 할 수 있습니다. Node.js 8.0.0 이전에는 &lt;code&gt;new Buffer(size)&lt;/code&gt; 의해 할당 된 버퍼가 포함되었습니다 . Node.js 8.0.0부터 &lt;code&gt;new&lt;/code&gt; 로 할당 된 버퍼 는이 옵션의 사용 여부에 관계없이 항상 0으로 채워집니다. &lt;a href=&quot;#buffer_class_method_buffer_allocunsafe_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#buffer_class_method_buffer_allocunsafeslow_size&quot;&gt; &lt;code&gt;Buffer.allocUnsafeSlow()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;new SlowBuffer(size)&lt;/code&gt; . 이 플래그를 사용하면 성능에 상당한 부정적인 영향을 줄 수 있습니다. 의 사용 &lt;code&gt;--zero-fill-buffers&lt;/code&gt; 옵션은 새로 할당 적용 할 경우에만 필요한 것이 좋습니다 &lt;code&gt;Buffer&lt;/code&gt; 인스턴스는 잠재적으로 민감한 오래된 데이터를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2f1a7ae4eec5392042ce17901f72140ba89d819" translate="yes" xml:space="preserve">
          <source>Node.js can link against an ICU build already installed on the system. In fact, most Linux distributions already come with ICU installed, and this option would make it possible to reuse the same set of data used by other components in the OS.</source>
          <target state="translated">Node.js는 시스템에 이미 설치된 ICU 빌드에 연결할 수 있습니다. 실제로 대부분의 Linux 배포에는 이미 ICU가 설치되어 제공되며이 옵션을 사용하면 OS의 다른 구성 요소에서 사용하는 것과 동일한 데이터 집합을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5810ddd39bdfe4323cf379ac3f7b781e60db98e0" translate="yes" xml:space="preserve">
          <source>Node.js comes with a variety of CLI options. These options expose built-in debugging, multiple ways to execute scripts, and other helpful runtime options.</source>
          <target state="translated">Node.js는 다양한 CLI 옵션과 함께 제공됩니다. 이러한 옵션은 내장 디버깅, 스크립트를 실행하는 여러 가지 방법 및 기타 유용한 런타임 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="700f33732d1ab659fda7ca90f224da1753e7cde0" translate="yes" xml:space="preserve">
          <source>Node.js contains experimental support for creating policies on loading code.</source>
          <target state="translated">Node.js에는 코드로드에 대한 정책 작성을위한 실험적인 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994583ed9ea64b95980a99b8ac9cb934c0c8136" translate="yes" xml:space="preserve">
          <source>Node.js contains support for ES Modules based upon the &lt;a href=&quot;https://github.com/nodejs/node-eps/blob/master/002-es-modules.md&quot;&gt;Node.js EP for ES Modules&lt;/a&gt; and the &lt;a href=&quot;https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md&quot;&gt;ECMAScript-modules implementation&lt;/a&gt;.</source>
          <target state="translated">Node.js에는 &lt;a href=&quot;https://github.com/nodejs/node-eps/blob/master/002-es-modules.md&quot;&gt;Node.js EP for ES Modules&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/nodejs/modules/blob/master/doc/plan-for-new-modules-implementation.md&quot;&gt;ECMAScript-modules 구현을&lt;/a&gt; 기반으로하는 ES Modules 지원이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f284dbd956cb499dff05c1a4c98369975a26484c" translate="yes" xml:space="preserve">
          <source>Node.js currently overwrites &lt;code&gt;argv[0]&lt;/code&gt; with &lt;code&gt;process.execPath&lt;/code&gt; on startup, so &lt;code&gt;process.argv[0]&lt;/code&gt; in a Node.js child process will not match the &lt;code&gt;argv0&lt;/code&gt; parameter passed to &lt;code&gt;spawn&lt;/code&gt; from the parent, retrieve it with the &lt;code&gt;process.argv0&lt;/code&gt; property instead.</source>
          <target state="translated">Node.js는 현재 시작시 &lt;code&gt;process.execPath&lt;/code&gt; 로 &lt;code&gt;argv[0]&lt;/code&gt; 을 겹쳐 쓰므 로 Node.js 하위 프로세스의 &lt;code&gt;process.argv[0]&lt;/code&gt; 은 상위에서 &lt;code&gt;spawn&lt;/code&gt; 되도록 전달 된 &lt;code&gt;argv0&lt;/code&gt; 매개 변수 와 일치하지 않으므로 &lt;code&gt;process.argv0&lt;/code&gt; 으로 검색하십시오. 대신 속성.</target>
        </trans-unit>
        <trans-unit id="71f1ec4dc71d40c8c7d0a68270209a7d73533f56" translate="yes" xml:space="preserve">
          <source>Node.js does not check whether Content-Length and the length of the body which has been transmitted are equal or not.</source>
          <target state="translated">Node.js는 Content-Length와 전송 된 본문의 길이가 같은지 여부를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06e7f421afd071d9d6af3f9498e9ce444a8edad0" translate="yes" xml:space="preserve">
          <source>Node.js does not provide routing logic. It is, therefore important to design an application such that it does not rely too heavily on in-memory data objects for things like sessions and login.</source>
          <target state="translated">Node.js는 라우팅 로직을 제공하지 않습니다. 따라서 세션 및 로그인과 같은 인 메모리 데이터 개체에 너무 의존하지 않도록 응용 프로그램을 디자인하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="59620f5a7d966f7ed19e56a82fa67f4d669f5bf7" translate="yes" xml:space="preserve">
          <source>Node.js establishes signal handlers for &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGTERM&lt;/code&gt; and Node.js processes will not terminate immediately due to receipt of those signals. Rather, Node.js will perform a sequence of cleanup actions and then will re-raise the handled signal.</source>
          <target state="translated">Node.js는 &lt;code&gt;SIGINT&lt;/code&gt; 및 &lt;code&gt;SIGTERM&lt;/code&gt; 에 대한 신호 처리기를 설정 하며 Node.js 프로세스는 이러한 신호를 수신하여 즉시 종료되지 않습니다. 오히려 Node.js는 일련의 정리 작업을 수행 한 다음 처리 된 신호를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b03b3b5fea382e76a7a57c11964832d9a8b669da" translate="yes" xml:space="preserve">
          <source>Node.js fully supports ECMAScript modules as they are currently specified and provides limited interoperability between them and the existing module format, &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt;.</source>
          <target state="translated">Node.js는 현재 지정되어있는 ECMAScript 모듈을 완벽하게 지원하며 모듈과 기존 모듈 형식 인 &lt;a href=&quot;modules&quot;&gt;CommonJS&lt;/a&gt; 간의 제한된 상호 운용성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d9420a48ed10cc5802fa3b78bba7653131bf1a8e" translate="yes" xml:space="preserve">
          <source>Node.js generates system errors when exceptions occur within its runtime environment. These usually occur when an application violates an operating system constraint. For example, a system error will occur if an application attempts to read a file that does not exist.</source>
          <target state="translated">런타임 환경에서 예외가 발생하면 Node.js가 시스템 오류를 생성합니다. 일반적으로 응용 프로그램이 운영 체제 제약 조건을 위반할 때 발생합니다. 예를 들어, 응용 프로그램이 존재하지 않는 파일을 읽으려고하면 시스템 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0cd156f333656194d6d4ee97e4372a26119bd21" translate="yes" xml:space="preserve">
          <source>Node.js has many features that make it easier to write internationalized programs. Some of them are:</source>
          <target state="translated">Node.js에는 국제화 된 프로그램을보다 쉽게 ​​작성할 수있는 많은 기능이 있습니다. 그들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195eccef86c70efe3ada3da5e4f20eea967db8b4" translate="yes" xml:space="preserve">
          <source>Node.js has several modules compiled into the binary. These modules are described in greater detail elsewhere in this documentation.</source>
          <target state="translated">Node.js에는 바이너리로 컴파일 된 여러 모듈이 있습니다. 이 모듈들은이 문서의 다른 곳에서 더 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d67c8f1728279b2419e85378220842f097aa2a" translate="yes" xml:space="preserve">
          <source>Node.js includes a number of other statically linked libraries including OpenSSL. These other libraries are located in the &lt;code&gt;deps/&lt;/code&gt; directory in the Node.js source tree. Only the libuv, OpenSSL, V8 and zlib symbols are purposefully re-exported by Node.js and may be used to various extents by Addons. See &lt;a href=&quot;#addons_linking_to_node_js_own_dependencies&quot;&gt;Linking to Node.js' own dependencies&lt;/a&gt; for additional information.</source>
          <target state="translated">Node.js에는 OpenSSL을 비롯한 여러 정적으로 링크 된 라이브러리가 포함되어 있습니다. 이러한 다른 라이브러리는 Node.js 소스 트리 의 &lt;code&gt;deps/&lt;/code&gt; 디렉토리에 있습니다. libuv, OpenSSL, V8 및 zlib 기호 만 Node.js에 의해 의도적으로 다시 내보내지고 애드온에 의해 다양한 범위로 사용될 수 있습니다. 추가 정보는 &lt;a href=&quot;#addons_linking_to_node_js_own_dependencies&quot;&gt;Node.js 자체 종속성&lt;/a&gt; 에 링크를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4002058c11230c8c613d48125799d611e8e5ab90" translate="yes" xml:space="preserve">
          <source>Node.js includes an out-of-process debugging utility accessible via a &lt;a href=&quot;#debugger_v8_inspector_integration_for_node_js&quot;&gt;V8 Inspector&lt;/a&gt; and built-in debugging client. To use it, start Node.js with the &lt;code&gt;inspect&lt;/code&gt; argument followed by the path to the script to debug; a prompt will be displayed indicating successful launch of the debugger:</source>
          <target state="translated">Node.js에는 &lt;a href=&quot;#debugger_v8_inspector_integration_for_node_js&quot;&gt;V8 인스펙터&lt;/a&gt; 및 내장 디버깅 클라이언트 를 통해 액세스 할 수있는 프로세스 외부 디버깅 유틸리티가 포함되어 있습니다 . 이를 사용하려면, &lt;code&gt;inspect&lt;/code&gt; 인수 와 함께 디버깅 할 스크립트 경로로 Node.js를 시작하십시오 . 디버거가 성공적으로 시작되었음을 알리는 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f9aede62d41177b7855358a4024583daeb12072" translate="yes" xml:space="preserve">
          <source>Node.js inspector supports all the Chrome DevTools Protocol domains declared by V8. Chrome DevTools Protocol domain provides an interface for interacting with one of the runtime agents used to inspect the application state and listen to the run-time events.</source>
          <target state="translated">Node.js 인스펙터는 V8에서 선언 한 모든 Chrome DevTools 프로토콜 도메인을 지원합니다. Chrome DevTools 프로토콜 도메인은 애플리케이션 상태를 검사하고 런타임 이벤트를 청취하는 데 사용되는 런타임 에이전트 중 하나와 상호 작용하기위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9b8c531580042ddb6a9c8b040b19ffbdbcdd1525" translate="yes" xml:space="preserve">
          <source>Node.js is a trademark of Joyent, Inc. and is used with its permission.</source>
          <target state="translated">Node.js는 Joyent, Inc.의 상표이며 허가를 받아 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f38a0ebf21cebf178508d7332d871c116478b9e4" translate="yes" xml:space="preserve">
          <source>Node.js is built with a default suite of enabled and disabled TLS ciphers. Currently, the default cipher suite is:</source>
          <target state="translated">Node.js는 활성화 및 비활성화 된 TLS 암호의 기본 제품군으로 빌드됩니다. 현재 기본 암호 제품군은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d419b29bddd025ae8da2d1cd92469cb932388b2a" translate="yes" xml:space="preserve">
          <source>Node.js itself uses the &lt;code&gt;repl&lt;/code&gt; module to provide its own interactive interface for executing JavaScript. This can be used by executing the Node.js binary without passing any arguments (or by passing the &lt;code&gt;-i&lt;/code&gt; argument):</source>
          <target state="translated">Node.js 자체는 &lt;code&gt;repl&lt;/code&gt; 모듈을 사용하여 JavaScript 실행을위한 자체 대화식 인터페이스를 제공합니다. 인수를 전달하지 않고 Node.js 바이너리를 실행하거나 &lt;code&gt;-i&lt;/code&gt; 인수 를 전달하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f09bc63e6e483ddf848817dae917ca441f8c70d6" translate="yes" xml:space="preserve">
          <source>Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests.</source>
          <target state="translated">Node.js는 서버 당 여러 개의 연결을 유지하여 HTTP 요청을합니다. 이 기능을 사용하면 요청을 투명하게 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef83fb721ff96281b3ffd2a1bcbc9e428f3194ea" translate="yes" xml:space="preserve">
          <source>Node.js makes no guarantees about the atomicity of the copy operation. If an error occurs after the destination file has been opened for writing, Node.js will attempt to remove the destination.</source>
          <target state="translated">Node.js는 복사 작업의 원 자성을 보증하지 않습니다. 대상 파일을 쓰기 위해 연 후 오류가 발생하면 Node.js가 대상 제거를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5a2313c41832d43d1e319cb20bebf01ebb24487d" translate="yes" xml:space="preserve">
          <source>Node.js may deprecate APIs for any of the following reasons:</source>
          <target state="translated">Node.js는 다음과 같은 이유로 API를 더 이상 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6a49596101ad1c6c0a10180ddfbbd5d2267fc0" translate="yes" xml:space="preserve">
          <source>Node.js options that are allowed are:</source>
          <target state="translated">허용되는 Node.js 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="138fea06dce092e1d24f06c81c94c22277dd9c70" translate="yes" xml:space="preserve">
          <source>Node.js processes launched with a custom &lt;code&gt;execPath&lt;/code&gt; will communicate with the parent process using the file descriptor (fd) identified using the environment variable &lt;code&gt;NODE_CHANNEL_FD&lt;/code&gt; on the child process.</source>
          <target state="translated">사용자 정의 &lt;code&gt;execPath&lt;/code&gt; 로 시작된 Node.js 프로세스는 하위 프로세스에서 환경 변수 &lt;code&gt;NODE_CHANNEL_FD&lt;/code&gt; 를 사용하여 식별 된 파일 디스크립터 (fd)를 사용하여 상위 프로세스와 통신 합니다.</target>
        </trans-unit>
        <trans-unit id="5196287aca961808313ef47efa5a6a6078aaae9f" translate="yes" xml:space="preserve">
          <source>Node.js supports several mechanisms for propagating and handling errors that occur while an application is running. How these errors are reported and handled depends entirely on the type of &lt;code&gt;Error&lt;/code&gt; and the style of the API that is called.</source>
          <target state="translated">Node.js는 애플리케이션이 실행되는 동안 발생하는 오류를 전파하고 처리하기위한 여러 메커니즘을 지원합니다. 이러한 오류가보고되고 처리되는 방법은 전적으로 &lt;code&gt;Error&lt;/code&gt; 유형 과 호출 된 API 스타일에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="02f6a2adac24b09ba48add96ffd834e0b65b5a81" translate="yes" xml:space="preserve">
          <source>Node.js used to support all GCM authentication tag lengths which are accepted by OpenSSL when calling &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer&quot;&gt;&lt;code&gt;decipher.setAuthTag()&lt;/code&gt;&lt;/a&gt;. Beginning with Node.js v11.0.0, only authentication tag lengths of 128, 120, 112, 104, 96, 64, and 32 bits are allowed. Authentication tags of other lengths are invalid per &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D&lt;/a&gt;.</source>
          <target state="translated">Node.js는 &lt;a href=&quot;crypto#crypto_decipher_setauthtag_buffer&quot;&gt; &lt;code&gt;decipher.setAuthTag()&lt;/code&gt; &lt;/a&gt; 호출 할 때 OpenSSL에서 허용하는 모든 GCM 인증 태그 길이를 지원하는 데 사용되었습니다 . Node.js v11.0.0부터는 128, 120, 112, 104, 96, 64 및 32 비트의 인증 태그 길이 만 허용됩니다. 다른 길이의 인증 태그는 &lt;a href=&quot;https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf&quot;&gt;NIST SP 800-38D에&lt;/a&gt; 따라 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2f9b6124a3880fa2afa106c7ef712fc837b2b911" translate="yes" xml:space="preserve">
          <source>Node.js uses a &lt;code&gt;KeyObject&lt;/code&gt; class to represent a symmetric or asymmetric key, and each kind of key exposes different functions. The &lt;a href=&quot;#crypto_crypto_createsecretkey_key&quot;&gt;&lt;code&gt;crypto.createSecretKey()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt;&lt;code&gt;crypto.createPublicKey()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt;&lt;code&gt;crypto.createPrivateKey()&lt;/code&gt;&lt;/a&gt; methods are used to create &lt;code&gt;KeyObject&lt;/code&gt; instances. &lt;code&gt;KeyObject&lt;/code&gt; objects are not to be created directly using the &lt;code&gt;new&lt;/code&gt; keyword.</source>
          <target state="translated">Node.js는 &lt;code&gt;KeyObject&lt;/code&gt; 클래스를 사용하여 대칭 또는 비대칭 키를 나타내며 각 키 종류는 서로 다른 기능을 제공합니다. &lt;a href=&quot;#crypto_crypto_createsecretkey_key&quot;&gt; &lt;code&gt;crypto.createSecretKey()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#crypto_crypto_createpublickey_key&quot;&gt; &lt;code&gt;crypto.createPublicKey()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#crypto_crypto_createprivatekey_key&quot;&gt; &lt;code&gt;crypto.createPrivateKey()&lt;/code&gt; &lt;/a&gt; 메소드를 만드는 데 사용되는 &lt;code&gt;KeyObject&lt;/code&gt; 의 인스턴스. &lt;code&gt;new&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;KeyObject&lt;/code&gt; 객체를 직접 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="38c8c1daba3fd0b1fc631a3c4423fc53da9f7c2d" translate="yes" xml:space="preserve">
          <source>Node.js uses a number of statically linked libraries such as V8, libuv and OpenSSL. All Addons are required to link to V8 and may link to any of the other dependencies as well. Typically, this is as simple as including the appropriate &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; statements (e.g. &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt;) and &lt;code&gt;node-gyp&lt;/code&gt; will locate the appropriate headers automatically. However, there are a few caveats to be aware of:</source>
          <target state="translated">Node.js는 V8, libuv 및 OpenSSL과 같은 여러 정적으로 링크 된 라이브러리를 사용합니다. 모든 애드온은 V8에 연결해야하며 다른 종속 항목에도 연결될 수 있습니다. 일반적으로 이것은 적절한 &lt;code&gt;#include &amp;lt;...&amp;gt;&lt;/code&gt; 문 (예 : &lt;code&gt;#include &amp;lt;v8.h&amp;gt;&lt;/code&gt; ) 을 포함하는 것만 큼 간단 하며 &lt;code&gt;node-gyp&lt;/code&gt; 은 적절한 헤더를 자동으로 찾습니다. 그러나 알아야 할 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc44a7efe4f28833703418200a1bb5df5098eb3" translate="yes" xml:space="preserve">
          <source>Node.js utilizes three kinds of Deprecations:</source>
          <target state="translated">Node.js는 세 종류의 지원 중단을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a46a838b1cdedce2bf909aec9c2762a50a63df17" translate="yes" xml:space="preserve">
          <source>Node.js was compiled without &lt;code&gt;scrypt&lt;/code&gt; support. Not possible with the official release binaries but can happen with custom builds, including distro builds.</source>
          <target state="translated">Node.js는 &lt;code&gt;scrypt&lt;/code&gt; 지원 없이 컴파일되었습니다 . 공식 릴리스 바이너리로는 가능하지 않지만 배포 빌드를 포함하여 사용자 정의 빌드에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2be6c44f29011482418546ee57fd088cf4e02101" translate="yes" xml:space="preserve">
          <source>Node.js was unable to watch for the &lt;code&gt;SIGINT&lt;/code&gt; signal.</source>
          <target state="translated">Node.js가 &lt;code&gt;SIGINT&lt;/code&gt; 신호 를 감시 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7aaa445f322cc3682bfe7bf5c6b4e24edfb5f0d7" translate="yes" xml:space="preserve">
          <source>Node.js will generate and throw &lt;code&gt;RangeError&lt;/code&gt; instances &lt;em&gt;immediately&lt;/em&gt; as a form of argument validation.</source>
          <target state="translated">Node.js는 &lt;code&gt;RangeError&lt;/code&gt; 인스턴스 를 인수 유효성 검사의 형태로 &lt;em&gt;즉시&lt;/em&gt; 생성하고 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="8a136533538960fd36c0a7d5584874bcb8bdd70d" translate="yes" xml:space="preserve">
          <source>Node.js will generate and throw &lt;code&gt;TypeError&lt;/code&gt; instances &lt;em&gt;immediately&lt;/em&gt; as a form of argument validation.</source>
          <target state="translated">Node.js는 인수 유효성 검사의 형태로 &lt;em&gt;즉시 &lt;/em&gt; &lt;code&gt;TypeError&lt;/code&gt; 인스턴스를 생성하고 throw 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86b0b7269fa723a49aa2197764257f8d6198ae0b" translate="yes" xml:space="preserve">
          <source>Node.js will normally exit with a &lt;code&gt;0&lt;/code&gt; status code when no more async operations are pending. The following status codes are used in other cases:</source>
          <target state="translated">더 이상 비동기 작업이 보류되지 않으면 Node.js는 일반적으로 &lt;code&gt;0&lt;/code&gt; 상태 코드로 종료됩니다 . 다른 경우에는 다음 상태 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d156462ec2e4a54246399867711ae97a6c34c54" translate="yes" xml:space="preserve">
          <source>Node.js will treat as CommonJS all other forms of input, such as &lt;code&gt;.js&lt;/code&gt; files where the nearest parent &lt;code&gt;package.json&lt;/code&gt; file contains no top-level &lt;code&gt;&quot;type&quot;&lt;/code&gt; field, or string input without the flag &lt;code&gt;--input-type&lt;/code&gt;. This behavior is to preserve backward compatibility. However, now that Node.js supports both CommonJS and ES modules, it is best to be explicit whenever possible. Node.js will treat the following as CommonJS when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">Node.js는 가장 가까운 상위 &lt;code&gt;package.json&lt;/code&gt; 파일에 최상위 &lt;code&gt;&quot;type&quot;&lt;/code&gt; 필드가 없거나 &lt;code&gt;--input-type&lt;/code&gt; 플래그가없는 문자열 입력이있는 &lt;code&gt;.js&lt;/code&gt; 파일 과 같은 다른 모든 유형의 입력을 CommonJS로 취급 합니다 . 이 동작은 이전 버전과의 호환성을 유지하기위한 것입니다. 그러나 Node.js는 CommonJS 및 ES 모듈을 모두 지원하므로 가능할 때마다 명시하는 것이 가장 좋습니다. Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 CommonJS로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="2745ff23353f08077c9763af60cfd72843015ebb" translate="yes" xml:space="preserve">
          <source>Node.js's debugger client is not a full-featured debugger, but simple step and inspection are possible.</source>
          <target state="translated">Node.js의 디버거 클라이언트는 모든 기능을 갖춘 디버거는 아니지만 간단한 단계 및 검사가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ac1013f374841b5452514d4b8359e7422406574b" translate="yes" xml:space="preserve">
          <source>Non-finite number values (&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;+Infinity&lt;/code&gt;, or &lt;code&gt;-Infinity&lt;/code&gt;) set the result to zero.</source>
          <target state="translated">무한 수가 아닌 값 ( &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+Infinity&lt;/code&gt; 또는 &lt;code&gt;-Infinity&lt;/code&gt; )은 결과를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7d5e643747b3ffedc83ffcb3b71cbc3c5585ca03" translate="yes" xml:space="preserve">
          <source>Not all constants will be available on every operating system.</source>
          <target state="translated">모든 운영 체제에서 모든 상수를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4436debc55754f82e9d430eaa05339b900fd927e" translate="yes" xml:space="preserve">
          <source>Not every constant will be available on every operating system.</source>
          <target state="translated">모든 운영 체제에서 모든 상수를 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="549ab44d98603b37017112009e5442a545e8a373" translate="yes" xml:space="preserve">
          <source>Not exported by the &lt;code&gt;zlib&lt;/code&gt; module. It is documented here because it is the base class of the compressor/decompressor classes.</source>
          <target state="translated">&lt;code&gt;zlib&lt;/code&gt; 모듈에서 내 보내지 않았습니다 . 컴프레서 / 디 컴프레서 클래스의 기본 클래스이므로 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf19ed98b0dffdc4b322b922e2a0a394c9f67eab" translate="yes" xml:space="preserve">
          <source>Not handling &lt;code&gt;Promise&lt;/code&gt; rejections is deprecated.</source>
          <target state="translated">처리하지 않음 &lt;code&gt;Promise&lt;/code&gt; 거부는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f471ec3f86ad87114b1805cf0ff78e30f33eee3" translate="yes" xml:space="preserve">
          <source>Not listening to this event no longer causes the socket to be destroyed if a client sends an Upgrade header.</source>
          <target state="translated">이 이벤트를 수신하지 않으면 클라이언트가 Upgrade 헤더를 보내도 더 이상 소켓이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d73f792bf4588a09b4c61304ecd28cf0baf02107" translate="yes" xml:space="preserve">
          <source>Notable differences inside a Worker environment are:</source>
          <target state="translated">작업자 환경 내에서 주목할만한 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="580765b00e88c3ab1fc90c8c0303dbfa89b6d16c" translate="yes" xml:space="preserve">
          <source>Note it is &lt;em&gt;not&lt;/em&gt; necessary to use &lt;code&gt;napi_make_callback&lt;/code&gt; from within a &lt;code&gt;napi_async_complete_callback&lt;/code&gt;; in that situation the callback's async context has already been set up, so a direct call to &lt;code&gt;napi_call_function&lt;/code&gt; is sufficient and appropriate. Use of the &lt;code&gt;napi_make_callback&lt;/code&gt; function may be required when implementing custom async behavior that does not use &lt;code&gt;napi_create_async_work&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;napi_make_callback&lt;/code&gt; 내에서 &lt;code&gt;napi_async_complete_callback&lt;/code&gt; 을 사용할 필요 는 &lt;em&gt;없습니다&lt;/em&gt; . 이 상황에서 콜백의 비동기 컨텍스트가 이미 설정 &lt;code&gt;napi_call_function&lt;/code&gt; 대한 직접 호출 이면 충분합니다. 의 사용 &lt;code&gt;napi_make_callback&lt;/code&gt; 의 사용하지 않는 사용자 정의 비동기 동작을 구현할 때 함수가 필요할 수 있습니다 &lt;code&gt;napi_create_async_work&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d6e41c1622948c03f6ca8311eb8aef26b223ccf0" translate="yes" xml:space="preserve">
          <source>Note, however, that using &lt;code&gt;--preserve-symlinks&lt;/code&gt; can have other side effects. Specifically, symbolically linked &lt;em&gt;native&lt;/em&gt; modules can fail to load if those are linked from more than one location in the dependency tree (Node.js would see those as two separate modules and would attempt to load the module multiple times, causing an exception to be thrown).</source>
          <target state="translated">그러나 &lt;code&gt;--preserve-symlinks&lt;/code&gt; 를 사용하면 다른 부작용이있을 수 있습니다. 특히 심볼 트리로 연결된 &lt;em&gt;네이티브&lt;/em&gt; 모듈이 종속성 트리에서 둘 이상의 위치에서 링크 된 경우로드하지 못할 수 있습니다 (Node.js는 해당 모듈을 두 개의 개별 모듈로보고 모듈을 여러 번로드하려고 시도하여 예외가 발생 함) ).</target>
        </trans-unit>
        <trans-unit id="972cb08f7fa7ede61014198194e4bb40a809cbac" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;getSession()&lt;/code&gt; works only for TLSv1.2 and below. For TLSv1.3, applications must use the &lt;a href=&quot;#tls_event_session&quot;&gt;&lt;code&gt;'session'&lt;/code&gt;&lt;/a&gt; event (it also works for TLSv1.2 and below).</source>
          <target state="translated">참고 : &lt;code&gt;getSession()&lt;/code&gt; 은 TLSv1.2 이하에서만 작동합니다. TLSv1.3의 경우 애플리케이션은 &lt;a href=&quot;#tls_event_session&quot;&gt; &lt;code&gt;'session'&lt;/code&gt; &lt;/a&gt; 이벤트를 사용해야합니다 (TLSv1.2 이하에서도 작동 함).</target>
        </trans-unit>
        <trans-unit id="ecd844f1014ce393ccf5d8fffcaf8b96adac6bf1" translate="yes" xml:space="preserve">
          <source>Note: &lt;em&gt;specifier&lt;/em&gt; is now a bare specifier.</source>
          <target state="translated">주 : &lt;em&gt;지정&lt;/em&gt; 자는 이제 베어 지정자입니다.</target>
        </trans-unit>
        <trans-unit id="01f9d22189eec14674a459713bb8e39e51c5a5c9" translate="yes" xml:space="preserve">
          <source>Note: For TLSv1.2 and below, &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt;&lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt;&lt;/a&gt; can be called once the handshake is complete. For TLSv1.3, only ticket based resumption is allowed by the protocol, multiple tickets are sent, and the tickets aren't sent until later, after the handshake completes, so it is necessary to wait for the &lt;code&gt;'session'&lt;/code&gt; event to get a resumable session. Applications are recommended to use the &lt;code&gt;'session'&lt;/code&gt; event instead of &lt;code&gt;getSession()&lt;/code&gt; to ensure they will work for all TLS protocol versions. Applications that only expect to get or use 1 session should listen for this event only once:</source>
          <target state="translated">참고 : TLSv1.2 이하의 경우 핸드 셰이크가 완료되면 &lt;a href=&quot;#tls_tlssocket_getsession&quot;&gt; &lt;code&gt;tls.TLSSocket.getSession()&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다. TLSv1.3의 경우 프로토콜에서 티켓 기반 재개 만 허용하고 여러 티켓이 전송되며 핸드 셰이크가 완료된 후 나중에 티켓이 전송되지 않으므로 &lt;code&gt;'session'&lt;/code&gt; 이벤트 가 완료 될 때까지 기다려야합니다 . 재개 가능한 세션. 애플리케이션은 모든 TLS 프로토콜 버전에서 작동하도록 &lt;code&gt;getSession()&lt;/code&gt; 대신 &lt;code&gt;'session'&lt;/code&gt; 이벤트 를 사용하는 것이 좋습니다 . 1 세션 만 가져 오거나 사용할 것으로 예상되는 응용 프로그램은이 이벤트를 한 번만 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8cc0b60938c91b13e1400e17c52a12ff07dd161" translate="yes" xml:space="preserve">
          <source>Note: The format of the output is identical to the output of &lt;code&gt;openssl s_client -trace&lt;/code&gt; or &lt;code&gt;openssl s_server -trace&lt;/code&gt;. While it is produced by OpenSSL's &lt;code&gt;SSL_trace()&lt;/code&gt; function, the format is undocumented, can change without notice, and should not be relied on.</source>
          <target state="translated">참고 : 출력 형식은 &lt;code&gt;openssl s_client -trace&lt;/code&gt; 또는 &lt;code&gt;openssl s_server -trace&lt;/code&gt; 의 출력과 동일합니다 . OpenSSL의 &lt;code&gt;SSL_trace()&lt;/code&gt; 함수에 의해 생성되는 동안 형식은 문서화되지 않으며 예고없이 변경 될 수 있으며 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4616f15367371a5e06b48d2440f7200dc5d1e91b" translate="yes" xml:space="preserve">
          <source>Note: this is not a strong encapsulation as any private modules can still be loaded by absolute paths.</source>
          <target state="translated">참고 : 개인 모듈은 절대 경로로로드 할 수 있으므로 강력한 캡슐화는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="29e915ad9f7438f469d5fcc18ac6ba4e549838fd" translate="yes" xml:space="preserve">
          <source>Numbers which contain a decimal point, such as floating-point numbers or numbers in scientific notation, are not an exception to this rule. Leading numbers up to the decimal point will be set as the URL's port, assuming they are valid:</source>
          <target state="translated">부동 소수점 숫자 또는 과학적 표기법의 숫자와 같이 소수점이 포함 된 숫자는이 규칙에서 예외가 아닙니다. 소수점 이하의 선행 숫자는 유효하다고 가정하면 URL의 포트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="950d326ee993b3c5fd62c84949251f546e884fe5" translate="yes" xml:space="preserve">
          <source>Numeric strings, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are now allowed time specifiers.</source>
          <target state="translated">숫자 문자열, &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;Infinity&lt;/code&gt; 에는 이제 시간 지정자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b569a17c3091df771016c89c44b2ffb4e1607960" translate="yes" xml:space="preserve">
          <source>OCSPRequest event (tls.Server)</source>
          <target state="translated">OCSPRequest 이벤트 (tls.Server)</target>
        </trans-unit>
        <trans-unit id="869b3c3e713ad68da924ccf887bfa9fee9bd8b2b" translate="yes" xml:space="preserve">
          <source>OCSPResponse event (tls.TLSSocket)</source>
          <target state="translated">OCSPResponse 이벤트 (tls.TLSSocket)</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="bf4c411135eaccffeeffff0459da3c06dede6217" translate="yes" xml:space="preserve">
          <source>OS Constants</source>
          <target state="translated">OS 상수</target>
        </trans-unit>
        <trans-unit id="bddd1661aadc76f58c10dd21eeb8e7deaace4a15" translate="yes" xml:space="preserve">
          <source>Object Creation Functions</source>
          <target state="translated">객체 생성 기능</target>
        </trans-unit>
        <trans-unit id="802b3a5ff4c325801801b1f33c90e6aeb50581e9" translate="yes" xml:space="preserve">
          <source>Object Lifetime management</source>
          <target state="translated">객체 수명 관리</target>
        </trans-unit>
        <trans-unit id="da1a453a1b599c80407bbb5b25d54d19f9155848" translate="yes" xml:space="preserve">
          <source>Object Mode</source>
          <target state="translated">객체 모드</target>
        </trans-unit>
        <trans-unit id="0e31dc36041309eb25a82e43f179da4c384a8655" translate="yes" xml:space="preserve">
          <source>Object Mode Duplex Streams</source>
          <target state="translated">객체 모드 이중 스트림</target>
        </trans-unit>
        <trans-unit id="e00ee9265d488224abef0452c70b1277e5a83f49" translate="yes" xml:space="preserve">
          <source>Object Wrap</source>
          <target state="translated">개체 랩</target>
        </trans-unit>
        <trans-unit id="6e782d8ce1f909216afa55f0563a026fe7e818df" translate="yes" xml:space="preserve">
          <source>Object factory</source>
          <target state="translated">객체 팩토리</target>
        </trans-unit>
        <trans-unit id="241d3fb63dae7cf76601d561abf3a990fe514c68" translate="yes" xml:space="preserve">
          <source>Objects may also define their own &lt;a href=&quot;#util_util_inspect_custom&quot;&gt;&lt;code&gt;[util.inspect.custom](depth, opts)&lt;/code&gt;&lt;/a&gt; function, which &lt;code&gt;util.inspect()&lt;/code&gt; will invoke and use the result of when inspecting the object:</source>
          <target state="translated">객체는 또한 자체 &lt;a href=&quot;#util_util_inspect_custom&quot;&gt; &lt;code&gt;[util.inspect.custom](depth, opts)&lt;/code&gt; &lt;/a&gt; 함수를 정의 할 수 있습니다.이 함수는 &lt;code&gt;util.inspect()&lt;/code&gt; 가 객체를 검사 할 때 결과를 호출하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3d0d2e6c538dec52ec33838e688cc3db3a4ab623" translate="yes" xml:space="preserve">
          <source>Objects returned from &lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt;&lt;code&gt;fs.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt;&lt;code&gt;fs.lstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt;&lt;code&gt;fs.fstat()&lt;/code&gt;&lt;/a&gt; and their synchronous counterparts are of this type. If &lt;code&gt;bigint&lt;/code&gt; in the &lt;code&gt;options&lt;/code&gt; passed to those methods is true, the numeric values will be &lt;code&gt;bigint&lt;/code&gt; instead of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#fs_fs_stat_path_options_callback&quot;&gt; &lt;code&gt;fs.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#fs_fs_lstat_path_options_callback&quot;&gt; &lt;code&gt;fs.lstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#fs_fs_fstat_fd_options_callback&quot;&gt; &lt;code&gt;fs.fstat()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 객체 와 해당 동기 대응 항목은이 유형입니다. 경우 &lt;code&gt;bigint&lt;/code&gt; 에서 &lt;code&gt;options&lt;/code&gt; 그 방법에 전달이 참, 숫자 값이 될 것 &lt;code&gt;bigint&lt;/code&gt; 대신 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="592e8c13ea9bd4b8af95ba0ada47b20335a6e103" translate="yes" xml:space="preserve">
          <source>Objects with circular references can be used as inputs now.</source>
          <target state="translated">원형 참조가있는 객체를 이제 입력으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ea40e2b9bd257d370923337e02a0992196f54f" translate="yes" xml:space="preserve">
          <source>Observe that the &lt;code&gt;then()&lt;/code&gt; callback claims to have executed in the context of the outer scope even though there was an asynchronous hop involved. Also, the &lt;code&gt;triggerAsyncId&lt;/code&gt; value is &lt;code&gt;0&lt;/code&gt;, which means that we are missing context about the resource that caused (triggered) the &lt;code&gt;then()&lt;/code&gt; callback to be executed.</source>
          <target state="translated">관찰 &lt;code&gt;then()&lt;/code&gt; 콜백 항 관여 비동기 홉 거기에도 외 범위의 콘텍스트에서 실행될 것으로. 또한 &lt;code&gt;triggerAsyncId&lt;/code&gt; 값이 &lt;code&gt;0&lt;/code&gt; 이므로 &lt;code&gt;then()&lt;/code&gt; 콜백이 실행 된 (트리거 된) 리소스에 대한 컨텍스트가 누락되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="083bef7791cf9d1baf8a9873f071dfc52b64445d" translate="yes" xml:space="preserve">
          <source>Occasionally, the deprecation of an API may be reversed. In such situations, this document will be updated with information relevant to the decision. However, the deprecation identifier will not be modified.</source>
          <target state="translated">때때로 API 사용 중단이 취소 될 수 있습니다. 이러한 상황에서이 문서는 결정과 관련된 정보로 업데이트됩니다. 그러나 지원 중단 식별자는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba38afb5d72c78a9ff4e1ee1598f9f9be252886d" translate="yes" xml:space="preserve">
          <source>Occurs with multiple attempts to shutdown an HTTP/2 session.</source>
          <target state="translated">HTTP / 2 세션을 여러 번 종료하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="a48963a917f62904a1e8543a2ead20c099e2eff3" translate="yes" xml:space="preserve">
          <source>Offset and length are optional but both &lt;em&gt;must&lt;/em&gt; be set if either are used. They are supported only when the first argument is a &lt;code&gt;Buffer&lt;/code&gt; or &lt;code&gt;Uint8Array&lt;/code&gt;.</source>
          <target state="translated">오프셋과 길이는 선택 사항이지만 둘 중 하나를 사용하는 경우 둘 다 설정 &lt;em&gt;해야합니다&lt;/em&gt; . 첫 번째 인수가 &lt;code&gt;Buffer&lt;/code&gt; 또는 &lt;code&gt;Uint8Array&lt;/code&gt; 인 경우에만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4a4dc432f9794752f6ad30e244e3a8e720cdc69" translate="yes" xml:space="preserve">
          <source>Old clients that rely on insecure and deprecated RC4 or DES-based ciphers (like Internet Explorer 6) cannot complete the handshaking process with the default configuration. If these clients &lt;em&gt;must&lt;/em&gt; be supported, the &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;TLS recommendations&lt;/a&gt; may offer a compatible cipher suite. For more details on the format, see the OpenSSL &lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;cipher list format&lt;/a&gt; documentation.</source>
          <target state="translated">안전하지 않고 더 이상 사용되지 않는 RC4 또는 DES 기반 암호 (예 : Internet Explorer 6)를 사용하는 이전 클라이언트는 기본 구성으로 핸드 쉐이킹 프로세스를 완료 할 수 없습니다. 이러한 클라이언트 &lt;em&gt;를&lt;/em&gt; 지원 &lt;em&gt;해야하는&lt;/em&gt; 경우 &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;TLS 권장 사항&lt;/a&gt; 은 호환 가능한 암호 제품군을 제공 할 수 있습니다. 형식에 대한 자세한 내용은 OpenSSL &lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;암호 목록 형식&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39846a8f31378460759ab91e423751587cbcd672" translate="yes" xml:space="preserve">
          <source>Omitting the callback function on asynchronous fs functions is deprecated and may result in an error being thrown in the future.</source>
          <target state="translated">비동기 fs 함수에서 콜백 함수를 생략하면 더 이상 사용되지 않으며 나중에 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d0e0b0451c6ef174ec5a71852c7111df84bc0bf" translate="yes" xml:space="preserve">
          <source>On 32-bit architectures, this value is &lt;code&gt;(2^30)-1&lt;/code&gt; (~1GB). On 64-bit architectures, this value is &lt;code&gt;(2^31)-1&lt;/code&gt; (~2GB).</source>
          <target state="translated">32 비트 아키텍처에서이 값은 &lt;code&gt;(2^30)-1&lt;/code&gt; (~ 1GB)입니다. 64 비트 아키텍처에서이 값은 &lt;code&gt;(2^31)-1&lt;/code&gt; (~ 2GB)입니다.</target>
        </trans-unit>
        <trans-unit id="cece5a81c61c5200f22063c4263b25c9ea0fa07a" translate="yes" xml:space="preserve">
          <source>On Aix systems, this feature depends on &lt;a href=&quot;https://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&quot;&gt;&lt;code&gt;AHAFS&lt;/code&gt;&lt;/a&gt;, which must be enabled.</source>
          <target state="translated">Aix 시스템에서이 기능은 활성화 &lt;a href=&quot;https://www.ibm.com/developerworks/aix/library/au-aix_event_infrastructure/&quot;&gt; &lt;code&gt;AHAFS&lt;/code&gt; &lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3287e458f7d140ce7af1d1893ae19d42b58cb150" translate="yes" xml:space="preserve">
          <source>On BSD systems, this uses &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt;&lt;code&gt;kqueue(2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">BSD 시스템에서는 &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt; &lt;code&gt;kqueue(2)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3cee5b68c9afac982d46719c80955c745508f033" translate="yes" xml:space="preserve">
          <source>On IPv4, if &lt;code&gt;multicastInterface&lt;/code&gt; is a valid address but does not match any interface, or if the address does not match the family then a &lt;a href=&quot;errors#errors_class_systemerror&quot;&gt;&lt;code&gt;System Error&lt;/code&gt;&lt;/a&gt; such as &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; or &lt;code&gt;EPROTONOSUP&lt;/code&gt; is thrown.</source>
          <target state="translated">IPv4에서 &lt;code&gt;multicastInterface&lt;/code&gt; 가 유효한 주소이지만 인터페이스와 일치하지 않거나 주소가 패밀리와 일치하지 않으면 &lt;code&gt;EADDRNOTAVAIL&lt;/code&gt; 또는 &lt;code&gt;EPROTONOSUP&lt;/code&gt; 과 같은 &lt;a href=&quot;errors#errors_class_systemerror&quot;&gt; &lt;code&gt;System Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d73abdde568049652b60fdd5aaa144ebebd0fc9" translate="yes" xml:space="preserve">
          <source>On IPv6, most errors with specifying or omitting scope will result in the socket continuing to use (or returning to) the system's default interface selection.</source>
          <target state="translated">IPv6에서 범위를 지정하거나 생략 할 때 발생하는 대부분의 오류는 소켓이 시스템의 기본 인터페이스 선택을 계속 사용하거나 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c0b541a8346341860cd7703b98a4352d06a66130" translate="yes" xml:space="preserve">
          <source>On Linux and macOS systems, &lt;code&gt;fs.watch()&lt;/code&gt; resolves the path to an &lt;a href=&quot;https://en.wikipedia.org/wiki/Inode&quot;&gt;inode&lt;/a&gt; and watches the inode. If the watched path is deleted and recreated, it is assigned a new inode. The watch will emit an event for the delete but will continue watching the &lt;em&gt;original&lt;/em&gt; inode. Events for the new inode will not be emitted. This is expected behavior.</source>
          <target state="translated">Linux 및 macOS 시스템에서 &lt;code&gt;fs.watch()&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inode&quot;&gt;inode&lt;/a&gt; 의 경로를 확인하고 inode 를 감시합니다. 감시 경로가 삭제되고 다시 생성되면 새로운 inode가 할당됩니다. 시계에서 삭제 이벤트가 발생하지만 &lt;em&gt;원래&lt;/em&gt; inode 는 계속 지켜 봅니다. 새로운 inode에 대한 이벤트는 생성되지 않습니다. 이것은 예상 된 동작입니다.</target>
        </trans-unit>
        <trans-unit id="08f31ae143ca922e16ce486612875e1b465fba38" translate="yes" xml:space="preserve">
          <source>On Linux systems, this uses &lt;a href=&quot;http://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt;&lt;code&gt;inotify(7)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Linux 시스템에서는 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/inotify.7.html&quot;&gt; &lt;code&gt;inotify(7)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b2f183efec4feb7bfa6fc109ebc4023975000344" translate="yes" xml:space="preserve">
          <source>On Linux, child processes of child processes will not be terminated when attempting to kill their parent. This is likely to happen when running a new process in a shell or with the use of the &lt;code&gt;shell&lt;/code&gt; option of &lt;code&gt;ChildProcess&lt;/code&gt;:</source>
          <target state="translated">Linux에서는 상위 프로세스를 종료하려고 할 때 하위 프로세스의 하위 프로세스가 종료되지 않습니다. 이것은 쉘에서 새 프로세스를 실행하거나 &lt;code&gt;ChildProcess&lt;/code&gt; 의 &lt;code&gt;shell&lt;/code&gt; 옵션을 사용하여 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7882f8e43f0f64c5514b81f5cfa8dcb3ff288045" translate="yes" xml:space="preserve">
          <source>On Linux, positional writes do not work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.</source>
          <target state="translated">Linux에서 파일을 추가 모드로 열면 위치 쓰기가 작동하지 않습니다. 커널은 position 인수를 무시하고 항상 파일 끝에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="58c85a79493b7491ac9088c933d8b858c448602a" translate="yes" xml:space="preserve">
          <source>On Linux, positional writes don't work when the file is opened in append mode. The kernel ignores the position argument and always appends the data to the end of the file.</source>
          <target state="translated">Linux에서 파일을 추가 모드로 열면 위치 쓰기가 작동하지 않습니다. 커널은 position 인수를 무시하고 항상 파일 끝에 데이터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9554e400419b2712320ba3378dbdb33b6ba3a586" translate="yes" xml:space="preserve">
          <source>On Linux, when Node.js is linked against musl libc, the procfs file system must be mounted on &lt;code&gt;/proc&lt;/code&gt; in order for this function to work. Glibc does not have this restriction.</source>
          <target state="translated">Linux에서 Node.js가 musl libc에 링크 된 경우이 기능이 작동 하려면 procfs 파일 시스템을 &lt;code&gt;/proc&lt;/code&gt; 에 마운트해야합니다 . Glibc에는이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="46927efa147a220d19018a44c19bb0a81a2795b4" translate="yes" xml:space="preserve">
          <source>On POSIX and Windows:</source>
          <target state="translated">POSIX 및 Windows :</target>
        </trans-unit>
        <trans-unit id="51d7bab8caccee4037b352d1dd8b48e36fb94ee8" translate="yes" xml:space="preserve">
          <source>On POSIX systems, for every process, the kernel maintains a table of currently open files and resources. Each open file is assigned a simple numeric identifier called a &lt;em&gt;file descriptor&lt;/em&gt;. At the system-level, all file system operations use these file descriptors to identify and track each specific file. Windows systems use a different but conceptually similar mechanism for tracking resources. To simplify things for users, Node.js abstracts away the specific differences between operating systems and assigns all open files a numeric file descriptor.</source>
          <target state="translated">POSIX 시스템에서 모든 프로세스에 대해 커널은 현재 열려있는 파일 및 리소스 테이블을 유지 관리합니다. 열려있는 각 파일에는 &lt;em&gt;파일 설명&lt;/em&gt; 자라는 간단한 숫자 식별자가 할당됩니다 . 시스템 레벨에서 모든 파일 시스템 조작은이 파일 디스크립터를 사용하여 각 특정 파일을 식별하고 추적합니다. Windows 시스템은 리소스를 추적하기 위해 다르지만 개념적으로 유사한 메커니즘을 사용합니다. 사용자를 위해 단순화하기 위해 Node.js는 운영 체제 간의 특정 차이점을 추상화하고 열려있는 모든 파일에 숫자 파일 설명자를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="fc406a1e7cf53219ab80c07c59e5aaa1d8a7ae6a" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the operating system release is determined by calling &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt;&lt;code&gt;uname(3)&lt;/code&gt;&lt;/a&gt;. On Windows, &lt;code&gt;GetVersionExW()&lt;/code&gt; is used. Please see &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 시스템에서 운영 체제 릴리스는 &lt;a href=&quot;https://linux.die.net/man/3/uname&quot;&gt; &lt;code&gt;uname(3)&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . Windows에서는 &lt;code&gt;GetVersionExW()&lt;/code&gt; 가 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uname#Examples&quot;&gt;https://en.wikipedia.org/wiki/Uname#Examples&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="43964d44f0ac16e56226d71c33bedb3c5fe5eddc" translate="yes" xml:space="preserve">
          <source>On POSIX:</source>
          <target state="translated">POSIX에서 :</target>
        </trans-unit>
        <trans-unit id="fbb774d38621fd75eb708c21854f712a9058284b" translate="yes" xml:space="preserve">
          <source>On SunOS systems (including Solaris and SmartOS), this uses &lt;a href=&quot;http://illumos.org/man/port_create&quot;&gt;&lt;code&gt;event ports&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">SunOS 시스템 (Solaris 및 SmartOS 포함)에서는 &lt;a href=&quot;http://illumos.org/man/port_create&quot;&gt; &lt;code&gt;event ports&lt;/code&gt; &lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="df56f9f559c9d44e41081b83b633aad4f3fae33d" translate="yes" xml:space="preserve">
          <source>On Unix, the local domain is also known as the Unix domain. The path is a filesystem pathname. It gets truncated to &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt;, which varies on different operating system between 91 and 107 bytes. The typical values are 107 on Linux and 103 on macOS. The path is subject to the same naming conventions and permissions checks as would be done on file creation. If the Unix domain socket (that is visible as a file system path) is created and used in conjunction with one of Node.js' API abstractions such as &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt;&lt;code&gt;net.createServer()&lt;/code&gt;&lt;/a&gt;, it will be unlinked as part of &lt;a href=&quot;#net_server_close_callback&quot;&gt;&lt;code&gt;server.close()&lt;/code&gt;&lt;/a&gt;. On the other hand, if it is created and used outside of these abstractions, the user will need to manually remove it. The same applies when the path was created by a Node.js API but the program crashes abruptly. In short, a Unix domain socket once successfully created will be visible in the filesystem, and will persist until unlinked.</source>
          <target state="translated">Unix에서 로컬 도메인은 Unix 도메인이라고도합니다. 경로는 파일 시스템 경로 이름입니다. &lt;code&gt;sizeof(sockaddr_un.sun_path) - 1&lt;/code&gt; 잘 리며 91-107 바이트 사이의 운영 체제에 따라 다릅니다. 일반적인 값은 Linux에서 107, macOS에서 103입니다. 경로는 파일 작성시와 동일한 이름 지정 규칙 및 권한 검사를 따릅니다. &lt;a href=&quot;#net_net_createserver_options_connectionlistener&quot;&gt; &lt;code&gt;net.createServer()&lt;/code&gt; &lt;/a&gt; 와 같은 Node.js API 추상화 중 하나와 함께 Unix 도메인 소켓 (파일 시스템 경로로 표시됨)을 작성하여 사용 하는 경우 &lt;a href=&quot;#net_server_close_callback&quot;&gt; &lt;code&gt;server.close()&lt;/code&gt; &lt;/a&gt; 일부로 연결 해제됩니다.. 반면에, 이러한 추상화 외부에서 작성하여 사용하는 경우 사용자는이를 수동으로 제거해야합니다. Node.js API에 의해 경로가 작성되었지만 프로그램이 갑자기 충돌하는 경우에도 동일하게 적용됩니다. 한마디로 성공적으로 생성 된 Unix 도메인 소켓은 파일 시스템에 표시되며 연결이 끊길 때까지 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="3972efd510cd3bdc92bf875a4f0a2ead952896ec" translate="yes" xml:space="preserve">
          <source>On Unix-like operating systems, the &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; method performs memory operations synchronously before decoupling the event loop from the child. Applications with a large memory footprint may find frequent &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt;&lt;code&gt;child_process.spawn()&lt;/code&gt;&lt;/a&gt; calls to be a bottleneck. For more information, see &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=7381&quot;&gt;V8 issue 7381&lt;/a&gt;.</source>
          <target state="translated">Unix와 유사한 운영 체제에서 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 메서드는 이벤트 루프를 자식에서 분리하기 전에 메모리 작업을 동 기적으로 수행합니다. 메모리 사용량이 큰 응용 프로그램은 자주 &lt;a href=&quot;#child_process_child_process_spawn_command_args_options&quot;&gt; &lt;code&gt;child_process.spawn()&lt;/code&gt; &lt;/a&gt; 호출에 병목 현상이 발생할 수 있습니다. 자세한 정보는 &lt;a href=&quot;https://bugs.chromium.org/p/v8/issues/detail?id=7381&quot;&gt;V8 문제 7381을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cccd5ed6fa224a3e49b57994f042004b58a3d24" translate="yes" xml:space="preserve">
          <source>On Windows Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example, &lt;code&gt;path.resolve('c:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;path.resolve('c:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉토리의 개념을 따릅니다. 백 슬래시없이 드라이브 경로를 사용할 때이 동작을 관찰 할 수 있습니다. 예를 들어 &lt;code&gt;path.resolve('c:\\')&lt;/code&gt; 는 잠재적으로 &lt;code&gt;path.resolve('c:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44da2b295d7da47cf09267ff3645f95eea8d9b81" translate="yes" xml:space="preserve">
          <source>On Windows operating systems, environment variables are case-insensitive.</source>
          <target state="translated">Windows 운영 체제에서 환경 변수는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ea919f697c12d8bddae320cb521d2942ea420cb" translate="yes" xml:space="preserve">
          <source>On Windows setting priority to &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; requires elevated user, otherwise the set priority will be silently reduced to &lt;code&gt;PRIORITY_HIGH&lt;/code&gt;.</source>
          <target state="translated">Windows에서 우선 순위를 &lt;code&gt;PRIORITY_HIGHEST&lt;/code&gt; 로 설정 하려면 관리자 가 높아야 합니다. 그렇지 않으면 설정된 우선 순위가 자동으로 &lt;code&gt;PRIORITY_HIGH&lt;/code&gt; 로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="1ec6383b7c3b09150b80d42778d5cc7a98c50e48" translate="yes" xml:space="preserve">
          <source>On Windows systems only, returns an equivalent &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces&quot;&gt;namespace-prefixed path&lt;/a&gt; for the given &lt;code&gt;path&lt;/code&gt;. If &lt;code&gt;path&lt;/code&gt; is not a string, &lt;code&gt;path&lt;/code&gt; will be returned without modifications.</source>
          <target state="translated">Windows 시스템에서만 지정된 &lt;code&gt;path&lt;/code&gt; 대해 동등한 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces&quot;&gt;네임 스페이스 접두어 경로&lt;/a&gt; 를 리턴합니다 . &lt;code&gt;path&lt;/code&gt; 가 문자열이 아닌 경우 수정없이 &lt;code&gt;path&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9768705b87b168aec5ab1fa9f7b54014d3f95ac4" translate="yes" xml:space="preserve">
          <source>On Windows systems, this feature depends on &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-readdirectorychangesw&quot;&gt;&lt;code&gt;ReadDirectoryChangesW&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows 시스템에서이 기능은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-readdirectorychangesw&quot;&gt; &lt;code&gt;ReadDirectoryChangesW&lt;/code&gt; 에&lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3df2880a42d4864e454ff5c30b2f005eea801949" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;NODE_PATH&lt;/code&gt; is delimited by semicolons (&lt;code&gt;;&lt;/code&gt;) instead of colons.</source>
          <target state="translated">Windows에서 &lt;code&gt;NODE_PATH&lt;/code&gt; 는 콜론 대신 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )으로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="5931a3f0a8409d7489021967eca3c561a80a89c9" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;file:&lt;/code&gt; URLs having encoded backslash will result in a throw:</source>
          <target state="translated">Windows에서 &lt;code&gt;file:&lt;/code&gt; 백 슬래시를 인코딩 한 URL은 다음을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="91506a2d47b419ea0ee01cc61a92dad8cc27411b" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;file:&lt;/code&gt; URLs with a hostname convert to UNC paths, while &lt;code&gt;file:&lt;/code&gt; URLs with drive letters convert to local absolute paths. &lt;code&gt;file:&lt;/code&gt; URLs without a hostname nor a drive letter will result in a throw:</source>
          <target state="translated">Windows에서 &lt;code&gt;file:&lt;/code&gt; 호스트 이름의 URL은 UNC 경로로 변환되고 &lt;code&gt;file:&lt;/code&gt; 드라이브 문자의 URL은 로컬 절대 경로로 변환됩니다. &lt;code&gt;file:&lt;/code&gt; 호스트 이름이없는 URL이나 드라이브 문자가 발생하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb13f48dbe09dfcc8c8afd1a18188c31d89c540d" translate="yes" xml:space="preserve">
          <source>On Windows, Node.js follows the concept of per-drive working directory. This behavior can be observed when using a drive path without a backslash. For example &lt;code&gt;fs.readdirSync('c:\\')&lt;/code&gt; can potentially return a different result than &lt;code&gt;fs.readdirSync('c:')&lt;/code&gt;. For more information, see &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;this MSDN page&lt;/a&gt;.</source>
          <target state="translated">Windows에서 Node.js는 드라이브 별 작업 디렉토리의 개념을 따릅니다. 백 슬래시없이 드라이브 경로를 사용할 때이 동작을 관찰 할 수 있습니다. 예를 들어 &lt;code&gt;fs.readdirSync('c:\\')&lt;/code&gt; 는 &lt;code&gt;fs.readdirSync('c:')&lt;/code&gt; 와 다른 결과를 반환 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#fully-qualified-vs-relative-paths&quot;&gt;이 MSDN 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebe6267af9150e34384ccfb932409adc54221278" translate="yes" xml:space="preserve">
          <source>On Windows, access-control policies (ACLs) on a directory may limit access to a file or directory. The &lt;code&gt;fs.access()&lt;/code&gt; function, however, does not check the ACL and therefore may report that a path is accessible even if the ACL restricts the user from reading or writing to it.</source>
          <target state="translated">Windows에서 디렉토리의 ACL (액세스 제어 정책)은 파일 또는 디렉토리에 대한 액세스를 제한 할 수 있습니다. 그러나 &lt;code&gt;fs.access()&lt;/code&gt; 함수는 ACL을 확인하지 않으므로 ACL이 사용자가 읽거나 쓰는 것을 제한하더라도 경로에 액세스 할 수 있다고보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aff139e0769d280257d0d48cf82151703507a29c" translate="yes" xml:space="preserve">
          <source>On Windows, both the forward slash (&lt;code&gt;/&lt;/code&gt;) and backward slash (&lt;code&gt;\&lt;/code&gt;) are accepted as path segment separators; however, the &lt;code&gt;path&lt;/code&gt; methods only add backward slashes (&lt;code&gt;\&lt;/code&gt;).</source>
          <target state="translated">Windows에서는 슬래시 ( &lt;code&gt;/&lt;/code&gt; )와 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )가 모두 경로 세그먼트 분리 자로 허용됩니다. 그러나 &lt;code&gt;path&lt;/code&gt; 메소드는 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 만 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e5e941fdda19df2837a224780f4308d95357b323" translate="yes" xml:space="preserve">
          <source>On Windows, if the file descriptor is connected to the console (e.g. &lt;code&gt;fd == 1&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt;) a string containing non-ASCII characters will not be rendered properly by default, regardless of the encoding used. It is possible to configure the console to render UTF-8 properly by changing the active codepage with the &lt;code&gt;chcp 65001&lt;/code&gt; command. See the &lt;a href=&quot;https://ss64.com/nt/chcp.html&quot;&gt;chcp&lt;/a&gt; docs for more details.</source>
          <target state="translated">Windows에서 파일 디스크립터가 콘솔에 연결된 경우 (예 : &lt;code&gt;fd == 1&lt;/code&gt; 또는 &lt;code&gt;stdout&lt;/code&gt; ) ASCII가 아닌 문자를 포함하는 문자열은 사용 된 인코딩에 관계없이 기본적으로 올바르게 렌더링되지 않습니다. &lt;code&gt;chcp 65001&lt;/code&gt; 명령으로 활성 코드 페이지를 변경하여 UTF-8을 올바르게 렌더링하도록 콘솔을 구성 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://ss64.com/nt/chcp.html&quot;&gt;chcp&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac67ee10708396162b94cc66d589c1b59dc10f64" translate="yes" xml:space="preserve">
          <source>On Windows, it is not yet possible to set up a named pipe server in a worker.</source>
          <target state="translated">Windows에서는 아직 작업자에서 명명 된 파이프 서버를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a20253c7c4edfcb2e4f480c38f30c92cd1f24b4" translate="yes" xml:space="preserve">
          <source>On Windows, opening an existing hidden file using the &lt;code&gt;'w'&lt;/code&gt; flag (either through &lt;code&gt;fs.open()&lt;/code&gt; or &lt;code&gt;fs.writeFile()&lt;/code&gt; or &lt;code&gt;fsPromises.open()&lt;/code&gt;) will fail with &lt;code&gt;EPERM&lt;/code&gt;. Existing hidden files can be opened for writing with the &lt;code&gt;'r+'&lt;/code&gt; flag.</source>
          <target state="translated">Windows에서 &lt;code&gt;'w'&lt;/code&gt; 플래그를 사용하여 ( &lt;code&gt;fs.open()&lt;/code&gt; 또는 &lt;code&gt;fs.writeFile()&lt;/code&gt; 또는 &lt;code&gt;fsPromises.open()&lt;/code&gt; ) 기존 숨김 파일 을 열면 &lt;code&gt;EPERM&lt;/code&gt; 이 실패 합니다. 기존의 숨겨진 파일은 &lt;code&gt;'r+'&lt;/code&gt; 플래그 로 쓰기 위해 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c3c7ea68df8c4d84bf0458c22f4d8178e9c209" translate="yes" xml:space="preserve">
          <source>On Windows, setting &lt;code&gt;options.detached&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; makes it possible for the child process to continue running after the parent exits. The child will have its own console window. Once enabled for a child process, it cannot be disabled.</source>
          <target state="translated">Windows에서 &lt;code&gt;options.detached&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 상위 프로세스가 종료 된 후에 하위 프로세스를 계속 실행할 수 있습니다. 아이에게는 자체 콘솔 창이 있습니다. 하위 프로세스에 대해 활성화 된 후에는 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cec484a036adf383f0cf83afa7944fb446a84f8f" translate="yes" xml:space="preserve">
          <source>On Windows, the leading slashes for UNC paths are now included in the return value.</source>
          <target state="translated">Windows에서 UNC 경로의 선행 슬래시가 이제 리턴 값에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef45d44679240b74995b77a40348470a3214c30" translate="yes" xml:space="preserve">
          <source>On Windows, the local domain is implemented using a named pipe. The path &lt;em&gt;must&lt;/em&gt; refer to an entry in &lt;code&gt;\\?\pipe\&lt;/code&gt; or &lt;code&gt;\\.\pipe\&lt;/code&gt;. Any characters are permitted, but the latter may do some processing of pipe names, such as resolving &lt;code&gt;..&lt;/code&gt; sequences. Despite how it might look, the pipe namespace is flat. Pipes will &lt;em&gt;not persist&lt;/em&gt;. They are removed when the last reference to them is closed. Unlike Unix domain sockets, Windows will close and remove the pipe when the owning process exits.</source>
          <target state="translated">Windows에서 로컬 도메인은 명명 된 파이프를 사용하여 구현됩니다. 경로 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;\\?\pipe\&lt;/code&gt; 또는 &lt;code&gt;\\.\pipe\&lt;/code&gt; 의 항목을 참조 &lt;em&gt;해야합니다&lt;/em&gt; . 모든 문자는 허용되지만 후자는 &lt;code&gt;..&lt;/code&gt; 시퀀스 해석과 같은 파이프 이름의 일부 처리를 수행 할 수 있습니다 . 모양에도 불구하고 파이프 네임 스페이스는 평평합니다. 파이프가 &lt;em&gt;지속되지 않습니다&lt;/em&gt; . 마지막 참조가 닫히면 제거됩니다. Unix 도메인 소켓과 달리 소유 프로세스가 종료되면 Windows가 파이프를 닫고 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b4d884e9df62086a09c3c39332a23060c917a2fd" translate="yes" xml:space="preserve">
          <source>On Windows, this is a &lt;code&gt;';'&lt;/code&gt;-separated list instead.</source>
          <target state="translated">Windows에서 이것은 &lt;code&gt;';'&lt;/code&gt; 입니다.대신 분리 된 목록.</target>
        </trans-unit>
        <trans-unit id="126249b93389124fc90335a9d8ca99dd0a8df116" translate="yes" xml:space="preserve">
          <source>On Windows, using &lt;code&gt;cmd.exe&lt;/code&gt; a single quote will not work correctly because it only recognizes double &lt;code&gt;&quot;&lt;/code&gt; for quoting. In Powershell or Git bash, both &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; are usable.</source>
          <target state="translated">Windows에서 &lt;code&gt;cmd.exe&lt;/code&gt; 를 사용 하면 인용 부호로 큰 &lt;code&gt;&quot;&lt;/code&gt; 만 인식되므로 작은 따옴표가 올바르게 작동하지 않습니다 . Powershell 또는 Git bash에서는 &lt;code&gt;'&lt;/code&gt; 와 &lt;code&gt;&quot;&lt;/code&gt; 를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1aa8a0561e5d494303a1665e8c1c1ffaec18bdf" translate="yes" xml:space="preserve">
          <source>On Windows, using &lt;code&gt;fs.mkdir()&lt;/code&gt; on the root directory even with recursion will result in an error:</source>
          <target state="translated">Windows에서 재귀와 함께 루트 디렉토리에서 &lt;code&gt;fs.mkdir()&lt;/code&gt; 을 사용 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95a625c5b6c3cb8c2b26fa2d6baf9cb114baf0b1" translate="yes" xml:space="preserve">
          <source>On Windows, where scope format uses an interface number:</source>
          <target state="translated">범위 형식이 인터페이스 번호를 사용하는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="8a5f22e0dff9bf222d72376b8ec44283751a3201" translate="yes" xml:space="preserve">
          <source>On all other platforms, &lt;code&gt;file:&lt;/code&gt; URLs with a hostname are unsupported and will result in a throw:</source>
          <target state="translated">다른 모든 플랫폼에서 &lt;code&gt;file:&lt;/code&gt; 호스트 이름을 가진 URL은 지원되지 않으며 다음 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="358e1630770bd86b6eaadca9e6e64f99e4bb79cd" translate="yes" xml:space="preserve">
          <source>On an error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code.</source>
          <target state="translated">오류에서 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 오브젝트이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다.</target>
        </trans-unit>
        <trans-unit id="002bfab7979fd23e069b0486d57556dd50036776" translate="yes" xml:space="preserve">
          <source>On completion, &lt;code&gt;callback&lt;/code&gt; will be called with &lt;code&gt;err&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;publicKey&lt;/code&gt; / &lt;code&gt;privateKey&lt;/code&gt; representing the generated key pair.</source>
          <target state="translated">완료되면, &lt;code&gt;callback&lt;/code&gt; 은 &lt;code&gt;err&lt;/code&gt; 이 &lt;code&gt;undefined&lt;/code&gt; 로 설정 되고 &lt;code&gt;publicKey&lt;/code&gt; / &lt;code&gt;privateKey&lt;/code&gt; 는 생성 된 키 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7886649da2b50ecb04b5356e20760a1e5cb6366c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is one of the &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS error codes&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS 오류 코드&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="944278cb905faca8676573641ea322dcf7de9025" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;err&lt;/code&gt; is an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the hostname does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;err&lt;/code&gt; 은 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 객체이며, 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 때 호스트 이름도 존재하지 않지만,없는 경우에만 그러한 측은 파일 설명한다.</target>
        </trans-unit>
        <trans-unit id="28da3a89db66c1e49e35684df5651bd41326f739" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is one of the &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS error codes&lt;/a&gt;.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체로 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 &lt;a href=&quot;#dns_error_codes&quot;&gt;DNS 오류 코드&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="da16732d5d9a380f16a376ff4e654c12594bd786" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다.</target>
        </trans-unit>
        <trans-unit id="efe534a2832704d62aaa34473a2409791c2952e2" translate="yes" xml:space="preserve">
          <source>On error, the &lt;code&gt;Promise&lt;/code&gt; is rejected with an &lt;a href=&quot;errors#errors_class_error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; object, where &lt;code&gt;err.code&lt;/code&gt; is the error code. Keep in mind that &lt;code&gt;err.code&lt;/code&gt; will be set to &lt;code&gt;'ENOTFOUND'&lt;/code&gt; not only when the hostname does not exist but also when the lookup fails in other ways such as no available file descriptors.</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;errors#errors_class_error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 개체 와 함께 &lt;code&gt;Promise&lt;/code&gt; 이 거부됩니다. 여기서 &lt;code&gt;err.code&lt;/code&gt; 는 오류 코드입니다. 있다는 사실을 숙지 &lt;code&gt;err.code&lt;/code&gt; 가 설정됩니다 &lt;code&gt;'ENOTFOUND'&lt;/code&gt; 조회가 다른 방법으로 실패 할 때 호스트 이름도 존재하지 않지만,없는 경우에만 그러한 측은 파일 설명한다.</target>
        </trans-unit>
        <trans-unit id="9d274e72d3eaf33ae1f5b101442303f281721deb" translate="yes" xml:space="preserve">
          <source>On macOS, this uses &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt;&lt;code&gt;kqueue(2)&lt;/code&gt;&lt;/a&gt; for files and &lt;a href=&quot;https://developer.apple.com/documentation/coreservices/file_system_events&quot;&gt;&lt;code&gt;FSEvents&lt;/code&gt;&lt;/a&gt; for directories.</source>
          <target state="translated">macOS에서는 파일에 &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;amp;sektion=2&quot;&gt; &lt;code&gt;kqueue(2)&lt;/code&gt; &lt;/a&gt; 를 사용 하고 디렉토리에 &lt;a href=&quot;https://developer.apple.com/documentation/coreservices/file_system_events&quot;&gt; &lt;code&gt;FSEvents&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39eb6da0166d08d18888bf5d340f82d447a083bd" translate="yes" xml:space="preserve">
          <source>On most platforms, &lt;code&gt;'rename'&lt;/code&gt; is emitted whenever a filename appears or disappears in the directory.</source>
          <target state="translated">대부분의 플랫폼에서 파일 이름이 디렉토리에 나타나거나 사라질 때마다 &lt;code&gt;'rename'&lt;/code&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4558f0d2f934a695ab52b8b29e7288d194b5266" translate="yes" xml:space="preserve">
          <source>On most systems, where scope format uses the interface name:</source>
          <target state="translated">범위 형식이 인터페이스 이름을 사용하는 대부분의 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="7b8df057d113972b6e227366e919aa409563a34a" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, if &lt;code&gt;options.detached&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the child process will be made the leader of a new process group and session. Child processes may continue running after the parent exits regardless of whether they are detached or not. See &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setsid.2.html&quot;&gt;&lt;code&gt;setsid(2)&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Windows 이외의 플랫폼에서 &lt;code&gt;options.detached&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 하위 프로세스가 새 프로세스 그룹 및 세션의 리더가됩니다. 하위 프로세스는 분리 여부에 관계없이 상위 종료 후 계속 실행될 수 있습니다. 자세한 내용은 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/setsid.2.html&quot;&gt; &lt;code&gt;setsid(2)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1643cfbf0d28d755f6e901a412963cf366b998f6" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;callback&lt;/code&gt; will now be called with an &lt;code&gt;error&lt;/code&gt; argument of &lt;code&gt;null&lt;/code&gt; rather than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">성공시, &lt;code&gt;callback&lt;/code&gt; 이제 호출됩니다 &lt;code&gt;error&lt;/code&gt; 의 인수 &lt;code&gt;null&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b992a9b66ecf9c509977f4e79d71ce4d083dbf97" translate="yes" xml:space="preserve">
          <source>On the client side, instances of &lt;a href=&quot;#http2_class_clienthttp2stream&quot;&gt;&lt;code&gt;ClientHttp2Stream&lt;/code&gt;&lt;/a&gt; are created when the &lt;code&gt;http2session.request()&lt;/code&gt; method is called.</source>
          <target state="translated">클라이언트 측 에서 &lt;code&gt;http2session.request()&lt;/code&gt; 메소드가 호출 될 때 &lt;a href=&quot;#http2_class_clienthttp2stream&quot;&gt; &lt;code&gt;ClientHttp2Stream&lt;/code&gt; &lt;/a&gt; 인스턴스 가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac9f26bc28901e0da3bba962837c8a762d501500" translate="yes" xml:space="preserve">
          <source>On the client, the &lt;code&gt;Http2Stream&lt;/code&gt; instance returned by &lt;code&gt;http2session.request()&lt;/code&gt; may not be immediately ready for use if the parent &lt;code&gt;Http2Session&lt;/code&gt; has not yet been fully established. In such cases, operations called on the &lt;code&gt;Http2Stream&lt;/code&gt; will be buffered until the &lt;code&gt;'ready'&lt;/code&gt; event is emitted. User code should rarely, if ever, need to handle the &lt;code&gt;'ready'&lt;/code&gt; event directly. The ready status of an &lt;code&gt;Http2Stream&lt;/code&gt; can be determined by checking the value of &lt;code&gt;http2stream.id&lt;/code&gt;. If the value is &lt;code&gt;undefined&lt;/code&gt;, the stream is not yet ready for use.</source>
          <target state="translated">클라이언트 에서 부모 &lt;code&gt;Http2Session&lt;/code&gt; 이 아직 완전히 설정되지 않은 경우 &lt;code&gt;http2session.request()&lt;/code&gt; 의해 리턴 된 &lt;code&gt;Http2Stream&lt;/code&gt; 인스턴스를 즉시 사용할 수 없습니다 . 이러한 경우 &lt;code&gt;Http2Stream&lt;/code&gt; 에서 호출 된 작업 은 &lt;code&gt;'ready'&lt;/code&gt; 이벤트가 생성 될 때까지 버퍼링됩니다 . 사용자 코드가 &lt;code&gt;'ready'&lt;/code&gt; 이벤트를 직접 처리 할 필요는 거의 없습니다 . 의 준비 상태 &lt;code&gt;Http2Stream&lt;/code&gt; 은 값 확인하여 판단 할 수 &lt;code&gt;http2stream.id&lt;/code&gt; 을 . 값이 &lt;code&gt;undefined&lt;/code&gt; 인 경우 스트림을 아직 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f16439cf41d36a278e3eaf44e9d440d888072b10" translate="yes" xml:space="preserve">
          <source>On the client, the &lt;code&gt;session&lt;/code&gt; can be provided to the &lt;code&gt;session&lt;/code&gt; option of &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt;&lt;code&gt;tls.connect()&lt;/code&gt;&lt;/a&gt; to resume the connection.</source>
          <target state="translated">클라이언트에서 &lt;code&gt;session&lt;/code&gt; 을 &lt;a href=&quot;#tls_tls_connect_options_callback&quot;&gt; &lt;code&gt;tls.connect()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;session&lt;/code&gt; 옵션에 제공 하여 연결을 재개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df17243448ce58a6e9d8efe145f7f94cbbd06305" translate="yes" xml:space="preserve">
          <source>On the first line, &lt;code&gt;foo.js&lt;/code&gt; loads the module &lt;code&gt;circle.js&lt;/code&gt; that is in the same directory as &lt;code&gt;foo.js&lt;/code&gt;.</source>
          <target state="translated">첫 번째 행에서 &lt;code&gt;foo.js&lt;/code&gt; 는 &lt;code&gt;foo.js&lt;/code&gt; 와 동일한 디렉토리에있는 &lt;code&gt;circle.js&lt;/code&gt; 모듈을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="3b07e2e6f8a12bd63b2638139eb922d67ad2dfaf" translate="yes" xml:space="preserve">
          <source>On the main thread, values are removed from the queue associated with the thread-safe function in an idle loop. This error indicates that an error has occurred when attempting to start the loop.</source>
          <target state="translated">기본 스레드에서 유휴 루프의 스레드 안전 기능과 관련된 대기열에서 값이 제거됩니다. 이 오류는 루프를 시작하려고 할 때 오류가 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bfb69afb09660b281005b2feb90d4b1d5ba3d6e1" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;node-inspect&lt;/code&gt; may be installed locally through a package manager, as it is published on the npm registry under the same name. No source code modification is necessary if that is done.</source>
          <target state="translated">반면 &lt;code&gt;node-inspect&lt;/code&gt; 는 npm 레지스트리에 동일한 이름으로 게시되므로 패키지 관리자를 통해 로컬로 설치할 수 있습니다. 소스 코드 수정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45d01237536f26cbcba80929de5b721832402940" translate="yes" xml:space="preserve">
          <source>On the server side, instances of &lt;a href=&quot;#http2_class_serverhttp2stream&quot;&gt;&lt;code&gt;ServerHttp2Stream&lt;/code&gt;&lt;/a&gt; are created either when:</source>
          <target state="translated">서버 측에서 &lt;a href=&quot;#http2_class_serverhttp2stream&quot;&gt; &lt;code&gt;ServerHttp2Stream&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 다음과 같은 경우에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="93fbaba0c5ebedfd2d6fa15d405cceb8572a7ff1" translate="yes" xml:space="preserve">
          <source>On the server side, user code will typically not listen for this event directly, and would instead register a handler for the &lt;code&gt;'stream'&lt;/code&gt; event emitted by the &lt;code&gt;net.Server&lt;/code&gt; or &lt;code&gt;tls.Server&lt;/code&gt; instances returned by &lt;code&gt;http2.createServer()&lt;/code&gt; and &lt;code&gt;http2.createSecureServer()&lt;/code&gt;, respectively, as in the example below:</source>
          <target state="translated">서버 측에서 사용자 코드는 일반적으로이 이벤트를 직접 수신하지 않고 &lt;code&gt;http2.createServer()&lt;/code&gt; 및 &lt;code&gt;http2.createSecureServer()&lt;/code&gt; 의해 리턴 된 net.Server 또는 &lt;code&gt;tls.Server&lt;/code&gt; 인스턴스 에서 &lt;code&gt;net.Server&lt;/code&gt; 된 &lt;code&gt;'stream'&lt;/code&gt; 이벤트에 대한 핸들러를 등록합니다. 아래 예와 같이 각각 ()</target>
        </trans-unit>
        <trans-unit id="b28a2e0cd081287892b62dd1e0f530cc16c1da53" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;process.connected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, it is no longer possible to send messages over the IPC channel using &lt;code&gt;process.send()&lt;/code&gt;.</source>
          <target state="translated">일단 &lt;code&gt;process.connected&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 그것은 IPC 채널 사용을 통해 메시지를 보내 더 이상 가능하다 &lt;code&gt;process.send()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa23dc4c315219e395e0590efe1a2b70ca58a09" translate="yes" xml:space="preserve">
          <source>Once a &lt;code&gt;Socket&lt;/code&gt; has been bound to an &lt;code&gt;Http2Session&lt;/code&gt;, user code should rely solely on the API of the &lt;code&gt;Http2Session&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; 이 &lt;code&gt;Http2Session&lt;/code&gt; 에 바인딩 되면 사용자 코드는 &lt;code&gt;Http2Session&lt;/code&gt; 의 API에만 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d73920c9a9f1ea9d30889c8dfb8841df2a90c168" translate="yes" xml:space="preserve">
          <source>Once a socket has been passed to a child, the parent is no longer capable of tracking when the socket is destroyed. To indicate this, the &lt;code&gt;.connections&lt;/code&gt; property becomes &lt;code&gt;null&lt;/code&gt;. It is recommended not to use &lt;code&gt;.maxConnections&lt;/code&gt; when this occurs.</source>
          <target state="translated">소켓이 자식에게 전달되면 소켓은 소켓이 파괴 될 때 더 이상 추적 할 수 없습니다. 이를 나타 내기 위해 &lt;code&gt;.connections&lt;/code&gt; 속성이 &lt;code&gt;null&lt;/code&gt; 이 됩니다. 이 경우 &lt;code&gt;.maxConnections&lt;/code&gt; 를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a692176ad95c5de300944c8834aa875a0d87f9b1" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_setkeepalive_enable_initialdelay&quot;&gt;&lt;code&gt;socket.setKeepAlive()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당되고 연결되면 &lt;a href=&quot;net#net_socket_setkeepalive_enable_initialdelay&quot;&gt; &lt;code&gt;socket.setKeepAlive()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7f52f26999bdf868260d070323acc69b57258b58" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_setnodelay_nodelay&quot;&gt;&lt;code&gt;socket.setNoDelay()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당하고 연결되면 &lt;a href=&quot;net#net_socket_setnodelay_nodelay&quot;&gt; &lt;code&gt;socket.setNoDelay()&lt;/code&gt; &lt;/a&gt; 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="33c79533c7386872c12f4b58db6859df57263cfa" translate="yes" xml:space="preserve">
          <source>Once a socket is assigned to this request and is connected &lt;a href=&quot;net#net_socket_settimeout_timeout_callback&quot;&gt;&lt;code&gt;socket.setTimeout()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">소켓이이 요청에 할당되고 연결되면 &lt;a href=&quot;net#net_socket_settimeout_timeout_callback&quot;&gt; &lt;code&gt;socket.setTimeout()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="efd079e73c7a96e390596e9440343bcb5e17ed66" translate="yes" xml:space="preserve">
          <source>Once again, to build this example, the &lt;code&gt;myobject.cc&lt;/code&gt; file must be added to the &lt;code&gt;binding.gyp&lt;/code&gt;:</source>
          <target state="translated">이 예제를 다시 작성하려면 &lt;code&gt;myobject.cc&lt;/code&gt; 파일을 &lt;code&gt;binding.gyp&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0f447123bcb9f711d107a546941eab8691f611f" translate="yes" xml:space="preserve">
          <source>Once an event has been emitted, all listeners attached to it at the time of emitting will be called in order. This implies that any &lt;code&gt;removeListener()&lt;/code&gt; or &lt;code&gt;removeAllListeners()&lt;/code&gt; calls &lt;em&gt;after&lt;/em&gt; emitting and &lt;em&gt;before&lt;/em&gt; the last listener finishes execution will not remove them from &lt;code&gt;emit()&lt;/code&gt; in progress. Subsequent events will behave as expected.</source>
          <target state="translated">이벤트가 생성되면 생성시 연결된 모든 리스너가 순서대로 호출됩니다. 이는 방출 &lt;em&gt;후&lt;/em&gt; 및 마지막 리스너 실행이 완료 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;removeListener()&lt;/code&gt; 또는 &lt;code&gt;removeAllListeners()&lt;/code&gt; 호출 이 진행중인 &lt;code&gt;emit()&lt;/code&gt; 에서 제거되지 않음을 의미합니다 . 후속 이벤트는 예상대로 작동합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2b0e5947e0cec9da5491e6da952ace81743900d" translate="yes" xml:space="preserve">
          <source>Once built, the binary Addon can be used from within Node.js by pointing &lt;a href=&quot;modules#modules_require_id&quot;&gt;&lt;code&gt;require()&lt;/code&gt;&lt;/a&gt; to the built &lt;code&gt;addon.node&lt;/code&gt; module:</source>
          <target state="translated">빌드 된 바이너리 &lt;code&gt;addon.node&lt;/code&gt; 은 &lt;a href=&quot;modules#modules_require_id&quot;&gt; &lt;code&gt;require()&lt;/code&gt; &lt;/a&gt; 를 빌드 된 addon.node 모듈 로 지정하여 Node.js 내에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15b98e33970016f35017b9cd3f8d13b67f71f0b2" translate="yes" xml:space="preserve">
          <source>Once called, the &lt;code&gt;http2session.pendingSettingsAck&lt;/code&gt; property will be &lt;code&gt;true&lt;/code&gt; while the session is waiting for the remote peer to acknowledge the new settings.</source>
          <target state="translated">라고하면, &lt;code&gt;http2session.pendingSettingsAck&lt;/code&gt; 속성이 될 것입니다 &lt;code&gt;true&lt;/code&gt; 세션이 새 설정을 확인하는 원격 피어를 기다리는 동안.</target>
        </trans-unit>
        <trans-unit id="b7b49eb661c1323cc9c21687a30ad06fc5aca2c4" translate="yes" xml:space="preserve">
          <source>Once compiled, the example Addon can be required and used from within Node.js:</source>
          <target state="translated">컴파일되면 Addon 예제가 필요하며 Node.js 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c860007d4d4eedf037226ad7546486c7073ead4f" translate="yes" xml:space="preserve">
          <source>Once created the async worker can be queued for execution using the &lt;a href=&quot;#n_api_napi_queue_async_work&quot;&gt;&lt;code&gt;napi_queue_async_work&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">일단 생성되면 비동기 작업자는 &lt;a href=&quot;#n_api_napi_queue_async_work&quot;&gt; &lt;code&gt;napi_queue_async_work&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 실행을 위해 대기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fde554252391956e05e5ec8e1b886df2dade9a50" translate="yes" xml:space="preserve">
          <source>Once destroyed, the &lt;code&gt;Http2Session&lt;/code&gt; will emit the &lt;code&gt;'close'&lt;/code&gt; event. If &lt;code&gt;error&lt;/code&gt; is not undefined, an &lt;code&gt;'error'&lt;/code&gt; event will be emitted immediately before the &lt;code&gt;'close'&lt;/code&gt; event.</source>
          <target state="translated">일단 &lt;code&gt;Http2Session&lt;/code&gt; 이 파괴되면 &lt;code&gt;'close'&lt;/code&gt; 이벤트가 발생합니다. &lt;code&gt;error&lt;/code&gt; 가 정의되지 않은 경우 &lt;code&gt;'close'&lt;/code&gt; 이벤트 직전에 &lt;code&gt;'error'&lt;/code&gt; 이벤트가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b2d38c26dd12cdd65c7b3c851e009727e58fdc0" translate="yes" xml:space="preserve">
          <source>Once enabled, Node.js will treat the following as ES modules when passed to &lt;code&gt;node&lt;/code&gt; as the initial input, or when referenced by &lt;code&gt;import&lt;/code&gt; statements within ES module code:</source>
          <target state="translated">활성화되면 Node.js는 &lt;code&gt;node&lt;/code&gt; 에 초기 입력으로 전달 되거나 ES 모듈 코드 내의 &lt;code&gt;import&lt;/code&gt; 문에서 참조 될 때 다음을 ES 모듈로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="73e0f4c1adc95b4748965a8b094cee1cd3d7802c" translate="yes" xml:space="preserve">
          <source>Once no more items are left in the queue, the idle loop must be suspended. This error indicates that the idle loop has failed to stop.</source>
          <target state="translated">대기열에 더 이상 항목이 남아 있지 않으면 유휴 루프를 일시 중단해야합니다. 이 오류는 유휴 루프가 중지되지 않았 음을 나타냅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
