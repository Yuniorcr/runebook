<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="8ace34e863de930657650d2da4b04c7f1f377acc" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;useEffect&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 경쟁 조건</target>
        </trans-unit>
        <trans-unit id="5c456dc6554aed5954e8c75d3fa6572cdb27a30f" translate="yes" xml:space="preserve">
          <source>Race Conditions with componentDidUpdate</source>
          <target state="translated">componentDidUpdate를 사용한 경쟁 조건</target>
        </trans-unit>
        <trans-unit id="42274756b2dc2c17eaeb7f294f21deef9e594667" translate="yes" xml:space="preserve">
          <source>Race Conditions with useEffect</source>
          <target state="translated">사용시 경쟁 조건</target>
        </trans-unit>
        <trans-unit id="7a22b192ac2fa53d431f80c3ed1ab58049c5282b" translate="yes" xml:space="preserve">
          <source>Race conditions are bugs that happen due to incorrect assumptions about the order in which our code may run. Fetching data in the &lt;code&gt;useEffect&lt;/code&gt; Hook or in class lifecycle methods like &lt;code&gt;componentDidUpdate&lt;/code&gt; often leads to them. Suspense can help here, too &amp;mdash; let&amp;rsquo;s see how.</source>
          <target state="translated">경쟁 조건은 코드 실행 순서에 대한 잘못된 가정으로 인해 발생하는 버그입니다. &lt;code&gt;useEffect&lt;/code&gt; Hook 또는 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 같은 클래스 라이프 사이클 메소드에서 데이터를 가져 오는 경우 종종 데이터를 가져옵니다 . 서스펜스도 여기서 도움을 줄 수 있습니다. 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="14755c296af9379808222382bdd6b5de345159dc" translate="yes" xml:space="preserve">
          <source>Rarely Used Lifecycle Methods</source>
          <target state="translated">드물게 사용되는 수명주기 방법</target>
        </trans-unit>
        <trans-unit id="26dd7fe02a64876676c6cbd9aa8708f0a20b47f9" translate="yes" xml:space="preserve">
          <source>Re-render the in-memory tree with a new root element. This simulates a React update at the root. If the new element has the same type and key as the previous element, the tree will be updated; otherwise, it will re-mount a new tree.</source>
          <target state="translated">새 루트 요소를 사용하여 메모리 내 트리를 다시 렌더링하십시오. 루트에서 React 업데이트를 시뮬레이션합니다. 새로운 요소가 이전 요소와 유형과 키가 같으면 트리가 업데이트됩니다. 그렇지 않으면 새 트리가 다시 마운트됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="cec80c2bc8202e23af151e7f74a7ef7ace217cd9" translate="yes" xml:space="preserve">
          <source>React 15 included a very limited support for error boundaries under a different method name: &lt;code&gt;unstable_handleError&lt;/code&gt;. This method no longer works, and you will need to change it to &lt;code&gt;componentDidCatch&lt;/code&gt; in your code starting from the first 16 beta release.</source>
          <target state="translated">React 15에는 다른 메소드 이름으로 &lt;code&gt;unstable_handleError&lt;/code&gt; 와 같은 오류 경계에 대한 매우 제한된 지원이 포함되었습니다 . 이 방법은 더 이상 작동하지 않으며 첫 16 베타 릴리스부터 코드에서 &lt;code&gt;componentDidCatch&lt;/code&gt; 로 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d738f325e7c19b6858708f27583b05cb0428fc2" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">반응 16은 콜렉션 유형 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; 에 따라 다릅니다 . 아직 기본적으로 제공하지 않는 (예 : IE &amp;lt;11) 또는 호환되지 않는 구현 (예 : IE 11) 이전 브라우저 및 장치를 지원하는 경우 번들 애플리케이션에 &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; 또는 &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel&lt;/a&gt; 과 같은 전역 폴리 필을 포함시키는 것을 고려하십시오 -polyfill .</target>
        </trans-unit>
        <trans-unit id="74986fa4e985ed82adb453f97ce762c40df9fea1" translate="yes" xml:space="preserve">
          <source>React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;.</source>
          <target state="translated">React 16 depends on the collection types &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;. If you support older browsers and devices which may not yet provide these natively (e.g. IE &amp;lt; 11) or which have non-compliant implementations (e.g. IE 11), consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1051bec19cd5874a397897a7f06cc6437c451c36" translate="yes" xml:space="preserve">
          <source>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</source>
          <target state="translated">React 16은 응용 프로그램이 실수로 삼킨 경우에도 개발중인 콘솔에 렌더링하는 동안 발생한 모든 오류를 인쇄합니다. 오류 메시지 및 JavaScript 스택 외에도 구성 요소 스택 추적도 제공합니다. 이제 컴포넌트 트리에서 정확히 어디에서 오류가 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30e0407bcbcc67abd7c79d5c3bd2fcd47ad42dd9" translate="yes" xml:space="preserve">
          <source>React 16.3 added a third option that offers the convenience of a string ref without any of the downsides:</source>
          <target state="translated">React 16.3에는 단점이없는 문자열 참조의 편의성을 제공하는 세 번째 옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c32dfc45304c45a68c84f0c0ee4c4f05460c24f" translate="yes" xml:space="preserve">
          <source>React 16.6 added a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; component that lets you &amp;ldquo;wait&amp;rdquo; for some code to load and declaratively specify a loading state (like a spinner) while we&amp;rsquo;re waiting:</source>
          <target state="translated">React 16.6에는 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 컴포넌트가 추가되었습니다. 대기중인 동안 일부 코드가로드 될 때까지 기다리면서로드 상태 (예 : 스피너)를 선언적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b645cea94d9f5a02a027aeb84445527c67977cf7" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0은 후크를 지원하는 첫 번째 릴리스입니다. 업그레이드 할 때는 React DOM을 포함한 모든 패키지를 업데이트해야합니다. React Native는 React Native &lt;a href=&quot;https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059&quot;&gt;0.59 릴리스&lt;/a&gt; 이후 후크를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e30a4592694f3d8efb2c8c6a713f826f50e4e4ee" translate="yes" xml:space="preserve">
          <source>React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</source>
          <target state="translated">React 16.8.0 is the first release to support Hooks. When upgrading, don&amp;rsquo;t forget to update all packages, including React DOM. React Native supports Hooks since &lt;a href=&quot;https://reactnative.dev/blog/2019/03/12/releasing-react-native-059&quot;&gt;the 0.59 release of React Native&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3fb6d1eb7c6bbf9522f3b769efa0699d62f423a0" translate="yes" xml:space="preserve">
          <source>React 17 on the web &lt;strong&gt;does not&lt;/strong&gt; use event pooling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2fa57c98aa2ff66a34e3804ba4afdbf43f949c" translate="yes" xml:space="preserve">
          <source>React &lt;a href=&quot;react-without-jsx&quot;&gt;doesn&amp;rsquo;t require&lt;/a&gt; using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</source>
          <target state="translated">React &lt;a href=&quot;react-without-jsx&quot;&gt;는&lt;/a&gt; JSX를 사용할 필요는 없지만 대부분의 사람들은 JavaScript 코드 내에서 UI로 작업 할 때 시각적 도움으로 유용하다고 생각합니다. 또한 React가 더 유용한 오류 및 경고 메시지를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56b4ec7d4044adf40d8ea846a837d5e5d0e2ec1" translate="yes" xml:space="preserve">
          <source>React DOM</source>
          <target state="translated">DOM 반응</target>
        </trans-unit>
        <trans-unit id="0e17312bf427154aa9521cc18565e992f954d046" translate="yes" xml:space="preserve">
          <source>React DOM Server</source>
          <target state="translated">DOM 서버 반응</target>
        </trans-unit>
        <trans-unit id="6783695eda495767c874d2c12b708f12b9eb5c68" translate="yes" xml:space="preserve">
          <source>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</source>
          <target state="translated">React DOM은 요소와 하위 요소를 이전 요소와 비교하고 DOM을 원하는 상태로 만드는 데 필요한 DOM 업데이트 만 적용합니다.</target>
        </trans-unit>
        <trans-unit id="c0f543b7e06f16286089bf4be437499e1b43b727" translate="yes" xml:space="preserve">
          <source>React DOM efficiently updates the DOM to match &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">React DOM은 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; 과 일치하도록 DOM을 효율적으로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="9fdeb7ff15e5768ee7e11ab66cd7913eac488847" translate="yes" xml:space="preserve">
          <source>React DOM updates the DOM with the boiling verdict and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</source>
          <target state="translated">React DOM은 끓는 평결로 DOM을 업데이트하고 원하는 입력 값과 일치시킵니다. 방금 편집 한 입력은 현재 값을 수신하고 다른 입력은 변환 후 온도로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3e9e3b704e86ac0ae2261ed5ae0110bb475463" translate="yes" xml:space="preserve">
          <source>React DOM uses camelCase property naming convention instead of HTML attribute names. For example, &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;code&gt;tabIndex&lt;/code&gt; in JSX. The attribute &lt;code&gt;class&lt;/code&gt; is also written as &lt;code&gt;className&lt;/code&gt; since &lt;code&gt;class&lt;/code&gt; is a reserved word in JavaScript:</source>
          <target state="translated">React DOM은 HTML 속성 이름 대신 camelCase 속성 명명 규칙을 사용합니다. 예를 들어 &lt;code&gt;tabindex&lt;/code&gt; 는 JSX에서 &lt;code&gt;tabIndex&lt;/code&gt; 가됩니다. 속성 &lt;code&gt;class&lt;/code&gt; 또한으로 기록되는 &lt;code&gt;className&lt;/code&gt; 때문에 &lt;code&gt;class&lt;/code&gt; 자바 스크립트에서 예약어 :</target>
        </trans-unit>
        <trans-unit id="64f7152b69ea8b7e6f11fc24d5c27c7549c6acd1" translate="yes" xml:space="preserve">
          <source>React Documentation</source>
          <target state="translated">반응 문서</target>
        </trans-unit>
        <trans-unit id="3a01dc41ed1fa68614175afe8e165764d9609ab0" translate="yes" xml:space="preserve">
          <source>React Must Be in Scope</source>
          <target state="translated">반응 범위 내에 있어야합니다</target>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="translated">네이티브 반응</target>
        </trans-unit>
        <trans-unit id="a2c6dfc0e1dfdf3f794b802a1ba06278b93a1b13" translate="yes" xml:space="preserve">
          <source>React Only Updates What&amp;rsquo;s Necessary</source>
          <target state="translated">필요한 업데이트 만 반응</target>
        </trans-unit>
        <trans-unit id="3633a811906ebb40f86bdd77c315e1e2bde36321" translate="yes" xml:space="preserve">
          <source>React Redux since v7.1.0 &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;supports Hooks API&lt;/a&gt; and exposes hooks like &lt;code&gt;useDispatch&lt;/code&gt; or &lt;code&gt;useSelector&lt;/code&gt;.</source>
          <target state="translated">v7.1.0부터 React Redux &lt;a href=&quot;https://react-redux.js.org/api/hooks&quot;&gt;는 Hooks API를 지원&lt;/a&gt; 하고 &lt;code&gt;useDispatch&lt;/code&gt; 또는 &lt;code&gt;useSelector&lt;/code&gt; 와 같은 후크를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb3fe34bf0fbac0db48c2c52246f7bf4643b58d" translate="yes" xml:space="preserve">
          <source>React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;supports hooks&lt;/a&gt; since v5.1.</source>
          <target state="translated">React Router &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Hooks&quot;&gt;는&lt;/a&gt; v5.1 이후 후크를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="db30dab9afce5ee17ad60f6815d45c7d2775403c" translate="yes" xml:space="preserve">
          <source>React Shallow Renderer</source>
          <target state="translated">얕은 렌더러 반응</target>
        </trans-unit>
        <trans-unit id="59f752bd2488cbb706a191bae6c25ec360c9ae78" translate="yes" xml:space="preserve">
          <source>React Test Renderer</source>
          <target state="translated">반응 테스트 렌더러</target>
        </trans-unit>
        <trans-unit id="493a1a450ae702c6d46a164382378d365c88d431" translate="yes" xml:space="preserve">
          <source>React Testing Library offers a &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;more concise helper&lt;/a&gt; for firing events.</source>
          <target state="translated">React Testing Library는 발사 이벤트를위한 &lt;a href=&quot;https://testing-library.com/docs/dom-testing-library/api-events&quot;&gt;보다 간결한 도우미&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="a3a37522e503e9a2cee5bb38180398e2a23e1f1f" translate="yes" xml:space="preserve">
          <source>React Top-Level API</source>
          <target state="translated">최상위 API 반응</target>
        </trans-unit>
        <trans-unit id="8e60d7618dece37120d3987205a0d2168962460f" translate="yes" xml:space="preserve">
          <source>React Without ES6</source>
          <target state="translated">ES6없이 반응</target>
        </trans-unit>
        <trans-unit id="cd5884fb1f8e40d0ef6cbe86d6584a46690762e1" translate="yes" xml:space="preserve">
          <source>React Without JSX</source>
          <target state="translated">JSX없이 반응</target>
        </trans-unit>
        <trans-unit id="9fe2f9ba8b44464b4bfefd199f9bc13307ee3332" translate="yes" xml:space="preserve">
          <source>React also depends on &lt;code&gt;requestAnimationFrame&lt;/code&gt; (even in test environments).</source>
          <target state="translated">반응은 또한 &lt;code&gt;requestAnimationFrame&lt;/code&gt; (테스트 환경에서도)에 의존합니다 .</target>
        </trans-unit>
        <trans-unit id="7d8f2b9666834dcad7e288b25fd8480664eaad61" translate="yes" xml:space="preserve">
          <source>React also supports another way to set refs called &amp;ldquo;callback refs&amp;rdquo;, which gives more fine-grain control over when refs are set and unset.</source>
          <target state="translated">React는 또한 &quot;콜백 참조&quot;라는 참조를 설정하는 또 다른 방법을 지원합니다. 이는 참조가 설정 및 설정 해제 될 때를보다 세밀하게 제어 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="10225c998465dfe979466a99502e0be87e759457" translate="yes" xml:space="preserve">
          <source>React and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary. As a developer, you are free to use React in your Web Components, or to use Web Components in React, or both.</source>
          <target state="translated">React와 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt; 는 다양한 문제를 해결하기 위해 만들어졌습니다. 웹 구성 요소는 재사용 가능한 구성 요소를 강력하게 캡슐화하고 React는 DOM을 데이터와 동기화하는 선언적 라이브러리를 제공합니다. 두 목표는 상호 보완 적입니다. 개발자는 웹 구성 요소에서 React를 사용하거나 React에서 웹 구성 요소를 사용하거나 둘 다 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27082daf4244e21a91a723f26657721dc905d29e" translate="yes" xml:space="preserve">
          <source>React builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a &amp;ldquo;virtual DOM&amp;rdquo;, but it works the same way on React Native.</source>
          <target state="translated">React는 렌더링 된 UI의 내부 표현을 작성하고 유지합니다. 여기에는 컴포넌트에서 반환 한 React 요소가 포함됩니다. 이 표현은 React가 DOM 노드를 생성하고 필요 이상으로 기존 노드에 액세스하는 것을 피할 수있게 해줍니다. JavaScript 객체에서의 작업보다 느릴 수 있습니다. 때로는 &quot;가상 DOM&quot;이라고도하지만 React Native에서 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="610b64665a6a2f5e728c19e6eca03a8b39cdcf07" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Calculator&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</source>
          <target state="translated">React는 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소의 &lt;code&gt;render&lt;/code&gt; 메소드를 호출하여 UI의 모양을 학습합니다. 두 입력의 값은 현재 온도와 활성 스케일에 따라 다시 계산됩니다. 여기에서 온도 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ba853d2a17e24f0bd22d89450b9557d4a2c11971" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;Welcome&lt;/code&gt; component with &lt;code&gt;{name: 'Sara'}&lt;/code&gt; as the props.</source>
          <target state="translated">React 는 소품 으로 &lt;code&gt;{name: 'Sara'}&lt;/code&gt; 를 사용하여 &lt;code&gt;Welcome&lt;/code&gt; 컴포넌트를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d6f2ebfc937521d2470061f7e3d9cde73833393e" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; method of the &lt;code&gt;BoilingVerdict&lt;/code&gt; component, passing the temperature in Celsius as its props.</source>
          <target state="translated">React 는 &lt;code&gt;BoilingVerdict&lt;/code&gt; 컴포넌트 의 &lt;code&gt;render&lt;/code&gt; 메소드를 호출하여 온도를 섭씨 온도로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f3922365ae8f20c0cd2b94600d6dd96e8199f37c" translate="yes" xml:space="preserve">
          <source>React calls the &lt;code&gt;render&lt;/code&gt; methods of the individual &lt;code&gt;TemperatureInput&lt;/code&gt; components with their new props specified by the &lt;code&gt;Calculator&lt;/code&gt;. It learns what their UI should look like.</source>
          <target state="translated">React 는 &lt;code&gt;Calculator&lt;/code&gt; 에 의해 지정된 새로운 props로 개별 &lt;code&gt;TemperatureInput&lt;/code&gt; 컴포넌트 의 &lt;code&gt;render&lt;/code&gt; 메소드를 호출합니다 . UI가 어떻게 생겼는지 배웁니다.</target>
        </trans-unit>
        <trans-unit id="36fdfacce7eedd6661f907c10f0f4ea9af876fce" translate="yes" xml:space="preserve">
          <source>React calls the function specified as &lt;code&gt;onChange&lt;/code&gt; on the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In our case, this is the &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component.</source>
          <target state="translated">React 는 DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 &lt;code&gt;onChange&lt;/code&gt; 로 지정된 함수를 호출합니다 . 우리의 경우에 이것은 &lt;code&gt;TemperatureInput&lt;/code&gt; 컴포넌트 의 &lt;code&gt;handleChange&lt;/code&gt; 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="bd8b2d2111896cb2314cfe1f0bde6a55efe40119" translate="yes" xml:space="preserve">
          <source>React can be embedded into other applications thanks to the flexibility of &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; 의 유연성 덕분에 React를 다른 애플리케이션에 임베드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1330ed30fca80f90b213d9b6f69f3e0df6ecab7" translate="yes" xml:space="preserve">
          <source>React can be used in any web application. It can be embedded in other applications and, with a little care, other applications can be embedded in React. This guide will examine some of the more common use cases, focusing on integration with &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt;, but the same ideas can be applied to integrating components with any existing code.</source>
          <target state="translated">React는 모든 웹 응용 프로그램에서 사용할 수 있습니다. 다른 애플리케이션에 임베드 될 수 있으며 약간의주의를 기울이면 다른 애플리케이션을 React에 임베드 할 수 있습니다. 이 가이드에서는 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 및 &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; 과의 통합에 중점을 두는보다 일반적인 사용 사례를 살펴볼 것이지만 기존 코드와 컴포넌트를 통합하는 데 동일한 아이디어를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d37e463c6f9b2a55b2880cfa9eafdf5e114306ed" translate="yes" xml:space="preserve">
          <source>React can be used to power animations. See &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; and &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; or &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring&lt;/a&gt;, for example.</source>
          <target state="translated">리 액트를 사용하여 애니메이션을 강화할 수 있습니다. 예를 들어, &lt;a href=&quot;https://reactcommunity.org/react-transition-group/&quot;&gt;React Transition Group&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;React Motion&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/react-spring/react-spring&quot;&gt;React Spring을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c793e68bb1fac249aba0ce5f3bec7e5d7023c434" translate="yes" xml:space="preserve">
          <source>React community&amp;rsquo;s experiments with render prop APIs, including &lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ryanflorence&quot;&gt;Ryan Florence&lt;/a&gt; 의 &lt;a href=&quot;https://github.com/reactions/component&quot;&gt;Reactions Component를&lt;/a&gt; 포함한 렌더링 소품 API로 커뮤니티의 실험에 반응하십시오 .</target>
        </trans-unit>
        <trans-unit id="27be082454b7d8bc7b1e13ab663caeb1f2c60981" translate="yes" xml:space="preserve">
          <source>React components are small, reusable pieces of code that return a React element to be rendered to the page. The simplest version of React component is a plain JavaScript function that returns a React element:</source>
          <target state="translated">React 컴포넌트는 페이지에 렌더링 할 React 요소를 반환하는 재사용 가능한 작은 코드 조각입니다. React 구성 요소의 가장 간단한 버전은 React 요소를 반환하는 일반 JavaScript 함수입니다.</target>
        </trans-unit>
        <trans-unit id="48861e38df56656ab830494ad258a4d6191d07f5" translate="yes" xml:space="preserve">
          <source>React components can also be defined as functions which can be wrapped:</source>
          <target state="translated">리 액트 컴포넌트는 랩핑 할 수있는 함수로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4cc5817b2558aba649764feaed76c372dd8b626" translate="yes" xml:space="preserve">
          <source>React components have their own &amp;ldquo;lifecycle&amp;rdquo;. They may receive props or update state at any point in time. However, each asynchronous request &lt;em&gt;also&lt;/em&gt; has its own &amp;ldquo;lifecycle&amp;rdquo;. It starts when we kick it off, and finishes when we get a response. The difficulty we&amp;rsquo;re experiencing is &amp;ldquo;synchronizing&amp;rdquo; several processes in time that affect each other. This is hard to think about.</source>
          <target state="translated">반응 구성 요소에는 자체 &quot;라이프 사이클&quot;이 있습니다. 그들은 언제든지 소품을 받거나 상태를 업데이트 할 수 있습니다. 그러나 각 비동기 요청은 &lt;em&gt;또한&lt;/em&gt; 자신의 '라이프 사이클'이있다. 시작하면 시작되고 응답을 받으면 끝납니다. 우리가 겪고있는 어려움은 서로 영향을 미치는 여러 프로세스를 &quot;동기화&quot;하는 것입니다. 생각하기 어렵다.</target>
        </trans-unit>
        <trans-unit id="4222b5a8657725e4a00728011e55a70511e28796" translate="yes" xml:space="preserve">
          <source>React components hide their implementation details, including their rendered output. Other components using &lt;code&gt;FancyButton&lt;/code&gt;&lt;strong&gt;usually will not need to&lt;/strong&gt;&lt;a href=&quot;refs-and-the-dom&quot;&gt;obtain a ref&lt;/a&gt; to the inner &lt;code&gt;button&lt;/code&gt; DOM element. This is good because it prevents components from relying on each other&amp;rsquo;s DOM structure too much.</source>
          <target state="translated">React 컴포넌트는 렌더링 된 출력을 포함하여 구현 세부 사항을 숨 깁니다. &lt;code&gt;FancyButton&lt;/code&gt; 을 사용하는 다른 구성 요소 &lt;strong&gt;는 일반적으로&lt;/strong&gt; 내부 &lt;code&gt;button&lt;/code&gt; DOM 요소에 &lt;a href=&quot;refs-and-the-dom&quot;&gt;대한 참조&lt;/a&gt; 를 얻을 &lt;strong&gt;필요가 없습니다&lt;/strong&gt; . 이것은 컴포넌트가 서로의 DOM 구조에 너무 의존하지 못하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5817ef7548b0234e3521fa7650bb8ea6c27ada2e" translate="yes" xml:space="preserve">
          <source>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing &lt;code&gt;React.Component&lt;/code&gt; or &lt;code&gt;React.PureComponent&lt;/code&gt;.</source>
          <target state="translated">React 구성 요소를 사용하면 UI를 독립적이고 재사용 가능한 조각으로 분할하고 각 조각을 분리하여 생각할 수 있습니다. &lt;code&gt;React.Component&lt;/code&gt; 또는 &lt;code&gt;React.PureComponent&lt;/code&gt; 를 서브 클래 싱하여 React 구성 요소를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca8d82c06b82b483efb7cfed08df669ddf86929f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t call &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; with initial props during &lt;a href=&quot;#mounting&quot;&gt;mounting&lt;/a&gt;. It only calls this method if some of component&amp;rsquo;s props may update. Calling &lt;code&gt;this.setState()&lt;/code&gt; generally doesn&amp;rsquo;t trigger &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;.</source>
          <target state="translated">React는 &lt;a href=&quot;#mounting&quot;&gt;마운트&lt;/a&gt; 하는 동안 초기 소품으로 &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 를 호출하지 않습니다 . 컴포넌트의 소품 중 일부가 업데이트 될 수있는 경우에만이 메소드를 호출합니다. &lt;code&gt;this.setState()&lt;/code&gt; 호출하면 일반적으로 &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt; 트리거되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca31c5026bd08138666663526caeedbe15b5ea02" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t force you to use the ES6 class syntax. If you prefer to avoid it, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module or a similar custom abstraction instead. Take a look at &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; to learn more.</source>
          <target state="translated">React는 ES6 클래스 구문을 사용하도록 강요하지 않습니다. 피하기를 원한다면 &lt;code&gt;create-react-class&lt;/code&gt; 모듈 또는 유사한 사용자 정의 추상화를 대신 사용할 수 있습니다. 에서보세요 &lt;a href=&quot;react-without-es6&quot;&gt;사용은 ES6없이 반작용&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="74b56919404ce18c573bf25676a77e3c0c3ec215" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t have opinions on how you put files into folders. That said there are a few common approaches popular in the ecosystem you may want to consider.</source>
          <target state="translated">React는 파일을 폴더에 넣는 방법에 대한 의견이 없습니다. 그것은 당신이 고려하고 싶을 수도있는 생태계에서 인기있는 몇 가지 일반적인 접근법이 있다고 말했다.</target>
        </trans-unit>
        <trans-unit id="65aea3f2a5c31b29c9426cd1a03d900e3079061c" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don&amp;rsquo;t happen during rendering. So if they throw, React still knows what to display on the screen.</source>
          <target state="translated">React는 이벤트 핸들러의 오류를 복구하기 위해 오류 경계가 필요하지 않습니다. render 메서드 및 lifecycle 메서드와 달리 이벤트 처리기는 렌더링 중에 발생하지 않습니다. 따라서 그들이 던지면 React는 여전히 화면에 무엇을 표시할지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd4db2f190bce0d1cd19887d508e28c6fb7d62f" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t offer a way to &amp;ldquo;attach&amp;rdquo; reusable behavior to a component (for example, connecting it to a store). If you&amp;rsquo;ve worked with React for a while, you may be familiar with patterns like &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow. If you look at a typical React application in React DevTools, you will likely find a &amp;ldquo;wrapper hell&amp;rdquo; of components surrounded by layers of providers, consumers, higher-order components, render props, and other abstractions. While we could &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;filter them out in DevTools&lt;/a&gt;, this points to a deeper underlying problem: React needs a better primitive for sharing stateful logic.</source>
          <target state="translated">React는 재사용 가능한 동작을 구성 요소에 &quot;첨부&quot;하는 방법을 제공하지 않습니다 (예 : 상점에 연결). React에서 잠시 작업 한 경우, &lt;a href=&quot;render-props&quot;&gt;렌더링 소품&lt;/a&gt; 및 이 문제를 해결하는 &lt;a href=&quot;higher-order-components&quot;&gt;고차 구성 요소&lt;/a&gt; 와 같은 패턴에 익숙 할 수 있습니다 . 그러나 이러한 패턴을 사용하면 구성 요소를 사용할 때 재구성해야하므로 번거롭고 코드를 따르기가 더 어려워 질 수 있습니다. React DevTools에서 일반적인 React 애플리케이션을 살펴보면 제공자, 소비자, 고차 컴포넌트, 렌더 소품 및 기타 추상화 계층으로 둘러싸인 컴포넌트의 &quot;래퍼 지옥&quot;을 찾을 수 있습니다. 우리는 &lt;a href=&quot;https://github.com/facebook/react-devtools/pull/503&quot;&gt;DevTools에서 그것들을 걸러&lt;/a&gt; 낼 수 있지만 , 이것은 더 근본적인 문제를 지적합니다. React는 상태 저장 논리를 공유하기 위해 더 나은 기본 요소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f78ca1328cbe2529b63f5cb261c75fa5b40138a1" translate="yes" xml:space="preserve">
          <source>React doesn&amp;rsquo;t use the &lt;code&gt;state = initialState&lt;/code&gt; argument convention popularized by Redux. The initial value sometimes needs to depend on props and so is specified from the Hook call instead. If you feel strongly about this, you can call &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; to emulate the Redux behavior, but it&amp;rsquo;s not encouraged.</source>
          <target state="translated">React는 Redux가 대중화 한 &lt;code&gt;state = initialState&lt;/code&gt; 인수 규칙을 사용하지 않습니다 . 초기 값은 때때로 소품에 의존해야하기 때문에 대신 후크 호출에서 지정됩니다. 이것에 대해 강하게 느끼면 &lt;code&gt;useReducer(reducer, undefined, reducer)&lt;/code&gt; 를 호출 하여 Redux 동작을 에뮬레이트 할 수 있지만 권장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d83294fcb3556b3e4c12f42b28d13fbaa61565e3" translate="yes" xml:space="preserve">
          <source>React elements are &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;immutable&lt;/a&gt;. Once you create an element, you can&amp;rsquo;t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</source>
          <target state="translated">반응 요소는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Immutable_object&quot;&gt;변경할 수 없습니다&lt;/a&gt; . 요소를 만든 후에는 해당 하위 요소 나 속성을 변경할 수 없습니다. 요소는 영화에서 단일 프레임과 같습니다. 특정 시점의 UI를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="72d7e53a8e0f9d5ea79b7f65c786e10e05c2fc30" translate="yes" xml:space="preserve">
          <source>React elements are the building blocks of React applications. One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. An element describes what you want to see on the screen. React elements are immutable.</source>
          <target state="translated">React 요소는 React 애플리케이션의 빌딩 블록입니다. 보다 널리 알려진 &quot;구성 요소&quot;개념과 요소를 혼동 할 수 있습니다. 요소는 화면에서보고 싶은 것을 설명합니다. 반응 요소는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6524f58f9d8f8ab1fca2ad781736505d87a9d6ca" translate="yes" xml:space="preserve">
          <source>React elements like &lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; are just objects, so you can pass them as props like any other data. This approach may remind you of &amp;ldquo;slots&amp;rdquo; in other libraries but there are no limitations on what you can pass as props in React.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Contacts /&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;Chat /&amp;gt;&lt;/code&gt; /&amp;gt; 과 같은 반응 요소 는 객체이므로 다른 데이터와 마찬가지로 소품으로 전달할 수 있습니다. 이 접근 방식은 다른 라이브러리의 &quot;슬롯&quot;을 상기시킬 수 있지만 React에서 소품으로 전달할 수있는 것에 대한 제한은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d783a77ced1d87ae35cd28616b7b8dde4c0feec8" translate="yes" xml:space="preserve">
          <source>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</source>
          <target state="translated">React는 렌더링 로직이 본질적으로 다른 UI 로직과 결합된다는 사실, 즉 이벤트 처리 방법, 시간 경과에 따른 상태 변경 방법 및 데이터 표시 준비 방법을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="71aa7bf3c2141f944fb5d607ee0a640c055cd5e3" translate="yes" xml:space="preserve">
          <source>React event handlers are named using camelCase, rather than lowercase.</source>
          <target state="translated">React 이벤트 핸들러는 소문자가 아닌 camelCase를 사용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaede23e33f54df8554d19c52716021dc6d0ad7" translate="yes" xml:space="preserve">
          <source>React events are named using camelCase, rather than lowercase.</source>
          <target state="translated">반응 이벤트는 소문자가 아닌 camelCase를 사용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d81cbd9c023137339681f3ecb86a4870cf58d1f3" translate="yes" xml:space="preserve">
          <source>React events will be grouped under the &lt;strong&gt;User Timing&lt;/strong&gt; label.</source>
          <target state="translated">반응 이벤트는 &lt;strong&gt;사용자 타이밍&lt;/strong&gt; 레이블 아래에 그룹화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a9f448560435e23fa1b8b20e5ca27d1ae3d080b" translate="yes" xml:space="preserve">
          <source>React expects that the rendered content is identical between the server and the client. It can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.</source>
          <target state="translated">React는 렌더링 된 컨텐츠가 서버와 클라이언트간에 동일 할 것으로 예상합니다. 텍스트 내용의 차이를 패치 할 수 있지만 불일치를 버그로 취급하고 수정해야합니다. 개발 모드에서 React는 수화 중 불일치에 대해 경고합니다. 불일치시 속성 차이가 패치 될 것이라는 보장은 없습니다. 대부분의 앱에서 불일치가 드물기 때문에 모든 마크 업을 검증하는 것은 엄청나게 비싸기 때문에 성능상의 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="688c4519446fdd44f425e4ac67a8e7c31b228818" translate="yes" xml:space="preserve">
          <source>React follows &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning (semver)&lt;/a&gt; principles.</source>
          <target state="translated">반응은 &lt;a href=&quot;https://semver.org/&quot;&gt;의미 버전 관리 (semver)&lt;/a&gt; 원칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="2ace8a8f59843973f666f085ceaf962fea60d36e" translate="yes" xml:space="preserve">
          <source>React for Beginners</source>
          <target state="translated">초보자를위한 반응</target>
        </trans-unit>
        <trans-unit id="0c447ed07bb40a48e19866c8e49bff0aaf61e27b" translate="yes" xml:space="preserve">
          <source>React for Designers</source>
          <target state="translated">디자이너를위한 반응</target>
        </trans-unit>
        <trans-unit id="a3064a3146d7f8947ad21494bc1745e87bfe69d8" translate="yes" xml:space="preserve">
          <source>React fully supports building accessible websites, often by using standard HTML techniques.</source>
          <target state="translated">React는 종종 표준 HTML 기술을 사용하여 액세스 가능한 웹 사이트를 완벽하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0931dcf2a1d7800c25ee9a956b9c2839a169eadd" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;dispatch&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">React는 &lt;code&gt;dispatch&lt;/code&gt; 기능 아이덴티티가 안정적이며 다시 렌더링 할 때 변경되지 않도록 보장 합니다. 따라서 &lt;code&gt;useEffect&lt;/code&gt; 또는 &lt;code&gt;useCallback&lt;/code&gt; 종속성 목록 에서 생략하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="760079d64e4b1bb1d3f5af076b4f911126e07d29" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;setState&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="translated">React는 &lt;code&gt;setState&lt;/code&gt; 함수 ID가 안정적이며 다시 렌더링 할 때 변경되지 않음을 보장 합니다. 따라서 &lt;code&gt;useEffect&lt;/code&gt; 또는 &lt;code&gt;useCallback&lt;/code&gt; 종속성 목록 에서 생략하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="52c2ef58675954a462a2178998aa8077eb12b98d" translate="yes" xml:space="preserve">
          <source>React guarantees that whenever we look at these components on the screen, they will reflect data from the same &lt;code&gt;user&lt;/code&gt;. If a different &lt;code&gt;user&lt;/code&gt; is passed down because of a state update, you would see them changing together. You can&amp;rsquo;t ever record a screen and find a frame where they would show values from different &lt;code&gt;user&lt;/code&gt;s. (If you ever run into a case like this, file a bug!)</source>
          <target state="translated">React는 화면에서 이러한 구성 요소를 볼 때마다 동일한 &lt;code&gt;user&lt;/code&gt; 데이터를 반영합니다 . 상태 업데이트로 인해 다른 &lt;code&gt;user&lt;/code&gt; 가 전달 되면 함께 변경되는 것을 볼 수 있습니다. 화면을 기록 할 수없고 다른 &lt;code&gt;user&lt;/code&gt; 의 값을 표시 할 프레임을 찾을 수 없습니다 . (이와 같은 경우에 버그가 있으면 버그를 신고하십시오!)</target>
        </trans-unit>
        <trans-unit id="cdc83e6519b0f0d8e4abbcdc04e6a6bc27050c9d" translate="yes" xml:space="preserve">
          <source>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</source>
          <target state="translated">React에는 강력한 컴포지션 모델이 있으므로 상속 대신 컴포지션을 사용하여 구성 요소간에 코드를 재사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df3b73a4c521d8e8577e5382082dcb38c98839b5" translate="yes" xml:space="preserve">
          <source>React has always provided a JavaScript-centric API to the DOM. Since React components often take both custom and DOM-related props, React uses the &lt;code&gt;camelCase&lt;/code&gt; convention just like the DOM APIs:</source>
          <target state="translated">React는 항상 JavaScript 중심의 API를 DOM에 제공했습니다. React 컴포넌트는 종종 사용자 정의 및 DOM 관련 소품을 모두 사용하므로 React는 DOM API와 같이 &lt;code&gt;camelCase&lt;/code&gt; 규칙을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6034f047f205ffc8dc240f7e19af8c137e1310ea" translate="yes" xml:space="preserve">
          <source>React has an API to update context, but it is fundamentally broken and you should not use it.</source>
          <target state="translated">React에는 컨텍스트를 업데이트하는 API가 있지만 근본적으로 손상되어 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="01b02eb95334a25e55e537194d6a183abb3dc8f6" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need.&lt;/strong&gt; Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app, the links in this section will help you get started.</source>
          <target state="translated">React는 점진적으로 채택 &lt;strong&gt;할 수 있도록&lt;/strong&gt; 처음부터 설계되었으며 &lt;strong&gt;필요한만큼 적게 또는 많이 사용할 수 있습니다. &lt;/strong&gt;React를 맛보고 싶거나 간단한 HTML 페이지에 대화 형 기능을 추가하거나 복잡한 React 기반 앱을 시작하려는 경우이 섹션의 링크를 사용하면 시작하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c050def493e7cae09b97f99b2e48a3bc9ad5f3d3" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need&lt;/strong&gt;. Perhaps you only want to add some &amp;ldquo;sprinkles of interactivity&amp;rdquo; to an existing page. React components are a great way to do that.</source>
          <target state="translated">React는 점진적으로 채택 &lt;strong&gt;할 수 있도록&lt;/strong&gt; 처음부터 설계되었으며 &lt;strong&gt;필요한만큼 또는 거의 React를 사용할 수 있습니다&lt;/strong&gt; . 아마도 기존 페이지에 일부&amp;ldquo;대화식 요소&amp;rdquo;를 추가하고 싶을 수도 있습니다. 반응 구성 요소는 그렇게하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7e2cc4782b2fb108291fcfae89e4501e3f4d58b8" translate="yes" xml:space="preserve">
          <source>React has two different approaches to dealing with form inputs.</source>
          <target state="translated">React에는 양식 입력을 처리하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6556acb734c30d6b0e81652863896aeac19e12df" translate="yes" xml:space="preserve">
          <source>React implements a browser-independent DOM system for performance and cross-browser compatibility. We took the opportunity to clean up a few rough edges in browser DOM implementations.</source>
          <target state="translated">React는 성능 및 브라우저 간 호환성을 위해 브라우저 독립적 인 DOM 시스템을 구현합니다. 우리는 브라우저 DOM 구현에서 거친 가장자리를 정리할 기회를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="6e11539e493eeb1713363587c427ffbbd6d68e65" translate="yes" xml:space="preserve">
          <source>React is a JavaScript library, and so we&amp;rsquo;ll assume you have a basic understanding of the JavaScript language. &lt;strong&gt;If you don&amp;rsquo;t feel very confident, we recommend &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;going through a JavaScript tutorial&lt;/a&gt; to check your knowledge level&lt;/strong&gt; and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour, but as a result you won&amp;rsquo;t have to feel like you&amp;rsquo;re learning both React and JavaScript at the same time.</source>
          <target state="translated">React는 JavaScript 라이브러리이므로 JavaScript 언어에 대한 기본 지식이 있다고 가정합니다. &lt;strong&gt;자신감이 없으면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;JavaScript 자습서&lt;/a&gt; 를 통해 지식 수준을 확인&lt;/strong&gt; 하고 길을 잃지 않고이 가이드를 따르십시오. 30 분에서 1 시간 정도 걸릴 수 있지만 결과적으로 React와 JavaScript를 동시에 배우고 있다고 느낄 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="61c3cb0936f8fb199aa04b34b04ecfe3125551c1" translate="yes" xml:space="preserve">
          <source>React is pretty flexible but it has a single strict rule:</source>
          <target state="translated">반응은 매우 유연하지만 하나의 엄격한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd576a79e84680cddef9aa2ab5587fa94134d1fe" translate="yes" xml:space="preserve">
          <source>React is unaware of changes made to the DOM outside of React. It determines updates based on its own internal representation, and if the same DOM nodes are manipulated by another library, React gets confused and has no way to recover.</source>
          <target state="translated">React는 React 외부의 DOM에 대한 변경 사항을 인식하지 못합니다. 자체 내부 표현을 기반으로 업데이트를 결정하고 다른 라이브러리에서 동일한 DOM 노드를 조작하는 경우 React가 혼동되어 복구 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cb3494e2a27c4434fdf174bb108a83ae2a686d9" translate="yes" xml:space="preserve">
          <source>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</source>
          <target state="translated">우리의 견해로는 React는 JavaScript를 사용하여 크고 빠른 웹 앱을 구축하는 최고의 방법입니다. Facebook과 Instagram에서 우리에게 아주 잘 맞습니다.</target>
        </trans-unit>
        <trans-unit id="56d6afe7c746ff7047ca63f1d78e3dc5b9dcfae0" translate="yes" xml:space="preserve">
          <source>React keeps track of the currently rendering component. Thanks to the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;, we know that Hooks are only called from React components (or custom Hooks &amp;mdash; which are also only called from React components).</source>
          <target state="translated">React는 현재 렌더링 컴포넌트를 추적합니다. &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙&lt;/a&gt; 덕분에 후크는 React 구성 요소 (또는 React 구성 요소에서만 호출되는 사용자 지정 후크)에서만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4e89f6b54b1e83e2f41d243abe76734deb9a4d0b" translate="yes" xml:space="preserve">
          <source>React lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend &lt;code&gt;React.Component&lt;/code&gt;:</source>
          <target state="translated">React를 사용하면 컴포넌트를 클래스 또는 함수로 정의 할 수 있습니다. 클래스로 정의 된 컴포넌트는 현재이 페이지에서 자세히 설명하는 더 많은 기능을 제공합니다. React 컴포넌트 클래스를 정의하려면 &lt;code&gt;React.Component&lt;/code&gt; 를 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="97a984b046ffb2272bbcd3ebf68f1025fff620f2" translate="yes" xml:space="preserve">
          <source>React makes this data flow explicit to help you understand how your program works, but it does require a little more typing than traditional two-way data binding.</source>
          <target state="translated">React는이 데이터 흐름을 명시 적으로 만들어 프로그램 작동 방식을 이해하는 데 도움이되지만 기존 양방향 데이터 바인딩보다 약간 더 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="51fd1862df14bb5b3bd3097a75315aaec37c0d5c" translate="yes" xml:space="preserve">
          <source>React may batch multiple &lt;code&gt;setState()&lt;/code&gt; calls into a single update for performance.</source>
          <target state="translated">React는 성능을 위해 여러 &lt;code&gt;setState()&lt;/code&gt; 호출을 단일 업데이트로 일괄 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7723873e421d86b75d6e18af64ca7963f769b3b" translate="yes" xml:space="preserve">
          <source>React normalizes events so that they have consistent properties across different browsers.</source>
          <target state="translated">React는 다른 브라우저에서 일관된 속성을 갖도록 이벤트를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="2d906a56aa31f7c4795766f5e6511a32ef9c51c2" translate="yes" xml:space="preserve">
          <source>React offers a new built-in &lt;code&gt;useTransition()&lt;/code&gt; Hook to help with this.</source>
          <target state="translated">React는이를 위해 새로운 내장 &lt;code&gt;useTransition()&lt;/code&gt; 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8a6c999a7613998525cad958f1f5a4415aeb6c88" translate="yes" xml:space="preserve">
          <source>React passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; function inside &lt;code&gt;forwardRef&lt;/code&gt; as a second argument.</source>
          <target state="translated">React는 &lt;code&gt;ref&lt;/code&gt; 를 &lt;code&gt;forwardRef&lt;/code&gt; 안의 &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; 함수 에 두 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6b8a0c49fcebb56ee095e5a48d9f54395dede3d8" translate="yes" xml:space="preserve">
          <source>React previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the &lt;a href=&quot;legacy-context&quot;&gt;legacy context docs here&lt;/a&gt;.</source>
          <target state="translated">이전에 실험용 컨텍스트 API와 함께 제공된 반응. 이전 API는 모든 16.x 릴리스에서 지원되지만 API를 사용하는 응용 프로그램은 새 버전으로 마이그레이션해야합니다. 레거시 API는 향후 주요 React 버전에서 제거 될 예정입니다. &lt;a href=&quot;legacy-context&quot;&gt;레거시 컨텍스트 문서를 여기에서&lt;/a&gt; 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="2765ccc9886a57c1e31be3cce27fa7d9e6c6390f" translate="yes" xml:space="preserve">
          <source>React provides a declarative API so that you don&amp;rsquo;t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React&amp;rsquo;s &amp;ldquo;diffing&amp;rdquo; algorithm so that component updates are predictable while being fast enough for high-performance apps.</source>
          <target state="translated">React는 선언적 API를 제공하므로 모든 업데이트에서 정확히 무엇이 변경 될지 걱정할 필요가 없습니다. 이로 인해 애플리케이션 작성이 훨씬 쉬워 지지만 이것이 React 내에서 어떻게 구현되는지는 분명하지 않을 수 있습니다. 이 기사에서는 React의&amp;ldquo;diffing&amp;rdquo;알고리즘에서 선택한 사항에 대해 설명하여 고성능 앱에 충분히 빠른 속도로 구성 요소 업데이트를 예측할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6cb4b93a472ab33ec73a24af7d41c47515e59e1" translate="yes" xml:space="preserve">
          <source>React provides a few built-in Hooks like &lt;code&gt;useState&lt;/code&gt;. You can also create your own Hooks to reuse stateful behavior between different components. We&amp;rsquo;ll look at the built-in Hooks first.</source>
          <target state="translated">React는 &lt;code&gt;useState&lt;/code&gt; 와 같은 몇 가지 내장 후크를 제공합니다 . 다른 구성 요소 간의 상태 저장 동작을 재사용하기 위해 자체 후크를 만들 수도 있습니다. 내장 후크를 먼저 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="01011cf1aceb6ea9b5b96f5c62df1bcc3dd1a485" translate="yes" xml:space="preserve">
          <source>React relies on a thriving open source community to file bug reports, open pull requests, and &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;submit RFCs&lt;/a&gt;. To encourage feedback we sometimes share special builds of React that include unreleased features.</source>
          <target state="translated">React는 번창하는 오픈 소스 커뮤니티에 의존하여 버그 보고서를 &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;제출&lt;/a&gt; 하고 풀 풀 요청을 제출하며 RFC를 제출 합니다. 피드백을 장려하기 위해 릴리스되지 않은 기능이 포함 된 특별한 React 빌드를 공유하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40d6ae813b74cf5f01219aa31530ea03f76cff9" translate="yes" xml:space="preserve">
          <source>React supports a special attribute that you can attach to any component. The &lt;code&gt;ref&lt;/code&gt; attribute can be an object created by &lt;a href=&quot;react-api#reactcreateref&quot;&gt;&lt;code&gt;React.createRef()&lt;/code&gt; function&lt;/a&gt; or a callback function, or a string (in legacy API). When the &lt;code&gt;ref&lt;/code&gt; attribute is a callback function, the function receives the underlying DOM element or class instance (depending on the type of element) as its argument. This allows you to have direct access to the DOM element or component instance.</source>
          <target state="translated">React는 모든 컴포넌트에 첨부 할 수있는 특수 속성을 지원합니다. &lt;code&gt;ref&lt;/code&gt; 특성에 의해 생성 된 객체가 될 수 &lt;a href=&quot;react-api#reactcreateref&quot;&gt; &lt;code&gt;React.createRef()&lt;/code&gt; 기능&lt;/a&gt; 이나 콜백 기능, (기존의 API) 캐릭터. 때는 &lt;code&gt;ref&lt;/code&gt; 속성이 콜백 함수는, 함수의 인수로서 DOM 요소 또는 클래스 인스턴스 (요소의 종류)에 따라 하부를 수신한다. 이를 통해 DOM 요소 또는 구성 요소 인스턴스에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="238af60aedac40fa19ce64bb9c937963b487a350" translate="yes" xml:space="preserve">
          <source>React supports all popular browsers, including Internet Explorer 9 and above, although &lt;a href=&quot;javascript-environment-requirements&quot;&gt;some polyfills are required&lt;/a&gt; for older browsers such as IE 9 and IE 10.</source>
          <target state="translated">React는 Internet Explorer 9 이상을 포함하여 널리 사용되는 모든 브라우저를 지원하지만 &lt;a href=&quot;javascript-environment-requirements&quot;&gt;일부 폴리 필은&lt;/a&gt; IE 9 및 IE 10과 같은 이전 브라우저에 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="f1108fbc718d743d28b30340d206d3e26c0f8796" translate="yes" xml:space="preserve">
          <source>React then calls the &lt;code&gt;Clock&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s render output.</source>
          <target state="translated">그런 다음 React는 &lt;code&gt;Clock&lt;/code&gt; 구성 요소의 &lt;code&gt;render()&lt;/code&gt; 메서드 를 호출합니다 . 이것이 React가 화면에 표시되어야 할 내용을 배우는 방법입니다. 그런 다음 React는 &lt;code&gt;Clock&lt;/code&gt; 의 렌더링 출력 과 일치하도록 DOM을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="8ec1afc5c4c338193066f6b054d7fabc1ccd93cf" translate="yes" xml:space="preserve">
          <source>React treats components starting with lowercase letters as DOM tags. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; represents an HTML div tag, but &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; represents a component and requires &lt;code&gt;Welcome&lt;/code&gt; to be in scope.</source>
          <target state="translated">React는 소문자로 시작하는 컴포넌트를 DOM 태그로 취급합니다. 예를 들어 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 는 HTML div 태그를 나타내지 만 &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; 은 구성 요소를 나타내며 시작 범위 내에 있어야 &lt;code&gt;Welcome&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960c9be08d5e97c9a662b93134873e0dbeec6765" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.user.read()&lt;/code&gt;. None of the data is fetched yet, so this component &amp;ldquo;suspends&amp;rdquo;. React skips over it, and tries rendering other components in the tree.</source>
          <target state="translated">React는 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 렌더링을 시도합니다 . &lt;code&gt;resource.user.read()&lt;/code&gt; 호출 합니다 . 데이터를 아직 가져 오지 않았으므로이 구성 요소는 &quot;일시 중단&quot;됩니다. React는 그것을 건너 뛰고 트리에서 다른 구성 요소를 렌더링하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="058b3578eec02c6fb7e50af3a2a4e4de20aaa646" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt;. It returns &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; as children.</source>
          <target state="translated">React는 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 렌더링을 시도합니다 . &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 을 자식으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e8754ec34540679dad16654502b2c038a71a9b14" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.posts.read()&lt;/code&gt;. Again, there&amp;rsquo;s no data yet, so this component also &amp;ldquo;suspends&amp;rdquo;. React skips over it too, and tries rendering other components in the tree.</source>
          <target state="translated">React는 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 렌더링을 시도합니다 . &lt;code&gt;resource.posts.read()&lt;/code&gt; 호출 합니다 . 다시 말하지만, 아직 데이터가 없으므로이 구성 요소도 &quot;일시 중단&quot;됩니다. React도 건너 뛰고 트리에서 다른 구성 요소를 렌더링하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2bdef9269be61bc9f880c393261771ba76dbc66f" translate="yes" xml:space="preserve">
          <source>React used to support &lt;code&gt;findDOMNode&lt;/code&gt; to search the tree for a DOM node given a class instance. Normally you don&amp;rsquo;t need this because you can &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;attach a ref directly to a DOM node&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;findDOMNode&lt;/code&gt; 를 지원 하여 클래스 인스턴스가 제공된 DOM 노드를 트리에서 검색하는 데 사용되는 반응 . 일반적으로 &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;DOM 노드에 직접 참조를 첨부&lt;/a&gt; 할 수 있기 때문에 이것을 필요로하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c79ec4f41b9bc945a753ba6040b79d5949594109" translate="yes" xml:space="preserve">
          <source>React uses a heuristic to decide how &amp;ldquo;urgent&amp;rdquo; an update is, and lets you adjust it with a few lines of code so that you can achieve the desired user experience for every interaction.</source>
          <target state="translated">React는 휴리스틱을 사용하여 업데이트의 &quot;급한&quot;정도를 결정하고 몇 줄의 코드로 업데이트하여 모든 상호 작용에 대해 원하는 사용자 경험을 얻을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="22e5b4566adcb56a590eb14809c46d916e2a5e62" translate="yes" xml:space="preserve">
          <source>React will always try to use a shorter lag when network and device allows it.</source>
          <target state="translated">React는 네트워크와 장치가 허용 할 때 항상 더 짧은 지연을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8dd1f1c89423b4d41ec8e1d8fe3ab9451ec3bb8a" translate="yes" xml:space="preserve">
          <source>React will assign the &lt;code&gt;current&lt;/code&gt; property with the DOM element when the component mounts, and assign it back to &lt;code&gt;null&lt;/code&gt; when it unmounts. &lt;code&gt;ref&lt;/code&gt; updates happen before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; lifecycle methods.</source>
          <target state="translated">React는 컴포넌트가 마운트 될 때 DOM 요소로 &lt;code&gt;current&lt;/code&gt; 프로퍼티를 할당 하고 마운트가 해제되면 다시 &lt;code&gt;null&lt;/code&gt; 로 할당합니다 . &lt;code&gt;ref&lt;/code&gt; 업데이트는 &lt;code&gt;componentDidMount&lt;/code&gt; 또는 &lt;code&gt;componentDidUpdate&lt;/code&gt; 라이프 사이클 메소드 전에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1522b7fcb611ab5619ba5c29f57c6f91086ebb4a" translate="yes" xml:space="preserve">
          <source>React will automatically append a &amp;ldquo;px&amp;rdquo; suffix to certain numeric inline style properties. If you want to use units other than &amp;ldquo;px&amp;rdquo;, specify the value as a string with the desired unit. For example:</source>
          <target state="translated">React는 특정 숫자 인라인 스타일 속성에 자동으로 &quot;px&quot;접미사를 추가합니다. &quot;px&quot;이외의 단위를 사용하려면 원하는 단위를 사용하여 값을 문자열로 지정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e48c661adaa0691f91d81c42dd5ad79faa9d5b40" translate="yes" xml:space="preserve">
          <source>React will call the &lt;code&gt;ref&lt;/code&gt; callback with the DOM element when the component mounts, and call it with &lt;code&gt;null&lt;/code&gt; when it unmounts. Refs are guaranteed to be up-to-date before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; fires.</source>
          <target state="translated">React는 컴포넌트가 마운트 될 때 DOM 요소로 &lt;code&gt;ref&lt;/code&gt; 콜백을 호출 하고 마운트가 해제되면 &lt;code&gt;null&lt;/code&gt; 로 호출합니다 . &lt;code&gt;componentDidMount&lt;/code&gt; 또는 &lt;code&gt;componentDidUpdate&lt;/code&gt; 가 실행 되기 전에 참조가 최신 상태로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="bec961fa87460a8199bc91207f5602b57da775e4" translate="yes" xml:space="preserve">
          <source>React will match the two &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; trees, match the two &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; trees, and then insert the &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">React는 두 개의 &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; 트리와 일치하고 두 개의 &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; 두 번째 &amp;lt;/ li&amp;gt; 트리와 일치 한 다음 &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; 트리 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="84c8d3d2c6b4ee18e7f6c58c4d0878cfba840ef7" translate="yes" xml:space="preserve">
          <source>React will mutate every child instead of realizing it can keep the &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; subtrees intact. This inefficiency can be a problem.</source>
          <target state="translated">React는 &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; 하위 트리를 그대로 유지할 수 있다는 것을 인식하는 대신 모든 어린이를 변경합니다 . 이 비효율은 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="037827f04da7e99d82ca6ffa924d84f2be8f32ef" translate="yes" xml:space="preserve">
          <source>React will only call this function during the first render. See the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt; API reference&lt;/a&gt;.</source>
          <target state="translated">React는 첫 번째 렌더링 동안에 만이 함수를 호출합니다. 참고 항목 &lt;a href=&quot;hooks-reference#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; 의 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d35f599dec735a7f7b9332bdccd38457cff29aae" translate="yes" xml:space="preserve">
          <source>React wouldn&amp;rsquo;t know what to return for the second &lt;code&gt;useState&lt;/code&gt; Hook call. React expected that the second Hook call in this component corresponds to the &lt;code&gt;persistForm&lt;/code&gt; effect, just like during the previous render, but it doesn&amp;rsquo;t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.</source>
          <target state="translated">React는 두 번째 &lt;code&gt;useState&lt;/code&gt; Hook 호출에 대해 무엇을 반환할지 모릅니다 . React는이 컴포넌트의 두 번째 Hook 호출이 이전 렌더링과 마찬가지로 &lt;code&gt;persistForm&lt;/code&gt; 효과에 해당 하지만 더 이상 그렇지 않을 것으로 예상했습니다 . 그 시점부터 우리가 건너 뛴 후의 다음 후크 호출도 하나씩 바뀌어 버그가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42280d34287efbc44d3bf22242efdd37d8595402" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called &lt;a href=&quot;reconciliation&quot;&gt;Reconciliation&lt;/a&gt;) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="translated">React&amp;rsquo;s diffing algorithm (called &lt;a href=&quot;reconciliation&quot;&gt;Reconciliation&lt;/a&gt;) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical ( &lt;code&gt;===&lt;/code&gt; ) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</target>
        </trans-unit>
        <trans-unit id="c1eb9dd2c424ef3fafa626c2c77948281802077e" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="translated">React의 diffing 알고리즘 (조정)은 구성 요소 ID를 사용하여 기존 하위 트리를 업데이트해야하는지 아니면 버리고 새 서브 마운트를 마운트할지 결정합니다. &lt;code&gt;render&lt;/code&gt; 에서 반환 된 구성 요소가 이전 렌더링의 구성 요소와 동일 ( &lt;code&gt;===&lt;/code&gt; )하면 React는 하위 트리를 새 하위 트리와 비교하여 재귀 적으로 업데이트합니다. 동일하지 않으면 이전 하위 트리가 완전히 마운트 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4b48776bb22bae427abe8b46cd79f8f736c2050d" translate="yes" xml:space="preserve">
          <source>React.Children</source>
          <target state="translated">React.Children</target>
        </trans-unit>
        <trans-unit id="cc1be87ed14efcaf593075d9ede44a45138aadc0" translate="yes" xml:space="preserve">
          <source>React.Children.count</source>
          <target state="translated">React.Children.count</target>
        </trans-unit>
        <trans-unit id="5af3ed601dd15ebbdaac8d067d95b65af5198725" translate="yes" xml:space="preserve">
          <source>React.Children.forEach</source>
          <target state="translated">React.Children.forEach</target>
        </trans-unit>
        <trans-unit id="b0b9f26dfc87ce7a1fabe603e845da6e1df1ce2e" translate="yes" xml:space="preserve">
          <source>React.Children.map</source>
          <target state="translated">React.Children.map</target>
        </trans-unit>
        <trans-unit id="4a803a2f5a435fe023facedc929712933c00bafa" translate="yes" xml:space="preserve">
          <source>React.Children.only</source>
          <target state="translated">React.Children.only</target>
        </trans-unit>
        <trans-unit id="b1c41bf42fafc87b8d58972c97a42005a457379c" translate="yes" xml:space="preserve">
          <source>React.Children.toArray</source>
          <target state="translated">React.Children.toArray</target>
        </trans-unit>
        <trans-unit id="5cfad44c38cc0f45d4217d64395ad2d18bc09eac" translate="yes" xml:space="preserve">
          <source>React.Component</source>
          <target state="translated">React.Component</target>
        </trans-unit>
        <trans-unit id="8767054cca9f51c04adc1d990df49bae21bd19e8" translate="yes" xml:space="preserve">
          <source>React.Fragment</source>
          <target state="translated">React.Fragment</target>
        </trans-unit>
        <trans-unit id="ec2b194c043c081abd8e1fa7d7077fc02478f79a" translate="yes" xml:space="preserve">
          <source>React.PureComponent</source>
          <target state="translated">React.PureComponent</target>
        </trans-unit>
        <trans-unit id="6f447c27948b73409db445d85ed438ff52b2fed4" translate="yes" xml:space="preserve">
          <source>React.Suspense</source>
          <target state="translated">React.Suspense</target>
        </trans-unit>
        <trans-unit id="da177d61b90dfb2b87eaf6b6fa8fe737abb149c1" translate="yes" xml:space="preserve">
          <source>React.createContext</source>
          <target state="translated">React.createContext</target>
        </trans-unit>
        <trans-unit id="9a1b7db7ce8d37e9b8f0ff95428c282a544b51fe" translate="yes" xml:space="preserve">
          <source>React.createRef</source>
          <target state="translated">React.createRef</target>
        </trans-unit>
        <trans-unit id="470198c910691938bdf95d3f55a8eea2de68e228" translate="yes" xml:space="preserve">
          <source>React.forwardRef</source>
          <target state="translated">React.forwardRef</target>
        </trans-unit>
        <trans-unit id="4d68edc4675fcac6e43f56a62dd19ef2ec4f971c" translate="yes" xml:space="preserve">
          <source>React.lazy</source>
          <target state="translated">React.lazy</target>
        </trans-unit>
        <trans-unit id="b168874df4ce448e7d39cbd474dab62d2a63a48c" translate="yes" xml:space="preserve">
          <source>React.memo</source>
          <target state="translated">React.memo</target>
        </trans-unit>
        <trans-unit id="d1dd4b799fd5b42020755757fd1ad8e4de9166c0" translate="yes" xml:space="preserve">
          <source>ReactDOM</source>
          <target state="translated">ReactDOM</target>
        </trans-unit>
        <trans-unit id="575e6ab87dc7232bd5aee91c11fb19e0ec0429d1" translate="yes" xml:space="preserve">
          <source>ReactDOMServer</source>
          <target state="translated">ReactDOMServer</target>
        </trans-unit>
        <trans-unit id="1c6e2478a4ec4479a4090a890821692248b05319" translate="yes" xml:space="preserve">
          <source>ReactJS: Props vs. State</source>
          <target state="translated">ReactJS : 소품 대 상태</target>
        </trans-unit>
        <trans-unit id="6bba779745f1dc5e89a8dc6f34f971f62a0cbbcf" translate="yes" xml:space="preserve">
          <source>Read more about the use of these elements to enhance accessibility here:</source>
          <target state="translated">접근성을 향상시키기 위해 이러한 요소의 사용에 대한 자세한 내용은 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="074b86f971ede72779f80c5984d463c0b08f7ddd" translate="yes" xml:space="preserve">
          <source>Read our &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;blog post on avoiding derived state&lt;/a&gt; to learn about what to do if you think you need some state to depend on the props.</source>
          <target state="translated">소품에 의존하기 위해 어떤 상태가 필요하다고 생각되면 어떻게해야하는지에 대해 알아 보려면 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;파생 된 상태&lt;/a&gt; 를 피하는 것에 대한 블로그 게시물을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="81948a47f0cece8eebf3d00111f8c4906a80131d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;context&quot;&gt;new context API documentation&lt;/a&gt; to help migrate to the new version.</source>
          <target state="translated">&lt;a href=&quot;context&quot;&gt;새 컨텍스트 API 설명서&lt;/a&gt; 를 읽고 새 버전으로 마이그레이션하십시오.</target>
        </trans-unit>
        <trans-unit id="9d13f2fc7ceb07a1e30213b5dad32a3a5179b292" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt; to learn why we&amp;rsquo;re introducing Hooks to React.</source>
          <target state="translated">우리가 왜 후크를 반응시키는 지 소개 하는 &lt;a href=&quot;hooks-intro#motivation&quot;&gt;동기&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3bbadf53c7263d165aad6e988afe2df6a73f4a1f" translate="yes" xml:space="preserve">
          <source>Reading State</source>
          <target state="translated">읽기 상태</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="bbff96495da2dd73f63babc3c8bf1ad05fa7f5d9" translate="yes" xml:space="preserve">
          <source>Reason is developed at Facebook, and is used in some of its products like Messenger. It is still somewhat experimental but it has &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;dedicated React bindings&lt;/a&gt; maintained by Facebook and a &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;vibrant community&lt;/a&gt;.</source>
          <target state="translated">Reason은 Facebook에서 개발되었으며 Messenger와 같은 일부 제품에서 사용됩니다. 그것은 여전히 ​​다소 실험적이지만 Facebook과 &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;활발한 커뮤니티가&lt;/a&gt; 유지하는 &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;전용 React 바인딩을&lt;/a&gt; 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="3a2b9fcfa6cb6b47fdf570bba482c7f6bd5778c1" translate="yes" xml:space="preserve">
          <source>Recommended Courses</source>
          <target state="translated">추천 코스</target>
        </trans-unit>
        <trans-unit id="10837ad0c0a51856150f656df265fcd25ac01ed3" translate="yes" xml:space="preserve">
          <source>Recommended Toolchains</source>
          <target state="translated">추천 툴체인</target>
        </trans-unit>
        <trans-unit id="244546a122b5c31cc9d410496feb2d652e2bbdc1" translate="yes" xml:space="preserve">
          <source>Recommended Tools</source>
          <target state="translated">추천 도구</target>
        </trans-unit>
        <trans-unit id="b29da9dd20f256ca2ca1f8f9694721825196ea4d" translate="yes" xml:space="preserve">
          <source>Reconciliation</source>
          <target state="translated">Reconciliation</target>
        </trans-unit>
        <trans-unit id="332ed81ec8ca439bef285d75f52c06cbc08b32a4" translate="yes" xml:space="preserve">
          <source>Recursing On Children</source>
          <target state="translated">아이들에게 되풀이</target>
        </trans-unit>
        <trans-unit id="ccfd566b538210ffef62a3cbbf17af444ab5c269" translate="yes" xml:space="preserve">
          <source>Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.</source>
          <target state="translated">감속기는 격리 된 상태에서 테스트하고 복잡한 업데이트 논리를 표현하도록 확장하는 데 매우 편리합니다. 필요한 경우 더 작은 감속기로 분리 할 수 ​​있습니다. 그러나 React local state 사용의 이점을 누리거나 다른 라이브러리를 설치하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0997f5332014e1341252581fa75655f6f29042ff" translate="yes" xml:space="preserve">
          <source>Ref forwarding is a technique for automatically passing a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; through a component to one of its children. This is typically not necessary for most components in the application. However, it can be useful for some kinds of components, especially in reusable component libraries. The most common scenarios are described below.</source>
          <target state="translated">참조 전달은 구성 요소를 통해 &lt;a href=&quot;refs-and-the-dom&quot;&gt;참조&lt;/a&gt; 를 자동으로 하위 요소 중 하나에 전달하는 기술입니다 . 일반적으로 응용 프로그램의 대부분의 구성 요소에는 필요하지 않습니다. 그러나 일부 유형의 구성 요소, 특히 재사용 가능한 구성 요소 라이브러리에서 유용 할 수 있습니다. 가장 일반적인 시나리오는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88e9c6ab30810deb881b406399ad25815aa00430" translate="yes" xml:space="preserve">
          <source>Ref forwarding is not limited to DOM components. You can forward refs to class component instances, too.</source>
          <target state="translated">참조 전달은 DOM 구성 요소로 제한되지 않습니다. 클래스 구성 요소 인스턴스에 참조를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f94f7a816faa7ffd5cf23158233fea5b06cec8af" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;React docs&lt;/a&gt; if you need help executing this step.</source>
          <target state="translated">이 단계를 실행하는 데 도움이 필요 하면 &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;React 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c29e646865b903a7f9176acc308f47b762dfedc4" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how best to use ChromeVox:</source>
          <target state="translated">ChromeVox를 가장 잘 사용하는 방법에 대해서는 다음 가이드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d97130a2c24d6da30b1f2bcc6a91ee349588c307" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to activate and use VoiceOver:</source>
          <target state="translated">VoiceOver 활성화 및 사용 방법에 대해서는 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="387cf309f2faa4474cac2537147bc4a9fb447c54" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use JAWS:</source>
          <target state="translated">JAWS를 가장 잘 사용하는 방법에 대해서는 다음 안내서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1af4dc4226ba5d7f48cd9164c32b42e6e3bf5ff" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use NVDA:</source>
          <target state="translated">NVDA를 가장 잘 사용하는 방법에 대해서는 다음 안내서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="e01e6c1194053e77088bcfb2d27b92af6a763645" translate="yes" xml:space="preserve">
          <source>Reference: Component</source>
          <target state="translated">참조 : 컴포넌트</target>
        </trans-unit>
        <trans-unit id="07e5e98584609eccb9f77b23943878ea7e66663b" translate="yes" xml:space="preserve">
          <source>Reference: React</source>
          <target state="translated">참조 : 반응</target>
        </trans-unit>
        <trans-unit id="6c5d1b546101e34b2fef5dfa40c4a0c35d04ef65" translate="yes" xml:space="preserve">
          <source>Reference: Test Utilities</source>
          <target state="translated">참조 : 테스트 유틸리티</target>
        </trans-unit>
        <trans-unit id="9b4ff94e05defc26bbc7cd77d4ca3c6ebd0b6024" translate="yes" xml:space="preserve">
          <source>Referencing Context in Function Components</source>
          <target state="translated">함수 구성 요소의 컨텍스트 참조</target>
        </trans-unit>
        <trans-unit id="9b14990da33d9df39d9d550b2e7f8b6fcd2b42ba" translate="yes" xml:space="preserve">
          <source>Referencing Context in Lifecycle Methods</source>
          <target state="translated">라이프 사이클 메소드에서 컨텍스트 참조</target>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="a3d901aa78a934ff41addcb0fd717d3f919ed007" translate="yes" xml:space="preserve">
          <source>Refs Aren&amp;rsquo;t Passed Through</source>
          <target state="translated">참조가 통과되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="f52edcfa76c4c361d68ab116986e39ab247fed52" translate="yes" xml:space="preserve">
          <source>Refs and Function Components</source>
          <target state="translated">참조 및 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="fb466d16b8687b6a8370254e6e32e29e3d0859c3" translate="yes" xml:space="preserve">
          <source>Refs and the DOM</source>
          <target state="translated">심판과 DOM</target>
        </trans-unit>
        <trans-unit id="d02e5e18486fdb7d98bc4b06d983eb76fb1c3d9f" translate="yes" xml:space="preserve">
          <source>Refs are created using &lt;code&gt;React.createRef()&lt;/code&gt; and attached to React elements via the &lt;code&gt;ref&lt;/code&gt; attribute. Refs are commonly assigned to an instance property when a component is constructed so they can be referenced throughout the component.</source>
          <target state="translated">참조는 &lt;code&gt;React.createRef()&lt;/code&gt; 사용하여 작성 되며 &lt;code&gt;ref&lt;/code&gt; 속성을 통해 React 요소에 첨부됩니다 . 참조는 일반적으로 구성 요소가 구성 될 때 인스턴스 특성에 지정되므로 구성 요소 전체에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d161866c6b9501cf0d2efb1f50f2016be3d6821" translate="yes" xml:space="preserve">
          <source>Refs provide a way to access DOM nodes or React elements created in the render method.</source>
          <target state="translated">참조는 render 메소드에서 작성된 DOM 노드 또는 React 요소에 액세스하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="899dfdc1d167e0237757bc336e63500e23158098" translate="yes" xml:space="preserve">
          <source>Relay has its own answers to some of these questions. There is certainly more than a single way to do it, and we&amp;rsquo;re excited to see what new ideas the React community comes up with.</source>
          <target state="translated">릴레이에는 이러한 질문 중 일부에 대한 답변이 있습니다. 이를위한 유일한 방법은 여러 가지가 있으며, React 커뮤니티가 어떤 새로운 아이디어를 내놓을 지 기대됩니다.</target>
        </trans-unit>
        <trans-unit id="f9896fabfbfb541e50cf8fbc89e1dedd902b28da" translate="yes" xml:space="preserve">
          <source>Release Channels</source>
          <target state="translated">출시 채널</target>
        </trans-unit>
        <trans-unit id="37042d2abc9098ffc1431b21485e7d0a1a7e4bba" translate="yes" xml:space="preserve">
          <source>Releases in Experimental are published with the &lt;code&gt;experimental&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">Experimental의 릴리스는 npm에 &lt;code&gt;experimental&lt;/code&gt; 태그 와 함께 게시됩니다 . 버전은 빌드 컨텐츠의 해시 (예 : &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt; )에서 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="1437218113e95e798836c2813420f7b58e53793d" translate="yes" xml:space="preserve">
          <source>Releases in Next are published with the &lt;code&gt;next&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt;.</source>
          <target state="translated">다음 릴리스는 npm에 &lt;code&gt;next&lt;/code&gt; 태그 와 함께 게시됩니다 . 버전은 빌드 컨텐츠의 해시 (예 : &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt; ) 에서 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="506ceb7ad9bf42c314daf190028b0b49649a9a76" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;props&lt;/code&gt; are readonly. They should not be modified in any way:</source>
          <target state="translated">기억 &lt;code&gt;props&lt;/code&gt; 읽기 전용입니다. 어떤 식 으로든 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="00ec254bb146176823654d1ba7e18ca2d439ac55" translate="yes" xml:space="preserve">
          <source>Remember that only React files ending with &lt;code&gt;.production.min.js&lt;/code&gt; are suitable for production.</source>
          <target state="translated">&lt;code&gt;.production.min.js&lt;/code&gt; 로 끝나는 React 파일 만 프로덕션에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="55c0498b17e0f7958c5f1cfe9a4af9cc2fac5b70" translate="yes" xml:space="preserve">
          <source>Remember that the function passed to &lt;code&gt;useMemo&lt;/code&gt; runs during rendering. Don&amp;rsquo;t do anything there that you wouldn&amp;rsquo;t normally do while rendering. For example, side effects belong in &lt;code&gt;useEffect&lt;/code&gt;, not &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useMemo&lt;/code&gt; 에 전달 된 함수는 렌더링 중에 실행됩니다. 렌더링하는 동안 일반적으로하지 않는 작업은 수행하지 마십시오. 예를 들어 부작용은 &lt;code&gt;useEffect&lt;/code&gt; 가 아닌 &lt;code&gt;useMemo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6275d186fd90e50c31acd8ea5dda666aacddf8" translate="yes" xml:space="preserve">
          <source>Remember that this is only necessary before deploying to production. For normal development, use &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="translated">이것은 프로덕션에 배포하기 전에 만 필요하다는 것을 기억하십시오. 정상적인 개발을 위해서는 &lt;code&gt;npm start&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a9b6c75a01a157a01b48b838460f641ef9518a1" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply &lt;code&gt;TerserPlugin&lt;/code&gt; in development because it will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">프로덕션 빌드에만이 작업을 수행하면됩니다. 유용한 React 경고를 숨기고 빌드를 훨씬 느리게 만들므로 &lt;code&gt;TerserPlugin&lt;/code&gt; 을 개발에 적용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="1aa3b578bcc142e681e33d9082e9b12920727051" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply the &lt;code&gt;terser&lt;/code&gt; plugin or the &lt;code&gt;replace&lt;/code&gt; plugin with &lt;code&gt;'production'&lt;/code&gt; value in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">프로덕션 빌드에만이 작업을 수행하면됩니다. 유용한 React 경고를 숨기고 빌드를 훨씬 느리게 만들기 때문에 개발 중에 &lt;code&gt;terser&lt;/code&gt; 플러그인 또는 &lt;code&gt;replace&lt;/code&gt; 플러그인을 &lt;code&gt;'production'&lt;/code&gt; 값으로 적용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="0564aab96aa66b680690a02b7eaf83e614ce4779" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply these plugins in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="translated">프로덕션 빌드에만이 작업을 수행하면됩니다. 유용한 React 경고를 숨기고 빌드를 훨씬 느리게 만들기 때문에 개발시 이러한 플러그인을 적용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cee5bbc977133f79e172d6c135cbc3a08da22a4c" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t pass the &lt;code&gt;-p&lt;/code&gt; flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.</source>
          <target state="translated">프로덕션 빌드에만이 작업을 수행하면됩니다. 유용한 React 경고를 숨기고 빌드 속도를 훨씬 느리게 만들기 때문에 &lt;code&gt;-p&lt;/code&gt; 플래그를 전달하거나 개발시이 플러그인을 적용 해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="02638cc549bbccd3a59e4d9f2b3447b3799a9799" translate="yes" xml:space="preserve">
          <source>Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a &amp;ldquo;shell&amp;rdquo; of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph.</source>
          <target state="translated">연결 속도가 느린 사용자 경험을 염두에 두십시오. JavaScript 코드는 초기 HTML 렌더링보다 훨씬 늦게로드 될 수 있으므로 클라이언트 전용 패스에서 다른 것을 렌더링하면 전환이 잘못 될 수 있습니다. 그러나 제대로 실행되면 서버에 응용 프로그램의 &quot;쉘&quot;을 렌더링하고 클라이언트에 추가 위젯 중 일부만 표시하는 것이 좋습니다. 마크 업 불일치 문제없이이 작업을 수행하는 방법을 알아 보려면 이전 단락의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0cf6b3967ff86476349c6cba924e1f4df9063ba0" translate="yes" xml:space="preserve">
          <source>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. &lt;strong&gt;This is often the most challenging part for newcomers to understand,&lt;/strong&gt; so follow these steps to figure it out:</source>
          <target state="translated">기억하십시오 : React는 컴포넌트 계층 구조로의 단방향 데이터 흐름에 관한 것입니다. 어떤 구성 요소가 어떤 상태를 소유해야하는지 명확하지 않을 수 있습니다. &lt;strong&gt;이는 초보자가 이해하기 가장 어려운 부분&lt;/strong&gt; 이므로 다음 단계에 따라 파악하십시오.</target>
        </trans-unit>
        <trans-unit id="4bddbe70e7cebef78898e35292cc2468b12a94b5" translate="yes" xml:space="preserve">
          <source>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns &lt;code&gt;true&lt;/code&gt; if a component was unmounted and &lt;code&gt;false&lt;/code&gt; if there was no component to unmount.</source>
          <target state="translated">DOM에서 마운트 된 React 컴포넌트를 제거하고 이벤트 핸들러 및 상태를 정리하십시오. 컨테이너에 컴포넌트가 마운트되지 않은 경우이 함수를 호출하면 아무 작업도 수행되지 않습니다. 구성 요소가 마운트 해제 된 경우 &lt;code&gt;true&lt;/code&gt; 를, 마운트 해제 할 구성 요소가없는 경우 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="86694784f4769bf45b391e840ebd17a5027533ee" translate="yes" xml:space="preserve">
          <source>Remove the &lt;code&gt;date&lt;/code&gt; prop from the &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;date&lt;/code&gt; 소품을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f97a2511af3b23436102ab6d44ee45e78c76ee6" translate="yes" xml:space="preserve">
          <source>Render Props</source>
          <target state="translated">렌더 소품</target>
        </trans-unit>
        <trans-unit id="e1ac8a2e8fd4c4d9b2e888fc8ab5aa1c5641c010" translate="yes" xml:space="preserve">
          <source>Render a React element into a detached DOM node in the document. &lt;strong&gt;This function requires a DOM.&lt;/strong&gt; It is effectively equivalent to:</source>
          <target state="translated">문서에서 분리 된 DOM 노드로 React 요소를 렌더링하십시오. &lt;strong&gt;이 기능에는 DOM이 필요합니다. &lt;/strong&gt;효과적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f4c267baa0ea37da44d3295841c41f7517ef016" translate="yes" xml:space="preserve">
          <source>Render a React element into the DOM in the supplied &lt;code&gt;container&lt;/code&gt; and return a &lt;a href=&quot;refs-and-the-dom&quot;&gt;reference&lt;/a&gt; to the component (or returns &lt;code&gt;null&lt;/code&gt; for &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;stateless components&lt;/a&gt;).</source>
          <target state="translated">제공된 &lt;code&gt;container&lt;/code&gt; 의 DOM에 React 요소를 렌더링 하고 컴포넌트에 대한 &lt;a href=&quot;refs-and-the-dom&quot;&gt;참조&lt;/a&gt; 를 리턴하거나 &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;상태 비 저장 컴포넌트에&lt;/a&gt; 대해서는 &lt;code&gt;null&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="dc5294dc207a073f91e4e23440d40dc7c1fe8ec8" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">React 요소를 초기 HTML로 렌더링합니다. React는 HTML 문자열을 반환합니다. 이 방법을 사용하면 서버에서 HTML을 생성하고 더 빠른 페이지로드를위한 초기 요청에서 마크 업을 보내어 검색 엔진이 SEO 목적으로 페이지를 크롤링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0113dc822fbf0c0333e792a37212eab08364f58" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. Returns a &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;Readable stream&lt;/a&gt; that outputs an HTML string. The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; would return. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="translated">React 요소를 초기 HTML로 렌더링합니다. HTML 문자열을 출력하는 &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;읽기 가능한 스트림&lt;/a&gt; 을 반환 합니다. 이 스트림의 HTML 출력은 &lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt; &lt;/a&gt; 이 반환 하는 것과 정확히 동일합니다 . 이 방법을 사용하면 서버에서 HTML을 생성하고 더 빠른 페이지로드를 위해 초기 요청에서 마크 업을 보내어 검색 엔진이 SEO 목적으로 페이지를 크롤링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd90297d318440c1f2f1e20386ac52433816dbc" translate="yes" xml:space="preserve">
          <source>Render phase lifecycles include the following class component methods:</source>
          <target state="translated">렌더 단계 수명주기에는 다음과 같은 클래스 구성 요소 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="1c25bcd6bd276eac5fcaea0f95ff3ce958900765" translate="yes" xml:space="preserve">
          <source>Rendering Elements</source>
          <target state="translated">렌더링 요소</target>
        </trans-unit>
        <trans-unit id="6e673765026d08ba19736d6743a5af8bbfbf2280" translate="yes" xml:space="preserve">
          <source>Rendering Multiple Components</source>
          <target state="translated">여러 구성 요소 렌더링</target>
        </trans-unit>
        <trans-unit id="5de451ee11969db712ecfa41261cd69923ac3c5e" translate="yes" xml:space="preserve">
          <source>Rendering a Component</source>
          <target state="translated">컴포넌트 렌더링</target>
        </trans-unit>
        <trans-unit id="5a1b1f26449aa10c5465e1866d5b17350d60dba1" translate="yes" xml:space="preserve">
          <source>Rendering an Element into the DOM</source>
          <target state="translated">요소를 DOM으로 렌더링</target>
        </trans-unit>
        <trans-unit id="2deeb1304f9fe594167184d5df3f289bd150a128" translate="yes" xml:space="preserve">
          <source>Reorders can also cause issues with component state when indexes are used as keys. Component instances are updated and reused based on their key. If the key is an index, moving an item changes it. As a result, component state for things like uncontrolled inputs can get mixed up and updated in unexpected ways.</source>
          <target state="translated">색인을 키로 사용하면 재정렬로 인해 구성 요소 상태에 문제가 발생할 수도 있습니다. 구성 요소 인스턴스는 해당 키를 기반으로 업데이트 및 재사용됩니다. 키가 색인 인 경우 항목을 이동하면 변경됩니다. 결과적으로 제어되지 않은 입력과 같은 구성 요소 상태가 예기치 않게 혼합되고 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbe7d9e0840a5d5cc2233edcc4df112b60c50775" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;props&lt;/code&gt; with &lt;code&gt;this.props&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; body.</source>
          <target state="translated">교체 &lt;code&gt;props&lt;/code&gt; 으로 &lt;code&gt;this.props&lt;/code&gt; 의 &lt;code&gt;render()&lt;/code&gt; 몸.</target>
        </trans-unit>
        <trans-unit id="cb57ef5effd1f60e8626d7c988da95a24b5ec275" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;this.props.date&lt;/code&gt; with &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">교체 &lt;code&gt;this.props.date&lt;/code&gt; 을 함께 &lt;code&gt;this.state.date&lt;/code&gt; 의 &lt;code&gt;render()&lt;/code&gt; 방법 :</target>
        </trans-unit>
        <trans-unit id="f9ea2adea65e9fb0a33960f20df2ec187396b408" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;Blocking Mode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; 대체 하고 &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;차단 모드를&lt;/a&gt; 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="317adb3c3ea2c25ffb027f680071c7621ebb38a5" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables Concurrent Mode.</source>
          <target state="translated">&lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; 대체 하고 동시 모드를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="28a19901d94163b49c0b9a0ab562c759e0d3c83b" translate="yes" xml:space="preserve">
          <source>Replacing String-Based Rendering with React</source>
          <target state="translated">문자열 기반 렌더링을 반응으로 대체</target>
        </trans-unit>
        <trans-unit id="326977983d9f5ffff2fba0920254350c35e6b262" translate="yes" xml:space="preserve">
          <source>Requires a &lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;function as a child&lt;/a&gt;. The function receives the current context value and returns a React node. The &lt;code&gt;value&lt;/code&gt; argument passed to the function will be equal to the &lt;code&gt;value&lt;/code&gt; prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the &lt;code&gt;value&lt;/code&gt; argument will be equal to the &lt;code&gt;defaultValue&lt;/code&gt; that was passed to &lt;code&gt;createContext()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;자녀로서의 기능이&lt;/a&gt; 필요합니다 . 이 함수는 현재 컨텍스트 값을 받고 React 노드를 반환합니다. 함수에 전달 된 &lt;code&gt;value&lt;/code&gt; 인수 는 트리에서이 컨텍스트에 대해 가장 가까운 제공자의 prop &lt;code&gt;value&lt;/code&gt; 과 같습니다 . 위에이 컨텍스트에 대한 제공자가없는 경우 &lt;code&gt;value&lt;/code&gt; 인수는 &lt;code&gt;createContext()&lt;/code&gt; 로 전달 된 &lt;code&gt;defaultValue&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e8319d57e9244f07c04fc5e8602151a6c0fa2d6f" translate="yes" xml:space="preserve">
          <source>Requiring Single Child</source>
          <target state="translated">미혼 자녀 필요</target>
        </trans-unit>
        <trans-unit id="7111cdd0dc257beff8eea7a806b1ab1fd962ca5c" translate="yes" xml:space="preserve">
          <source>Resist the temptation to modify a component&amp;rsquo;s prototype (or otherwise mutate it) inside a HOC.</source>
          <target state="translated">HOC 내부에서 구성 요소의 프로토 타입을 수정하거나 다른 방식으로 변경하려는 유혹에 저항하십시오.</target>
        </trans-unit>
        <trans-unit id="d9204284eada33e6b4a89c93c4c4d56bd1b58bad" translate="yes" xml:space="preserve">
          <source>Return a function that produces React elements of a given type. Like &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;, the type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="translated">주어진 유형의 React 요소를 생성하는 함수를 반환합니다. &lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 type 인수는 태그 이름 문자열 (예 : &lt;code&gt;'div'&lt;/code&gt; 또는 &lt;code&gt;'span'&lt;/code&gt; ), &lt;a href=&quot;components-and-props&quot;&gt;React 구성 요소&lt;/a&gt; 유형 (클래스 또는 함수) 또는 &lt;a href=&quot;#reactfragment&quot;&gt;React 단편&lt;/a&gt; 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9490a5975f4c1aeeb1fba945378a6267587086" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. The representation is more detailed than the one provided by &lt;code&gt;toJSON()&lt;/code&gt;, and includes the user-written components. You probably don&amp;rsquo;t need this method unless you&amp;rsquo;re writing your own assertion library on top of the test renderer.</source>
          <target state="translated">렌더링 된 트리를 나타내는 객체를 반환합니다. 표현은 &lt;code&gt;toJSON()&lt;/code&gt; 제공하는 것보다 더 자세 하며 사용자 작성 구성 요소를 포함합니다. 테스트 렌더러 위에 자체 어설 션 라이브러리를 작성하지 않는 한이 방법이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7c1bb71db1342d91c5ef36e51eb4eaefb116d31" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. This tree only contains the platform-specific nodes like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and their props, but doesn&amp;rsquo;t contain any user-written components. This is handy for &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;snapshot testing&lt;/a&gt;.</source>
          <target state="translated">렌더링 된 트리를 나타내는 객체를 반환합니다. 이 트리에는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; 와 같은 플랫폼 별 노드 와 해당 소품 만 포함되지만 사용자 작성 구성 요소는 포함되어 있지 않습니다. 이것은 &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;스냅 샷 테스트에&lt;/a&gt; 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="74fc039e9565bf16b53a3b89e5b81f2b44db53f3" translate="yes" xml:space="preserve">
          <source>Return the instance corresponding to the root element, if available. This will not work if the root element is a function component because they don&amp;rsquo;t have instances.</source>
          <target state="translated">가능한 경우 루트 요소에 해당하는 인스턴스를 반환하십시오. 루트 요소가 인스턴스가 없기 때문에 함수 구성 요소 인 경우에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bf63f8c82c0848fec82740dea18e1228a6949a1" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;null&lt;/code&gt; from a component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method does not affect the firing of the component&amp;rsquo;s lifecycle methods. For instance &lt;code&gt;componentDidUpdate&lt;/code&gt; will still be called.</source>
          <target state="translated">구성 요소의 &lt;code&gt;render&lt;/code&gt; 메서드 에서 &lt;code&gt;null&lt;/code&gt; 을 반환 해도 구성 요소의 수명주기 메서드 실행에는 영향을 미치지 않습니다. 예를 들어 &lt;code&gt;componentDidUpdate&lt;/code&gt; 가 계속 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7bc6aecb5d9aba689da1df93e2754ec3bbba006b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is a React element whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;element&lt;/code&gt; A는 누구을 입력이다 반작용 요소 반작용이다 &lt;code&gt;componentClass&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a190fbdb0884ae9441f701da292b119b62675501" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is any React element.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 가 React 요소 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="4c122a79f21fb165125e2d7f4bf95f4c5c45a74e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a DOM component (such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; 가 DOM 구성 요소 (예 : &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; ) 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="e33afd14605447b5271912282d921b04b0bd5370" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a component whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; 가 유형이 React &lt;code&gt;componentClass&lt;/code&gt; 인 컴포넌트 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="499d37d763d22c84b2d39e5c1954470c821ac070" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a user-defined component, such as a class or a function.</source>
          <target state="translated">&lt;code&gt;instance&lt;/code&gt; 가 클래스 또는 함수와 같은 사용자 정의 구성 요소 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ebac6d7da5644ee246df2cbcbead0e219e53e73f" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; callback.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;메모 된&lt;/a&gt; 콜백을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d3db2224691dc0b90f31765016663484bb5df51c" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; value.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;메모 된&lt;/a&gt; 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ebd4eccf8c2df94f154d585fd787ad0e2ae4f7f8" translate="yes" xml:space="preserve">
          <source>Returns a deferred version of the value that may &amp;ldquo;lag behind&amp;rdquo; it for at most &lt;code&gt;timeoutMs&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;code&gt;timeoutMs&lt;/code&gt; 동안 &quot;지연된&quot;값의 지연된 버전을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e3aaff9eb4ac50df91dd22852b4c13a60bac4270" translate="yes" xml:space="preserve">
          <source>Returns a stateful value, and a function to update it.</source>
          <target state="translated">상태 저장 값과 값을 업데이트하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62e25a4ff0b51f4bd36d6a71ad97da75dd2e0c57" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;children&lt;/code&gt; opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice &lt;code&gt;this.props.children&lt;/code&gt; before passing it down.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; 불투명 데이터 구조를 각 하위에 키가 할당 된 평면 배열로 반환합니다 . 렌더 메소드에서 하위 컬렉션을 조작하려는 경우, 특히 &lt;code&gt;this.props.children&lt;/code&gt; 을 전달하기 전에 순서를 변경하거나 슬라이스하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4fdadee436b13fdfda743f94c2cfe940b695fe60" translate="yes" xml:space="preserve">
          <source>Returns the root &amp;ldquo;test instance&amp;rdquo; object that is useful for making assertions about specific nodes in the tree. You can use it to find other &amp;ldquo;test instances&amp;rdquo; deeper below.</source>
          <target state="translated">트리의 특정 노드에 대한 어설 션을 만드는 데 유용한 루트 &quot;테스트 인스턴스&quot;개체를 반환합니다. 이를 사용하여 아래의 다른 &quot;테스트 인스턴스&quot;를 더 깊이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a38b55153cd2060423a41d78bde79f2b8e20191" translate="yes" xml:space="preserve">
          <source>Returns the total number of components in &lt;code&gt;children&lt;/code&gt;, equal to the number of times that a callback passed to &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; would be invoked.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; 의 전체 컴포넌트 수를 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;forEach&lt;/code&gt; 에 전달 된 콜백이 호출 된 횟수와 같은 수로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4aeaf8edb1adb3ef0d49248b4bb93fa627e27381" translate="yes" xml:space="preserve">
          <source>Reviewing the Changes</source>
          <target state="translated">변경 사항 검토</target>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="74d0a40665676a538ac8d7c46b8e150fe7235473" translate="yes" xml:space="preserve">
          <source>Route-based code splitting</source>
          <target state="translated">경로 기반 코드 분할</target>
        </trans-unit>
        <trans-unit id="60d643b40f21ca2b9a8a2512b3ba9f597aab6291" translate="yes" xml:space="preserve">
          <source>Rules of Hooks</source>
          <target state="translated">후크 규칙</target>
        </trans-unit>
        <trans-unit id="9020d3797b111846dfc58e088bf239a503f003ec" translate="yes" xml:space="preserve">
          <source>Run JSX Preprocessor</source>
          <target state="translated">JSX 전 처리기 실행</target>
        </trans-unit>
        <trans-unit id="e0f8daf0577d98a996bfa8ec0c41df7d50af891c" translate="yes" xml:space="preserve">
          <source>Run your test suite against the updated packages.</source>
          <target state="translated">업데이트 된 패키지에 대해 테스트 스위트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0827761783f753ff9b40994c31529959784a8de2" translate="yes" xml:space="preserve">
          <source>Running Flow</source>
          <target state="translated">흐르는 흐름</target>
        </trans-unit>
        <trans-unit id="fc77263186fd8066db7ad56b10769297381f425f" translate="yes" xml:space="preserve">
          <source>Running TypeScript</source>
          <target state="translated">TypeScript 실행</target>
        </trans-unit>
        <trans-unit id="98df08dc14cf2fe8409704906e8ba7f061915ee5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, but is used to hydrate a container whose HTML contents were rendered by &lt;a href=&quot;react-dom-server&quot;&gt;&lt;code&gt;ReactDOMServer&lt;/code&gt;&lt;/a&gt;. React will attempt to attach event listeners to the existing markup.</source>
          <target state="translated">&lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 HTML 내용이 &lt;a href=&quot;react-dom-server&quot;&gt; &lt;code&gt;ReactDOMServer&lt;/code&gt; 에&lt;/a&gt; 의해 렌더링 된 컨테이너를 수화하는 데 사용됩니다 . React는 이벤트 리스너를 기존 마크 업에 첨부하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f129cfc1e70fca4be604a579a5f801302cd6ac8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt;&lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt;&lt;/a&gt; but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt; &lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 하나의 결과가있을 것으로 예상하고 하나의 결과를 반환하거나 다른 수의 일치 항목이 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a4ebff257960955bf717b48cfa34669ee1fa3976" translate="yes" xml:space="preserve">
          <source>Scaling to many files and components.</source>
          <target state="translated">많은 파일 및 구성 요소로 확장</target>
        </trans-unit>
        <trans-unit id="9a78372a71733c0c9188bac3d792afa287fb2eda" translate="yes" xml:space="preserve">
          <source>Screen readers</source>
          <target state="translated">스크린 리더</target>
        </trans-unit>
        <trans-unit id="b61bfcb18d2395a6da3e919d474b496e6bf967ac" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;this visualization&lt;/a&gt; for a comparison of &lt;code&gt;throttle&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;throttle&lt;/code&gt; 및 &lt;code&gt;debounce&lt;/code&gt; 기능을 비교하려면 &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;이 시각화&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7cb44d447dbdc4f2ebff6dfd7717cd653ac4777" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;react-without-jsx&quot;&gt;Using React without JSX&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;react-without-jsx&quot;&gt;JSX없이 React 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d32e26b0425e2167e0dcb6fdf91a985d64bf28a6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt; for more information about the state.</source>
          <target state="translated">참조 &lt;a href=&quot;state-and-lifecycle&quot;&gt;주 및 라이프 사이클&lt;/a&gt; 상태에 대한 자세한 정보는.</target>
        </trans-unit>
        <trans-unit id="85a5ceb78c2280eeda3b846f0acb9cd42d788db2" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;the recommended pattern for derived state&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;파생 된 상태에 대한 권장 패턴&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a01530646c79b2f55199eeb7b47f0556cdd706ac" translate="yes" xml:space="preserve">
          <source>See below for how to fix this problem.</source>
          <target state="translated">이 문제를 해결하는 방법은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1693e8fef7af337e4a3ee1564391e1db17535c9f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;react-component&quot;&gt;React.Component API Reference&lt;/a&gt; for a list of methods and properties related to the base &lt;code&gt;React.Component&lt;/code&gt; class.</source>
          <target state="translated">기본 &lt;code&gt;React.Component&lt;/code&gt; 클래스 와 관련된 메소드 및 특성 목록은 &lt;a href=&quot;react-component&quot;&gt;React.Component API 참조 서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b57f0fefc1bf09d35ad975ad4ca5e7a0022756a" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;Thinking In React: Step 2&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">펜보기 &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;2 단계 :에서 반응 생각&lt;/a&gt; 에 &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="889e869dc48285461d9781e138af203334338e0d" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;Thinking In React: Step 5&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt; 의 펜 &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;사고&lt;/a&gt; 에 대한 5 단계 : 5 단계를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b9f4e6141331c9cdb4f88c27dd7d6b936edcd8e" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;Thinking In React: Step 4&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">펜 참조 &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;4 단계 :에 반응 생각&lt;/a&gt; 에 &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e91150ff591242b615b363e43cadf66bc003b974" translate="yes" xml:space="preserve">
          <source>Selection Events</source>
          <target state="translated">선택 이벤트</target>
        </trans-unit>
        <trans-unit id="337b6de00774331dfea10bf7602f57a929bd0481" translate="yes" xml:space="preserve">
          <source>Selective Hydration</source>
          <target state="translated">선택적 수화</target>
        </trans-unit>
        <trans-unit id="7c55bcc8e6eca62fa53850720b0e3bfdb3df096a" translate="yes" xml:space="preserve">
          <source>Semantic HTML</source>
          <target state="translated">시맨틱 HTML</target>
        </trans-unit>
        <trans-unit id="b2058039eabd80a65369d8f9cda9fc120b4c0fed" translate="yes" xml:space="preserve">
          <source>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</source>
          <target state="translated">시맨틱 HTML은 웹 애플리케이션에서 접근성의 기초입니다. 웹 사이트에서 정보의 의미를 강화하기 위해 다양한 HTML 요소를 사용하면 종종 무료로 접근 할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="551eb6c2699adf574c58f34b218b75ea8a444ba2" translate="yes" xml:space="preserve">
          <source>Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:</source>
          <target state="translated">독립 상태 변수를 분리하면 또 다른 이점이 있습니다. 예를 들어 다음과 같은 관련 논리를 사용자 정의 후크로 쉽게 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab5ab1acf5db0758245097e8fa3ad6f910f353a0" translate="yes" xml:space="preserve">
          <source>Server side rendering</source>
          <target state="translated">서버 측 렌더링</target>
        </trans-unit>
        <trans-unit id="aa8d26b865d79b0e63b8bfd0b9391b4237522018" translate="yes" xml:space="preserve">
          <source>Server-only. This API is not available in the browser.</source>
          <target state="translated">서버 전용. 이 API는 브라우저에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="21878b65dc5eb634bcd11071915a81b9ce37484e" translate="yes" xml:space="preserve">
          <source>Set the document &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; to correctly describe the current page content as this ensures that the user remains aware of the current page context:</source>
          <target state="translated">현재 페이지 내용을 올바르게 설명하도록 &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 문서를 설정하면 사용자가 현재 페이지 컨텍스트를 계속 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32b0183325e39fb8a7bae93ef8b271742e8892b1" translate="yes" xml:space="preserve">
          <source>Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt; and &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt;.</source>
          <target state="translated">선호하는 연속 통합 플랫폼을 사용하여 크론 작업을 설정하십시오. Cron 작업은 &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt; 및 &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt; 모두에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca49bc3bc95dc20864ef73e70622bcc8d41e81bb" translate="yes" xml:space="preserve">
          <source>Setting the Initial State</source>
          <target state="translated">초기 상태 설정</target>
        </trans-unit>
        <trans-unit id="418beebb985e8d40774763fdd4f9e8a6047b5b90" translate="yes" xml:space="preserve">
          <source>Setting the document title</source>
          <target state="translated">문서 제목 설정</target>
        </trans-unit>
        <trans-unit id="fac5905f3c39f20c6f85ca274a70117415678188" translate="yes" xml:space="preserve">
          <source>Setting the language</source>
          <target state="translated">언어 설정</target>
        </trans-unit>
        <trans-unit id="c08c4a1087611b4f8dc1ce3b9d6eab6afb735be4" translate="yes" xml:space="preserve">
          <source>Setup/Teardown</source>
          <target state="translated">Setup/Teardown</target>
        </trans-unit>
        <trans-unit id="1a12bbc273b9d327eac0e2f46ee90996baa545d4" translate="yes" xml:space="preserve">
          <source>Shallow Renderer</source>
          <target state="translated">얕은 렌더러</target>
        </trans-unit>
        <trans-unit id="157334ad7585fe71fa4ab72dc1138a4016d37634" translate="yes" xml:space="preserve">
          <source>Shallow testing currently has some limitations, namely not supporting refs.</source>
          <target state="translated">얕은 테스트에는 현재 심판을 지원하지 않는 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61717f0f4104f3c6b59d2620027283eb267d0f6f" translate="yes" xml:space="preserve">
          <source>Short Syntax</source>
          <target state="translated">짧은 구문</target>
        </trans-unit>
        <trans-unit id="d78971d67c66eff9e3aca079ae91a776c3dbebcf" translate="yes" xml:space="preserve">
          <source>Should I use Hooks, classes, or a mix of both?</source>
          <target state="translated">후크, 클래스 또는 둘의 혼합을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="65ba853a7020f20726c91f50244f39620f835b31" translate="yes" xml:space="preserve">
          <source>Should I use a state management library like Redux or MobX?</source>
          <target state="translated">Redux 또는 MobX와 같은 상태 관리 라이브러리를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="2eea49ef9ef41333d4d180d43ca9ea2c23559f87" translate="yes" xml:space="preserve">
          <source>Should I use one or many state variables?</source>
          <target state="translated">하나 이상의 상태 변수를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="9e6a9215ce35f846b17b522ab097d2abb82a7869" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">&lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;data-reactroot&lt;/code&gt; 와 같이 React가 내부적으로 사용하는 추가 DOM 속성을 생성하지 않는다는 점만 다릅니다 . 추가 속성을 제거하면 일부 바이트를 절약 할 수 있으므로 React를 간단한 정적 페이지 생성기로 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3608f05da13ebf98cb83134331188e8ec9e99c3e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="translated">&lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 &lt;code&gt;data-reactroot&lt;/code&gt; 와 같이 React가 내부적으로 사용하는 추가 DOM 속성을 생성하지 않는다는 점만 다릅니다 . 추가 속성을 제거하면 일부 바이트를 절약 할 수 있으므로 React를 간단한 정적 페이지 생성기로 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="90d668391f22451830d3dcf0d685e789289cf850" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt; helper from &lt;code&gt;react-dom/test-utils&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TestRenderer.act&lt;/code&gt; prepares a component for assertions. Use this version of &lt;code&gt;act()&lt;/code&gt; to wrap calls to &lt;code&gt;TestRenderer.create&lt;/code&gt; and &lt;code&gt;testRenderer.update&lt;/code&gt;.</source>
          <target state="translated">받는 유사 &lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;act()&lt;/code&gt; 에서 도우미 &lt;code&gt;react-dom/test-utils&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;TestRenderer.act&lt;/code&gt; 는 주장에 대한 구성 요소를 준비합니다. 이 버전의 &lt;code&gt;act()&lt;/code&gt; 를 사용 하여 &lt;code&gt;TestRenderer.create&lt;/code&gt; 및 &lt;code&gt;testRenderer.update&lt;/code&gt; 에 대한 호출을 래핑 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f95b4050bee5ae0b356d207e738904d2352b8c01" translate="yes" xml:space="preserve">
          <source>Similarly, all SVG attributes are fully supported:</source>
          <target state="translated">마찬가지로 모든 SVG 속성이 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ac994655a077627f0a00237edd40be91d12515d2" translate="yes" xml:space="preserve">
          <source>Similarly, we know from research that interactions like hover and text input need to be handled within a very short period of time, while clicks and page transitions can wait a little longer without feeling laggy. The different &amp;ldquo;priorities&amp;rdquo; that Concurrent Mode uses internally roughly correspond to the interaction categories in the human perception research.</source>
          <target state="translated">마찬가지로 연구 결과에 따르면 호버 및 텍스트 입력과 같은 상호 작용을 매우 짧은 시간 내에 처리해야하지만 클릭 및 페이지 전환은 느리게 느껴지지 않고 조금 더 오래 기다릴 수 있습니다. 동시 모드가 내부적으로 사용하는 다른&amp;ldquo;우선 순위&amp;rdquo;는 인간의 인식 연구에서 상호 작용 범주와 대략적으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="95c6045668485e434001bbb400904f65d6473b52" translate="yes" xml:space="preserve">
          <source>Simulate</source>
          <target state="translated">Simulate</target>
        </trans-unit>
        <trans-unit id="cdbbf7631367f8cecedfefc8e66eb086c7762a50" translate="yes" xml:space="preserve">
          <source>Simulate an event dispatch on a DOM node with optional &lt;code&gt;eventData&lt;/code&gt; event data.</source>
          <target state="translated">선택적 &lt;code&gt;eventData&lt;/code&gt; 이벤트 데이터 를 사용하여 DOM 노드에서 이벤트 디스패치를 ​​시뮬레이션하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a90574fe221159516cab518b7b70d81b6f6d291" translate="yes" xml:space="preserve">
          <source>Since &amp;ldquo;virtual DOM&amp;rdquo; is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term &amp;ldquo;virtual DOM&amp;rdquo; is usually associated with &lt;a href=&quot;rendering-elements&quot;&gt;React elements&lt;/a&gt; since they are the objects representing the user interface. React, however, also uses internal objects called &amp;ldquo;fibers&amp;rdquo; to hold additional information about the component tree. They may also be considered a part of &amp;ldquo;virtual DOM&amp;rdquo; implementation in React.</source>
          <target state="translated">&quot;가상 DOM&quot;은 특정 기술보다 더 많은 패턴이기 때문에 사람들은 때때로 다른 것을 의미한다고 말합니다. React 세계에서 &quot;가상 DOM&quot;이라는 용어는 일반적으로 사용자 인터페이스를 나타내는 객체이므로 &lt;a href=&quot;rendering-elements&quot;&gt;React 요소&lt;/a&gt; 와 관련이 있습니다. 그러나 React는 또한 &quot;섬유&quot;라는 내부 객체를 사용하여 구성 요소 트리에 대한 추가 정보를 보유합니다. 또한 React에서 &quot;가상 DOM&quot;구현의 일부로 간주 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4830b2d00e988292620868e08773981b63e3a3f0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;for&lt;/code&gt; is a reserved word in JavaScript, React elements use &lt;code&gt;htmlFor&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 는 JavaScript에서 예약어 이므로 React 요소는 대신 &lt;code&gt;htmlFor&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c096576bbc5548a29f7624ed231f5f3700e9858e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;false&lt;/code&gt; for the subtree rooted at C2, React did not attempt to render C2, and thus didn&amp;rsquo;t even have to invoke &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on C4 and C5.</source>
          <target state="translated">이후 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 가 반환 &lt;code&gt;false&lt;/code&gt; C2를 루트로하는 서브 트리를 들어, C2를 렌더링하지 않은 반응, 따라서도 호출 할 필요가 없었다 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 을 C4와 C5에.</target>
        </trans-unit>
        <trans-unit id="fa0676e6e4f1be773446c673e249d40dd484a093" translate="yes" xml:space="preserve">
          <source>Since Hooks are functions, we can pass information between them.</source>
          <target state="translated">후크는 함수이기 때문에 정보를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce78c3b89392f8fd00349533b1a860c5b146a75c" translate="yes" xml:space="preserve">
          <source>Since JSX compiles into calls to &lt;code&gt;React.createElement&lt;/code&gt;, the &lt;code&gt;React&lt;/code&gt; library must also always be in scope from your JSX code.</source>
          <target state="translated">JSX는 &lt;code&gt;React.createElement&lt;/code&gt; 에 대한 호출로 컴파일되므로 &lt;code&gt;React&lt;/code&gt; 라이브러리도 항상 JSX 코드 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="582c0c532f56fb3bc564df7ce904fded5bbd449f" translate="yes" xml:space="preserve">
          <source>Since JSX is closer to JavaScript than to HTML, React DOM uses &lt;code&gt;camelCase&lt;/code&gt; property naming convention instead of HTML attribute names.</source>
          <target state="translated">JSX는 HTML보다 JavaScript에 더 가깝기 때문에 React DOM은 HTML 속성 이름 대신 &lt;code&gt;camelCase&lt;/code&gt; 속성 명명 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a5465180db9678022404188e56a14dedb56e8c77" translate="yes" xml:space="preserve">
          <source>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</source>
          <target state="translated">제어되지 않는 구성 요소는 DOM에서 진실의 근원을 유지하므로 제어되지 않는 구성 요소를 사용할 때 React 코드와 비 React 코드를 통합하는 것이 더 쉬운 경우가 있습니다. 빠르고 더러워지기를 원한다면 코드가 약간 적을 수도 있습니다. 그렇지 않으면 일반적으로 제어되는 구성 요소를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="12802519d13596acb64db3728385146466f1c0c6" translate="yes" xml:space="preserve">
          <source>Since components are the basic unit of code reuse in React, let&amp;rsquo;s try refactoring the code a bit to use a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component that encapsulates the behavior we need to reuse elsewhere.</source>
          <target state="translated">컴포넌트는 React에서 코드 재사용의 기본 단위이므로 코드를 약간 리팩토링하여 다른 곳에서 재사용해야하는 동작을 캡슐화 하는 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 컴포넌트를 사용하도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7d149476874665e632f5d09368dfec9b329e5fb0" translate="yes" xml:space="preserve">
          <source>Since object refs were largely added as a replacement for string refs, strict mode now warns about usage of string refs.</source>
          <target state="translated">문자열 참조 대신 대체로 객체 참조가 추가되었으므로 이제 엄격 모드는 문자열 참조 사용에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="945a3eb7a113afe7fb345d5867e2f0417b7c4d31" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;value&lt;/code&gt; attribute is set on our form element, the displayed value will always be &lt;code&gt;this.state.value&lt;/code&gt;, making the React state the source of truth. Since &lt;code&gt;handleChange&lt;/code&gt; runs on every keystroke to update the React state, the displayed value will update as the user types.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 속성이 폼 요소에 설정되어 있기 때문에 표시되는 값은 항상 &lt;code&gt;this.state.value&lt;/code&gt; 가되어 React 상태를 진실의 소스로 만듭니다. &lt;code&gt;handleChange&lt;/code&gt; 는 모든 키 입력에서 실행되어 React 상태를 업데이트 하므로 사용자 가 입력 할 때 표시된 값이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="65dca83b0699ba95c122c68674390a7799fe42a9" translate="yes" xml:space="preserve">
          <source>Since this technique is a little unusual, you&amp;rsquo;ll probably want to explicitly state that &lt;code&gt;children&lt;/code&gt; should be a function in your &lt;code&gt;propTypes&lt;/code&gt; when designing an API like this.</source>
          <target state="translated">이 기술은 약간 특이하기 때문에 API를 디자인 할 때 &lt;code&gt;children&lt;/code&gt; 이 &lt;code&gt;propTypes&lt;/code&gt; 의 함수 여야한다고 명시 적으로 언급하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b258100f25369e4ae0ce97a3b2cb85cb2dfc0fe6" translate="yes" xml:space="preserve">
          <source>Since you&amp;rsquo;re often displaying a JSON data model to a user, you&amp;rsquo;ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That&amp;rsquo;s because UI and data models tend to adhere to the same &lt;em&gt;information architecture&lt;/em&gt;. Separate your UI into components, where each component matches one piece of your data model.</source>
          <target state="translated">JSON 데이터 모델을 사용자에게 자주 표시하기 때문에 모델이 올바르게 빌드 된 경우 UI (및 구성 요소 구조)가 멋지게 매핑됩니다. UI와 데이터 모델이 동일한 &lt;em&gt;정보 아키텍처&lt;/em&gt; 를 따르는 경향이 있기 때문 입니다. UI를 구성 요소로 분리하십시오. 여기서 각 구성 요소는 하나의 데이터 모델과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="625d8d80af7bbcdfa81222888dc91ae1c67047a5" translate="yes" xml:space="preserve">
          <source>Single-File Builds</source>
          <target state="translated">단일 파일 빌드</target>
        </trans-unit>
        <trans-unit id="b79ccec4e08c14b21b7dbe1bf30a724c5d594935" translate="yes" xml:space="preserve">
          <source>Single-page Application</source>
          <target state="translated">단일 페이지 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="5e268b8fb13c4275436f6fec47445b6c6a370b4f" translate="yes" xml:space="preserve">
          <source>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</source>
          <target state="translated">Skiplinks 또는 Navigation Navigation Links는 키보드 사용자가 페이지와 상호 작용할 때만 표시되는 숨겨진 탐색 링크입니다. 내부 페이지 앵커 및 일부 스타일링으로 구현하기가 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">스냅 샷 테스트</target>
        </trans-unit>
        <trans-unit id="540d1ef8fe38fe16e9bd6ac54276ab966b7a4f51" translate="yes" xml:space="preserve">
          <source>So What About Inheritance?</source>
          <target state="translated">상속은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="be184e3655c9a842843034adac922d2b6b3bcf62" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it&amp;rsquo;s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">지금까지 소품의 상태와 계층 구조로 흐르는 상태로 올바르게 렌더링되는 앱을 만들었습니다. 이제 다른 방식으로 흐르는 데이터를 지원할 차례입니다. 계층 구조의 깊이에있는 양식 구성 요소는 &lt;code&gt;FilterableProductTable&lt;/code&gt; 의 상태를 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3d36706ca32133596b9127ed5d816900d1e29cf2" translate="yes" xml:space="preserve">
          <source>So finally, our state is:</source>
          <target state="translated">마지막으로, 우리주는 :</target>
        </trans-unit>
        <trans-unit id="41a2c2d31192f2035b56a37240597cc8d1ce2f0e" translate="yes" xml:space="preserve">
          <source>So how does React know which state corresponds to which &lt;code&gt;useState&lt;/code&gt; call? The answer is that &lt;strong&gt;React relies on the order in which Hooks are called&lt;/strong&gt;. Our example works because the order of the Hook calls is the same on every render:</source>
          <target state="translated">그렇다면 React는 어떤 state가 어느 &lt;code&gt;useState&lt;/code&gt; 호출에 해당하는지 어떻게 알 수 있습니까? 대답은 &lt;strong&gt;React가 Hooks의 순서에 의존&lt;/strong&gt; 한다는 것입니다 . 이 예제는 Hook 호출 순서가 모든 렌더에서 동일하기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="91956b86d2b226dc60b40a10c6064c0879b25281" translate="yes" xml:space="preserve">
          <source>So the correct fix is to put &lt;code&gt;setQuery&lt;/code&gt; (which doesn&amp;rsquo;t suspend) &lt;em&gt;outside&lt;/em&gt; the transition, but &lt;code&gt;setResource&lt;/code&gt; (which will suspend) &lt;em&gt;inside&lt;/em&gt; of it.</source>
          <target state="translated">따라서 올바른 수정은 전환 &lt;em&gt;외부&lt;/em&gt; 에 &lt;code&gt;setQuery&lt;/code&gt; (일시 중지되지 않음)를 &lt;em&gt;배치&lt;/em&gt; 하지만 그 &lt;em&gt;안에는 &lt;/em&gt; &lt;code&gt;setResource&lt;/code&gt; (일시 중지)를 &lt;em&gt;넣는&lt;/em&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="11bcfd3ea24e7b454ce05dfb87c9d0158ac74b60" translate="yes" xml:space="preserve">
          <source>So the following jQuery implementation&amp;hellip;</source>
          <target state="translated">다음 jQuery 구현은&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="bf1cb757dd15a9b82f28af071a783eda7ce755d2" translate="yes" xml:space="preserve">
          <source>So using a render prop makes it possible to use either pattern.</source>
          <target state="translated">따라서 렌더링 소품을 사용하면 두 패턴 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8bee9b25a62fc9052ff4b48a5eeea612a72ba58" translate="yes" xml:space="preserve">
          <source>So what if we could write a &lt;code&gt;useReducer&lt;/code&gt; Hook that lets us manage the &lt;em&gt;local&lt;/em&gt; state of our component with a reducer? A simplified version of it might look like this:</source>
          <target state="translated">그렇다면 리듀서로 컴포넌트 의 &lt;em&gt;로컬&lt;/em&gt; 상태를 관리 할 수 있는 &lt;code&gt;useReducer&lt;/code&gt; Hook를 작성할 수 있다면 어떨까요? 단순화 된 버전은 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4363bcb8572f01d639e93f80d7731d5945c5a5b1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There are a few ways we can answer this:</source>
          <target state="translated">So what&amp;rsquo;s the point of Suspense? There are a few ways we can answer this:</target>
        </trans-unit>
        <trans-unit id="d06b3c258f542a990c77a5fae1fe50270e36d2d1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There&amp;rsquo;s a few ways we can answer this:</source>
          <target state="translated">서스펜스의 요점은 무엇입니까? 이에 대한 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7658e82394e9389e52b89bd4d2384e335440e9a" translate="yes" xml:space="preserve">
          <source>So, how can Hooks solve this problem? Just like &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;you can use the &lt;em&gt;State&lt;/em&gt; Hook more than once&lt;/a&gt;, you can also use several effects. This lets us separate unrelated logic into different effects:</source>
          <target state="translated">그렇다면 후크가 어떻게이 문제를 해결할 수 있습니까? &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;&lt;em&gt;State&lt;/em&gt;&lt;/a&gt; Hook를 두 번 이상 사용할 수있는&lt;em&gt;&lt;/em&gt; 것처럼 여러 효과를 사용할 수도 있습니다. 이를 통해 관련없는 논리를 다른 효과로 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8d02b7e415d9e8d63052f83b346ef42769efa71e" translate="yes" xml:space="preserve">
          <source>Solving Race Conditions with Suspense</source>
          <target state="translated">서스펜스로 레이스 조건 해결</target>
        </trans-unit>
        <trans-unit id="5dcc864f338464da25786ad58214ee40c24cb4fd" translate="yes" xml:space="preserve">
          <source>Some components don&amp;rsquo;t know their children ahead of time. This is especially common for components like &lt;code&gt;Sidebar&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; that represent generic &amp;ldquo;boxes&amp;rdquo;.</source>
          <target state="translated">일부 구성 요소는 미리 자녀를 알지 못합니다. &lt;code&gt;Sidebar&lt;/code&gt; 또는 &lt;code&gt;Dialog&lt;/code&gt; 와 같은 일반 &quot;상자&quot;를 나타내는 구성 요소에 특히 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="96871b8dd7b23918e375f655cee67524e2b12086" translate="yes" xml:space="preserve">
          <source>Some components have dependencies for modules that may not work well in test environments, or aren&amp;rsquo;t essential to our tests. It can be useful to selectively mock these modules out with suitable replacements &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 구성 요소에는 테스트 환경에서 제대로 작동하지 않거나 테스트에 필수적이지 않은 모듈에 대한 종속성이 있습니다. 적절한 대체품 &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(예)으로&lt;/small&gt;&lt;/a&gt; 이러한 모듈을 선택적으로 조롱하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="614c13a8b04ce94e3f4ed5ff071c3bd90dde1618" translate="yes" xml:space="preserve">
          <source>Some examples in the documentation use &lt;code&gt;style&lt;/code&gt; for convenience, but &lt;strong&gt;using the &lt;code&gt;style&lt;/code&gt; attribute as the primary means of styling elements is generally not recommended.&lt;/strong&gt; In most cases, &lt;a href=&quot;#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; should be used to reference classes defined in an external CSS stylesheet. &lt;code&gt;style&lt;/code&gt; is most often used in React applications to add dynamically-computed styles at render time. See also &lt;a href=&quot;faq-styling&quot;&gt;FAQ: Styling and CSS&lt;/a&gt;.</source>
          <target state="translated">문서 사용의 몇 가지 예 &lt;code&gt;style&lt;/code&gt; 편의를 위해, 그러나 &lt;strong&gt;사용하여 &lt;code&gt;style&lt;/code&gt; 스타일링 요소의 주요 수단으로 속성은 일반적으로 권장되지 않습니다. &lt;/strong&gt;대부분의 경우 &lt;a href=&quot;#classname&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt; 을 사용하여 외부 CSS 스타일 시트에 정의 된 클래스를 참조해야합니다. &lt;code&gt;style&lt;/code&gt; 은 렌더링시 동적으로 계산 된 스타일을 추가하기 위해 React 애플리케이션에서 가장 자주 사용됩니다. &lt;a href=&quot;faq-styling&quot;&gt;FAQ : 스타일링 및 CSS&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef4f7933de9dfc7491281fed4ffdc03bbfcf3853" translate="yes" xml:space="preserve">
          <source>Some modules might not work well inside a testing environment, or may not be as essential to the test itself. Mocking out these modules with dummy replacements can make it easier to write tests for your own code.</source>
          <target state="translated">일부 모듈은 테스트 환경에서 제대로 작동하지 않거나 테스트 자체에 필수적이지 않을 수 있습니다. 더미 교체로 이러한 모듈을 모의하면 자신의 코드에 대한 테스트를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4cfa33208dbe4639a0d378dff52c7435fff87fc" translate="yes" xml:space="preserve">
          <source>Some of the DOM attributes supported by React include:</source>
          <target state="translated">React가 지원하는 일부 DOM 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96e5cbe3009d23e8b32e7d37fe1acce8dabd1560" translate="yes" xml:space="preserve">
          <source>Some people also prefer to go further, and separate components into different folders depending on their role in the application. For example, &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; is a design methodology built on this principle. Remember that it&amp;rsquo;s often more productive to treat such methodologies as helpful examples rather than strict rules to follow.</source>
          <target state="translated">또한 일부 사람들은 더 나아가 응용 프로그램에서의 역할에 따라 구성 요소를 다른 폴더로 분리하는 것을 선호합니다. 예를 들어 &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; 은이 원칙을 기반으로하는 설계 방법입니다. 이러한 방법론을 엄격한 규칙이 아닌 유용한 예제로 취급하는 것이 종종 생산적이라는 점을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="d096867d249bc9020052a71ba018f7a10b3ca19c" translate="yes" xml:space="preserve">
          <source>Something Missing?</source>
          <target state="translated">누락 된 뭔가?</target>
        </trans-unit>
        <trans-unit id="80413ba692b4736af61c7baf6819b5bb8236d925" translate="yes" xml:space="preserve">
          <source>Sometimes a parent component needs to set focus to an element in a child component. We can do this by &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;exposing DOM refs to parent components&lt;/a&gt; through a special prop on the child component that forwards the parent&amp;rsquo;s ref to the child&amp;rsquo;s DOM node.</source>
          <target state="translated">때로는 상위 구성 요소가 하위 구성 요소의 요소에 초점을 설정해야합니다. 부모의 참조를 자식의 DOM 노드로 전달하는 자식 구성 요소의 특수 소품을 통해 &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;DOM 참조를 부모 구성 요소&lt;/a&gt; 에 노출 하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="b43c302a7eeb97d1c3b75a79a6531baafe26b30a" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to define a static method on a React component. For example, Relay containers expose a static method &lt;code&gt;getFragment&lt;/code&gt; to facilitate the composition of GraphQL fragments.</source>
          <target state="translated">때때로 React 컴포넌트에 정적 메소드를 정의하는 것이 유용합니다. 예를 들어, 릴레이 컨테이너는 정적 메소드 &lt;code&gt;getFragment&lt;/code&gt; 를 노출하여 GraphQL 조각의 구성을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="5d35c9c3f98eb464527bcc5a72fa4944c7139e41" translate="yes" xml:space="preserve">
          <source>Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;a list of commonly recommended resources&lt;/a&gt;, some of which are free.</source>
          <target state="translated">때때로 사람들은 공식 서적보다 타사 서적 및 비디오 과정이 더 유용하다고 생각합니다. 우리 &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;는 일반적으로 권장되는 자원의 목록을&lt;/a&gt; 유지 하며 일부는 무료입니다.</target>
        </trans-unit>
        <trans-unit id="892625bcde39b047433f6f0e4c2a6c85238cae55" translate="yes" xml:space="preserve">
          <source>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the &lt;code&gt;map()&lt;/code&gt; body is too nested, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">때로는 코드가 더 명확 해지지 만이 스타일도 남용 될 수 있습니다. JavaScript와 마찬가지로 가독성을 위해 변수를 추출 할 가치가 있는지 결정하는 것은 사용자의 몫입니다. 경우 생성 있다는 사실을 숙지 &lt;code&gt;map()&lt;/code&gt; 몸이 너무 중첩되어, 좋은 시간이 될 수있는 &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;구성 요소를 추출한다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0183ce117e89d5333990aad33e9f21dbd3c8ad5" translate="yes" xml:space="preserve">
          <source>Sometimes very different components may share some common functionality. These are sometimes called &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;cross-cutting concerns&lt;/a&gt;. &lt;code&gt;createReactClass&lt;/code&gt; lets you use a legacy &lt;code&gt;mixins&lt;/code&gt; system for that.</source>
          <target state="translated">때로는 매우 다른 구성 요소가 공통 기능을 공유 할 수 있습니다. 이를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;간절히 우려하는 문제&lt;/a&gt; 라고 합니다. &lt;code&gt;createReactClass&lt;/code&gt; 를 사용하면 레거시 &lt;code&gt;mixins&lt;/code&gt; 시스템을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0df05a3843bbcf9ee66e7ee68ac3c0653e4fec68" translate="yes" xml:space="preserve">
          <source>Sometimes we break HTML semantics when we add &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements to our JSX to make our React code work, especially when working with lists (&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt;) and the HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;. In these cases we should rather use &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; to group together multiple elements.</source>
          <target state="translated">때로는 리스트 ( &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt; ) 및 HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 으로 작업 할 때 React 코드를 작동시키기 위해 JSX에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소를 추가 할 때 HTML 의미가 깨지는 경우가 있습니다 . 이 경우 &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; 를 사용 하여 여러 요소를 그룹화 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6e2e5311eb15d9d862c73dbfbe53759a23f39f84" translate="yes" xml:space="preserve">
          <source>Sometimes we think about components as being &amp;ldquo;special cases&amp;rdquo; of other components. For example, we might say that a &lt;code&gt;WelcomeDialog&lt;/code&gt; is a special case of &lt;code&gt;Dialog&lt;/code&gt;.</source>
          <target state="translated">때로는 구성 요소를 다른 구성 요소의 &quot;특별한 사례&quot;로 생각합니다. 예를 들어 &lt;code&gt;WelcomeDialog&lt;/code&gt; 는 &lt;code&gt;Dialog&lt;/code&gt; 의 특별한 경우 라고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2113ccfe3cef67ecda3109bea67055bdcc179fac" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to &lt;strong&gt;run some additional code after React has updated the DOM.&lt;/strong&gt; Network requests, manual DOM mutations, and logging are common examples of effects that don&amp;rsquo;t require a cleanup. We say that because we can run them and immediately forget about them. Let&amp;rsquo;s compare how classes and Hooks let us express such side effects.</source>
          <target state="translated">때때로 &lt;strong&gt;React가 DOM을 업데이트 한 후 몇 가지 추가 코드&lt;/strong&gt; 를 &lt;strong&gt;실행&lt;/strong&gt; 하려고합니다 &lt;strong&gt;. &lt;/strong&gt;네트워크 요청, 수동 DOM 변이 및 로깅은 정리가 필요없는 일반적인 효과의 예입니다. 우리는 그들을 실행할 수 있고 즉시 잊어 버릴 수 있다고 말합니다. 클래스와 후크가 어떻게 이러한 부작용을 표현할 수 있는지 비교해 봅시다.</target>
        </trans-unit>
        <trans-unit id="657bcb464d6a199b5a3987ac0c1ea4a5d73c44d1" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; and &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;. Custom Hooks let you do this, but without adding more components to your tree.</source>
          <target state="translated">때때로, 우리는 컴포넌트들 사이의 상태 저장 로직을 재사용하려고합니다. 전통적으로이 문제에 대한 두 가지 대중적인 솔루션이있었습니다 : &lt;a href=&quot;higher-order-components&quot;&gt;고차 컴포넌트&lt;/a&gt; 와 &lt;a href=&quot;render-props&quot;&gt;렌더 소품&lt;/a&gt; . 사용자 지정 후크를 사용하면 더 많은 구성 요소를 트리에 추가하지 않고도이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351447063fd3690ce16863aa7ac3c07a6ab525f3" translate="yes" xml:space="preserve">
          <source>Sometimes, you may not want to mock timers. For example, maybe you&amp;rsquo;re testing an animation, or interacting with an endpoint that&amp;rsquo;s sensitive to timing (like an API rate limiter). Libraries with timer mocks let you enable and disable them on a per test/suite basis, so you can explicitly choose how these tests would run.</source>
          <target state="translated">때로는 타이머를 조롱하고 싶지 않을 수도 있습니다. 예를 들어, 애니메이션을 테스트하거나 타이밍에 민감한 엔드 포인트 (예 : API 속도 제한 기)와 상호 작용할 수 있습니다. 타이머 모의가있는 라이브러리를 사용하면 테스트 / 스위트별로이를 활성화 및 비활성화 할 수 있으므로 이러한 테스트 실행 방법을 명시 적으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091ab55337927adfcab6d0cbf58d4ada7ebe5d05" translate="yes" xml:space="preserve">
          <source>Sometimes, your effect may be using state that changes too often. You might be tempted to omit that state from a list of dependencies, but that usually leads to bugs:</source>
          <target state="translated">때로는 효과가 너무 자주 변하는 상태를 사용하고있을 수도 있습니다. 의존성 목록에서 해당 상태를 생략하고 싶을 수도 있지만 일반적으로 버그가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="1fa161cc62a9e4ea6aa020d607d68a8963cee67c" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;[count]&lt;/code&gt; as a list of dependencies would fix the bug, but would cause the interval to be reset on every change. Effectively, each &lt;code&gt;setInterval&lt;/code&gt; would get one chance to execute before being cleared (similar to a &lt;code&gt;setTimeout&lt;/code&gt;.) That may not be desirable. To fix this, we can use the &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;functional update form of &lt;code&gt;setState&lt;/code&gt;&lt;/a&gt;. It lets us specify &lt;em&gt;how&lt;/em&gt; the state needs to change without referencing the &lt;em&gt;current&lt;/em&gt; state:</source>
          <target state="translated">종속성 목록으로 &lt;code&gt;[count]&lt;/code&gt; 를 지정 하면 버그가 해결되지만 변경 될 때마다 간격이 재설정됩니다. 효과적으로 각 &lt;code&gt;setInterval&lt;/code&gt; 은 지워지기 전에 한 번의 기회를 얻습니다 ( &lt;code&gt;setTimeout&lt;/code&gt; 과 유사 ). 바람직하지 않을 수 있습니다. 이 문제를 해결하기 위해 &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt; &lt;code&gt;setState&lt;/code&gt; &lt;/a&gt; 기능 업데이트 양식을 사용할 수 있습니다 . &lt;em&gt;현재&lt;/em&gt; 상태 를 참조하지 않고 상태를 변경 &lt;em&gt;하는 방법을&lt;/em&gt; 지정할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f9a50e2fbfe07712e5925cf722f8b4a41d2e0df" translate="yes" xml:space="preserve">
          <source>Specifying Attributes with JSX</source>
          <target state="translated">JSX로 속성 지정</target>
        </trans-unit>
        <trans-unit id="5a158241151d38add28063d1a39efc6a532ed860" translate="yes" xml:space="preserve">
          <source>Specifying Children with JSX</source>
          <target state="translated">JSX로 자식 지정</target>
        </trans-unit>
        <trans-unit id="e4fa66e9ea342e16491d74d178d20dc425ce360e" translate="yes" xml:space="preserve">
          <source>Specifying The React Element Type</source>
          <target state="translated">반응 요소 유형 지정</target>
        </trans-unit>
        <trans-unit id="248e5212cad1782449c4a8e8fdc79f7d18ea7441" translate="yes" xml:space="preserve">
          <source>Specifying the initial state</source>
          <target state="translated">초기 상태 지정</target>
        </trans-unit>
        <trans-unit id="484b72292d9dd5e8ed98a1228281ec72fe6aaebe" translate="yes" xml:space="preserve">
          <source>Specifying the value prop on a &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled component&lt;/a&gt; prevents the user from changing the input unless you desire so. If you&amp;rsquo;ve specified a &lt;code&gt;value&lt;/code&gt; but the input is still editable, you may have accidentally set &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;forms#controlled-components&quot;&gt;제어되는 구성 요소&lt;/a&gt; 에 값 prop을 지정하면 사용자가 원치 않는 한 사용자가 입력을 변경하지 못하게됩니다. &lt;code&gt;value&lt;/code&gt; 지정 했지만 입력을 여전히 편집 할 수있는 경우 실수로 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 로 설정했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04a3524370f46bd76ff0ae35ee1a6d4dc7ad661e" translate="yes" xml:space="preserve">
          <source>Splitting High and Low Priority State</source>
          <target state="translated">높고 낮은 우선 순위 상태 분할</target>
        </trans-unit>
        <trans-unit id="7250062690f9f9d303c56e302576ed47dd44bdaf" translate="yes" xml:space="preserve">
          <source>Spread Attributes</source>
          <target state="translated">스프레드 속성</target>
        </trans-unit>
        <trans-unit id="efd4ca2d204c1e4616c4e8cf039d050140fdb3ee" translate="yes" xml:space="preserve">
          <source>Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don&amp;rsquo;t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly.</source>
          <target state="translated">스프레드 속성은 유용 할 수 있지만 불필요한 소품을 신경 쓰지 않는 구성 요소에 쉽게 전달하거나 유효하지 않은 HTML 속성을 DOM에 전달할 수 있습니다. 이 구문을 조금만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="064bfcfabe6af4f3be4dbea953ea4d27d586523d" translate="yes" xml:space="preserve">
          <source>Standalone Node Package</source>
          <target state="translated">독립형 노드 패키지</target>
        </trans-unit>
        <trans-unit id="5def4534ce22a871405cdf372bebde72db101bdc" translate="yes" xml:space="preserve">
          <source>Standards and Guidelines</source>
          <target state="translated">표준 및 지침</target>
        </trans-unit>
        <trans-unit id="cd1bd3ab3b9ae3d1a43994956517d5ee88941549" translate="yes" xml:space="preserve">
          <source>Start Fetching Early</source>
          <target state="translated">일찍 가져 오기 시작</target>
        </trans-unit>
        <trans-unit id="711a21abde2479b997c6cb2cae4595727f2a64c8" translate="yes" xml:space="preserve">
          <source>Start With A Mock</source>
          <target state="translated">모의로 시작</target>
        </trans-unit>
        <trans-unit id="91177ccaba80c331e7a4c30fc35a6c5a3d541e03" translate="yes" xml:space="preserve">
          <source>Start fetching</source>
          <target state="translated">가져 오기 시작</target>
        </trans-unit>
        <trans-unit id="8f669e598b328d921b668756a5d615493ee0168c" translate="yes" xml:space="preserve">
          <source>Start rendering</source>
          <target state="translated">렌더링 시작</target>
        </trans-unit>
        <trans-unit id="a86d8f44e22238201b173b962f6886510a0da088" translate="yes" xml:space="preserve">
          <source>Starting with 16.8.0, React includes a stable implementation of React Hooks for:</source>
          <target state="translated">16.8.0부터 React에는 다음을위한 안정적인 React Hooks 구현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="92f810f23bdc85140b73e30ea49450509c5bd85c" translate="yes" xml:space="preserve">
          <source>Starting with React 17, the &lt;code&gt;onScroll&lt;/code&gt; event &lt;strong&gt;does not bubble&lt;/strong&gt; in React. This matches the browser behavior and prevents the confusion when a nested scrollable element fires events on a distant parent.</source>
          <target state="translated">Starting with React 17, the &lt;code&gt;onScroll&lt;/code&gt; event &lt;strong&gt;does not bubble&lt;/strong&gt; in React. This matches the browser behavior and prevents the confusion when a nested scrollable element fires events on a distant parent.</target>
        </trans-unit>
        <trans-unit id="18c688a4bc8cbf6a9e644ceeea91e61be20a88de" translate="yes" xml:space="preserve">
          <source>State Updates May Be Asynchronous</source>
          <target state="translated">상태 업데이트는 비동기적일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="88237580e68309e5a5a6557ed798f9117f825c21" translate="yes" xml:space="preserve">
          <source>State Updates are Merged</source>
          <target state="translated">상태 업데이트가 병합되었습니다</target>
        </trans-unit>
        <trans-unit id="a8d6e1e76b0e2efabcf40d1b7270dae7fadac365" translate="yes" xml:space="preserve">
          <source>State and Lifecycle</source>
          <target state="translated">상태 및 수명주기</target>
        </trans-unit>
        <trans-unit id="67d1df931840b49786d4500f55b14d3015fe3f48" translate="yes" xml:space="preserve">
          <source>State and Lifecycle guide</source>
          <target state="translated">상태 및 수명주기 안내서</target>
        </trans-unit>
        <trans-unit id="4df972d16c5d19e8d5ddb903b62a89007862e156" translate="yes" xml:space="preserve">
          <source>State is similar to props, but it is private and fully controlled by the component.</source>
          <target state="translated">상태는 소품과 유사하지만 구성 요소에 의해 완전히 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="1d1c74f2d06c5f4368c9bc7a2cf5d263cebf3d96" translate="yes" xml:space="preserve">
          <source>State updater functions (the first argument to &lt;code&gt;setState&lt;/code&gt;)</source>
          <target state="translated">State updater functions (the first argument to &lt;code&gt;setState&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7d421eaa763efe61aa522fbfca14b10e27b8dcc0" translate="yes" xml:space="preserve">
          <source>State variables and state cells in &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt;.</source>
          <target state="translated">의 상태 변수와 상태의 세포 &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3878c33013f598bc32c82cf1ead566633a3f208e" translate="yes" xml:space="preserve">
          <source>Static Methods Must Be Copied Over</source>
          <target state="translated">정적 메소드를 복사해야합니다</target>
        </trans-unit>
        <trans-unit id="bd88cfef69c4e37c1ba575ea9f53e708a1a1232c" translate="yes" xml:space="preserve">
          <source>Static Type Checking</source>
          <target state="translated">정적 유형 확인</target>
        </trans-unit>
        <trans-unit id="924e72d946f8bfadb7a3147de738b256272c4bf4" translate="yes" xml:space="preserve">
          <source>Static type checkers like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; identify certain types of problems before you even run your code. They can also improve developer workflow by adding features like auto-completion. For this reason, we recommend using Flow or TypeScript instead of &lt;code&gt;PropTypes&lt;/code&gt; for larger code bases.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; 및 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 와 같은 정적 유형 검사기는 코드를 실행하기 전에 특정 유형의 문제를 식별합니다. 또한 자동 완성과 같은 기능을 추가하여 개발자 워크 플로를 향상시킬 수 있습니다. 따라서 더 큰 코드 기반 에는 &lt;code&gt;PropTypes&lt;/code&gt; 대신 Flow 또는 TypeScript를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a0bd05cb8a239da7ed3487a46c276e0484a9dd10" translate="yes" xml:space="preserve">
          <source>Staying Informed</source>
          <target state="translated">정보를 유지</target>
        </trans-unit>
        <trans-unit id="9feb5d73b7d630e1fa9f796479ee1477109b8dba" translate="yes" xml:space="preserve">
          <source>Step 1: Add a DOM Container to the HTML</source>
          <target state="translated">1 단계 : HTML에 DOM 컨테이너 추가</target>
        </trans-unit>
        <trans-unit id="14221e6881613f0cccb7ed29f77307bf69df44a9" translate="yes" xml:space="preserve">
          <source>Step 1: Break The UI Into A Component Hierarchy</source>
          <target state="translated">1 단계 : UI를 구성 요소 계층으로 나누기</target>
        </trans-unit>
        <trans-unit id="f86ff7cc0b24afa445be129e259c884fd0af8b9b" translate="yes" xml:space="preserve">
          <source>Step 2: Add the Script Tags</source>
          <target state="translated">2 단계 : 스크립트 태그 추가</target>
        </trans-unit>
        <trans-unit id="123ca7868e30446f688a7f747df83b53290cef75" translate="yes" xml:space="preserve">
          <source>Step 2: Build A Static Version in React</source>
          <target state="translated">2 단계 : React에서 정적 버전 빌드</target>
        </trans-unit>
        <trans-unit id="39ec5061574d18b5de0be9ab6b2b1a042b9c2339" translate="yes" xml:space="preserve">
          <source>Step 3: Create a React Component</source>
          <target state="translated">3 단계 : 반응 구성 요소 생성</target>
        </trans-unit>
        <trans-unit id="33a5f37d369f03644215598531ec2c023674c11b" translate="yes" xml:space="preserve">
          <source>Step 3: Identify The Minimal (but complete) Representation Of UI State</source>
          <target state="translated">3 단계 : UI 상태의 최소 (그러나 완전한) 표현 식별</target>
        </trans-unit>
        <trans-unit id="62f65581c960b7670694036d15605d1e79ee3f22" translate="yes" xml:space="preserve">
          <source>Step 4: Identify Where Your State Should Live</source>
          <target state="translated">4 단계 : 주가 어디에서 살 것인지 식별</target>
        </trans-unit>
        <trans-unit id="d63ae2a1550f68c81fc498e7a755f439ca787317" translate="yes" xml:space="preserve">
          <source>Step 5: Add Inverse Data Flow</source>
          <target state="translated">5 단계 : 역 데이터 흐름 추가</target>
        </trans-unit>
        <trans-unit id="0395deb615c42389e7f7f63e97f88c21bad5e8cb" translate="yes" xml:space="preserve">
          <source>Step-by-Step Guide</source>
          <target state="translated">단계별 가이드</target>
        </trans-unit>
        <trans-unit id="ded55f9c4ea8f5cf7b52f527f0d476e47f977212" translate="yes" xml:space="preserve">
          <source>Stop recording.</source>
          <target state="translated">녹음을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="translated">엄격한 모드</target>
        </trans-unit>
        <trans-unit id="ffd57d06c3bfecbc437452b09e192830e0690661" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:</source>
          <target state="translated">Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following functions:</target>
        </trans-unit>
        <trans-unit id="1433029b40a7c8096820012bb4fd0012e00acc4b" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following methods:</source>
          <target state="translated">엄격 모드는 자동으로 부작용을 감지 할 수 없지만, 좀 더 결정 론적으로 만들어 부작용을 발견 할 수 있습니다. 이것은 의도적으로 다음 방법을 두 번 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f8563c9f25fde889f1c031be9d1996fb84fdad0" translate="yes" xml:space="preserve">
          <source>Strict mode checks are run in development mode only; &lt;em&gt;they do not impact the production build&lt;/em&gt;.</source>
          <target state="translated">엄격한 모드 검사는 개발 모드에서만 실행됩니다. &lt;em&gt;프로덕션 빌드에는 영향을 미치지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="translated">문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="504651e88e0554e0480e5760d113aa05357364b8" translate="yes" xml:space="preserve">
          <source>String Refs</source>
          <target state="translated">문자열 참조</target>
        </trans-unit>
        <trans-unit id="9491d60784f7659ed917ac4823f4059dd50ab9e6" translate="yes" xml:space="preserve">
          <source>Stripping Flow Syntax from the Compiled Code</source>
          <target state="translated">컴파일 된 코드에서 스트립 핑 흐름 구문</target>
        </trans-unit>
        <trans-unit id="89d196a4aa8b803a1ebf5056e05caebbbc2bd828" translate="yes" xml:space="preserve">
          <source>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. &lt;code&gt;node.style.backgroundImage&lt;/code&gt;). Vendor prefixes &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt;other than &lt;code&gt;ms&lt;/code&gt;&lt;/a&gt; should begin with a capital letter. This is why &lt;code&gt;WebkitTransition&lt;/code&gt; has an uppercase &amp;ldquo;W&amp;rdquo;.</source>
          <target state="translated">JS에서 DOM 노드의 속성에 액세스하기 위해 스타일 키가 camelCased됩니다 (예 : &lt;code&gt;node.style.backgroundImage&lt;/code&gt; ). &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt; &lt;code&gt;ms&lt;/code&gt; &lt;/a&gt; 이외의 공급 업체 접두사 는 대문자로 시작해야합니다. 이것이 &lt;code&gt;WebkitTransition&lt;/code&gt; 에 대문자&amp;ldquo;W&amp;rdquo;가있는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="dd76e22706bae25144071aa88dd7860b26352adb" translate="yes" xml:space="preserve">
          <source>Styling and CSS</source>
          <target state="translated">스타일링 및 CSS</target>
        </trans-unit>
        <trans-unit id="414b5ca82eb42c71f0f2d39c844f482fd42ea9da" translate="yes" xml:space="preserve">
          <source>Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:</source>
          <target state="translated">후속 통화는 동일한주기에서 이전 통화의 값보다 우선하므로 수량은 한 번만 증가합니다. 다음 상태가 현재 상태에 의존하는 경우 업데이트 프로그램 기능 양식을 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="333ad9c79db454c75a821468e0cf82cb446eefbc" translate="yes" xml:space="preserve">
          <source>Such functions are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&amp;ldquo;pure&amp;rdquo;&lt;/a&gt; because they do not attempt to change their inputs, and always return the same result for the same inputs.</source>
          <target state="translated">이러한 기능은 입력을 변경하지 않고 항상 동일한 입력에 대해 동일한 결과를 반환하기 때문에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&quot;순수&quot;&lt;/a&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="2358d63b1ed4396759930456a478ea2a3ecb09ca" translate="yes" xml:space="preserve">
          <source>Supported Events</source>
          <target state="translated">지원되는 이벤트</target>
        </trans-unit>
        <trans-unit id="e9d85411dc54581517da69d2b9ea66c39e1aebb2" translate="yes" xml:space="preserve">
          <source>Suppose you have a structure like:</source>
          <target state="translated">다음과 같은 구조가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="abd40b2a3a10e13029651065e57e2382da64bf8f" translate="yes" xml:space="preserve">
          <source>Suspense</source>
          <target state="translated">Suspense</target>
        </trans-unit>
        <trans-unit id="a18d9f771ec11baec15e54073d783f488add33bd" translate="yes" xml:space="preserve">
          <source>Suspense API</source>
          <target state="translated">서스펜스 API</target>
        </trans-unit>
        <trans-unit id="ac2887f41b70a20e517e2b034cd704e52c8fb68b" translate="yes" xml:space="preserve">
          <source>Suspense Reveal &amp;ldquo;Train&amp;rdquo;</source>
          <target state="translated">서스펜스 공개 &quot;기차&quot;</target>
        </trans-unit>
        <trans-unit id="321f28f3a1ac7332ad69a67dae8b9247d8a85a04" translate="yes" xml:space="preserve">
          <source>Suspense SSR + Hydration</source>
          <target state="translated">서스펜스 SSR + 수화</target>
        </trans-unit>
        <trans-unit id="81114a1c8b3333230f42d8c8600b93746352c08a" translate="yes" xml:space="preserve">
          <source>Suspense and Race Conditions</source>
          <target state="translated">서스펜스 및 레이스 조건</target>
        </trans-unit>
        <trans-unit id="b82aa4510b7ffae21c24013d7b39f194e5aaa84e" translate="yes" xml:space="preserve">
          <source>Suspense answers some questions, but it also poses new questions of its own:</source>
          <target state="translated">서스펜스는 몇 가지 질문에 대답하지만 자체 질문도 제기합니다.</target>
        </trans-unit>
        <trans-unit id="0668777af59a2bb3b94fb7bd2790a6a69182a367" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching</source>
          <target state="translated">데이터 가져 오기에 대한 서스펜스</target>
        </trans-unit>
        <trans-unit id="17e3380602b04a7d645ea7631524d14d2b831868" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching (Experimental)</source>
          <target state="translated">데이터 가져 오기에 대한 서스펜스 (실험적)</target>
        </trans-unit>
        <trans-unit id="693b7a99ad484ef032cfb982205ce455d09996b7" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching is a new feature that lets you also use &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; to &lt;strong&gt;declaratively &amp;ldquo;wait&amp;rdquo; for anything else, including data.&lt;/strong&gt; This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</source>
          <target state="translated">Suspense for Data Fetching은 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 를 사용 &lt;strong&gt;하여 데이터를 포함한 다른 모든 것을 선언적으로 &quot;대기&quot;&lt;/strong&gt; 할 수있는 새로운 기능입니다 &lt;strong&gt;. &lt;/strong&gt;이 페이지는 데이터 가져 오기 사용 사례에 중점을 두지 만 이미지, 스크립트 또는 기타 비동기 작업을 기다릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0d4cdaa1a76384c088f402a4f96d85a28531e2" translate="yes" xml:space="preserve">
          <source>Suspense is not a data fetching library. It&amp;rsquo;s a &lt;strong&gt;mechanism for data fetching libraries&lt;/strong&gt; to communicate to React that &lt;em&gt;the data a component is reading is not ready yet&lt;/em&gt;. React can then wait for it to be ready and update the UI. At Facebook, we use Relay and its &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;new Suspense integration&lt;/a&gt;. We expect that other libraries like Apollo can provide similar integrations.</source>
          <target state="translated">서스펜스는 데이터 페치 라이브러리가 아닙니다. &lt;strong&gt;데이터 페치 라이브러리&lt;/strong&gt; 가 &lt;em&gt;컴포넌트가 읽고있는 데이터가 아직 준비되지 않았다는&lt;/em&gt; React와 통신 하는 &lt;strong&gt;메커니즘입니다&lt;/strong&gt; . React는 준비가 될 때까지 기다렸다가 UI를 업데이트 할 수 있습니다. Facebook에서는 Relay와 &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;새로운 Suspense 통합을 사용&lt;/a&gt; 합니다. 우리는 Apollo와 같은 다른 라이브러리가 유사한 통합을 제공 할 수있을 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="ae0fdcad1737c52adbeb2031aa8e91aa234309f3" translate="yes" xml:space="preserve">
          <source>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions. Let&amp;rsquo;s clarify the most common ones:</source>
          <target state="translated">서스펜스는 이러한 문제에 대한 기존의 접근 방식과 크게 다르므로 처음으로 그것에 대해 읽는 것은 종종 오해로 이어집니다. 가장 일반적인 것들을 명확히합시다.</target>
        </trans-unit>
        <trans-unit id="2300fe3099f2f4c3d641d1d53b84cabdafe3a65d" translate="yes" xml:space="preserve">
          <source>Suspense itself as a mechanism is flexible and doesn&amp;rsquo;t have many constraints. Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees. Some questions that we&amp;rsquo;re currently exploring include:</source>
          <target state="translated">메커니즘으로서의 서스펜스 자체는 유연하고 많은 제약이 없습니다. 폭포수가 없도록 제품 코드를 더 제한해야하지만 이러한 보장을 제공하는 다른 방법이 있습니다. 현재 조사중인 몇 가지 질문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0d14a0b49b6d0f702b2ffbbecd59f387529f76b" translate="yes" xml:space="preserve">
          <source>Suspense lets components &amp;ldquo;wait&amp;rdquo; for something before rendering. Today, Suspense only supports one use case: &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;loading components dynamically with &lt;code&gt;React.lazy&lt;/code&gt;&lt;/a&gt;. In the future, it will support other use cases like data fetching.</source>
          <target state="translated">서스펜스는 렌더링 전에 컴포넌트가 무언가를&amp;ldquo;기다릴&amp;rdquo;수있게합니다. 현재 Suspense는 &lt;a href=&quot;code-splitting#reactlazy&quot;&gt; &lt;code&gt;React.lazy&lt;/code&gt; 를&lt;/a&gt; 사용하여 구성 요소를 동적으로로드 하는 하나의 사용 사례 만 지원합니다 . 앞으로는 데이터 가져 오기와 같은 다른 사용 사례를 지원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5cc08b841d3b9a32f5104a0898d01491b08aa477" translate="yes" xml:space="preserve">
          <source>Suspense lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render. In &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;this example&lt;/a&gt;, two components wait for an asynchronous API call to fetch some data:</source>
          <target state="translated">Suspense를 사용하면 구성 요소가 렌더링하기 전에 무언가를&amp;ldquo;기다릴&amp;rdquo;수 있습니다. 에서 &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;예&lt;/a&gt; , 두 가지 구성 요소는 일부 데이터를 가져 오기위한 비동기 API 호출을 기다립니다</target>
        </trans-unit>
        <trans-unit id="597e77ccf0147ff1e0e95dbbfc0c166549395d98" translate="yes" xml:space="preserve">
          <source>SuspenseList</source>
          <target state="translated">SuspenseList</target>
        </trans-unit>
        <trans-unit id="f0933b54a50ee57a6c427ef3484a69b2e12b94de" translate="yes" xml:space="preserve">
          <source>SyntheticEvent</source>
          <target state="translated">SyntheticEvent</target>
        </trans-unit>
        <trans-unit id="eb94a49137dc3e1d46de143e47c86b9942e468c2" translate="yes" xml:space="preserve">
          <source>Teams with a strong focus on user experience sometimes solve similar problems with one-off solutions. However, those solutions rarely survive for a long time, as they&amp;rsquo;re hard to maintain. With Concurrent Mode, our goal is to bake the UI research findings into the abstraction itself, and provide idiomatic ways to use them. As a UI library, React is well-positioned to do that.</source>
          <target state="translated">사용자 경험에 중점을 둔 팀은 때때로 일회성 솔루션으로 유사한 문제를 해결합니다. 그러나 이러한 솔루션은 유지 관리가 어렵 기 때문에 오랫동안 지속되는 경우는 거의 없습니다. Concurrent Mode를 사용하면 UI 연구 결과를 추상화 자체로 구워서이를 사용하는 관용적 방법을 제공하는 것입니다. UI 라이브러리로서 React는 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c65f0a5afe770a42c1f536806bc2ba23c61729" translate="yes" xml:space="preserve">
          <source>Temporarily &lt;strong&gt;disable all Chrome extensions, especially React DevTools&lt;/strong&gt;. They can significantly skew the results!</source>
          <target state="translated">&lt;strong&gt;모든 Chrome 확장 프로그램, 특히 React DevTools를&lt;/strong&gt; 일시적으로 &lt;strong&gt;사용 중지합니다&lt;/strong&gt; . 결과가 크게 왜곡 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="2d9f45c513924550decb83eed63be6f6d9fd3fb5" translate="yes" xml:space="preserve">
          <source>Test Renderer</source>
          <target state="translated">테스트 렌더러</target>
        </trans-unit>
        <trans-unit id="f9f882a7cfbac9fa3cff0ad94e26ffd24816fce8" translate="yes" xml:space="preserve">
          <source>Test Utilities</source>
          <target state="translated">테스트 유틸리티</target>
        </trans-unit>
        <trans-unit id="ba890ac7eaae740a1397d738f471733e2031742f" translate="yes" xml:space="preserve">
          <source>Test runners</source>
          <target state="translated">테스트 러너</target>
        </trans-unit>
        <trans-unit id="124162fb455da17f3c10873c994eb7025be9ae73" translate="yes" xml:space="preserve">
          <source>Test runners like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt; let you write test suites as regular JavaScript, and run them as part of your development process. Additionally, test suites are run as part of continuous integration.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; , &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt; , &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt; 와 같은 테스트 러너는 테스트 스위트를 일반 JavaScript로 작성하고 개발 프로세스의 일부로 실행할 수 있습니다. 또한 테스트 스위트는 지속적인 통합의 일부로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df1ad36dfe1da6bac30d4a2122b6bbb6bcdc9305" translate="yes" xml:space="preserve">
          <source>TestInstance</source>
          <target state="translated">TestInstance</target>
        </trans-unit>
        <trans-unit id="0e69f126cac48a7e0d8d39281bf25ed113ce94ed" translate="yes" xml:space="preserve">
          <source>TestRenderer</source>
          <target state="translated">TestRenderer</target>
        </trans-unit>
        <trans-unit id="6cfd3bb51c904996890bb1730778d2a7efc233b6" translate="yes" xml:space="preserve">
          <source>TestRenderer instance</source>
          <target state="translated">TestRenderer 인스턴스</target>
        </trans-unit>
        <trans-unit id="b4da10691865addeea2f1c653b85a8f1e0286f02" translate="yes" xml:space="preserve">
          <source>TestRenderer.act()</source>
          <target state="translated">TestRenderer.act()</target>
        </trans-unit>
        <trans-unit id="2e71b6a628eaf51262cd4d225cbcddbb76bb40a1" translate="yes" xml:space="preserve">
          <source>TestRenderer.create()</source>
          <target state="translated">TestRenderer.create()</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="12812e81c11031211b6dbe3caf13286f4d099fbc" translate="yes" xml:space="preserve">
          <source>Testing Environments</source>
          <target state="translated">테스트 환경</target>
        </trans-unit>
        <trans-unit id="89b062a062bb5077e146efeebbb24fba0a676163" translate="yes" xml:space="preserve">
          <source>Testing Overview</source>
          <target state="translated">테스트 개요</target>
        </trans-unit>
        <trans-unit id="d4f180c77cb6606396db8f6554504a4d8a6d0019" translate="yes" xml:space="preserve">
          <source>Testing Recipes</source>
          <target state="translated">레시피 테스트</target>
        </trans-unit>
        <trans-unit id="6cd6d80805fdc664e169392908689e2225952cde" translate="yes" xml:space="preserve">
          <source>Testing accessibility in the browser</source>
          <target state="translated">브라우저에서 접근성 테스트</target>
        </trans-unit>
        <trans-unit id="e77bc776e14ce1b3f92953a1505b14b5e8807a09" translate="yes" xml:space="preserve">
          <source>Testing with a screen reader should form part of your accessibility tests.</source>
          <target state="translated">스크린 리더를 사용한 테스트는 접근성 테스트의 일부를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a38b0e5bfa5bb2618320d9e5309a34ceaea5d8a2" translate="yes" xml:space="preserve">
          <source>Testing your rate limiting</source>
          <target state="translated">속도 제한 테스트</target>
        </trans-unit>
        <trans-unit id="0ee7b58ebfe6f538de913f611a981507c709cfc5" translate="yes" xml:space="preserve">
          <source>Tests often run in an environment without access to a real rendering surface like a browser. For these environments, we recommend simulating a browser with &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;, a lightweight browser implementation that runs inside Node.js.</source>
          <target state="translated">테스트는 종종 브라우저와 같은 실제 렌더링 화면에 액세스하지 않고 환경에서 실행됩니다. 이러한 환경에서는 Node.js 내에서 실행되는 경량 브라우저 구현 인 &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt; 으로 브라우저를 시뮬레이션하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5360faacc2fd3e662f0f2d953eff4fe5f229a4dc" translate="yes" xml:space="preserve">
          <source>That means that with a version number &lt;strong&gt;x.y.z&lt;/strong&gt;:</source>
          <target state="translated">이는 버전 번호가 &lt;strong&gt;xyz 인&lt;/strong&gt; 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2572cbe643325f3e4047c805feaf04cce5e624d2" translate="yes" xml:space="preserve">
          <source>That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.</source>
          <target state="translated">즉,이 목록의 변경으로 인해 커뮤니티에서 광범위한 문제가 발생할 것으로 예상되는 경우에도 점진적인 마이그레이션 경로를 제공하기 위해 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="133f42dd430ef5bbc99318df87da28082b76ff20" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s It!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="47cf34ef6f2d037d4305bba6dc055a53cc17f54f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;logProps&amp;rdquo; HOC passes all &lt;code&gt;props&lt;/code&gt; through to the component it wraps, so the rendered output will be the same. For example, we can use this HOC to log all props that get passed to our &amp;ldquo;fancy button&amp;rdquo; component:</source>
          <target state="translated">&quot;logProps&quot;HOC는 모든 &lt;code&gt;props&lt;/code&gt; 을 포장하는 구성 요소로 전달 하므로 렌더링 된 출력이 동일합니다. 예를 들어,이 HOC를 사용하여 &quot;팬시 버튼&quot;구성 요소로 전달되는 모든 소품을 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e338a1de1df09480e7fd8879427799044a4cefcc" translate="yes" xml:space="preserve">
          <source>The &amp;rdquo;+&amp;rdquo; and &amp;rdquo;-&amp;rdquo; buttons use the functional form, because the updated value is based on the previous value. But the &amp;ldquo;Reset&amp;rdquo; button uses the normal form, because it always sets the count back to the initial value.</source>
          <target state="translated">업데이트 된 값은 이전 값을 기반으로하기 때문에 &quot;+&quot;및 &quot;-&quot;버튼은 기능적 형식을 사용합니다. 그러나 &quot;재설정&quot;버튼은 항상 카운트를 초기 값으로 설정하기 때문에 일반 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="01b742ba6eb43b216e145ce39e12bd4bdf765b31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; objects are pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event event handler has been called. For example, this won&amp;rsquo;t work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2384cbfbef2aaecf2b1b1cef6cc143a819625453" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary&quot;&gt;glossary&lt;/a&gt; contains an overview of the most common terms you&amp;rsquo;ll see in the React documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including &lt;a href=&quot;faq-ajax&quot;&gt;making AJAX requests&lt;/a&gt;, &lt;a href=&quot;faq-state&quot;&gt;component state&lt;/a&gt;, and &lt;a href=&quot;faq-structure&quot;&gt;file structure&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary&quot;&gt;용어는&lt;/a&gt; 당신이이 문서 반응에 볼 수 가장 일반적인 용어에 대한 개요가 포함되어 있습니다. &lt;a href=&quot;faq-ajax&quot;&gt;AJAX 요청&lt;/a&gt; , &lt;a href=&quot;faq-state&quot;&gt;구성 요소 상태&lt;/a&gt; 및 &lt;a href=&quot;faq-structure&quot;&gt;파일 구조 &lt;/a&gt;작성을 포함하여 일반적인 주제에 대한 간단한 질문과 답변을 제공하는 FAQ 섹션도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="748db1aa2803f2dfcb93b31b6cbd612e4302e368" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook makes it easier to control when individual children update, reducing the need for pure components.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; 의&lt;/a&gt; 훅은 쉽게 순수 부품의 필요성을 절감, 개별 아동 업데이트 할 때를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d194b55aa0e5c4407ec3ef22a2a2374e9ad14f78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; used this example to get familiar with Hooks:</source>
          <target state="translated">&lt;a href=&quot;hooks-intro&quot;&gt;소개 페이지는&lt;/a&gt; 후크에 익숙해 위해이 예제를 사용 :</target>
        </trans-unit>
        <trans-unit id="2346342023beadde66b62f9c79644b07c2e16dd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook lets you keep the same callback reference between re-renders so that &lt;code&gt;shouldComponentUpdate&lt;/code&gt; continues to work:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; 의&lt;/a&gt; 후크는 사이 같은 콜백 참조 너무 재 - 렌더링 유지할 수 있습니다 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 가 계속 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="120d49be1a12891d545be48cefeee776b16e23c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook lets you cache calculations between multiple renders by &amp;ldquo;remembering&amp;rdquo; the previous computation:</source>
          <target state="translated">&lt;a href=&quot;hooks-reference#usememo&quot;&gt; &lt;code&gt;useMemo&lt;/code&gt; 의&lt;/a&gt; 후크는 여러가 &quot;기억&quot;이전 계산에 의해 렌더링 사이에 당신이 계산을 캐시 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="098a2975ef1c374c6d16cb1384320a5fa0b0dcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;array destructuring&lt;/a&gt; syntax lets us give different names to the state variables we declared by calling &lt;code&gt;useState&lt;/code&gt;. These names aren&amp;rsquo;t a part of the &lt;code&gt;useState&lt;/code&gt; API. Instead, React assumes that if you call &lt;code&gt;useState&lt;/code&gt; many times, you do it in the same order during every render. We&amp;rsquo;ll come back to why this works and when this is useful later.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;배열 destructuring의&lt;/a&gt; 구문은 우리가 호출하여 선언 된 상태 변수에 다른 이름을 부여 할 수 있습니다 &lt;code&gt;useState&lt;/code&gt; 을 . 이 이름은 &lt;code&gt;useState&lt;/code&gt; API 의 일부가 아닙니다 . 대신 React는 &lt;code&gt;useState&lt;/code&gt; 를 여러 번 호출 하면 모든 렌더링 중에 동일한 순서로 수행 한다고 가정합니다 . 이것이 왜 효과가 있고 나중에 유용 할 때 다시 돌아올 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1157f3e19fdd019adc6c8af16bcb7d469610ebc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; plugin compresses and mangles the final bundle.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt; &lt;code&gt;terser&lt;/code&gt; &lt;/a&gt; 압축 미치게 최종 번들 플러그인.</target>
        </trans-unit>
        <trans-unit id="edcb883b6855822aeaaaf923c3ccb9c7db6aacae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint-plugin-jsx-a11y&lt;/a&gt; plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE&amp;rsquo;s allow you to integrate these findings directly into code analysis and source code windows.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint - 플러그인 - jsx-a11y의&lt;/a&gt; ESLint에 대한 플러그인은 JSX의 접근성 문제에 대한 AST linting 피드백을 제공합니다. 많은 IDE를 사용하면 이러한 결과를 코드 분석 및 소스 코드 창에 직접 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="466c527e21770fbc02c5b0d781265c63d3f2df55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;&lt;code&gt;envify&lt;/code&gt;&lt;/a&gt; transform ensures the right build environment is set. Make it global (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt; &lt;code&gt;envify&lt;/code&gt; &lt;/a&gt; 변환 보장하지만이 오른쪽 빌드 환경이 설정됩니다. 전역 화하십시오 ( &lt;code&gt;-g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="682e1228ae05401a65c58b0a5a7c5947327f9fa8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt;&lt;code&gt;uglifyify&lt;/code&gt;&lt;/a&gt; transform removes development imports. Make it global too (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="translated">는 &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt; &lt;code&gt;uglifyify&lt;/code&gt; &lt;/a&gt; 제거합니다을 개발 수입을 변환. 전역 화하십시오 ( &lt;code&gt;-g&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d8ad55d9dccafa63caad67ca7c1eeabc211f835" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt;&lt;code&gt;commonjs&lt;/code&gt;&lt;/a&gt; plugin provides support for CommonJS in Rollup.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt; &lt;code&gt;commonjs&lt;/code&gt; &lt;/a&gt; 플러그인은 롤업에 CommonJS에 대한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fec342ad3128435e51009a9f76d45133f8620021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt; plugin ensures the right build environment is set.</source>
          <target state="translated">는 &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; 올바른 빌드 환경이 설정되어 보장하지만 플러그인.</target>
        </trans-unit>
        <trans-unit id="de89beb93569715dce635201036fc64e63c3ab03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/&quot;&gt;React homepage&lt;/a&gt; contains a few small React examples with a live editor. Even if you don&amp;rsquo;t know anything about React yet, try changing their code and see how it affects the result.</source>
          <target state="translated">는 &lt;a href=&quot;https://reactjs.org/&quot;&gt;홈페이지 반응&lt;/a&gt; 몇 가지 작은 라이브 편집기로 예제 반응이 포함되어 있습니다. 아직 React에 대해 아무것도 모르더라도 코드를 변경하여 결과에 어떤 영향을 미치는지보십시오.</target>
        </trans-unit>
        <trans-unit id="974ac1c4a0c9da760228a943bce37428cd6a0e23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;React blog&lt;/a&gt; is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted there first.</source>
          <target state="translated">는 &lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;블로그 반응&lt;/a&gt; (가) 팀이 반응에서 업데이트의 공식 소스입니다. 출시 노트 또는 지원 중단 공지를 포함하여 중요한 사항이 먼저 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad57eeeea994127067368039363f4ff4d6702fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;Web Accessibility Evaluation Tool&lt;/a&gt; is another accessibility browser extension.</source>
          <target state="translated">&lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;웹 접근성 평가 도구는&lt;/a&gt; 다른 접근 브라우저 확장 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f83d6081d60ff040de57036c3c2ca925f0d22729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;Web Accessibility Initiative - Accessible Rich Internet Applications&lt;/a&gt; document contains techniques for building fully accessible JavaScript widgets.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;웹 접근성 이니셔티브 - 액세스 리치 인터넷 어플리케이션의&lt;/a&gt; 문서는 완전히 액세스 자바 스크립트 위젯을 구축하기위한 기술이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c94cd5415c60ee0381a2c958378a40eaeaf801" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Web Content Accessibility Guidelines&lt;/a&gt; provides guidelines for creating accessible web sites.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;웹 콘텐츠 접근성 지침&lt;/a&gt; 에 액세스 할 웹 사이트를 만들기위한 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71e5eefc03760deefaf5de6d0e50a96ab32f93bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing-recipes&quot;&gt;&lt;code&gt;recipes&lt;/code&gt;&lt;/a&gt; document contains more details on how &lt;code&gt;act()&lt;/code&gt; behaves, with examples and usage.</source>
          <target state="translated">&lt;a href=&quot;testing-recipes&quot;&gt; &lt;code&gt;recipes&lt;/code&gt; &lt;/a&gt; 문서는 더 방법에 대한 자세한 내용이 포함 &lt;code&gt;act()&lt;/code&gt; 예제 및 사용과 동작합니다을.</target>
        </trans-unit>
        <trans-unit id="93cd169de202dab7b3a7bc88a7d0ccacf3c3279a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Avatar&lt;/code&gt; doesn&amp;rsquo;t need to know that it is being rendered inside a &lt;code&gt;Comment&lt;/code&gt;. This is why we have given its prop a more generic name: &lt;code&gt;user&lt;/code&gt; rather than &lt;code&gt;author&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Avatar&lt;/code&gt; 그것이 내부 렌더링되고 있음을 알 필요가 없습니다 &lt;code&gt;Comment&lt;/code&gt; . 그렇기 때문에 우리는 그 prop에보다 일반적인 이름 &lt;code&gt;author&lt;/code&gt; 대신 &lt;code&gt;user&lt;/code&gt; 를 부여했습니다 .</target>
        </trans-unit>
        <trans-unit id="4a76f53d7593b26bd487b5056b04b9938d981554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FormattedDate&lt;/code&gt; component would receive the &lt;code&gt;date&lt;/code&gt; in its props and wouldn&amp;rsquo;t know whether it came from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s state, from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s props, or was typed by hand:</source>
          <target state="translated">&lt;code&gt;FormattedDate&lt;/code&gt; 의 구성 요소는받을 &lt;code&gt;date&lt;/code&gt; 의 소품과가 온인지 모르겠다 &lt;code&gt;Clock&lt;/code&gt; '는에서의 상태 &lt;code&gt;Clock&lt;/code&gt; 의'소품, 또는 손으로 입력했다 :</target>
        </trans-unit>
        <trans-unit id="ef0d77ae8586dfacccde29ab8965e058f9cd57a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; measures how often a React application renders and what the &amp;ldquo;cost&amp;rdquo; of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimizations such as memoization&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 측정 방법 종종 응용 프로그램을 렌더링하고 어떤 렌더링의 &quot;비용&quot;입니다 반응한다. 그것의 목적은 느리고 응용 프로그램의 일부를 식별 &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;하여 메모와 같은 최적화의&lt;/a&gt; 혜택을 볼 수 있도록 돕는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ada4ac9d87ac916586daecc13fbb29890339bfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; requires an &lt;code&gt;onRender&lt;/code&gt; function as a prop. React calls this function any time a component within the profiled tree &amp;ldquo;commits&amp;rdquo; an update. It receives parameters describing what was rendered and how long it took.</source>
          <target state="translated">&lt;code&gt;Profiler&lt;/code&gt; 필요로 &lt;code&gt;onRender&lt;/code&gt; 소품 등의 기능을. React는 프로파일 된 트리 내의 컴포넌트가 업데이트를 &quot;커밋&quot;할 때마다이 함수를 호출합니다. 렌더링 된 내용과 소요 시간을 설명하는 매개 변수를받습니다.</target>
        </trans-unit>
        <trans-unit id="135fecf5352f306a8ec799e1818c365ff3112c82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.Fragment&lt;/code&gt; component lets you return multiple elements in a &lt;code&gt;render()&lt;/code&gt; method without creating an additional DOM element:</source>
          <target state="translated">&lt;code&gt;React.Fragment&lt;/code&gt; 의 구성 요소를 사용하면 여러 요소를 반환 할 수 있습니다 &lt;code&gt;render()&lt;/code&gt; 추가 DOM 요소를 생성하지 않고 방법 :</target>
        </trans-unit>
        <trans-unit id="bb92ce250ac6de4e11572565bd150102f2d8a162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.lazy&lt;/code&gt; function lets you render a dynamic import as a regular component.</source>
          <target state="translated">&lt;code&gt;React.lazy&lt;/code&gt; 의 기능은 일반 구성 요소로 동적 가져 오기를 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb6a31b8dfd687a65274464ad8c41bf13e449eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReactDOMServer&lt;/code&gt; object enables you to render components to static markup. Typically, it&amp;rsquo;s used on a Node server:</source>
          <target state="translated">&lt;code&gt;ReactDOMServer&lt;/code&gt; 의 객체는 정적 마크 업 구성 요소를 렌더링 할 수 있습니다. 일반적으로 노드 서버에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9450751b918d37e1e6d5d17ecb9ef92dc4e90c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&lt;/code&gt; is pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&lt;/code&gt; 은 풀링됩니다. 이것은 이벤트 콜백이 호출 된 후 &lt;code&gt;SyntheticEvent&lt;/code&gt; 객체가 재사용되고 모든 속성이 무효화 됨을 의미합니다 . 이것은 성능상의 이유 때문입니다. 따라서 비동기 방식으로 이벤트에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="199347fbd83520bd3e789e3686528fa06113abd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; components of type &lt;code&gt;checkbox&lt;/code&gt; or &lt;code&gt;radio&lt;/code&gt;. You can use it to set whether the component is checked. This is useful for building controlled components. &lt;code&gt;defaultChecked&lt;/code&gt; is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.</source>
          <target state="translated">&lt;code&gt;checked&lt;/code&gt; 특성에 의해지지된다 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 유형의 컴포넌트 &lt;code&gt;checkbox&lt;/code&gt; 또는 &lt;code&gt;radio&lt;/code&gt; . 이를 사용하여 구성 요소를 확인할지 여부를 설정할 수 있습니다. 제어 된 구성 요소를 빌드하는 데 유용합니다. &lt;code&gt;defaultChecked&lt;/code&gt; 는 제어되지 않는 동등 항목으로, 처음 마운트 할 때 구성 요소를 검사할지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b6728729851a5746fae29188678d79fa67af247b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentDidMount()&lt;/code&gt; method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</source>
          <target state="translated">&lt;code&gt;componentDidMount()&lt;/code&gt; 컴포넌트 출력 후에 실행 방법은 DOM으로 표현되었다. 타이머를 설정하기에 좋은 곳입니다.</target>
        </trans-unit>
        <trans-unit id="ed96963c77fb1890112f95b4829564475778ec4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compose&lt;/code&gt; utility function is provided by many third-party libraries including lodash (as &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt;&lt;code&gt;lodash.flowRight&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Redux&lt;/a&gt;, and &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 유틸리티 기능은 (같은 lodash 등 많은 타사 라이브러리에서 제공 &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt; &lt;code&gt;lodash.flowRight&lt;/code&gt; &lt;/a&gt; ) &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;돌아 오는&lt;/a&gt; , 그리고 &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e04791f8bce0f48514a481f8e96c984420b6e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contextType&lt;/code&gt; property on a class can be assigned a Context object created by &lt;a href=&quot;#reactcreatecontext&quot;&gt;&lt;code&gt;React.createContext()&lt;/code&gt;&lt;/a&gt;. This lets you consume the nearest current value of that Context type using &lt;code&gt;this.context&lt;/code&gt;. You can reference this in any of the lifecycle methods including the render function.</source>
          <target state="translated">클래스 의 &lt;code&gt;contextType&lt;/code&gt; 속성에는 &lt;a href=&quot;#reactcreatecontext&quot;&gt; &lt;code&gt;React.createContext()&lt;/code&gt; &lt;/a&gt; 만든 Context 객체를 할당 할 수 있습니다 . 이를 통해 &lt;code&gt;this.context&lt;/code&gt; 를 사용하여 해당 컨텍스트 유형의 가장 가까운 현재 값을 사용할 수 있습니다 . 렌더 함수를 포함한 모든 라이프 사이클 방법에서이를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cccbfd6e53da65ebc9b175cdb8162582789149dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultProps&lt;/code&gt; will be used to ensure that &lt;code&gt;this.props.name&lt;/code&gt; will have a value if it was not specified by the parent component. The &lt;code&gt;propTypes&lt;/code&gt; typechecking happens after &lt;code&gt;defaultProps&lt;/code&gt; are resolved, so typechecking will also apply to the &lt;code&gt;defaultProps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 는 것을 보장하기 위해 사용됩니다 &lt;code&gt;this.props.name&lt;/code&gt; 이 가 부모 요소에 의해 지정되지 않은 경우 값을가집니다. &lt;code&gt;propTypes&lt;/code&gt; 의 후 유형 검사는 발생 &lt;code&gt;defaultProps&lt;/code&gt; 가 해결 유형 검사도 적용됩니다, 그래서 &lt;code&gt;defaultProps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee13fb806f9e8f23f14548fbcf1c0937a20a5c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultValue&lt;/code&gt; argument is &lt;strong&gt;only&lt;/strong&gt; used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing &lt;code&gt;undefined&lt;/code&gt; as a Provider value does not cause consuming components to use &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;defaultValue&lt;/code&gt; 인수되는 &lt;strong&gt;경우에만&lt;/strong&gt; 구성 요소가 트리의 위에 일치하는 공급자가없는 경우에 사용. 이는 구성 요소를 랩핑하지 않고 분리하여 테스트하는 데 도움이 될 수 있습니다. 참고 : &lt;code&gt;undefined&lt;/code&gt; 제공자 값을 &lt;code&gt;defaultValue&lt;/code&gt; 소비 컴포넌트가 defaultValue 를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6a777fc98bbd33659d037fd7c927c40043be8933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;displayName&lt;/code&gt; string is used in debugging messages. Usually, you don&amp;rsquo;t need to set it explicitly because it&amp;rsquo;s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;Wrap the Display Name for Easy Debugging&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;displayName&lt;/code&gt; 문자열은 메시지를 디버깅에 사용됩니다. 일반적으로 구성 요소를 정의하는 함수 또는 클래스의 이름에서 유추되므로 명시 적으로 설정할 필요가 없습니다. 디버깅 목적으로 다른 이름을 표시하거나 상위 구성 요소를 작성할 때 명시 적으로 설정하려는 경우 자세한 내용 &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;은 쉬운 디버깅을&lt;/a&gt; 위해 표시 이름 랩핑 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f3264d4c6693710d81212483cd77491f03734f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallback&lt;/code&gt; prop accepts any React elements that you want to render while waiting for the component to load. You can place the &lt;code&gt;Suspense&lt;/code&gt; component anywhere above the lazy component. You can even wrap multiple lazy components with a single &lt;code&gt;Suspense&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; 소품은 당신이 부하로 구성 요소를 기다리는 동안 렌더링하려는 요소 반응 받아들입니다. 지연 구성 요소 위의 아무 곳에 나 &lt;code&gt;Suspense&lt;/code&gt; 구성 요소를 배치 할 수 있습니다 . 단일 &lt;code&gt;Suspense&lt;/code&gt; 구성 요소로 여러 게으른 구성 요소를 래핑 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a87cab9efee0ca186ad1f9234f7af7e9b2e6f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getChildContext&lt;/code&gt; function will be called when the state or props changes. In order to update data in the context, trigger a local state update with &lt;code&gt;this.setState&lt;/code&gt;. This will trigger a new context and changes will be received by the children.</source>
          <target state="translated">&lt;code&gt;getChildContext&lt;/code&gt; 의 기능은 때 주 또는 소품 변경 호출됩니다. 컨텍스트에서 데이터를 업데이트하려면 &lt;code&gt;this.setState&lt;/code&gt; 로 로컬 상태 업데이트를 트리거하십시오 . 이것은 새로운 맥락을 유발할 것이며 아이들이 변화를받을 것입니다.</target>
        </trans-unit>
        <trans-unit id="aec1e744f364f63f5ad699d9c279366bd3b643fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component calls &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; with the new desired value. Its props, including &lt;code&gt;onTemperatureChange&lt;/code&gt;, were provided by its parent component, the &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TemperatureInput&lt;/code&gt; 구성 요소 의 &lt;code&gt;handleChange&lt;/code&gt; 메소드는 원하는 새 값으로 &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; 를 호출 합니다. &lt;code&gt;onTemperatureChange&lt;/code&gt; 를 포함한 소품 은 상위 컴포넌트 인 &lt;code&gt;Calculator&lt;/code&gt; 에 의해 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="210f25cbff1c57d320cf40f4827a05dd0f21c6f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialState&lt;/code&gt; argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:</source>
          <target state="translated">&lt;code&gt;initialState&lt;/code&gt; 인수는 초기 렌더링 중에 사용 된 상태입니다. 후속 렌더링에서는 무시됩니다. 초기 상태가 비싼 계산의 결과 인 경우 대신 초기 렌더에서만 실행되는 함수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4b380ee4d5e3b1bd645f3f0bfab036ddd24f72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isPending&lt;/code&gt; boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.</source>
          <target state="translated">&lt;code&gt;isPending&lt;/code&gt; 의 부울는 우리가 이전 프로필 페이지에 약간의 로딩 텍스트를 표시하여 사용자가이 알려 할 수 있도록, 우리의 구성 요소가 전환되는 것을 알고 반응 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd1395ba5aab1721b29879ffafc1520cf2ef8732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; property can take any of the values documented in the &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOM Level 3 Events spec&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 속성에 설명 된 값 중 하나 걸릴 수 있습니다 &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOM 레벨 3 이벤트 사양을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50b803bb4c9f45c5004b2f4b0708f76ae97a29fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name !== ''&lt;/code&gt; condition is &lt;code&gt;true&lt;/code&gt; on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition &lt;code&gt;false&lt;/code&gt;. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:</source>
          <target state="translated">&lt;code&gt;name !== ''&lt;/code&gt; 조건은 &lt;code&gt;true&lt;/code&gt; 우리가이 후크를 실행하므로, 최초의 렌더링에. 그러나 다음 렌더링에서 사용자는 양식을 지우고 조건을 &lt;code&gt;false&lt;/code&gt; 로 만들 수 있습니다 . 렌더링 중에이 후크를 건너 뛰기 때문에 후크 호출 순서가 달라집니다.</target>
        </trans-unit>
        <trans-unit id="f85476d3988e9bdfdd3e540a4ed2f05b110634e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onBlur&lt;/code&gt; event handler is called when focus has left the element (or left some element inside of it). For example, it&amp;rsquo;s called when the user clicks outside of a focused text input.</source>
          <target state="translated">The &lt;code&gt;onBlur&lt;/code&gt; event handler is called when focus has left the element (or left some element inside of it). For example, it&amp;rsquo;s called when the user clicks outside of a focused text input.</target>
        </trans-unit>
        <trans-unit id="a2f669e76a5881578195b4cedc603f344983fd17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onChange&lt;/code&gt; event behaves as you would expect it to: whenever a form field is changed, this event is fired. We intentionally do not use the existing browser behavior because &lt;code&gt;onChange&lt;/code&gt; is a misnomer for its behavior and React relies on this event to handle user input in real time.</source>
          <target state="translated">&lt;code&gt;onChange&lt;/code&gt; 양식 필드가 변경 될 때마다,이 이벤트가 발생한다 : 당신이 그것을 기대하는 것처럼 이벤트 동작합니다. &lt;code&gt;onChange&lt;/code&gt; 는 해당 동작의 잘못된 이름 이므로 React는이 이벤트를 사용하여 실시간으로 사용자 입력을 처리 하므로 기존 브라우저 동작을 의도적으로 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9df1c231344463418878f550484397733c07805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onFocus&lt;/code&gt; event is called when the element (or some element inside of it) receives focus. For example, it&amp;rsquo;s called when the user clicks on a text input.</source>
          <target state="translated">The &lt;code&gt;onFocus&lt;/code&gt; event is called when the element (or some element inside of it) receives focus. For example, it&amp;rsquo;s called when the user clicks on a text input.</target>
        </trans-unit>
        <trans-unit id="94e4f5de13553781365d91a92540227537125ed7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onMouseEnter&lt;/code&gt; and &lt;code&gt;onMouseLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">&lt;code&gt;onMouseEnter&lt;/code&gt; 및 &lt;code&gt;onMouseLeave&lt;/code&gt; 이벤트는 하나가 아닌 일반 버블의 입력되는 왼쪽되는 요소로부터 전파하고 캡처 단계가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf02d54b18eb7e4b7f6b5f2f59bf6af62f2393be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onPointerEnter&lt;/code&gt; and &lt;code&gt;onPointerLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="translated">&lt;code&gt;onPointerEnter&lt;/code&gt; 및 &lt;code&gt;onPointerLeave&lt;/code&gt; 이벤트는 하나가 아닌 일반 버블의 입력되는 왼쪽되는 요소로부터 전파하고 캡처 단계가 없습니다.</target>
        </trans-unit>
        <trans-unit id="674e5d12b6df14f94e34397b4ed6ffef33e647e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onTemperatureChange&lt;/code&gt; prop will be provided together with the &lt;code&gt;temperature&lt;/code&gt; prop by the parent &lt;code&gt;Calculator&lt;/code&gt; component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new &lt;code&gt;Calculator&lt;/code&gt; implementation very soon.</source>
          <target state="translated">&lt;code&gt;onTemperatureChange&lt;/code&gt; 의 소품이 함께 제공 될 것이다 &lt;code&gt;temperature&lt;/code&gt; 부모에 의해 프로스 &lt;code&gt;Calculator&lt;/code&gt; 컴포넌트. 자체 로컬 상태를 수정하여 변경 사항을 처리하므로 두 입력을 모두 새 값으로 다시 렌더링합니다. 새로운 &lt;code&gt;Calculator&lt;/code&gt; 구현을 곧 살펴볼 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d719b7a2d158d7590b77512a3cf13bd01ac52e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-dom&lt;/code&gt; package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</source>
          <target state="translated">는 &lt;code&gt;react-dom&lt;/code&gt; 패키지는 당신이 필요한 경우 모델 반응의 외부를 얻을 수 있도록 응용 프로그램의 최상위 수준과 탈출구로 사용할 수 있습니다 DOM 고유의 방법을 제공합니다. 대부분의 구성 요소는이 모듈을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bed13105d59f319bf16f5451f3a730147d671056" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; function should be pure, meaning that it does not modify component state, it returns the same result each time it&amp;rsquo;s invoked, and it does not directly interact with the browser.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 함수는 동일한 결과를가 호출 될 때마다 반환하고, 브라우저와 직접 상호 작용하지 않습니다, 그것은 구성 요소 상태를 변경하지 않음을 의미 순수해야한다.</target>
        </trans-unit>
        <trans-unit id="0a3390f73827da0e30d1b704469d47775415fc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; method is the only required method in a class component.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; 메소드는 클래스 구성 요소에서 유일하게 필요한 방법이다.</target>
        </trans-unit>
        <trans-unit id="481c653efaf41fafb96ad006f60184c54f2b1c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 방법</target>
        </trans-unit>
        <trans-unit id="54fcb9f91c38f310283c2df0f37ef88cd13c8c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method will be called each time an update happens, but as long as we render &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; into the same DOM node, only a single instance of the &lt;code&gt;Clock&lt;/code&gt; class will be used. This lets us use additional features such as local state and lifecycle methods.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 방법은 업데이트가 발생 때마다 호출 될하지만 같은 우리가 렌더링으로 &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 같은 DOM 노드에, 인스턴스가 하나만 &lt;code&gt;Clock&lt;/code&gt; 클래스가 사용됩니다. 이를 통해 로컬 상태 및 수명주기 방법과 같은 추가 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71aa8e04c24836138e98c85afaa8c4097328724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; option means that the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes inside this list &lt;strong&gt;will only &amp;ldquo;reveal&amp;rdquo; their content in the order they appear in the tree &amp;mdash; even if the data for them arrives in a different order&lt;/strong&gt;. &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; has other interesting modes: try changing &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; to &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; or &lt;code&gt;&quot;together&quot;&lt;/code&gt; and see what happens.</source>
          <target state="translated">&lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; 옵션 수단이 가장 가까운 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 노드 목록 안에 &lt;strong&gt;그들 만이 트리에 나타나는 순서대로 콘텐츠를 &quot;공개&quot;것 - 그들에 대한 데이터는 다른 순서로 도착해도&lt;/strong&gt; . &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 에는 다른 흥미로운 모드가 있습니다 : &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; 를 &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;together&quot;&lt;/code&gt; 하고 어떻게되는지보십시오.</target>
        </trans-unit>
        <trans-unit id="107dbf68568c2380480dc053ea5bfc5ee8072aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selected&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; components. You can use it to set whether the component is selected. This is useful for building controlled components.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 속성이 지원하는 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 구성 요소. 컴포넌트를 선택할지 여부를 설정하는 데 사용할 수 있습니다. 제어 된 구성 요소를 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="203b22e021419cba17f499d4cb5572448638f462" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setState&lt;/code&gt; function is used to update the state. It accepts a new state value and enqueues a re-render of the component.</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 를 기능 상태를 업데이트하는 데 사용됩니다. 새 상태 값을 수락하고 구성 요소의 다시 렌더링을 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="357dff3065dc86ea9f744a876b9ab8c50c2ae184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;style&lt;/code&gt; attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM &lt;code&gt;style&lt;/code&gt; JavaScript property, is more efficient, and prevents XSS security holes. For example:</source>
          <target state="translated">&lt;code&gt;style&lt;/code&gt; 속성은 낙타 표기법 특성보다는 CSS 문자열을 자바 스크립트 객체를 받아들입니다. 이는 DOM &lt;code&gt;style&lt;/code&gt; JavaScript 속성 과 일치하며 보다 효율적이며 XSS 보안 허점을 방지합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc5e56642dd04f2aba447e6f924682226c0df90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useTransition&lt;/code&gt; hook returns two values in an array.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 의 후크 배열에서 두 값을 반환한다.</target>
        </trans-unit>
        <trans-unit id="7e1f703ed3eb58b4b8f113ebc5568614f8d4fd8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 특성에 의해지지된다 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 요소. 이를 사용하여 구성 요소의 값을 설정할 수 있습니다. 제어 된 구성 요소를 빌드하는 데 유용합니다. &lt;code&gt;defaultValue&lt;/code&gt; 는 제어되지 않는 동등 항목으로, 처음 마운트 될 때 구성 요소의 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3b3a8f7885d22f578c1eb0f567738d06ed793b6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</target>
        </trans-unit>
        <trans-unit id="3f3679e38fe474c4819ac2803806e3be80472bfc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Effect Hook&lt;/em&gt; lets you perform side effects in function components:</source>
          <target state="translated">&lt;em&gt;효과 후크&lt;/em&gt; 는 기능 구성 요소의 부작용을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a9385e3f6becba3f891272f25765e8d4da17eddd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commit&lt;/strong&gt; phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) React also calls lifecycles like &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt; during this phase.</source>
          <target state="translated">는 &lt;strong&gt;커밋&lt;/strong&gt; 변경을 적용 할 때 반작용 위상이다. React DOM의 경우 React가 DOM 노드를 삽입, 업데이트 및 제거 할 때입니다. React는 이 단계에서 &lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 같은 라이프 사이클도 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c328cac95d0c017f1f700cb3a749d7591b80a4e4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;render&lt;/strong&gt; phase determines what changes need to be made to e.g. the DOM. During this phase, React calls &lt;code&gt;render&lt;/code&gt; and then compares the result to the previous render.</source>
          <target state="translated">&lt;strong&gt;렌더링&lt;/strong&gt; 단계는 DOM을 예하게 할 필요가 변경을 결정합니다. 이 단계에서 React는 &lt;code&gt;render&lt;/code&gt; 호출 한 다음 결과를 이전 렌더와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="874a87db1393bc286872f5465f37d25df7ac77ad" translate="yes" xml:space="preserve">
          <source>The API call duration in this example is randomized. If you keep refreshing it, you will notice that sometimes the posts arrive first, and sometimes the &amp;ldquo;fun facts&amp;rdquo; arrive first.</source>
          <target state="translated">이 예제에서 API 호출 기간은 무작위입니다. 계속 새로 고치면 게시물이 먼저 도착하고 때로는 &quot;재미있는 사실&quot;이 먼저 도착한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f489e901fd1aa4d117bab0e4b0d39576560ff5b" translate="yes" xml:space="preserve">
          <source>The API of ES6 classes is similar to &lt;code&gt;createReactClass()&lt;/code&gt; with a few exceptions.</source>
          <target state="translated">ES6 클래스의 API 는 몇 가지 예외를 제외 하고 &lt;code&gt;createReactClass()&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">구성 요소 수명주기</target>
        </trans-unit>
        <trans-unit id="21bf04493983dc2ff15309868ae4a25193bad67d" translate="yes" xml:space="preserve">
          <source>The Data Flows Down</source>
          <target state="translated">데이터 흐름</target>
        </trans-unit>
        <trans-unit id="616776b2c6e2444aea1e5faa27917853b1c7f97e" translate="yes" xml:space="preserve">
          <source>The Diffing Algorithm</source>
          <target state="translated">확산 알고리즘</target>
        </trans-unit>
        <trans-unit id="c5491cfca6b82c27502e045c3ec98fc3838da8d2" translate="yes" xml:space="preserve">
          <source>The Effect Hook unifies both use cases with a single API.</source>
          <target state="translated">효과 후크는 단일 API로 두 가지 사용 사례를 통합합니다.</target>
        </trans-unit>
        <trans-unit id="1612e741e93d1c692496ad71dfcff5baab42464f" translate="yes" xml:space="preserve">
          <source>The Effect Hook, &lt;code&gt;useEffect&lt;/code&gt;, adds the ability to perform side effects from a function component. It serves the same purpose as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; in React classes, but unified into a single API. (We&amp;rsquo;ll show examples comparing &lt;code&gt;useEffect&lt;/code&gt; to these methods in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">효과 후크 인 &lt;code&gt;useEffect&lt;/code&gt; 는 함수 구성 요소에서 부작용을 수행하는 기능을 추가합니다. React 클래스의 &lt;code&gt;componentDidMount&lt;/code&gt; , &lt;code&gt;componentDidUpdate&lt;/code&gt; 및 &lt;code&gt;componentWillUnmount&lt;/code&gt; 와 동일한 목적을 수행 하지만 단일 API로 통합됩니다. ( &lt;a href=&quot;hooks-effect&quot;&gt;이펙트 훅 사용&lt;/a&gt; 에서 &lt;code&gt;useEffect&lt;/code&gt; 를 이들 방법 과 비교하는 예제를 보여줍니다 .)</target>
        </trans-unit>
        <trans-unit id="124aae01ad58b7e1a4ee8c92047de4631d765919" translate="yes" xml:space="preserve">
          <source>The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostaticmarkup&quot;&gt;&lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt;&lt;/a&gt; would return.</source>
          <target state="translated">이 스트림의 HTML 출력은 &lt;a href=&quot;#rendertostaticmarkup&quot;&gt; &lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt; &lt;/a&gt; 이 반환 하는 것과 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3b58a9fba5b1ef8c2e9715e61380a0bbdc5a87e1" translate="yes" xml:space="preserve">
          <source>The Next channel is a prerelease channel that tracks the master branch of the React repository. We use prereleases in the Next channel as release candidates for the Latest channel. You can think of Next as a superset of Latest that is updated more frequently.</source>
          <target state="translated">다음 채널은 React 저장소의 마스터 분기를 추적하는 시험판 채널입니다. 다음 채널의 시험판을 최신 채널의 릴리스 후보로 사용합니다. 다음을 더 자주 업데이트되는 최신의 상위 집합으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="737fdcd14ec762266f15547050e6808527354f7e" translate="yes" xml:space="preserve">
          <source>The Next channel is designed to support integration testing between React and other projects.</source>
          <target state="translated">다음 채널은 React와 다른 프로젝트 간의 통합 테스트를 지원하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3ed94c8d360c8d9c494a2ca722d37e49ce3e6ed" translate="yes" xml:space="preserve">
          <source>The Paciello Group - Color Contrast Analyzer</source>
          <target state="translated">Paciello Group-색상 대비 분석기</target>
        </trans-unit>
        <trans-unit id="089acaacdb35dc83d6617b2cd65a862a39e1490f" translate="yes" xml:space="preserve">
          <source>The Paciello Group explains accessible names</source>
          <target state="translated">Paciello 그룹은 접근 가능한 이름을 설명합니다</target>
        </trans-unit>
        <trans-unit id="b6ecb4067f5d6149e2462ed2c6f4975edca53137" translate="yes" xml:space="preserve">
          <source>The Power Of Not Mutating Data</source>
          <target state="translated">데이터를 변경하지 않는 힘</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="892213a47fde12815f3b55308a07c21a28514331" translate="yes" xml:space="preserve">
          <source>The Provider component accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</source>
          <target state="translated">The Provider component accepts a &lt;code&gt;value&lt;/code&gt; prop to be passed to consuming components that are descendants of this Provider. One Provider can be connected to many consumers. Providers can be nested to override values deeper within the tree.</target>
        </trans-unit>
        <trans-unit id="26e24b6b93e7419bc0e50a40347349c779318865" translate="yes" xml:space="preserve">
          <source>The React documentation assumes some familiarity with programming in the JavaScript language. You don&amp;rsquo;t have to be an expert, but it&amp;rsquo;s harder to learn both React and JavaScript at the same time.</source>
          <target state="translated">React 문서는 JavaScript 언어로 프로그래밍하는 데 어느 정도 익숙하다고 가정합니다. 전문가 일 필요는 없지만 React와 JavaScript를 동시에 배우기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="0fd3ac585dc50ef7294c9de3e83e35480b26454b" translate="yes" xml:space="preserve">
          <source>The React team primarily recommends these solutions:</source>
          <target state="translated">React 팀은 주로 다음 솔루션을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="ba2f4b1bedd474c3014f164a2122303c060ccb81" translate="yes" xml:space="preserve">
          <source>The Receded state doesn&amp;rsquo;t feel very nice because it hides existing content.</source>
          <target state="translated">Receded 상태는 기존 내용을 숨기므로 기분이 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f929f091bc2ce827e8bf4c5ed48e578b25c2e1c" translate="yes" xml:space="preserve">
          <source>The Three Steps</source>
          <target state="translated">세 단계</target>
        </trans-unit>
        <trans-unit id="e6a086f204eb46311763e005551391b5b863e8b8" translate="yes" xml:space="preserve">
          <source>The W3C demonstrates user notifications</source>
          <target state="translated">W3C는 사용자 알림을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="a94514ea6fcc374a0e4ec5a9365c3dabf4e39fbb" translate="yes" xml:space="preserve">
          <source>The W3C shows us how to label elements</source>
          <target state="translated">W3C는 요소를 라벨링하는 방법을 보여줍니다</target>
        </trans-unit>
        <trans-unit id="94dcda409aa812a420ab1cfa14badcf0b13d6d3b" translate="yes" xml:space="preserve">
          <source>The above two components are equivalent from React&amp;rsquo;s point of view.</source>
          <target state="translated">위의 두 구성 요소는 React의 관점과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="37cd269b859b44611e84ee5db5c7b9f522b36e09" translate="yes" xml:space="preserve">
          <source>The above two lines are equivalent, and use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">위의 두 줄은 동일하며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수&lt;/a&gt; 와 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt; &lt;code&gt;Function.prototype.bind&lt;/code&gt; 를&lt;/a&gt; 각각 사용합니다.</target>
        </trans-unit>
        <trans-unit id="215acedeed5a2bd97d915656e07e386e37862aa8" translate="yes" xml:space="preserve">
          <source>The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven&amp;rsquo;t found this to be an issue.</source>
          <target state="translated">알고리즘은 다른 구성 요소 유형의 서브 트리를 일치시키지 않습니다. 출력이 매우 유사한 두 구성 요소 유형이 번갈아 표시되는 경우 동일한 유형으로 만들 수 있습니다. 실제로, 우리는 이것이 문제가되지 않았다.</target>
        </trans-unit>
        <trans-unit id="d4d34ce90ceca5ceb82456075b266e3c7316fc14" translate="yes" xml:space="preserve">
          <source>The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It&amp;rsquo;s especially regrettable if the original fix is for a bug that is rarely encountered in practice.</source>
          <target state="translated">대답은 React (또는 다른 소프트웨어)를 변경하면 예기치 않은 방식으로 침입 할 위험이 있다는 것입니다. 하나의 버그를 수정하는 패치 릴리스에서 실수로 다른 버그가 발생하는 시나리오를 상상해보십시오. 이는 개발자에게 혼란을 줄뿐만 아니라 향후 패치 릴리스에 대한 자신감을 손상시킵니다. 원래 수정이 실제로 거의 발생하지 않는 버그에 대한 것이면 유감입니다.</target>
        </trans-unit>
        <trans-unit id="e635eec21597077475b644c681e965353535e3c4" translate="yes" xml:space="preserve">
          <source>The answer to this problem &lt;strong&gt;is to split the state in two parts:&lt;/strong&gt; a &amp;ldquo;high priority&amp;rdquo; part that updates immediately, and a &amp;ldquo;low priority&amp;rdquo; part that may wait for a transition.</source>
          <target state="translated">이 문제에 대한 답 &lt;strong&gt;은 상태를&lt;/strong&gt; 즉시 업데이트하는 &quot;높은 우선 순위&quot;부분과 전환을 기다릴 수있는 &quot;낮은 우선 순위&quot;부분 &lt;strong&gt;으로 두 부분으로 나누는 것&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7a38c075e6a3910c420e7a01266e74d7df6ccf8" translate="yes" xml:space="preserve">
          <source>The approach above requires your React components to be aware of the Backbone models and collections. If you later plan to migrate to another data management solution, you might want to concentrate the knowledge about Backbone in as few parts of the code as possible.</source>
          <target state="translated">위의 방법을 사용하려면 React 컴포넌트가 백본 모델 및 컬렉션을 인식해야합니다. 나중에 다른 데이터 관리 솔루션으로 마이그레이션하려는 경우 가능한 적은 코드 부분으로 Backbone에 대한 지식을 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20f69e03e2db102e3ca9bf7104bb1da944732c2" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the callback. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">종속성 배열은 콜백에 인수로 전달되지 않습니다. 그러나 개념적으로는 이것이 나타내는 것입니다. 콜백 내에서 참조되는 모든 값은 dependencies 배열에도 나타나야합니다. 앞으로는 충분히 고급 컴파일러가이 배열을 자동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2478d3374b94309b968843a77f28e2fb9c9b3b9" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the effect function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">종속성 배열은 효과 함수에 인수로 전달되지 않습니다. 그러나 개념적으로는 그것이 나타내는 것입니다. 효과 함수 내에서 참조 된 모든 값은 dependencies 배열에도 나타나야합니다. 앞으로는 충분히 고급 컴파일러가이 배열을 자동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="029b5464ab1167d56107b8168f06ebc2ea8d2817" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="translated">종속성 배열은 함수에 인수로 전달되지 않습니다. 그러나 개념적으로는 그것이 나타내는 것입니다. 함수 내에서 참조되는 모든 값은 dependencies 배열에도 나타나야합니다. 앞으로는 충분히 고급 컴파일러가이 배열을 자동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f143982715c022eb1b0b1e351548f58f45f5da7" translate="yes" xml:space="preserve">
          <source>The best way to introduce code-splitting into your app is through the dynamic &lt;code&gt;import()&lt;/code&gt; syntax.</source>
          <target state="translated">앱에 코드 분할을 도입하는 가장 좋은 방법은 동적 &lt;code&gt;import()&lt;/code&gt; 구문을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71f1b3c82a840e802e29fee64e41fc0cc4d94466" translate="yes" xml:space="preserve">
          <source>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</source>
          <target state="translated">키를 선택하는 가장 좋은 방법은 형제 중에서 목록 항목을 고유하게 식별하는 문자열을 사용하는 것입니다. 대부분의 경우 데이터의 ID를 키로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ef94bfdedef023164021f6b1e4be76fc19c50903" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;act()&lt;/code&gt; will also flush the effects inside of them.</source>
          <target state="translated">&lt;code&gt;act()&lt;/code&gt; 호출 은 그 내부의 효과를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="556c1bcef07eebbaa4e004179e9cfd3eeb9f0fd9" translate="yes" xml:space="preserve">
          <source>The children test instances of this test instance.</source>
          <target state="translated">자식은이 테스트 인스턴스의 인스턴스를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c6ef3d6c1361f3d575ce5bfd7aa23746e033615f" translate="yes" xml:space="preserve">
          <source>The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the &lt;strong&gt;previous effect is cleaned up before executing the next effect&lt;/strong&gt;. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.</source>
          <target state="translated">메모리 누수를 방지하기 위해 UI에서 구성 요소를 제거하기 전에 정리 기능이 실행됩니다. 또한 구성 요소가 일반적으로하는 것처럼 여러 번 렌더링되는 경우 &lt;strong&gt;다음 효과를 실행하기 전에 이전 효과가 정리됩니다&lt;/strong&gt; . 이 예에서 이것은 모든 업데이트에 대해 새 구독이 생성됨을 의미합니다. 모든 업데이트에 영향을주지 않으려면 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a0d7a14266fbc4abca5b3a288ac51756a81b9c9a" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming async mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="translated">커밋 단계는 일반적으로 매우 빠르지 만 렌더링 속도가 느려질 수 있습니다. 이러한 이유로 다가오는 비동기 모드 (기본적으로 아직 활성화되어 있지 않음)는 렌더링 작업을 여러 조각으로 나눠 브라우저를 차단하지 않기 위해 작업을 일시 중지하고 다시 시작합니다. 이것은 React가 커밋하기 전에 렌더 단계 수명주기를 두 번 이상 호출하거나 전혀 커밋하지 않고 호출 할 수 있음을 의미합니다 (오류 또는 높은 우선 순위 중단으로 인해).</target>
        </trans-unit>
        <trans-unit id="4da89e96ab9a876de60be2bee912c245e63ac6d3" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming concurrent mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="translated">The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming concurrent mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</target>
        </trans-unit>
        <trans-unit id="35d925f6ec4f8cdb5a9258d473e99341d40e0c29" translate="yes" xml:space="preserve">
          <source>The common owner component is &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">공통 소유자 컴포넌트는 &lt;code&gt;FilterableProductTable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a63c154dead70a08be6cc8e31aeac4618b4d14ed" translate="yes" xml:space="preserve">
          <source>The compiler is of no help to us until we tell it what to do. In TypeScript, these rules are defined in a special file called &lt;code&gt;tsconfig.json&lt;/code&gt;. To generate this file:</source>
          <target state="translated">컴파일러는 우리가 무엇을해야 할지를 알려줄 때까지 우리에게 도움이되지 않습니다. TypeScript에서 이러한 규칙은 &lt;code&gt;tsconfig.json&lt;/code&gt; 이라는 특수 파일에 정의되어 있습니다. 이 파일을 생성하려면</target>
        </trans-unit>
        <trans-unit id="121cd37d21dcf9844e0b109d86b1a674e3ab8297" translate="yes" xml:space="preserve">
          <source>The complete implementation of the &lt;code&gt;Chosen&lt;/code&gt; component looks like this:</source>
          <target state="translated">&lt;code&gt;Chosen&lt;/code&gt; 구성 요소 의 전체 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7fdbd63cb007ae3a70e4c0ab3cbfed9aceb771a" translate="yes" xml:space="preserve">
          <source>The component below demonstrates how to make an AJAX call in &lt;code&gt;componentDidMount&lt;/code&gt; to populate local component state.</source>
          <target state="translated">아래 컴포넌트는 &lt;code&gt;componentDidMount&lt;/code&gt; 에서 AJAX 호출을 수행 하여 로컬 컴포넌트 상태를 채우는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1198438307a24068ab1bba755a37a1b96d2a22fd" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function.</source>
          <target state="translated">The component can either be provided as a string, as a subclass of &lt;code&gt;React.Component&lt;/code&gt; , or a plain function.</target>
        </trans-unit>
        <trans-unit id="da6ce7faf44f37b3dd8abfc2e0722acdb78a9da3" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, or as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function for stateless components.</source>
          <target state="translated">컴포넌트는 문자열 또는 &lt;code&gt;React.Component&lt;/code&gt; 의 서브 클래스 또는 상태 비 저장 컴포넌트의 일반 함수 로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7be5cec66fa7af4738a87fd4dc3bac4a3b9e7f65" translate="yes" xml:space="preserve">
          <source>The component instance corresponding to this test instance. It is only available for class components, as function components don&amp;rsquo;t have instances. It matches the &lt;code&gt;this&lt;/code&gt; value inside the given component.</source>
          <target state="translated">이 테스트 인스턴스에 해당하는 컴포넌트 인스턴스 함수 구성 요소에는 인스턴스가 없으므로 클래스 구성 요소에서만 사용할 수 있습니다. 주어진 구성 요소 내 &lt;code&gt;this&lt;/code&gt; 값 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1c518ce84f1f2ec0768b9431ff8843a33c87e2e0" translate="yes" xml:space="preserve">
          <source>The component type corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; component has a type of &lt;code&gt;Button&lt;/code&gt;.</source>
          <target state="translated">이 테스트 인스턴스에 해당하는 구성 요소 유형입니다. 예를 들어 &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; 구성 요소의 유형은 &lt;code&gt;Button&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a0029f3f238b96fbe9f5f708c5daccae03c6952" translate="yes" xml:space="preserve">
          <source>The constructor for a React component is called before it is mounted. When implementing the constructor for a &lt;code&gt;React.Component&lt;/code&gt; subclass, you should call &lt;code&gt;super(props)&lt;/code&gt; before any other statement. Otherwise, &lt;code&gt;this.props&lt;/code&gt; will be undefined in the constructor, which can lead to bugs.</source>
          <target state="translated">React 컴포넌트의 생성자는 마운트되기 전에 호출됩니다. &lt;code&gt;React.Component&lt;/code&gt; 서브 클래스에 대한 생성자를 구현할 때 다른 명령문보다 먼저 &lt;code&gt;super(props)&lt;/code&gt; 를 호출해야 합니다. 그렇지 않으면 &lt;code&gt;this.props&lt;/code&gt; 가 생성자에서 정의되지 않아 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c0031304d2df9c111be15322f423f7290b0447" translate="yes" xml:space="preserve">
          <source>The container components created by HOCs show up in the &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; like any other component. To ease debugging, choose a display name that communicates that it&amp;rsquo;s the result of a HOC.</source>
          <target state="translated">HOC가 만든 컨테이너 구성 요소는 다른 구성 요소와 마찬가지로 &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; 에 표시됩니다 . 디버깅을 쉽게하려면 HOC의 결과임을 알리는 표시 이름을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="f005497689e0366001c3fb7c5e6cf6a2f89e046f" translate="yes" xml:space="preserve">
          <source>The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.</source>
          <target state="translated">효과의 기본 동작은 렌더링이 완료 될 때마다 효과를 발생시키는 것입니다. 이렇게하면 종속성 중 하나가 변경되면 항상 효과가 다시 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="a9abe7524edac0d7bf58996697456382aebf41d4" translate="yes" xml:space="preserve">
          <source>The definition of a &amp;ldquo;feature&amp;rdquo; is not universal, and it is up to you to choose the granularity. If you can&amp;rsquo;t come up with a list of top-level folders, you can ask the users of your product what major parts it consists of, and use their mental model as a blueprint.</source>
          <target state="translated">&amp;ldquo;기능&amp;rdquo;의 정의는 보편적이지 않으며, 세분성을 선택하는 것은 사용자의 책임입니다. 최상위 폴더 목록을 만들 수 없으면 제품 사용자에게 구성 요소의 주요 부분을 물어보고 정신 모델을 청사진으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727f035106e7c393c4cb029a45dec8da874d352f" translate="yes" xml:space="preserve">
          <source>The degree of change between the most recent Next release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, &lt;strong&gt;the Next channel does not conform to semantic versioning.&lt;/strong&gt; You should expect occasional breaking changes between successive releases in the Next channel.</source>
          <target state="translated">가장 최근의 다음 릴리스와 가장 최근의 최신 릴리스 사이의 변경 정도는 두 개의 작은 semver 릴리스 사이에서 볼 수있는 것과 거의 같습니다. 그러나 &lt;strong&gt;다음 채널은 시맨틱 버전 관리를 따르지 않습니다. &lt;/strong&gt;다음 채널의 후속 릴리스간에 간헐적 인 변경이있을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="11c828ed161f8e904365be750c1b6b190b0b36c6" translate="yes" xml:space="preserve">
          <source>The developer can hint at which child elements may be stable across different renders with a &lt;code&gt;key&lt;/code&gt; prop.</source>
          <target state="translated">개발자는 &lt;code&gt;key&lt;/code&gt; 소품을 사용하여 다른 렌더에서 어떤 하위 요소가 안정적 일지를 암시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90fce0d3e59b886792d5aea4491610c01d3638de" translate="yes" xml:space="preserve">
          <source>The easiest way to avoid conflicts is to prevent the React component from updating. You can do this by rendering elements that React has no reason to update, like an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">충돌을 피하는 가장 쉬운 방법은 React 컴포넌트가 업데이트되지 않도록하는 것입니다. 빈 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 처럼 React가 업데이트 할 이유가없는 요소를 렌더링하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="039378bb9c3350b891bbb97f95519708b2e90b22" translate="yes" xml:space="preserve">
          <source>The empty set of dependencies, &lt;code&gt;[]&lt;/code&gt;, means that the effect will only run once when the component mounts, and not on every re-render. The problem is that inside the &lt;code&gt;setInterval&lt;/code&gt; callback, the value of &lt;code&gt;count&lt;/code&gt; does not change, because we&amp;rsquo;ve created a closure with the value of &lt;code&gt;count&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; as it was when the effect callback ran. Every second, this callback then calls &lt;code&gt;setCount(0 + 1)&lt;/code&gt;, so the count never goes above 1.</source>
          <target state="translated">빈 종속성 집합 &lt;code&gt;[]&lt;/code&gt; 은 구성 요소가 마운트 될 때 효과가 한 번만 실행되며 모든 렌더링에 적용되지는 않음을 의미합니다. 문제는 &lt;code&gt;setInterval&lt;/code&gt; 콜백 내에서 &lt;code&gt;count&lt;/code&gt; 의 값이 변경되지 않는다는 것입니다. 우리는 effect 콜백이 실행될 때와 같이 &lt;code&gt;count&lt;/code&gt; 값이 &lt;code&gt;0&lt;/code&gt; 으로 설정된 클로저를 만들었 기 때문 입니다. 이 콜백은 매초 &lt;code&gt;setCount(0 + 1)&lt;/code&gt; 을 호출 하므로 카운트는 1을 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7d18e24fe1c347ef1b3c94e07922d8cc04f6942" translate="yes" xml:space="preserve">
          <source>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append &lt;code&gt;Capture&lt;/code&gt; to the event name; for example, instead of using &lt;code&gt;onClick&lt;/code&gt;, you would use &lt;code&gt;onClickCapture&lt;/code&gt; to handle the click event in the capture phase.</source>
          <target state="translated">아래의 이벤트 핸들러는 버블 링 단계의 이벤트에 의해 트리거됩니다. 캡처 단계에 대한 이벤트 핸들러를 등록하려면 이벤트 이름에 &lt;code&gt;Capture&lt;/code&gt; 를 추가 하십시오 . 예를 들어 &lt;code&gt;onClick&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;onClickCapture&lt;/code&gt; 를 사용 하여 캡처 단계에서 클릭 이벤트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="35470d31aa9c663f5b39b9e3bf6a8825cba5c87e" translate="yes" xml:space="preserve">
          <source>The event sequence now becomes like this:</source>
          <target state="translated">이제 이벤트 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2feb552bc0b04f016976d27749dad0528ebe0952" translate="yes" xml:space="preserve">
          <source>The exact way to do this depends on the tools you use to compile JavaScript.</source>
          <target state="translated">이를 수행하는 정확한 방법은 JavaScript를 컴파일하는 데 사용하는 도구에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="778ba0676987a60a9e2c8429a7aa41f2c83bff58" translate="yes" xml:space="preserve">
          <source>The example API returns a JSON object like this:</source>
          <target state="translated">예제 API는 다음과 같은 JSON 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d6f789ab2260e267676497b52bf0d82f9dfacb6" translate="yes" xml:space="preserve">
          <source>The example below implements a common pattern: using the &lt;code&gt;ref&lt;/code&gt; callback to store a reference to a DOM node in an instance property.</source>
          <target state="translated">아래 예제는 일반적인 패턴을 구현합니다. &lt;code&gt;ref&lt;/code&gt; 콜백을 사용하여 인스턴스 속성에 DOM 노드에 대한 참조를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5f9470c3b84dc932fd588852cc8390acf73521e5" translate="yes" xml:space="preserve">
          <source>The examples below demonstrate the differences.</source>
          <target state="translated">아래 예제는 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8caf0302f63f1367b6cfadfc61944e1907afd828" translate="yes" xml:space="preserve">
          <source>The examples below have been updated to use the &lt;code&gt;React.createRef()&lt;/code&gt; API introduced in React 16.3. If you are using an earlier release of React, we recommend using &lt;a href=&quot;#callback-refs&quot;&gt;callback refs&lt;/a&gt; instead.</source>
          <target state="translated">아래 예제 는 React 16.3에 도입 된 &lt;code&gt;React.createRef()&lt;/code&gt; API 를 사용하도록 업데이트되었습니다 . 이전 릴리스의 React를 사용하는 경우 &lt;a href=&quot;#callback-refs&quot;&gt;콜백 참조를&lt;/a&gt; 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="455e064548d40d5ab668249f72a1cd4f0163750c" translate="yes" xml:space="preserve">
          <source>The file input Tag</source>
          <target state="translated">파일 입력 태그</target>
        </trans-unit>
        <trans-unit id="eb4803464d7b9f0c8c680d9449f96660c199ce10" translate="yes" xml:space="preserve">
          <source>The filtered list of products</source>
          <target state="translated">필터링 된 제품 목록</target>
        </trans-unit>
        <trans-unit id="782d3e0cd7b112da27839308868fb0a14dcc498e" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;child&lt;/code&gt;) is any &lt;a href=&quot;react-component#render&quot;&gt;renderable React child&lt;/a&gt;, such as an element, string, or fragment. The second argument (&lt;code&gt;container&lt;/code&gt;) is a DOM element.</source>
          <target state="translated">첫 번째 인수 ( &lt;code&gt;child&lt;/code&gt; )는 요소, 문자열 또는 조각과 같은 &lt;a href=&quot;react-component#render&quot;&gt;렌더링 가능한 React child&lt;/a&gt; 입니다. 두 번째 인수 ( &lt;code&gt;container&lt;/code&gt; )는 DOM 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b8c5930c6860f5766726b86234129269ec281ca2" translate="yes" xml:space="preserve">
          <source>The first argument is an &lt;code&gt;updater&lt;/code&gt; function with the signature:</source>
          <target state="translated">첫 번째 인수는 서명 이있는 &lt;code&gt;updater&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="bb81ac8fd7276dc657a1d763df0cbcb0143cbe4c" translate="yes" xml:space="preserve">
          <source>The first parameter is the wrapped component. The second parameter retrieves the data we&amp;rsquo;re interested in, given a &lt;code&gt;DataSource&lt;/code&gt; and the current props.</source>
          <target state="translated">첫 번째 매개 변수는 랩핑 된 구성 요소입니다. 두 번째 매개 변수는 &lt;code&gt;DataSource&lt;/code&gt; 와 현재 소품이 주어지면 관심있는 데이터를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="003f348ba9fdbe52c6f6090cd3f9396dc2b157db" translate="yes" xml:space="preserve">
          <source>The first part of a JSX tag determines the type of the React element.</source>
          <target state="translated">JSX 태그의 첫 번째 부분은 React 요소의 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="917597890dc6b95bb360440dd8da1fd3c7810b0f" translate="yes" xml:space="preserve">
          <source>The first thing you&amp;rsquo;ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you&amp;rsquo;re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</source>
          <target state="translated">가장 먼저해야 할 일은 모의 모든 구성 요소 (및 하위 구성 요소) 주위에 상자를 그려 모든 이름을 지정하는 것입니다. 디자이너와 함께 작업하는 경우 이미이 작업을 수행했을 수도 있으므로 대화하십시오! Photoshop 레이어 이름은 React 구성 요소의 이름이 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="58af51c7a5ea330490a54c507bc24a5957ec1db5" translate="yes" xml:space="preserve">
          <source>The first two tags load React. The third one will load your component code.</source>
          <target state="translated">처음 두 태그는 React를로드합니다. 세 번째는 컴포넌트 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="63d7151a3f248b4aaf387f1b0df617c10a48c0cc" translate="yes" xml:space="preserve">
          <source>The following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don&amp;rsquo;t stress about learning them up front.</source>
          <target state="translated">다음 훅은 이전 섹션의 기본 훅의 변형이거나 특정 경우에만 필요합니다. 미리 배우는 것에 대해 강조하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e308e9b3043ec57ac18e0b3c611264d1750d56e5" translate="yes" xml:space="preserve">
          <source>The following WCAG checklists provide an overview:</source>
          <target state="translated">다음 WCAG 체크리스트는 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="694131f03d1bab80a6c7d4c80f4b1b3a3241dee3" translate="yes" xml:space="preserve">
          <source>The following code demonstrates this. (The input is locked at first but becomes editable after a short delay.)</source>
          <target state="translated">다음 코드는 이것을 보여줍니다. 입력은 처음에는 잠기지 만 잠시 후에 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6211b0539ce28a1c45c57e19f644594cc9415732" translate="yes" xml:space="preserve">
          <source>The following methods can be used in both the server and browser environments:</source>
          <target state="translated">서버 및 브라우저 환경 모두에서 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e58ff833910cac432aba7935a817cbc0b058b56" translate="yes" xml:space="preserve">
          <source>The following resources show us how to do this:</source>
          <target state="translated">다음 리소스는이 작업을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="98a6e91ed5c938365a3d023a4ee79e40777157be" translate="yes" xml:space="preserve">
          <source>The following toolchains offer more flexibility and choice. We recommend them to more experienced users:</source>
          <target state="translated">다음 툴체인은 더 ​​많은 유연성과 선택을 제공합니다. 보다 숙련 된 사용자에게 권장합니다.</target>
        </trans-unit>
        <trans-unit id="e92b55a478f169e90eff18e9f5c9f441b0eac9b2" translate="yes" xml:space="preserve">
          <source>The granularity of error boundaries is up to you. You may wrap top-level route components to display a &amp;ldquo;Something went wrong&amp;rdquo; message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.</source>
          <target state="translated">오류 경계의 세분성은 사용자에게 달려 있습니다. 서버 측 프레임 워크가 종종 충돌을 처리하는 것처럼 최상위 경로 구성 요소를 래핑하여 &quot;문제가 발생했습니다&quot;메시지를 사용자에게 표시 할 수 있습니다. 개별 위젯을 오류 경계로 감싸서 나머지 애플리케이션이 충돌하지 않도록 보호 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a6247bb2d42aa3e3342c1d43e5c94a83c8139f8" translate="yes" xml:space="preserve">
          <source>The inputs stay in sync because their values are computed from the same state:</source>
          <target state="translated">입력 값이 동일한 상태에서 계산되므로 입력이 동기화 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7f76c6b2c5bda1e950d51d378999359849f255f5" translate="yes" xml:space="preserve">
          <source>The keyboard</source>
          <target state="translated">키보드</target>
        </trans-unit>
        <trans-unit id="0054077e1ddf463832b68523a2ad7ad7cfc55cae" translate="yes" xml:space="preserve">
          <source>The last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn&amp;rsquo;t have to update the DOM.</source>
          <target state="translated">마지막으로 흥미로운 사례는 C8입니다. React는이 컴포넌트를 렌더링해야했지만 반환 된 React 요소는 이전에 렌더링 된 요소와 같으므로 DOM을 업데이트 할 필요가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="650917a3548229098547ab66dc585a177cef3daa" translate="yes" xml:space="preserve">
          <source>The lazy component should then be rendered inside a &lt;code&gt;Suspense&lt;/code&gt; component, which allows us to show some fallback content (such as a loading indicator) while we&amp;rsquo;re waiting for the lazy component to load.</source>
          <target state="translated">게으른 구성 요소는 &lt;code&gt;Suspense&lt;/code&gt; 구성 요소 안에 렌더링되어야하며 , 이로 인해 지연 구성 요소가로드되기를 기다리는 동안 로딩 표시와 같은 대체 콘텐츠를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20ca449aab3a55095a75facca274bd40f837461" translate="yes" xml:space="preserve">
          <source>The legacy context API is error-prone, and will be removed in a future major version. It still works for all 16.x releases but will show this warning message in strict mode:</source>
          <target state="translated">레거시 컨텍스트 API는 오류가 발생하기 쉬우 며 향후 주요 버전에서 제거 될 예정입니다. 여전히 모든 16.x 릴리스에서 작동하지만이 경고 메시지는 엄격 모드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="da3bba855b5bdb90a044ae1549472e5dd22f334f" translate="yes" xml:space="preserve">
          <source>The legacy context API will be removed in a future major version. Use the &lt;a href=&quot;context&quot;&gt;new context API&lt;/a&gt; introduced with version 16.3. The legacy API will continue working for all 16.x releases.</source>
          <target state="translated">레거시 컨텍스트 API는 향후 주요 버전에서 제거 될 예정입니다. 버전 16.3에 도입 된 &lt;a href=&quot;context&quot;&gt;새로운 컨텍스트 API를&lt;/a&gt; 사용하십시오 . 레거시 API는 모든 16.x 릴리스에서 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="81ccef2b9339e6d81469f85f907bf4389c10515e" translate="yes" xml:space="preserve">
          <source>The lifecycle methods below are marked as &amp;ldquo;legacy&amp;rdquo;. They still work, but we don&amp;rsquo;t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="translated">아래의 수명주기 방법은 &quot;레거시&quot;로 표시되어 있습니다. 여전히 작동하지만 새 코드에서 사용하지 않는 것이 좋습니다. &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;이 블로그 게시물&lt;/a&gt; 에서 레거시 수명주기 방법에서 마이그레이션하는 방법에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15cd4ff64ab80f5a2212f2df0011a9c029b32518" translate="yes" xml:space="preserve">
          <source>The majority of websites aren&amp;rsquo;t, and don&amp;rsquo;t need to be, single-page apps. With &lt;strong&gt;a few lines of code and no build tooling&lt;/strong&gt;, try React in a small part of your website. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">대부분의 웹 사이트는 단일 페이지 앱일 필요는 없으며 반드시 그럴 필요는 없습니다. 으로 &lt;strong&gt;코드없이 빌드 도구의 몇 줄의&lt;/strong&gt; 시도 귀하의 웹 사이트의 작은 부분에 반응한다. 그런 다음 점진적으로 그 존재를 확장하거나 동적 위젯 몇 개에 포함되도록 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f4513e10a025e9de18b63415157d7cf17b1b0f" translate="yes" xml:space="preserve">
          <source>The merging is shallow, so &lt;code&gt;this.setState({comments})&lt;/code&gt; leaves &lt;code&gt;this.state.posts&lt;/code&gt; intact, but completely replaces &lt;code&gt;this.state.comments&lt;/code&gt;.</source>
          <target state="translated">병합이 얕으므로 &lt;code&gt;this.setState({comments})&lt;/code&gt; 는 &lt;code&gt;this.state.posts&lt;/code&gt; 를 그대로 유지하지만 &lt;code&gt;this.state.comments&lt;/code&gt; 를 완전히 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="0dcbdabac908b8f2fc6e0ffecf4fbddf1e58850e" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="translated">이 섹션의 방법은 일반적이지 않은 사용 사례에 해당합니다. 한 번에 편리하지만 대부분의 구성 요소가 필요하지 않을 수 있습니다. &lt;strong&gt;맨 위의 &quot;일반적인 수명주기가 덜 표시됨&quot;확인란을 클릭하면 &lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;이 수명주기 다이어그램&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 에서 아래의 대부분의 방법을 볼 수 있습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a5a58960afc3a46f1622f9179fa142d4ab56648" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="translated">The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8fed08012b5625fe563e0b37a0ff08e44a38cb3" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">이 섹션의 방법은 React 컴포넌트를 생성하는 대부분의 사용 사례를 다룹니다. &lt;strong&gt;시각적 참조는 &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;이 라이프 사이클 다이어그램을&lt;/a&gt; 확인하십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4ced5c859243ea7f8a1e5d64710e4914cd027be" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32e0c3ff6eb1184d53d22e7e647c950849c06e4c" translate="yes" xml:space="preserve">
          <source>The most common signature for HOCs looks like this:</source>
          <target state="translated">HOC의 가장 일반적인 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01e425821d940bee1f75b9701bf9cae45803a7fb" translate="yes" xml:space="preserve">
          <source>The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named &lt;code&gt;withSubscription&lt;/code&gt;, and the wrapped component&amp;rsquo;s display name is &lt;code&gt;CommentList&lt;/code&gt;, use the display name &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt;:</source>
          <target state="translated">가장 일반적인 기술은 랩핑 된 구성 요소의 표시 이름을 랩핑하는 것입니다. 따라서 상위 컴포넌트의 이름이 &lt;code&gt;withSubscription&lt;/code&gt; 이고 랩된 컴포넌트의 표시 이름이 &lt;code&gt;CommentList&lt;/code&gt; 인 경우 표시 이름 &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d772efa9541ff8cc5757d21265f1b50c9976f1e3" translate="yes" xml:space="preserve">
          <source>The most important difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; is that &lt;code&gt;props&lt;/code&gt; are passed from a parent component, but &lt;code&gt;state&lt;/code&gt; is managed by the component itself. A component cannot change its &lt;code&gt;props&lt;/code&gt;, but it can change its &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">가장 중요한 차이점 &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;props&lt;/code&gt; 이다 &lt;code&gt;props&lt;/code&gt; 부모 구성 요소에서 전달되는,하지만 &lt;code&gt;state&lt;/code&gt; 구성 요소 자체에 의해 관리됩니다. 구성 요소는 &lt;code&gt;props&lt;/code&gt; 변경할 수 없지만 &lt;code&gt;state&lt;/code&gt; 는 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5da4bb3efd80371c6e943cdabe174c4c7232ece8" translate="yes" xml:space="preserve">
          <source>The most important things we learned so far are:</source>
          <target state="translated">우리가 지금까지 배운 가장 중요한 것은 :</target>
        </trans-unit>
        <trans-unit id="0f3841fcee35f1e3e8f100fa6282724ddf54ce64" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;act&lt;/code&gt; comes from the &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; pattern.</source>
          <target state="translated">&lt;code&gt;act&lt;/code&gt; 이름 은 &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; 패턴 에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="5264af61d93942a8eba8291eaa575dd302096081" translate="yes" xml:space="preserve">
          <source>The names on the left aren&amp;rsquo;t a part of the React API. You can name your own state variables:</source>
          <target state="translated">왼쪽의 이름은 React API의 일부가 아닙니다. 자신의 상태 변수 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a5345a128b80e8d405e799312115fb3b799e29d" translate="yes" xml:space="preserve">
          <source>The need to manage local state with a reducer in a complex component is common enough that we&amp;rsquo;ve built the &lt;code&gt;useReducer&lt;/code&gt; Hook right into React. You&amp;rsquo;ll find it together with other built-in Hooks in the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt;.</source>
          <target state="translated">복잡한 컴포넌트에서 리듀서를 사용하여 로컬 상태를 관리해야 할 필요성은 &lt;code&gt;useReducer&lt;/code&gt; Hook를 React에 바로 구축하기에 충분합니다 . &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API 참조 서&lt;/a&gt; 에서 다른 내장 후크와 함께 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f051d87ee25566d70564d3a58864ab99806f58c" translate="yes" xml:space="preserve">
          <source>The only argument to &lt;code&gt;useState&lt;/code&gt; is the initial state. In the example above, it is &lt;code&gt;0&lt;/code&gt; because our counter starts from zero. Note that unlike &lt;code&gt;this.state&lt;/code&gt;, the state here doesn&amp;rsquo;t have to be an object &amp;mdash; although it can be if you want. The initial state argument is only used during the first render.</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; 에 대한 유일한 인수 는 초기 상태입니다. 위의 예 에서 카운터 는 &lt;code&gt;0&lt;/code&gt; 부터 시작하기 때문에 0입니다. &lt;code&gt;this.state&lt;/code&gt; 와 달리 여기서 상태는 객체 일 필요는 없지만 원하는 경우에도 가능합니다. 초기 상태 인수는 첫 번째 렌더링 중에 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b534a04aeb4f463839ecea6daf302d82f8c6468e" translate="yes" xml:space="preserve">
          <source>The only difference between these two examples is that the first uses regular &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;s, but the second one uses our custom &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">이 두 예제의 유일한 차이점은 첫 번째는 일반 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 을 사용하고 두 번째는 &lt;code&gt;useTransition&lt;/code&gt; 과 함께 사용자 정의 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 구성 요소를 사용 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="489679e8916d61c0a6ff61f577314e68b03922ae" translate="yes" xml:space="preserve">
          <source>The only method you &lt;em&gt;must&lt;/em&gt; define in a &lt;code&gt;React.Component&lt;/code&gt; subclass is called &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;. All the other methods described on this page are optional.</source>
          <target state="translated">&lt;code&gt;React.Component&lt;/code&gt; 서브 클래스 에서 정의 &lt;em&gt;해야하는&lt;/em&gt; 유일한 메소드 는 &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 입니다. 이 페이지에 설명 된 다른 모든 방법은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="06b09efecaccac65bc2017106119837f0fe67989" translate="yes" xml:space="preserve">
          <source>The only place where you can assign &lt;code&gt;this.state&lt;/code&gt; is the constructor.</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; 를 지정할 수있는 유일한 곳 은 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="c3c884b2822ecc82667f90bc15a105ccc9d50096" translate="yes" xml:space="preserve">
          <source>The original list of products</source>
          <target state="translated">원래 제품 목록</target>
        </trans-unit>
        <trans-unit id="4ea78638cae1dd6caebc10f10aa13e863c90b117" translate="yes" xml:space="preserve">
          <source>The original list of products is passed in as props, so that&amp;rsquo;s not state. The search text and the checkbox seem to be state since they change over time and can&amp;rsquo;t be computed from anything. And finally, the filtered list of products isn&amp;rsquo;t state because it can be computed by combining the original list of products with the search text and value of the checkbox.</source>
          <target state="translated">제품의 원래 목록은 소품으로 전달되므로 상태가 아닙니다. 검색 텍스트와 확인란은 시간이 지남에 따라 변경되어 아무 것도 계산할 수 없으므로 상태 인 것 같습니다. 마지막으로 필터링 된 제품 목록은 원래 제품 목록과 검색 텍스트 및 확인란의 값을 결합하여 계산할 수 있기 때문에 상태가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6f1bbb5016bd5b7f1cbbbc8bff248976ede2bdbd" translate="yes" xml:space="preserve">
          <source>The parent test instance of this test instance.</source>
          <target state="translated">이 테스트 인스턴스의 상위 테스트 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="75a37bc623c00c3288da02b16fb11939ee777c48" translate="yes" xml:space="preserve">
          <source>The problem here isn&amp;rsquo;t just about performance &amp;mdash; remounting a component causes the state of that component and all of its children to be lost.</source>
          <target state="translated">여기서 문제는 성능에만 국한된 것이 아닙니다. 구성 요소를 다시 마운트하면 해당 구성 요소와 모든 하위 구성 요소의 상태가 유실됩니다.</target>
        </trans-unit>
        <trans-unit id="15386a7181b277d545f04b8eedc8056cc4a44d6c" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;PureComponent&lt;/code&gt; will do a simple comparison between the old and new values of &lt;code&gt;this.props.words&lt;/code&gt;. Since this code mutates the &lt;code&gt;words&lt;/code&gt; array in the &lt;code&gt;handleClick&lt;/code&gt; method of &lt;code&gt;WordAdder&lt;/code&gt;, the old and new values of &lt;code&gt;this.props.words&lt;/code&gt; will compare as equal, even though the actual words in the array have changed. The &lt;code&gt;ListOfWords&lt;/code&gt; will thus not update even though it has new words that should be rendered.</source>
          <target state="translated">문제는 &lt;code&gt;PureComponent&lt;/code&gt; 가 &lt;code&gt;this.props.words&lt;/code&gt; 의 이전 값과 새 값을 간단하게 비교 한다는 것 입니다. 이 코드 변이 때문에 &lt;code&gt;words&lt;/code&gt; 에 배열 &lt;code&gt;handleClick&lt;/code&gt; 의 방법 &lt;code&gt;WordAdder&lt;/code&gt; 의 신구 값 &lt;code&gt;this.props.words&lt;/code&gt; 는 어레이의 실제 단어를 변경 한 경우에도 동일하게 비교된다. 따라서 &lt;code&gt;ListOfWords&lt;/code&gt; 에는 렌더링해야하는 새 단어가 있어도 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f0ea7c5399c0c473f0cc17a73922eb556fef997" translate="yes" xml:space="preserve">
          <source>The problem is that it&amp;rsquo;s both unnecessary (you can use &lt;code&gt;this.props.color&lt;/code&gt; directly instead), and creates bugs (updates to the &lt;code&gt;color&lt;/code&gt; prop won&amp;rsquo;t be reflected in the state).</source>
          <target state="translated">문제는 그것이 불필요하고 ( 대신 &lt;code&gt;this.props.color&lt;/code&gt; 를 직접 사용할 수 있음 ) 버그를 생성한다는 것입니다 ( &lt;code&gt;color&lt;/code&gt; 소품에 대한 업데이트 는 상태에 반영되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="f8e70f0f5024e3a8775d44c1ce4056df7f4d3a4d" translate="yes" xml:space="preserve">
          <source>The problem is, if a context value provided by component changes, descendants that use that value won&amp;rsquo;t update if an intermediate parent returns &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. This is totally out of control of the components using context, so there&amp;rsquo;s basically no way to reliably update the context. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;This blog post&lt;/a&gt; has a good explanation of why this is a problem and how you might get around it.</source>
          <target state="translated">문제는 구성 요소가 제공 한 컨텍스트 값이 변경되면 중간 부모가 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 반환하면 해당 값을 사용하는 하위 항목이 업데이트되지 않는다는 것 입니다. 컨텍스트를 사용하여 구성 요소를 완전히 제어 할 수 없으므로 기본적으로 컨텍스트를 안정적으로 업데이트 할 수있는 방법이 없습니다. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;이 블로그 게시물&lt;/a&gt; 에는 이것이 왜 문제이며 어떻게 해결할 수 있는지에 대한 좋은 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="985aef5fd109f4727b2c3e05bea5a14a684f7867" translate="yes" xml:space="preserve">
          <source>The problem with this is that now we &lt;em&gt;always&lt;/em&gt; wait for both of them to be fetched. However, if it&amp;rsquo;s the &lt;em&gt;posts&lt;/em&gt; that came back first, there&amp;rsquo;s no reason to delay showing them. When fun facts load later, they won&amp;rsquo;t shift the layout because they&amp;rsquo;re already below the posts.</source>
          <target state="translated">이것의 문제점은 이제 우리는 &lt;em&gt;항상&lt;/em&gt; 두 가지를 모두 가져 오기를 기다리는 것입니다. 그러나 처음 &lt;em&gt;게시 된 게시물&lt;/em&gt; 인 경우 &lt;em&gt;게시&lt;/em&gt; 를 지연시킬 이유가 없습니다. 재미있는 사실이 나중에로드되면 레이아웃이 이미 게시물 아래에 있으므로 레이아웃을 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03950f8935a0284b924067f2374cf9480513156a" translate="yes" xml:space="preserve">
          <source>The problem with this syntax is that a different callback is created each time the &lt;code&gt;LoggingButton&lt;/code&gt; renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</source>
          <target state="translated">이 구문의 문제점은 &lt;code&gt;LoggingButton&lt;/code&gt; 이 렌더링 될 때마다 다른 콜백이 생성 된다는 것 입니다. 대부분의 경우 이것은 괜찮습니다. 그러나이 콜백이 구성 요소를 낮추기위한 소품으로 전달되면 해당 구성 요소는 추가로 다시 렌더링 할 수 있습니다. 이런 종류의 성능 문제를 피하려면 일반적으로 생성자에서 바인딩하거나 클래스 필드 구문을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9fe552e7244a26ea298807902943abd3f5ea401" translate="yes" xml:space="preserve">
          <source>The props corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; component has &lt;code&gt;{size: 'small'}&lt;/code&gt; as props.</source>
          <target state="translated">이 테스트 인스턴스에 해당하는 소품. 예를 들어 &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; 구성 요소에는 props로 &lt;code&gt;{size: 'small'}&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fce336ce1bf6f03834b6fbd791d6f0d85f22369" translate="yes" xml:space="preserve">
          <source>The purpose of our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook is to subscribe us to a friend&amp;rsquo;s status. This is why it takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether this friend is online:</source>
          <target state="translated">&lt;code&gt;useFriendStatus&lt;/code&gt; Hook 의 목적은 친구의 상태를 구독하는 것입니다. 이것이 &lt;code&gt;friendID&lt;/code&gt; 를 인수로 사용하여이 친구가 온라인인지 여부를 리턴하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="b6c0cdaae16617f0fa21ba142bf2809ac5269c18" translate="yes" xml:space="preserve">
          <source>The quickest way to try JSX in your project is to add this &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to your page:</source>
          <target state="translated">프로젝트에서 JSX를 사용하는 가장 빠른 방법은이 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 페이지에 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a47571ee342cc7e146815342e103ee52412ecda" translate="yes" xml:space="preserve">
          <source>The reason for the stutter is simple: once rendering begins, it can&amp;rsquo;t be interrupted. So the browser can&amp;rsquo;t update the text input right after the key press. No matter how good a UI library (such as React) might look on a benchmark, if it uses blocking rendering, a certain amount of work in your components will always cause stutter. And, often, there is no easy fix.</source>
          <target state="translated">말더듬의 이유는 간단합니다. 일단 렌더링이 시작되면 중단 할 수 없습니다. 따라서 브라우저는 키를 누른 직후 텍스트 입력을 업데이트 할 수 없습니다. UI 라이브러리 (예 : React)가 벤치 마크에서 아무리 잘 보일지라도 블로킹 렌더링을 사용하는 경우 구성 요소의 특정 작업으로 인해 항상 말더듬이 발생할 수 있습니다. 그리고 종종 쉬운 해결책이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6faacd46ba2798dfe6d96de925d3e8fb01c4350a" translate="yes" xml:space="preserve">
          <source>The result looks like this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61eea536517b5e0755810228e63123231a9fbc54" translate="yes" xml:space="preserve">
          <source>The same functionality can be achieved by using appropriate event handlers instead, such as &lt;code&gt;onBlur&lt;/code&gt; and &lt;code&gt;onFocus&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;onBlur&lt;/code&gt; 및 &lt;code&gt;onFocus&lt;/code&gt; 와 같은 적절한 이벤트 핸들러를 대신 사용하여 동일한 기능을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7784002558cdfc24a42cb236b2e3ce3aa1c6451" translate="yes" xml:space="preserve">
          <source>The search text the user has entered</source>
          <target state="translated">사용자가 입력 한 검색 텍스트</target>
        </trans-unit>
        <trans-unit id="271217a1e95a4db6a472aae868aac48af77b167f" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;ref&lt;/code&gt; argument only exists when you define a component with &lt;code&gt;React.forwardRef&lt;/code&gt; call. Regular function or class components don&amp;rsquo;t receive the &lt;code&gt;ref&lt;/code&gt; argument, and ref is not available in props either.</source>
          <target state="translated">두 번째 &lt;code&gt;ref&lt;/code&gt; 인수는 &lt;code&gt;React.forwardRef&lt;/code&gt; 호출 로 컴포넌트를 정의 할 때만 존재합니다 . 일반 함수 또는 클래스 구성 요소는 &lt;code&gt;ref&lt;/code&gt; 인수를 받지 않으며 ref는 소품에서도 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="55fe0f7cb0bc62f87df6f7b88593c40ba2275b33" translate="yes" xml:space="preserve">
          <source>The second parameter to &lt;code&gt;setState()&lt;/code&gt; is an optional callback function that will be executed once &lt;code&gt;setState&lt;/code&gt; is completed and the component is re-rendered. Generally we recommend using &lt;code&gt;componentDidUpdate()&lt;/code&gt; for such logic instead.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 의 두 번째 매개 변수 는 &lt;code&gt;setState&lt;/code&gt; 가 완료되고 컴포넌트가 다시 렌더링되면 실행되는 선택적 콜백 함수입니다 . 일반적으로 그러한 논리에 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f35ac8c2adbf99f7b5bef181874b520f98344d20" translate="yes" xml:space="preserve">
          <source>The select Tag</source>
          <target state="translated">선택 태그</target>
        </trans-unit>
        <trans-unit id="07e95df1e5b40e195c7db30f2c1280116b62015e" translate="yes" xml:space="preserve">
          <source>The signature is identical to &lt;code&gt;useEffect&lt;/code&gt;, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside &lt;code&gt;useLayoutEffect&lt;/code&gt; will be flushed synchronously, before the browser has a chance to paint.</source>
          <target state="translated">서명은 &lt;code&gt;useEffect&lt;/code&gt; 와 동일 하지만 모든 DOM 변이 후에 동기식으로 실행됩니다. 이를 사용하여 DOM에서 레이아웃을 읽고 동 기적으로 다시 렌더링하십시오. &lt;code&gt;useLayoutEffect&lt;/code&gt; 내부에서 예약 된 업데이트 는 브라우저가 페인트하기 전에 동 기적으로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c639e86090bfaf74758cb091cb2ea67a1fddcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the &lt;code&gt;handleClick&lt;/code&gt; method above could be rewritten using &lt;code&gt;concat&lt;/code&gt; as:</source>
          <target state="translated">이 문제점을 피하는 가장 간단한 방법은 props 또는 state로 사용중인 값을 변경하지 않는 것입니다. 예를 들어, 위 의 &lt;code&gt;handleClick&lt;/code&gt; 메소드는 다음과 같이 &lt;code&gt;concat&lt;/code&gt; 을 사용하여 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71460fd47e61e6f8130d4e6e217a7bd0d4fb7bfc" translate="yes" xml:space="preserve">
          <source>The simplest way to consume &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; models and collections from a React component is to listen to the various change events and manually force an update.</source>
          <target state="translated">React 컴포넌트에서 &lt;a href=&quot;https://backbonejs.org/&quot;&gt;백본&lt;/a&gt; 모델 및 콜렉션 을 사용하는 가장 간단한 방법 은 다양한 변경 이벤트를 듣고 수동으로 업데이트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c75dd6397b4e899517f186ce7dd6fec1fc4143c7" translate="yes" xml:space="preserve">
          <source>The simplest way to define a component is to write a JavaScript function:</source>
          <target state="translated">컴포넌트를 정의하는 가장 간단한 방법은 JavaScript 함수를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ea592b9f9c12cb222debb92695fe41e5990f382a" translate="yes" xml:space="preserve">
          <source>The smallest React example looks like this:</source>
          <target state="translated">가장 작은 반응 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40b2a1c643d292094f43059dfae62b82207b4ff4" translate="yes" xml:space="preserve">
          <source>The solution for this problem is to use the &lt;code&gt;React.forwardRef&lt;/code&gt; API (introduced with React 16.3). &lt;a href=&quot;forwarding-refs&quot;&gt;Learn more about it in the forwarding refs section&lt;/a&gt;.</source>
          <target state="translated">이 문제에 대한 해결책은 &lt;code&gt;React.forwardRef&lt;/code&gt; API (React 16.3에서 도입 )를 사용하는 것 입니다. &lt;a href=&quot;forwarding-refs&quot;&gt;전달 참조 섹션에서 이에 대해 자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e03e04eaae4ac606ca548d267f13b377ac94de6" translate="yes" xml:space="preserve">
          <source>The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.</source>
          <target state="translated">상태에는 시간이 지남에 따라 변경 될 수있는이 구성 요소에 특정한 데이터가 포함됩니다. 상태는 사용자 정의이며 일반 JavaScript 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d178c16b57f339917ec9004067811e1e0f7f4019" translate="yes" xml:space="preserve">
          <source>The state of each component is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="translated">The state of each component is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</target>
        </trans-unit>
        <trans-unit id="22478714b7fd0f489e81d753e9c3c235e69d54ef" translate="yes" xml:space="preserve">
          <source>The state of these components is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="translated">이러한 구성 요소의 상태는 완전히 독립적입니다. 후크는 상태 자체가 아니라 상태 &lt;em&gt;저장 논리&lt;/em&gt; 를 재사용하는 방법 입니다. 실제로, 후크에 대한 각 &lt;em&gt;호출&lt;/em&gt; 은 완전히 분리 된 상태이므로 하나의 구성 요소에서 동일한 사용자 정의 후크를 두 번 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2641b617455464f7d6496f2f2334b192cde2dbee" translate="yes" xml:space="preserve">
          <source>The state starts as &lt;code&gt;{ count: 0 }&lt;/code&gt;, and we increment &lt;code&gt;state.count&lt;/code&gt; when the user clicks a button by calling &lt;code&gt;this.setState()&lt;/code&gt;. We&amp;rsquo;ll use snippets from this class throughout the page.</source>
          <target state="translated">상태는 &lt;code&gt;{ count: 0 }&lt;/code&gt; 으로 시작하고 &lt;code&gt;this.setState()&lt;/code&gt; 를 호출하여 사용자가 버튼을 클릭하면 &lt;code&gt;state.count&lt;/code&gt; 를 증가 시킵니다 . 페이지 전체에서이 클래스의 스 니펫을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2573196fe586fe5ec0e5e5bd258214571daa5288" translate="yes" xml:space="preserve">
          <source>The static &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; lifecycle</source>
          <target state="translated">정적 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="18095f89e6ec05009ccfd909d0cb8cefbc086b0a" translate="yes" xml:space="preserve">
          <source>The stream returned from this method will return a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt;, which provides transform streams for transcoding text.</source>
          <target state="translated">이 메소드에서 리턴 된 스트림은 utf-8로 인코딩 된 바이트 스트림을 리턴합니다. 다른 인코딩의 스트림이 필요한 경우 텍스트 트랜스 코딩을위한 변환 스트림을 제공하는 &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt; 와 같은 프로젝트를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="c23c69a9c20200b9704aea13ea549c14e1ec4040" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;Hello world!&lt;/code&gt; is available in &lt;code&gt;props.children&lt;/code&gt; in the &lt;code&gt;Welcome&lt;/code&gt; component:</source>
          <target state="translated">문자열 &lt;code&gt;Hello world!&lt;/code&gt; &lt;code&gt;Welcome&lt;/code&gt; 컴포넌트의 &lt;code&gt;props.children&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89ccb3f5a789f0345b99477baf67e4ea269b0c4b" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&amp;ldquo;render prop&amp;rdquo;&lt;/a&gt; refers to a technique for sharing code between React components using a prop whose value is a function.</source>
          <target state="translated">&lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&quot;렌더 소품&quot;&lt;/a&gt; 이라는 용어 는 값이 함수 인 소품을 사용하여 React 컴포넌트간에 코드를 공유하는 기술을 말합니다.</target>
        </trans-unit>
        <trans-unit id="945ad83d6f6df882982c2eea500580f8486a2610" translate="yes" xml:space="preserve">
          <source>The textarea Tag</source>
          <target state="translated">텍스트 영역 태그</target>
        </trans-unit>
        <trans-unit id="0b75157dc01568e5ebeb7fddf73f5af3b9ebb9b6" translate="yes" xml:space="preserve">
          <source>The toolchains recommended on this page &lt;strong&gt;don&amp;rsquo;t require configuration to get started&lt;/strong&gt;.</source>
          <target state="translated">이 페이지에서 권장하는 툴체인 &lt;strong&gt;은 시작하기 위해 구성 할 필요가 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="46c2a81a73e1db62c5ec0751bf9c3489bd2fa0f4" translate="yes" xml:space="preserve">
          <source>The tradeoff we&amp;rsquo;re making here is that &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; will be inconsistent with other components and potentially show an older item. Click &amp;ldquo;Next&amp;rdquo; a few times, and you&amp;rsquo;ll notice it. But thanks to that, we were able to cut down the transition time from 1000ms to 300ms.</source>
          <target state="translated">여기서의 장단점은 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 이 다른 구성 요소와 일치하지 않으며 이전 항목이 표시 될 수 있다는 것입니다. &amp;ldquo;다음&amp;rdquo;을 몇 번 클릭하면 알 수 있습니다. 그러나 덕분에 전환 시간을 1000ms에서 300ms로 줄일 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="12aef5cfe0207aa12a859449db31e95cefb54821" translate="yes" xml:space="preserve">
          <source>The value of the checkbox</source>
          <target state="translated">확인란의 값</target>
        </trans-unit>
        <trans-unit id="47da38aacbdc104c0e2be9e42b4998d633ad332b" translate="yes" xml:space="preserve">
          <source>The value of the ref differs depending on the type of the node:</source>
          <target state="translated">ref의 값은 노드의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8d6f43e31ac36677cfe23fbc628d0bbec73cb47d" translate="yes" xml:space="preserve">
          <source>The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at:</source>
          <target state="translated">위의 버전은 개발 용이며 프로덕션에는 적합하지 않습니다. React의 축소 및 최적화 된 프로덕션 버전은 다음에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="74ef4a162b977ab31ffac13bf23f9dcbf0227789" translate="yes" xml:space="preserve">
          <source>The virtual DOM (VDOM) is a programming concept where an ideal, or &amp;ldquo;virtual&amp;rdquo;, representation of a UI is kept in memory and synced with the &amp;ldquo;real&amp;rdquo; DOM by a library such as ReactDOM. This process is called &lt;a href=&quot;reconciliation&quot;&gt;reconciliation&lt;/a&gt;.</source>
          <target state="translated">가상 DOM (VDOM)은 UI의 이상적인 또는 &quot;가상&quot;표현이 메모리에 유지되고 ReactDOM과 같은 라이브러리에 의해 &quot;실제&quot;DOM과 동기화되는 프로그래밍 개념입니다. 이 과정을 &lt;a href=&quot;reconciliation&quot;&gt;조정&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="574a3a781870e163cce88ef2b0762f4b08191e2e" translate="yes" xml:space="preserve">
          <source>The way changes are determined can cause some issues when passing objects as &lt;code&gt;value&lt;/code&gt;: see &lt;a href=&quot;#caveats&quot;&gt;Caveats&lt;/a&gt;.</source>
          <target state="translated">변경 사항이 결정되는 방식으로 개체를 &lt;code&gt;value&lt;/code&gt; 전달할 때 일부 문제가 발생할 수 있습니다 . &lt;a href=&quot;#caveats&quot;&gt;주의 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b1b6af3227db905819bedeb8a6cf6a56db68adc" translate="yes" xml:space="preserve">
          <source>Then add the &lt;code&gt;flow&lt;/code&gt; preset to your &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel configuration&lt;/a&gt;. For example, if you configure Babel through &lt;code&gt;.babelrc&lt;/code&gt; file, it could look like this:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel 구성에 &lt;/a&gt; &lt;code&gt;flow&lt;/code&gt; 사전 설정을 추가하십시오 . 예를 들어 &lt;code&gt;.babelrc&lt;/code&gt; 파일을 통해 Babel을 구성하면 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49b398d1b5e04088832e8b4a9d6f3fd68e540ca4" translate="yes" xml:space="preserve">
          <source>Then we can focus it elsewhere in our component when needed:</source>
          <target state="translated">그런 다음 필요할 때 컴포넌트의 다른 곳에 초점을 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9618d02f199ba8a6ff1e620695267d9b59eba053" translate="yes" xml:space="preserve">
          <source>Then you can assert:</source>
          <target state="translated">그런 다음 다음과 같이 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d964dac0f67b92e21c4a4e8448328868b35a75e8" translate="yes" xml:space="preserve">
          <source>Then you can update them independently with separate &lt;code&gt;setState()&lt;/code&gt; calls:</source>
          <target state="translated">그런 다음 별도의 &lt;code&gt;setState()&lt;/code&gt; 호출로 독립적으로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4acfee1bfbaf53b3d5fb903139781650425ac98e" translate="yes" xml:space="preserve">
          <source>Then you can use it as a regular component:</source>
          <target state="translated">그런 다음 일반 구성 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="352af5a158542075e87c87aa4822f1cc90f9c371" translate="yes" xml:space="preserve">
          <source>Then, to create a production build, add the &lt;code&gt;-p&lt;/code&gt; flag to the &lt;code&gt;build&lt;/code&gt; command:</source>
          <target state="translated">그런 다음 프로덕션 빌드를 작성 하려면 &lt;code&gt;build&lt;/code&gt; 명령에 &lt;code&gt;-p&lt;/code&gt; 플래그를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b1892a438ed36b827ab226ef3f0d930f33d28ce" translate="yes" xml:space="preserve">
          <source>There are a few good use cases for refs:</source>
          <target state="translated">심판에 대한 몇 가지 좋은 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6693c58ee9b46421c76137aee80156eafed70d79" translate="yes" xml:space="preserve">
          <source>There are a few less commonly used built-in Hooks that you might find useful. For example, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; lets you subscribe to React context without introducing nesting:</source>
          <target state="translated">유용하게 사용될 수있는 덜 자주 사용되는 내장 후크가 있습니다. 예를 들어, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt; &lt;code&gt;useContext&lt;/code&gt; 를&lt;/a&gt; 사용하면 중첩을 도입하지 않고도 React 컨텍스트를 구독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ccf0a06731ef0941dac9931fd0d028970a49b3" translate="yes" xml:space="preserve">
          <source>There are a few more heuristics, and they might change over time as we fine-tune the rule to balance finding bugs with avoiding false positives.</source>
          <target state="translated">휴리스틱이 몇 가지 더 있으며, 오 탐지를 피하고 버그 찾기의 균형을 맞추기 위해 규칙을 미세 조정함에 따라 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb277ba2cfa0f874f335d88ec76a246c5b350e75" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentDidUpdate&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="translated">There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentDidUpdate&lt;/code&gt; , the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</target>
        </trans-unit>
        <trans-unit id="7f27bf7450b1f7493e5f3835cc19efaeea4250b6" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentWillReceiveProps&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="translated">이것에는 몇 가지 문제가 있습니다. 하나는 입력 컴포넌트를 확장 컴포넌트와 별도로 재사용 할 수 없다는 것입니다. 더 중요한 것은 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 변경 하는 다른 HOC를 &lt;code&gt;EnhancedComponent&lt;/code&gt; 에 적용 하면 첫 번째 HOC 기능이 무시됩니다! 이 HOC는 수명주기 방법이없는 함수 구성 요소와도 작동하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bfc361ac490a02de7694989e5f2a21519a4e9158" translate="yes" xml:space="preserve">
          <source>There are a few ways to test React components. Broadly, they divide into two categories:</source>
          <target state="translated">React 컴포넌트를 테스트하는 몇 가지 방법이 있습니다. 크게 두 가지 범주로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="34efc5850f64e7842db51c2c07fdbcdd7ce86bfb" translate="yes" xml:space="preserve">
          <source>There are a number of attributes that work differently between React and HTML:</source>
          <target state="translated">React와 HTML간에 다르게 작동하는 많은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="094824494a1508942600fda7b6cb25cca5aedab2" translate="yes" xml:space="preserve">
          <source>There are a number of tools we can use to assist in the creation of accessible web applications.</source>
          <target state="translated">액세스 가능한 웹 응용 프로그램을 만드는 데 도움이되는 여러 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f2e85d0d652f9d1bc05d28f3438dd676ea31cf" translate="yes" xml:space="preserve">
          <source>There are just two of them: &lt;code&gt;setState()&lt;/code&gt; and &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 와 &lt;code&gt;forceUpdate()&lt;/code&gt; 두 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f815a5aa15ca4b033e70b18a3f7155b455cca3b" translate="yes" xml:space="preserve">
          <source>There are many pain points associated with deep directory nesting in JavaScript projects. It becomes harder to write relative imports between them, or to update those imports when the files are moved. Unless you have a very compelling reason to use a deep folder structure, consider limiting yourself to a maximum of three or four nested folders within a single project. Of course, this is only a recommendation, and it may not be relevant to your project.</source>
          <target state="translated">JavaScript 프로젝트에는 깊은 디렉토리 중첩과 관련된 많은 어려움이 있습니다. 이들 사이에 상대적인 가져 오기를 작성하거나 파일을 이동할 때 해당 가져 오기를 업데이트하기가 더 어려워집니다. 깊은 폴더 구조를 사용해야하는 강력한 이유가 없다면 단일 프로젝트 내에서 최대 3-4 개의 중첩 폴더로 제한하십시오. 물론 이것은 권장 사항 일 뿐이며 프로젝트와 관련이 없을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb52a486a0defd5e5a737df39df0a9e362d83228" translate="yes" xml:space="preserve">
          <source>There are several different ways to specify props in JSX.</source>
          <target state="translated">JSX에서 소품을 지정하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba31773d4580276a2fa01ba27c7c6e4050da9978" translate="yes" xml:space="preserve">
          <source>There are several ways to make sure functions have access to component attributes like &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt;, depending on which syntax and build steps you are using.</source>
          <target state="translated">사용 하는 구문 및 빌드 단계에 따라 함수가 &lt;code&gt;this.props&lt;/code&gt; 및 &lt;code&gt;this.state&lt;/code&gt; 와 같은 컴포넌트 속성에 액세스 할 수 있도록하는 몇 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="035c67657dec8a559bd085096871d672c1441169" translate="yes" xml:space="preserve">
          <source>There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;state of the art algorithms&lt;/a&gt; have a complexity in the order of O(n&lt;sup&gt;3&lt;/sup&gt;) where n is the number of elements in the tree.</source>
          <target state="translated">하나의 트리를 다른 트리로 변환하기 위해 최소 수의 연산을 생성하는 알고리즘 문제에 대한 일반적인 해결책이 있습니다. 그러나, &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;최신 알고리즘&lt;/a&gt; 은 O (n &lt;sup&gt;3&lt;/sup&gt; ) 의 순서로 복잡성을 가지며, 여기서 n은 트리의 요소의 수이다.</target>
        </trans-unit>
        <trans-unit id="bd7701becfe3cd2853a0554a2a6f2a828400586b" translate="yes" xml:space="preserve">
          <source>There are some special rules about where you can and can&amp;rsquo;t use Hooks within a component. We&amp;rsquo;ll learn them in &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">구성 요소 내에서 후크를 사용할 수있는 위치와 사용할 수없는 위치에 대한 특별한 규칙이 있습니다. 우리는 그것들 &lt;a href=&quot;hooks-rules&quot;&gt;을 훅의 규칙&lt;/a&gt; 에서 배울 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f5ab23a7947a8c9190ca88a94b27fa5bfa00f119" translate="yes" xml:space="preserve">
          <source>There are three things you should know about &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 에 대해 알아야 할 세 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="495dcf3a5be823b2ed9fbe753129b50e1e7a9952" translate="yes" xml:space="preserve">
          <source>There are two common kinds of side effects in React components: those that don&amp;rsquo;t require cleanup, and those that do. Let&amp;rsquo;s look at this distinction in more detail.</source>
          <target state="translated">React 구성 요소에는 두 가지 일반적인 부작용이 있습니다. 정리가 필요하지 않은 것과 부작용이 있습니다. 이 차이점을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7bbc4d57f5374db57bc481f127695ec68040f840" translate="yes" xml:space="preserve">
          <source>There are two different ways to initialize &lt;code&gt;useReducer&lt;/code&gt; state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:</source>
          <target state="translated">&lt;code&gt;useReducer&lt;/code&gt; 상태 를 초기화하는 방법에는 두 가지가 있습니다 . 사용 사례에 따라 둘 중 하나를 선택할 수 있습니다. 가장 간단한 방법은 초기 상태를 두 번째 인수로 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5bced4d36eb8976c4c687005ab8da42f62d1581" translate="yes" xml:space="preserve">
          <source>There are two main reasons:</source>
          <target state="translated">두 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56772a4b4c1e06b0df2a414953a659ffda40d7b" translate="yes" xml:space="preserve">
          <source>There are two main ways to get declarations for a library:</source>
          <target state="translated">라이브러리에 대한 선언을 얻는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a32a8b81054e306fc51c8a8d5d4a6e5c26811de5" translate="yes" xml:space="preserve">
          <source>There are two types of &amp;ldquo;model&amp;rdquo; data in React: props and state. It&amp;rsquo;s important to understand the distinction between the two; skim &lt;a href=&quot;state-and-lifecycle&quot;&gt;the official React docs&lt;/a&gt; if you aren&amp;rsquo;t sure what the difference is. See also &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ: What is the difference between state and props?&lt;/a&gt;</source>
          <target state="translated">React에는 props와 state라는 두 가지 유형의&amp;ldquo;모델&amp;rdquo;데이터가 있습니다. 둘 사이의 차이점을 이해하는 것이 중요합니다. 차이점이 무엇인지 확실하지 않으면 &lt;a href=&quot;state-and-lifecycle&quot;&gt;공식 React 문서를&lt;/a&gt; 훑어보십시오 . 참조 &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;자주 묻는 질문 : 상태와 소품의 차이점은 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="972f3aee5b48db67c62cfafa5894934c6d7a06bc" translate="yes" xml:space="preserve">
          <source>There is a JavaScript proposal to add &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread properties&lt;/a&gt; to make it easier to update objects without mutation as well:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;객체 스프레드 속성&lt;/a&gt; 을 추가 하여 변경없이 객체를보다 쉽게 ​​업데이트 할 수 있는 JavaScript 제안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b6781e91bd723c7b2a32f9c7b9c767072958836" translate="yes" xml:space="preserve">
          <source>There is a common theme around Concurrent Mode features. &lt;strong&gt;Its mission is to help integrate the findings from the Human-Computer Interaction research into real UIs.&lt;/strong&gt;</source>
          <target state="translated">동시 모드 기능에 대한 공통 주제가 있습니다. &lt;strong&gt;휴먼-컴퓨터 상호 작용 연구 결과를 실제 UI에 통합하는 데 도움이됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c02f2726f7bf82129cb0890af06297b7f6ef5f8" translate="yes" xml:space="preserve">
          <source>There is a new, shorter syntax you can use for declaring fragments. It looks like empty tags:</source>
          <target state="translated">조각을 선언하는 데 사용할 수있는 더 짧은 새 구문이 있습니다. 빈 태그처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="268f6fed8cb60468299ecf4640f5b215834edb2a" translate="yes" xml:space="preserve">
          <source>There is a simpler way to solve this. &lt;strong&gt;Instead of making the transition shorter, we can &amp;ldquo;disconnect&amp;rdquo; the slow component from the transition&lt;/strong&gt; by wrapping it into &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이를 해결하는 더 간단한 방법이 있습니다. &lt;strong&gt;전환을 더 짧게 만드는 대신, 느린 구성 요소&lt;/strong&gt; 를 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 로 감싸서 &lt;strong&gt;전환에서 &quot;연결 해제&quot;할 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2255fef7c8ea4db88004b8c5dca9f64337cd0c4f" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;an option&lt;/a&gt; to force Flow to check &lt;em&gt;all&lt;/em&gt; files regardless of the annotation. This can be too noisy for existing projects, but is reasonable for a new project if you want to fully type it with Flow.</source>
          <target state="translated">주석에 관계없이 Flow가 &lt;em&gt;모든&lt;/em&gt; 파일 을 확인하도록 &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;하는 옵션&lt;/a&gt; 도 있습니다 . 기존 프로젝트에는 노이즈가 많을 수 있지만 Flow로 완전히 입력하려는 경우 새 프로젝트에 적합합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6f37ffca9a0422d14d4f49211218871c0bda6b" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;#short-syntax&quot;&gt;short syntax&lt;/a&gt; for declaring them.</source>
          <target state="translated">선언을위한 새로운 &lt;a href=&quot;#short-syntax&quot;&gt;짧은 구문&lt;/a&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f70442d13f0b33081b997d454535c8bb3c00192d" translate="yes" xml:space="preserve">
          <source>There is an internal list of &amp;ldquo;memory cells&amp;rdquo; associated with each component. They&amp;rsquo;re just JavaScript objects where we can put some data. When you call a Hook like &lt;code&gt;useState()&lt;/code&gt;, it reads the current cell (or initializes it during the first render), and then moves the pointer to the next one. This is how multiple &lt;code&gt;useState()&lt;/code&gt; calls each get independent local state.</source>
          <target state="translated">각 구성 요소와 관련된 &quot;메모리 셀&quot;의 내부 목록이 있습니다. 데이터를 넣을 수있는 JavaScript 객체 일뿐입니다. &lt;code&gt;useState()&lt;/code&gt; 와 같은 후크를 호출 하면 현재 셀을 읽거나 첫 번째 렌더링 중에 초기화 한 다음 포인터를 다음 셀로 이동합니다. 여러 &lt;code&gt;useState()&lt;/code&gt; 호출이 각각 독립적 인 로컬 상태를 얻는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="d22c59ace56ae0e2f33663b9156aad827b310eee" translate="yes" xml:space="preserve">
          <source>There is no special code for handling updates because &lt;code&gt;useEffect&lt;/code&gt; handles them &lt;em&gt;by default&lt;/em&gt;. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 가 &lt;em&gt;기본적으로&lt;/em&gt; 업데이트를 처리하기 때문에 업데이트를 처리하기위한 특수 코드는 없습니다 . 다음 효과를 적용하기 전에 이전 효과를 정리합니다. 이를 설명하기 위해이 구성 요소가 시간이 지남에 따라 생성 할 수있는 구독 및 구독 취소 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="642dbc420d30f0e2507cbd973e44025c3ff1e85c" translate="yes" xml:space="preserve">
          <source>There is no special meaning to either &lt;code&gt;temperature&lt;/code&gt; or &lt;code&gt;onTemperatureChange&lt;/code&gt; prop names in custom components. We could have called them anything else, like name them &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;onChange&lt;/code&gt; which is a common convention.</source>
          <target state="translated">사용자 컴포넌트에서 &lt;code&gt;temperature&lt;/code&gt; 또는 &lt;code&gt;onTemperatureChange&lt;/code&gt; prop 이름 에는 특별한 의미가 없습니다 . 우리는 이름처럼, 그 어떤 다른 불렀다 수있는 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;onChange&lt;/code&gt; 가 일반적인 관례이다.</target>
        </trans-unit>
        <trans-unit id="67cb15262522dd0a8cac5f7e753834e720749476" translate="yes" xml:space="preserve">
          <source>There is no step four. &lt;strong&gt;You have just added the first React component to your website.&lt;/strong&gt;</source>
          <target state="translated">4 단계는 없습니다. &lt;strong&gt;웹 사이트에 첫 번째 React 컴포넌트를 추가했습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdbe940e85f9c9f408b6f7b07e4942bd67b971b2" translate="yes" xml:space="preserve">
          <source>There is one caveat to the above example: refs will not get passed through. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not a prop. Like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.</source>
          <target state="translated">위의 예에는 한 가지주의 사항이 있습니다. 심판은 통과되지 않습니다. &lt;code&gt;ref&lt;/code&gt; 이 소품이 아니기 때문 입니다. &lt;code&gt;key&lt;/code&gt; 와 마찬가지로 React에서 다르게 처리합니다. HOC에 참조를 추가하면 해당 참조는 랩핑 된 구성 요소가 아니라 가장 바깥 쪽 컨테이너 구성 요소를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="edb71d2b04e7a94b003ba55463bb2af6d539a2e7" translate="yes" xml:space="preserve">
          <source>There should be a single &amp;ldquo;source of truth&amp;rdquo; for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">React 애플리케이션에서 변경되는 모든 데이터에 대해 단일 &quot;소스 소스&quot;가 있어야합니다. 일반적으로 상태는 렌더링에 필요한 구성 요소에 먼저 추가됩니다. 그런 다음 다른 구성 요소에도 필요한 경우 가장 가까운 공통 조상까지 들어 올릴 수 있습니다. 서로 다른 구성 요소간에 상태를 동기화하는 대신 &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;하향식 데이터 흐름&lt;/a&gt; 에 의존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="50e2bee19b1efd62498d4e7cf956c72bd6a2c65c" translate="yes" xml:space="preserve">
          <source>There will be no complicated tools or install requirements &amp;mdash; &lt;strong&gt;to complete this section, you only need an internet connection, and a minute of your time.&lt;/strong&gt;</source>
          <target state="translated">복잡한 도구 나 설치 요구 사항은 없습니다. &lt;strong&gt;이 섹션을 완료하려면 인터넷에 연결되어 있고 잠시만 있으면됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a00d2e6fc2d4c1af40a867da6248d449045f1b6d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing left to try rendering. Because &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; suspended, React shows the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; fallback above it in the tree: &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt;. We&amp;rsquo;re done for now.</source>
          <target state="translated">렌더링을 시도 할 것이 남아 있지 않습니다. &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 가 일시 중단 되었으므로 React는 &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt; 트리에서 가장 가까운 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 폴백을 표시합니다 . 우리는 지금 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="a8630452d7c496e5f59324dba0cad19af10a411b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing new inside of it &amp;mdash; the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.</source>
          <target state="translated">그 안에는 새로운 것이 없습니다. 논리는 위의 구성 요소에서 복사됩니다. 컴포넌트에서와 마찬가지로, 사용자 정의 후크의 최상위 레벨에서 다른 후크 만 무조건 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7952e7362764435c9ea989c8c2fb10bb29a9cee" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still something that feels broken about &lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;our last example&lt;/a&gt;. Sure, it&amp;rsquo;s nice not to see a &amp;ldquo;bad&amp;rdquo; loading state. &lt;strong&gt;But having no indication of progress at all feels even worse!&lt;/strong&gt; When we click &amp;ldquo;Next&amp;rdquo;, nothing happens and it feels like the app is broken.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;우리의 마지막 예제&lt;/a&gt; 에 대해 여전히 깨진 느낌이 있습니다 . 물론, &quot;불량&quot;로딩 상태를 보지 않는 것이 좋습니다. &lt;strong&gt;그러나 진전의 징후가 전혀없는 것조차 더 나빠집니다! &lt;/strong&gt;&amp;ldquo;Next (다음)&amp;rdquo;를 클릭하면 아무 일도 일어나지 않으며 앱이 고장난 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6bddc517086dd36d013186f2bec7354c8db9a7c" translate="yes" xml:space="preserve">
          <source>Therefore, if the condition is &lt;code&gt;true&lt;/code&gt;, the element right after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will appear in the output. If it is &lt;code&gt;false&lt;/code&gt;, React will ignore and skip it.</source>
          <target state="translated">따라서 조건이 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 바로 뒤에있는 요소 가 출력에 나타납니다. 이 경우 &lt;code&gt;false&lt;/code&gt; 무시하고 건너 뜁니다 반응한다.</target>
        </trans-unit>
        <trans-unit id="acf42ba40fc8ff04bd47c18be64214611d7241a1" translate="yes" xml:space="preserve">
          <source>These acronyms all refer to the most recent versions of the ECMAScript Language Specification standard, which the JavaScript language is an implementation of. The ES6 version (also known as ES2015) includes many additions to the previous versions such as: arrow functions, classes, template literals, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; statements. You can learn more about specific versions &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이러한 두문자어는 모두 최신 버전의 ECMAScript 언어 사양 표준을 나타내며 JavaScript 언어가 구현됩니다. ES6 버전 (ES2015라고도 함)에는 화살표 기능, 클래스, 템플릿 리터럴, &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 문과 같은 이전 버전에 추가 된 많은 기능이 포함되어 있습니다. 특정 버전에 대한 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c8f570a03b769a433d84e1f653f21208428d0f" translate="yes" xml:space="preserve">
          <source>These additional methods depend on a package (&lt;code&gt;stream&lt;/code&gt;) that is &lt;strong&gt;only available on the server&lt;/strong&gt;, and won&amp;rsquo;t work in the browser.</source>
          <target state="translated">이러한 추가 방법은 &lt;strong&gt;서버에서만 사용할 수&lt;/strong&gt; 있고 브라우저에서 작동하지 않는 패키지 ( &lt;code&gt;stream&lt;/code&gt; ) 에 따라 다릅니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25f2c87c8d7c38128e886a538842ed24717179ac" translate="yes" xml:space="preserve">
          <source>These features are still experimental and are subject to change. They are not yet a part of a stable React release, but you can try them in an experimental build.</source>
          <target state="translated">이러한 기능은 아직 실험 중이며 변경 될 수 있습니다. 그것들은 아직 안정적인 React 릴리즈의 일부는 아니지만 실험 빌드에서 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfd15dde0728fd1294866669352da44f07f52a05" translate="yes" xml:space="preserve">
          <source>These focus events work on all elements in the React DOM, not just form elements.</source>
          <target state="translated">이러한 포커스 이벤트는 폼 요소뿐만 아니라 React DOM의 모든 요소에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6edf527844fb9062eb5f03c19c4ca3c36036d6d5" translate="yes" xml:space="preserve">
          <source>These instructions are &lt;em&gt;not&lt;/em&gt; for Create React App users. Even though Create React App uses Babel under the hood, it is already configured to understand Flow. Only follow this step if you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; use Create React App.</source>
          <target state="translated">이 지침은 Create React App 사용자를위한 것이 &lt;em&gt;아닙니다&lt;/em&gt; . React 앱 생성은 후드 아래에서 Babel을 사용하지만 흐름을 이해하도록 이미 구성되어 있습니다. Create React App을 사용 &lt;em&gt;하지 않는&lt;/em&gt; 경우에만이 단계를 &lt;em&gt;수행&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="27cd91a26272aaf22f4c969e79b8478aeac76543" translate="yes" xml:space="preserve">
          <source>These methods are called &amp;ldquo;lifecycle methods&amp;rdquo;.</source>
          <target state="translated">이러한 방법을 &quot;라이프 사이클 방법&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="2cf266ce8120d83117da0747bc989507336f90cb" translate="yes" xml:space="preserve">
          <source>These methods are called in the following order when an instance of a component is being created and inserted into the DOM:</source>
          <target state="translated">이러한 메소드는 컴포넌트의 인스턴스가 작성되어 DOM에 삽입 될 때 다음 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b08807c117d4211e82a119e990441e3210202eac" translate="yes" xml:space="preserve">
          <source>These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.</source>
          <target state="translated">이러한 메소드는 렌더링 중, 라이프 사이클 메소드 또는 하위 컴포넌트의 생성자에서 오류가있을 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf826c1be1dddf71c330af16e0387bbeaf491590" translate="yes" xml:space="preserve">
          <source>These methods are considered legacy and you should &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;avoid them&lt;/a&gt; in new code:</source>
          <target state="translated">이러한 메소드는 레거시로 간주 되며 새 코드에서는 &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;피해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5397ce3496bad1b4a47faf92ec8d097aa003eb30" translate="yes" xml:space="preserve">
          <source>These objects are called &amp;ldquo;React elements&amp;rdquo;. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</source>
          <target state="translated">이러한 개체를 &quot;반응 요소&quot;라고합니다. 그것들을 화면에서보고 싶은 것에 대한 설명으로 생각할 수 있습니다. React는 이러한 객체를 읽고이를 사용하여 DOM을 구성하고 최신 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7b6700f21ab8958202550e8eb63814cd2f217a46" translate="yes" xml:space="preserve">
          <source>These props work similarly to the corresponding HTML attributes, with the exception of the special cases documented above.</source>
          <target state="translated">이러한 소품은 위에서 설명한 특수한 경우를 제외하고 해당 HTML 속성과 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="57b15873af6800f6b7b4f80c07910a05fdb08912" translate="yes" xml:space="preserve">
          <source>These two code snippets are equivalent. While &lt;strong&gt;JSX is &lt;a href=&quot;react-without-jsx&quot;&gt;completely optional&lt;/a&gt;&lt;/strong&gt;, many people find it helpful for writing UI code &amp;mdash; both with React and with other libraries.</source>
          <target state="translated">이 두 코드 스 니펫은 동일합니다. 하지만 &lt;strong&gt;JSX는 &lt;a href=&quot;react-without-jsx&quot;&gt;전적으로 선택&lt;/a&gt;&lt;/strong&gt; 모두 반작용으로 다른 라이브러리 - 많은 사람들이 UI 코드를 작성하는 것이 도움이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed106eaeea3ec56157f40637b694602b4cae386d" translate="yes" xml:space="preserve">
          <source>These two examples are identical:</source>
          <target state="translated">이 두 예는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="56d15e879fdb4c26d55c62a23500106fee00015c" translate="yes" xml:space="preserve">
          <source>These two functions convert numbers. We will write another function that takes a string &lt;code&gt;temperature&lt;/code&gt; and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</source>
          <target state="translated">이 두 함수는 숫자를 변환합니다. 문자열 &lt;code&gt;temperature&lt;/code&gt; 와 변환기 함수를 인수로 사용하여 문자열을 반환하는 다른 함수를 작성 합니다. 이를 사용하여 다른 입력을 기반으로 한 입력의 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3699d971496c4c45664da21c1ceb710a806217eb" translate="yes" xml:space="preserve">
          <source>These two lines of code find the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; we added to our HTML in the first step, and then display our &amp;ldquo;Like&amp;rdquo; button React component inside of it.</source>
          <target state="translated">이 두 줄의 코드 는 첫 번째 단계에서 HTML에 추가 한 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 를 찾은 다음 &quot;좋아요&quot;버튼 React 구성 요소를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4a0587ca694e69794c117c641540939e9bf9ef81" translate="yes" xml:space="preserve">
          <source>Think of &lt;code&gt;setState()&lt;/code&gt; as a &lt;em&gt;request&lt;/em&gt; rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 를 구성 요소를 업데이트하기위한 즉각적인 명령이 아니라 &lt;em&gt;요청&lt;/em&gt; 으로 생각하십시오 . 더 나은 인식 성능을 위해 React는 지연된 후 단일 구성으로 여러 구성 요소를 업데이트 할 수 있습니다. React는 상태 변경이 즉시 적용되도록 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82175a17958f607718d88007b35ef471a4c8a4fc" translate="yes" xml:space="preserve">
          <source>Think of all of the pieces of data in our example application. We have:</source>
          <target state="translated">예제 애플리케이션에서 모든 데이터를 생각해보십시오. 우리는 :</target>
        </trans-unit>
        <trans-unit id="a9605b9c41376c59380ce0d49a74b0c4e4dec5fc" translate="yes" xml:space="preserve">
          <source>Thinking in React</source>
          <target state="translated">반응으로 생각하기</target>
        </trans-unit>
        <trans-unit id="1ac9e8ec0e64fdd160c9350d87ed590c03f195a8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHub comment&lt;/a&gt; dives deep into the specific examples.</source>
          <target state="translated">이 &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHub 주석은&lt;/a&gt; 구체적인 예에 ​​대해 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="80ff15eb59c42a69211ff51d176242fbe4d315e0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;resource&lt;/code&gt; object represents the data that isn&amp;rsquo;t there yet, but might eventually get loaded. When we call &lt;code&gt;read()&lt;/code&gt;, we either get the data, or the component &amp;ldquo;suspends&amp;rdquo;.</source>
          <target state="translated">이 &lt;code&gt;resource&lt;/code&gt; 개체는 아직 존재하지 않지만 결국로드 될 수있는 데이터를 나타냅니다. &lt;code&gt;read()&lt;/code&gt; 호출 하면 데이터를 얻거나 구성 요소가 &quot;정지&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="476f561e8a18c3f9a07a3bccf37bcc7bf21f3874" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;inversion of control&lt;/em&gt; can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. However, this isn&amp;rsquo;t the right choice in every case: moving more complexity higher in the tree makes those higher-level components more complicated and forces the lower-level components to be more flexible than you may want.</source>
          <target state="translated">이러한 &lt;em&gt;제어 역전은&lt;/em&gt; 응용 프로그램을 통과하는 데 필요한 소품의 양을 줄이고 루트 구성 요소에 대한 제어를 강화하여 많은 경우 코드를 더 깨끗하게 만들 수 있습니다. 그러나 이것이 모든 경우에 올바른 선택은 아닙니다. 트리에서 더 복잡하게 이동하면 이러한 상위 구성 요소가 더 복잡해지고 하위 구성 요소가 원하는 것보다 더 유연 해집니다.</target>
        </trans-unit>
        <trans-unit id="c2d8fcc8f1d3d88cd2e77fadce662c854a2e0c6b" translate="yes" xml:space="preserve">
          <source>This API was introduced as a replacement of the deprecated &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt;.</source>
          <target state="translated">이 API는 더 이상 사용되지 않는 &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt; 대신 사용 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="65ff46d55592f673e6ce548bfba9bb56b9ccffbe" translate="yes" xml:space="preserve">
          <source>This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and function components. And because it&amp;rsquo;s a pure function, it&amp;rsquo;s composable with other HOCs, or even with itself.</source>
          <target state="translated">이 HOC는 충돌 가능성을 피하면서 변형 버전과 동일한 기능을 가지고 있습니다. 클래스 및 함수 구성 요소와 동일하게 작동합니다. 또한 순수한 기능이기 때문에 다른 HOC 또는 그 자체와도 조합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d22c37d9cec94e4690e2dd97d9efbf3bb2f8b371" translate="yes" xml:space="preserve">
          <source>This JavaScript syntax is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&amp;ldquo;array destructuring&amp;rdquo;&lt;/a&gt;. It means that we&amp;rsquo;re making two new variables &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;setFruit&lt;/code&gt;, where &lt;code&gt;fruit&lt;/code&gt; is set to the first value returned by &lt;code&gt;useState&lt;/code&gt;, and &lt;code&gt;setFruit&lt;/code&gt; is the second. It is equivalent to this code:</source>
          <target state="translated">이 JavaScript 구문을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&quot;배열 제거&quot;라고&lt;/a&gt; 합니다. 즉 , &lt;code&gt;fruit&lt;/code&gt; 는 &lt;code&gt;useState&lt;/code&gt; 에 의해 반환 된 첫 번째 값으로 설정 되고 &lt;code&gt;setFruit&lt;/code&gt; 는 두 번째로 새로운 &lt;code&gt;fruit&lt;/code&gt; 및 &lt;code&gt;setFruit&lt;/code&gt; 변수 를 만듭니다 . 이 코드와 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="f39d319ca5796008fa8e12b9089eeb33281858c9" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lag behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="translated">이를 통해 &lt;code&gt;input&lt;/code&gt; 대한 새 텍스트를 즉시 표시 할 수 있으므로 웹 페이지가 반응 적으로 느껴집니다. 한편 &lt;code&gt;MySlowList&lt;/code&gt; 는 업데이트 전 &lt;code&gt;timeoutMs&lt;/code&gt; 에 따라 최대 2 초 동안 &quot;지연&quot; 되어 백그라운드에서 현재 텍스트로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2faedabcd971bfb80a56e6a80e4761e335043c56" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lags behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="translated">This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lags behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</target>
        </trans-unit>
        <trans-unit id="7aada4a90bf5f5f9b0e68049574b4b5eb9269c5b" translate="yes" xml:space="preserve">
          <source>This also allows you to handle out-of-order responses with a local variable inside the effect:</source>
          <target state="translated">또한 이펙트 내에서 로컬 변수를 사용하여 비 순차 응답을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d31f740bc3cca1056bef47f761e3120ae5f4ad05" translate="yes" xml:space="preserve">
          <source>This also works for effects that have a cleanup phase:</source>
          <target state="translated">정리 단계가있는 효과에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c00c421c14ae8acb27703b9f15f007c9b9f49302" translate="yes" xml:space="preserve">
          <source>This also works for user-defined components:</source>
          <target state="translated">이것은 또한 사용자 정의 컴포넌트에서도 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="9dd47e6d4547b62faa16a4d7bcc454ad3c75bf3e" translate="yes" xml:space="preserve">
          <source>This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.</source>
          <target state="translated">이 접근 방식은 React의 선언적 API를 가능하게합니다. UI에 어떤 상태를 원하는지 React에 알리고 DOM이 해당 상태와 일치하는지 확인합니다. 앱 조작에 사용해야하는 속성 조작, 이벤트 처리 및 수동 DOM 업데이트를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="52a664b8479bda397f841c5ef66ce5073db36b03" translate="yes" xml:space="preserve">
          <source>This approach is fine for learning and creating simple demos. However, it makes your website slow and &lt;strong&gt;isn&amp;rsquo;t suitable for production&lt;/strong&gt;. When you&amp;rsquo;re ready to move forward, remove this new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attributes you&amp;rsquo;ve added. Instead, in the next section you will set up a JSX preprocessor to convert all your &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags automatically.</source>
          <target state="translated">이 방법은 간단한 데모를 배우고 만드는 데 적합합니다. 그러나 웹 사이트 속도 &lt;strong&gt;가&lt;/strong&gt; 느려서 &lt;strong&gt;제작에 적합하지 않습니다&lt;/strong&gt; . 계속 진행할 준비가되면이 새로운 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그와 추가 한 &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; 속성을 제거하십시오. 대신 다음 섹션에서는 모든 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 자동으로 변환하도록 JSX 프리 프로세서를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="dc7a58c1bb894f6665e299a7d4744f572f039148" translate="yes" xml:space="preserve">
          <source>This approach will work for our specific use case, but we haven&amp;rsquo;t achieved the objective of truly encapsulating the behavior in a reusable way. Now, every time we want the mouse position for a different use case, we have to create a new component (i.e. essentially another &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt;) that renders something specifically for that use case.</source>
          <target state="translated">이 접근 방식은 특정 사용 사례에 적합하지만 재사용 가능한 방식으로 동작을 실제로 캡슐화한다는 목표를 달성하지 못했습니다. 이제 우리는 다른 사용 사례에 대한 마우스 위치를 원할 때마다 해당 사용 사례를 위해 특별히 무언가를 렌더링 하는 새로운 구성 요소 (예 : 본질적으로 다른 &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt; )를 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2e57d12892a38e7dcd020760497cd1e93da0684e" translate="yes" xml:space="preserve">
          <source>This avoids creating an expensive object until it&amp;rsquo;s truly needed for the first time. If you use Flow or TypeScript, you can also give &lt;code&gt;getObserver()&lt;/code&gt; a non-nullable type for convenience.</source>
          <target state="translated">이렇게하면 처음으로 정말로 필요할 때까지 값 비싼 객체를 만들지 않아도됩니다. Flow 또는 TypeScript를 사용하는 경우 편의상 &lt;code&gt;getObserver()&lt;/code&gt; 에 널 입력 불가능 유형을 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4bfd1fe7162ecd3d60fc0279dd88e809b50adee" translate="yes" xml:space="preserve">
          <source>This behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.</source>
          <target state="translated">이 동작은 기본적으로 일관성을 보장하고 누락 된 업데이트 논리로 인해 클래스 구성 요소에서 일반적인 버그를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="57cd10a74bd70a6ee7ad4242517da20969dce195" translate="yes" xml:space="preserve">
          <source>This behavior is usually not relevant. It&amp;rsquo;s only mentioned here for completeness.</source>
          <target state="translated">이 동작은 일반적으로 관련이 없습니다. 완전성을 위해 여기에서만 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="36d268dd874440a54786b6aa3e4fd35dffcea642" translate="yes" xml:space="preserve">
          <source>This can be a problem with more complex data structures. For example, let&amp;rsquo;s say you want a &lt;code&gt;ListOfWords&lt;/code&gt; component to render a comma-separated list of words, with a parent &lt;code&gt;WordAdder&lt;/code&gt; component that lets you click a button to add a word to the list. This code does &lt;em&gt;not&lt;/em&gt; work correctly:</source>
          <target state="translated">보다 복잡한 데이터 구조에서는 문제가 될 수 있습니다. 예를 들어, &lt;code&gt;ListOfWords&lt;/code&gt; 구성 요소가 쉼표로 구분 된 단어 목록을 렌더링 하고 버튼을 클릭하여 목록에 단어를 추가 할 수 있는 상위 &lt;code&gt;WordAdder&lt;/code&gt; 구성 요소를 원한다고 가정 합니다. 이 코드는 올바르게 작동 하지 &lt;em&gt;않습니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="e3fd91e7d534e8d25e2851069fc549d8b17681ec" translate="yes" xml:space="preserve">
          <source>This can be useful to conditionally render React elements. This JSX renders the &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; component only if &lt;code&gt;showHeader&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">이는 React 요소를 조건부로 렌더링하는 데 유용 할 수 있습니다. 이 JSX 는 &lt;code&gt;showHeader&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; 구성 요소를 렌더링 합니다 .</target>
        </trans-unit>
        <trans-unit id="4cda35b9ac3d3dc1a2fb8d778758e7d5c8c67eb1" translate="yes" xml:space="preserve">
          <source>This can lead to a lot of repetitive code across components. This is why &lt;strong&gt;we generally recommend to bake &lt;code&gt;useTransition&lt;/code&gt; into the &lt;em&gt;design system&lt;/em&gt; components of your app&lt;/strong&gt;. For example, we can extract the transition logic into our own &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">이로 인해 구성 요소 전체에 많은 반복적 인 코드가 생길 수 있습니다. 이것이 &lt;strong&gt;일반적으로 &lt;code&gt;useTransition&lt;/code&gt; 을 앱 의 &lt;em&gt;디자인 시스템&lt;/em&gt; 구성 요소에 굽는 것이 좋습니다&lt;/strong&gt; . 예를 들어 전환 논리를 자체 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 구성 요소 로 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0acb8e50c6ec942725a3ba4829c748d2a76cb440" translate="yes" xml:space="preserve">
          <source>This change has an important implication. &lt;strong&gt;As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.&lt;/strong&gt;</source>
          <target state="translated">이 변경은 중요한 의미를 갖습니다. &lt;strong&gt;React 16부터는 오류 경계에서 발견되지 않은 오류로 인해 React 구성 요소 트리 전체가 마운트 해제됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45bd4df84d8256fb24d5cb41b9549c58035a0dac" translate="yes" xml:space="preserve">
          <source>This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong.</source>
          <target state="translated">이 변경은 React 16으로 마이그레이션 할 때 이전에 알려지지 않은 응용 프로그램의 기존 충돌을 발견 할 수 있음을 의미합니다. 오류 경계를 추가하면 문제가 발생할 때 더 나은 사용자 경험을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef0e2d23198ee6495349b5b1d8a65e07c969027" translate="yes" xml:space="preserve">
          <source>This code &lt;strong&gt;will not&lt;/strong&gt; work if you transform classes with Babel. See &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;this issue&lt;/a&gt; for the discussion. Include the &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapter&lt;/a&gt; before you load your web components to fix this issue.</source>
          <target state="translated">Babel로 클래스를 변환하면 이 코드 &lt;strong&gt;가&lt;/strong&gt; 작동 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 토론 은 &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오 . 이 문제를 해결하기 위해 웹 구성 요소를로드하기 전에 &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;사용자 정의 요소 -es5 어댑터&lt;/a&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="75a9a87d91df5d83f693447e427e9a52b32eb756" translate="yes" xml:space="preserve">
          <source>This code calls &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt;. But if the dependencies &lt;code&gt;[a, b]&lt;/code&gt; haven&amp;rsquo;t changed since the last value, &lt;code&gt;useMemo&lt;/code&gt; skips calling it a second time and simply reuses the last value it returned.</source>
          <target state="translated">이 코드는 &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt; 호출합니다 . 그러나 종속성 &lt;code&gt;[a, b]&lt;/code&gt; 가 마지막 값 이후로 변경되지 않은 경우, &lt;code&gt;useMemo&lt;/code&gt; 는 두 번째 호출을 건너 뛰고 반환 된 마지막 값을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="81c06c00fb945143b7361b0df45a46e15659b746" translate="yes" xml:space="preserve">
          <source>This code defines a React component called &lt;code&gt;LikeButton&lt;/code&gt;. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand it yet &amp;mdash; we&amp;rsquo;ll cover the building blocks of React later in our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;hands-on tutorial&lt;/a&gt; and &lt;a href=&quot;index&quot;&gt;main concepts guide&lt;/a&gt;. For now, let&amp;rsquo;s just get it showing on the screen!</source>
          <target state="translated">이 코드는 &lt;code&gt;LikeButton&lt;/code&gt; 이라는 React 컴포넌트를 정의합니다 . 아직 이해하지 않아도 걱정하지 마십시오. 나중에 &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;실습 튜토리얼&lt;/a&gt; 및 &lt;a href=&quot;index&quot;&gt;주요 개념 안내서&lt;/a&gt; 에서 React의 빌딩 블록을 다룰 것 입니다. 지금은 화면에 표시되도록하겠습니다!</target>
        </trans-unit>
        <trans-unit id="ec10d5aea9322aa37f3498ec1bf3e0477eec9989" translate="yes" xml:space="preserve">
          <source>This code displays a bullet list of numbers between 1 and 5.</source>
          <target state="translated">이 코드는 1과 5 사이의 글 머리 기호 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0909f97a53314c9c73d25a10366a5436355b5bcb" translate="yes" xml:space="preserve">
          <source>This code exposes the functionality to both pointer device and keyboard users. Also note the added &lt;code&gt;aria-*&lt;/code&gt; props to support screen-reader users. For simplicity&amp;rsquo;s sake the keyboard events to enable &lt;code&gt;arrow key&lt;/code&gt; interaction of the popover options have not been implemented.</source>
          <target state="translated">이 코드는 포인터 장치와 키보드 사용자 모두에게 기능을 제공합니다. 또한 화면 판독기 사용자를 지원하기 위해 추가 된 &lt;code&gt;aria-*&lt;/code&gt; 소품을 참고하십시오 . 간단하게하기 위해 팝 오버 옵션의 &lt;code&gt;arrow key&lt;/code&gt; 상호 작용 을 활성화하는 키보드 이벤트 는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d03bff01f1b2c1f0ab0a8b09ec93a5ca0ae8ec22" translate="yes" xml:space="preserve">
          <source>This code is deceptively easy to read.</source>
          <target state="translated">이 코드는 믿을 수 없을 정도로 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9c3f4795fe6fc80bbb24c51583253bdab9f12c27" translate="yes" xml:space="preserve">
          <source>This code is very readable, but unlike the examples earlier, the Suspense version doesn&amp;rsquo;t suffer from race conditions. You might be wondering why. The answer is that in the Suspense version, we don&amp;rsquo;t have to think about &lt;em&gt;time&lt;/em&gt; as much in our code. Our original code with race conditions needed to set the state &lt;em&gt;at the right moment later&lt;/em&gt;, or otherwise it would be wrong. But with Suspense, we set the state &lt;em&gt;immediately&lt;/em&gt; &amp;mdash; so it&amp;rsquo;s harder to mess it up.</source>
          <target state="translated">이 코드는 매우 읽기 쉽지만 이전 예제와 달리 Suspense 버전은 경쟁 조건이 없습니다. 왜 그런지 궁금 할 것입니다. 정답은 서스펜스 버전에서는 코드에서 &lt;em&gt;시간&lt;/em&gt; 에 대해 많이 생각할 필요가 없다는 것 입니다. 경쟁 조건을 가진 우리의 원래 코드는 &lt;em&gt;나중에 적절한 순간에&lt;/em&gt; 국가를 설정하는 데 필요 &lt;em&gt;했습니다&lt;/em&gt; . 그렇지 않으면 잘못되었을 것입니다. 그러나 Suspense를 사용하면 상태를 &lt;em&gt;즉시&lt;/em&gt; 설정 하므로 엉망으로 만드는 것이 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="aa231c70c510f0fa3b63aa156a3b29b91e637dfa" translate="yes" xml:space="preserve">
          <source>This code logs &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; to the console.</source>
          <target state="translated">이 코드는 &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; 을 콘솔에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6a6f4f287ca192e5cbaa9fe54b7458432ec57111" translate="yes" xml:space="preserve">
          <source>This code uses a &lt;code&gt;ref&lt;/code&gt; to store a reference to a DOM node:</source>
          <target state="translated">이 코드는 &lt;code&gt;ref&lt;/code&gt; 를 사용 하여 DOM 노드에 대한 참조 를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6a8d7c8fd298f61f6a8bbce768774e83c0634e4e" translate="yes" xml:space="preserve">
          <source>This command installs the latest version of Flow into your project.</source>
          <target state="translated">이 명령은 최신 버전의 Flow를 프로젝트에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="e2822f37a50da57c71f17598917890486aef2cbb" translate="yes" xml:space="preserve">
          <source>This command will create a Flow configuration file that you will need to commit.</source>
          <target state="translated">이 명령은 커밋해야하는 흐름 구성 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7e628fdea4b27c53ebdbd7cfcab1d2dfb0cb46e5" translate="yes" xml:space="preserve">
          <source>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let&amp;rsquo;s extract a few components from it.</source>
          <target state="translated">이 구성 요소는 모든 중첩으로 인해 변경하기 까다로울 수 있으며 개별 부분을 재사용하기도 어렵습니다. 그것에서 몇 가지 구성 요소를 추출합시다.</target>
        </trans-unit>
        <trans-unit id="9a4e11fd53e38859e2f4e904e8bc53c30f989275" translate="yes" xml:space="preserve">
          <source>This convention helps ensure that HOCs are as flexible and reusable as possible.</source>
          <target state="translated">이 규칙은 HOC가 최대한 유연하고 재사용 가능하도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="b994c283ac2682b4140498a38b7c06a032ede4f8" translate="yes" xml:space="preserve">
          <source>This demo is a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t quite make sense yet. We&amp;rsquo;ll talk more about how it works below. Keep in mind that Suspense is more of a &lt;em&gt;mechanism&lt;/em&gt;, and particular APIs like &lt;code&gt;fetchProfileData()&lt;/code&gt; or &lt;code&gt;resource.posts.read()&lt;/code&gt; in the above example are not very important. If you&amp;rsquo;re curious, you can find their definitions right in the &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;demo sandbox&lt;/a&gt;.</source>
          <target state="translated">이 데모는 티저입니다. 아직 이해가되지 않더라도 걱정하지 마십시오. 우리는 그것이 어떻게 작동하는지에 대해 더 이야기 할 것입니다. Suspense는 더 많은 &lt;em&gt;메커니즘&lt;/em&gt; 이며 위 예제의 &lt;code&gt;fetchProfileData()&lt;/code&gt; 또는 &lt;code&gt;resource.posts.read()&lt;/code&gt; 와 같은 특정 API 는 그다지 중요하지 않습니다. 궁금한 점이 있다면 &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;데모 샌드 박스&lt;/a&gt; 에서 해당 정의를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c154659e1f7cd40edb5f4f1f5bd3d6e54fcb386b" translate="yes" xml:space="preserve">
          <source>This document goes through the factors that can affect your environment and recommendations for some scenarios.</source>
          <target state="translated">이 문서는 환경에 영향을 줄 수있는 요소와 일부 시나리오에 대한 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35b8fd0fdad43cdb6f7a55761174dc27e6567773" translate="yes" xml:space="preserve">
          <source>This document will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.</source>
          <target state="translated">이 문서는 프레임 워크, 라이브러리 또는 개발자 툴링 작업을하는 개발자에게 가장 적합합니다. React를 주로 사용하여 사용자 용 응용 프로그램을 작성하는 개발자는 시험판 채널에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="435796402e94e0bfce47d4b1891156df1a181824" translate="yes" xml:space="preserve">
          <source>This documentation always reflects the latest stable version of React. Since React 16, you can find older versions of the documentation on a &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;separate page&lt;/a&gt;. Note that documentation for past versions is snapshotted at the time of the release, and isn&amp;rsquo;t being continuously updated.</source>
          <target state="translated">이 문서는 항상 최신 안정 버전의 React를 반영합니다. React 16부터는 &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;별도의 페이지&lt;/a&gt; 에서 이전 버전의 문서를 찾을 수 있습니다 . 이전 버전에 대한 설명서는 릴리스 당시 스냅 샷이며 지속적으로 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f71278bd00ce0cd4a740cd181d9c507c3a29e6b" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now.</source>
          <target state="translated">이 문서는 얼리 어답터와 궁금한 사람들을 대상으로합니다. &lt;strong&gt;React를 처음 사용하는 경우 이러한 기능에 대해 걱정할&lt;/strong&gt; 필요가 없습니다. 바로 지금 배울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="437152ef0fb92cb09cfcc08f167fa7c209605af6" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now. For example, if you&amp;rsquo;re looking for a data fetching tutorial that works today, read &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; instead.</source>
          <target state="translated">이 문서는 얼리 어답터와 궁금한 사람들을 대상으로합니다. &lt;strong&gt;React를 처음 사용하는 경우 이러한 기능에 대해 걱정할&lt;/strong&gt; 필요가 없습니다. 바로 지금 배울 필요가 없습니다. 예를 들어, 오늘 작동하는 데이터 가져 오기 자습서를 찾고 있다면 대신 &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;이 기사&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b3b7a9dc3eaa0b9d881ea28d247bfcc301b885f9" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of scope of this section.</source>
          <target state="translated">이 문서 섹션은 첫 번째 경우의 테스트 전략에 중점을 둡니다. 전체 종단 간 테스트는 중요한 워크 플로로의 회귀를 방지하는 데 매우 유용 할 수 있지만 이러한 테스트는 특히 React 구성 요소와 관련이 없으며이 섹션의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="3240812f318bd40bfe50a481d020711afec7ad2b" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of the scope of this section.</source>
          <target state="translated">This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of the scope of this section.</target>
        </trans-unit>
        <trans-unit id="922990d6659447b8f59207b30b32f18ac5da5266" translate="yes" xml:space="preserve">
          <source>This documentation section is useful when you want to learn more details about a particular React API. For example, &lt;a href=&quot;react-component&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt; API reference&lt;/a&gt; can provide you with details on how &lt;code&gt;setState()&lt;/code&gt; works, and what different lifecycle methods are useful for.</source>
          <target state="translated">이 문서 섹션은 특정 React API에 대한 자세한 내용을 배우려는 경우에 유용합니다. 예를 들어 &lt;a href=&quot;react-component&quot;&gt; &lt;code&gt;React.Component&lt;/code&gt; API 참조&lt;/a&gt; 는 &lt;code&gt;setState()&lt;/code&gt; 작동 방식과 다른 수명주기 메소드 에 대한 세부 사항을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0fc508cf47e625d8de371f53892327cc9e9bdd" translate="yes" xml:space="preserve">
          <source>This does not mean it is impossible or even necessarily difficult to combine React with other ways of affecting the DOM, you just have to be mindful of what each is doing.</source>
          <target state="translated">이것은 React를 DOM에 영향을 미치는 다른 방법과 결합하는 것이 불가능하거나 반드시 어렵다는 것을 의미하지는 않으며, 각각의 행동을 염두에 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8276e9f3cf97b98c079c64319a9395bb85c298e" translate="yes" xml:space="preserve">
          <source>This enables a better &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;error handling experience&lt;/a&gt; in React 16 and later.</source>
          <target state="translated">이를 통해 React 16 이상에서 &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;오류 처리 경험&lt;/a&gt; 이 향상 됩니다.</target>
        </trans-unit>
        <trans-unit id="6271e95bb91f56ffa298799cf7094cffbc64f6c4" translate="yes" xml:space="preserve">
          <source>This ensures, for example, that if both &lt;code&gt;Parent&lt;/code&gt; and &lt;code&gt;Child&lt;/code&gt; call &lt;code&gt;setState&lt;/code&gt; during a click event, &lt;code&gt;Child&lt;/code&gt; isn&amp;rsquo;t re-rendered twice. Instead, React &amp;ldquo;flushes&amp;rdquo; the state updates at the end of the browser event. This results in significant performance improvements in larger apps.</source>
          <target state="translated">예를 들어 click 이벤트 중에 &lt;code&gt;Parent&lt;/code&gt; 와 &lt;code&gt;Child&lt;/code&gt; 가 &lt;code&gt;setState&lt;/code&gt; 를 호출 하면 &lt;code&gt;Child&lt;/code&gt; 가 두 번 다시 렌더링되지 않습니다. 대신 React는 브라우저 이벤트가 끝날 때 상태 업데이트를 &quot;플러시&quot;합니다. 이로 인해 더 큰 앱에서 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="eee2a3b437fecc5c5822dcc3a1aa7661967a85bb" translate="yes" xml:space="preserve">
          <source>This example is modified for hooks from a previous example in the &lt;a href=&quot;context&quot;&gt;Context Advanced Guide&lt;/a&gt;, where you can find more information about when and how to use Context.</source>
          <target state="translated">이 예제는 &lt;a href=&quot;context&quot;&gt;컨텍스트 고급 안내서&lt;/a&gt; 의 이전 예제에서 가져온 후크에 맞게 수정되어 컨텍스트 사용시기 및 방법에 대한 자세한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46bc9849fafc7153a5665495ec0e17727641f27f" translate="yes" xml:space="preserve">
          <source>This example renders a counter. When you click the button, it increments the value:</source>
          <target state="translated">이 예제는 카운터를 렌더링합니다. 버튼을 클릭하면 값이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="25d9404a127c52ed8d6407f955450a6c3892e5d8" translate="yes" xml:space="preserve">
          <source>This example renders a different greeting depending on the value of &lt;code&gt;isLoggedIn&lt;/code&gt; prop.</source>
          <target state="translated">이 예에서는 &lt;code&gt;isLoggedIn&lt;/code&gt; prop 값에 따라 다른 인사말을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="b723244ac7769f9d42bc741d1cc7c26e97275391" translate="yes" xml:space="preserve">
          <source>This feature was added to JavaScript in ES2018.</source>
          <target state="translated">This feature was added to JavaScript in ES2018.</target>
        </trans-unit>
        <trans-unit id="9fa578e3db7433d9dce5a039b28793d6ebc08f28" translate="yes" xml:space="preserve">
          <source>This feels a lot better! Clicking &amp;ldquo;Refresh&amp;rdquo; doesn&amp;rsquo;t pull us away from the page we&amp;rsquo;re browsing anymore. We see something is loading &amp;ldquo;inline&amp;rdquo;, and when the data is ready, it&amp;rsquo;s displayed.</source>
          <target state="translated">이것은 훨씬 나아졌습니다! &quot;새로 고침&quot;을 클릭해도 더 이상 탐색중인 페이지에서 벗어날 수 없습니다. 무언가가 &quot;인라인&quot;으로 로딩되고 데이터가 준비되면 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="53a0f3e6dfc92e9db69114ebee6eb233f6ffcd07" translate="yes" xml:space="preserve">
          <source>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it&amp;rsquo;s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called &amp;ldquo;controlled components&amp;rdquo;.</source>
          <target state="translated">이 양식에는 사용자가 양식을 제출할 때 새 페이지를 탐색하는 기본 HTML 양식 동작이 있습니다. React 에서이 동작을 원하면 작동합니다. 그러나 대부분의 경우 양식 제출을 처리하고 사용자가 양식에 입력 한 데이터에 액세스 할 수있는 JavaScript 함수를 사용하는 것이 편리합니다. 이를 달성하기위한 표준 방법은 &quot;제어 된 구성 요소&quot;라는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="ab7820f59467fdd32ce070f1b80bfd31db68d1ae" translate="yes" xml:space="preserve">
          <source>This form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the &lt;code&gt;connect&lt;/code&gt; function have the signature &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt;. Functions whose output type is the same as its input type are really easy to compose together.</source>
          <target state="translated">이 양식은 혼란 스럽거나 불필요 해 보이지만 유용한 속성이 있습니다. &lt;code&gt;connect&lt;/code&gt; 함수가 리턴 한 것과 같은 단일 인수 HOC 에는 서명 &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt; 있습니다. 출력 유형이 입력 유형과 동일한 기능은 실제로 작성하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cb9e95f2893a4866bae321fd4e53d2d167c573c0" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;setState()&lt;/code&gt; is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:</source>
          <target state="translated">이 형식의 &lt;code&gt;setState()&lt;/code&gt; 도 비동기식이며 동일한주기 동안 여러 호출을 일괄 처리 할 수 ​​있습니다. 예를 들어, 동일한주기에서 품목 수량을 두 번 이상 늘리려 고하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42fc90231014ca33898b042e3cf5d5166ecf1c1c" translate="yes" xml:space="preserve">
          <source>This function is a valid React component because it accepts a single &amp;ldquo;props&amp;rdquo; (which stands for properties) object argument with data and returns a React element. We call such components &amp;ldquo;function components&amp;rdquo; because they are literally JavaScript functions.</source>
          <target state="translated">이 함수는 데이터와 함께 단일 &quot;props&quot;(속성) 객체 인수를 받아들이고 React 요소를 반환하므로 유효한 React 구성 요소입니다. 이러한 구성 요소는 문자 그대로 JavaScript 함수이므로 &quot;기능 구성 요소&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ebc1a8ba6d4628a8a3c7196192f99a87a1bd99af" translate="yes" xml:space="preserve">
          <source>This funny tag syntax is neither a string nor HTML.</source>
          <target state="translated">이 재미있는 태그 구문은 문자열이나 HTML이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4443039824b2698985c389ddf03cc24cafe1255b" translate="yes" xml:space="preserve">
          <source>This gets at the root of what Concurrent Mode is. We&amp;rsquo;ve &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;previously said&lt;/a&gt; it&amp;rsquo;s a bit like React working on state update on a &amp;ldquo;branch&amp;rdquo;. Another way we can conceptualize is that wrapping a state update in &lt;code&gt;startTransition&lt;/code&gt; begins rendering it &lt;em&gt;&amp;ldquo;in a different universe&amp;rdquo;&lt;/em&gt;, much like in science fiction movies. We don&amp;rsquo;t &amp;ldquo;see&amp;rdquo; that universe directly &amp;mdash; but we can get a signal from it that tells us something is happening (&lt;code&gt;isPending&lt;/code&gt;). When the update is ready, our &amp;ldquo;universes&amp;rdquo; merge back together, and we see the result on the screen!</source>
          <target state="translated">이것은 동시 모드의 근본입니다. 우리는 &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;이전에&lt;/a&gt; React가&amp;ldquo;브랜치&amp;rdquo;의 상태 업데이트 작업과 비슷 하다고 말했습니다 . 우리가 개념화 할 수있는 또 다른 방법은 &lt;code&gt;startTransition&lt;/code&gt; 에서 상태 업데이트를 래핑하여 공상 과학 영화에서와 같이 &lt;em&gt;&quot;다른 우주에서&quot;&lt;/em&gt; 렌더링하기 시작한다는 것입니다. 우리는 그 우주를 직접&amp;ldquo;보지&amp;rdquo;않습니다 &amp;ndash; 그러나 우리는 무언가가 일어나고 있다는 것을 알려주는 신호를 얻을 수 있습니다 ( &lt;code&gt;isPending&lt;/code&gt; ). 업데이트가 준비되면 &quot;유니버스&quot;가 다시 병합되고 화면에 결과가 표시됩니다!</target>
        </trans-unit>
        <trans-unit id="998f34489f4bb64d39d8842ae0c316430832dd96" translate="yes" xml:space="preserve">
          <source>This guide is designed for people who prefer &lt;strong&gt;learning concepts step by step&lt;/strong&gt;. If you prefer to learn by doing, check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. You might find this guide and the tutorial complementary to each other.</source>
          <target state="translated">이 안내서는 &lt;strong&gt;학습 개념을 단계별로&lt;/strong&gt; 선호하는 사람들을 위해 만들어 &lt;strong&gt;졌습니다&lt;/strong&gt; . 수행하여 배우기를 선호하는 경우 &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;실용적인 자습서를&lt;/a&gt; 확인하십시오 . 이 안내서와 학습서가 서로 보완적인 것을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a85cf72b8fe4c4bfdcedf2d7561fb56fd2aca5d8" translate="yes" xml:space="preserve">
          <source>This guide occasionally uses some of the newer JavaScript syntax in the examples. If you haven&amp;rsquo;t worked with JavaScript in the last few years, &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;these three points&lt;/a&gt; should get you most of the way.</source>
          <target state="translated">이 안내서는 때때로 예제에서 최신 JavaScript 구문 중 일부를 사용합니다. 지난 몇 년 동안 JavaScript를 사용해 본 적이 없다면 &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;이 세 가지 사항&lt;/a&gt; 을 최대한 활용할 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="81e4ce45e3f3a7f95f58bb8c19a35f09c68f268f" translate="yes" xml:space="preserve">
          <source>This has an interesting implication. Even if we use a GraphQL client that collects all data requirements in a single request, &lt;em&gt;streaming the response lets us show more content sooner&lt;/em&gt;. Because we render-&lt;em&gt;as-we-fetch&lt;/em&gt; (as opposed to &lt;em&gt;after&lt;/em&gt; fetching), if &lt;code&gt;user&lt;/code&gt; appears in the response earlier than &lt;code&gt;posts&lt;/code&gt;, we&amp;rsquo;ll be able to &amp;ldquo;unlock&amp;rdquo; the outer &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary before the response even finishes. We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering. Suspense doesn&amp;rsquo;t inherently suffer from this waterfall, and libraries like Relay take advantage of this.</source>
          <target state="translated">이것은 흥미로운 의미가 있습니다. 단일 요청으로 모든 데이터 요구 사항을 수집하는 GraphQL 클라이언트를 사용하더라도 &lt;em&gt;응답을 스트리밍하면 더 많은 콘텐츠를 더 빨리 표시 할 수 있습니다&lt;/em&gt; . &lt;em&gt;우리가 가져 오기로&lt;/em&gt; 렌더링하기 때문에 ( 가져 오기 &lt;em&gt;후&lt;/em&gt; 와 반대로 ), &lt;code&gt;user&lt;/code&gt; 가 &lt;code&gt;posts&lt;/code&gt; 이전의 응답에 나타나는 경우 응답이 끝나기 전에 외부 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계 를 &quot;잠금 해제&quot;할 수 있습니다 . 우리는 이것을 이전에 놓쳤을지도 모르지만, 페치-렌더 솔루션에는 페치와 렌더링 사이의 폭포가 포함되어 있습니다. 서스펜스는 본질적으로이 폭포를 겪지 않으며, Relay와 같은 라이브러리가이를 활용합니다.</target>
        </trans-unit>
        <trans-unit id="ff59847832eda94cc856a80d664ae3e8945e2a20" translate="yes" xml:space="preserve">
          <source>This helper is considered legacy, and we encourage you to either use JSX or use &lt;code&gt;React.createElement()&lt;/code&gt; directly instead.</source>
          <target state="translated">이 헬퍼는 레거시로 간주되므로 JSX를 사용하거나 대신 &lt;code&gt;React.createElement()&lt;/code&gt; 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="45b88d2165ef4f3c9c1467a053131dbd114d3bd3" translate="yes" xml:space="preserve">
          <source>This helps make your tests run closer to what real users would experience when using your application. The rest of these examples use &lt;code&gt;act()&lt;/code&gt; to make these guarantees.</source>
          <target state="translated">따라서 응용 프로그램을 사용할 때 실제 사용자가 경험할 수있는 수준에 가까운 테스트를 실행할 수 있습니다. 이 예제의 나머지 부분에서는 &lt;code&gt;act()&lt;/code&gt; 를 사용하여 이러한 보장을합니다.</target>
        </trans-unit>
        <trans-unit id="812baa4dde898829de6f1ec51ca212cbe1c227c1" translate="yes" xml:space="preserve">
          <source>This illustrates how UI libraries, including React, typically work today. Once they start rendering an update, including creating new DOM nodes and running the code inside components, they can&amp;rsquo;t interrupt this work. We&amp;rsquo;ll call this approach &amp;ldquo;blocking rendering&amp;rdquo;.</source>
          <target state="translated">이것은 오늘날 React를 포함한 UI 라이브러리가 어떻게 작동하는지 보여줍니다. 새로운 DOM 노드 생성 및 구성 요소 내에서 코드 실행을 포함하여 업데이트 렌더링을 시작하면이 작업을 중단 할 수 없습니다. 우리는이 접근법을&amp;ldquo;차단 렌더링&amp;rdquo;이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="fa7d8e8505d96d032001acde26d204de1f9b82ac" translate="yes" xml:space="preserve">
          <source>This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing &lt;em&gt;React tree&lt;/em&gt;, even if those elements are not ancestors in the &lt;em&gt;DOM tree&lt;/em&gt;. Assuming the following HTML structure:</source>
          <target state="translated">여기에는 이벤트 버블 링이 포함됩니다. 포털 내부에서 발생한 이벤트 는 &lt;em&gt;DOM 트리&lt;/em&gt; 에서 해당 요소가 조상이 아니더라도 포함하는 &lt;em&gt;React 트리의&lt;/em&gt; 조상에게 전파됩니다 . 다음 HTML 구조를 가정합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99dc48109b6cce011425c20dc166b6aaf5634758" translate="yes" xml:space="preserve">
          <source>This is a bit simplified, and in practice solutions tend to use a mix of different approaches. Still, we will look at them in isolation to better contrast their tradeoffs.</source>
          <target state="translated">이것은 약간 단순화되었으며 실제로 솔루션은 다른 접근법을 혼합하여 사용하는 경향이 있습니다. 그럼에도 불구하고 우리는 그들의 절충을 더 잘 대비하기 위해 그것들을 고립 된 상태로 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="f354ebc1c8de6bed11d9fe920271b4b204cffba6" translate="yes" xml:space="preserve">
          <source>This is a rare use case. If you need it, you can &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;use a mutable ref&lt;/a&gt; to manually store a boolean value corresponding to whether you are on the first or a subsequent render, then check that flag in your effect. (If you find yourself doing this often, you could create a custom Hook for it.)</source>
          <target state="translated">이것은 드문 사용 사례입니다. 필요한 경우 &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;변경 가능한 참조&lt;/a&gt; 를 사용 하여 첫 번째 또는 후속 렌더링에 있는지 여부에 해당하는 부울 값을 수동으로 저장 한 다음 효과에서 해당 플래그를 확인할 수 있습니다. 이 작업을 자주 수행하는 경우 사용자 지정 후크를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75075312cba14b3581378e03695ec96938d319ac" translate="yes" xml:space="preserve">
          <source>This is a rather convoluted pattern but it shows that you can do this escape hatch optimization if you need it. It&amp;rsquo;s more bearable if you extract it to a custom Hook:</source>
          <target state="translated">이것은 다소 복잡한 패턴이지만 필요한 경우이 탈출 해치 최적화를 수행 할 수 있음을 보여줍니다. 사용자 정의 후크로 추출하면 더 견딜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5227f8717f5136bb9804d5f23e2236aefaabea00" translate="yes" xml:space="preserve">
          <source>This is also &lt;strong&gt;the easiest way to integrate React into an existing website.&lt;/strong&gt; You can always add a larger toolchain if you find it helpful!</source>
          <target state="translated">이것은 또한 &lt;strong&gt;React를 기존 웹 사이트에 통합하는 가장 쉬운 방법입니다. &lt;/strong&gt;도움이된다면 언제든지 더 큰 툴체인을 추가 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="23555155fd49eb625fe9b6ee74d6f52738cd077a" translate="yes" xml:space="preserve">
          <source>This is an implementation detail so avoid relying on it directly. In the future versions, React will batch updates by default in more cases.</source>
          <target state="translated">이것은 구현 세부 사항이므로 직접 의존하지 마십시오. 이후 버전에서 React는 더 많은 경우 기본적으로 업데이트를 일괄 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3a3631bbcc581acd6fff6b114d111cf6ae38309c" translate="yes" xml:space="preserve">
          <source>This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render &amp;mdash; but React class components don&amp;rsquo;t have a method like this. We could extract a separate method but we would still have to call it in two places.</source>
          <target state="translated">대부분의 경우 구성 요소가 방금 마운트되었는지 또는 업데이트되었는지에 관계없이 동일한 부작용을 수행하기를 원하기 때문입니다. 개념적으로 우리는 매 렌더링마다 발생하기를 원하지만 React 클래스 컴포넌트에는 이와 같은 메소드가 없습니다. 별도의 메소드를 추출 할 수는 있지만 여전히 두 곳에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="94660750769ee2d6cb7338105b6ef20240dc1dbe" translate="yes" xml:space="preserve">
          <source>This is because when we update a state variable, we &lt;em&gt;replace&lt;/em&gt; its value. This is different from &lt;code&gt;this.setState&lt;/code&gt; in a class, which &lt;em&gt;merges&lt;/em&gt; the updated fields into the object.</source>
          <target state="translated">이는 상태 변수를 업데이트 할 때 해당 값 을 &lt;em&gt;대체하기&lt;/em&gt; 때문입니다. 이것은 업데이트 된 필드를 객체로 &lt;em&gt;병합&lt;/em&gt; 하는 클래스의 &lt;code&gt;this.setState&lt;/code&gt; 와 다릅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a47325c97eec71b52ae248148cefc0b2a8e23dc" translate="yes" xml:space="preserve">
          <source>This is both more convenient from the maintenance perspective (no need to keep forwarding callbacks), and avoids the callback problem altogether. Passing &lt;code&gt;dispatch&lt;/code&gt; down like this is the recommended pattern for deep updates.</source>
          <target state="translated">이는 유지 관리 측면에서 더 편리하고 (콜백을 계속 전달할 필요가 없음) 콜백 문제를 방지합니다. 이와 같이 &lt;code&gt;dispatch&lt;/code&gt; 전달하면 깊은 업데이트에 권장되는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="78dce35fd65045b02f21fbe73c4f3d79910e2283" translate="yes" xml:space="preserve">
          <source>This is commonly called a &amp;ldquo;top-down&amp;rdquo; or &amp;ldquo;unidirectional&amp;rdquo; data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components &amp;ldquo;below&amp;rdquo; them in the tree.</source>
          <target state="translated">이를 일반적으로 &quot;하향식&quot;또는 &quot;단방향&quot;데이터 흐름이라고합니다. 모든 상태는 항상 특정 구성 요소가 소유하며 해당 상태에서 파생 된 모든 데이터 또는 UI는 트리에서 구성 요소 아래에있는 구성 요소에만 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f263fdbfe4befbdbe35c83008d89219aa3bc1f80" translate="yes" xml:space="preserve">
          <source>This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.</source>
          <target state="translated">이것은 일반적으로 사용자 입력을 기반으로 즉시 렌더링되는 것과 데이터 가져 오기를 기다려야하는 것이있을 때 인터페이스를 반응 적으로 유지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f35b27d1c72a73a47404576ed9069707f86b93da" translate="yes" xml:space="preserve">
          <source>This is enough to get our component to render, but we also want to be notified about the value changes. To do this, we will subscribe to the jQuery &lt;code&gt;change&lt;/code&gt; event on the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; managed by Chosen.</source>
          <target state="translated">이것으로 구성 요소를 렌더링하기에 충분하지만 값 변경에 대한 알림을 받고 싶습니다. 이를 위해 Chosen이 관리 하는 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 의 jQuery &lt;code&gt;change&lt;/code&gt; 이벤트를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="76b2cd066ec6800da2e6fca46c1c5bc66a392c5d" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;.bind&lt;/code&gt;:</source>
          <target state="translated">이것은 &lt;code&gt;.bind&lt;/code&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d3c5bf674b9409038c85e451ead5b4000258b898" translate="yes" xml:space="preserve">
          <source>This is especially useful for data fetching. It is usually preferable to use &amp;ldquo;fake&amp;rdquo; data for tests to avoid the slowness and flakiness due to fetching from real API endpoints &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. This helps make the tests predictable. Libraries like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; and &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;, among others, support mocked functions. For end-to-end tests, mocking network can be more difficult, but you might also want to test the real API endpoints in them anyway.</source>
          <target state="translated">데이터 가져 오기에 특히 유용합니다. 실제 API 엔드 포인트 &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(&lt;/small&gt;&lt;/a&gt; 페치)에서 가져 오기로 인한 속도 저하 및 약점을 피하기 위해 테스트에 &quot;가짜&quot;데이터를 사용하는 것이 좋습니다 &lt;small&gt;(예)&lt;/small&gt; . 이를 통해 테스트를 예측할 수 있습니다. &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; 및 &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt; 과 같은 라이브러리는 모의 기능을 지원합니다. 엔드-투-엔드 테스트의 경우 네트워크 조롱이 더 어려울 수 있지만 실제 API 엔드 포인트도 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a0acb35ae332ccbc63c94a04c970a5a6662d52" translate="yes" xml:space="preserve">
          <source>This is not React-specific behavior; it is a part of &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;how functions work in JavaScript&lt;/a&gt;. Generally, if you refer to a method without &lt;code&gt;()&lt;/code&gt; after it, such as &lt;code&gt;onClick={this.handleClick}&lt;/code&gt;, you should bind that method.</source>
          <target state="translated">이것은 React 특정 동작이 아닙니다. &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;JavaScript에서 함수가 작동하는 방식&lt;/a&gt; 의 일부입니다 . 일반적 으로 &lt;code&gt;onClick={this.handleClick}&lt;/code&gt; 과 같이 &lt;code&gt;()&lt;/code&gt; 없이 메소드를 참조하는 경우 해당 메소드를 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="acd30756daf69694d4f232dd03c1bf787fd40f16" translate="yes" xml:space="preserve">
          <source>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</source>
          <target state="translated">이것은 종종 임의 길이의 JSX 표현식 목록을 렌더링하는 데 유용합니다. 예를 들어 HTML 목록을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="5a99ff5d36d8c6c9227545d3f9b811542fdf7a14" translate="yes" xml:space="preserve">
          <source>This is one example of many cases where depending on only pointer and mouse events will break functionality for keyboard users. Always testing with the keyboard will immediately highlight the problem areas which can then be fixed by using keyboard aware event handlers.</source>
          <target state="translated">이것은 포인터 및 마우스 이벤트에만 의존하여 키보드 사용자의 기능이 작동하지 않는 많은 경우의 한 예입니다. 항상 키보드로 테스트하면 키보드 인식 이벤트 핸들러를 사용하여 해결할 수있는 문제 영역이 즉시 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c45d9be4282e8391a17aca9ac958259838791726" translate="yes" xml:space="preserve">
          <source>This is the first chapter in a step-by-step guide about main React concepts. You can find a list of all its chapters in the navigation sidebar. If you&amp;rsquo;re reading this from a mobile device, you can access the navigation by pressing the button in the bottom right corner of your screen.</source>
          <target state="translated">이 문서는 주요 React 개념에 대한 단계별 가이드의 첫 번째 장입니다. 탐색 사이드 바에서 모든 장의 목록을 찾을 수 있습니다. 휴대 기기에서이 내용을 읽는 경우 화면 오른쪽 하단에있는 버튼을 눌러 탐색에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c25acae8adf4005a2b896567a72c2c799a087f8c" translate="yes" xml:space="preserve">
          <source>This is the only lifecycle method called on server rendering.</source>
          <target state="translated">이것은 서버 렌더링에서 호출되는 유일한 수명주기 방법입니다.</target>
        </trans-unit>
        <trans-unit id="81793ae769b5dc5c19104ac5a737a90042932a4e" translate="yes" xml:space="preserve">
          <source>This is typically implemented by attaching a &lt;code&gt;click&lt;/code&gt; event to the &lt;code&gt;window&lt;/code&gt; object that closes the popover:</source>
          <target state="translated">이것은 일반적으로 popover를 닫는 &lt;code&gt;window&lt;/code&gt; 객체에 &lt;code&gt;click&lt;/code&gt; 이벤트를 첨부하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a759a421b0f990ff09a818938bdffadcc8719ff" translate="yes" xml:space="preserve">
          <source>This is valid JSX, and &lt;code&gt;props.children&lt;/code&gt; in &lt;code&gt;MyComponent&lt;/code&gt; will simply be the string &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt;. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</source>
          <target state="translated">이 JSX 유효하며, &lt;code&gt;props.children&lt;/code&gt; 의 &lt;code&gt;MyComponent&lt;/code&gt; 단순히 문자열이 될 것이다 &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt; . HTML은 이스케이프 처리되지 않으므로 일반적으로 다음과 같이 HTML을 작성하는 것처럼 JSX를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c613ddcfbe3b097acdf335938f040949d7b413dc" translate="yes" xml:space="preserve">
          <source>This is why in React classes, we put side effects into &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:</source>
          <target state="translated">이것이 React 클래스에서 &lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; 에 부작용을 넣는 이유입니다 . 예제로 돌아가서, React가 DOM을 변경 한 직후에 문서 제목을 업데이트하는 React 카운터 클래스 구성 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c62ddb716217cd9d943db6e89f3da163d5211696" translate="yes" xml:space="preserve">
          <source>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</source>
          <target state="translated">그렇기 때문에 상태를 종종 로컬 또는 캡슐화라고합니다. 소유하고 설정 한 구성 요소 이외의 구성 요소에는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="18a571f38f03339764897ec37c93ff611f9faab0" translate="yes" xml:space="preserve">
          <source>This is why when we click the button, it feels like we&amp;rsquo;ve &amp;ldquo;taken a step back&amp;rdquo;. The &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary which was previously showing useful content (&lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt;) had to &amp;ldquo;recede&amp;rdquo; to showing the fallback (&lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt;). We call that a &lt;strong&gt;Receded&lt;/strong&gt; state.</source>
          <target state="translated">이것이 우리가 버튼을 클릭 할 때&amp;ldquo;한 단계 뒤로 물러 난&amp;rdquo;느낌입니다. &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계 이전 보여주는데 유용한 콘텐츠 ( &lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt; ) 대체를 보여주는에 &quot;떼&quot;에 있었다 ( &lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt; ). 이를 &lt;strong&gt;Receded&lt;/strong&gt; 상태 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="718eb18e387e45c3190a58540cc9769ac7b3487c" translate="yes" xml:space="preserve">
          <source>This lets other components pass arbitrary children to them by nesting the JSX:</source>
          <target state="translated">그러면 JSX를 중첩하여 다른 구성 요소가 임의의 자식을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8cee0a900fd1abfbf74aa34a43408d67133f7b3" translate="yes" xml:space="preserve">
          <source>This lets us know whether the &lt;em&gt;currently selected&lt;/em&gt; friend is online. If we pick a different friend and update the &lt;code&gt;recipientID&lt;/code&gt; state variable, our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.</source>
          <target state="translated">&lt;em&gt;현재 선택된&lt;/em&gt; 친구가 온라인 인지 알 수 있습니다. 다른 친구를 선택하고 &lt;code&gt;recipientID&lt;/code&gt; 상태 변수를 업데이트하면 &lt;code&gt;useFriendStatus&lt;/code&gt; Hook가 이전에 선택한 친구의 구독을 취소하고 새로 선택한 친구의 상태를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="17465f6f30cbbd158822bfd9a93d4e55ec625a26" translate="yes" xml:space="preserve">
          <source>This lets us simplify &lt;code&gt;Comment&lt;/code&gt; even further:</source>
          <target state="translated">이를 통해 &lt;code&gt;Comment&lt;/code&gt; 을 더욱 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2145d5b7dc2e2f3be97d96fbee1e1d4c248b4f29" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.</source>
          <target state="translated">이 수명주기는 하위 구성 요소에 의해 오류가 발생한 후 호출됩니다. 매개 변수로 발생한 오류를 수신하고 값을 업데이트 상태로 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="968ffe95e9be91c36d5595d98ef8add12caa0d69" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:</source>
          <target state="translated">이 수명주기는 하위 구성 요소에 의해 오류가 발생한 후 호출됩니다. 두 개의 매개 변수를받습니다.</target>
        </trans-unit>
        <trans-unit id="594ba927ec8ab8edb9aadc0d0584d8c6c365a647" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillMount&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">이 라이프 사이클은 이전에 &lt;code&gt;componentWillMount&lt;/code&gt; 로 이름이 지정되었습니다 . 이 이름은 버전 17까지 계속 작동합니다. &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; 를 사용하여 구성 요소를 자동으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6588d01fe985f33b6111c5dd3aa724cc493cfaf0" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillReceiveProps&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">이 라이프 사이클은 이전에 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 로 이름이 지정되었습니다 . 이 이름은 버전 17까지 계속 작동합니다. &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; 를 사용하여 구성 요소를 자동으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="94637589013bd1046cc3548741fa19cadd64d909" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillUpdate&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="translated">이 수명주기는 이전에 &lt;code&gt;componentWillUpdate&lt;/code&gt; 로 이름이 지정되었습니다 . 이 이름은 버전 17까지 계속 작동합니다. &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt; &lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; 를 사용하여 구성 요소를 자동으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c80a55eed22ae85461d3cfcaba922c6522694d" translate="yes" xml:space="preserve">
          <source>This makes sense in the vast majority of situations. Inconsistent UI is confusing and can mislead users. (For example, it would be terrible if a messenger&amp;rsquo;s Send button and the conversation picker pane &amp;ldquo;disagreed&amp;rdquo; about which thread is currently selected.)</source>
          <target state="translated">이것은 대부분의 상황에서 의미가 있습니다. 일관성이없는 UI가 혼동되어 사용자를 오도 할 수 있습니다. 예를 들어, 메신저의 보내기 단추와 대화 선택기 창이 현재 선택된 스레드에 대해 &quot;실패한&quot;경우에는 끔찍할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef24e13773cbfa21de17ac04cc277350c44f1c93" translate="yes" xml:space="preserve">
          <source>This may work fine for users with pointer devices, such as a mouse, but operating this with the keyboard alone leads to broken functionality when tabbing to the next element as the &lt;code&gt;window&lt;/code&gt; object never receives a &lt;code&gt;click&lt;/code&gt; event. This can lead to obscured functionality which blocks users from using your application.</source>
          <target state="translated">이것은 마우스와 같은 포인터 장치를 사용하는 사용자에게는 잘 작동하지만 키보드만으로 이것을 조작하면 &lt;code&gt;window&lt;/code&gt; 개체가 &lt;code&gt;click&lt;/code&gt; 이벤트를 수신하지 않으므로 다음 요소를 탭할 때 기능이 손상됩니다 . 이로 인해 사용자가 응용 프로그램을 사용하지 못하게하는 기능이 가려 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ab2af6f9d4c72cf5bf3ee19ce9e396909f22dc" translate="yes" xml:space="preserve">
          <source>This means that refs intended for our &lt;code&gt;FancyButton&lt;/code&gt; component will actually be attached to the &lt;code&gt;LogProps&lt;/code&gt; component:</source>
          <target state="translated">이는 &lt;code&gt;FancyButton&lt;/code&gt; 구성 요소 에 대한 참조 가 실제로 LogProps 구성 요소에 첨부 &lt;code&gt;LogProps&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="20cdec50ca2bbe2c60a25c71a851df8e68f79fdd" translate="yes" xml:space="preserve">
          <source>This means that you can use JSX inside of &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops, assign it to variables, accept it as arguments, and return it from functions:</source>
          <target state="translated">즉, &lt;code&gt;if&lt;/code&gt; 문과 &lt;code&gt;for&lt;/code&gt; 루프 내에서 JSX를 사용 하고 변수에 할당하고 인수로 받아 들여 함수에서 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf58efcf63a028a41c47c43c10732e6a1a269f5" translate="yes" xml:space="preserve">
          <source>This means writing ES6 classes comes with a little more boilerplate code for event handlers, but the upside is slightly better performance in large applications.</source>
          <target state="translated">즉, ES6 클래스를 작성하면 이벤트 핸들러를위한 보일러 플레이트 코드가 조금 더 제공되지만 큰 응용 프로그램에서는 성능이 약간 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ccb7790fbe3b5adbb51adc314fe96e90f8b9bd" translate="yes" xml:space="preserve">
          <source>This method doesn&amp;rsquo;t have access to the component instance. If you&amp;rsquo;d like, you can reuse some code between &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; and the other class methods by extracting pure functions of the component props and state outside the class definition.</source>
          <target state="translated">이 메소드는 구성 요소 인스턴스에 액세스 할 수 없습니다. 원하는 경우 구성 요소 소품의 순수 함수와 클래스 정의 외부의 상태를 추출하여 &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; 와 다른 클래스 메서드 간에 일부 코드를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deaaaea3817236bf17270b39c61839a1ba533f0b" translate="yes" xml:space="preserve">
          <source>This method exists for &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;rare use cases&lt;/a&gt; where the state depends on changes in props over time. For example, it might be handy for implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component that compares its previous and next children to decide which of them to animate in and out.</source>
          <target state="translated">이 방법 은 상태가 시간이 지남에 따라 소품의 변화에 ​​의존하는 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;드문 사용 사례에&lt;/a&gt; 존재합니다 . 예를 들어, 이전 및 다음 자식을 비교하여 애니메이션을 적용 할 요소를 결정 하는 &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; 구성 요소 를 구현하는 것이 편리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="831ab868298258b184dc29308d4e3381f3bfdc48" translate="yes" xml:space="preserve">
          <source>This method is a good place to set up any subscriptions. If you do that, don&amp;rsquo;t forget to unsubscribe in &lt;code&gt;componentWillUnmount()&lt;/code&gt;.</source>
          <target state="translated">이 방법은 구독을 설정하기에 좋은 곳입니다. 그렇게하면 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 에서 구독을 취소해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4ab528114f0749b536a7ef2d3ed5cc959586f962" translate="yes" xml:space="preserve">
          <source>This method is called when a component is being removed from the DOM:</source>
          <target state="translated">이 메소드는 컴포넌트가 DOM에서 제거 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8d1ff3351a12658bbf9b29cefa88394ca0bb9811" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a render, as this can lead to bugs.</source>
          <target state="translated">이 방법은 &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;성능 최적화&lt;/a&gt;&lt;/strong&gt; 로만 존재합니다 &lt;strong&gt;. &lt;/strong&gt;버그를 일으킬 수 있으므로 렌더를&amp;ldquo;예방&amp;rdquo;하는 데 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ebb829156f7c61ef4acced6f34d456127053816e" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a rendering, as this can lead to bugs. &lt;strong&gt;Consider using the built-in &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;PureComponent&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand. &lt;code&gt;PureComponent&lt;/code&gt; performs a shallow comparison of props and state, and reduces the chance that you&amp;rsquo;ll skip a necessary update.</source>
          <target state="translated">이 방법은 &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;성능 최적화&lt;/a&gt;&lt;/strong&gt; 로만 존재합니다 &lt;strong&gt;. &lt;/strong&gt;버그를 일으킬 수 있으므로 렌더링을 &quot;예방&quot;하는 데 의존하지 마십시오. &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 를 직접 작성하는 대신 &lt;strong&gt;내장 &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;PureComponent&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt; 를 &lt;strong&gt;사용하는 &lt;/strong&gt;&lt;strong&gt;것이&lt;/strong&gt; 좋습니다 . &lt;code&gt;PureComponent&lt;/code&gt; 는 props와 state를 간략하게 비교하고 필요한 업데이트를 건너 뛸 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="ee800d90e38eaef10a7bc57aaa91d6a6506aa2cf" translate="yes" xml:space="preserve">
          <source>This might be a bit convoluted but you can extract it into a custom Hook:</source>
          <target state="translated">약간 복잡 할 수 있지만 사용자 정의 후크로 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e32186cfd473e2a105089ea30d4f98232d190b91" translate="yes" xml:space="preserve">
          <source>This might look strange at first, but an update during rendering is exactly what &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; has always been like conceptually.</source>
          <target state="translated">처음에는 이상하게 보일 수 있지만 렌더링 중 업데이트는 &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 가 항상 개념적으로 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef2cab890f08c2a76dbdff387f6da7cc1005dff6" translate="yes" xml:space="preserve">
          <source>This might seem like a lot to take in at first. Don&amp;rsquo;t rush it! If you&amp;rsquo;re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to &amp;ldquo;forget&amp;rdquo; how state works in classes, and look at this code with fresh eyes, it will make sense.</source>
          <target state="translated">처음에는 많은 것들이 필요할 것 같습니다. 서두르지 마십시오! 설명을 잃어버린 경우 위의 코드를 다시보고 위에서 아래로 읽으십시오. 우리는 일단 클래스에서 상태가 작동하는 방식을 &quot;잊어 버리고&quot;신선한 눈으로이 코드를 살펴보면 이해가 될 것이라고 약속합니다.</target>
        </trans-unit>
        <trans-unit id="d07825aa1cec991e99499e19669c9ccceb78fe54" translate="yes" xml:space="preserve">
          <source>This new function &lt;code&gt;useState&lt;/code&gt; is the first &amp;ldquo;Hook&amp;rdquo; we&amp;rsquo;ll learn about, but this example is just a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make sense yet!</source>
          <target state="translated">이 새로운 함수 &lt;code&gt;useState&lt;/code&gt; 는 우리가 배울 첫 번째 &quot;후크&quot;이지만이 예제는 티저 일뿐입니다. 아직 이해가되지 않더라도 걱정하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="e3a722c80ed9c76ca1113dc4457219ac30784908" translate="yes" xml:space="preserve">
          <source>This only applies to development mode. &lt;em&gt;Lifecycles will not be double-invoked in production mode.&lt;/em&gt;</source>
          <target state="translated">이것은 개발 모드에만 적용됩니다. &lt;em&gt;라이프 사이클은 프로덕션 모드에서 이중 호출되지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4350c5287a7a2684318bbc298f11388e35c98227" translate="yes" xml:space="preserve">
          <source>This package provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.</source>
          <target state="translated">이 패키지는 DOM 또는 기본 모바일 환경에 의존하지 않고 React 컴포넌트를 순수한 JavaScript 객체로 렌더링하는 데 사용할 수있는 React 렌더러를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8402b5bdda223e1895c6750dabf232de29a825ec" translate="yes" xml:space="preserve">
          <source>This page answers some of the frequently asked questions about &lt;a href=&quot;hooks-overview&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;hooks-overview&quot;&gt;후크&lt;/a&gt; 에 대해 자주 묻는 질문에 대한 답변 입니다.</target>
        </trans-unit>
        <trans-unit id="34334d5085c7858cfe5a0f8a0877627d68a2b7b4" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;re using &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; as a test runner. If you use a different test runner, you may need to adjust the API, but the overall shape of the solution will likely be the same. Read more details on setting up a testing environment on the &lt;a href=&quot;testing-environments&quot;&gt;Testing Environments&lt;/a&gt; page.</source>
          <target state="translated">이 페이지에서는 &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; 를 테스트 러너로 사용한다고 가정합니다 . 다른 테스트 러너를 사용하는 경우 API를 조정해야 할 수도 있지만 솔루션의 전체 모양이 동일 할 수 있습니다. 테스트 환경 설정에 대한 자세한 내용은 &lt;a href=&quot;testing-environments&quot;&gt;테스트 환경&lt;/a&gt; 페이지에서 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3a166d200254a5d8e02bad9a5106cd778d917587" translate="yes" xml:space="preserve">
          <source>This page contains a detailed API reference for the React component class definition. It assumes you&amp;rsquo;re familiar with fundamental React concepts, such as &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt;, as well as &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt;. If you&amp;rsquo;re not, read them first.</source>
          <target state="translated">이 페이지에는 React 컴포넌트 클래스 정의에 대한 자세한 API 참조가 있습니다. &lt;a href=&quot;state-and-lifecycle&quot;&gt;State 및 Lifecycle&lt;/a&gt; 뿐만 아니라 &lt;a href=&quot;components-and-props&quot;&gt;Components 및 Props&lt;/a&gt; 와 같은 기본 React 개념에 익숙하다고 가정합니다 . 그렇지 않다면 먼저 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="5b013d41bce54d9463c50238174c350420a86fd1" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;not yet available&lt;/a&gt; in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">이 페이지 &lt;strong&gt;&lt;a href=&quot;concurrent-mode-adoption&quot;&gt;에서는 아직&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 안정된 릴리스에서는 &lt;/strong&gt;&lt;strong&gt;사용할 수없는&lt;/strong&gt;&lt;strong&gt; 실험 기능에&lt;/strong&gt; 대해 설명 합니다. 프로덕션 앱에서 실험적인 React 빌드에 의존하지 마십시오. 이러한 기능은 React의 일부가되기 전에 경고없이 크게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="122960595a4931302583328a511b76c9b89150ab" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are not yet available in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="translated">이 페이지 &lt;strong&gt;에서는 아직 안정된 릴리스에서는 사용할 수없는 실험 기능에&lt;/strong&gt; 대해 설명 합니다. 프로덕션 앱에서 실험적인 React 빌드에 의존하지 마십시오. 이러한 기능은 React의 일부가되기 전에 경고없이 크게 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4047aad22e87564322a6b203dc72bdb4dac3a75c" translate="yes" xml:space="preserve">
          <source>This page describes a few popular React toolchains which help with tasks like:</source>
          <target state="translated">이 페이지는 다음과 같은 작업에 도움이되는 몇 가지 유명한 React 툴체인에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e37bdca683407609c8ea8e0d16eadc7cfa276546" translate="yes" xml:space="preserve">
          <source>This page describes the APIs for the built-in Hooks in React.</source>
          <target state="translated">이 페이지는 React의 내장 후크에 대한 API를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e718f59fd28ee7f281f2c32ed198268003156f5" translate="yes" xml:space="preserve">
          <source>This page introduces the concept of state and lifecycle in a React component. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 React 컴포넌트의 상태 및 수명주기 개념을 소개합니다. &lt;a href=&quot;react-component&quot;&gt;자세한 구성 요소 API 참조는 여기에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3489831af2b614861bf122f1b342924d1410d7" translate="yes" xml:space="preserve">
          <source>This page is an API reference for the React &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode&lt;/a&gt;. If you&amp;rsquo;re looking for a guided introduction instead, check out &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 리 액트 &lt;a href=&quot;concurrent-mode-intro&quot;&gt;동시 모드에&lt;/a&gt; 대한 API 참조입니다 . 대신 안내를 찾고 있다면 &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c533e178a623d6b733cedd5bdbf8ab43278f207d" translate="yes" xml:space="preserve">
          <source>This page is an overview of the React documentation and related resources.</source>
          <target state="translated">이 페이지는 React 문서 및 관련 리소스에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="435071639c16cd82d53215bba45c4f7afefd14fc" translate="yes" xml:space="preserve">
          <source>This page is only relevant for React 16 and earlier, and for React Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8155926f2a677459aa518b97627e56b8d5d2b3b9" translate="yes" xml:space="preserve">
          <source>This page provides a theoretical overview of Concurrent Mode. &lt;strong&gt;For a more practical introduction, you might want to check out the next sections:&lt;/strong&gt;</source>
          <target state="translated">이 페이지는 동시 모드에 대한 이론적 개요를 제공합니다. &lt;strong&gt;보다 실용적인 소개를 위해 다음 섹션을 확인하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a471db84150e912bcf081d5315a354a60b2801c7" translate="yes" xml:space="preserve">
          <source>This pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; if the child needs to communicate with the parent before rendering.</source>
          <target state="translated">이 패턴은 자녀를 직계 부모로부터 분리해야하는 경우에 충분합니다. &lt;a href=&quot;render-props&quot;&gt;렌더링&lt;/a&gt; 전에 자식이 부모와 통신해야하는 경우 렌더 소품을 사용하여 더 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fd07e4c840f003b08c9bdf6f21a1ec4e1acc30" translate="yes" xml:space="preserve">
          <source>This performs a shallow merge of &lt;code&gt;stateChange&lt;/code&gt; into the new state, e.g., to adjust a shopping cart item quantity:</source>
          <target state="translated">그러면 장바구니 항목 수량을 조정하기 위해 &lt;code&gt;stateChange&lt;/code&gt; 를 새 상태로 얕은 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="846fc8c98cf14dc25d66ba13bf4262e8d78da49b" translate="yes" xml:space="preserve">
          <source>This plugin is included by default in &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">이 플러그인은 기본적으로 &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;React 앱 만들기에&lt;/a&gt; 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c77f485b089c71f74af9f0894a753a93bcba93" translate="yes" xml:space="preserve">
          <source>This policy is designed to be pragmatic: certainly, we don&amp;rsquo;t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can&amp;rsquo;t make progress in improving React as fast as we&amp;rsquo;d like.</source>
          <target state="translated">이 정책은 실용적입니다. 확실히, 우리는 당신을 위해 두통을 일으키고 싶지 않습니다. 이러한 모든 변경 사항에 대해 주요 버전이 충돌하면 더 많은 주요 버전이 릴리스되고 결국 커뮤니티에 더 많은 버전 관리 문제가 발생합니다. 또한 React를 원하는만큼 빠르게 개선 할 수 없다는 의미이기도합니다.</target>
        </trans-unit>
        <trans-unit id="1ea9e452d1eff58bbc103278e7e1bc082218f9a3" translate="yes" xml:space="preserve">
          <source>This poses a question of how do we know &lt;em&gt;what&lt;/em&gt; to fetch before rendering the next screen. There are several ways to solve this (for example, by integrating data fetching closer with your routing solution). If you work on a data fetching library, &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; presents a deep dive on how to accomplish this and why it&amp;rsquo;s important.</source>
          <target state="translated">이것은 다음 화면을 렌더링하기 전에 &lt;em&gt;무엇&lt;/em&gt; 을 가져올 지 어떻게 알 수 &lt;em&gt;있는지&lt;/em&gt; 에 대한 의문을 제기합니다 . 이 문제를 해결하는 방법에는 여러 가지가 있습니다 (예 : 라우팅 솔루션에 데이터 페치를 더 가깝게 통합). 데이터 페치 라이브러리에서 작업하는 경우 &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;동시 모드 및 서스펜스로 훌륭한 사용자 경험 구축은&lt;/a&gt; 이를 달성하는 방법과 중요한 이유에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f84a144236df428813d59f9cce1db593da13efb1" translate="yes" xml:space="preserve">
          <source>This presents a problem. If the response for fun facts arrives first, we&amp;rsquo;ll see the fun facts below the &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; fallback for posts. We might start reading them, but then the &lt;em&gt;posts&lt;/em&gt; response will come back, and shift all the facts down. This is jarring.</source>
          <target state="translated">문제가 있습니다. 재미있는 사실에 대한 응답이 먼저 도착하면 &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; 아래에 재미있는 사실이 표시됩니다 . 우리는 그것들을 읽을 수 있지만 &lt;em&gt;게시물&lt;/em&gt; 응답이 되돌아오고 모든 사실을 아래로 이동합니다. 이건 엉망이야</target>
        </trans-unit>
        <trans-unit id="8635080f7265c9f1c5179ee0c18eafa6af31514f" translate="yes" xml:space="preserve">
          <source>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it&amp;rsquo;s unintuitive and difficult to debug.</source>
          <target state="translated">이 문제는 해결할 수 있지만 (효과 정리 기능을 사용하여 오래된 요청을 무시하거나 취소 할 수 있음) 직관적이지 않고 디버그하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="8d1f82deaae287572c7914a6acb4b6162faaf183" translate="yes" xml:space="preserve">
          <source>This reference guide documents the &lt;code&gt;SyntheticEvent&lt;/code&gt; wrapper that forms part of React&amp;rsquo;s Event System. See the &lt;a href=&quot;handling-events&quot;&gt;Handling Events&lt;/a&gt; guide to learn more.</source>
          <target state="translated">이 참조 안내서 는 React의 이벤트 시스템의 일부를 구성 하는 &lt;code&gt;SyntheticEvent&lt;/code&gt; 랩퍼를 문서화합니다 . 자세한 내용은 &lt;a href=&quot;handling-events&quot;&gt;취급 이벤트&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d398accdf2e13d5c40a6a46660190acf5d11f2a" translate="yes" xml:space="preserve">
          <source>This release is primarily aimed at early adopters, library authors, and curious people.</source>
          <target state="translated">이 릴리스는 주로 얼리 어답터, 라이브러리 작성자 및 호기심 많은 사람들을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="219eb5ca004ef24ebdbe9552a6315cfaaddd9726" translate="yes" xml:space="preserve">
          <source>This requirement is common enough that it is built into the &lt;code&gt;useEffect&lt;/code&gt; Hook API. You can tell React to &lt;em&gt;skip&lt;/em&gt; applying an effect if certain values haven&amp;rsquo;t changed between re-renders. To do so, pass an array as an optional second argument to &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">이 요구 사항은 &lt;code&gt;useEffect&lt;/code&gt; Hook API에 빌드 될만큼 충분히 일반적 입니다. 다시 렌더링간에 특정 값이 변경되지 않은 경우 React에 효과 적용 을 &lt;em&gt;건너 뛰&lt;/em&gt; 도록 지시 할 수 있습니다 . 그렇게하려면 배열을 선택적 두 번째 인수로 사용하여 &lt;code&gt;useEffect&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="72e02f13475aaf546ed6868e8e94f97eaca88513" translate="yes" xml:space="preserve">
          <source>This reveals an important insight. React always prefers to go to the Skeleton state as soon as possible. Even if we use transitions with long timeouts everywhere, React will not stay in the Pending state for longer than necessary to avoid the Receded state.</source>
          <target state="translated">이것은 중요한 통찰력을 보여줍니다. React는 항상 가능한 빨리 스켈레톤 상태로 가기를 선호합니다. 우리가 어디에서나 긴 타임 아웃으로 전환을 사용하더라도 React는 Receded 상태를 피하기 위해 필요 이상으로 Pending 상태를 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4974405692544c270ead0116083e7b2246305e51" translate="yes" xml:space="preserve">
          <source>This scenario (Receded &amp;rarr; Skeleton &amp;rarr; Complete) is the default one. However, the Receded state is not very pleasant because it &amp;ldquo;hides&amp;rdquo; existing information. This is why React lets us opt into a different sequence (&lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete) with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="translated">이 시나리오 (Receded &amp;rarr; Skeleton &amp;rarr; Complete)가 기본 시나리오입니다. 그러나 Receded 상태는 기존 정보를 &quot;숨기므로&quot;별로 좋지 않습니다. 이것이 React 가 &lt;code&gt;useTransition&lt;/code&gt; 을 사용하여 다른 순서 ( &lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete)를 선택할 수있게하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="8932805285fb5fb9fa75db833708a1c02394b849" translate="yes" xml:space="preserve">
          <source>This section documents a legacy API. See the &lt;a href=&quot;context&quot;&gt;new API&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 레거시 API에 대해 설명합니다. &lt;a href=&quot;context&quot;&gt;새로운 API를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="deb7679ee67f771ffc1fa43a1b5ac4df3c5b01eb" translate="yes" xml:space="preserve">
          <source>This section exists only for the reference.</source>
          <target state="translated">이 섹션은 참조 용으로 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ed85cf7679f0f0f6b3d4ece5fc84efdd9e4a1ae9" translate="yes" xml:space="preserve">
          <source>This section is divided in two pages:</source>
          <target state="translated">이 섹션은 두 페이지로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="11ef194a779a4e464739e9fe4bc7b3d85cd3c158" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you configure webpack directly.</source>
          <target state="translated">이 섹션은 웹팩을 직접 구성한 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="431d6b70a9186c1768894b47222b952f79b7c64c" translate="yes" xml:space="preserve">
          <source>This signals to the user that some work is happening. However, if the transition is relatively short (less than 500ms), it might be too distracting and make the transition itself feel &lt;em&gt;slower&lt;/em&gt;.</source>
          <target state="translated">이것은 일부 작업이 진행되고 있음을 사용자에게 알립니다. 그러나 전환이 비교적 짧은 경우 (500ms 미만) 너무 산만 해져 전환 자체가 &lt;em&gt;느려질 수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c7316ea14507d8a3106cad0c901fad61aced90" translate="yes" xml:space="preserve">
          <source>This snippet is based on the &lt;a href=&quot;hooks-state&quot;&gt;counter example from the previous page&lt;/a&gt;, but we added a new feature to it: we set the document title to a custom message including the number of clicks.</source>
          <target state="translated">이 스 니펫은 &lt;a href=&quot;hooks-state&quot;&gt;이전 페이지&lt;/a&gt; 의 카운터 예제를 기반으로 하지만 여기에는 새로운 기능이 추가되었습니다. 클릭 수를 포함한 문서 제목을 사용자 정의 메시지로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1a2b973923810065ae120310178374258ed4b621" translate="yes" xml:space="preserve">
          <source>This strategy is mostly useful while React-powered parts of the page are isolated from each other. Inside React code, it&amp;rsquo;s easier to use &lt;a href=&quot;components-and-props#composing-components&quot;&gt;component composition&lt;/a&gt; instead.</source>
          <target state="translated">이 전략은 페이지의 반응 기반 부분이 서로 분리되어있는 동안 주로 유용합니다. React 코드 내에서 &lt;a href=&quot;components-and-props#composing-components&quot;&gt;구성 요소 구성&lt;/a&gt; 을 사용하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="af97e3139dc5dabdecc79fb897156e2581c55f4a" translate="yes" xml:space="preserve">
          <source>This syntax is enabled by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">이 구문은 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React 앱 작성&lt;/a&gt; 에서 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6a74e9393c537e68f37f167c1398d5d5cb7b7e5" translate="yes" xml:space="preserve">
          <source>This technique can also be particularly useful with &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (also known as HOCs). Let&amp;rsquo;s start with an example HOC that logs component props to the console:</source>
          <target state="translated">이 기술은 또한 &lt;a href=&quot;higher-order-components&quot;&gt;고차 부품&lt;/a&gt; (HOC라고도 함)에 특히 유용 할 수 있습니다 . 구성 요소 소품을 콘솔에 기록하는 HOC의 예부터 시작해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f2aa2891249ff7426f74024d6c648d613960876e" translate="yes" xml:space="preserve">
          <source>This technique is not limited to Backbone. You can use React with any model library by subscribing to its changes in the lifecycle methods and, optionally, copying the data into the local React state.</source>
          <target state="translated">이 기술은 백본에만 국한되지 않습니다. 라이프 사이클 메소드의 변경 사항을 구독하고 선택적으로 데이터를 로컬 React 상태로 복사하여 모든 모델 라이브러리에서 React를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5452f415731db14c0cf1bafa5cfea7a02476b736" translate="yes" xml:space="preserve">
          <source>This technique makes the behavior that we need to share extremely portable. To get that behavior, render a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a &lt;code&gt;render&lt;/code&gt; prop that tells it what to render with the current (x, y) of the cursor.</source>
          <target state="translated">이 기술은 우리가 공유해야 할 행동을 매우 이식 가능하게 만듭니다. 해당 동작을 얻으려면 커서의 현재 (x, y)로 렌더링 할 대상을 알려주 는 &lt;code&gt;render&lt;/code&gt; 소품 으로 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 를 렌더링하십시오.</target>
        </trans-unit>
        <trans-unit id="cd27a6856541e6f1acbb51200bd11813ffca7cb1" translate="yes" xml:space="preserve">
          <source>This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.</source>
          <target state="translated">이 사용 사례는 일반적이지 않지만 특별한 방법으로 스크롤 위치를 처리해야하는 채팅 스레드와 같은 UI에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03fa86c4209790d37407690c0571a1707fae797b" translate="yes" xml:space="preserve">
          <source>This versioning policy does not apply to prerelease builds in the Next or Experimental channels. &lt;a href=&quot;release-channels&quot;&gt;Learn more about prereleases.&lt;/a&gt;</source>
          <target state="translated">이 버전 관리 정책은 다음 또는 실험 채널의 시험판 빌드에는 적용되지 않습니다. &lt;a href=&quot;release-channels&quot;&gt;시험판에 대해 자세히 알아보십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538b744fcb20bb669203461ab8ea0f4f166bb679" translate="yes" xml:space="preserve">
          <source>This wasn&amp;rsquo;t very difficult to implement. However, if you start thinking about how this could possibly work, it might become a little mindbending. If we set the state, how come we don&amp;rsquo;t see the result right away? &lt;em&gt;Where&lt;/em&gt; is the next &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; rendering?</source>
          <target state="translated">구현하기가 그리 어렵지 않았습니다. 그러나 이것이 어떻게 작동 할 수 있는지에 대해 생각하기 시작하면 약간 혼란 스러울 수 있습니다. 상태를 설정하면 결과가 바로 보이지 않습니까? 다음 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 렌더링 은 &lt;em&gt;어디에 있습니까&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="eeb258d5f9ce72d55863431781bc340ff334eba5" translate="yes" xml:space="preserve">
          <source>This way, Chosen will know to update its DOM element when the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; children managed by React change.</source>
          <target state="translated">이런 식으로 Chosen은 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 하위가 React 변경으로 관리 될 때 DOM 요소를 업데이트하는 것을 알게됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ec28439ceebf9c4cb58d176fb968b8783b61655" translate="yes" xml:space="preserve">
          <source>This way, components using &lt;code&gt;FancyButton&lt;/code&gt; can get a ref to the underlying &lt;code&gt;button&lt;/code&gt; DOM node and access it if necessary&amp;mdash;just like if they used a DOM &lt;code&gt;button&lt;/code&gt; directly.</source>
          <target state="translated">이런 식으로 &lt;code&gt;FancyButton&lt;/code&gt; 을 사용하는 컴포넌트 는 DOM &lt;code&gt;button&lt;/code&gt; 직접 사용하는 것처럼 기본 &lt;code&gt;button&lt;/code&gt; DOM 노드를 참조하여 필요한 경우 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f587d14d7da8b297c6acc91bd9525b1f055544f8" translate="yes" xml:space="preserve">
          <source>This way, only the higher-order component needs to know about Backbone model internals, and most components in the app can stay agnostic of Backbone.</source>
          <target state="translated">이런 식으로, 상위 구성 요소 만 Backbone 모델 내부에 대해 알아야하며, 앱의 대부분의 구성 요소는 Backbone을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a68f6ee634325f5570e4ef9513f5baf023e798ec" translate="yes" xml:space="preserve">
          <source>This will automatically load the bundle containing the &lt;code&gt;OtherComponent&lt;/code&gt; when this component is first rendered.</source>
          <target state="translated">이 컴포넌트가 처음 렌더링 될 때 &lt;code&gt;OtherComponent&lt;/code&gt; 를 포함하는 번들을 자동으로로드합니다 .</target>
        </trans-unit>
        <trans-unit id="4daa2bc6eb40a0cae06d556ea78d107730c1a949" translate="yes" xml:space="preserve">
          <source>This will create a production build of your app in the &lt;code&gt;build/&lt;/code&gt; folder of your project.</source>
          <target state="translated">프로젝트 의 &lt;code&gt;build/&lt;/code&gt; 폴더에 앱의 프로덕션 빌드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="21d07f344e93b8d1d52a83aa0e0b2781c4b8f11b" translate="yes" xml:space="preserve">
          <source>This will destroy the old &lt;code&gt;Counter&lt;/code&gt; and remount a new one.</source>
          <target state="translated">이것은 기존 &lt;code&gt;Counter&lt;/code&gt; 를 파괴하고 새로운 카운터 를 다시 마운트합니다.</target>
        </trans-unit>
        <trans-unit id="f0e763956fc3a258729b7ba8f4a255aa7e25a67d" translate="yes" xml:space="preserve">
          <source>This will let you use the Flow syntax in your code.</source>
          <target state="translated">이를 통해 코드에서 Flow 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d22477424f4173933134c5395efeb476e21ff5a" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;useRef()&lt;/code&gt; creates a plain JavaScript object. The only difference between &lt;code&gt;useRef()&lt;/code&gt; and creating a &lt;code&gt;{current: ...}&lt;/code&gt; object yourself is that &lt;code&gt;useRef&lt;/code&gt; will give you the same ref object on every render.</source>
          <target state="translated">&lt;code&gt;useRef()&lt;/code&gt; 가 일반 JavaScript 객체를 생성 하기 때문에 작동 합니다. &lt;code&gt;useRef()&lt;/code&gt; 와 &lt;code&gt;{current: ...}&lt;/code&gt; 객체를 직접 만드는 것의 유일한 차이점은 useRef 가 모든 렌더링에서 동일한 ref 객체를 제공 &lt;code&gt;useRef&lt;/code&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="b90fb512dd2dc602c018f93fa57436e6ed3df13a" translate="yes" xml:space="preserve">
          <source>This would break the consistency between &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt;, causing issues that are very hard to debug.</source>
          <target state="translated">이는 &lt;code&gt;props&lt;/code&gt; 와 &lt;code&gt;state&lt;/code&gt; 간의 일관성을 손상시켜 디버깅하기 매우 어려운 문제를 야기합니다.</target>
        </trans-unit>
        <trans-unit id="95c22763d2077a1ee86e0ec4084c276829b632d6" translate="yes" xml:space="preserve">
          <source>This would make some of the new features we&amp;rsquo;re working on impossible to implement.</source>
          <target state="translated">이로 인해 우리가 작업중인 새로운 기능 중 일부를 구현할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="c63210a01f156ac5b080f30f90aa5a8002dd873b" translate="yes" xml:space="preserve">
          <source>Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.</source>
          <target state="translated">React에서 단일 페이지 애플리케이션을 빌드 할 수 있지만 필수는 아닙니다. React는 추가 상호 작용 기능으로 기존 웹 사이트의 작은 부분을 향상시키는 데 사용할 수도 있습니다. React로 작성된 코드는 PHP 또는 다른 클라이언트 측 라이브러리에 의해 서버에 렌더링 된 마크 업과 평화롭게 공존 할 수 있습니다. 사실 이것은 정확히 React가 Facebook에서 사용되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="8ecbfeb2bc4103c08c0932a78431577e530cc4f3" translate="yes" xml:space="preserve">
          <source>Throttle</source>
          <target state="translated">Throttle</target>
        </trans-unit>
        <trans-unit id="105be49bda488aaca7ed254ac9ecc09a5112187b" translate="yes" xml:space="preserve">
          <source>Throttling prevents a function from being called more than once in a given window of time. The example below throttles a &amp;ldquo;click&amp;rdquo; handler to prevent calling it more than once per second.</source>
          <target state="translated">조절 기능은 주어진 시간 동안 함수가 두 번 이상 호출되는 것을 방지합니다. 아래 예제는 &quot;클릭&quot;처리기를 조절하여 초당 두 번 이상 호출하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="3dac8fa9afddf95742a5b60661cff381617249d8" translate="yes" xml:space="preserve">
          <source>Timing of effects</source>
          <target state="translated">효과의 타이밍</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="02a6b3cc0676cb3a0bc75f54672fa33daf4c1c54" translate="yes" xml:space="preserve">
          <source>Tip: Minify JavaScript for Production</source>
          <target state="translated">팁 : 프로덕션 용 JavaScript 축소</target>
        </trans-unit>
        <trans-unit id="47616b21251215181f15d43775daece337895ac6" translate="yes" xml:space="preserve">
          <source>Tip: Optimizing Performance by Skipping Effects</source>
          <target state="translated">팁 : 효과를 건너 뛰어 성능 최적화</target>
        </trans-unit>
        <trans-unit id="7fa62c774597708b7f9dc61b6315405aedb3c2e8" translate="yes" xml:space="preserve">
          <source>Tip: Pass Information Between Hooks</source>
          <target state="translated">팁 : 후크간에 정보 전달</target>
        </trans-unit>
        <trans-unit id="6646f32e08b3abdc68e954b73a34054ed4a2fe87" translate="yes" xml:space="preserve">
          <source>Tip: Reuse a Component</source>
          <target state="translated">팁 : 구성 요소 재사용</target>
        </trans-unit>
        <trans-unit id="3cb18070e3d87dfd34832eb7efde20c790409673" translate="yes" xml:space="preserve">
          <source>Tip: Use Multiple Effects to Separate Concerns</source>
          <target state="translated">팁 : 여러 효과를 사용하여 문제 분리</target>
        </trans-unit>
        <trans-unit id="057cb52d94797cd2b615c07e7a0fe7d5d1551b78" translate="yes" xml:space="preserve">
          <source>Tip: Using Multiple State Variables</source>
          <target state="translated">팁 : 여러 상태 변수 사용</target>
        </trans-unit>
        <trans-unit id="cac26bb6c0e4c5715088485c08a32cef54843337" translate="yes" xml:space="preserve">
          <source>Tip: What Do Square Brackets Mean?</source>
          <target state="translated">팁 : 대괄호는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="0fcbdd8749f567ca5ba943cad166f28f7c8d3609" translate="yes" xml:space="preserve">
          <source>Tips for Using Effects</source>
          <target state="translated">효과 사용을위한 팁</target>
        </trans-unit>
        <trans-unit id="8c18a9fca169c11391ce64e4496ce6b8c1d20039" translate="yes" xml:space="preserve">
          <source>To answer these questions, we will refer to the next section on &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="translated">이 질문들에 답하기 위해, 우리는 &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt; 의 다음 섹션을 참조 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cec2f6f831ea050e128a8fa50a07760d119b6ac9" translate="yes" xml:space="preserve">
          <source>To avoid re-creating the ignored initial state, we can pass a &lt;strong&gt;function&lt;/strong&gt; to &lt;code&gt;useState&lt;/code&gt;:</source>
          <target state="translated">무시 된 초기 상태를 다시 만들지 않기 위해 &lt;code&gt;useState&lt;/code&gt; 에&lt;strong&gt;함수&lt;/strong&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67a0eb6712ca908d62558fdb45a11cb5f440325c" translate="yes" xml:space="preserve">
          <source>To avoid winding up with a large bundle, it&amp;rsquo;s good to get ahead of the problem and start &amp;ldquo;splitting&amp;rdquo; your bundle. Code-Splitting is a feature supported by bundlers like &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; and Browserify (via &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt;) which can create multiple bundles that can be dynamically loaded at runtime.</source>
          <target state="translated">큰 번들을 사용하지 않으려면 문제를 해결하고 번들을 &quot;분할&quot;하는 것이 좋습니다. Code-Splitting은 런타임에 동적으로로드 할 수있는 여러 번들을 생성 할 수있는 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; 및 Browserify ( &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt; 통해)와 같은 번 들러 에서 지원하는 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="3828d4a44288ab3a5602117afc478907c184247c" translate="yes" xml:space="preserve">
          <source>To be able to show errors and hints from other packages, the compiler relies on declaration files. A declaration file provides all the type information about a library. This enables us to use javascript libraries like those on npm in our project.</source>
          <target state="translated">다른 패키지의 오류 및 힌트를 표시하려면 컴파일러는 선언 파일을 사용합니다. 선언 파일은 라이브러리에 대한 모든 유형 정보를 제공합니다. 이를 통해 프로젝트에서 npm과 같은 자바 스크립트 라이브러리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8e92cc09f5d0c415337688bf30629119745650" translate="yes" xml:space="preserve">
          <source>To build a static version of your app that renders your data model, you&amp;rsquo;ll want to build components that reuse other components and pass data using &lt;em&gt;props&lt;/em&gt;. &lt;em&gt;props&lt;/em&gt; are a way of passing data from parent to child. If you&amp;rsquo;re familiar with the concept of &lt;em&gt;state&lt;/em&gt;, &lt;strong&gt;don&amp;rsquo;t use state at all&lt;/strong&gt; to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don&amp;rsquo;t need it.</source>
          <target state="translated">데이터 모델을 렌더링하는 정적 버전의 앱을 빌드하려면 다른 컴포넌트를 재사용하고 &lt;em&gt;props를&lt;/em&gt; 사용하여 데이터를 전달하는 컴포넌트를 빌드해야합니다 . &lt;em&gt;props&lt;/em&gt; 는 부모에서 자식으로 데이터를 전달하는 방법입니다. 의 개념에서 나왔습니다에 익숙한 당신이 경우 &lt;em&gt;상태&lt;/em&gt; , &lt;strong&gt;전혀 상태를 사용하지 않는&lt;/strong&gt; 이 정적 버전을 구축 할 수 있습니다. 상태는 대화 형 작업, 즉 시간이 지남에 따라 변경되는 데이터에 대해서만 예약됩니다. 이 버전은 앱의 정적 버전이므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44e1640b1de0ce4a7e355efb726594659452c610" translate="yes" xml:space="preserve">
          <source>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY: &lt;em&gt;Don&amp;rsquo;t Repeat Yourself&lt;/em&gt;&lt;/a&gt;. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you&amp;rsquo;re building a TODO list, keep an array of the TODO items around; don&amp;rsquo;t keep a separate state variable for the count. Instead, when you want to render the TODO count, take the length of the TODO items array.</source>
          <target state="translated">앱을 올바르게 빌드하려면 먼저 앱에 필요한 최소한의 변경 가능한 상태 집합을 고려해야합니다. 여기서 핵심은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY : &lt;em&gt;Do n't Repeat Yourself&lt;/em&gt;&lt;/a&gt; 입니다. 응용 프로그램에 필요한 상태를 최소한으로 표현하고 필요에 따라 필요한 모든 것을 계산하십시오. 예를 들어, TODO 목록을 작성하는 경우 TODO 항목 배열을 유지하십시오. 카운트에 대해 별도의 상태 변수를 유지하지 마십시오. 대신 TODO 수를 렌더링하려면 TODO 항목 배열의 길이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c67fad59392ccaf9eabdb04c2a983cfc8ae6159e" translate="yes" xml:space="preserve">
          <source>To compare these approaches, we&amp;rsquo;ll implement a profile page with each of them.</source>
          <target state="translated">이러한 접근법을 비교하기 위해 각각의 프로파일 페이지를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="96c475cd68a1fc17197255130dcc89b3e9015930" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;new project&lt;/strong&gt; with TypeScript support, run:</source>
          <target state="translated">TypeScript를 지원 하는 &lt;strong&gt;새 프로젝트&lt;/strong&gt; 를 만들려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="58471b12b491c92d9fe1ca36cea662b1ac465f46" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these plugins &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">프로덕션 빌드를 작성하려면 다음 플러그인을 추가해야합니다 &lt;strong&gt;(순서 중요)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b971cbe6f62da89ac8ee7a0afbbd588d46b42f7" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these transforms &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="translated">프로덕션 빌드를 작성하려면 다음 변환을 추가해야합니다 &lt;strong&gt;(순서 중요)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="09c773716596ab713897dcc4bd3d4c47765e2c72" translate="yes" xml:space="preserve">
          <source>To demonstrate how to use it, we will connect a &lt;code&gt;NameInput&lt;/code&gt; React component to a Backbone model, and update its &lt;code&gt;firstName&lt;/code&gt; attribute every time the input changes:</source>
          <target state="translated">사용 방법을 보여주기 위해 &lt;code&gt;NameInput&lt;/code&gt; React 컴포넌트를 Backbone 모델에 연결 하고 입력이 변경 될 때마다 &lt;code&gt;firstName&lt;/code&gt; 속성을 업데이트합니다 :</target>
        </trans-unit>
        <trans-unit id="0ab6586b71fbb2871880374f66e0a1257dbeeb31" translate="yes" xml:space="preserve">
          <source>To demonstrate the issue, we will add a top-level &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component that renders our &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; with a button that lets us &lt;strong&gt;switch between different profiles&lt;/strong&gt;:</source>
          <target state="translated">이 문제를 설명하기 위해 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 를 렌더링하는 최상위 &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; 구성 요소를 추가하여 &lt;strong&gt;다른 프로파일 간을 전환&lt;/strong&gt; 할 수있는 버튼을 사용합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9560e6c157be1cfbb8dadbde0a7036fe5b15715f" translate="yes" xml:space="preserve">
          <source>To demonstrate this feature, we&amp;rsquo;ll use &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;the profile switcher example&lt;/a&gt;. Click the &amp;ldquo;Next&amp;rdquo; button and notice how it takes 1 second to do a transition.</source>
          <target state="translated">이 기능을 시연하기 &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;위해 프로파일 스위처 예제를&lt;/a&gt; 사용 합니다 . &quot;다음&quot;버튼을 클릭하고 전환하는 데 1 초가 걸리는 것을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1c67e18ada396a70dc3856809cab6d64b8650311" translate="yes" xml:space="preserve">
          <source>To demonstrate this, let&amp;rsquo;s sketch out a wrapper for a generic jQuery plugin.</source>
          <target state="translated">이를 설명하기 위해 일반 jQuery 플러그인의 래퍼를 스케치 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e825e335e101a3280e4a617d4f080f38681e18c0" translate="yes" xml:space="preserve">
          <source>To do this in Chrome:</source>
          <target state="translated">Chrome에서이를 수행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="61a324463a8291f2d8b2c3c948a378a1dc9f02f3" translate="yes" xml:space="preserve">
          <source>To exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; and defer showing it with &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt;. This way, the UI doesn&amp;rsquo;t appear broken before hydration.</source>
          <target state="translated">서버 렌더링 HTML에서 레이아웃 효과가 필요한 컴포넌트를 제외하려면 &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; 를 사용하여 조건부로 렌더링하고 &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt; 표시를 연기하십시오 . 이렇게하면 수화 전에 UI가 깨져 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb8f9dde0c24efe373765229e6c43a7c2f9337d4" translate="yes" xml:space="preserve">
          <source>To fix it, use a second form of &lt;code&gt;setState()&lt;/code&gt; that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</source>
          <target state="translated">이를 해결하려면 객체가 아닌 함수를 허용하는 두 번째 형식의 &lt;code&gt;setState()&lt;/code&gt; 를 사용하십시오. 이 함수는 이전 상태를 첫 번째 인수로 받고 업데이트가 두 번째 인수로 적용되는 시점의 소품을받습니다.</target>
        </trans-unit>
        <trans-unit id="3d6dd3cdedde657acf900d4a89c0336446299310" translate="yes" xml:space="preserve">
          <source>To fix this, make sure that the expression before &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is always boolean:</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 앞의 표현식 이 항상 부울 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="26f99cfd42eb715ac4995805986b83748003e11d" translate="yes" xml:space="preserve">
          <source>To fix this, we will assign the type to a capitalized variable first:</source>
          <target state="translated">이 문제를 해결하기 위해 먼저 대문자 변수에 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4180ca125a608d7a0e25df64e609f9ecb9c30f6e" translate="yes" xml:space="preserve">
          <source>To fix this, we will rename &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;Hello&lt;/code&gt; and use &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; when referring to it:</source>
          <target state="translated">이 문제를 해결하려면, 우리는 이름을 변경합니다 &lt;code&gt;hello&lt;/code&gt; 에 &lt;code&gt;Hello&lt;/code&gt; 사용 &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; 그것은 언급 할 때 :</target>
        </trans-unit>
        <trans-unit id="4dbe0f13cbbf4d21a676b7a8718fc4a5f8142b73" translate="yes" xml:space="preserve">
          <source>To get around this problem, you can sometimes define the prop as an instance method, like so:</source>
          <target state="translated">이 문제를 해결하기 위해 다음과 같이 소품을 인스턴스 메소드로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ba2f6b08deb2dd30866e5b1b9d4a3ddab93d66" translate="yes" xml:space="preserve">
          <source>To get around this, lift the value into the parent&amp;rsquo;s state:</source>
          <target state="translated">이 문제를 해결하려면 값을 부모의 상태로 들어 올리십시오.</target>
        </trans-unit>
        <trans-unit id="2f2493e07779dd5286222aecb67fb87e67cc0be1" translate="yes" xml:space="preserve">
          <source>To illustrate this, let&amp;rsquo;s look at a prolific example of broken accessibility caused by click events. This is the outside click pattern, where a user can disable an opened popover by clicking outside the element.</source>
          <target state="translated">이를 설명하기 위해 클릭 이벤트로 인한 액세스 장애의 많은 예를 살펴 보겠습니다. 외부 클릭 패턴으로, 사용자는 요소 외부를 클릭하여 열린 팝 오버를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f9c02dda0f950eb210d479587b65f95f4cc303" translate="yes" xml:space="preserve">
          <source>To illustrate this, we&amp;rsquo;ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:</source>
          <target state="translated">이를 설명하기 위해 가상 채팅 예제의 다른 구성 요소를 사용합니다. 현재 선택된 친구가 온라인인지 여부를 표시하는 채팅 메시지 수신자 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="961d23cd4294477c013c8951229dab570e818eda" translate="yes" xml:space="preserve">
          <source>To implement this, pass a second argument to &lt;code&gt;useEffect&lt;/code&gt; that is the array of values that the effect depends on. Our updated example now looks like this:</source>
          <target state="translated">이를 구현하려면 효과가 의존하는 값의 배열 인 &lt;code&gt;useEffect&lt;/code&gt; 에 두 번째 인수를 전달하십시오 . 업데이트 된 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cbe7212eb0bb22a0ce6673108171b6c2eba3a81" translate="yes" xml:space="preserve">
          <source>To implement this, we need to add &amp;ldquo;state&amp;rdquo; to the &lt;code&gt;Clock&lt;/code&gt; component.</source>
          <target state="translated">이를 구현하려면 &lt;code&gt;Clock&lt;/code&gt; 구성 요소에 &quot;상태&quot;를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e877ead3847a981597e9e8f4b95b055907cf7831" translate="yes" xml:space="preserve">
          <source>To keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.</source>
          <target state="translated">컨텍스트를 다시 렌더링하려면 React는 각 컨텍스트 소비자를 트리에서 별도의 노드로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8ae5d271af6e506124cf18131498a70ca2be75" translate="yes" xml:space="preserve">
          <source>To learn more about the reasoning behind this convention, please read &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt;.</source>
          <target state="translated">이 협약의 추론에 대한 자세한 내용은 &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cf9ecedef1338a4eac3e138d708e2dc3ae6e04d" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;16&lt;/code&gt; with the version number.</source>
          <target state="translated">특정 버전의 &lt;code&gt;react&lt;/code&gt; 및 &lt;code&gt;react-dom&lt;/code&gt; 을로드하려면 &lt;code&gt;16&lt;/code&gt; 을 버전 번호로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="a5eda8e7fdbff1721f24fafdb7853cef70444134" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;17&lt;/code&gt; with the version number.</source>
          <target state="translated">To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt; , replace &lt;code&gt;17&lt;/code&gt; with the version number.</target>
        </trans-unit>
        <trans-unit id="9170ed3b74ebf37599d0d132e15a2a18d2b9e376" translate="yes" xml:space="preserve">
          <source>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React achieves this with &lt;strong&gt;state&lt;/strong&gt;.</source>
          <target state="translated">UI를 대화식으로 만들려면 기본 데이터 모델에 대한 변경을 트리거 할 수 있어야합니다. 반응은 &lt;strong&gt;state로&lt;/strong&gt; 이것을 달성합니다 .</target>
        </trans-unit>
        <trans-unit id="5db9a96f52fb596a5edee35fcf3c37dc6093b9ec" translate="yes" xml:space="preserve">
          <source>To opt into production profiling, React provides a special production build with profiling enabled. Read more about how to use this build at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="translated">프로덕션 프로파일 링을 선택하기 위해 React는 프로파일 링이 활성화 된 특수 프로덕션 빌드를 제공합니다. &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiles&lt;/a&gt; 에서이 빌드를 사용하는 방법에 대해 자세히 알아보십시오</target>
        </trans-unit>
        <trans-unit id="75c17fcf1c7e00497ec03d423858cf51a3dcb835" translate="yes" xml:space="preserve">
          <source>To prepare a component for assertions, wrap the code rendering it and performing updates inside an &lt;code&gt;act()&lt;/code&gt; call. This makes your test run closer to how React works in the browser.</source>
          <target state="translated">어설 션을 위해 구성 요소를 준비하려면 코드를 래핑하여 &lt;code&gt;act()&lt;/code&gt; 호출 내에서 업데이트를 수행 하십시오. 이렇게하면 브라우저에서 React가 작동하는 방식에 가까운 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39042bd85f101d91f59c4ce1fe317b35d4e24bd" translate="yes" xml:space="preserve">
          <source>To prevent React from touching the DOM after mounting, we will return an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; from the &lt;code&gt;render()&lt;/code&gt; method. The &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; element has no properties or children, so React has no reason to update it, leaving the jQuery plugin free to manage that part of the DOM:</source>
          <target state="translated">마운트 후 React가 DOM에 닿지 않도록하기 위해 &lt;code&gt;render()&lt;/code&gt; 메소드 에서 빈 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 를 반환합니다 . &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 요소는 그래서 DOM의 일부를 관리하는 무료 플러그인 jQuery를 떠나는를 업데이트 할 이유를,이 없습니다 반작용, 어떤 속성이나 아이가없는 :</target>
        </trans-unit>
        <trans-unit id="aa5fc70f2e6ed1981d083882d48e4da2f10514fd" translate="yes" xml:space="preserve">
          <source>To recap:</source>
          <target state="translated">요약하자면:</target>
        </trans-unit>
        <trans-unit id="040be61ccf0b0b4ecaddbde299a3d8ac64c9d4c6" translate="yes" xml:space="preserve">
          <source>To reduce the boilerplate, we recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to encourage writing tests that use your components as the end users do.</source>
          <target state="translated">상용구를 줄이려면 최종 사용자와 마찬가지로 구성 요소를 사용하는 테스트 작성을 장려하도록 설계된 &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="42bbd6b79127d268b3e68ed35e45d252d94d666f" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">To render a React element into a root DOM node, pass both to &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="cf123112fa334cc8cc9830f8fa36f2c5c572a5c3" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;code&gt;ReactDOM.render()&lt;/code&gt;:</source>
          <target state="translated">React 요소를 루트 DOM 노드로 렌더링하려면 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 둘 다 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cd0441cfa854cfc8274a8b07aebcc808a1c6f06" translate="yes" xml:space="preserve">
          <source>To set focus in React, we can use &lt;a href=&quot;refs-and-the-dom&quot;&gt;Refs to DOM elements&lt;/a&gt;.</source>
          <target state="translated">React에서 포커스를 설정하기 위해 &lt;a href=&quot;refs-and-the-dom&quot;&gt;Refs to DOM elements를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc462152955304c3080ea64e57ba27af39acf454" translate="yes" xml:space="preserve">
          <source>To show that all components are truly isolated, we can create an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt;s:</source>
          <target state="translated">모든 구성 요소가 완전히 격리되어 있음을 나타 내기 위해 세 개의 &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt; 을 렌더링 하는 &lt;code&gt;App&lt;/code&gt; 구성 요소를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="802b4b9df13b5c75142658af8ad751b38ada5317" translate="yes" xml:space="preserve">
          <source>To solve these problems, &lt;strong&gt;Hooks let you use more of React&amp;rsquo;s features without classes.&lt;/strong&gt; Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don&amp;rsquo;t require you to learn complex functional or reactive programming techniques.</source>
          <target state="translated">이러한 문제를 해결하기 위해 &lt;strong&gt;후크를 사용하면 클래스없이 더 많은 React 기능을 사용할 수 있습니다. &lt;/strong&gt;개념적으로 React 컴포넌트는 항상 기능에 더 가깝습니다. 후크는 기능을 수용하지만 실제 React의 정신을 희생시키지 않습니다. 후크는 필수 탈출 해치에 대한 액세스를 제공하며 복잡한 기능적 또는 반응성 프로그래밍 기술을 배울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="711f5e98a5aa9e9c0eca8855c68da41e1af743dd" translate="yes" xml:space="preserve">
          <source>To solve this, &lt;strong&gt;Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data)&lt;/strong&gt;, rather than forcing a split based on lifecycle methods. You may also opt into managing the component&amp;rsquo;s local state with a reducer to make it more predictable.</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;strong&gt;후크를 사용하면&lt;/strong&gt; 수명주기 방법을 기준으로 분할을 수행하는 대신 &lt;strong&gt;관련 구성 요소 (예 : 구독 설정 또는 데이터 가져 오기)에 따라 하나의 구성 요소를 더 작은 함수로 분할 할 수 있습니다&lt;/strong&gt; . 리듀서를 사용하여 구성 요소의 로컬 상태를보다 예측 가능하게 관리하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="456430f26783e12f01dfb3ab0df061bfad8fd1e5" translate="yes" xml:space="preserve">
          <source>To solve this, we will import &lt;code&gt;SuspenseList&lt;/code&gt;:</source>
          <target state="translated">이를 해결하기 위해 &lt;code&gt;SuspenseList&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="df1f73a03ded94e95f1acc62d67c8fde1d9192e4" translate="yes" xml:space="preserve">
          <source>To solve this, you could copy the methods onto the container before returning it:</source>
          <target state="translated">이를 해결하기 위해 메소드를 리턴하기 전에 컨테이너에 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41cee84baf17b8b37b5a62207732214045e846c5" translate="yes" xml:space="preserve">
          <source>To specify a CSS class, use the &lt;code&gt;className&lt;/code&gt; attribute. This applies to all regular DOM and SVG elements like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, and others.</source>
          <target state="translated">CSS 클래스를 지정하려면 &lt;code&gt;className&lt;/code&gt; 속성을 사용하십시오 . 이것은 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 등의 모든 일반 DOM 및 SVG 요소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff92cd51808e0c139d5c320624daac6f819d6683" translate="yes" xml:space="preserve">
          <source>To use Flow, you need to:</source>
          <target state="translated">흐름을 사용하려면 다음이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7728e4d8199feb9c930de3dba23c508446c8b19f" translate="yes" xml:space="preserve">
          <source>To use TypeScript, you need to:</source>
          <target state="translated">TypeScript를 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="161f5895c0ace53ed0bdbe5b22982a6a7e932910" translate="yes" xml:space="preserve">
          <source>To write an uncontrolled component, instead of writing an event handler for every state update, you can &lt;a href=&quot;refs-and-the-dom&quot;&gt;use a ref&lt;/a&gt; to get form values from the DOM.</source>
          <target state="translated">모든 상태 업데이트에 대한 이벤트 처리기를 작성하는 대신 제어되지 않은 구성 요소를 작성하려면 &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; 를 사용 하여 DOM에서 양식 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10ccc5d107f7904bbc61b7a412891849240b695c" translate="yes" xml:space="preserve">
          <source>To write this without mutating the original object, we can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method:</source>
          <target state="translated">원본 객체를 변경하지 않고 이것을 작성하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7f0884f833f751d0ef4b5804217e883199fbd5" translate="yes" xml:space="preserve">
          <source>Touch Events</source>
          <target state="translated">터치 이벤트</target>
        </trans-unit>
        <trans-unit id="f698e5b2645ac0bbc246d48b10271b68e9474767" translate="yes" xml:space="preserve">
          <source>Tradeoffs</source>
          <target state="translated">Tradeoffs</target>
        </trans-unit>
        <trans-unit id="e09ef19ed713b6bf4b952611e8fb8bed5595d988" translate="yes" xml:space="preserve">
          <source>Traditional Approaches vs Suspense</source>
          <target state="translated">전통적 접근법 대 서스펜스</target>
        </trans-unit>
        <trans-unit id="9c6bcbcbb843659ef482025bbc0496703fc2c9f1" translate="yes" xml:space="preserve">
          <source>Traditionally in React, we&amp;rsquo;ve had two popular ways to share stateful logic between components: &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt;. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.</source>
          <target state="translated">전통적으로 React에서는 컴포넌트간에 스테이트 풀 논리를 공유하는 두 가지 일반적인 방법 인 &lt;a href=&quot;render-props&quot;&gt;렌더 소품&lt;/a&gt; 과 &lt;a href=&quot;higher-order-components&quot;&gt;고차 컴포넌트를 사용했습니다&lt;/a&gt; . 이제 나무에 더 많은 컴포넌트를 추가하지 않고도 Hooks가 동일한 문제를 해결하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="867ed4b8bc75b5b5326132e2b60c8c0b99335d9c" translate="yes" xml:space="preserve">
          <source>Traditionally, performance concerns around inline functions in React have been related to how passing new callbacks on each render breaks &lt;code&gt;shouldComponentUpdate&lt;/code&gt; optimizations in child components. Hooks approach this problem from three sides.</source>
          <target state="translated">전통적으로 React의 인라인 함수와 관련된 성능 문제 는 자식 구성 요소의 componentUpdate 최적화가 각 렌더 브레이크에서 새 콜백을 전달하는 방법과 관련이 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; . 후크는 세 가지 측면에서이 문제에 접근합니다.</target>
        </trans-unit>
        <trans-unit id="79b58c889bdd40be6a9258235ddadc622908c97f" translate="yes" xml:space="preserve">
          <source>Transforming Elements</source>
          <target state="translated">변형 요소</target>
        </trans-unit>
        <trans-unit id="861553513522659f696c3c2acb5a9f21bd9c2977" translate="yes" xml:space="preserve">
          <source>Transition Events</source>
          <target state="translated">전환 이벤트</target>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="dab3f667a0d8b5abd4238e47610e2d5abaeedb69" translate="yes" xml:space="preserve">
          <source>Transitions Are Everywhere</source>
          <target state="translated">전환은 어디에나 있습니다</target>
        </trans-unit>
        <trans-unit id="7b44f1918af555e5d533829bafdc652efe0e1809" translate="yes" xml:space="preserve">
          <source>Transitions are probably the most common Concurrent Mode pattern you&amp;rsquo;ll encounter, but there are a few more patterns you might find useful.</source>
          <target state="translated">전환은 가장 일반적인 동시 모드 패턴 일 수 있지만 유용 할 수있는 패턴이 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a496151406c7c9004e4058dfa652f7eb082f09c" translate="yes" xml:space="preserve">
          <source>Traverse all components in &lt;code&gt;tree&lt;/code&gt; and accumulate all components where &lt;code&gt;test(component)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This is not that useful on its own, but it&amp;rsquo;s used as a primitive for other test utils.</source>
          <target state="translated">&lt;code&gt;tree&lt;/code&gt; 에서 모든 컴포넌트를 순회하고 &lt;code&gt;test(component)&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 모든 컴포넌트를 누적하십시오 . 이것은 그다지 유용하지는 않지만 다른 테스트 유틸리티의 기본으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43ac9a4202ce55afef326fe04f9278e801c3bbcd" translate="yes" xml:space="preserve">
          <source>Triggering imperative animations.</source>
          <target state="translated">명령형 애니메이션 트리거</target>
        </trans-unit>
        <trans-unit id="eccdf562ab40da83be6c16a48f5e930ce51f7c3d" translate="yes" xml:space="preserve">
          <source>Try React</source>
          <target state="translated">반응을 시도</target>
        </trans-unit>
        <trans-unit id="cfb591755dd76c1452b5a348fbeebe6806df4186" translate="yes" xml:space="preserve">
          <source>Try to avoid this pattern if possible.</source>
          <target state="translated">가능하면이 패턴을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="f6062735b940c7bf271c9b6f8c2b28e0bf5e59c6" translate="yes" xml:space="preserve">
          <source>Try to resist adding abstraction too early. Now that function components can do more, it&amp;rsquo;s likely that the average function component in your codebase will become longer. This is normal &amp;mdash; don&amp;rsquo;t feel like you &lt;em&gt;have to&lt;/em&gt; immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.</source>
          <target state="translated">추상화를 너무 일찍 추가하는 것을 거부하십시오. 이제 함수 구성 요소가 더 많은 작업을 수행 할 수 있으므로 코드베이스의 평균 함수 구성 요소가 더 길어질 수 있습니다. 이것은 정상 입니다. 즉각 후크로 분리해야 할 &lt;em&gt;필요&lt;/em&gt; 는 없습니다 . 그러나 사용자 정의 후크가 간단한 인터페이스 뒤에 복잡한 논리를 숨기거나 복잡한 구성 요소를 풀 수있는 경우를 발견하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="334611c431de5751798ac787ddca7df7e73e72f9" translate="yes" xml:space="preserve">
          <source>Try typing into the input now. Something&amp;rsquo;s wrong! The input is updating very slowly.</source>
          <target state="translated">입력을 지금 입력하십시오. 뭔가 잘못 됐어! 입력이 매우 느리게 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1b99d50739153c959d7213579c4a965e5873684c" translate="yes" xml:space="preserve">
          <source>Two elements of different types will produce different trees.</source>
          <target state="translated">다른 유형의 두 요소는 다른 나무를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="translated">타입 정의</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="d3523ff7754d38fca6faee8a30f9b66412b28d78" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Basic Types</source>
          <target state="translated">TypeScript 설명서 : 기본 유형</target>
        </trans-unit>
        <trans-unit id="f9ce122df460bfd7e1f36f7b4329fefda2a5f261" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Migrating from Javascript</source>
          <target state="translated">TypeScript 설명서 : Javascript에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="35a5e4b988fb1f5f965bda27ff40e707d14e3010" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: React and Webpack</source>
          <target state="translated">TypeScript 설명서 : React 및 Webpack</target>
        </trans-unit>
        <trans-unit id="c3d225e3af7ff48de43e2bd459c9b1c338c2417b" translate="yes" xml:space="preserve">
          <source>Typechecking With PropTypes</source>
          <target state="translated">PropTypes로 타입 검사</target>
        </trans-unit>
        <trans-unit id="d215bb61686448cb9ae653f89b0f5e7dd3dad265" translate="yes" xml:space="preserve">
          <source>Typically it is placed at the top of a file. Try adding it to some files in your project and run &lt;code&gt;yarn flow&lt;/code&gt; or &lt;code&gt;npm run flow&lt;/code&gt; to see if Flow already found any issues.</source>
          <target state="translated">일반적으로 파일 맨 위에 배치됩니다. 프로젝트의 일부 파일에 파일을 추가하고 &lt;code&gt;yarn flow&lt;/code&gt; 또는 &lt;code&gt;npm run flow&lt;/code&gt; 을 실행 하여 Flow에 이미 문제가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="73e9a38fd5dec87870b44081fc23f86a7fa9e9ef" translate="yes" xml:space="preserve">
          <source>Typically, elements are not used directly, but get returned from components.</source>
          <target state="translated">일반적으로 요소는 직접 사용되지 않지만 구성 요소에서 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0ea11a83e136215d62bce59ca2e4bf0e74fd2d" translate="yes" xml:space="preserve">
          <source>Typically, in React constructors are only used for two purposes:</source>
          <target state="translated">일반적으로 React 생성자는 두 가지 목적으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1daac2fa2690d23fe34be5b54bc70593b395a6de" translate="yes" xml:space="preserve">
          <source>Typically, new React apps have a single &lt;code&gt;App&lt;/code&gt; component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like &lt;code&gt;Button&lt;/code&gt; and gradually work your way to the top of the view hierarchy.</source>
          <target state="translated">일반적으로 새로운 React 앱은 맨 위에 단일 &lt;code&gt;App&lt;/code&gt; 구성 요소가 있습니다. 그러나 React를 기존 앱에 통합하면 &lt;code&gt;Button&lt;/code&gt; 과 같은 작은 구성 요소로 상향식으로 시작 하여 점차적으로 뷰 계층 구조의 맨 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="68a6a755ada6660b29b2c9a473f41d1442935fd7" translate="yes" xml:space="preserve">
          <source>Typically, this method can be replaced by &lt;code&gt;componentDidUpdate()&lt;/code&gt;. If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt;.</source>
          <target state="translated">일반적으로이 메소드는 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 로 대체 될 수 있습니다 . 이 메소드에서 DOM에서 읽는 경우 (예 : 스크롤 위치 저장) 해당 로직을 &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; 로 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f8fe4b91a258395d82ce705eae35d1dba13e5d0" translate="yes" xml:space="preserve">
          <source>UI Events</source>
          <target state="translated">UI 이벤트</target>
        </trans-unit>
        <trans-unit id="4fb0447cd4cc8d21fe08d8d8d1d385e065b4d751" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillMount()</source>
          <target state="translated">UNSAFE_componentWillMount()</target>
        </trans-unit>
        <trans-unit id="043736bc28e0c4444c9b35f7a1596b1baa86712f" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillReceiveProps()</source>
          <target state="translated">UNSAFE_componentWillReceiveProps()</target>
        </trans-unit>
        <trans-unit id="602b351d9bb4a7f81d1bd7cf0654468b51cd30dd" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillUpdate()</source>
          <target state="translated">UNSAFE_componentWillUpdate()</target>
        </trans-unit>
        <trans-unit id="44a89ad0f567037d498dd94937dc567d3df46056" translate="yes" xml:space="preserve">
          <source>Uncontrolled Components</source>
          <target state="translated">제어되지 않은 구성 요소</target>
        </trans-unit>
        <trans-unit id="91ba162b681d6b6ee5e37c09ea2e8e36df8b03a6" translate="yes" xml:space="preserve">
          <source>Under the Hood</source>
          <target state="translated">후드</target>
        </trans-unit>
        <trans-unit id="91622521af8534f6e0a8cc517ee55a45aa6f3a6c" translate="yes" xml:space="preserve">
          <source>Unfortunately, neither using a class nor the &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; syntax helped us solve this problem. This version suffers from exactly the same race conditions, for the same reasons.</source>
          <target state="translated">불행히도 클래스 또는 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 구문을 사용 하여이 문제를 해결하는 데 도움이 되지 않았습니다 . 이 버전은 동일한 이유로 동일한 경쟁 조건을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="9f80ce906590fe652cad0aa027fb0b4de4ce5b39" translate="yes" xml:space="preserve">
          <source>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render. For a concrete example, you can look at how &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt; enforces preloading. Our messaging about this hasn&amp;rsquo;t been very consistent in the past. Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</source>
          <target state="translated">폭포를 방지 할 수있는 솔루션이 없으면 렌더링 전에 페치를 선호하거나 강제 적용하는 API를 선호하는 것이 좋습니다. 구체적인 예를 들어, &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API가&lt;/a&gt; 사전로드를 적용 하는 방법을 살펴볼 수 있습니다 . 이에 대한 우리의 메시지는 과거에 일관성이 없었습니다. 데이터 가져 오기에 대한 서스펜스는 아직 실험 단계이므로 프로덕션 사용법에서 더 많은 정보를 얻고 문제 공간을 더 잘 이해하면 시간이 지남에 따라 권장 사항이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="961dfa537f5c77804b72ca4ff3d24ad3146c886c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;, the function passed to &lt;code&gt;useEffect&lt;/code&gt; fires &lt;strong&gt;after&lt;/strong&gt; layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn&amp;rsquo;t block the browser from updating the screen.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 달리 , &lt;code&gt;useEffect&lt;/code&gt; 에 전달 된 함수 는 연기 된 이벤트 중에 레이아웃 및 페인트 &lt;strong&gt;후&lt;/strong&gt; 실행 됩니다. 따라서 구독 및 이벤트 처리기 설정과 같은 많은 일반적인 부작용에 적합합니다. 대부분의 작업 유형은 브라우저가 화면을 업데이트하는 것을 차단하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="60a61e13204634a47f56d56022d06304cef51b86" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt;, effects scheduled with &lt;code&gt;useEffect&lt;/code&gt; don&amp;rsquo;t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don&amp;rsquo;t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt; Hook with an API identical to &lt;code&gt;useEffect&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; 또는 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 달리 &lt;code&gt;useEffect&lt;/code&gt; 로 예약 된 효과 는 브라우저가 화면을 업데이트하지 못하도록 차단하지 않습니다. 이를 통해 앱의 응답 성이 향상됩니다. 대부분의 효과는 동 기적으로 발생할 필요가 없습니다. 그것들은 (예 레이아웃에서 측정)을 수행 드문 경우 별도있다 &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; 의&lt;/a&gt; 동일한 API를 가진 후크 &lt;code&gt;useEffect&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="b85ad9f5bd023a746d09d4ff6f648319da333072" translate="yes" xml:space="preserve">
          <source>Unlike a React component, a custom Hook doesn&amp;rsquo;t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it&amp;rsquo;s just like a normal function. Its name should always start with &lt;code&gt;use&lt;/code&gt; so that you can tell at a glance that the &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; apply to it.</source>
          <target state="translated">React 컴포넌트와 달리 사용자 정의 후크에는 특정 서명이 필요하지 않습니다. 우리는 인수로서 무엇이 필요한지, 그리고 무엇이 있다면 반환해야 할지를 결정할 수 있습니다. 다시 말해, 그것은 정상적인 기능과 같습니다. &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙이&lt;/a&gt; 적용됨을 한눈에 알 수 있도록 이름은 항상 &lt;code&gt;use&lt;/code&gt; 시작해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2b66fd7542b07767f815ec47cf6d8029807d9066" translate="yes" xml:space="preserve">
          <source>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</source>
          <target state="translated">브라우저 DOM 요소와 달리 React 요소는 일반 객체이며 작성하기가 저렴합니다. React DOM은 React 요소와 일치하도록 DOM을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="409cf1b9538e64c6ea6640e27a0a2cb930cbc916" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; method on class components, the &lt;code&gt;areEqual&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; if the props are equal and &lt;code&gt;false&lt;/code&gt; if the props are not equal. This is the inverse from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; &lt;/a&gt; 클래스 구성 요소에있어서, 상기 &lt;code&gt;areEqual&lt;/code&gt; 함수가 반환 &lt;code&gt;true&lt;/code&gt; 소품의 경우는 평등하고있는 &lt;code&gt;false&lt;/code&gt; 소품이 동일하지 않은 경우. 이것은 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 와 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1d59b8380230e83e5040bef8fbd9f3658ca115f6" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;setState&lt;/code&gt; method found in class components, &lt;code&gt;useState&lt;/code&gt; does not automatically merge update objects. You can replicate this behavior by combining the function updater form with object spread syntax:</source>
          <target state="translated">클래스 구성 요소에 있는 &lt;code&gt;setState&lt;/code&gt; 메서드 와 달리 &lt;code&gt;useState&lt;/code&gt; 는 업데이트 객체를 자동으로 병합하지 않습니다. 함수 업데이터 양식과 객체 스프레드 구문을 결합하여이 동작을 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d4c6b47d1d280d4c980af5669c79f72a2220526" translate="yes" xml:space="preserve">
          <source>Unlike the lifecycle methods above (which React calls for you), the methods below are the methods &lt;em&gt;you&lt;/em&gt; can call from your components.</source>
          <target state="translated">위의 라이프 사이클 메소드 (React가 호출)는 달리 아래 메소드는 컴포넌트에서 호출 &lt;em&gt;할&lt;/em&gt; 수 있는 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="afee7066378e96dff04ac25d626ac161d6174ffc" translate="yes" xml:space="preserve">
          <source>Unmount the in-memory tree, triggering the appropriate lifecycle events.</source>
          <target state="translated">인 메모리 트리를 마운트 해제하여 적절한 수명주기 이벤트를 트리거하십시오.</target>
        </trans-unit>
        <trans-unit id="dc1890384805c160e15933042986e8c1270701db" translate="yes" xml:space="preserve">
          <source>Unmounting</source>
          <target state="translated">Unmounting</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="7140c62e34aa56f0454814b03078ba09696680fc" translate="yes" xml:space="preserve">
          <source>Updating Context</source>
          <target state="translated">컨텍스트 업데이트</target>
        </trans-unit>
        <trans-unit id="e8f9d5ed2b68142879f0064acd39d5dddc19e0e8" translate="yes" xml:space="preserve">
          <source>Updating Context from a Nested Component</source>
          <target state="translated">중첩 된 컴포넌트에서 컨텍스트 업데이트</target>
        </trans-unit>
        <trans-unit id="636abf0ade1a63bc188164ee602e69ee61c11abf" translate="yes" xml:space="preserve">
          <source>Updating State</source>
          <target state="translated">상태 업데이트</target>
        </trans-unit>
        <trans-unit id="6eb521bc92ea8deef0873674e85f6a2b677e0160" translate="yes" xml:space="preserve">
          <source>Updating the Rendered Element</source>
          <target state="translated">렌더링 된 요소 업데이트</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cb779c71f17fb4651dcbb26ce93ad9f3b869a15e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; to let React know if a component&amp;rsquo;s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.</source>
          <target state="translated">사용 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 구성 요소의 출력 상태 나 소품의 전류 변화에 의해 영향을받지 않으면 알고 반응하게합니다. 기본 동작은 모든 상태 변경시 다시 렌더링하는 것이며 대부분의 경우 기본 동작에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1f252513f7226882a0b24dbdb6d8dcbaf0e88fb" translate="yes" xml:space="preserve">
          <source>Use HOCs For Cross-Cutting Concerns</source>
          <target state="translated">교차 절단 문제에 HOC 사용</target>
        </trans-unit>
        <trans-unit id="efcd67afa619eafb57d29f164d865f7967e67a72" translate="yes" xml:space="preserve">
          <source>Use Render Props for Cross-Cutting Concerns</source>
          <target state="translated">교차 절단 문제에 렌더 소품 사용</target>
        </trans-unit>
        <trans-unit id="945e7893698701d1a0783de1c07354e2873bcd51" translate="yes" xml:space="preserve">
          <source>Use an integrated toolchain for the best user and developer experience.</source>
          <target state="translated">최상의 사용자 및 개발자 경험을 위해 통합 툴체인을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6c96a7f53534a11f3be968f06caa0a7bdbcfbe" translate="yes" xml:space="preserve">
          <source>Use arrow functions, e.g. &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt;.</source>
          <target state="translated">화살표 기능을 사용하십시오 (예 : &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7add3fa600f24de210341c304ca34869584489ae" translate="yes" xml:space="preserve">
          <source>Use as little or as much React as you need.</source>
          <target state="translated">필요한만큼 적게 또는 많이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a25e73bb61bda8c3da0ca1b1bab2f08d9fd2b4b1" translate="yes" xml:space="preserve">
          <source>Use refs sparingly. If you find yourself often using refs to &amp;ldquo;make things happen&amp;rdquo; in your app, consider getting more familiar with &lt;a href=&quot;lifting-state-up&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="translated">심판은 드물게 사용하십시오. 앱에서 &quot;일이 발생하도록&quot;참조를 자주 사용하는 경우 &lt;a href=&quot;lifting-state-up&quot;&gt;하향식 데이터 흐름에&lt;/a&gt; 익숙해지는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a45798aa0c2077edf1d4bdb602e7360df7b30fa1" translate="yes" xml:space="preserve">
          <source>Use the Production Build</source>
          <target state="translated">프로덕션 빌드 사용</target>
        </trans-unit>
        <trans-unit id="501943d285edf21697f4469e8359a5357bcaaa0a" translate="yes" xml:space="preserve">
          <source>Use the right file extensions</source>
          <target state="translated">올바른 파일 확장자를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d60684d4bf976b6606e32f95fd03e20ad2cdaa9b" translate="yes" xml:space="preserve">
          <source>Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</source>
          <target state="translated">컴포넌트가 업데이트 될 때 DOM에서 작동 할 수있는 기회로 이것을 사용하십시오. 또한 현재 소품을 이전 소품과 비교하는 한 네트워크 요청을하기에 좋은 곳입니다 (예 : 소품이 변경되지 않은 경우 네트워크 요청이 필요하지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="09bb24d7602932e8e5252fa3559cae849ed40e36" translate="yes" xml:space="preserve">
          <source>User-Defined Components Must Be Capitalized</source>
          <target state="translated">사용자 정의 구성 요소는 대문자 여야합니다</target>
        </trans-unit>
        <trans-unit id="7bf9efc7891aa3dc73c45128d1b30d30f360d6b7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Enter&lt;/code&gt; to activate elements.</source>
          <target state="translated">&lt;code&gt;Enter&lt;/code&gt; 를 사용하여 요소를 활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce90babb0b7d4740ec6dff8069a1a70de2528e0a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Function.prototype.bind&lt;/code&gt; in render creates a new function each time the component renders, which may have performance implications (see below).</source>
          <target state="translated">렌더링에서 &lt;code&gt;Function.prototype.bind&lt;/code&gt; 를 사용 하면 구성 요소가 렌더링 될 때마다 새 기능이 만들어 지므로 성능에 영향을 줄 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="0268b704052253efcc133928357695716f43f5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.lazy&lt;/code&gt;with dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.</source>
          <target state="translated">동적 가져 오기와 함께 &lt;code&gt;React.lazy&lt;/code&gt; 를 사용 하려면 JS 환경에서 약속을 사용할 수 있어야합니다. 이를 위해서는 IE11 이하의 폴리 필이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a83225bb31031d74727c744b6f62dbc383870f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ReactDOM.render()&lt;/code&gt; to hydrate a server-rendered container is deprecated and will be removed in React 17. Use &lt;a href=&quot;#hydrate&quot;&gt;&lt;code&gt;hydrate()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버 렌더링 컨테이너를 수화하기 위해 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 사용 은 더 이상 사용되지 않으며 React 17에서 제거 됩니다. 대신 &lt;a href=&quot;#hydrate&quot;&gt; &lt;code&gt;hydrate()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="48a22ac3c2727930ac2f50162b02ed7090f9a062" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Tab&lt;/code&gt; and &lt;code&gt;Shift+Tab&lt;/code&gt; to browse.</source>
          <target state="translated">&lt;code&gt;Tab&lt;/code&gt; 및 &lt;code&gt;Shift+Tab&lt;/code&gt; 을 사용 하여 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="5e1ba50e8dbe44c933cf9cf96a6e9c30d740bb4f" translate="yes" xml:space="preserve">
          <source>Using Backbone Models in React Components</source>
          <target state="translated">리 액트 컴포넌트에서 백본 모델 사용</target>
        </trans-unit>
        <trans-unit id="c5fda53e2ec39e55fd191ee394197d4e5b88f71c" translate="yes" xml:space="preserve">
          <source>Using Dot Notation for JSX Type</source>
          <target state="translated">JSX 유형에 도트 표기법 사용</target>
        </trans-unit>
        <trans-unit id="338906b8dfe048bf958f52de3a30e3c835027dc9" translate="yes" xml:space="preserve">
          <source>Using Props Other Than &lt;code&gt;render&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 이외의 소품 사용</target>
        </trans-unit>
        <trans-unit id="88a483ee4ba49991c90e9465efe4ff7c34213894" translate="yes" xml:space="preserve">
          <source>Using React in your Web Components</source>
          <target state="translated">웹 컴포넌트에서 React 사용</target>
        </trans-unit>
        <trans-unit id="5fc69751a627e9e7608b6451c760b3088a1776d1" translate="yes" xml:space="preserve">
          <source>Using State Correctly</source>
          <target state="translated">상태를 올바르게 사용</target>
        </trans-unit>
        <trans-unit id="603e93ed4db9941f0130803851a41f15bbe0f4a6" translate="yes" xml:space="preserve">
          <source>Using Suspense in Practice</source>
          <target state="translated">실제로 서스펜스 사용</target>
        </trans-unit>
        <trans-unit id="64afa8340add2c118e1444b499855f90bdb7bdc0" translate="yes" xml:space="preserve">
          <source>Using TypeScript with Create React App</source>
          <target state="translated">Create React 앱과 함께 TypeScript 사용</target>
        </trans-unit>
        <trans-unit id="3181824009d3d8ab8f244eb65008a1d2883dcad7" translate="yes" xml:space="preserve">
          <source>Using Web Components in React</source>
          <target state="translated">React에서 웹 컴포넌트 사용</target>
        </trans-unit>
        <trans-unit id="2b2c69cb3df5e00c387989ba3ee2f2cdc8414be3" translate="yes" xml:space="preserve">
          <source>Using a Custom Hook</source>
          <target state="translated">사용자 정의 후크 사용</target>
        </trans-unit>
        <trans-unit id="6f7d4170c0a916b341350d421df2093f43390598" translate="yes" xml:space="preserve">
          <source>Using a render prop can negate the advantage that comes from using &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; if you create the function inside a &lt;code&gt;render&lt;/code&gt; method. This is because the shallow prop comparison will always return &lt;code&gt;false&lt;/code&gt; for new props, and each &lt;code&gt;render&lt;/code&gt; in this case will generate a new value for the render prop.</source>
          <target state="translated">렌더 소품을 사용 하면 &lt;code&gt;render&lt;/code&gt; 메서드 내에서 함수를 만드는 경우 &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt; 를 사용하여 얻을 수있는 이점을 무시할 수 있습니다 . 얕은 소품 비교는 항상 새로운 소품에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 하고, 이 경우 각 &lt;code&gt;render&lt;/code&gt; 는 렌더링 소품에 대해 새로운 값을 생성하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="49915cecc2ab68b6142d2a20882e769c815b1066" translate="yes" xml:space="preserve">
          <source>Using an arrow function in render creates a new function each time the component renders, which may break optimizations based on strict identity comparison.</source>
          <target state="translated">렌더링에서 화살표 기능을 사용하면 구성 요소가 렌더링 될 때마다 새로운 기능이 만들어 지므로 엄격한 ID 비교를 기반으로 최적화가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fda59156c5563425ee7b0abda49555ce452777ef" translate="yes" xml:space="preserve">
          <source>Using context, we can avoid passing props through intermediate elements:</source>
          <target state="translated">문맥을 사용하면 중간 요소를 통해 소품을 전달하는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645200f75c6ba99bc214dfeec259746827cb20cb" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Chrome</source>
          <target state="translated">Chrome에서 접근성 검사기 사용</target>
        </trans-unit>
        <trans-unit id="1c8312836922d5bcc9a8621ff5c07034606e0932" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Firefox</source>
          <target state="translated">Firefox에서 내게 필요한 옵션 검사기 사용</target>
        </trans-unit>
        <trans-unit id="d5154d969b060a162f316e9c1d66f061f10670c9" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in OS X Safari</source>
          <target state="translated">OS X Safari에서 내게 필요한 옵션 검사기 사용</target>
        </trans-unit>
        <trans-unit id="34c7c3a33655d5d85c739523b21799c0f20d8a60" translate="yes" xml:space="preserve">
          <source>Using the Effect Hook</source>
          <target state="translated">효과 후크 사용</target>
        </trans-unit>
        <trans-unit id="5e7e608bd7f9e83ae5e7e66cf348bd9227a4b385" translate="yes" xml:space="preserve">
          <source>Using the Next Channel for Integration Testing</source>
          <target state="translated">통합 테스트에 다음 채널 사용</target>
        </trans-unit>
        <trans-unit id="2cfba3a33414eaa5fb929de86b11b61915da61b8" translate="yes" xml:space="preserve">
          <source>Using the State Hook</source>
          <target state="translated">상태 후크 사용</target>
        </trans-unit>
        <trans-unit id="ed1021f647e8e233565d10846cc30295f9907000" translate="yes" xml:space="preserve">
          <source>Using third-party libraries from npm.</source>
          <target state="translated">npm에서 타사 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="30d2d9559518afc440cfbf857d66b14037aea32a" translate="yes" xml:space="preserve">
          <source>Using this lifecycle method often leads to bugs and inconsistencies</source>
          <target state="translated">이 수명주기 방법을 사용하면 종종 버그와 불일치가 발생합니다</target>
        </trans-unit>
        <trans-unit id="b8d2760e3203f83799237c703f9e064427a4c014" translate="yes" xml:space="preserve">
          <source>Using this technique will only capture the last published value in a frame. You can see an example of how this optimization works on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 기술을 사용하면 프레임에서 마지막으로 게시 된 값만 캡처합니다. 이 최적화가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; 에서&lt;/a&gt; 작동하는 방법의 예를 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f13ada68bafae110ed822c96f8ad142bdd952a1f" translate="yes" xml:space="preserve">
          <source>Using this, we first create a ref to an element in the JSX of a component class:</source>
          <target state="translated">이를 사용하여 먼저 컴포넌트 클래스의 JSX에있는 요소에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="06db89939f2e73f5bd1f0be19ed53194716ba43e" translate="yes" xml:space="preserve">
          <source>Usually you would render lists inside a &lt;a href=&quot;components-and-props&quot;&gt;component&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;components-and-props&quot;&gt;컴포넌트&lt;/a&gt; 내부에 목록을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="e48c24f8824265a1d358e010460e0be08e5de8e2" translate="yes" xml:space="preserve">
          <source>Usually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component&amp;rsquo;s data dependencies:</source>
          <target state="translated">일반적으로 HOC는 추가 인수를 허용합니다. Relay의이 예제에서 구성 객체는 구성 요소의 데이터 종속성을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b203f86fed1a8723475dce775230e059b8ed90f3" translate="yes" xml:space="preserve">
          <source>Usually, an update to Next is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.</source>
          <target state="translated">일반적으로 다음에 대한 업데이트는 실험에 대한 해당 업데이트와 함께 제공됩니다. 동일한 소스 개정판을 기반으로하지만 다른 기능 플래그 세트를 사용하여 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="f1866b2703384cc1bc55c57199a504d049c9aa7b" translate="yes" xml:space="preserve">
          <source>Usually, when we update the state, we expect to see changes on the screen immediately. This makes sense because we want to keep our app responsive to user input. However, there are cases where we might prefer to &lt;strong&gt;defer an update from appearing on the screen&lt;/strong&gt;.</source>
          <target state="translated">일반적으로 상태를 업데이트하면 화면에 즉시 변경 사항이 표시됩니다. 우리는 앱이 사용자 입력에 반응하도록 유지하고 싶기 때문에 의미가 있습니다. 그러나 &lt;strong&gt;화면에 업데이트가 나타나지 않는&lt;/strong&gt; 것을 선호하는 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7169fb86be8f9fb1f6dc74f3d60393bc42e3fa2" translate="yes" xml:space="preserve">
          <source>Verifies that &lt;code&gt;children&lt;/code&gt; has only one child (a React element) and returns it. Otherwise this method throws an error.</source>
          <target state="translated">를 검증은 것을 &lt;code&gt;children&lt;/code&gt; 단 하나의 아이 (A는 요소 반응) 반환을 가지고있다. 그렇지 않으면이 메소드는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b84f1567e8f5f03f192913a113aca22668c5a0d0" translate="yes" xml:space="preserve">
          <source>Verifies the object is a React element. Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">객체가 React 요소인지 확인합니다. &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="27d6aa7034ec4c5be2d4ab35f28b89ccab502b9e" translate="yes" xml:space="preserve">
          <source>Versioned Documentation</source>
          <target state="translated">버전 문서</target>
        </trans-unit>
        <trans-unit id="cd797cf0fe303d32f5502e0cd652eb3709acf2f2" translate="yes" xml:space="preserve">
          <source>Versioning Policy</source>
          <target state="translated">버전 관리 정책</target>
        </trans-unit>
        <trans-unit id="0e87ae23796278c9462fd444edf70fe1a009d923" translate="yes" xml:space="preserve">
          <source>Video Introduction</source>
          <target state="translated">비디오 소개</target>
        </trans-unit>
        <trans-unit id="c2a2aea3dead057a6a1ec3e587afea025320c2dd" translate="yes" xml:space="preserve">
          <source>View the full example source code</source>
          <target state="translated">전체 예제 소스 코드보기</target>
        </trans-unit>
        <trans-unit id="64cfe6fcb223ea8768b2640f2636977ba0d164fb" translate="yes" xml:space="preserve">
          <source>Virtual DOM and Internals</source>
          <target state="translated">가상 DOM 및 내부</target>
        </trans-unit>
        <trans-unit id="f85fbf92e499fc71591a2e669124a9722afaf021" translate="yes" xml:space="preserve">
          <source>Virtualize Long Lists</source>
          <target state="translated">긴 목록 가상화</target>
        </trans-unit>
        <trans-unit id="2ef3ffb278db3f335c5ff68b2879712b4c381076" translate="yes" xml:space="preserve">
          <source>VoiceOver in Safari</source>
          <target state="translated">Safari의 VoiceOver</target>
        </trans-unit>
        <trans-unit id="d9957a9af3a69ef84d5b820d611a3f62b1ccf86a" translate="yes" xml:space="preserve">
          <source>VoiceOver is an integrated screen reader on Apple devices.</source>
          <target state="translated">VoiceOver는 Apple 장치의 통합 스크린 리더입니다.</target>
        </trans-unit>
        <trans-unit id="665b0a94753596ab58c7b0bfabd4f05a281f3d86" translate="yes" xml:space="preserve">
          <source>WAI-ARIA</source>
          <target state="translated">WAI-ARIA</target>
        </trans-unit>
        <trans-unit id="55894c1196e8f880851ae38d59786f7cb22f88d8" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices - Design Patterns and Widgets</source>
          <target state="translated">WAI-ARIA 작성 실습-디자인 패턴 및 위젯</target>
        </trans-unit>
        <trans-unit id="3354373068a65230be0efcf6468f02a4db93217b" translate="yes" xml:space="preserve">
          <source>WCAG</source>
          <target state="translated">WCAG</target>
        </trans-unit>
        <trans-unit id="0f298949c575de92097cb4a1eb81d16e079aff0f" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Color Contrast Requirement</source>
          <target state="translated">WCAG-색상 대비 요구 사항 이해</target>
        </trans-unit>
        <trans-unit id="565ff00b6dae2e3752c6332ca334f9853f076fdb" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Document Title Requirement</source>
          <target state="translated">WCAG-문서 제목 요구 사항 이해</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
