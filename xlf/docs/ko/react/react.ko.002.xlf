<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="679fe92462c39504c9ff9773ae608eb7389ffc9e" translate="yes" xml:space="preserve">
          <source>For a more concrete example of these concepts, let&amp;rsquo;s write a minimal wrapper for the plugin &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen&lt;/a&gt;, which augments &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; inputs.</source>
          <target state="translated">이러한 개념에 대한보다 구체적인 예를 들어, 플러그인 &lt;a href=&quot;https://harvesthq.github.io/chosen/&quot;&gt;Chosen에&lt;/a&gt; 대한 최소 래퍼를 작성하여 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 입력 을 보강 합니다.</target>
        </trans-unit>
        <trans-unit id="e02416dec32f4ac14f5c635f846c95b0b1f3e149" translate="yes" xml:space="preserve">
          <source>For a more detailed walkthrough, check out &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;this article by Ben Schwarz&lt;/a&gt;.</source>
          <target state="translated">자세한 연습 &lt;a href=&quot;https://calibreapp.com/blog/react-performance-profiling-optimization&quot;&gt;은 Ben Schwarz의이 기사를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6742712e3a4c00cde6cec63fd4e900f882182503" translate="yes" xml:space="preserve">
          <source>For components defined as classes, use &lt;code&gt;this.props.children&lt;/code&gt;:</source>
          <target state="translated">클래스로 정의 된 컴포넌트의 경우 &lt;code&gt;this.props.children&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="df0460aa967c08b3c0359b521985038ac48561d5" translate="yes" xml:space="preserve">
          <source>For each particular piece of changing data, there should be just one component that &amp;ldquo;owns&amp;rdquo; it in its state. Don&amp;rsquo;t try to synchronize states of two different components. Instead, &lt;a href=&quot;lifting-state-up&quot;&gt;lift it up&lt;/a&gt; to their closest shared ancestor, and pass it down as props to both of them.</source>
          <target state="translated">각각의 특정 변경 데이터에 대해 해당 상태에서 데이터를 &quot;소유&quot;하는 구성 요소는 하나만 있어야합니다. 서로 다른 두 구성 요소의 상태를 동기화하려고하지 마십시오. 대신, 가장 가까운 조상 &lt;a href=&quot;lifting-state-up&quot;&gt;까지 들어 올려&lt;/a&gt; 두 사람에게 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="647bc53c804dc25be5b4801130ef3922760422b8" translate="yes" xml:space="preserve">
          <source>For each piece of state in your application:</source>
          <target state="translated">응용 프로그램의 각 상태에 대해 :</target>
        </trans-unit>
        <trans-unit id="4657ab12168f0360582ae377c9a3fb4c69201085" translate="yes" xml:space="preserve">
          <source>For each test, we usually want to render our React tree to a DOM element that&amp;rsquo;s attached to &lt;code&gt;document&lt;/code&gt;. This is important so that it can receive DOM events. When the test ends, we want to &amp;ldquo;clean up&amp;rdquo; and unmount the tree from the &lt;code&gt;document&lt;/code&gt;.</source>
          <target state="translated">각 테스트마다 일반적으로 React 트리를 &lt;code&gt;document&lt;/code&gt; 에 첨부 된 DOM 요소로 렌더링하려고합니다 . DOM 이벤트를 수신 할 수 있도록하는 것이 중요합니다. 테스트가 끝나면 &quot;정리&quot;하고 &lt;code&gt;document&lt;/code&gt; 에서 트리를 마운트 해제하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="9d2f11c83d765d839676e4e232e576ddbe2a1a64" translate="yes" xml:space="preserve">
          <source>For example a custom Hook that returned a &lt;code&gt;Date&lt;/code&gt; value could avoid calling the &lt;code&gt;toDateString&lt;/code&gt; function unnecessarily by passing the following formatter:</source>
          <target state="translated">예를 들어, &lt;code&gt;Date&lt;/code&gt; 값 을 리턴 한 사용자 정의 후크 는 다음 형식 &lt;code&gt;toDateString&lt;/code&gt; 전달하여 불필요하게 toDateString 함수를 호출 하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="6ccd00019fe7c93727e1ee7af34a30096debfa1c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;class&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; in JSX, and &lt;code&gt;tabindex&lt;/code&gt; becomes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt;&lt;code&gt;tabIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 JSX에서 &lt;code&gt;class&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/className&quot;&gt; &lt;code&gt;className&lt;/code&gt; &lt;/a&gt; 이되고 &lt;code&gt;tabindex&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex&quot;&gt; &lt;code&gt;tabIndex&lt;/code&gt; &lt;/a&gt; 가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="257bf267f4accf76b8a71c8a6fc907d879bb3b3b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; returns an empty string, and &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; returns &lt;code&gt;'50.396'&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;tryConvert('abc', toCelsius)&lt;/code&gt; 는 빈 문자열을 반환하고 &lt;code&gt;tryConvert('10.22', toFahrenheit)&lt;/code&gt; 는 &lt;code&gt;'50.396'&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="86da3811ff28fce969e656a6a27c26d72c389972" translate="yes" xml:space="preserve">
          <source>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</source>
          <target state="translated">예를 들어 Facebook Messenger는 사이드 바의 내용, 정보 패널, 대화 로그 및 메시지 입력을 별도의 오류 경계로 래핑합니다. 이러한 UI 영역 중 하나의 일부 구성 요소가 충돌하면 나머지 구성 요소는 대화식으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d8139b3a5725d0dbe39a1d636583f71febc457" translate="yes" xml:space="preserve">
          <source>For example, both of the imports are necessary in this code, even though &lt;code&gt;React&lt;/code&gt; and &lt;code&gt;CustomButton&lt;/code&gt; are not directly referenced from JavaScript:</source>
          <target state="translated">예를 들어 &lt;code&gt;React&lt;/code&gt; 및 &lt;code&gt;CustomButton&lt;/code&gt; 이 JavaScript에서 직접 참조되지 않더라도이 코드에서 두 가져 오기가 모두 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="390fb39992645b6398deff562b8f840081098a97" translate="yes" xml:space="preserve">
          <source>For example, consider a &lt;code&gt;Page&lt;/code&gt; component that passes a &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; prop several levels down so that deeply nested &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components can read it:</source>
          <target state="translated">예를 들어, 중첩 된 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소가 읽을 수 있도록 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;avatarSize&lt;/code&gt; prop를 여러 수준 아래로 전달 하는 &lt;code&gt;Page&lt;/code&gt; 구성 요소를 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="3a0f37544377fd4ba88f4814137f0c59e828e67d" translate="yes" xml:space="preserve">
          <source>For example, consider a filterable list like this:</source>
          <target state="translated">예를 들어 다음과 같이 필터링 가능한 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="672d122436eb70d444bbe9b6d5a7454eb80d94df" translate="yes" xml:space="preserve">
          <source>For example, consider the &lt;code&gt;useFriendStatus&lt;/code&gt; custom Hook described in &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;자신의 후크 만들기&amp;rdquo;에&lt;/a&gt; 설명 된 &lt;code&gt;useFriendStatus&lt;/code&gt; 사용자 정의 후크를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="897f4de2b32102497cc28727717c94d918135994" translate="yes" xml:space="preserve">
          <source>For example, consider the following code:</source>
          <target state="translated">예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9050062cc798394f53d6e8b1ff9014a2612f33bb" translate="yes" xml:space="preserve">
          <source>For example, consider this &lt;code&gt;Comment&lt;/code&gt; component:</source>
          <target state="translated">예를 들어, 다음 &lt;code&gt;Comment&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="17c300f11b425a9fc05f0c1272d1583ab4603762" translate="yes" xml:space="preserve">
          <source>For example, continuing with our &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component from above, if &lt;code&gt;Mouse&lt;/code&gt; were to extend &lt;code&gt;React.PureComponent&lt;/code&gt; instead of &lt;code&gt;React.Component&lt;/code&gt;, our example would look like this:</source>
          <target state="translated">예를 들어, 위에서 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 컴포넌트를 계속해서 &lt;code&gt;Mouse&lt;/code&gt; 가 &lt;code&gt;React.PureComponent&lt;/code&gt; 대신 React.PureComponent 를 확장 &lt;code&gt;React.Component&lt;/code&gt; , 예제는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="20ed488706a8a3ad440cf53c3eca5d4c4ed1ad07" translate="yes" xml:space="preserve">
          <source>For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.</source>
          <target state="translated">예를 들어, 후크를 발표 할 때 실험 채널이 존재했다면 실험 채널이 후크에서 최신으로 제공되기 몇 주 전에 릴리스되었습니다.</target>
        </trans-unit>
        <trans-unit id="72386049d7fd0a4d1be43f2f6774c74af5948367" translate="yes" xml:space="preserve">
          <source>For example, if we enter 37 into the Celsius input, the state of the &lt;code&gt;Calculator&lt;/code&gt; component will be:</source>
          <target state="translated">예를 들어 Celsius 입력에 37을 입력하면 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소 의 상태 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9993ee38514320027480d338484992ca1feb5c6" translate="yes" xml:space="preserve">
          <source>For example, if we switch from one page to another, and none of the code or data for the next screen has loaded yet, it might be frustrating to immediately see a blank page with a loading indicator. We might prefer to stay longer on the previous screen. Implementing this pattern has historically been difficult in React. Concurrent Mode offers a new set of tools to do that.</source>
          <target state="translated">예를 들어, 한 페이지에서 다른 페이지로 전환했는데 다음 화면의 코드 나 데이터가 아직로드되지 않은 경우로드 표시기가있는 빈 페이지가 즉시 표시되지 않으면 실망 할 수 있습니다. 이전 화면에서 더 오래 머무르기를 선호 할 수 있습니다. 이 패턴을 구현하는 것은 역사적으로 React에서 어려웠습니다. 동시 모드는이를위한 새로운 도구 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65295b13b97c2a6ed8a939287bfe094925fc31cc" translate="yes" xml:space="preserve">
          <source>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</source>
          <target state="translated">예를 들어, 이전 예제 로그를 제출할 때 이름을 로그로 만들려면 양식을 제어 된 구성 요소로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90b29303f730a5e659074ca0cb511ba946d5117" translate="yes" xml:space="preserve">
          <source>For example, if you &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract&lt;/a&gt; a &lt;code&gt;ListItem&lt;/code&gt; component, you should keep the key on the &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; elements in the array rather than on the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element in the &lt;code&gt;ListItem&lt;/code&gt; itself.</source>
          <target state="translated">예를 들어 &lt;code&gt;ListItem&lt;/code&gt; 구성 요소 를 &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;추출&lt;/a&gt; 하는 경우 &lt;code&gt;ListItem&lt;/code&gt; 자체 의 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소가 아닌 배열 의 &lt;code&gt;&amp;lt;ListItem /&amp;gt;&lt;/code&gt; 요소에 키를 보관해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4f472461a434d14b304ba318506b6c2b7dd4f729" translate="yes" xml:space="preserve">
          <source>For example, if you have the following component:</source>
          <target state="translated">예를 들어 다음 구성 요소가있는 경우</target>
        </trans-unit>
        <trans-unit id="cf9af7a91451dd9ae9a9996fb7f391bbc16ec6a4" translate="yes" xml:space="preserve">
          <source>For example, instead of exposing &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;close()&lt;/code&gt; methods on a &lt;code&gt;Dialog&lt;/code&gt; component, pass an &lt;code&gt;isOpen&lt;/code&gt; prop to it.</source>
          <target state="translated">예를 들어 &lt;code&gt;Dialog&lt;/code&gt; 구성 요소 에 &lt;code&gt;open()&lt;/code&gt; 및 &lt;code&gt;close()&lt;/code&gt; 메서드를 노출시키는 대신 &lt;code&gt;isOpen&lt;/code&gt; 소품을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="d8de9356ec83d73b1f5bd25ff7148e61b4571f9a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; component that renders the image of a cat chasing the mouse around the screen. We might use a &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; prop to tell the component the coordinates of the mouse so it knows where to position the image on the screen.</source>
          <target state="translated">예를 들어, 화면 주위에 마우스를 쫓는 고양이의 이미지를 렌더링 하는 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 컴포넌트 가 있다고 가정 해 봅시다 . 우리는 사용할 수있는 &lt;code&gt;&amp;lt;Cat mouse={{ x, y }}&amp;gt;&lt;/code&gt; 가 알 수 있도록 화면에 이미지를 배치 할 경우 구성 요소를 마우스의 좌표를 알려 소품.</target>
        </trans-unit>
        <trans-unit id="ba22bdb002e0f405abcc6c642198532d39f6bf7a" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this &lt;code&gt;Counter&lt;/code&gt; component:</source>
          <target state="translated">예를 &lt;code&gt;Counter&lt;/code&gt; 구성 요소 가 있다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6f0a42e407f76b6421f57202e0a6b998a33eea86" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have this counter component:</source>
          <target state="translated">예를 들어이 카운터 구성 요소가 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6829043516c2d5b5543372593d5ecc18cc4a4134" translate="yes" xml:space="preserve">
          <source>For example, maybe you have a complex component that contains a lot of local state that is managed in an ad-hoc way. &lt;code&gt;useState&lt;/code&gt; doesn&amp;rsquo;t make centralizing the update logic any easier so you might prefer to write it as a &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; reducer:</source>
          <target state="translated">예를 들어, 임시 방식으로 관리되는 많은 로컬 상태를 포함하는 복잡한 구성 요소가있을 수 있습니다. &lt;code&gt;useState&lt;/code&gt; 는 업데이트 논리를 더 쉽게 중앙 집중화하지 않으므로 &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; 감속기 로 작성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e18ae5d39ecd3952c9cebace04d8ec7b3336fb23" translate="yes" xml:space="preserve">
          <source>For example, research shows that displaying too many intermediate loading states when transitioning between screens makes a transition feel &lt;em&gt;slower&lt;/em&gt;. This is why Concurrent Mode shows new loading states on a fixed &amp;ldquo;schedule&amp;rdquo; to avoid jarring and too frequent updates.</source>
          <target state="translated">예를 들어, 연구에 따르면 화면 간 전환시 너무 많은 중간 로딩 상태를 표시하면 전환 &lt;em&gt;속도가 느려집니다&lt;/em&gt; . 이것이 바로 동시 모드가 고정 된&amp;ldquo;스케줄&amp;rdquo;에 새로운로드 상태를 표시하여 문제가 발생하거나 너무 자주 업데이트되지 않도록하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="78683415bcaad856b1ab7dfe02f23e05fa2ced55" translate="yes" xml:space="preserve">
          <source>For example, say you have a &lt;code&gt;CommentList&lt;/code&gt; component that subscribes to an external data source to render a list of comments:</source>
          <target state="translated">예를 들어, 주석 목록을 렌더링하기 위해 외부 데이터 소스를 구독 하는 &lt;code&gt;CommentList&lt;/code&gt; 구성 요소가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a1a629d470f55d2fee2000499a4cacbb9a4833a" translate="yes" xml:space="preserve">
          <source>For example, the HTML:</source>
          <target state="translated">예를 들어 HTML :</target>
        </trans-unit>
        <trans-unit id="6ba76674660b5e537e8b2cdd0ef1d5a91df770a7" translate="yes" xml:space="preserve">
          <source>For example, the following component tracks the mouse position in a web app:</source>
          <target state="translated">예를 들어 다음 구성 요소는 웹 앱에서 마우스 위치를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="e8f359161b98ba57290664f3cc1ede81cf753231" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as &amp;rdquo;&lt;em&gt;ForwardRef&lt;/em&gt;&amp;rdquo; in the DevTools:</source>
          <target state="translated">예를 들어 DevTools에서 다음 구성 요소가 &quot; &lt;em&gt;ForwardRef&lt;/em&gt; &quot; 로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="5c4201bd25776812cd7bc0c469c68c4fbd842451" translate="yes" xml:space="preserve">
          <source>For example, the following component will appear as MyDisplayName in the DevTools:</source>
          <target state="translated">예를 들어 DevTools에서 다음 구성 요소가 MyDisplayName으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3069268548855f5d165876787923a3ea3d1da874" translate="yes" xml:space="preserve">
          <source>For example, this code accepts a single name in an uncontrolled component:</source>
          <target state="translated">예를 들어이 코드는 제어되지 않는 구성 요소에서 단일 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2c55286e50f3215379ff426fa48eb785d76df4a7" translate="yes" xml:space="preserve">
          <source>For example, this code may fail to update the counter:</source>
          <target state="translated">예를 들어이 코드는 카운터를 업데이트하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ccc1009af6f8f6328943760f3255e5b65c01689" translate="yes" xml:space="preserve">
          <source>For example, this code renders &amp;ldquo;Hello, Sara&amp;rdquo; on the page:</source>
          <target state="translated">예를 들어이 코드는 페이지에 &quot;Hello, Sara&quot;를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c3a55dc4cb118bd5e2852ddf3c6b69f2d61b25ed" translate="yes" xml:space="preserve">
          <source>For example, this code will not run as expected:</source>
          <target state="translated">예를 들어이 코드는 예상대로 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e989a1227816ccbcfdce9a1ef1f8646c7fe3950" translate="yes" xml:space="preserve">
          <source>For example, this code written with JSX:</source>
          <target state="translated">예를 들어이 코드는 JSX로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="f04fad3363acf285dbccbb82a73f5be8eb678633" translate="yes" xml:space="preserve">
          <source>For example, this component sets the document title after React updates the DOM:</source>
          <target state="translated">예를 들어,이 컴포넌트는 React가 DOM을 업데이트 한 후 문서 제목을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7884e8e4fb1aae5ecf12d8317e1f6d9f4593fec2" translate="yes" xml:space="preserve">
          <source>For example, this will not re-render a component:</source>
          <target state="translated">예를 들어, 이것은 컴포넌트를 다시 렌더링하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20851a45788a2fdc02ea529e15ac7f8112f9de05" translate="yes" xml:space="preserve">
          <source>For example, to profile a &lt;code&gt;Navigation&lt;/code&gt; component and its descendants:</source>
          <target state="translated">예를 들어, &lt;code&gt;Navigation&lt;/code&gt; 구성 요소 및 해당 하위 항목 을 프로파일 링하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d13080b59ca5d53e0ba7b314b267e9b38197f049" translate="yes" xml:space="preserve">
          <source>For example, we can create an &lt;code&gt;App&lt;/code&gt; component that renders &lt;code&gt;Welcome&lt;/code&gt; many times:</source>
          <target state="translated">예를 들어 &lt;code&gt;Welcome&lt;/code&gt; 을 여러 번 렌더링 하는 &lt;code&gt;App&lt;/code&gt; 구성 요소를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ead1eab1f84507539e34706446448f0d28e9f5" translate="yes" xml:space="preserve">
          <source>For example, we could split our component state into &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; objects, and always replace the &lt;code&gt;position&lt;/code&gt; with no need for merging:</source>
          <target state="translated">예를 들어 구성 요소 상태를 &lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 객체 로 분할 하고 항상 병합 할 필요없이 &lt;code&gt;position&lt;/code&gt; 를 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d42c3a9b978bb53213888cf10f240637aca3105" translate="yes" xml:space="preserve">
          <source>For example, when adding an element at the end of the children, converting between these two trees works well:</source>
          <target state="translated">예를 들어 자식의 끝에 요소를 추가 할 때이 두 트리 사이를 변환하면 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3142f55d25c885268e370e43896a3749c9b69c27" translate="yes" xml:space="preserve">
          <source>For example, your state may contain several independent variables:</source>
          <target state="translated">예를 들어, 주에는 여러 개의 독립 변수가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="331fc234992fd41cfe4aafa1cbadd06d8bfafb82" translate="yes" xml:space="preserve">
          <source>For modal dialogs, ensure that everyone can interact with them by following the &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA Modal Authoring Practices&lt;/a&gt;.</source>
          <target state="translated">모달 대화 상자의 경우 &lt;a href=&quot;https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal&quot;&gt;WAI-ARIA 모달 작성 실습&lt;/a&gt; 에 따라 모든 사람이 대화 할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec096cdc71e0b7a6ca398c02cfc7d40516f822a1" translate="yes" xml:space="preserve">
          <source>For more detail, see:</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c88366a24fd2ea482dc14d0de87b283bbe87e7a" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;Error Handling in React 16&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;&lt;em&gt;은 React 16의 오류 처리를&lt;/em&gt;&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db28a2392ea1b7c225c391a0872eaf779d774686" translate="yes" xml:space="preserve">
          <source>For more info, see &lt;a href=&quot;fragments&quot;&gt;the Fragments documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;fragments&quot;&gt;은 조각 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ab9916b7ffb2e490bd12d8282c8ddb3d82ffa2a" translate="yes" xml:space="preserve">
          <source>For more information about the &amp;lsquo;function as a child&amp;rsquo; pattern, see &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;.</source>
          <target state="translated">'자식 기능'패턴에 대한 자세한 정보는 &lt;a href=&quot;render-props&quot;&gt;render props를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="754ab305ab4f9aeec53763a39090226c0de9d63f" translate="yes" xml:space="preserve">
          <source>For more information about the onChange event, see &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="translated">onChange 이벤트에 대한 자세한 정보는 &lt;a href=&quot;forms&quot;&gt;양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cba5c3c0c27cf5088d9888383d141d07a0f2491" translate="yes" xml:space="preserve">
          <source>For more information on Concurrent Mode, check out the &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode documentation.&lt;/a&gt;</source>
          <target state="translated">동시 모드에 대한 자세한 내용은 &lt;a href=&quot;concurrent-mode-intro&quot;&gt;동시 모드 설명서를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9732d78e0ad658ec6be5aa1a8cfda86c791eaa9" translate="yes" xml:space="preserve">
          <source>For more information, check out &lt;a href=&quot;testing-recipes&quot;&gt;Testing Recipes&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;testing-recipes&quot;&gt;테스팅 레시피를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4a38f12036a32191520afa8a2753bdccc47eea0" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;forwarding-refs&quot;&gt;forwarding refs&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 참조 &lt;a href=&quot;forwarding-refs&quot;&gt;전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5fc1e92e2c893003eb2447d228048e1a7aaf57a" translate="yes" xml:space="preserve">
          <source>For older codebases, Concurrent Mode might be a step too far. This is why we also provide a new &amp;ldquo;Blocking Mode&amp;rdquo; in the experimental React builds. You can try it by substituting &lt;code&gt;createRoot&lt;/code&gt; with &lt;code&gt;createBlockingRoot&lt;/code&gt;. It only offers a &lt;em&gt;small subset&lt;/em&gt; of the Concurrent Mode features, but it is closer to how React works today and can serve as a migration step.</source>
          <target state="translated">오래된 코드베이스의 경우 동시 모드가 너무 한 단계 일 수 있습니다. 이것이 실험적인 React 빌드에서 새로운&amp;ldquo;차단 모드&amp;rdquo;를 제공하는 이유입니다. &lt;code&gt;createRoot&lt;/code&gt; 를 &lt;code&gt;createBlockingRoot&lt;/code&gt; 로 대체하여 시도해 볼 수 있습니다 . 동시 모드 기능 중 &lt;em&gt;일부만&lt;/em&gt; 제공 하지만 React의 작동 방식에 더 가깝고 마이그레이션 단계로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="770927b3887fe0c354b4fb137b4cc1bdc30fbbb9" translate="yes" xml:space="preserve">
          <source>For other use cases, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;follow the recommendations in this blog post about derived state&lt;/a&gt;.</source>
          <target state="translated">다른 사용 사례의 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;경우이 블로그 게시물의 파생 된 상태에 대한 권장 사항을 따르십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b327cbe7031e739d617d4f75e12fa5fef2acc3b7" translate="yes" xml:space="preserve">
          <source>For the most efficient Browserify production build, install a few plugins:</source>
          <target state="translated">가장 효율적인 Browserify 프로덕션 빌드를 위해 몇 가지 플러그인을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="17194133fbe1957bfdd4b741f2933c9c86f4ba6d" translate="yes" xml:space="preserve">
          <source>For the most efficient Brunch production build, install the &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt;&lt;code&gt;terser-brunch&lt;/code&gt;&lt;/a&gt; plugin:</source>
          <target state="translated">가장 효율적인 Brunch 프로덕션 빌드를 위해 &lt;a href=&quot;https://github.com/brunch/terser-brunch&quot;&gt; &lt;code&gt;terser-brunch&lt;/code&gt; &lt;/a&gt; 플러그인을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6ce51b2f939e3558a44b1cb8fdbdf554bc07d90" translate="yes" xml:space="preserve">
          <source>For the most efficient Rollup production build, install a few plugins:</source>
          <target state="translated">가장 효율적인 롤업 프로덕션 빌드를 위해 몇 가지 플러그인을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="7475cb5e6f5adf915c29f1cdea4e2bdc8ba92aa9" translate="yes" xml:space="preserve">
          <source>For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.</source>
          <target state="translated">이러한 이유로 우리는 가장 중요한 버그 및 보안 취약점에 대해서만 패치 릴리스를 예약합니다.</target>
        </trans-unit>
        <trans-unit id="faa8c036fd5e3a800041a6a85017b66c2fe68715" translate="yes" xml:space="preserve">
          <source>For this change, we&amp;rsquo;ve provided a &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; to automatically migrate your code.</source>
          <target state="translated">이 변경을 위해 코드를 자동으로 마이그레이션하기 위한 &lt;a href=&quot;https://github.com/reactjs/react-codemod#error-boundaries&quot;&gt;codemod&lt;/a&gt; 가 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1bce685a135223c199242bc8c77e474653706f" translate="yes" xml:space="preserve">
          <source>For this reason &lt;code&gt;useDebugValue&lt;/code&gt; accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.</source>
          <target state="translated">이러한 이유로 &lt;code&gt;useDebugValue&lt;/code&gt; 는 선택적 두 번째 매개 변수로 형식화 기능을 승인합니다. 이 기능은 후크를 검사 한 경우에만 호출됩니다. 디버그 값을 매개 변수로 수신하며 형식화 된 표시 값을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="d77cd5d73e371d728872a07b909df96d58e4b7b3" translate="yes" xml:space="preserve">
          <source>Forgetting to handle &lt;code&gt;componentDidUpdate&lt;/code&gt; properly is a common source of bugs in React applications.</source>
          <target state="translated">&lt;code&gt;componentDidUpdate&lt;/code&gt; 를 올바르게 처리 하지 않는 것은 React 애플리케이션의 일반적인 버그 소스입니다.</target>
        </trans-unit>
        <trans-unit id="7d30ae53e81b25bd47a3ef79f6270bb2aee0a4b4" translate="yes" xml:space="preserve">
          <source>Form Events</source>
          <target state="translated">양식 이벤트</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="955e3f80970e0af47e55f5200545b8b3a318bc97" translate="yes" xml:space="preserve">
          <source>Fortunately, we can explicitly forward refs to the inner &lt;code&gt;FancyButton&lt;/code&gt; component using the &lt;code&gt;React.forwardRef&lt;/code&gt; API. &lt;code&gt;React.forwardRef&lt;/code&gt; accepts a render function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; parameters and returns a React node. For example:</source>
          <target state="translated">다행히 &lt;code&gt;React.forwardRef&lt;/code&gt; API를 사용하여 내부 &lt;code&gt;FancyButton&lt;/code&gt; 구성 요소에 참조를 명시 적으로 전달할 수 있습니다 . &lt;code&gt;React.forwardRef&lt;/code&gt; 는 &lt;code&gt;props&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 매개 변수 를 수신 하고 React 노드를 리턴 하는 렌더 함수를 승인 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f601df170026e953bbac95daafb8c35102220f96" translate="yes" xml:space="preserve">
          <source>Forwarding Refs</source>
          <target state="translated">전달 참조</target>
        </trans-unit>
        <trans-unit id="98364eb3c7e295c55161e71c692712d164542fd6" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order components</source>
          <target state="translated">고차 부품의 참조 전달</target>
        </trans-unit>
        <trans-unit id="fe54eca6f507b141b7575b8953c555c23ecbd348" translate="yes" xml:space="preserve">
          <source>Forwarding refs in higher-order-components</source>
          <target state="translated">고차 부품의 참조 전달</target>
        </trans-unit>
        <trans-unit id="ee0dcf389f3ad894e637d4cba7ff22af9df9a072" translate="yes" xml:space="preserve">
          <source>Forwarding refs to DOM components</source>
          <target state="translated">참조를 DOM 구성 요소로 전달</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="796f3ca672ebd9bd41a7a01b5a01b8745791f0e8" translate="yes" xml:space="preserve">
          <source>Fragments declared with the explicit &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; syntax may have keys. A use case for this is mapping a collection to an array of fragments &amp;mdash; for example, to create a description list:</source>
          <target state="translated">명시적인 &lt;code&gt;&amp;lt;React.Fragment&amp;gt;&lt;/code&gt; 구문 으로 선언 된 조각 에는 키가있을 수 있습니다. 이를위한 유스 케이스는 콜렉션을 단편 배열에 맵핑하는 것입니다 (예 : 설명 목록 작성).</target>
        </trans-unit>
        <trans-unit id="8065c017db022d1f5ec110b82bbd874c082a88f9" translate="yes" xml:space="preserve">
          <source>Fragments solve this problem.</source>
          <target state="translated">조각은이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="3bcb0016a5230b33666fdcf36ccabf570e7de70e" translate="yes" xml:space="preserve">
          <source>Frameworks like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt;, &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; and &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; are useful for running &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;end-to-end tests&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; , &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; 및 &lt;a href=&quot;https://www.seleniumhq.org/projects/webdriver/&quot;&gt;webdriver&lt;/a&gt; 와 같은 프레임 워크 는 &lt;a href=&quot;#end-to-end-tests-aka-e2e-tests&quot;&gt;엔드 투 엔드 테스트&lt;/a&gt; 를 실행하는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf9e2789ee767980ad3bc5023d41ac7e306fd5ec" translate="yes" xml:space="preserve">
          <source>Frameworks like Jest also let you save &amp;ldquo;snapshots&amp;rdquo; of data with &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;&lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;&lt;/a&gt;. With these, we can &amp;ldquo;save&amp;rdquo; the rendered component output and ensure that a change to it has to be explicitly committed as a change to the snapshot.</source>
          <target state="translated">Jest와 같은 프레임 워크를 사용하면 &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt; &lt;code&gt;toMatchSnapshot&lt;/code&gt; / &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; 을 사용&lt;/a&gt; 하여 데이터의 &quot;스냅 샷&quot;을 저장할 수 있습니다 . 이를 통해 렌더링 된 구성 요소 출력을 &quot;저장&quot;하고 변경 사항을 스냅 샷 변경으로 명시 적으로 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="149defa1bf170ed878773e58e8f5ff8d5c8a3478" translate="yes" xml:space="preserve">
          <source>From Classes to Hooks</source>
          <target state="translated">수업에서 후크까지</target>
        </trans-unit>
        <trans-unit id="bbed11ef2d053428bd9995e6dc4db90c56f977a2" translate="yes" xml:space="preserve">
          <source>From React&amp;rsquo;s point of view, a component using Hooks is just a regular component. If your testing solution doesn&amp;rsquo;t rely on React internals, testing components with Hooks shouldn&amp;rsquo;t be different from how you normally test components.</source>
          <target state="translated">React의 관점에서 후크를 사용하는 구성 요소는 일반적인 구성 요소입니다. 테스트 솔루션이 React internals에 의존하지 않는 경우 후크가있는 구성 요소 테스트는 일반적으로 구성 요소를 테스트하는 방법과 다르지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="12d07daa800d296a026c49de79bda8bb9f64ea8a" translate="yes" xml:space="preserve">
          <source>From here you could start moving more logic into the component and begin adopting more common React practices. For example, in components it is best not to rely on IDs because the same component can be rendered multiple times. Instead, we will use the &lt;a href=&quot;handling-events&quot;&gt;React event system&lt;/a&gt; and register the click handler directly on the React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">여기에서 더 많은 로직을 컴포넌트로 옮기고보다 일반적인 React 사례를 채택 할 수 있습니다. 예를 들어 구성 요소에서는 동일한 구성 요소를 여러 번 렌더링 할 수 있으므로 ID에 의존하지 않는 것이 가장 좋습니다. 대신 &lt;a href=&quot;handling-events&quot;&gt;React 이벤트 시스템을&lt;/a&gt; 사용 하고 React &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 요소 에 직접 클릭 핸들러를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="732afd30e77a6dc18afd55e03cd71f20b12f519d" translate="yes" xml:space="preserve">
          <source>Fully-Fledged Solutions</source>
          <target state="translated">완전한 솔루션</target>
        </trans-unit>
        <trans-unit id="d1ab6dc65e716361136b87c26f6834c3fa7eba19" translate="yes" xml:space="preserve">
          <source>Function and Class Components</source>
          <target state="translated">기능 및 클래스 구성 요소</target>
        </trans-unit>
        <trans-unit id="fd744c2eded0413dd090011205868c3aa86df00b" translate="yes" xml:space="preserve">
          <source>Function and Class components both have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;.</source>
          <target state="translated">Function and Class components both have some additional features that we will discuss in the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next sections&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ccf4dbac73be46db02a4f245d06acae861568bf3" translate="yes" xml:space="preserve">
          <source>Function component bodies</source>
          <target state="translated">Function component bodies</target>
        </trans-unit>
        <trans-unit id="a0437f301087d86e5d06d2280e2674b540deaba5" translate="yes" xml:space="preserve">
          <source>Function components are also able to reference &lt;code&gt;context&lt;/code&gt; if &lt;code&gt;contextTypes&lt;/code&gt; is defined as a property of the function. The following code shows a &lt;code&gt;Button&lt;/code&gt; component written as a function component.</source>
          <target state="translated">&lt;code&gt;contextTypes&lt;/code&gt; 가 함수의 속성으로 정의 된 경우 함수 구성 요소는 &lt;code&gt;context&lt;/code&gt; 를 참조 할 수도 있습니다. 다음 코드는 함수 구성 요소로 작성된 &lt;code&gt;Button&lt;/code&gt; 구성 요소를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="73f523ab76ca84802a4f7ad409b8b8a11d5ec14d" translate="yes" xml:space="preserve">
          <source>Functional updates</source>
          <target state="translated">기능 업데이트</target>
        </trans-unit>
        <trans-unit id="68254545bf32d5c6b80d7f1482247c069c365636" translate="yes" xml:space="preserve">
          <source>Functions as Children</source>
          <target state="translated">어린이로서의 기능</target>
        </trans-unit>
        <trans-unit id="1f41b572070fa59c9db0924aa546698fb57d612e" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;useState&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, or &lt;code&gt;useReducer&lt;/code&gt;</source>
          <target state="translated">Functions passed to &lt;code&gt;useState&lt;/code&gt; , &lt;code&gt;useMemo&lt;/code&gt; , or &lt;code&gt;useReducer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b8b995fc31e98c113f50f1e6e4e3cd2d61d6d9d" translate="yes" xml:space="preserve">
          <source>Fundamentally, JSX just provides syntactic sugar for the &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; function. The JSX code:</source>
          <target state="translated">기본적으로 JSX는 &lt;code&gt;React.createElement(component, props, ...children)&lt;/code&gt; 함수에 구문 설탕을 제공 합니다. JSX 코드 :</target>
        </trans-unit>
        <trans-unit id="4d6b62bf07d530cf7754450cf7f4baeba776dcc5" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;React.PureComponent&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; skips prop updates for the whole component subtree. Make sure all the children components are also &amp;ldquo;pure&amp;rdquo;.</source>
          <target state="translated">또한 &lt;code&gt;React.PureComponent&lt;/code&gt; 의 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 는 전체 컴포넌트 하위 트리에 대한 prop 업데이트를 건너 뜁니다. 모든 하위 구성 요소도 &quot;순수&quot;해야합니다.</target>
        </trans-unit>
        <trans-unit id="96bfe330b3c43755e29748c139c92671348a757f" translate="yes" xml:space="preserve">
          <source>Gatsby</source>
          <target state="translated">Gatsby</target>
        </trans-unit>
        <trans-unit id="14837150cbbe37e0d75d8160b89e20cd804e5090" translate="yes" xml:space="preserve">
          <source>Generally speaking, no.</source>
          <target state="translated">일반적으로 말해서</target>
        </trans-unit>
        <trans-unit id="52caaec9d0bac23a32c7ed19ebe70c6cf9d9b6ff" translate="yes" xml:space="preserve">
          <source>Generally speaking, yes, it is OK, and it is often the easiest way to pass parameters to callback functions.</source>
          <target state="translated">일반적으로, 그렇습니다. 괜찮습니다. 종종 콜백 함수에 매개 변수를 전달하는 가장 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="28a76c547269406d92dd91388795bcc92164307d" translate="yes" xml:space="preserve">
          <source>Generally, you don&amp;rsquo;t want to keep the generated javascript in your source control, so be sure to add the build folder to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">일반적으로 생성 된 자바 스크립트를 소스 제어에 유지하지 않으려면 빌드 폴더를 &lt;code&gt;.gitignore&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="18b5b1a5960100dd8954a497a5206e63c5798df0" translate="yes" xml:space="preserve">
          <source>Generic Events</source>
          <target state="translated">Generic Events</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="b75a226127e3ed2978b5f42961dd98a51c54f567" translate="yes" xml:space="preserve">
          <source>Given the code below, we use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; function to take an array of &lt;code&gt;numbers&lt;/code&gt; and double their values. We assign the new array returned by &lt;code&gt;map()&lt;/code&gt; to the variable &lt;code&gt;doubled&lt;/code&gt; and log it:</source>
          <target state="translated">아래 코드가 주어지면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 &lt;code&gt;numbers&lt;/code&gt; 배열을 가져 와서 값을 두 배로 만듭니다. &lt;code&gt;map()&lt;/code&gt; 이 반환 한 새 배열 을 변수 &lt;code&gt;doubled&lt;/code&gt; 에 할당 하고 기록합니다.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="96136d53d8b75905c13546cd90a5c916cbb29871" translate="yes" xml:space="preserve">
          <source>Glossary and FAQ</source>
          <target state="translated">용어 및 FAQ</target>
        </trans-unit>
        <trans-unit id="2f13a545b80f208a5c342a3f09da99fe34c3e60a" translate="yes" xml:space="preserve">
          <source>Glossary of React Terms</source>
          <target state="translated">반응 용어집</target>
        </trans-unit>
        <trans-unit id="c8a8632c801140a5a9de611953f386d1dbbf8845" translate="yes" xml:space="preserve">
          <source>Go to your project folder in the terminal, and paste these two commands:</source>
          <target state="translated">터미널의 프로젝트 폴더로 이동하여 다음 두 명령을 붙여 넣습니다.</target>
        </trans-unit>
        <trans-unit id="d182bef8d5f2839f88903394bb60f7e51fd6c42c" translate="yes" xml:space="preserve">
          <source>Google Chromebook Help - Use the Built-in Screen Reader</source>
          <target state="translated">Google 크롬 북 도움말-내장 스크린 리더 사용</target>
        </trans-unit>
        <trans-unit id="bcf36c27c78804650761947c87a38f4f6e07ce7e" translate="yes" xml:space="preserve">
          <source>Gradual Adoption Strategy</source>
          <target state="translated">점진적 입양 전략</target>
        </trans-unit>
        <trans-unit id="428e0a93f1ac72bcc666336cd6d935f2d9640d9e" translate="yes" xml:space="preserve">
          <source>Gradual Upgrades via Warnings</source>
          <target state="translated">경고를 통한 점진적 업그레이드</target>
        </trans-unit>
        <trans-unit id="58273e47057ce993d5fd97a4eb4dface99c26929" translate="yes" xml:space="preserve">
          <source>Great! Now when we run our build script the compiler will output the generated javascript to the &lt;code&gt;build&lt;/code&gt; folder. The &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;TypeScript React Starter&lt;/a&gt; provides a &lt;code&gt;tsconfig.json&lt;/code&gt; with a good set of rules to get you started.</source>
          <target state="translated">큰! 빌드 스크립트를 실행하면 컴파일러는 생성 된 자바 스크립트를 &lt;code&gt;build&lt;/code&gt; 폴더에 출력 합니다. &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Starter/blob/master/tsconfig.json&quot;&gt;타이프 라이터는 스타터 반응&lt;/a&gt; 제공 &lt;code&gt;tsconfig.json&lt;/code&gt; 시작하기 위해 규칙의 좋은 세트를.</target>
        </trans-unit>
        <trans-unit id="72b257d572f9de8cb600dc9ff344b295b0affeca" translate="yes" xml:space="preserve">
          <source>Grouping by features or routes</source>
          <target state="translated">기능 또는 경로별로 그룹화</target>
        </trans-unit>
        <trans-unit id="b7fd6516d065f4d8e30a111bc4d1476d4af19bbe" translate="yes" xml:space="preserve">
          <source>Grouping by file type</source>
          <target state="translated">파일 유형별로 그룹화</target>
        </trans-unit>
        <trans-unit id="b02dd6f98e40fbc355cf17dc049baecc28173b57" translate="yes" xml:space="preserve">
          <source>HOCs add features to a component. They shouldn&amp;rsquo;t drastically alter its contract. It&amp;rsquo;s expected that the component returned from a HOC has a similar interface to the wrapped component.</source>
          <target state="translated">HOC는 구성 요소에 기능을 추가합니다. 계약을 크게 변경해서는 안됩니다. HOC에서 리턴 된 컴포넌트는 랩된 컴포넌트와 유사한 인터페이스를 가질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="063035c50f06bf73e08fe91d42e9d79e9dcc00b0" translate="yes" xml:space="preserve">
          <source>HOCs are common in third-party React libraries, such as Redux&amp;rsquo;s &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; and Relay&amp;rsquo;s &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HOC는 Redux의 &lt;a href=&quot;https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 및 Relay의 &lt;a href=&quot;http://facebook.github.io/relay/docs/en/fragment-container.html&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; 와 같은 타사 React 라이브러리에서 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="5c8962b048f87decc8156392f32206c1be5db772" translate="yes" xml:space="preserve">
          <source>HOCs should pass through props that are unrelated to its specific concern. Most HOCs contain a render method that looks something like this:</source>
          <target state="translated">HOC는 특정 관심사와 관련이없는 소품을 통과해야합니다. 대부분의 HOC에는 다음과 같은 렌더링 메소드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="90574747f52ec1f5009a45ed8d33cb2283639a02" translate="yes" xml:space="preserve">
          <source>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</source>
          <target state="translated">HTML 요소는 React의 다른 DOM 요소와 약간 다르게 작동합니다. 양식 요소는 자연스럽게 내부 상태를 유지하기 때문입니다. 예를 들어, 일반 HTML로 된이 양식은 단일 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0d2d67fd740d7ec7df3d8674c33679652ab92712" translate="yes" xml:space="preserve">
          <source>Handling Errors</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="d425f7e27fe0f057871c46f4c72c4a3bd2b0f136" translate="yes" xml:space="preserve">
          <source>Handling Events</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="a45618425a820085679577753f54c9b8cd00317e" translate="yes" xml:space="preserve">
          <source>Handling Multiple Inputs</source>
          <target state="translated">여러 입력 처리</target>
        </trans-unit>
        <trans-unit id="af96eff387bd2ffe3a5340f3ed51fac600fd535c" translate="yes" xml:space="preserve">
          <source>Handling events with React elements has some syntactic differences:</source>
          <target state="translated">React 요소로 이벤트를 처리하는 것은 약간의 구문상의 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5e781a7966802398bc6183dffb3545a19611d53" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</source>
          <target state="translated">React 요소로 이벤트를 처리하는 것은 DOM 요소에서 이벤트를 처리하는 것과 매우 유사합니다. 구문상의 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47bdd35246e7567f551a4817bb36764578de248d" translate="yes" xml:space="preserve">
          <source>Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</source>
          <target state="translated">Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</target>
        </trans-unit>
        <trans-unit id="710df444e674bad2b7f10527830ac10000028b6c" translate="yes" xml:space="preserve">
          <source>Here are some good resources for further reading on when to use &lt;code&gt;props&lt;/code&gt; vs &lt;code&gt;state&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 와 &lt;code&gt;state&lt;/code&gt; 를 언제 사용할 지에 대한 추가 자료를 얻을 수있는 좋은 자료는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa9e19aaf02a489848d103e6df5f48fd01b2888" translate="yes" xml:space="preserve">
          <source>Here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;an example of the issues that can be caused by using indexes as keys&lt;/a&gt; on CodePen, and here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues&lt;/a&gt;.</source>
          <target state="translated">Here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&quot;&gt;an example of the issues that can be caused by using indexes as keys&lt;/a&gt; on CodePen, and here is &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&quot;&gt;an updated version of the same example showing how not using indexes as keys will fix these reordering, sorting, and prepending issues&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a3421fa1b421c70fdf50bc5b3706d1884ec45d9" translate="yes" xml:space="preserve">
          <source>Here is a &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;small demo&lt;/a&gt; to get you started. To learn more, check out &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; about data fetching with Hooks.</source>
          <target state="translated">다음은 시작하기 위한 &lt;a href=&quot;https://codesandbox.io/s/jvvkoo8pq3&quot;&gt;작은 데모&lt;/a&gt; 입니다. 자세한 내용 은 Hooks를 사용한 데이터 가져 오기에 대한 &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;이 기사&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8317f95e08c6543e53027d145f8eddcf023d7fe" translate="yes" xml:space="preserve">
          <source>Here is a step-by-step explanation of what happens in the above example:</source>
          <target state="translated">위의 예에서 발생하는 상황에 대한 단계별 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10e83a22ccb4f6fc7030872a422ceee48e5b88b6" translate="yes" xml:space="preserve">
          <source>Here is an &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;in-depth explanation about why keys are necessary&lt;/a&gt; if you&amp;rsquo;re interested in learning more.</source>
          <target state="translated">여기입니다 &lt;a href=&quot;reconciliation#recursing-on-children&quot;&gt;키가 필요한 이유에 대한 깊이있는 설명이&lt;/a&gt; 좀 더 학습에 관심이 있다면이.</target>
        </trans-unit>
        <trans-unit id="469c11af4fb767b071b7bc9fc6660c36d0303d75" translate="yes" xml:space="preserve">
          <source>Here is an example documenting the different validators provided:</source>
          <target state="translated">제공된 다른 유효성 검사기를 문서화하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd61c330907127ed38d293d1d4af5a24b4c290e7" translate="yes" xml:space="preserve">
          <source>Here is how we can test it:</source>
          <target state="translated">테스트 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3102275a43d8c23e8b4c58890783bfe23456b8e1" translate="yes" xml:space="preserve">
          <source>Here is the equivalent with &lt;a href=&quot;hooks-intro&quot;&gt;Hooks&lt;/a&gt;:</source>
          <target state="translated">Here is the equivalent with &lt;a href=&quot;hooks-intro&quot;&gt;Hooks&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="36728af60fa3c9f7c434352505e9201caca43d44" translate="yes" xml:space="preserve">
          <source>Here we require knowledge of &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA Roles&lt;/a&gt; as well as &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;ARIA States and Properties&lt;/a&gt;. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</source>
          <target state="translated">여기서 우리는 &lt;a href=&quot;https://www.w3.org/TR/wai-aria/#roles&quot;&gt;ARIA 상태 &lt;/a&gt;&lt;a href=&quot;https://www.w3.org/TR/wai-aria/#states_and_properties&quot;&gt;및 속성&lt;/a&gt; 뿐만 아니라 ARIA 역할에 대한 지식이 필요합니다 . 이것들은 JSX에서 완벽하게 지원되는 HTML 속성으로 채워진 툴박스이며, 우리가 완전히 액세스 가능한 고기능 React 컴포넌트를 구성 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="dc9d8cd325a00d9730f610bfeca5652d530f0f8e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a subtree of components. For each one, &lt;code&gt;SCU&lt;/code&gt; indicates what &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned, and &lt;code&gt;vDOMEq&lt;/code&gt; indicates whether the rendered React elements were equivalent. Finally, the circle&amp;rsquo;s color indicates whether the component had to be reconciled or not.</source>
          <target state="translated">다음은 컴포넌트의 서브 트리입니다. 각각에 대해 &lt;code&gt;SCU&lt;/code&gt; 는 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 가 반환 한 &lt;code&gt;vDOMEq&lt;/code&gt; 나타내고 vDOMEq 는 렌더링 된 React 요소가 동일한 지 여부를 나타냅니다. 마지막으로 원의 색상은 구성 요소의 조정 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3e5e88093705abf9b440083ab6665499dccb5254" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how to setup route-based code splitting into your app using libraries like &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; with &lt;code&gt;React.lazy&lt;/code&gt;.</source>
          <target state="translated">다음 은 &lt;code&gt;React.lazy&lt;/code&gt; 와 함께 &lt;a href=&quot;https://reacttraining.com/react-router/&quot;&gt;React Router&lt;/a&gt; 와 같은 라이브러리를 사용하여 앱에 라우트 기반 코드 분할을 설정하는 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="983fc3a4301db31eed982a269174f75044f4d44b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the counter example from the &lt;a href=&quot;#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; section, rewritten to use a reducer:</source>
          <target state="translated">다음은 &lt;a href=&quot;#usestate&quot;&gt; &lt;code&gt;useState&lt;/code&gt; &lt;/a&gt; 섹션 의 카운터 예제 이며 감속기를 사용하도록 다시 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ccd56b3438af9572583e63a1873615e49b63ab1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what happens when we render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; on the screen:</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 를 화면에 렌더링하면 다음과 같이됩니다 .</target>
        </trans-unit>
        <trans-unit id="23a6a5eadd7c0a89a44b430f4d016d98f4bf2e1e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where the render prop comes in: Instead of hard-coding a &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; inside a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, and effectively changing its rendered output, we can provide &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a function prop that it uses to dynamically determine what to render&amp;ndash;a render prop.</source>
          <target state="translated">렌더 소품이 들어온 곳은 다음과 같습니다 . &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 구성 요소 내 에서 &lt;code&gt;&amp;lt;Cat&amp;gt;&lt;/code&gt; 를 하드 코딩 하고 렌더링 된 출력을 효과적으로 변경하는 대신 렌더링 할 항목 을 동적으로 결정하는 데 사용되는 함수 소품을 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 에 제공 할 수 있습니다. &amp;ndash; 렌더 소품.</target>
        </trans-unit>
        <trans-unit id="4fc4a89b23c19ca1c558111776c4ec5e877854de" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="translated">Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the &lt;a href=&quot;events&quot;&gt; &lt;code&gt;SyntheticEvent&lt;/code&gt; &lt;/a&gt; reference guide to learn more.</target>
        </trans-unit>
        <trans-unit id="f2ee35e6fcb6ceeda6ad5733dbfe3081d417836a" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;e&lt;/code&gt; is a synthetic event. React defines these synthetic events according to the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C spec&lt;/a&gt;, so you don&amp;rsquo;t need to worry about cross-browser compatibility. See the &lt;a href=&quot;events&quot;&gt;&lt;code&gt;SyntheticEvent&lt;/code&gt;&lt;/a&gt; reference guide to learn more.</source>
          <target state="translated">여기서 &lt;code&gt;e&lt;/code&gt; 는 합성 이벤트입니다. React는 &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;W3C 사양&lt;/a&gt; 에 따라 이러한 합성 이벤트를 정의 하므로 브라우저 간 호환성에 대해 걱정할 필요가 없습니다. 자세한 내용은 &lt;a href=&quot;events&quot;&gt; &lt;code&gt;SyntheticEvent&lt;/code&gt; &lt;/a&gt; 참조 안내서를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc55606f595a34d3c61c69e9ffbf6a6904254c39" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;useState&lt;/code&gt; is a &lt;em&gt;Hook&lt;/em&gt; (we&amp;rsquo;ll talk about what this means in a moment). We call it inside a function component to add some local state to it. React will preserve this state between re-renders. &lt;code&gt;useState&lt;/code&gt; returns a pair: the &lt;em&gt;current&lt;/em&gt; state value and a function that lets you update it. You can call this function from an event handler or somewhere else. It&amp;rsquo;s similar to &lt;code&gt;this.setState&lt;/code&gt; in a class, except it doesn&amp;rsquo;t merge the old and new state together. (We&amp;rsquo;ll show an example comparing &lt;code&gt;useState&lt;/code&gt; to &lt;code&gt;this.state&lt;/code&gt; in &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.)</source>
          <target state="translated">여기서 &lt;code&gt;useState&lt;/code&gt; 는 &lt;em&gt;Hook입니다&lt;/em&gt; (이것이 곧 무엇을 의미하는지 이야기하겠습니다). 함수 구성 요소 내에서 호출하여 로컬 상태를 추가합니다. 반응은 다시 렌더링 사이에이 상태를 유지합니다. &lt;code&gt;useState&lt;/code&gt; 는 &lt;em&gt;현재&lt;/em&gt; 상태 값과이를 업데이트 할 수있는 함수 쌍을 반환 합니다. 이벤트 핸들러 또는 다른 곳에서이 함수를 호출 할 수 있습니다. 이전 상태와 새로운 상태를 병합하지 않는다는 점을 제외하고 클래스의 &lt;code&gt;this.setState&lt;/code&gt; 와 유사 합니다. (우리는 비교 예를 보여 드리겠습니다 &lt;code&gt;useState&lt;/code&gt; 을 에 &lt;code&gt;this.state&lt;/code&gt; 에 &lt;a href=&quot;hooks-state&quot;&gt;국가 후크를 사용하여&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="62ba3ca71c800446a468a8f1df328896c57eaf85" translate="yes" xml:space="preserve">
          <source>Here, we store the previous value of the &lt;code&gt;row&lt;/code&gt; prop in a state variable so that we can compare:</source>
          <target state="translated">여기에서 &lt;code&gt;row&lt;/code&gt; 소품 의 이전 값을 상태 변수에 저장하여 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="694a8ab065bc1ddcb8bfd82b16d99febb5b29744" translate="yes" xml:space="preserve">
          <source>Heydon Pickering - ARIA Examples</source>
          <target state="translated">헤이 던 피커링-ARIA 사례</target>
        </trans-unit>
        <trans-unit id="9949204d6ccc01e71532e6b5a07e754220b79927" translate="yes" xml:space="preserve">
          <source>Higher-Order Components</source>
          <target state="translated">더 높은 주문 구성 요소</target>
        </trans-unit>
        <trans-unit id="020cce2b859c795f0df3f5cefeb0457647d208e5" translate="yes" xml:space="preserve">
          <source>Higher-order components come with a few caveats that aren&amp;rsquo;t immediately obvious if you&amp;rsquo;re new to React.</source>
          <target state="translated">고차 부품에는 React를 처음 사용하는 경우 즉시 알 수없는 몇 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="5f4d9480b4df0d6e740642769da4ab963d23e1df" translate="yes" xml:space="preserve">
          <source>Hooks &lt;strong&gt;don&amp;rsquo;t&lt;/strong&gt; work inside classes. But you can use them instead of writing classes.</source>
          <target state="translated">수업 내 &lt;strong&gt;에서는&lt;/strong&gt; 후크 &lt;strong&gt;가&lt;/strong&gt; 작동 &lt;strong&gt;하지 않습니다&lt;/strong&gt; . 그러나 클래스를 작성하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6346e065d302bd612cb57acc37b5c4b2d11b5c55" translate="yes" xml:space="preserve">
          <source>Hooks API Reference</source>
          <target state="translated">후크 API 참조</target>
        </trans-unit>
        <trans-unit id="83f68a3284889949ad8da40e185f437f9cd788cc" translate="yes" xml:space="preserve">
          <source>Hooks FAQ</source>
          <target state="translated">후크 FAQ</target>
        </trans-unit>
        <trans-unit id="6741749abbd97e5aa67270b4114318826ae8ec0d" translate="yes" xml:space="preserve">
          <source>Hooks and Function Components</source>
          <target state="translated">후크 및 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="984e9f1dce4f6c473f93ec63fbba28614d61a0c3" translate="yes" xml:space="preserve">
          <source>Hooks are &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;backwards-compatible&lt;/a&gt;. This page provides an overview of Hooks for experienced React users. This is a fast-paced overview. If you get confused, look for a yellow box like this:</source>
          <target state="translated">후크는 &lt;a href=&quot;hooks-intro#no-breaking-changes&quot;&gt;이전 버전과 호환됩니다&lt;/a&gt; . 이 페이지는 숙련 된 React 사용자를위한 후크 개요를 제공합니다. 이것은 빠르게 진행되는 개요입니다. 혼란 스러우면 다음과 같은 노란색 상자를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="de1b424d96849c452e8623c3aff21cbd2124f794" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but they impose two additional rules:</source>
          <target state="translated">후크는 JavaScript 함수이지만 두 가지 추가 규칙을 부과합니다.</target>
        </trans-unit>
        <trans-unit id="c38711e94905b544d78f9780d3bf6f82e5586c52" translate="yes" xml:space="preserve">
          <source>Hooks are JavaScript functions, but you need to follow two rules when using them. We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically:</source>
          <target state="translated">후크는 JavaScript 함수이지만 사용시 두 가지 규칙을 따라야합니다. 이러한 규칙을 자동으로 시행 하기위한 &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;린터 플러그인&lt;/a&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="12baa054732ac507c2f0e0ac9c1bc905d155c97a" translate="yes" xml:space="preserve">
          <source>Hooks are a more direct way to use the React features you already know &amp;mdash; such as state, lifecycle, context, and refs. They don&amp;rsquo;t fundamentally change how React works, and your knowledge of components, props, and top-down data flow is just as relevant.</source>
          <target state="translated">후크는 상태, 수명주기, 컨텍스트 및 참조와 같이 이미 알고있는 React 기능을 사용하는보다 직접적인 방법입니다. 기본적으로 React의 작동 방식을 변경하지 않으며 구성 요소, 소품 및 하향식 데이터 흐름에 대한 지식도 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3dffafdaf027921074c093681b6b2fa42d7706d" translate="yes" xml:space="preserve">
          <source>Hooks are called in the same order on every render.</source>
          <target state="translated">후크는 모든 렌더에서 동일한 순서로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4f6e49743738970df49a4e276c80da3002abd881" translate="yes" xml:space="preserve">
          <source>Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React state and lifecycle features from function components. Hooks don&amp;rsquo;t work inside classes &amp;mdash; they let you use React without classes. (We &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;don&amp;rsquo;t recommend&lt;/a&gt; rewriting your existing components overnight but you can start using Hooks in the new ones if you&amp;rsquo;d like.)</source>
          <target state="translated">후크는 기능 구성 요소의 반응 상태 및 수명주기 기능을 &quot;후크&quot;할 수있는 기능입니다. 후크는 클래스 내부에서 작동하지 않습니다. 클래스없이 React를 사용할 수 있습니다. (우리는 &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;하지 않는 것이 좋습니다&lt;/a&gt; 하룻밤 기존 구성 요소를 다시 작성하지만 당신은 당신이 원하는 경우 새로운에서 후크를 사용하여 시작할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ea0760f5cbbc31d25fdb696fae6c90d049a7e43f" translate="yes" xml:space="preserve">
          <source>Hooks at a Glance</source>
          <target state="translated">한눈에보기</target>
        </trans-unit>
        <trans-unit id="d26a024e6656cfd225f9b3faaf69112eb79c72b0" translate="yes" xml:space="preserve">
          <source>Hooks avoid a lot of the overhead that classes require, like the cost of creating class instances and binding event handlers in the constructor.</source>
          <target state="translated">후크는 클래스 인스턴스 작성 및 생성자에서 이벤트 핸들러 바인딩 비용과 같이 클래스에 필요한 많은 오버 헤드를 피합니다.</target>
        </trans-unit>
        <trans-unit id="c4f46f02e8a51698c3e23f41f8d864b3b26080e0" translate="yes" xml:space="preserve">
          <source>Hooks do have a learning curve of their own. If there&amp;rsquo;s something missing in this documentation, &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;raise an issue&lt;/a&gt; and we&amp;rsquo;ll try to help.</source>
          <target state="translated">훅에는 자체 학습 곡선이 있습니다. 이 문서에 빠진 &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;것이 있으면 문제를 제기하면&lt;/a&gt; 도와 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="e78aadbe4b447f0e05b05e1acb099273d9660236" translate="yes" xml:space="preserve">
          <source>Hooks let you organize side effects in a component by what pieces are related (such as adding and removing a subscription), rather than forcing a split based on lifecycle methods.</source>
          <target state="translated">후크를 사용하면 수명주기 방법을 기준으로 분할을 수행하지 않고 관련 부분 (예 : 구독 추가 및 제거)으로 구성 요소의 부작용을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fd8adc24c90fba774c6fae7ebe2e06da199b06e" translate="yes" xml:space="preserve">
          <source>Hooks offer a powerful and expressive new way to reuse functionality between components. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;Building Your Own Hooks&amp;rdquo;&lt;/a&gt; provides a glimpse of what&amp;rsquo;s possible. &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;This article&lt;/a&gt; by a React core team member dives deeper into the new capabilities unlocked by Hooks.</source>
          <target state="translated">후크는 구성 요소 간 기능을 재사용 할 수있는 강력하고 표현력있는 새로운 방법을 제공합니다. &lt;a href=&quot;hooks-custom&quot;&gt;&amp;ldquo;자신의 고리 만들기&amp;rdquo;&lt;/a&gt; 는 가능한 것을 살짝 보여줍니다. React 핵심 팀원 &lt;a href=&quot;https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889&quot;&gt;이 작성한이 기사&lt;/a&gt; 는 Hooks가 잠금 해제 한 새로운 기능에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="beee8e71e8faa563add416aa12ae92953a859ef1" translate="yes" xml:space="preserve">
          <source>Hooks solve a wide variety of seemingly unconnected problems in React that we&amp;rsquo;ve encountered over five years of writing and maintaining tens of thousands of components. Whether you&amp;rsquo;re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</source>
          <target state="translated">후크는 React에서 5 년 이상 수만 개의 구성 요소를 작성하고 유지 관리하는 동안 발생했던 연결되지 않은 다양한 문제를 해결합니다. React를 배우거나 매일 사용하거나 비슷한 구성 요소 모델을 가진 다른 라이브러리를 선호하더라도 이러한 문제 중 일부를 인식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="125ff9caefd47f46f6f9836d25c8aeb5965e4029" translate="yes" xml:space="preserve">
          <source>Hooks synthesize ideas from several different sources:</source>
          <target state="translated">후크는 여러 소스에서 아이디어를 합성합니다.</target>
        </trans-unit>
        <trans-unit id="9ddd1c044852bd20a73c95243ed31e59f05c49ac" translate="yes" xml:space="preserve">
          <source>Hooks were designed with static typing in mind. Because they&amp;rsquo;re functions, they are easier to type correctly than patterns like higher-order components. The latest Flow and TypeScript React definitions include support for React Hooks.</source>
          <target state="translated">후크는 정적 타이핑을 염두에두고 설계되었습니다. 그것들은 기능이기 때문에 고차 컴포넌트와 같은 패턴보다 올바르게 입력하기가 더 쉽습니다. 최신 Flow 및 TypeScript React 정의에는 React Hook 지원이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3263600c56483c0a3a486401c7c00425cf496889" translate="yes" xml:space="preserve">
          <source>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you&amp;rsquo;re used to, remember that code is read far more than it&amp;rsquo;s written, and it&amp;rsquo;s less difficult to read this modular, explicit code. As you start to build large libraries of components, you&amp;rsquo;ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</source>
          <target state="translated">바라건대, 이것은 React로 컴포넌트와 애플리케이션을 구축하는 방법에 대한 아이디어를 제공합니다. 사용하는 것보다 타이핑이 조금 더 많을 수 있지만 코드는 작성된 것보다 훨씬 많이 읽히므로 모듈 식의 명시 적 코드를 읽는 것이 어렵지 않습니다. 대규모 구성 요소 라이브러리를 구축하기 시작하면 이러한 명시 성과 모듈성을 높이 평가할 수 있으며 코드를 재사용하면 코드 줄이 줄어들 기 시작합니다. :)</target>
        </trans-unit>
        <trans-unit id="692095ebf5adc28ef5dd43de59073c7e0f30fed7" translate="yes" xml:space="preserve">
          <source>How About Event Handlers?</source>
          <target state="translated">이벤트 핸들러는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="cb6ede7c8218456d272e15d1df527222761a5d58" translate="yes" xml:space="preserve">
          <source>How About try/catch?</source>
          <target state="translated">시도 / 캐치는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="10f9d04f7128ff4e06c8d87250d8e47453873aca" translate="yes" xml:space="preserve">
          <source>How Can I Learn More About Experimental Features?</source>
          <target state="translated">실험 기능에 대한 자세한 내용은 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6b32b4ad6bd37176faffadb32d22a8289534a746" translate="yes" xml:space="preserve">
          <source>How To Use Context</source>
          <target state="translated">컨텍스트를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="0d3b1dc4703059a43990fb4f54a82b7ea462210e" translate="yes" xml:space="preserve">
          <source>How can I do data fetching with Hooks?</source>
          <target state="translated">Hooks로 데이터를 가져 오는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5f3eb93766a70bcb23bd57b5f81706e1346cc00b" translate="yes" xml:space="preserve">
          <source>How can I make an AJAX call?</source>
          <target state="translated">AJAX 전화를 걸려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="d65c5d09d6ca3b416e582fadae15682637bf85c2" translate="yes" xml:space="preserve">
          <source>How can I measure a DOM node?</source>
          <target state="translated">DOM 노드를 어떻게 측정 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fe8a15cb87dd32841f00b87b456991b2721d9c55" translate="yes" xml:space="preserve">
          <source>How can I prevent a function from being called too quickly or too many times in a row?</source>
          <target state="translated">함수가 너무 빨리 또는 여러 번 연속해서 호출되지 않도록하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="6aec71a52b9be72fd0463ec529f9c780d7f499e0" translate="yes" xml:space="preserve">
          <source>How can I write comments in JSX?</source>
          <target state="translated">JSX에서 주석을 작성하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="83d4d9bc9ea4bb507420dda2c277f59106d4c62f" translate="yes" xml:space="preserve">
          <source>How do I add CSS classes to components?</source>
          <target state="translated">컴포넌트에 CSS 클래스를 어떻게 추가합니까?</target>
        </trans-unit>
        <trans-unit id="81a15ac345101e045ea595d31734e8063db66661" translate="yes" xml:space="preserve">
          <source>How do I bind a function to a component instance?</source>
          <target state="translated">구성 요소 인스턴스에 함수를 어떻게 바인딩합니까?</target>
        </trans-unit>
        <trans-unit id="aa62b3618db8ebfa8f917b302351ed7099483e1f" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;getDerivedStateFromProps&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;getDerivedStateFromProps&lt;/code&gt; 를 어떻게 구현 합니까?</target>
        </trans-unit>
        <trans-unit id="d0572ad330916c3fe730299d4ede58b185b5ca13" translate="yes" xml:space="preserve">
          <source>How do I implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 어떻게 구현 합니까 ?</target>
        </trans-unit>
        <trans-unit id="fb9e955accc6d91168550466054bc2a0652117d7" translate="yes" xml:space="preserve">
          <source>How do I implement getDerivedStateFromProps?</source>
          <target state="translated">getDerivedStateFromProps를 어떻게 구현합니까?</target>
        </trans-unit>
        <trans-unit id="e9415649ba2cf6fdc23c48d06f17328a84773eae" translate="yes" xml:space="preserve">
          <source>How do I implement shouldComponentUpdate?</source>
          <target state="translated">shouldComponentUpdate를 어떻게 구현합니까?</target>
        </trans-unit>
        <trans-unit id="d0ca0d1ae983bdbef86eee8bd0c53b191176837f" translate="yes" xml:space="preserve">
          <source>How do I pass a parameter to an event handler or callback?</source>
          <target state="translated">이벤트 처리기 또는 콜백에 매개 변수를 전달하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="38b2ecaed14852353d71b3ff348314158c48bfb1" translate="yes" xml:space="preserve">
          <source>How do I pass an event handler (like onClick) to a component?</source>
          <target state="translated">onClick과 같은 이벤트 핸들러를 구성 요소에 어떻게 전달합니까?</target>
        </trans-unit>
        <trans-unit id="b0b4082736e34d847d56b0cabd7b94a845d15d06" translate="yes" xml:space="preserve">
          <source>How do I update state with values that depend on the current state?</source>
          <target state="translated">현재 상태에 의존하는 값으로 상태를 업데이트하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="1571c2b05260a179a5c52b92711d13ace65d09c2" translate="yes" xml:space="preserve">
          <source>How do lifecycle methods correspond to Hooks?</source>
          <target state="translated">수명주기 방법은 후크와 어떻게 일치합니까?</target>
        </trans-unit>
        <trans-unit id="ef86d6c075ad452ca05fc6dfcb095042d6b94c62" translate="yes" xml:space="preserve">
          <source>How do we separate the Receded and the Skeleton states? The difference between them is that the &lt;strong&gt;Receded&lt;/strong&gt; state feels like &amp;ldquo;taking a step back&amp;rdquo; to the user, while the &lt;strong&gt;Skeleton&lt;/strong&gt; state feels like &amp;ldquo;taking a step forward&amp;rdquo; in our progress to show more content.</source>
          <target state="translated">Receded와 Skeleton 상태를 어떻게 분리합니까? 차이점은 &lt;strong&gt;Receded&lt;/strong&gt; 상태는 사용자에게&amp;ldquo;한 단계 뒤로 &lt;strong&gt;물러나고&lt;/strong&gt; &amp;rdquo;있는 것처럼 느끼고 &lt;strong&gt;Skeleton&lt;/strong&gt; 상태는 더 많은 콘텐츠를 표시하기 위해 진행 과정에서&amp;ldquo;앞으로 물러나&amp;rdquo;고 느끼는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9cd07e5b2055c72f75ab42f26ab2628f05373053" translate="yes" xml:space="preserve">
          <source>How does React associate Hook calls with components?</source>
          <target state="translated">React는 후크 호출을 구성 요소와 어떻게 연결합니까?</target>
        </trans-unit>
        <trans-unit id="03433b6618565d81523f098fea7bbfc849e26f58" translate="yes" xml:space="preserve">
          <source>How is this different from debouncing? Our example has a fixed artificial delay (3ms for every one of 80 items), so there is always a delay, no matter how fast our computer is. However, the &lt;code&gt;useDeferredValue&lt;/code&gt; value only &amp;ldquo;lags behind&amp;rdquo; if the rendering takes a while. There is no minimal lag imposed by React. With a more realistic workload, you can expect the lag to adjust to the user&amp;rsquo;s device. On fast machines, the lag would be smaller or non-existent, and on slow machines, it would be more noticeable. In both cases, the app would remain responsive. That&amp;rsquo;s the advantage of this mechanism over debouncing or throttling, which always impose a minimal delay and can&amp;rsquo;t avoid blocking the thread while rendering.</source>
          <target state="translated">수신 거부와 다른 점은 무엇입니까? 이 예에는 고정 인공 지연 (80 개 항목 당 3ms)이 있으므로 컴퓨터 속도에 상관없이 항상 지연이 발생합니다. 그러나 렌더링에 시간 이 &lt;code&gt;useDeferredValue&lt;/code&gt; 값은 &quot;지연&quot;됩니다. React가 부과하는 최소 지연은 없습니다. 보다 현실적인 작업량으로 지연이 사용자의 장치에 맞게 조정될 수 있습니다. 빠른 기계에서는 지연이 더 작거나 존재하지 않으며 느린 기계에서는 눈에 띄게 나타납니다. 두 경우 모두 앱이 반응을 유지합니다. 이것이 디 바운싱 또는 스로틀 링에 비해이 메커니즘의 장점입니다.이 메커니즘은 항상 최소 지연을 부과하며 렌더링하는 동안 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef20a3ab1615429a9e3caea2dfc9283ba06feb8c" translate="yes" xml:space="preserve">
          <source>How much of my React knowledge stays relevant?</source>
          <target state="translated">내 React 지식은 얼마나 관련성이 있습니까?</target>
        </trans-unit>
        <trans-unit id="01cf9009310d5e4e171575929c85ba93f68d8165" translate="yes" xml:space="preserve">
          <source>How to Approach the Problem</source>
          <target state="translated">문제에 접근하는 방법</target>
        </trans-unit>
        <trans-unit id="772ce99a70283ae35b4e13fa8d26821113684e81" translate="yes" xml:space="preserve">
          <source>How to Read This Guide</source>
          <target state="translated">이 안내서를 읽는 방법</target>
        </trans-unit>
        <trans-unit id="5e5bdd73691289d5424afb561fb4d4a8c352d85e" translate="yes" xml:space="preserve">
          <source>How to avoid passing callbacks down?</source>
          <target state="translated">콜백을 전달하지 않으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="e4460bb5cb239f962c6f963dd45f4bfc12fafab4" translate="yes" xml:space="preserve">
          <source>How to create expensive objects lazily?</source>
          <target state="translated">값 비싼 객체를 느리게 만드는 방법?</target>
        </trans-unit>
        <trans-unit id="b8b7e53bed65fc2a70652cc57c409f8809ebddf6" translate="yes" xml:space="preserve">
          <source>How to get the previous props or state?</source>
          <target state="translated">이전 소품이나 상태를 얻는 방법?</target>
        </trans-unit>
        <trans-unit id="c24f12ba653d001525d8a8bd81fe1cef3fad0860" translate="yes" xml:space="preserve">
          <source>How to memoize calculations?</source>
          <target state="translated">계산을 메모하는 방법?</target>
        </trans-unit>
        <trans-unit id="24fb9eef456bcd915cd5640203146790d6c28cff" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from &lt;code&gt;useCallback&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;useCallback&lt;/code&gt; 에서 자주 변경되는 값을 읽는 방법은 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="ecc2a2a6938156221ff27517255883f6fe53d187" translate="yes" xml:space="preserve">
          <source>How to read an often-changing value from useCallback?</source>
          <target state="translated">useCallback에서 자주 변경되는 값을 읽는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4e42ecde4eca22b2d3b189bcf068d674eeacdb8a" translate="yes" xml:space="preserve">
          <source>How to test components that use Hooks?</source>
          <target state="translated">후크를 사용하는 구성 요소를 테스트하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9da64590fe0ba979539b260ad3ab00d0ecded657" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;useRef()&lt;/code&gt; is useful for more than the &lt;code&gt;ref&lt;/code&gt; attribute. It&amp;rsquo;s &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;handy for keeping any mutable value around&lt;/a&gt; similar to how you&amp;rsquo;d use instance fields in classes.</source>
          <target state="translated">그러나 &lt;code&gt;useRef()&lt;/code&gt; 는 &lt;code&gt;ref&lt;/code&gt; 속성 이상에 유용 합니다. 그것은의 &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;주위에 어떤 가변 값을 유지하는 편리한&lt;/a&gt; 당신이 클래스에 인스턴스 필드를 사용하십시오 방법과 유사한.</target>
        </trans-unit>
        <trans-unit id="65f0f95f546c8a3bf04820043025e19f7a76c111" translate="yes" xml:space="preserve">
          <source>However, React also offers an option to use &lt;a href=&quot;introducing-jsx&quot;&gt;JSX&lt;/a&gt; instead:</source>
          <target state="translated">그러나 React는 &lt;a href=&quot;introducing-jsx&quot;&gt;JSX를&lt;/a&gt; 대신 사용할 수있는 옵션도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3333696f448160f28cb91d4eececaddabcf02145" translate="yes" xml:space="preserve">
          <source>However, React components are declarative and specify &lt;em&gt;what&lt;/em&gt; should be rendered:</source>
          <target state="translated">그러나 React 컴포넌트는 선언적이며 렌더링해야 할 &lt;em&gt;것을&lt;/em&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="e9b9ee92c12009c14589ca7400a64667019fa998" translate="yes" xml:space="preserve">
          <source>However, elements can also represent user-defined components:</source>
          <target state="translated">그러나 요소는 사용자 정의 구성 요소를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8914df7a2751ed9a49c0a876b51e78db6ebded98" translate="yes" xml:space="preserve">
          <source>However, in Concurrent Mode there are cases where you might &lt;em&gt;want&lt;/em&gt; to &amp;ldquo;duplicate&amp;rdquo; some data in different state variables. Consider this tiny translation app:</source>
          <target state="translated">그러나 동시 모드 에서는 다른 상태 변수의 일부 데이터를 &quot;중복&quot; &lt;em&gt;하려는&lt;/em&gt; 경우가 있습니다 . 이 작은 번역 앱을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d58ece91c2a93ff8dda87d95414ebd23f4782a9c" translate="yes" xml:space="preserve">
          <source>However, it also preserves &lt;code&gt;ref&lt;/code&gt;s. This means that if you get a child with a &lt;code&gt;ref&lt;/code&gt; on it, you won&amp;rsquo;t accidentally steal it from your ancestor. You will get the same &lt;code&gt;ref&lt;/code&gt; attached to your new element.</source>
          <target state="translated">그러나 &lt;code&gt;ref&lt;/code&gt; 도 보존 합니다. 이것은 당신이 그것에 &lt;code&gt;ref&lt;/code&gt; 을 가진 아이를 얻는다면 , 실수로 조상으로부터 아이를 훔치지 않을 것임을 의미합니다. 새 요소에 동일한 &lt;code&gt;ref&lt;/code&gt; 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="7dccca1546e00e09348d2ca880b503bbc3782a4f" translate="yes" xml:space="preserve">
          <source>However, it does raise the question of why these releases aren&amp;rsquo;t versioned as patches instead.</source>
          <target state="translated">그러나이 릴리스가 패치로 버전 화되지 않은 이유에 대한 의문이 제기됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a583f2ca74afad8b48de4866dda319994ca798" translate="yes" xml:space="preserve">
          <source>However, it misses a crucial requirement: the fact that the &lt;code&gt;Clock&lt;/code&gt; sets up a timer and updates the UI every second should be an implementation detail of the &lt;code&gt;Clock&lt;/code&gt;.</source>
          <target state="translated">사실 : 그러나, 중요한 요구 사항 그리워 &lt;code&gt;Clock&lt;/code&gt; 타이머 및 업데이트 설정이 UI마다 두 번째는의 구현 세부 있어야합니다 &lt;code&gt;Clock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b55a581ed0d44371ffb07796a1f139be740fa1" translate="yes" xml:space="preserve">
          <source>However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called &lt;a href=&quot;#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt;. It has the same signature as &lt;code&gt;useEffect&lt;/code&gt;, and only differs in when it is fired.</source>
          <target state="translated">그러나 모든 효과가 지연되는 것은 아닙니다. 예를 들어, 사용자가 볼 수있는 DOM 변이는 사용자가 시각적 불일치를 인식하지 못하도록 다음 페인트 전에 동기식으로 발생해야합니다. 이러한 구별은 개념적으로 수동 및 활성 이벤트 리스너와 개념적으로 유사합니다. 이러한 유형의 효과에 대해 React는 &lt;a href=&quot;#uselayouteffect&quot;&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; &lt;/a&gt; 라는 추가 후크를 제공합니다 . &lt;code&gt;useEffect&lt;/code&gt; 와 동일한 서명을 가지고 있으며 발생했을 때만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="66df5c038ad97c79d198f1c4a9bcf642fe39edab" translate="yes" xml:space="preserve">
          <source>However, sometimes it might be helpful to intentionally introduce an inconsistency. We could do it manually by &amp;ldquo;splitting&amp;rdquo; the state like above, but React also offers a built-in Hook for this:</source>
          <target state="translated">그러나 때로는 불일치를 의도적으로 도입하는 것이 도움이 될 수 있습니다. 위와 같이 상태를 &quot;분할&quot;하여 수동으로 수행 할 수 있지만 React는이를 위해 내장 후크도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="684d4b7ace58812c1c1257030e5191e892f4d124" translate="yes" xml:space="preserve">
          <source>However, sometimes it&amp;rsquo;s useful to insert a child into a different location in the DOM:</source>
          <target state="translated">그러나 때때로 DOM의 다른 위치에 자식을 삽입하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7873b7f443466f38d48c121a13c985ec5c569acf" translate="yes" xml:space="preserve">
          <source>However, sometimes the same data needs to be accessible by many components in the tree, and at different nesting levels. Context lets you &amp;ldquo;broadcast&amp;rdquo; such data, and changes to it, to all components below. Common examples where using context might be simpler than the alternatives include managing the current locale, theme, or a data cache.</source>
          <target state="translated">그러나 트리의 여러 구성 요소와 다른 중첩 수준에서 동일한 데이터에 액세스해야하는 경우가 있습니다. 컨텍스트를 사용하면 이러한 데이터를&amp;ldquo;브로드 캐스트&amp;rdquo;하고 변경하여 아래의 모든 구성 요소로 변경할 수 있습니다. 대안을 사용하는 것보다 컨텍스트를 사용하는 것이 더 간단한 일반적인 예에는 현재 로캘, 테마 또는 데이터 캐시 관리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="23514e5e71b6ee6ebabf134e94bf282dd4ddd004" translate="yes" xml:space="preserve">
          <source>However, the experience feels really jarring. We were browsing a page, but it got replaced by a loading state right as we were interacting with it. It&amp;rsquo;s disorienting. &lt;strong&gt;Just like before, to avoid showing an undesirable loading state, we can wrap the state update in a transition:&lt;/strong&gt;</source>
          <target state="translated">그러나 그 경험은 정말 엉망입니다. 우리는 페이지를 탐색했지만 페이지와 상호 작용하면서 로딩 상태로 바뀌 었습니다. 혼란 스러워요. &lt;strong&gt;이전과 마찬가지로, 바람직하지 않은 로딩 상태를 나타내지 않기 위해 상태 업데이트를 전환으로 래핑 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b955a466dd5e01eaf645eec3e93c8799d5ab4f5" translate="yes" xml:space="preserve">
          <source>However, this may be overkill in some cases, like the subscription example from the previous section. We don&amp;rsquo;t need to create a new subscription on every update, only if the &lt;code&gt;source&lt;/code&gt; prop has changed.</source>
          <target state="translated">그러나 이전 섹션의 구독 예제와 같이 일부 경우에는 너무 과도 할 수 있습니다. &lt;code&gt;source&lt;/code&gt; 소품이 변경된 경우에만 모든 업데이트에 대해 새 구독을 만들 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d54fc10053a808be02d653b28bf41ebcbb425fe4" translate="yes" xml:space="preserve">
          <source>However, this requires you to know exactly which methods need to be copied. You can use &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;hoist-non-react-statics&lt;/a&gt; to automatically copy all non-React static methods:</source>
          <target state="translated">그러나이를 위해서는 정확히 어떤 방법을 복사해야하는지 알아야합니다. &lt;a href=&quot;https://github.com/mridgway/hoist-non-react-statics&quot;&gt;호이스트 비 반응 정적&lt;/a&gt; 을 사용하여 모든 비 반응 정적 방법을 자동으로 복사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b543d8a8b990abf052de4f376f9d0b9c65f73938" translate="yes" xml:space="preserve">
          <source>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</source>
          <target state="translated">그러나이 두 입력이 서로 동기화되기를 원합니다. 섭씨 입력을 업데이트 할 때 화씨 입력은 변환 된 온도를 반영해야하며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="bd3ad954f0338c11e6cda950a40addb37e02fd0f" translate="yes" xml:space="preserve">
          <source>However, you might still be wondering why React doesn&amp;rsquo;t just update &lt;code&gt;this.state&lt;/code&gt; immediately without re-rendering.</source>
          <target state="translated">그러나 왜 React가 다시 렌더링하지 않고 즉시 &lt;code&gt;this.state&lt;/code&gt; 를 업데이트하지 않는지 궁금 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1e059ed18e3f4b02238b502a8f5e588e0008af29" translate="yes" xml:space="preserve">
          <source>Ideally we want to write this once and have the &lt;code&gt;Clock&lt;/code&gt; update itself:</source>
          <target state="translated">이상적으로 우리는 이것을 한 번 작성하고 &lt;code&gt;Clock&lt;/code&gt; 자체를 업데이트 하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="6a176af0e3541b91734625dec4f3b8292439dd1d" translate="yes" xml:space="preserve">
          <source>Ideas</source>
          <target state="translated">Ideas</target>
        </trans-unit>
        <trans-unit id="dbd660e2dd45612fbe7fcb2d52008460403f801b" translate="yes" xml:space="preserve">
          <source>Identify every component that renders something based on that state.</source>
          <target state="translated">해당 상태를 기반으로 무언가를 렌더링하는 모든 구성 요소를 식별하십시오.</target>
        </trans-unit>
        <trans-unit id="96c7ee658b9e92f85c8bfec7b6c2a38fb96663d7" translate="yes" xml:space="preserve">
          <source>Identifying components with unsafe lifecycles</source>
          <target state="translated">안전하지 않은 수명 주기로 구성 요소 식별</target>
        </trans-unit>
        <trans-unit id="634e92551f670791962e82615e588bc9e77eae60" translate="yes" xml:space="preserve">
          <source>Identifying unsafe lifecycles</source>
          <target state="translated">안전하지 않은 수명주기 식별</target>
        </trans-unit>
        <trans-unit id="c95633762d757325e688096b23309ad6ed512c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;children&lt;/code&gt; is a &lt;code&gt;Fragment&lt;/code&gt; it will be treated as a single child and not traversed.</source>
          <target state="translated">경우 &lt;code&gt;children&lt;/code&gt; A는 &lt;code&gt;Fragment&lt;/code&gt; 그것은 하나의 아이로 취급 통과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9ec8b74463d4b6788285debd449e8a36886f529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is defined within a component, the following &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; will receive an additional parameter, the &lt;code&gt;context&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;contextTypes&lt;/code&gt; 가 구성 요소 내에 정의 된 경우 다음 &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;수명주기 메소드&lt;/a&gt; 는 &lt;code&gt;context&lt;/code&gt; 매개 변수 인 추가 매개 변수를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="a7942ea96f993393244bb793ed3444403e13d0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;contextTypes&lt;/code&gt; is not defined, then &lt;code&gt;context&lt;/code&gt; will be an empty object.</source>
          <target state="translated">&lt;code&gt;contextTypes&lt;/code&gt; 가 정의되지 않은 경우 &lt;code&gt;context&lt;/code&gt; 는 빈 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cb8bc3d5f6a162a81742105b7e5aa8a5814ce785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is not provided, it will be set by default to &lt;code&gt;'blue'&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;props.color&lt;/code&gt; 가 제공되지 않습니다, 그것은 기본적으로 설정됩니다 &lt;code&gt;'blue'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="459dd598a5e1720f34594d812d939384bffda8ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt;, it will remain &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">If &lt;code&gt;props.color&lt;/code&gt; is set to &lt;code&gt;null&lt;/code&gt; , it will remain &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba93d4ea31d24880e40a17c457b5255600429f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;props.color&lt;/code&gt; is set to null, it will remain null:</source>
          <target state="translated">경우 &lt;code&gt;props.color&lt;/code&gt; 가 null로 설정되어, 그것은 null이 유지됩니다 :</target>
        </trans-unit>
        <trans-unit id="a6b6d366d7013c823d86f9937f864aa2f4eb5035" translate="yes" xml:space="preserve">
          <source>If a Minor Release Includes No New Features, Why Isn&amp;rsquo;t It a Patch?</source>
          <target state="translated">부 릴리스에 새로운 기능이 포함되어 있지 않은 경우 패치가 아닌 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7808973984d8e4c597980af26324716a790b3eb9" translate="yes" xml:space="preserve">
          <source>If a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</source>
          <target state="translated">컴포넌트가 여러 믹스 인을 사용하고 여러 믹스 인이 동일한 라이프 사이클 방법을 정의하는 경우 (즉, 컴포넌트가 소멸 될 때 여러 믹스 인이 일부 정리를 수행하려는 경우) 모든 라이프 사이클 메소드가 호출되도록 보장됩니다. 오더 믹스 인에서 실행 된 믹스 인에 정의 된 메소드가 나열되고 구성 요소에 대한 메소드 호출이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="97235b567c0265f0d9926f25dc8829579aa2e646" translate="yes" xml:space="preserve">
          <source>If a feature is not documented, they may be accompanied by an &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">기능이 문서화되지 않은 경우 &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;RFC&lt;/a&gt; 가 수반 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6bc1e73352759548987f8a409ddc10869579747" translate="yes" xml:space="preserve">
          <source>If a release includes non-essential changes &amp;mdash; such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes &amp;mdash; we will bump the minor version even when there are no new features.</source>
          <target state="translated">릴리스에 내부 리 팩터, 구현 세부 사항 변경, 성능 개선 또는 사소한 버그 수정과 같은 필수적이지 않은 변경 사항이 포함 된 경우 새로운 기능이 없어도 사소한 버전이 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="b8ff55774a140aca8bdaed69bfb51da5366dacc0" translate="yes" xml:space="preserve">
          <source>If a single element&amp;rsquo;s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the warning by adding &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; to the element. It only works one level deep, and is intended to be an escape hatch. Don&amp;rsquo;t overuse it. Unless it&amp;rsquo;s text content, React still won&amp;rsquo;t attempt to patch it up, so it may remain inconsistent until future updates.</source>
          <target state="translated">단일 요소의 속성 또는 텍스트 내용이 서버와 클라이언트간에 불가피하게 다른 경우 (예 : 타임 스탬프) &lt;code&gt;suppressHydrationWarning={true}&lt;/code&gt; 를 요소 에 추가하여 경고를 끌 수 있습니다 . 한 수준 깊이에서만 작동하며 탈출구로 사용됩니다. 그것을 과도하게 사용하지 마십시오. 텍스트 내용이 아닌 한 React는 여전히 패치를 시도하지 않으므로 향후 업데이트 될 때까지 일관성이 유지되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d556b20cb4547e127f2815074ef2fe4e41710802" translate="yes" xml:space="preserve">
          <source>If a tag is empty, you may close it immediately with &lt;code&gt;/&amp;gt;&lt;/code&gt;, like XML:</source>
          <target state="translated">태그가 비어 있으면 XML과 같이 &lt;code&gt;/&amp;gt;&lt;/code&gt; 로 즉시 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b320bf64ff848996f74d77101a47dfdd619e264" translate="yes" xml:space="preserve">
          <source>If after that we still don&amp;rsquo;t use any values from the component scope, it&amp;rsquo;s safe to specify &lt;code&gt;[]&lt;/code&gt;:</source>
          <target state="translated">그 후에도 여전히 컴포넌트 범위의 값을 사용하지 않으면 &lt;code&gt;[]&lt;/code&gt; 를 지정하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="5b6b3e11e3d3c38135418032d8908ab5281f6aca" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;bind&lt;/code&gt; annoys you, there are two ways you can get around this. If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use class fields to correctly bind callbacks:</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 호출이 성가신 경우 ,이 문제를 해결할 수있는 두 가지 방법이 있습니다. 실험적인 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;공개 클래스 필드 구문&lt;/a&gt; 을 사용하는 경우 클래스 필드를 사용하여 콜백을 올바르게 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ab379086a708259f83594879dae195d221ed0e" translate="yes" xml:space="preserve">
          <source>If everything passes, great! You can expect that your project will work with the next minor React release.</source>
          <target state="translated">모든 것이 통과되면 좋습니다! 프로젝트가 다음 마이너 React 릴리스와 함께 작동 할 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6bec09d61efa659eb228a4953584f79786650d2" translate="yes" xml:space="preserve">
          <source>If fetching user details takes three seconds, we&amp;rsquo;ll only &lt;em&gt;start&lt;/em&gt; fetching the posts after three seconds! That&amp;rsquo;s a &amp;ldquo;waterfall&amp;rdquo;: an unintentional &lt;em&gt;sequence&lt;/em&gt; that should have been parallelized.</source>
          <target state="translated">사용자 세부 정보를 가져 오는 데 3 초가 걸리면 3 초 후에 게시물을 가져 오기 &lt;em&gt;시작&lt;/em&gt; 합니다. 그것은 &quot;폭포&quot;입니다. 의도하지 않은 &lt;em&gt;순서&lt;/em&gt; 로 병행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="61455d144dae27e035208c57b22d9252594b892f" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s still not clear which type of component you should use for a particular situation, you might find &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;this article on controlled versus uncontrolled inputs&lt;/a&gt; to be helpful.</source>
          <target state="translated">특정 상황에서 어떤 유형의 구성 요소를 사용해야하는지 확실하지 않은 경우 &lt;a href=&quot;https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/&quot;&gt;제어 된 입력과 제어되지 않은 입력에&lt;/a&gt; 대한 이 기사 가 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64a099559eb261307dc775d158033df86e50e770" translate="yes" xml:space="preserve">
          <source>If no array is provided, a new value will be computed on every render.</source>
          <target state="translated">배열이 제공되지 않으면 모든 렌더링에서 새 값이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="44bfdbf92e17d273381e7b8fb1a3f01879ecf26c" translate="yes" xml:space="preserve">
          <source>If some common scenario is not covered, please let us know on the &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;issue tracker&lt;/a&gt; for the documentation website.</source>
          <target state="translated">일부 일반적인 시나리오가 다루어지지 않으면 설명서 웹 사이트 의 &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues&quot;&gt;이슈 트래커&lt;/a&gt; 에 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="0387b7a09358144d9726581e47b1de8c8b84739d" translate="yes" xml:space="preserve">
          <source>If some component &amp;ldquo;suspends&amp;rdquo;, does the app freeze? How to avoid this?</source>
          <target state="translated">일부 구성 요소가 &quot;일시 중단&quot;되면 앱이 정지됩니까? 이것을 피하는 방법?</target>
        </trans-unit>
        <trans-unit id="fb69be684ead34368506e903349ff51d28c48c95" translate="yes" xml:space="preserve">
          <source>If some value isn&amp;rsquo;t used for rendering or data flow (for example, a timer ID), you don&amp;rsquo;t have to put it in the state. Such values can be defined as fields on the component instance.</source>
          <target state="translated">렌더링 또는 데이터 흐름에 일부 값을 사용하지 않으면 (예 : 타이머 ID) 상태에 넣을 필요가 없습니다. 이러한 값은 구성 요소 인스턴스의 필드로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb0fa5a864d283d560c5564be4c37fdc16ee5c7f" translate="yes" xml:space="preserve">
          <source>If something breaks unexpectedly, please let us know by &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;filing an issue&lt;/a&gt;.</source>
          <target state="translated">예기치 않은 &lt;a href=&quot;https://github.com/facebook/react/issues&quot;&gt;문제가 발생하면 문제&lt;/a&gt; 를 제기하여 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="e81b0e7afa3fb271a0976602cc04371ca693d752" translate="yes" xml:space="preserve">
          <source>If something can be derived from either props or state, it probably shouldn&amp;rsquo;t be in the state. For example, instead of storing both &lt;code&gt;celsiusValue&lt;/code&gt; and &lt;code&gt;fahrenheitValue&lt;/code&gt;, we store just the last edited &lt;code&gt;temperature&lt;/code&gt; and its &lt;code&gt;scale&lt;/code&gt;. The value of the other input can always be calculated from them in the &lt;code&gt;render()&lt;/code&gt; method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</source>
          <target state="translated">props 또는 state에서 무언가를 파생시킬 수 있다면 아마도 state에 있지 않아야합니다. 예를 들어 &lt;code&gt;celsiusValue&lt;/code&gt; 와 &lt;code&gt;fahrenheitValue&lt;/code&gt; 를 모두 저장하는 대신 마지막으로 편집 한 &lt;code&gt;temperature&lt;/code&gt; 와 해당 &lt;code&gt;scale&lt;/code&gt; 만 저장합니다 . 다른 입력의 값은 항상 &lt;code&gt;render()&lt;/code&gt; 메소드 에서 계산할 수 있습니다 . 이를 통해 사용자 입력의 정밀도를 잃지 않으면 서 다른 필드를 반올림하거나 반올림 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1eff28de072c228c3fac6f7de4af84285d52c7" translate="yes" xml:space="preserve">
          <source>If something is missing in the documentation or if you found some part confusing, please &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;file an issue for the documentation repository&lt;/a&gt; with your suggestions for improvement, or tweet at the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt;. We love hearing from you!</source>
          <target state="translated">문서에 누락 된 부분이 있거나 혼동되는 부분이있는 경우 개선을위한 제안 사항 &lt;a href=&quot;https://github.com/reactjs/reactjs.org/issues/new&quot;&gt;이 포함 된 문서 저장소 문제를 제기&lt;/a&gt; 하거나 &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs 계정으로&lt;/a&gt; 트윗하십시오 . 우리는 당신의 의견을 사랑합니다!</target>
        </trans-unit>
        <trans-unit id="9ba9933df2ec0f3c00ec311cb0e316ed0a71e056" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Calculator&lt;/code&gt; owns the shared state, it becomes the &amp;ldquo;source of truth&amp;rdquo; for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both &lt;code&gt;TemperatureInput&lt;/code&gt; components are coming from the same parent &lt;code&gt;Calculator&lt;/code&gt; component, the two inputs will always be in sync.</source>
          <target state="translated">&lt;code&gt;Calculator&lt;/code&gt; 가 공유 상태를 소유 한 경우 두 입력 모두에서 현재 온도의 &quot;진실 소스&quot;가됩니다. 둘 다 서로 일치하는 값을 갖도록 지시 할 수 있습니다. 두 &lt;code&gt;TemperatureInput&lt;/code&gt; 구성 요소 의 소품은 동일한 상위 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소 에서 가져 오기 때문에 두 입력은 항상 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e1508d0b9f38075d8659f83a363a29e0a2c1eb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Clock&lt;/code&gt; component is ever removed from the DOM, React calls the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method so the timer is stopped.</source>
          <target state="translated">경우 &lt;code&gt;Clock&lt;/code&gt; 구성 요소가 이제까지 DOM에서 제거, 통화량 반작용 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 타이머가 정지되도록 수명주기 방법.</target>
        </trans-unit>
        <trans-unit id="285cc10d670d67e7a1d042087524d72b3c61948c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref&lt;/code&gt; callback is defined as an inline function, it will get called twice during updates, first with &lt;code&gt;null&lt;/code&gt; and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the &lt;code&gt;ref&lt;/code&gt; callback as a bound method on the class, but note that it shouldn&amp;rsquo;t matter in most cases.</source>
          <target state="translated">경우 &lt;code&gt;ref&lt;/code&gt; 콜백이 인라인 함수로 정의된다, 그것은 첫째로, 업데이트하는 동안 두 번 불려가는 &lt;code&gt;null&lt;/code&gt; DOM 요소와 후 다시. 이는 렌더링마다 함수의 새 인스턴스가 생성되므로 React는 이전 참조를 지우고 새 참조를 설정해야하기 때문입니다. 클래스에서 바인딩 된 메소드로 &lt;code&gt;ref&lt;/code&gt; 콜백 을 정의하여이를 피할 수 있지만 대부분의 경우 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a11443443fa44ef2cec37924f0c1f90e49c7f394" translate="yes" xml:space="preserve">
          <source>If the React element was previously rendered into &lt;code&gt;container&lt;/code&gt;, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React element.</source>
          <target state="translated">React 요소가 이전에 &lt;code&gt;container&lt;/code&gt; 로 렌더링 된 경우 업데이트가 수행되고 최신 React 요소를 반영하기 위해 필요한 경우 DOM 만 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f68368472358ffa4040481d1ccc81327648d3fb5" translate="yes" xml:space="preserve">
          <source>If the boilerplate code is too unattractive to you, you may enable the &lt;strong&gt;experimental&lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;Class Properties&lt;/a&gt; syntax proposal with Babel:</source>
          <target state="translated">상용구 코드가 너무 매력적이지 않으면 Babel을 사용하여 &lt;strong&gt;실험적인 &lt;/strong&gt;&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;클래스 속성&lt;/a&gt; 구문 제안을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1524d0a0bb3f485163f09431911716ee3095bb5" translate="yes" xml:space="preserve">
          <source>If the function you&amp;rsquo;re calling is a pure computation and is safe to call while rendering, you may &lt;strong&gt;call it outside of the effect instead,&lt;/strong&gt; and make the effect depend on the returned value.</source>
          <target state="translated">호출하는 함수가 순수한 계산이고 렌더링하는 동안 호출하기에 안전하다면 &lt;strong&gt;대신 효과 외부에서 호출&lt;/strong&gt; 하여 반환 된 값에 따라 효과를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c76fa2e50dee5e670f91c11fbf1264bff2a124" translate="yes" xml:space="preserve">
          <source>If the new state is computed using the previous state, you can pass a function to &lt;code&gt;setState&lt;/code&gt;. The function will receive the previous value, and return an updated value. Here&amp;rsquo;s an example of a counter component that uses both forms of &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">새 상태가 이전 상태를 사용하여 계산 된 경우 함수를 &lt;code&gt;setState&lt;/code&gt; 에 전달할 수 있습니다 . 이 함수는 이전 값을 수신하고 업데이트 된 값을 반환합니다. 다음은 두 가지 형식의 &lt;code&gt;setState&lt;/code&gt; 를 사용하는 카운터 구성 요소의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4d5fb4c02d4fde303749802adf11f045d7e01c08" translate="yes" xml:space="preserve">
          <source>If the only way your component ever changes is when the &lt;code&gt;props.color&lt;/code&gt; or the &lt;code&gt;state.count&lt;/code&gt; variable changes, you could have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; check that:</source>
          <target state="translated">&lt;code&gt;props.color&lt;/code&gt; 또는 &lt;code&gt;state.count&lt;/code&gt; 변수가 변경 될 때 구성 요소가 변경되는 유일한 방법 인 경우 shouldComponentUpdate 가 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 확인하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d4d632eeb98bbd6eb7a8cf7c7cf0db0d585a084" translate="yes" xml:space="preserve">
          <source>If the optional callback is provided, it will be executed after the component is rendered or updated.</source>
          <target state="translated">선택적 콜백이 제공되면 구성 요소가 렌더링되거나 업데이트 된 후 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9825426bb3519158f32e335335bf1288ffbb02ac" translate="yes" xml:space="preserve">
          <source>If the other module fails to load (for example, due to network failure), it will trigger an error. You can handle these errors to show a nice user experience and manage recovery with &lt;a href=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/a&gt;. Once you&amp;rsquo;ve created your Error Boundary, you can use it anywhere above your lazy components to display an error state when there&amp;rsquo;s a network error.</source>
          <target state="translated">다른 모듈을로드하지 못하면 (예 : 네트워크 장애로 인해) 오류가 발생합니다. 이러한 오류를 처리하여 멋진 사용자 경험을 표시하고 &lt;a href=&quot;error-boundaries&quot;&gt;오류 경계를&lt;/a&gt; 사용하여 복구를 관리 할 수 있습니다. 오류 경계를 만든 후에는 지연 오류 구성 요소 위의 아무 곳이나 사용하여 네트워크 오류가있을 때 오류 상태를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d645637af0f89ddb43e30926c108ad1d42dea97" translate="yes" xml:space="preserve">
          <source>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. &lt;strong&gt;In most cases, you can attach a ref to the DOM node and avoid using &lt;code&gt;findDOMNode&lt;/code&gt; at all.&lt;/strong&gt;</source>
          <target state="translated">이 컴포넌트가 DOM에 마운트 된 경우 해당 고유 브라우저 DOM 요소를 리턴합니다. 이 방법은 양식 필드 값 및 DOM 측정 수행과 같이 DOM에서 값을 읽는 데 유용합니다. &lt;strong&gt;대부분의 경우 참조를 DOM 노드에 첨부하고 &lt;code&gt;findDOMNode&lt;/code&gt; 를 전혀 사용하지 않아도 됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2beaac6d52020b7f238083eeeeccbf47e42f3e4b" translate="yes" xml:space="preserve">
          <source>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</source>
          <target state="translated">둘 이상의 컨텍스트 값을 함께 사용하는 경우 둘 다 제공하는 고유 한 렌더 소품 구성 요소를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d1f978898c43c050ba9392e9f7a52dfcd4549f6d" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want some component to delay the transition, we can wrap it in its own &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary.</source>
          <target state="translated">일부 구성 요소가 전환을 지연시키지 않으려면 자체 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19013949653b81e2adb86a0553d1ff708b6beb68" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to load this component in our tests, we can mock out the dependency itself to a dummy component, and run our tests:</source>
          <target state="translated">테스트에서이 구성 요소를로드하지 않으려면 더미 구성 요소에 대한 종속성 자체를 모의하고 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc989df7c0d84bfb51075d6a4b04861fa37c52c1" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to stay in the Pending state for too long, our first instinct might be to set &lt;code&gt;timeoutMs&lt;/code&gt; in &lt;code&gt;useTransition&lt;/code&gt; to something smaller, like &lt;code&gt;3000&lt;/code&gt;. You can try this &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;here&lt;/a&gt;. This lets us escape the prolonged Pending state, but we still don&amp;rsquo;t have anything useful to show!</source>
          <target state="translated">Pending 상태를 너무 오래 유지하지 않으려면 첫 번째 본능은 &lt;code&gt;useTransition&lt;/code&gt; 에서 &lt;code&gt;timeoutMs&lt;/code&gt; 을 &lt;code&gt;3000&lt;/code&gt; 과 같이 더 작은 것으로 설정 하는 것 입니다. &lt;a href=&quot;https://codesandbox.io/s/practical-kowalevski-kpjg4&quot;&gt;여기서&lt;/a&gt; 시도해보십시오 . 이를 통해 장기 보류 상태를 벗어날 수 있지만 여전히 유용한 정보는 없습니다!</target>
        </trans-unit>
        <trans-unit id="b28361e99b6744be8efafa4d49b562aaade2f3b5" translate="yes" xml:space="preserve">
          <source>If we intentionally &lt;em&gt;want&lt;/em&gt; to show an inconsistent UI for a small period of time, can we do that?</source>
          <target state="translated">우리가 의도적으로하면 &lt;em&gt;원하는&lt;/em&gt; 시간의 작은 기간 동안 일관성 UI를 보여주기 위해, 우리는 그렇게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="dc070f0d7e8042a80001420c3eae7347b4592739" translate="yes" xml:space="preserve">
          <source>If we just wanted to set an interval, we wouldn&amp;rsquo;t need the ref (&lt;code&gt;id&lt;/code&gt; could be local to the effect), but it&amp;rsquo;s useful if we want to clear the interval from an event handler:</source>
          <target state="translated">인터벌을 설정하고 싶다면 참조가 필요하지 않지만 ( &lt;code&gt;id&lt;/code&gt; 는 효과에 국지적 일 수 있음) 이벤트 핸들러에서 인터벌을 지우려면 유용합니다.</target>
        </trans-unit>
        <trans-unit id="10129e51e2f781d3b2a1978fc9c0500021cdb2cc" translate="yes" xml:space="preserve">
          <source>If we later edit the Fahrenheit field to be 212, the state of the &lt;code&gt;Calculator&lt;/code&gt; will be:</source>
          <target state="translated">나중에 화씨 필드를 212로 편집하면 &lt;code&gt;Calculator&lt;/code&gt; 의 상태 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ef4de5727a1ae42b86ddd7ac75d5b2cb2686cbb" translate="yes" xml:space="preserve">
          <source>If we make our API responses take 5 seconds, &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;we can confirm&lt;/a&gt; that now React &amp;ldquo;gives up&amp;rdquo; and transitions anyway to the next screen after 3 seconds. This is because we passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to &lt;code&gt;useTransition()&lt;/code&gt;. For example, if we passed &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; instead, it would wait a whole minute.</source>
          <target state="translated">API 응답이 5 초가 걸리면 이제 React가&amp;ldquo;기동&amp;rdquo;되어 3 초 후에 다음 화면으로 전환됨을 &lt;a href=&quot;https://codesandbox.io/s/relaxed-greider-suewh&quot;&gt;확인할 수 있습니다&lt;/a&gt; . 우리는 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; 을 &lt;code&gt;useTransition()&lt;/code&gt; 전달했기 때문 입니다. 예를 들어 &lt;code&gt;{timeoutMs: 60000}&lt;/code&gt; 전달하면 1 분 정도 기다립니다.</target>
        </trans-unit>
        <trans-unit id="0d759d3e1bb1bdd18c1893117d44336d9737a917" translate="yes" xml:space="preserve">
          <source>If we try this code, it might seem like it works at first. However, if we randomize the delay time in our &amp;ldquo;fake API&amp;rdquo; implementation and press the &amp;ldquo;Next&amp;rdquo; button fast enough, we&amp;rsquo;ll see from the console logs that something is going very wrong. &lt;strong&gt;Requests from the previous profiles may sometimes &amp;ldquo;come back&amp;rdquo; after we&amp;rsquo;ve already switched the profile to another ID &amp;mdash; and in that case they can overwrite the new state with a stale response for a different ID.&lt;/strong&gt;</source>
          <target state="translated">이 코드를 사용하면 처음에는 작동하는 것처럼 보일 수 있습니다. 그러나 &quot;가짜 API&quot;구현에서 지연 시간을 무작위로 지정하고 &quot;다음&quot;버튼을 충분히 빠르게 누르면 콘솔 로그에서 무언가 잘못되었다는 것을 알 수 있습니다. &lt;strong&gt;이전 프로필의 요청은 이미 프로필을 다른 ID로 전환 한 후&amp;ldquo;다시 돌아올&amp;rdquo;수 있으며,이 경우 다른 ID에 대한 오래된 응답으로 새 상태를 덮어 쓸 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be3a9278266bf705f6dd179c22a52cc57d1c6f99" translate="yes" xml:space="preserve">
          <source>If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm based on two assumptions:</source>
          <target state="translated">이것을 React에서 사용한 경우 1000 개의 요소를 표시하려면 10 억 개의 비교 순서가 필요합니다. 이것은 너무 비싸다. 대신 React는 다음 두 가지 가정을 기반으로 휴리스틱 O (n) 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0bd6f78d0df5d6a5d29d430057c8831c6b2afedc" translate="yes" xml:space="preserve">
          <source>If we wanted to wrap the &lt;code&gt;CustomTextInput&lt;/code&gt; above to simulate it being clicked immediately after mounting, we could use a ref to get access to the custom input and call its &lt;code&gt;focusTextInput&lt;/code&gt; method manually:</source>
          <target state="translated">마운트 후 바로 클릭되는 것을 시뮬레이션하기 위해 위 의 &lt;code&gt;CustomTextInput&lt;/code&gt; 을 래핑하려면 ref를 사용하여 사용자 정의 입력에 액세스하고 &lt;code&gt;focusTextInput&lt;/code&gt; 메소드를 수동으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="406ca61e719e6f4e1e3008d4b342561469a8b770" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re willing to sacrifice consistency, we could &lt;strong&gt;pass potentially stale data to the components that delay our transition&lt;/strong&gt;. That&amp;rsquo;s what &lt;code&gt;useDeferredValue()&lt;/code&gt; lets us do:</source>
          <target state="translated">일관성을 기꺼이 희생하려는 경우 &lt;strong&gt;오래된 데이터를 구성 요소에 전달하여 전환을 지연시킬 수&lt;/strong&gt; 있습니다. 이것이 &lt;code&gt;useDeferredValue()&lt;/code&gt; 할 수있는 일입니다.</target>
        </trans-unit>
        <trans-unit id="6c9413bd0fc5834a029e8af7dddbd9382c56068a" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;props&lt;/code&gt; as an object, and you want to pass it in JSX, you can use &lt;code&gt;...&lt;/code&gt; as a &amp;ldquo;spread&amp;rdquo; operator to pass the whole props object. These two components are equivalent:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 를 이미 객체로 가지고 있고 JSX로 전달하려는 경우 &lt;code&gt;...&lt;/code&gt; 를 &quot;spread&quot;연산자로 사용하여 전체 props 객체를 전달할 수 있습니다. 이 두 구성 요소는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8735706de7bdc6d287d2a819b6a76fae1e775b79" translate="yes" xml:space="preserve">
          <source>If you already minify the application scripts, &lt;strong&gt;your site will be production-ready&lt;/strong&gt; if you ensure that the deployed HTML loads the versions of React ending in &lt;code&gt;production.min.js&lt;/code&gt;:</source>
          <target state="translated">이미 응용 프로그램 스크립트를 축소 한 경우 배포 된 HTML이 &lt;code&gt;production.min.js&lt;/code&gt; 로 끝나는 React 버전을로드하도록하면 &lt;strong&gt;사이트가 프로덕션 준비 상태가&lt;/strong&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cd058484ca6af46bd0f0bdc60864ddb7e7bdf9f" translate="yes" xml:space="preserve">
          <source>If you are confident you want to write it by hand, you may compare &lt;code&gt;this.props&lt;/code&gt; with &lt;code&gt;nextProps&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; with &lt;code&gt;nextState&lt;/code&gt; and return &lt;code&gt;false&lt;/code&gt; to tell React the update can be skipped. Note that returning &lt;code&gt;false&lt;/code&gt; does not prevent child components from re-rendering when &lt;em&gt;their&lt;/em&gt; state changes.</source>
          <target state="translated">당신이 확신하는 경우에는 손으로 쓰고 싶어요, 당신은 비교할 수있다 &lt;code&gt;this.props&lt;/code&gt; 와 &lt;code&gt;nextProps&lt;/code&gt; 및 &lt;code&gt;this.state&lt;/code&gt; 을 함께 &lt;code&gt;nextState&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; 업데이트를 건너 뛸 수 있습니다 반작용 말할 수 있습니다. 반환합니다 &lt;code&gt;false&lt;/code&gt; 다시 렌더링 할 때부터 자식 요소를 방지하지 않습니다 &lt;em&gt;자신의&lt;/em&gt; 상태 변경.</target>
        </trans-unit>
        <trans-unit id="15c76b0412bce989363700bf2ef3011d9639d358" translate="yes" xml:space="preserve">
          <source>If you are using a Babel transform like &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; , you can also declare &lt;code&gt;defaultProps&lt;/code&gt; as static property within a React component class. This syntax has not yet been finalized though and will require a compilation step to work within a browser. For more information, see the &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;class fields proposal&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;transform-class-properties&lt;/a&gt; 와 같은 Babel 변환을 사용하는 경우 React 컴포넌트 클래스 내에서 &lt;code&gt;defaultProps&lt;/code&gt; 를 정적 특성으로 선언 할 수도 있습니다 . 이 구문은 아직 확정되지 않았으므로 브라우저 내에서 작동하려면 컴파일 단계가 필요합니다. 자세한 정보는 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields&quot;&gt;클래스 필드 제안을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75b66416e2290abd98cf21dbd99025df7c4ba6a0" translate="yes" xml:space="preserve">
          <source>If you are using the experimental &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;public class fields syntax&lt;/a&gt;, you can use a &lt;strong&gt;static&lt;/strong&gt; class field to initialize your &lt;code&gt;contextType&lt;/code&gt;.</source>
          <target state="translated">실험용 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-class-properties/&quot;&gt;공개 클래스 필드 구문&lt;/a&gt; 을 사용하는 경우 &lt;strong&gt;정적&lt;/strong&gt; 클래스 필드를 사용 하여 &lt;code&gt;contextType&lt;/code&gt; 을 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bcd73af03cb4d3e4e3b7c1bd1f74a1bd7b665d0" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t sure whether your build process is set up correctly, you can check it by installing &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;React Developer Tools for Chrome&lt;/a&gt;. If you visit a site with React in production mode, the icon will have a dark background:</source>
          <target state="translated">빌드 프로세스가 올바르게 설정되었는지 확실하지 않은 경우 &lt;a href=&quot;https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi&quot;&gt;Chrome 용 React Developer Tools를&lt;/a&gt; 설치하여 확인할 수 있습니다 . 프로덕션 모드에서 반응이있는 사이트를 방문하면 아이콘의 배경이 어두워집니다.</target>
        </trans-unit>
        <trans-unit id="eb0c664da034e861544cfcdf5f02c8fd40d847b9" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using class fields syntax, you can use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; in the callback:</source>
          <target state="translated">클래스 필드 구문을 사용하지 않는 경우 콜백에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38bf06802507eba86661f75bc21760f1686e68d8" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t, you&amp;rsquo;ll need to setup bundling yourself. For example, see the &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;Installation&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;Getting Started&lt;/a&gt; guides on the Webpack docs.</source>
          <target state="translated">그렇지 않은 경우 번들링을 직접 설정해야합니다. 예를 들어, 웹팩 문서 의 &lt;a href=&quot;https://webpack.js.org/guides/installation/&quot;&gt;설치&lt;/a&gt; 및 &lt;a href=&quot;https://webpack.js.org/guides/getting-started/&quot;&gt;시작&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e3292dd08de71388ad7c0b1a0bf8e95045ff37d" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</source>
          <target state="translated">이 서버 렌더링 마크 업이 이미있는 노드에서 &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; 를 호출하면 React는이를 유지하고 이벤트 핸들러 만 첨부하므로 성능이 뛰어난 첫 번째로드 경험을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c12886015a122be4810ebe17201bb8cce342272e" translate="yes" xml:space="preserve">
          <source>If you call it on a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM node, it reads the attributes off of the original DOM node, hides it with an inline style, and then appends a separate DOM node with its own visual representation right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. Then it fires jQuery events to notify us about the changes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; DOM 노드에서 호출 하면 원래 DOM 노드에서 속성을 읽고 인라인 스타일로 숨기고 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 바로 뒤에 고유 한 시각적 표현으로 별도의 DOM 노드를 추가합니다 . 그런 다음 jQuery 이벤트를 시작하여 변경 사항을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a4f9877110efff3327fdffedf68d4026372380df" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common owner component.</source>
          <target state="translated">상태를 소유하는 것이 적합한 구성 요소를 찾을 수없는 경우 상태를 유지하기위한 용도로만 새 구성 요소를 생성하고 공통 소유자 구성 요소 위의 계층 구조 어딘가에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e80d72886f63f44e90c32f25b0726ec9919167cc" translate="yes" xml:space="preserve">
          <source>If you do have performance issues, by all means, optimize!</source>
          <target state="translated">성능 문제가있는 경우 반드시 최적화하십시오!</target>
        </trans-unit>
        <trans-unit id="842af6389784f4195a6f44b18d1ae6472e5779f0" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t experience the problems described above or don&amp;rsquo;t feel comfortable using JavaScript tools yet, consider &lt;a href=&quot;add-react-to-a-website&quot;&gt;adding React as a plain &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag on an HTML page&lt;/a&gt;, optionally &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;with JSX&lt;/a&gt;.</source>
          <target state="translated">위에서 설명한 문제점이 발생하지 않거나 아직 JavaScript 도구를 사용 &lt;a href=&quot;add-react-to-a-website#optional-try-react-with-jsx&quot;&gt;하는 데 불편 함이 없다면 &lt;/a&gt;&lt;a href=&quot;add-react-to-a-website&quot;&gt;HTML 페이지&lt;/a&gt; 에 선택적 으로 JSX를 사용 하여 React를 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 로 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3a3d724ce9d7d08105873a53c6f8dacf835179a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a minification step for your scripts, &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;here&amp;rsquo;s one way to set it up&lt;/a&gt;.</source>
          <target state="translated">스크립트에 대한 축소 단계가없는 경우 &lt;a href=&quot;https://gist.github.com/gaearon/42a2ffa41b8319948f9be4076286e1f3&quot;&gt;이를 설정하는 한 가지 방법이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a180293faf5f67e8b6a45fe2b65f049a132062b3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="translated">If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/@babel/plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="169a21de60ad2e2c1ea7fcef1a94d52e1be56808" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Create React App, you can add &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;this plugin&lt;/a&gt; manually to your Babel configuration. Note that it&amp;rsquo;s intended only for development and &lt;strong&gt;must be disabled in production&lt;/strong&gt;.</source>
          <target state="translated">React 앱 생성을 사용하지 않는 &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source&quot;&gt;경우이 플러그인&lt;/a&gt; 을 Babel 구성에 수동으로 추가 할 수 있습니다 . 개발만을위한 것이며 &lt;strong&gt;프로덕션 환경에서 비활성화해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="59cb0765a73ef01c64e7a89fed250a66bd20f39c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 classes, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead. See &lt;a href=&quot;react-without-es6&quot;&gt;Using React without ES6&lt;/a&gt; for more information.</source>
          <target state="translated">ES6 클래스를 사용하지 않으면 대신 &lt;code&gt;create-react-class&lt;/code&gt; 모듈을 사용할 수 있습니다 . 자세한 정보는 &lt;a href=&quot;react-without-es6&quot;&gt;ES6없이 React 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f856dc1fed776914cf062b3e550d19f3eb8f9429" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use ES6 yet, you may use the &lt;code&gt;create-react-class&lt;/code&gt; module instead:</source>
          <target state="translated">ES6을 아직 사용하지 않는 경우 &lt;code&gt;create-react-class&lt;/code&gt; 모듈을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b0b9b7af2dae0cbfcf4257fa36894387d46af3e" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use Relay today, you might have to wait before you can really try Suspense in your app. So far, it&amp;rsquo;s the only implementation that we tested in production and are confident in.</source>
          <target state="translated">오늘 릴레이를 사용하지 않으면 앱에서 실제로 Suspense를 시도하기 전에 기다려야 할 수도 있습니다. 지금까지는 프로덕션 환경에서 테스트하고 확신 한 유일한 구현입니다.</target>
        </trans-unit>
        <trans-unit id="332383307eebba5d31fd9d269485dc3ba0b151a2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use a JavaScript bundler and loaded React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, it is already in scope as the &lt;code&gt;React&lt;/code&gt; global.</source>
          <target state="translated">JavaScript 번 들러를 사용하지 않고 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 에서 React를로드 한 경우 해당 범위는 이미 &lt;code&gt;React&lt;/code&gt; 글로벌 범위 입니다.</target>
        </trans-unit>
        <trans-unit id="6fce0593a2dfad3e9857ade52faf663322205bd6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use either Create React App or Babel, you can use &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; to strip the type annotations.</source>
          <target state="translated">React 앱 작성 또는 Babel을 사용하지 않는 경우 &lt;a href=&quot;https://github.com/flowtype/flow-remove-types&quot;&gt;flow-remove-types&lt;/a&gt; 를 사용하여 유형 주석을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb891743d28825149d46e0a3067c093baedd036f" translate="yes" xml:space="preserve">
          <source>If you feel completely stuck, start by keeping all files in a single folder. Eventually it will grow large enough that you will want to separate some files from the rest. By that time you&amp;rsquo;ll have enough knowledge to tell which files you edit together most often. In general, it is a good idea to keep files that often change together close to each other. This principle is called &amp;ldquo;colocation&amp;rdquo;.</source>
          <target state="translated">완전히 멈췄다면 모든 파일을 단일 폴더에 보관하십시오. 결국 일부 파일을 나머지 파일과 분리하려고 할만큼 충분히 커집니다. 그때까지 가장 자주 편집하는 파일을 알 수있는 충분한 지식이 있습니다. 일반적으로 자주 변경되는 파일을 서로 가깝게 유지하는 것이 좋습니다. 이 원칙을 &quot;코 로케이션&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="df68e6e9e49708727aa3d9b52f358771b20204ab" translate="yes" xml:space="preserve">
          <source>If you feel that the React documentation goes at a faster pace than you&amp;rsquo;re comfortable with, check out &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;this overview of React by Tania Rascia&lt;/a&gt;. It introduces the most important React concepts in a detailed, beginner-friendly way. Once you&amp;rsquo;re done, give the documentation another try!</source>
          <target state="translated">React 문서가 익숙한 것보다 빠른 속도로 진행된다고 생각되면 &lt;a href=&quot;https://www.taniarascia.com/getting-started-with-react/&quot;&gt;Tania Rascia의 React 개요를&lt;/a&gt; 확인하십시오 . 가장 중요한 React 개념을 자세하고 초보자에게 친숙한 방식으로 소개합니다. 완료되면 문서를 다시 시도하십시오!</target>
        </trans-unit>
        <trans-unit id="4d81fbc72ec17b2e89d0c20f4ef89b52ec88b669" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="translated">어떤 이유로 기본 브라우저 이벤트가 필요한 경우 &lt;code&gt;nativeEvent&lt;/code&gt; 속성을 사용하여 가져 오십시오. 모든 &lt;code&gt;SyntheticEvent&lt;/code&gt; 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e08083c70a07076b5dab4e563d39dc680a49a8" translate="yes" xml:space="preserve">
          <source>If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. The synthetic events are different from, and do not map directly to, the browser&amp;rsquo;s native events. For example in &lt;code&gt;onMouseLeave&lt;/code&gt;&lt;code&gt;event.nativeEvent&lt;/code&gt; will point to a &lt;code&gt;mouseout&lt;/code&gt; event. The specific mapping is not part of the public API and may change at any time. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</source>
          <target state="translated">If you find that you need the underlying browser event for some reason, simply use the &lt;code&gt;nativeEvent&lt;/code&gt; attribute to get it. The synthetic events are different from, and do not map directly to, the browser&amp;rsquo;s native events. For example in &lt;code&gt;onMouseLeave&lt;/code&gt; &lt;code&gt;event.nativeEvent&lt;/code&gt; will point to a &lt;code&gt;mouseout&lt;/code&gt; event. The specific mapping is not part of the public API and may change at any time. Every &lt;code&gt;SyntheticEvent&lt;/code&gt; object has the following attributes:</target>
        </trans-unit>
        <trans-unit id="76310cae2aa02095c07fe271a1cb7cd76b5e2f80" translate="yes" xml:space="preserve">
          <source>If you first click &amp;ldquo;Show alert&amp;rdquo; and then increment the counter, the alert will show the &lt;code&gt;count&lt;/code&gt; variable &lt;strong&gt;at the time you clicked the &amp;ldquo;Show alert&amp;rdquo; button&lt;/strong&gt;. This prevents bugs caused by the code assuming props and state don&amp;rsquo;t change.</source>
          <target state="translated">먼저 &quot;알림 표시&quot;를 클릭 한 다음 카운터 &lt;strong&gt;를 늘리면 &quot;알림 표시&quot;버튼을 클릭 할 때 &lt;/strong&gt; &lt;code&gt;count&lt;/code&gt; 변수 가 표시됩니다 . 이는 props와 state가 변경되지 않는다고 가정하여 코드로 인한 버그를 방지합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88c29ce29fd299ea922160b41c611cec1eecbc8a" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run Flow for the first time.</source>
          <target state="translated">위의 지침을 따른 경우 처음으로 흐름을 실행할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5309b9cba3e5ecb4cc81e27f68ffbda4d5dab96" translate="yes" xml:space="preserve">
          <source>If you followed the instructions above, you should be able to run TypeScript for the first time.</source>
          <target state="translated">위의 지침을 따르면 처음으로 TypeScript를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f39f38f2b3af85590f8b59543c367401e440f4" translate="yes" xml:space="preserve">
          <source>If you get tired of typing &lt;code&gt;React.createElement&lt;/code&gt; so much, one common pattern is to assign a shorthand:</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; 를 너무 많이 입력하는 데 지치면 일반적인 패턴 중 하나는 속기를 할당하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7325f76c86bc8debb6d4b74351284f0958afc1d0" translate="yes" xml:space="preserve">
          <source>If you have a large existing app, or if your app depends on a lot of third-party packages, please don&amp;rsquo;t expect that you can use the Concurrent Mode immediately. &lt;strong&gt;For example, at Facebook we are using Concurrent Mode for the new website, but we&amp;rsquo;re not planning to enable it on the old website.&lt;/strong&gt; This is because our old website still uses unsafe lifecycle methods in the product code, incompatible third-party libraries, and patterns that don&amp;rsquo;t work well with the Concurrent Mode.</source>
          <target state="translated">기존 앱이 크거나 앱이 많은 타사 패키지에 의존하는 경우 동시 모드를 즉시 사용할 수 있다고 기대하지 마십시오. &lt;strong&gt;예를 들어 Facebook에서는 새 웹 사이트에 동시 모드를 사용하고 있지만 이전 웹 사이트에서는이를 사용할 계획이 없습니다. &lt;/strong&gt;이전 웹 사이트는 여전히 제품 코드, 호환되지 않는 타사 라이브러리 및 동시 모드와 잘 작동하지 않는 패턴에서 안전하지 않은 수명주기 방법을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="049b884296cbaec372f91838646c82b517badc89" translate="yes" xml:space="preserve">
          <source>If you have an event handler such as &lt;code&gt;onClick&lt;/code&gt; or &lt;code&gt;onScroll&lt;/code&gt; and want to prevent the callback from being fired too quickly, then you can limit the rate at which callback is executed. This can be done by using:</source>
          <target state="translated">&lt;code&gt;onClick&lt;/code&gt; 또는 &lt;code&gt;onScroll&lt;/code&gt; 과 같은 이벤트 핸들러가 있고 콜백이 너무 빨리 발생하지 않게하려면 콜백 실행 속도를 제한 할 수 있습니다. 다음을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c213f4472d12ecabe35b829a19649d2ed0d0411" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed the React DevTools, you can find them here:</source>
          <target state="translated">React DevTools를 아직 설치하지 않은 경우 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4eeb14778b01a7164c9500da7ff7d43818dfb4" translate="yes" xml:space="preserve">
          <source>If you imagine a component tree as a waterfall of props, each component&amp;rsquo;s state is like an additional water source that joins it at an arbitrary point but also flows down.</source>
          <target state="translated">구성 요소 트리를 소품 폭포로 생각하면 각 구성 요소의 상태는 임의의 지점에서 결합하지만 아래로 흐르는 추가 수원과 같습니다.</target>
        </trans-unit>
        <trans-unit id="827469f1283cc9cfff29c0d19a28165070940429" translate="yes" xml:space="preserve">
          <source>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</source>
          <target state="translated">순진하게 구현하면 처음에 요소를 삽입하면 성능이 저하됩니다. 예를 들어이 두 트리 간 변환은 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d15834c075532b4876fc67d3752aa2da60bdf369" translate="yes" xml:space="preserve">
          <source>If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a state variable like &lt;code&gt;this.state.isClient&lt;/code&gt;, which you can set to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration. Note that this approach will make your components slower because they have to render twice, so use it with caution.</source>
          <target state="translated">서버와 클라이언트에서 의도적으로 다른 것을 렌더링해야하는 경우 2 단계 렌더링을 수행 할 수 있습니다. 클라이언트에서 다른 것을 렌더링하는 구성 요소는 &lt;code&gt;this.state.isClient&lt;/code&gt; 와 같은 상태 변수를 읽을 수 있으며 &lt;code&gt;componentDidMount()&lt;/code&gt; 에서 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 이렇게하면 초기 렌더링 패스가 서버와 동일한 내용을 렌더링하여 불일치를 피할 수 있지만 수화 직후에 추가 패스가 동 기적으로 발생합니다. 이 방법을 사용하면 구성 요소가 두 번 렌더링되어야하므로 구성 요소가 느려지므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="286d3422088a5f59b246609f9ba1c043e52041ac" translate="yes" xml:space="preserve">
          <source>If you intentionally want to read the &lt;em&gt;latest&lt;/em&gt; state from some asynchronous callback, you could keep it in &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;a ref&lt;/a&gt;, mutate it, and read from it.</source>
          <target state="translated">의도적 으로 일부 비동기 콜백에서 &lt;em&gt;최신&lt;/em&gt; 상태 를 읽으려면 상태를 &lt;a href=&quot;hooks-faq#is-there-something-like-instance-variables&quot;&gt;ref로&lt;/a&gt; 유지하고 변경 한 후 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e225027ec18fdfd87c9b8442cffb1951bc054fb1" translate="yes" xml:space="preserve">
          <source>If you know that in some situations your component doesn&amp;rsquo;t need to update, you can return &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt; instead, to skip the whole rendering process, including calling &lt;code&gt;render()&lt;/code&gt; on this component and below.</source>
          <target state="translated">일부 상황에서 구성 요소를 업데이트 할 필요가없는 경우 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하여이 구성 요소와 그 아래에서 &lt;code&gt;render()&lt;/code&gt; 호출을 포함하여 전체 렌더링 프로세스를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91d2eeadcd117626f038d440e0070b4483671a4" translate="yes" xml:space="preserve">
          <source>If you load React from a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag, these top-level APIs are available on the &lt;code&gt;ReactDOM&lt;/code&gt; global. If you use ES6 with npm, you can write &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt;. If you use ES5 with npm, you can write &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 에서 React를로드 하면 &lt;code&gt;ReactDOM&lt;/code&gt; 전역 에서 이러한 최상위 API를 사용할 수 있습니다 . npm과 함께 ES6을 사용하는 경우 &lt;code&gt;import ReactDOM from 'react-dom'&lt;/code&gt; 쓸 수 있습니다 . npm과 함께 ES5를 사용하는 경우 &lt;code&gt;var ReactDOM = require('react-dom')&lt;/code&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b93e9d0b0522ffa63fd03295a5cdd6cf8a5e08ca" translate="yes" xml:space="preserve">
          <source>If you look at &lt;code&gt;ProductTable&lt;/code&gt;, you&amp;rsquo;ll see that the table header (containing the &amp;ldquo;Name&amp;rdquo; and &amp;ldquo;Price&amp;rdquo; labels) isn&amp;rsquo;t its own component. This is a matter of preference, and there&amp;rsquo;s an argument to be made either way. For this example, we left it as part of &lt;code&gt;ProductTable&lt;/code&gt; because it is part of rendering the &lt;em&gt;data collection&lt;/em&gt; which is &lt;code&gt;ProductTable&lt;/code&gt;&amp;rsquo;s responsibility. However, if this header grows to be complex (e.g., if we were to add affordances for sorting), it would certainly make sense to make this its own &lt;code&gt;ProductTableHeader&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;ProductTable&lt;/code&gt; 을 보면 테이블 이름 ( &quot;이름&quot;및 &quot;가격&quot;레이블 포함)이 자체 구성 요소가 아님을 알 수 있습니다. 이것은 선호의 문제이며 어느 쪽이든 주장해야합니다. 이 예를 들어, 우리는의 일부로 남아 &lt;code&gt;ProductTable&lt;/code&gt; 는 렌더링의 일부이기 때문에 &lt;em&gt;데이터 수집&lt;/em&gt; 입니다 &lt;code&gt;ProductTable&lt;/code&gt; 의 책임을. 그러나이 헤더가 복잡해지면 (예를 들어 정렬을위한 여유를 추가하는 경우)이를 고유 한 &lt;code&gt;ProductTableHeader&lt;/code&gt; 구성 요소 로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a8d1d424e7e902eeef27e0e70b07d9c861ccdada" translate="yes" xml:space="preserve">
          <source>If you manually configured Babel for your project, you will need to install a special preset for Flow.</source>
          <target state="translated">프로젝트에 대해 Babel을 수동으로 구성한 경우 흐름에 대한 특별 사전 설정을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2852832854adc219ab4e001ad21ce5c774975fe9" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you can write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, instead &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="translated">자동 병합이 누락 된 경우 객체 상태 업데이트를 병합 하는 사용자 정의 &lt;code&gt;useLegacyState&lt;/code&gt; Hook을 작성할 수 있습니다. 그러나 &lt;strong&gt;값이 함께 변경되는 경향에 따라 상태를 여러 상태 변수로 분할하는 것이 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b8240e4f9b63ece74e9ad3522c2bee38662743" translate="yes" xml:space="preserve">
          <source>If you miss automatic merging, you could write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</source>
          <target state="translated">If you miss automatic merging, you could write a custom &lt;code&gt;useLegacyState&lt;/code&gt; Hook that merges object state updates. However, &lt;strong&gt;we recommend to split state into multiple state variables based on which values tend to change together.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d79521cbe23ba5b60b28726474c0765c13be1ba0" translate="yes" xml:space="preserve">
          <source>If you name the render function, DevTools will also include its name (e.g. &amp;rdquo;&lt;em&gt;ForwardRef(myFunction)&lt;/em&gt;&amp;rdquo;):</source>
          <target state="translated">렌더링 함수의 이름을 지정하면 DevTools에도 이름이 포함됩니다 (예 : &quot; &lt;em&gt;ForwardRef (myFunction)&lt;/em&gt; &quot;) :</target>
        </trans-unit>
        <trans-unit id="86f30ff0b95e1da79af197894b22f7fa988c3f02" translate="yes" xml:space="preserve">
          <source>If you need to &lt;strong&gt;perform a side effect&lt;/strong&gt; (for example, data fetching or an animation) in response to a change in props, use &lt;a href=&quot;#componentdidupdate&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/a&gt; lifecycle instead.</source>
          <target state="translated">소품 변경에 대한 응답으로 &lt;strong&gt;부작용&lt;/strong&gt; (예 : 데이터 가져 오기 또는 애니메이션) 을 &lt;strong&gt;수행&lt;/strong&gt; 해야하는 경우 &lt;a href=&quot;#componentdidupdate&quot;&gt; &lt;code&gt;componentDidUpdate&lt;/code&gt; &lt;/a&gt; 수명주기를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c925262a759cc54d5372cde4e465f2bacbb07601" translate="yes" xml:space="preserve">
          <source>If you need to access event object&amp;rsquo;s properties after the event handler has run, you need to call &lt;code&gt;e.persist()&lt;/code&gt;:</source>
          <target state="translated">이벤트 핸들러가 실행 된 후 이벤트 객체의 속성에 액세스해야하는 경우 &lt;code&gt;e.persist()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="205f3177c868e6b279f403e9745e8dcaeb2d6fd7" translate="yes" xml:space="preserve">
          <source>If you need to catch an error inside event handler, use the regular JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; statement:</source>
          <target state="translated">이벤트 핸들러 내에서 오류를 잡아야하는 경우 일반 JavaScript &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70a74f7dd4fe0268f156490184fdd512266a1aa6" translate="yes" xml:space="preserve">
          <source>If you need to have access to the parent component in the handler, you also need to bind the function to the component instance (see below).</source>
          <target state="translated">핸들러에서 상위 컴포넌트에 액세스해야하는 경우, 함수를 컴포넌트 인스턴스에 바인드해야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="ca64c98be7ac6b3d7e337c9127443df11a919dbf" translate="yes" xml:space="preserve">
          <source>If you need to interact with the browser, perform your work in &lt;code&gt;componentDidMount()&lt;/code&gt; or the other lifecycle methods instead. Keeping &lt;code&gt;render()&lt;/code&gt; pure makes components easier to think about.</source>
          <target state="translated">브라우저와 상호 작용해야하는 경우 &lt;code&gt;componentDidMount()&lt;/code&gt; 또는 다른 라이프 사이클 메소드 에서 작업을 수행하십시오 . &lt;code&gt;render()&lt;/code&gt; 순수하게 유지 하면 구성 요소를 쉽게 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999ea53a2b5707c7945911f1e76d3cadb698fd97" translate="yes" xml:space="preserve">
          <source>If you need to modify some value in response to user input or a network response, use &lt;code&gt;state&lt;/code&gt; instead.</source>
          <target state="translated">사용자 입력 또는 네트워크 응답에 따라 일부 값을 수정해야하는 경우 &lt;code&gt;state&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8943142e15f89aafbe2213a7c4d356ded10b9fca" translate="yes" xml:space="preserve">
          <source>If you need to test a custom Hook, you can do so by creating a component in your test, and using your Hook from it. Then you can test the component you wrote.</source>
          <target state="translated">사용자 정의 후크를 테스트해야하는 경우 테스트에서 컴포넌트를 작성하고 후크를 사용하여이를 수행 할 수 있습니다. 그런 다음 작성한 구성 요소를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1a99a66b2ca1ad147dc87037be4bed83199b9c" translate="yes" xml:space="preserve">
          <source>If you notice that you&amp;rsquo;re getting comfortable with build tools and want them to do more for you, &lt;a href=&quot;create-a-new-react-app&quot;&gt;the next section&lt;/a&gt; describes some of the most popular and approachable toolchains. If not &amp;mdash; those script tags will do just fine!</source>
          <target state="translated">빌드 도구에 익숙해지고 더 많은 도구를 원한다면 &lt;a href=&quot;create-a-new-react-app&quot;&gt;다음 섹션&lt;/a&gt; 에서 가장 인기 있고 접근하기 쉬운 도구 체인에 대해 설명합니다. 그렇지 않은 경우 &amp;mdash; 해당 스크립트 태그는 정상적으로 작동합니다!</target>
        </trans-unit>
        <trans-unit id="130609e0ef86c8bb326cdb736a8d5fa6030de201" translate="yes" xml:space="preserve">
          <source>If you now create a file called &lt;code&gt;src/like_button.js&lt;/code&gt; with this &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX starter code&lt;/a&gt;&lt;/strong&gt;, the watcher will create a preprocessed &lt;code&gt;like_button.js&lt;/code&gt; with the plain JavaScript code suitable for the browser. When you edit the source file with JSX, the transform will re-run automatically.</source>
          <target state="translated">이 &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/c8e112dc74ac44aac4f673f2c39d19d1/raw/09b951c86c1bf1116af741fa4664511f2f179f0a/like_button.js&quot;&gt;JSX 시작 코드&lt;/a&gt;&lt;/strong&gt; 를 사용하여 &lt;code&gt;src/like_button.js&lt;/code&gt; 라는 파일 을 작성하면 감시자는 브라우저에 적합한 일반 JavaScript 코드 로 사전 처리 된 &lt;code&gt;like_button.js&lt;/code&gt; 를 작성 합니다. JSX로 소스 파일을 편집하면 변환이 자동으로 다시 실행됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eeff73e27684ff93921c75989a38770068d66406" translate="yes" xml:space="preserve">
          <source>If you often find yourself writing code like this, &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; package can simplify it.</source>
          <target state="translated">이런 코드를 자주 작성한다면 &lt;a href=&quot;https://www.npmjs.com/package/classnames#usage-with-reactjs&quot;&gt;classnames&lt;/a&gt; 패키지로 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="523f123efc70d115d1e9f594fc23ba7ce9678a9f" translate="yes" xml:space="preserve">
          <source>If you pass an empty array (&lt;code&gt;[]&lt;/code&gt;), the props and state inside the effect will always have their initial values. While passing &lt;code&gt;[]&lt;/code&gt; as the second argument is closer to the familiar &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; mental model, there are usually &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;better&lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;solutions&lt;/a&gt; to avoid re-running effects too often. Also, don&amp;rsquo;t forget that React defers running &lt;code&gt;useEffect&lt;/code&gt; until after the browser has painted, so doing extra work is less of a problem.</source>
          <target state="translated">빈 배열 ( &lt;code&gt;[]&lt;/code&gt; ) 을 전달하면 효과 내부의 props와 state는 항상 초기 값을 갖습니다. 두 번째 인수가 익숙한 &lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentWillUnmount&lt;/code&gt; 멘탈 모델에 더 가깝기 때문에 &lt;code&gt;[]&lt;/code&gt; 를 전달하는 동안 일반적으로 재실행 효과를 너무 자주 피하지 않는 &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;더 나은 &lt;/a&gt;&lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;솔루션&lt;/a&gt; 이 있습니다. 또한 React 는 브라우저가 페인트 될 때까지 &lt;code&gt;useEffect&lt;/code&gt; 실행을 연기 하므로 추가 작업을 수행하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec6b23abafdc2b9551fe13b784fbb8c555b202cd" translate="yes" xml:space="preserve">
          <source>If you pass no value for a prop, it defaults to &lt;code&gt;true&lt;/code&gt;. These two JSX expressions are equivalent:</source>
          <target state="translated">prop에 값을 전달하지 않으면 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 이 두 JSX 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c20bd7989c1f9f633f138de90c77630a2841cd72" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">클라이언트에서 React를 사용하여 마크 업을 대화식으로 만들려면이 방법을 사용하지 마십시오. 대신, 사용 &lt;a href=&quot;#rendertonodestream&quot;&gt; &lt;code&gt;renderToNodeStream&lt;/code&gt; 를&lt;/a&gt; 서버와에 &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; 클라이언트.</target>
        </trans-unit>
        <trans-unit id="4310f49d1554474b642c8b917463ce1122a21130" translate="yes" xml:space="preserve">
          <source>If you plan to use React on the client to make the markup interactive, do not use this method. Instead, use &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt; on the server and &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt;&lt;/a&gt; on the client.</source>
          <target state="translated">클라이언트에서 React를 사용하여 마크 업을 대화식으로 만들려면이 방법을 사용하지 마십시오. 대신, 사용 &lt;a href=&quot;#rendertostring&quot;&gt; &lt;code&gt;renderToString&lt;/code&gt; &lt;/a&gt; 서버와에 &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; &lt;/a&gt; 클라이언트.</target>
        </trans-unit>
        <trans-unit id="47e07a9bb649f4c37cacef3f1b08b496d76e7c98" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="translated">&lt;strong&gt;수행&lt;/strong&gt; 하여 &lt;strong&gt;배우기&lt;/strong&gt; 를 선호하는 경우 &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;실용적인 자습서를&lt;/a&gt; 확인하십시오 . 이 튜토리얼에서는 React에서 틱택 토 게임을 빌드합니다. 게임을 만들지 않고 기회를주기 때문에 건너 뛰고 싶을 수도 있습니다. 튜토리얼에서 배우는 기술은 &lt;em&gt;모든&lt;/em&gt; React 앱 을 빌드 &lt;em&gt;하는 데&lt;/em&gt; 있어 기본 이며,이를 마스터하면 훨씬 더 깊이 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1b9fd1209940d1b60d72917c0ebfc7e5668281f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not into building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</source>
          <target state="translated">If you prefer to &lt;strong&gt;learn by doing,&lt;/strong&gt; check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. In this tutorial, we build a tic-tac-toe game in React. You might be tempted to skip it because you&amp;rsquo;re not into building games &amp;mdash; but give it a chance. The techniques you&amp;rsquo;ll learn in the tutorial are fundamental to building &lt;em&gt;any&lt;/em&gt; React apps, and mastering it will give you a much deeper understanding.</target>
        </trans-unit>
        <trans-unit id="25ae91e52cf25cb83ca4d281086a571771ef39b0" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn by doing&lt;/strong&gt;, start with our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;.</source>
          <target state="translated">당신이 선호하는 경우 &lt;strong&gt;수행하여 배우고&lt;/strong&gt; , 우리의 시작 &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;실용적인 튜토리얼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c18121d1ed0c7e2f4c183167ee82f078e32e932e" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step,&lt;/strong&gt; our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt; is the best place to start. Every next chapter in it builds on the knowledge introduced in the previous chapters so you won&amp;rsquo;t miss anything as you go along.</source>
          <target state="translated">&lt;strong&gt;단계별로 개념&lt;/strong&gt; 을 &lt;strong&gt;배우기를&lt;/strong&gt; 원한다면 &lt;a href=&quot;index&quot;&gt;주요 개념에&lt;/a&gt; 대한 가이드 가 시작하기 가장 좋은 곳입니다. 다음 장은 이전 장에서 소개 된 지식을 바탕으로 진행되므로 진행중인 내용을 놓치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51a1d7a5fd157767ed19cef5074e83cab2e2cd1f" translate="yes" xml:space="preserve">
          <source>If you prefer to &lt;strong&gt;learn concepts step by step&lt;/strong&gt;, start with our &lt;a href=&quot;index&quot;&gt;guide to main concepts&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;단계별로 개념&lt;/strong&gt; 을 &lt;strong&gt;배우 &lt;/strong&gt;&lt;a href=&quot;index&quot;&gt;려면 주요 개념에&lt;/a&gt; 대한 안내서부터 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a70d45458110999e3ed23edf11293a04e3c413b" translate="yes" xml:space="preserve">
          <source>If you prefer to set up your own JavaScript toolchain from scratch, &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;check out this guide&lt;/a&gt; that re-creates some of the Create React App functionality.</source>
          <target state="translated">고유 한 JavaScript 툴체인을 처음부터 설정하려면 React 앱 작성 기능 중 일부를 다시 작성 &lt;a href=&quot;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&quot;&gt;하는이 안내서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce6bf88e40be3156ec3b84e97a7685d5e9ea541e" translate="yes" xml:space="preserve">
          <source>If you prefer to use your own text editor, you can also &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;download this HTML file&lt;/a&gt;, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so we&amp;rsquo;d only recommend using this for simple demos.</source>
          <target state="translated">자체 텍스트 편집기를 사용하려면 &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;이 HTML 파일을 다운로드하여&lt;/a&gt; 편집 한 후 브라우저의 로컬 파일 시스템에서 열 수 있습니다. 런타임 코드 변환이 느리기 때문에 간단한 데모에만 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f757443e0590f766abe60dffa51082eecb2b0c12" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes a whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="translated">If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes a whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</target>
        </trans-unit>
        <trans-unit id="d251364ce59ed1632b03eee6d1772a843639a2d0" translate="yes" xml:space="preserve">
          <source>If you press &amp;ldquo;Open Profile&amp;rdquo; now, you can tell something is wrong. It takes whole seven seconds to make the transition now! This is because our trivia API is too slow. Let&amp;rsquo;s say we can&amp;rsquo;t make the API faster. How can we improve the user experience with this constraint?</source>
          <target state="translated">지금&amp;ldquo;프로필 열기&amp;rdquo;를 누르면 문제가 있음을 알 수 있습니다. 지금 전환하는 데 7 초가 걸립니다! 사소한 API가 너무 느리기 때문입니다. API를 더 빨리 만들 수 없다고 가정 해 봅시다. 이 제약 조건으로 사용자 경험을 어떻게 개선 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ab0fcad6ece9f5a091fd940a4e69d81e420608bb" translate="yes" xml:space="preserve">
          <source>If you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">Reducer Hook에서 현재 상태와 동일한 값을 반환하면 자식 렌더링이나 발사 효과없이 React가 구제됩니다. (React는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 비교 알고리즘을&lt;/a&gt; 사용합니다 .)</target>
        </trans-unit>
        <trans-unit id="759d8e9c5a7a89f86b0192bac647a89f30115a0f" translate="yes" xml:space="preserve">
          <source>If you run this code and watch the console logs, you&amp;rsquo;ll notice the sequence is:</source>
          <target state="translated">이 코드를 실행하고 콘솔 로그를 보면 시퀀스가 ​​다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5efa147e22d5f8a48f15dbde439cdd94297df3a9" translate="yes" xml:space="preserve">
          <source>If you see an error message saying &amp;ldquo;You have mistakenly installed the &lt;code&gt;babel&lt;/code&gt; package&amp;rdquo;, you might have missed &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;the previous step&lt;/a&gt;. Perform it in the same folder, and then try again.</source>
          <target state="translated">&quot;실제로 &lt;code&gt;babel&lt;/code&gt; 패키지를 설치했습니다&quot;라는 오류 메시지가 표시 &lt;a href=&quot;#add-jsx-to-a-project&quot;&gt;되면 이전 단계를&lt;/a&gt; 놓친 것일 수 있습니다 . 동일한 폴더에서 수행 한 다음 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="b075833725a23cb77b5ba4dda4642dd74ec1c98a" translate="yes" xml:space="preserve">
          <source>If you see no output, it means that it completed successfully.</source>
          <target state="translated">출력이 없으면 성공적으로 완료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c6e92cbb0194609294df3744170608e6c63909c" translate="yes" xml:space="preserve">
          <source>If you serve React from a CDN, we recommend to keep the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt;&lt;code&gt;crossorigin&lt;/code&gt;&lt;/a&gt; attribute set:</source>
          <target state="translated">CDN에서 React를 제공하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes&quot;&gt; &lt;code&gt;crossorigin&lt;/code&gt; &lt;/a&gt; 속성 세트 를 유지하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6188f195de25803ee9e3dfbd8d8e12ea147b1a34" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;suppressHydrationWarning&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don&amp;rsquo;t overuse it. You can read more about hydration in the &lt;a href=&quot;react-dom#hydrate&quot;&gt;&lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;suppressHydrationWarning&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 React는 해당 요소의 속성 및 내용의 불일치에 대해 경고하지 않습니다. 한 수준 깊이에서만 작동하며 탈출 해치로 사용됩니다. 그것을 과도하게 사용하지 마십시오. 수화에 대한 자세한 내용은 &lt;a href=&quot;react-dom#hydrate&quot;&gt; &lt;code&gt;ReactDOM.hydrate()&lt;/code&gt; 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b1b979c8e20d02ec5a081ede351ede1e9e64ce" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useLayoutEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values that are used inside the callback and participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="translated">If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt; , &lt;code&gt;useLayoutEffect&lt;/code&gt; , &lt;code&gt;useMemo&lt;/code&gt; , &lt;code&gt;useCallback&lt;/code&gt; , or &lt;code&gt;useImperativeHandle&lt;/code&gt; , it must include all values that are used inside the callback and participate in the React data flow. That includes props, state, and anything derived from them.</target>
        </trans-unit>
        <trans-unit id="83336394d37cf4d7a5b1da0ff1854997645bf222" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;list of dependencies&lt;/a&gt; as the last argument to &lt;code&gt;useEffect&lt;/code&gt;, &lt;code&gt;useMemo&lt;/code&gt;, &lt;code&gt;useCallback&lt;/code&gt;, or &lt;code&gt;useImperativeHandle&lt;/code&gt;, it must include all values used inside that participate in the React data flow. That includes props, state, and anything derived from them.</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; , &lt;code&gt;useMemo&lt;/code&gt; , &lt;code&gt;useCallback&lt;/code&gt; 또는 &lt;code&gt;useImperativeHandle&lt;/code&gt; 의 마지막 인수로 &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;종속성 목록&lt;/a&gt; 을 지정하는 경우 React 데이터 플로우에 참여하는 내부에서 사용 된 모든 값을 포함해야합니다. 여기에는 소품, 상태 및 그로부터 파생 된 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="faccdb965000ef6d3d72692abf68f01516804384" translate="yes" xml:space="preserve">
          <source>If you try to type or check the box in the current version of the example, you&amp;rsquo;ll see that React ignores your input. This is intentional, as we&amp;rsquo;ve set the &lt;code&gt;value&lt;/code&gt; prop of the &lt;code&gt;input&lt;/code&gt; to always be equal to the &lt;code&gt;state&lt;/code&gt; passed in from &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="translated">예제의 현재 버전에서 상자를 입력하거나 선택하면 React가 입력을 무시한다는 것을 알 수 있습니다. 이것은 &lt;code&gt;input&lt;/code&gt; 의 &lt;code&gt;value&lt;/code&gt; prop 가 항상 &lt;code&gt;FilterableProductTable&lt;/code&gt; 에서 전달 된 &lt;code&gt;state&lt;/code&gt; 같도록 설정했기 때문에 의도적 인 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6678ae603feef4934590c9fa76461843ca5d6683" translate="yes" xml:space="preserve">
          <source>If you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt;&lt;code&gt;Object.is&lt;/code&gt; comparison algorithm&lt;/a&gt;.)</source>
          <target state="translated">State Hook를 현재 상태와 동일한 값으로 업데이트하면 자식 렌더링이나 발사 효과없이 React가 구제됩니다. (React는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description&quot;&gt; &lt;code&gt;Object.is&lt;/code&gt; 비교 알고리즘을&lt;/a&gt; 사용합니다 .)</target>
        </trans-unit>
        <trans-unit id="56066137d55bf0e7ea681f5b1c777065f8ae4ce8" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;, run:</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 을 사용하는 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ade7aaf73be5436c90eadc8335fc3dd6aae134ed" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;, run:</source>
          <target state="translated">&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; 을 사용하는 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2699510a2c0fb7e097d079f03709fb5c277aac2f" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;react-test-renderer&lt;/code&gt;, it also provides an &lt;code&gt;act&lt;/code&gt; export that behaves the same way.</source>
          <target state="translated">&lt;code&gt;react-test-renderer&lt;/code&gt; 를 사용 하면 동일한 방식으로 작동 하는 &lt;code&gt;act&lt;/code&gt; 내보내기 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2f17ca24abe37d1b86e8f96b92da181d93f0022e" translate="yes" xml:space="preserve">
          <source>If you use Create React App, you can &lt;strong&gt;skip the rest of this page&lt;/strong&gt;. It describes the manual setup which doesn&amp;rsquo;t apply to Create React App users.</source>
          <target state="translated">React App 작성을 사용 &lt;strong&gt;하는 경우이 페이지의 나머지 부분을 건너 뛸&lt;/strong&gt; 수 있습니다 . React App 사용자 생성에는 적용되지 않는 수동 설정에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4a8c97699e7a184def74f6d4614cb42d1ba5dcbe" translate="yes" xml:space="preserve">
          <source>If you use React 16.2 or lower, or if you need more flexibility than provided by ref forwarding, you can use &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;this alternative approach&lt;/a&gt; and explicitly pass a ref as a differently named prop.</source>
          <target state="translated">React 16.2 이하를 사용하거나 참조 전달에서 제공하는 것보다 더 많은 유연성이 필요한 경우, &lt;a href=&quot;https://gist.github.com/gaearon/1a018a023347fe1c2476073330cc5509&quot;&gt;이 대체 방법을&lt;/a&gt; 사용 하여 다른 이름을 가진 prop로 명시 적으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a26f616e6ce178a355bc6c9ea84fd7cd247eb1f" translate="yes" xml:space="preserve">
          <source>If you use React 16.3 or higher, we recommend to use &lt;a href=&quot;forwarding-refs&quot;&gt;ref forwarding&lt;/a&gt; for these cases. &lt;strong&gt;Ref forwarding lets components opt into exposing any child component&amp;rsquo;s ref as their own&lt;/strong&gt;. You can find a detailed example of how to expose a child&amp;rsquo;s DOM node to a parent component &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;in the ref forwarding documentation&lt;/a&gt;.</source>
          <target state="translated">React 16.3 이상을 사용 하는 경우 이러한 경우에 &lt;a href=&quot;forwarding-refs&quot;&gt;Ref Forwarding&lt;/a&gt; 을 사용하는 것이 좋습니다 . &lt;strong&gt;참조 전달을 사용하면 구성 요소가 하위 구성 요소의 참조를 자신의 것으로 표시하도록 선택할 수 있습니다&lt;/strong&gt; . &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;참조 전달 문서에서&lt;/a&gt; 자식의 DOM 노드를 부모 구성 요소 에 노출시키는 방법에 대한 자세한 예를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9cdf2ae438a9227b0fb23473474b484ea3d6ee" translate="yes" xml:space="preserve">
          <source>If you use React with Web Components (which is uncommon), use the &lt;code&gt;class&lt;/code&gt; attribute instead.</source>
          <target state="translated">일반적이지 않은 웹 구성 요소로 React를 사용하는 경우 &lt;code&gt;class&lt;/code&gt; 속성을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab5e9d5516774b9d626ce5a38d7e13d370bfc3f7" translate="yes" xml:space="preserve">
          <source>If you use Yarn, run:</source>
          <target state="translated">Yarn을 사용하는 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="102d3b3dd48c9c09e36ebc5686501b3bb694fec8" translate="yes" xml:space="preserve">
          <source>If you use npm, run:</source>
          <target state="translated">npm을 사용하는 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b8118d016218e4b145cd1549aa3d71605952205a" translate="yes" xml:space="preserve">
          <source>If you use server rendering, keep in mind that &lt;em&gt;neither&lt;/em&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt; nor &lt;code&gt;useEffect&lt;/code&gt; can run until the JavaScript is downloaded. This is why React warns when a server-rendered component contains &lt;code&gt;useLayoutEffect&lt;/code&gt;. To fix this, either move that logic to &lt;code&gt;useEffect&lt;/code&gt; (if it isn&amp;rsquo;t necessary for the first render), or delay showing that component until after the client renders (if the HTML looks broken until &lt;code&gt;useLayoutEffect&lt;/code&gt; runs).</source>
          <target state="translated">당신은 서버 렌더링을 사용하는 경우, 것을 명심 &lt;em&gt;도 &lt;/em&gt; &lt;code&gt;useLayoutEffect&lt;/code&gt; 도 &lt;code&gt;useEffect&lt;/code&gt; 은 자바 스크립트가 다운로드 될 때까지 실행할 수 있습니다. 이것이 서버 렌더링 컴포넌트에 &lt;code&gt;useLayoutEffect&lt;/code&gt; 가 포함 된 경우 React가 경고하는 이유 입니다. 이 문제를 해결하려면 해당 논리를 &lt;code&gt;useEffect&lt;/code&gt; 로 이동하거나 (첫 번째 렌더링에 필요하지 않은 경우) 클라이언트가 렌더링 될 때까지 해당 구성 요소 표시를 지연하십시오 ( &lt;code&gt;useLayoutEffect&lt;/code&gt; 가 실행될 때까지 HTML이 손상된 경우 ).</target>
        </trans-unit>
        <trans-unit id="70f4f49dc8d98ed757f120ffbd84c5052c4128e4" translate="yes" xml:space="preserve">
          <source>If you use server-side React rendering, normally there is a warning when the server and the client render different content. However, in some rare cases, it is very hard or impossible to guarantee an exact match. For example, timestamps are expected to differ on the server and on the client.</source>
          <target state="translated">서버 측 React 렌더링을 사용하는 경우 일반적으로 서버와 클라이언트가 다른 컨텐츠를 렌더링 할 때 경고가 발생합니다. 그러나 드문 경우이지만 정확한 일치를 보장하는 것은 매우 어렵거나 불가능합니다. 예를 들어, 타임 스탬프는 서버와 클라이언트에서 다를 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4178e978ea6a519b02f6012454f8eaa90a9377" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;what to do when the array changes too often&lt;/a&gt;.</source>
          <target state="translated">이 최적화를 사용하는 경우 &lt;strong&gt;시간이 지남에 따라 변경되고 effect에 의해 사용되는 구성 요소 범위 (예 : props 및 state)의 모든 값&lt;/strong&gt; 이 배열에 포함되어 있는지 확인하십시오 . 그렇지 않으면 코드가 이전 렌더링의 오래된 값을 참조합니다. &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;함수 처리 방법&lt;/a&gt; 및 &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;배열이 너무 자주 변경 될 때 수행 할 작업&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="6b64e4be8855b0be8c046942224485641c321ede" translate="yes" xml:space="preserve">
          <source>If you use this optimization, make sure the array includes &lt;strong&gt;all values from the component scope (such as props and state) that change over time and that are used by the effect&lt;/strong&gt;. Otherwise, your code will reference stale values from previous renders. Learn more about &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;how to deal with functions&lt;/a&gt; and what to do when the &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;array values change too often&lt;/a&gt;.</source>
          <target state="translated">이 최적화를 사용하는 경우 &lt;strong&gt;시간이 지남에 따라 변경되고 effect에 의해 사용되는 구성 요소 범위 (예 : props 및 state)의 모든 값&lt;/strong&gt; 이 배열에 포함되어 있는지 확인하십시오 . 그렇지 않으면 코드가 이전 렌더링의 오래된 값을 참조합니다. &lt;a href=&quot;hooks-faq#is-it-safe-to-omit-functions-from-the-list-of-dependencies&quot;&gt;함수 처리 방법&lt;/a&gt; 및 &lt;a href=&quot;hooks-faq#what-can-i-do-if-my-effect-dependencies-change-too-often&quot;&gt;배열 값이 너무 자주 변경&lt;/a&gt; 될 때 수행 할 작업 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="d4105f95647054b8ce2ef44647d3afb57bb52d64" translate="yes" xml:space="preserve">
          <source>If you use this shorthand form for &lt;code&gt;React.createElement&lt;/code&gt;, it can be almost as convenient to use React without JSX.</source>
          <target state="translated">&lt;code&gt;React.createElement&lt;/code&gt; 에이 속기 양식을 사용하면 JSX 없이 React를 사용하는 것이 거의 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cd2291bcdecaf7bcb60d1e8e04c1651f5828fbb6" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; for &lt;strong&gt;re-computing some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 을 위한 &lt;strong&gt;소품 변경하는 경우에만 일부 데이터를 재 계산&lt;/strong&gt; , &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;대신 메모이 제이션 도우미를 사용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa1798685fecc6fe21b1daed99365b31b3e0abf4" translate="yes" xml:space="preserve">
          <source>If you used &lt;code&gt;componentWillReceiveProps&lt;/code&gt; to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;prop가 변경 될 때 &lt;/strong&gt; &lt;code&gt;componentWillReceiveProps&lt;/code&gt; 를 사용 하여 &lt;strong&gt;일부 상태&lt;/strong&gt; 를 &lt;strong&gt;&quot;재설정&quot;한 경우&lt;/strong&gt; 대신 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 구성 요소를 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;완전히 제어&lt;/a&gt; 하거나 완전히 제어하지 않는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3a26502e1fe8a2d37c09afc69271006277d32cf" translate="yes" xml:space="preserve">
          <source>If you used classes in React before, this code should look familiar:</source>
          <target state="translated">이전에 React에서 클래스를 사용한 경우이 코드는 익숙해 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="f80346a09a47643908c6e3e6ed53648965736c75" translate="yes" xml:space="preserve">
          <source>If you visit a site with React in development mode, the icon will have a red background:</source>
          <target state="translated">개발 모드에서 React가있는 사이트를 방문하면 아이콘에 빨간색 배경이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8d195f74ff5d044f82074fc4c274d0cab852a524" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;&amp;ldquo;reset&amp;rdquo; some state when a prop changes&lt;/strong&gt;, consider either making a component &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;fully controlled&lt;/a&gt; or &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt;fully uncontrolled with a &lt;code&gt;key&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;소품이 변경 될 때 일부 상태&lt;/strong&gt; 를 &lt;strong&gt;&quot;재설정&quot;&lt;/strong&gt; 하려면 구성 요소를 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component&quot;&gt;완전히 제어&lt;/a&gt; 하거나 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 완전히 제어 해제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="029c59f29056b8c40cf61f9a51a8fb598e52ee51" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;re-compute some data only when a prop changes&lt;/strong&gt;, &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;use a memoization helper instead&lt;/a&gt;.</source>
          <target state="translated">당신이 원하는 경우 &lt;strong&gt;소품 변경하는 경우에만 일부 데이터를 재 계산&lt;/strong&gt; , &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization&quot;&gt;대신 메모이 제이션 도우미를 사용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec176e2b65d2b16278f626d01b65a2ecdb160310" translate="yes" xml:space="preserve">
          <source>If you want to access the event properties in an asynchronous way, you should call &lt;code&gt;event.persist()&lt;/code&gt; on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</source>
          <target state="translated">비동기 방식으로 이벤트 속성에 액세스하려면 이벤트에서 &lt;code&gt;event.persist()&lt;/code&gt; 를 호출해야합니다. 그러면 풀에서 합성 이벤트가 제거되고 이벤트에 대한 참조가 사용자 코드에 의해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7b47497fde239e197e47109c7ac26f42ec5315b4" translate="yes" xml:space="preserve">
          <source>If you want to allow people to take a &lt;code&gt;ref&lt;/code&gt; to your function component, you can use &lt;a href=&quot;forwarding-refs&quot;&gt;&lt;code&gt;forwardRef&lt;/code&gt;&lt;/a&gt; (possibly in conjunction with &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt;), or you can convert the component to a class.</source>
          <target state="translated">사람들이 함수 구성 요소를 &lt;code&gt;ref&lt;/code&gt; 하도록하려면 &lt;a href=&quot;forwarding-refs&quot;&gt; &lt;code&gt;forwardRef&lt;/code&gt; &lt;/a&gt; ( useImperativeHandle 과 함께 &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt; )를 사용하거나 구성 요소를 클래스로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9774977c9a0cf92ae57d02963964597fc3851501" translate="yes" xml:space="preserve">
          <source>If you want to extend your contrast testing abilities you can use these tools:</source>
          <target state="translated">대비 테스트 기능을 확장하려면 다음 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86422551613e303c9360cc61b58e27131dcc97ca" translate="yes" xml:space="preserve">
          <source>If you want to mark an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; as selected, reference the value of that option in the &lt;code&gt;value&lt;/code&gt; of its &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; instead. Check out &lt;a href=&quot;forms#the-select-tag&quot;&gt;&amp;ldquo;The select Tag&amp;rdquo;&lt;/a&gt; for detailed instructions.</source>
          <target state="translated">If you want to mark an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; as selected, reference the value of that option in the &lt;code&gt;value&lt;/code&gt; of its &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; instead. Check out &lt;a href=&quot;forms#the-select-tag&quot;&gt;&amp;ldquo;The select Tag&amp;rdquo;&lt;/a&gt; for detailed instructions.</target>
        </trans-unit>
        <trans-unit id="4c61cdf741239e1629cb1394fd5b25ad2e23b07e" translate="yes" xml:space="preserve">
          <source>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</source>
          <target state="translated">구성 요소간에 UI가 아닌 기능을 재사용하려면 별도의 JavaScript 모듈로 추출하는 것이 좋습니다. 컴포넌트는 그것을 가져 오지 않고 해당 함수, 객체 또는 클래스를 가져 와서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c62cdf54a3c4b69e723af171e44872b6cf5229d" translate="yes" xml:space="preserve">
          <source>If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array (&lt;code&gt;[]&lt;/code&gt;) as a second argument. This tells React that your effect doesn&amp;rsquo;t depend on &lt;em&gt;any&lt;/em&gt; values from props or state, so it never needs to re-run. This isn&amp;rsquo;t handled as a special case &amp;mdash; it follows directly from how the dependencies array always works.</source>
          <target state="translated">효과를 실행하고 마운트 및 마운트 해제시 한 번만 정리하려면 빈 배열 ( &lt;code&gt;[]&lt;/code&gt; )을 두 번째 인수로 전달할 수 있습니다 . 이것은 당신의 효과에 의존하지 않는 반작용 알려줍니다 &lt;em&gt;어떤&lt;/em&gt; 이 다시 실행해야하지 않도록, 소품이나 상태의 값. 이것은 특별한 경우로 처리되지 않습니다. 의존성 배열이 항상 작동하는 방식에서 직접 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff9f5e51b60174574056d9954f4502bc83ff6681" translate="yes" xml:space="preserve">
          <source>If you want to test out how some specific JSX is converted into JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">특정 JSX가 JavaScript로 어떻게 변환되는지 테스트 &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;하려면 온라인 Babel 컴파일러를&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="ff5c25e81b4c83c34080d583406db75e5fbd89cb" translate="yes" xml:space="preserve">
          <source>If you want, you can &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;extract this logic&lt;/a&gt; into a reusable Hook:</source>
          <target state="translated">원하는 &lt;a href=&quot;https://codesandbox.io/s/m5o42082xy&quot;&gt;경우이 논리&lt;/a&gt; 를 재사용 가능한 후크로 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="399df8ef1381d54faa0cf11b65366b05a0ec37b9" translate="yes" xml:space="preserve">
          <source>If you worked with React before, you might be familiar with an older API where the &lt;code&gt;ref&lt;/code&gt; attribute is a string, like &lt;code&gt;&quot;textInput&quot;&lt;/code&gt;, and the DOM node is accessed as &lt;code&gt;this.refs.textInput&lt;/code&gt;. We advise against it because string refs have &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;some issues&lt;/a&gt;, are considered legacy, and &lt;strong&gt;are likely to be removed in one of the future releases&lt;/strong&gt;.</source>
          <target state="translated">이전에 React로 작업 한 경우 &lt;code&gt;ref&lt;/code&gt; 속성이 &lt;code&gt;&quot;textInput&quot;&lt;/code&gt; 과 같은 문자열이고 DOM 노드가 &lt;code&gt;this.refs.textInput&lt;/code&gt; 으로 액세스 되는 이전 API에 익숙 할 수 있습니다 . 문자열 참조에는 &lt;a href=&quot;https://github.com/facebook/react/pull/8333#issuecomment-271648615&quot;&gt;몇 가지 문제&lt;/a&gt; 가 있고 레거시로 간주 &lt;strong&gt;되며 향후 릴리스 중 하나에서 제거 될&lt;/strong&gt; 수 있기 때문에 권장하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="aefdc0d20887310bdbbac46cc25deb537667e418" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d rather play it safe, you have a few options:</source>
          <target state="translated">안전하게 플레이하고 싶다면 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7e8f0a6c71e57b282d77890abf3bb605b7ee301" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re &lt;strong&gt;learning React&lt;/strong&gt; or &lt;strong&gt;creating a new &lt;a href=&quot;glossary#single-page-application&quot;&gt;single-page&lt;/a&gt; app,&lt;/strong&gt; use &lt;a href=&quot;#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="translated">당신이 경우 &lt;strong&gt;학습 반응&lt;/strong&gt; 또는 &lt;strong&gt;새로운 창조 &lt;a href=&quot;glossary#single-page-application&quot;&gt;단일 페이지&lt;/a&gt; 응용 프로그램을&lt;/strong&gt; 사용 &lt;a href=&quot;#create-react-app&quot;&gt;만들기 앱 반응&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35c007d618e08aa59cd6a4806d7e82c16701dda7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re benchmarking or experiencing performance problems in your React apps, make sure you&amp;rsquo;re testing with the minified production build.</source>
          <target state="translated">React 앱에서 벤치마킹하거나 성능 문제가 발생하는 경우 축소 된 프로덕션 빌드로 테스트하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7fc0f59462da1ba03fb1bccaf4af7f83c2421ae8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;component library&lt;/strong&gt; or &lt;strong&gt;integrating with an existing codebase&lt;/strong&gt;, try &lt;a href=&quot;#more-flexible-toolchains&quot;&gt;More Flexible Toolchains&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;컴포넌트 라이브러리를&lt;/strong&gt; 구축 하거나 &lt;strong&gt;기존 코드베이스와 통합하는 경우 &lt;/strong&gt;&lt;a href=&quot;#more-flexible-toolchains&quot;&gt;보다 유연한 툴체인을&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="e3161c887f0931683850b4ab0d55e09441cde098" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;server-rendered website with Node.js,&lt;/strong&gt; try &lt;a href=&quot;#nextjs&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Node.js&lt;/strong&gt; 로 &lt;strong&gt;서버 렌더링 웹 사이트를&lt;/strong&gt; 구축하는 경우 &lt;a href=&quot;#nextjs&quot;&gt;Next.js를&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="1fbb68fe4e24629438d31ddaa72b597eeb2cb3e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a &lt;strong&gt;static content-oriented website,&lt;/strong&gt; try &lt;a href=&quot;#gatsby&quot;&gt;Gatsby&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;정적 콘텐츠 지향 웹 사이트를&lt;/strong&gt; 구축하는 경우 &lt;a href=&quot;#gatsby&quot;&gt;Gatsby를&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="5cb0145636525588474f0e8276c35e496d1aac96" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from a design background, &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;these resources&lt;/a&gt; are a great place to get started.</source>
          <target state="translated">디자인 배경에서 온다면 &lt;a href=&quot;https://reactfordesigners.com/&quot;&gt;이러한 리소스&lt;/a&gt; 는 시작하기에 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="1b21a8327f2d695d247dab9ba4c44926f184c95d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from classes, you might be tempted to always call &lt;code&gt;useState()&lt;/code&gt; once and put all state into a single object. You can do it if you&amp;rsquo;d like. Here is an example of a component that follows the mouse movement. We keep its position and size in the local state:</source>
          <target state="translated">클래스에서 오는 경우 항상 &lt;code&gt;useState()&lt;/code&gt; 한 번 호출 하고 모든 상태를 단일 객체에 넣으려고 할 수 있습니다 . 원한다면 할 수 있습니다. 다음은 마우스 움직임을 따르는 구성 요소의 예입니다. 우리는 그 위치와 크기를 지방 상태로 유지합니다</target>
        </trans-unit>
        <trans-unit id="bbe478a8949bbc21442ebfd2295d514e9b9da8e6" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re curious to see more examples of how JSX is converted to JavaScript, you can try out &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;the online Babel compiler&lt;/a&gt;.</source>
          <target state="translated">JSX가 JavaScript로 변환되는 방법에 대한 더 많은 예제가 궁금하다면 &lt;a href=&quot;https://babeljs.io/repl/#?presets=react&amp;amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&quot;&gt;온라인 Babel 컴파일러를&lt;/a&gt; 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="cdbf14a41aa9dba4bb37c7ce0040976c3385bce3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re currently using &lt;code&gt;this.refs.textInput&lt;/code&gt; to access refs, we recommend using either the &lt;a href=&quot;#callback-refs&quot;&gt;callback pattern&lt;/a&gt; or the &lt;a href=&quot;#creating-refs&quot;&gt;&lt;code&gt;createRef&lt;/code&gt; API&lt;/a&gt; instead.</source>
          <target state="translated">현재 &lt;code&gt;this.refs.textInput&lt;/code&gt; 을 사용하여 참조 에 액세스하는 경우 &lt;a href=&quot;#callback-refs&quot;&gt;콜백 패턴&lt;/a&gt; 또는 &lt;a href=&quot;#creating-refs&quot;&gt; &lt;code&gt;createRef&lt;/code&gt; API를&lt;/a&gt; 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1c02314892cb9a48617e7c2fdd059a92d98fef42" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with React class lifecycle methods, you can think of &lt;code&gt;useEffect&lt;/code&gt; Hook as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; combined.</source>
          <target state="translated">React 클래스 라이프 사이클 메소드에 익숙하다면 &lt;code&gt;useEffect&lt;/code&gt; Hook를 &lt;code&gt;componentDidMount&lt;/code&gt; , &lt;code&gt;componentDidUpdate&lt;/code&gt; 및 &lt;code&gt;componentWillUnmount&lt;/code&gt; 결합 으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bdbd195fffc505b9d49fae18463ec74871e0648" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with the context API before Hooks, &lt;code&gt;useContext(MyContext)&lt;/code&gt; is equivalent to &lt;code&gt;static contextType = MyContext&lt;/code&gt; in a class, or to &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">후크 전에 컨텍스트 API에 익숙한 경우 &lt;code&gt;useContext(MyContext)&lt;/code&gt; 는 클래스의 &lt;code&gt;static contextType = MyContext&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;MyContext.Consumer&amp;gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="71cc84d56c28a1262eb498557fb996376cead69c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt;.</source>
          <target state="translated">React로 놀고 싶다면 온라인 코드 놀이터를 사용할 수 있습니다. &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt; 또는 &lt;a href=&quot;https://glitch.com/edit/#!/remix/starter-react-template&quot;&gt;Glitch&lt;/a&gt; 에서 Hello World 템플릿을 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="111900da49ce06d00c9d5ebb52775be7c724af2c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://stackblitz.com/fork/react&quot;&gt;Stackblitz&lt;/a&gt;.</source>
          <target state="translated">If you&amp;rsquo;re interested in playing around with React, you can use an online code playground. Try a Hello World template on &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/hello-world&quot;&gt;CodePen&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/new&quot;&gt;CodeSandbox&lt;/a&gt;, or &lt;a href=&quot;https://stackblitz.com/fork/react&quot;&gt;Stackblitz&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b478957a5f6430e0e6de7b367d98ab11dc6863ad" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re just starting a project, &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;don&amp;rsquo;t spend more than five minutes&lt;/a&gt; on choosing a file structure. Pick any of the above approaches (or come up with your own) and start writing code! You&amp;rsquo;ll likely want to rethink it anyway after you&amp;rsquo;ve written some real code.</source>
          <target state="translated">프로젝트를 방금 시작하는 경우 파일 구조를 선택하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Analysis_paralysis&quot;&gt;데 5 분 이상을 소비하지 마십시오&lt;/a&gt; . 위의 접근 방식 중 하나를 선택하거나 직접 작성하십시오! 실제 코드를 작성한 후 어쨌든 다시 생각하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="02065c0e863b23eb9f215dd9e810ad0fbc822f45" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; is one of the popular choices. However, it is built on the same principles of controlled components and managing state &amp;mdash; so don&amp;rsquo;t neglect to learn them.</source>
          <target state="translated">검증, 방문 필드 추적 및 양식 제출 처리를 포함한 완벽한 솔루션을 찾고 있다면 &lt;a href=&quot;https://jaredpalmer.com/formik&quot;&gt;Formik&lt;/a&gt; 가 가장 인기있는 선택 중 하나입니다. 그러나 제어되는 구성 요소 및 관리 상태와 동일한 원칙을 기반으로하므로 배우는 것을 소홀히하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff4bea4c5b521a6375a592447c292171386ec893" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re migrating code from a class component, note &lt;code&gt;useLayoutEffect&lt;/code&gt; fires in the same phase as &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, &lt;strong&gt;we recommend starting with &lt;code&gt;useEffect&lt;/code&gt; first&lt;/strong&gt; and only trying &lt;code&gt;useLayoutEffect&lt;/code&gt; if that causes a problem.</source>
          <target state="translated">클래스 컴포넌트에서 코드를 마이그레이션하는 경우 &lt;code&gt;useLayoutEffect&lt;/code&gt; 는 &lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 동일한 단계에서 실행됩니다 . 그러나 &lt;strong&gt;먼저 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;useEffect&lt;/code&gt; 로&lt;/strong&gt;&lt;strong&gt; 시작&lt;/strong&gt; 하고 문제가 발생하는 경우 &lt;code&gt;useLayoutEffect&lt;/code&gt; 를 시도하는 &lt;strong&gt;것이 좋습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5503753c4ba3a8933fe75a74d026956b4dbf0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to Hooks, you might want to check out &lt;a href=&quot;hooks-overview&quot;&gt;the overview&lt;/a&gt; first. You may also find useful information in the &lt;a href=&quot;hooks-faq&quot;&gt;frequently asked questions&lt;/a&gt; section.</source>
          <target state="translated">Hooks를 처음 사용 하는 &lt;a href=&quot;hooks-overview&quot;&gt;경우&lt;/a&gt; 먼저 개요 를 확인하십시오 . &lt;a href=&quot;hooks-faq&quot;&gt;질문&lt;/a&gt; 과 대답 섹션 에서 유용한 정보를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c7ebc6b49f6dd3625d44bdc17f0c9841de397f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not familiar with this syntax, check out the &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;explanation&lt;/a&gt; in the State Hook documentation.</source>
          <target state="translated">이 구문에 익숙하지 않은 경우 State Hook 설명서 의 &lt;a href=&quot;hooks-state#tip-what-do-square-brackets-mean&quot;&gt;설명&lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5174b478727365c84b01ba51be97ccc6bde6c829" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up Webpack yourself, you&amp;rsquo;ll probably want to read Webpack&amp;rsquo;s &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;guide on code splitting&lt;/a&gt;. Your Webpack config should look vaguely &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;like this&lt;/a&gt;.</source>
          <target state="translated">Webpack을 직접 설정하는 경우 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;코드 분할에 대한&lt;/a&gt; Webpack 안내서 를 읽고 싶을 것입니다 . Webpack 설정은 다음 &lt;a href=&quot;https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269&quot;&gt;과 같이&lt;/a&gt; 모호해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a795cf4399197efaee67030befff9eb14a55d67d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you&amp;rsquo;re interested, follow these steps:</source>
          <target state="translated">타사 React 프레임 워크, 라이브러리, 개발자 도구 또는 유사한 인프라 유형 프로젝트의 작성자 인 경우 가장 최근에 테스트 스위트를 정기적으로 실행하여 사용자 및 전체 React 커뮤니티에 React를 안정적으로 유지할 수 있습니다. 변화. 관심이 있으시면 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="88d974a28ce0731e8c5b22ec90e221bfa58d8cf7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let&amp;rsquo;s look at a practical example to see why this design helps us create components with fewer bugs.</source>
          <target state="translated">수업에 익숙하다면 마운트 해제 중 한 번이 아니라 모든 다시 렌더링 후에 효과 정리 단계가 발생하는 이유가 궁금 할 것입니다. 이 디자인이 버그가 적은 구성 요소를 만드는 데 도움이되는 이유를 알아보기위한 실용적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1a62f31b074af071c75f6aa5fa6fe227724f9d8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="translated">If you&amp;rsquo;re using &lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://nextjs.org/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</target>
        </trans-unit>
        <trans-unit id="d6e2e192cd0c1fbe3f4992433f068147160c96ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt;, &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;Gatsby&lt;/a&gt;, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;응용 프로그램 반작용 만들기&lt;/a&gt; , &lt;a href=&quot;https://github.com/zeit/next.js/&quot;&gt;Next.js&lt;/a&gt; , &lt;a href=&quot;https://www.gatsbyjs.org/&quot;&gt;개츠비&lt;/a&gt; , 또는 유사한 도구를, 당신은 당신의 응용 프로그램을 번들하기 위해 상자의 밖으로 웹팩 설정을해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d127abe7b8ab646fe461064799810c4bc682187" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, both &lt;code&gt;Object.assign&lt;/code&gt; and the object spread syntax are available by default.</source>
          <target state="translated">React 앱 작성 을 사용하는 경우 기본적으로 &lt;code&gt;Object.assign&lt;/code&gt; 및 오브젝트 스프레드 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e78c645e20c8ca2c19f0d386c2f5955c20c8fe1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Create React App, please follow &lt;a href=&quot;#create-react-app&quot;&gt;the instructions above&lt;/a&gt;.</source>
          <target state="translated">React 앱 만들기를 사용하는 경우 &lt;a href=&quot;#create-react-app&quot;&gt;위의 지침을&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="2b82de6f7cc131deac549e5bef7f9e8de5d34f8d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working on a data fetching library, there&amp;rsquo;s a crucial aspect of Render-as-You-Fetch you don&amp;rsquo;t want to miss. &lt;strong&gt;We kick off fetching &lt;em&gt;before&lt;/em&gt; rendering.&lt;/strong&gt; Look at this code example closer:</source>
          <target state="translated">데이터 페치 라이브러리에서 작업하는 경우 놓치고 싶지 않은 렌더로 가져 오기의 중요한 측면이 있습니다. &lt;strong&gt;렌더링 &lt;/strong&gt;&lt;strong&gt;&lt;em&gt;전에&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 페칭을 시작합니다 . &lt;em&gt;&lt;/em&gt;&lt;/strong&gt;이 코드 예제를 자세히 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="52cc1d74837d5c0361acef0611ccd09597783f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a library that tests mostly browser-specific behavior, and requires native browser behavior like layout or real inputs, you could use a framework like &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha.&lt;/a&gt;</source>
          <target state="translated">대부분 브라우저 별 동작을 테스트하고 레이아웃 또는 실제 입력과 같은 기본 브라우저 동작이 필요한 라이브러리를 작성하는 경우 &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt; 와 같은 프레임 워크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b3ede746a1b41e135139260bd938036c1b5653" translate="yes" xml:space="preserve">
          <source>If your React component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; function renders the same result given the same props and state, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; for a performance boost in some cases.</source>
          <target state="translated">React 컴포넌트의 &lt;code&gt;render()&lt;/code&gt; 함수가 동일한 props와 state가 주어지면 동일한 결과를 렌더링하는 경우 &lt;code&gt;React.PureComponent&lt;/code&gt; 를 사용 하여 성능을 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ae535fa4a52d95be43cd119d3dce94ee825d2ad" translate="yes" xml:space="preserve">
          <source>If your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as &amp;ldquo;windowing&amp;rdquo;. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.</source>
          <target state="translated">응용 프로그램이 긴 데이터 목록 (수백 또는 수천 행)을 렌더링하는 경우&amp;ldquo;창&amp;rdquo;이라는 기술을 사용하는 것이 좋습니다. 이 기술은 주어진 시간에 행의 작은 서브 세트 만 렌더링하며, 컴포넌트를 다시 렌더링하는 데 걸리는 시간과 작성된 DOM 노드 수를 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0415d8714549e60a664370c6ba10482c3fc92d" translate="yes" xml:space="preserve">
          <source>If your application requires pointer events, we recommend adding a third party pointer event polyfill.</source>
          <target state="translated">응용 프로그램에 포인터 이벤트가 필요한 경우 타사 포인터 이벤트 폴리 필을 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2395816cffe7512d0939e7686c6115bba399430f" translate="yes" xml:space="preserve">
          <source>If your component implements the &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; lifecycle (which is rare), the value it returns will be passed as a third &amp;ldquo;snapshot&amp;rdquo; parameter to &lt;code&gt;componentDidUpdate()&lt;/code&gt;. Otherwise this parameter will be undefined.</source>
          <target state="translated">구성 요소가 &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt; 수명주기 (드문 경우)를 구현하는 경우 반환되는 값은 세 번째 &quot;snapshot&quot;매개 변수로 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 됩니다. 그렇지 않으면이 매개 변수는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a60b45baec63445920ea948b6b750469a15d8d0" translate="yes" xml:space="preserve">
          <source>If your component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="translated">If your component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</target>
        </trans-unit>
        <trans-unit id="20d599f1233ec4f9623c8e348df9de9e2c174bee" translate="yes" xml:space="preserve">
          <source>If your function component renders the same result given the same props, you can wrap it in a call to &lt;code&gt;React.memo&lt;/code&gt; for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.</source>
          <target state="translated">함수 구성 요소가 동일한 소품으로 동일한 결과를 렌더링하는 경우 결과를 &lt;code&gt;React.memo&lt;/code&gt; 하여 성능 향상을 위해 React.memo 를 호출하여 랩핑 할 수 있습니다. 이것은 React가 컴포넌트 렌더링을 건너 뛰고 마지막 렌더링 결과를 재사용한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b153be87230d19e0959754d7e8fdb722e18406e" translate="yes" xml:space="preserve">
          <source>If your project is built with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, run:</source>
          <target state="translated">프로젝트가 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React App 작성&lt;/a&gt; 으로 빌드 된 경우 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4f76989cbe467f747eafaee915ffd618ee7e8e9e" translate="yes" xml:space="preserve">
          <source>If your project was set up using &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;, congratulations! The Flow annotations are already being stripped by default so you don&amp;rsquo;t need to do anything else in this step.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React App 만들기&lt;/a&gt; 를 사용하여 프로젝트를 설정 한 경우 축하합니다! 흐름 주석은 기본적으로 이미 제거되어 있으므로이 단계에서 다른 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0fc4f1f17431418025447890fea827dfa0079ea0" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.</source>
          <target state="translated">If your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.</target>
        </trans-unit>
        <trans-unit id="71e8d7dcd1b990fee40afd460f8d53442f4e8b92" translate="yes" xml:space="preserve">
          <source>If your update function returns the exact same value, the subsequent rerender will be skipped completely.</source>
          <target state="translated">업데이트 함수가 정확히 동일한 값을 반환하면 후속 렌더링은 완전히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e2e9082f9e460ca12ce12808ea1db2401ca59946" translate="yes" xml:space="preserve">
          <source>Image Events</source>
          <target state="translated">이미지 이벤트</target>
        </trans-unit>
        <trans-unit id="38bbbb29751f3fd92cc08381c3226ccef034d3b1" translate="yes" xml:space="preserve">
          <source>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</source>
          <target state="translated">우리는 이미 JSON API와 디자이너의 모의가 있다고 상상해보십시오. 모형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="515dd2117b7986f40a9ea292c49529e087a55c0a" translate="yes" xml:space="preserve">
          <source>Imagine we&amp;rsquo;re navigating between two screens in an app. Sometimes, we might not have enough code and data loaded to show a &amp;ldquo;good enough&amp;rdquo; loading state to the user on the new screen. Transitioning to an empty screen or a large spinner can be a jarring experience. However, it&amp;rsquo;s also common that the necessary code and data doesn&amp;rsquo;t take too long to fetch. &lt;strong&gt;Wouldn&amp;rsquo;t it be nicer if React could stay on the old screen for a little longer, and &amp;ldquo;skip&amp;rdquo; the &amp;ldquo;bad loading state&amp;rdquo; before showing the new screen?&lt;/strong&gt;</source>
          <target state="translated">앱에서 두 화면 사이를 탐색한다고 가정합니다. 때로는 새 화면에서 사용자에게 &quot;충분히 양호한&quot;로드 상태를 표시하기에 충분한 코드와 데이터가로드되지 않은 경우가 있습니다. 빈 화면이나 큰 스피너로 전환하는 것은 어려운 경험이 될 수 있습니다. 그러나 필요한 코드와 데이터를 가져 오는 데 너무 오래 걸리지 않는 것도 일반적입니다. &lt;strong&gt;React가 기존 화면에서 조금 더 오래 머무를 수 있고 새 화면을 표시하기 전에&amp;ldquo;불량 로딩 상태&amp;rdquo;를&amp;ldquo;건너 뛰는&amp;rdquo;것이 더 좋지 않습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a33a303f56a6bbd06206e5ce4d8446405d3fa4f3" translate="yes" xml:space="preserve">
          <source>Importantly, custom Hooks give you the power to constrain React API if you&amp;rsquo;d like to type them more strictly in some way. React gives you the primitives, but you can combine them in different ways than what we provide out of the box.</source>
          <target state="translated">중요하게도 커스텀 후크는 어떤 식 으로든 더 엄격하게 입력하려는 경우 React API를 제한 할 수있는 기능을 제공합니다. React는 프리미티브를 제공하지만 기본 제공 방식과 다른 방식으로 조합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="389fbb58f34b12bedefc8ca743f17e0f3583836d" translate="yes" xml:space="preserve">
          <source>Importantly, the way you &lt;em&gt;use&lt;/em&gt; React is the same. Concepts like components, props, and state fundamentally work the same way. When you want to update the screen, you set the state.</source>
          <target state="translated">중요한 것은 React 를 &lt;em&gt;사용&lt;/em&gt; 하는 방법이 동일합니다. 구성 요소, 소품 및 상태와 같은 개념은 기본적으로 동일한 방식으로 작동합니다. 화면을 업데이트하려면 상태를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1368d43d01a36b5581bb3e9a2be050b9de12c101" translate="yes" xml:space="preserve">
          <source>In CSS, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt;&lt;code&gt;display: contents&lt;/code&gt;&lt;/a&gt; attribute can be used if you don&amp;rsquo;t want the node to be part of the layout.</source>
          <target state="translated">CSS 에서 노드를 레이아웃의 일부로 사용하지 않으려는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents&quot;&gt; &lt;code&gt;display: contents&lt;/code&gt; &lt;/a&gt; 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b55e065dea1bfb41665c75fc1cc794c8f70a095" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, rendering is not blocking. It is interruptible. This improves the user experience. It also unlocks new features that weren&amp;rsquo;t possible before. Before we look at concrete examples in the &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;next&lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;chapters&lt;/a&gt;, we&amp;rsquo;ll do a high-level overview of new features.</source>
          <target state="translated">동시 모드에서 렌더링이 차단되지 않습니다. 인터럽트 가능합니다. 이것은 사용자 경험을 향상시킵니다. 또한 이전에는 불가능했던 새로운 기능의 잠금을 해제합니다. &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;다음 &lt;/a&gt;&lt;a href=&quot;concurrent-mode-patterns&quot;&gt;장&lt;/a&gt; 에서 구체적인 예를 살펴보기 전에 새로운 기능에 대해 개괄적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7ecc95e249a2849c1eb4333865f60656c17be67b" translate="yes" xml:space="preserve">
          <source>In Concurrent Mode, the lifecycle methods &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;previously marked&lt;/a&gt; as &amp;ldquo;unsafe&amp;rdquo; actually &lt;em&gt;are&lt;/em&gt; unsafe, and lead to bugs even more than in today&amp;rsquo;s React. We don&amp;rsquo;t recommend trying Concurrent Mode until your app is &lt;a href=&quot;strict-mode&quot;&gt;Strict Mode&lt;/a&gt;-compatible.</source>
          <target state="translated">동시 모드에서 &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;이전에&lt;/a&gt; &quot;안전하지 않은&quot; 것으로 표시된 수명주기 방법 &lt;em&gt;은&lt;/em&gt; 실제로 안전하지 않으며 오늘날의 React보다 훨씬 많은 버그로 이어집니다. 앱이 &lt;a href=&quot;strict-mode&quot;&gt;엄격한 모드와&lt;/a&gt; 호환 될 때까지 동시 모드를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="21ea6a0b5b929f6e4d971d6001063e6cdcc606f8" translate="yes" xml:space="preserve">
          <source>In ES6 classes, you can define the initial state by assigning &lt;code&gt;this.state&lt;/code&gt; in the constructor:</source>
          <target state="translated">ES6 클래스 에서 생성자에 &lt;code&gt;this.state&lt;/code&gt; 를 할당하여 초기 상태를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74b9508d775e315d9d48d1ac6d2be46507d95cbb" translate="yes" xml:space="preserve">
          <source>In HTML, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</source>
          <target state="translated">HTML에서 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 는 드롭 다운 목록을 만듭니다. 예를 들어이 HTML은 맛 드롭 다운 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6260ccb22bfbbde7ec537c88316f474366bfa99b" translate="yes" xml:space="preserve">
          <source>In HTML, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; element defines its text by its children:</source>
          <target state="translated">HTML에서 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 요소는 자식으로 텍스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cee26a6db634e40e4019da1e44bc2fa5e8708d30" translate="yes" xml:space="preserve">
          <source>In HTML, an &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt;.</source>
          <target state="translated">HTML에서 &lt;code&gt;&amp;lt;input type=&quot;file&quot;&amp;gt;&lt;/code&gt; 을 사용하면 사용자는 장치 저장소에서 하나 이상의 파일을 선택하여 서버에 업로드하거나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications&quot;&gt;File API&lt;/a&gt; 를 통해 JavaScript로 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd8882487752794b9ff3cba07ccbd1e6347dd57" translate="yes" xml:space="preserve">
          <source>In HTML, form elements such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with &lt;a href=&quot;react-component#setstate&quot;&gt;&lt;code&gt;setState()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTML에서 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 와 같은 양식 요소는 일반적으로 자체 상태를 유지하고 사용자 입력에 따라 업데이트합니다. React에서 변경 가능한 상태는 일반적으로 구성 요소의 state 속성에 유지되며 &lt;a href=&quot;react-component#setstate&quot;&gt; &lt;code&gt;setState()&lt;/code&gt; &lt;/a&gt; 로만 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="451fb8c93e5b83ed15cecd30a84768222971358c" translate="yes" xml:space="preserve">
          <source>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: &lt;code&gt;props.children&lt;/code&gt;. There are several different ways to pass children:</source>
          <target state="translated">여는 태그와 닫는 태그가 모두 포함 된 JSX 표현식에서 해당 태그 사이의 컨텐츠는 특수 &lt;code&gt;props.children&lt;/code&gt; : props.children 으로 전달됩니다 . 자녀를 합격시키는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b47b7c0e900bd9fddd8dd976d3fa0c74ee40520" translate="yes" xml:space="preserve">
          <source>In JavaScript, these two code snippets are &lt;strong&gt;not&lt;/strong&gt; equivalent:</source>
          <target state="translated">JavaScript에서이 두 코드 스 니펫은 동일 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="896c4ff0b7dad9168327f4c2b1e69fd7b821d242" translate="yes" xml:space="preserve">
          <source>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</source>
          <target state="translated">React 앱에서 구성 요소의 상태 저장 여부는 시간이 지남에 따라 변경 될 수있는 구성 요소의 구현 세부 사항으로 간주됩니다. 상태 저장 구성 요소 내부에서 상태 비 저장 구성 요소를 사용할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b509261276a2c24087d4a53dfcbb229d41ff110f" translate="yes" xml:space="preserve">
          <source>In React class components, the &lt;code&gt;render&lt;/code&gt; method itself shouldn&amp;rsquo;t cause side effects. It would be too early &amp;mdash; we typically want to perform our effects &lt;em&gt;after&lt;/em&gt; React has updated the DOM.</source>
          <target state="translated">React 클래스 컴포넌트에서 &lt;code&gt;render&lt;/code&gt; 메소드 자체는 부작용을 일으키지 않아야합니다. 너무 빠를 것입니다. 일반적으로 React가 DOM을 업데이트 &lt;em&gt;한 후에&lt;/em&gt; 효과를 수행하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="cea30c1cddacc5c2fb8659ad8a3ea7724439494a" translate="yes" xml:space="preserve">
          <source>In React components declared as ES6 classes, methods follow the same semantics as regular ES6 classes. This means that they don&amp;rsquo;t automatically bind &lt;code&gt;this&lt;/code&gt; to the instance. You&amp;rsquo;ll have to explicitly use &lt;code&gt;.bind(this)&lt;/code&gt; in the constructor:</source>
          <target state="translated">ES6 클래스로 선언 된 React 컴포넌트에서 메소드는 일반 ES6 클래스와 동일한 의미를 따릅니다. 이 방법은 자동으로 결합하지 않는 것이 &lt;code&gt;this&lt;/code&gt; 인스턴스에. 생성자에서 &lt;code&gt;.bind(this)&lt;/code&gt; 를 명시 적으로 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="538221c0cbcf54504c0c303253382099a46a923b" translate="yes" xml:space="preserve">
          <source>In React, a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; uses a &lt;code&gt;value&lt;/code&gt; attribute instead. This way, a form using a &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; can be written very similarly to a form that uses a single-line input:</source>
          <target state="translated">React에서 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 는 대신 &lt;code&gt;value&lt;/code&gt; 속성을 사용합니다. 이런 식으로 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 를 사용하는 양식은 한 줄 입력을 사용하는 양식과 매우 유사하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c9a3a5e0ceac65aab6602bc1dbe2fe9e493d0fe" translate="yes" xml:space="preserve">
          <source>In React, all DOM properties and attributes (including event handlers) should be camelCased. For example, the HTML attribute &lt;code&gt;tabindex&lt;/code&gt; corresponds to the attribute &lt;code&gt;tabIndex&lt;/code&gt; in React. The exception is &lt;code&gt;aria-*&lt;/code&gt; and &lt;code&gt;data-*&lt;/code&gt; attributes, which should be lowercased. For example, you can keep &lt;code&gt;aria-label&lt;/code&gt; as &lt;code&gt;aria-label&lt;/code&gt;.</source>
          <target state="translated">React에서 모든 DOM 속성 및 속성 (이벤트 핸들러 포함)은 camelCased 여야합니다. 예를 들어 HTML 속성 &lt;code&gt;tabindex&lt;/code&gt; 는 React의 &lt;code&gt;tabIndex&lt;/code&gt; 속성에 해당합니다 . 예외는 &lt;code&gt;aria-*&lt;/code&gt; 및 &lt;code&gt;data-*&lt;/code&gt; 소문자로해야한다 속성. 예를 들어 &lt;code&gt;aria-label&lt;/code&gt; 을 &lt;code&gt;aria-label&lt;/code&gt; 로 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c511871e368bc7af53ec2e81d4fb957978f940e" translate="yes" xml:space="preserve">
          <source>In React, an &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically.</source>
          <target state="translated">React에서 &lt;code&gt;&amp;lt;input type=&quot;file&quot; /&amp;gt;&lt;/code&gt; 은 항상 제어 할 수없는 구성 요소입니다. 그 값은 프로그래밍 방식이 아닌 사용자 만 설정할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3c7fa02f2469625e763a13cd5609a01cda7c6c08" translate="yes" xml:space="preserve">
          <source>In React, both &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; represent the &lt;em&gt;rendered&lt;/em&gt; values, i.e. what&amp;rsquo;s currently on the screen.</source>
          <target state="translated">React에서 &lt;code&gt;this.props&lt;/code&gt; 와 &lt;code&gt;this.state&lt;/code&gt; 는 &lt;em&gt;렌더링 된&lt;/em&gt; 값, 즉 현재 화면에 표시 &lt;em&gt;되는&lt;/em&gt; 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f14047f4f0476e66fe99901264ae249589cef260" translate="yes" xml:space="preserve">
          <source>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called &amp;ldquo;lifting state up&amp;rdquo;. We will remove the local state from the &lt;code&gt;TemperatureInput&lt;/code&gt; and move it into the &lt;code&gt;Calculator&lt;/code&gt; instead.</source>
          <target state="translated">React에서 공유 상태는 필요한 구성 요소의 가장 가까운 공통 조상으로 이동하여 수행됩니다. 이것을 &quot;리프팅 상태 상승&quot;이라고합니다. &lt;code&gt;TemperatureInput&lt;/code&gt; 에서 로컬 상태를 제거하고 대신 &lt;code&gt;Calculator&lt;/code&gt; 로 옮깁니다 .</target>
        </trans-unit>
        <trans-unit id="4a53b8bc22280c0c555667af9e91fb2d02153f1e" translate="yes" xml:space="preserve">
          <source>In React, this could instead be:</source>
          <target state="translated">React에서 대신 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="410126e91330d77043a8e4cf7862f0a183679992" translate="yes" xml:space="preserve">
          <source>In React, this is also achieved by composition, where a more &amp;ldquo;specific&amp;rdquo; component renders a more &amp;ldquo;generic&amp;rdquo; one and configures it with props:</source>
          <target state="translated">React에서, 이것은 또한 더 &quot;특정한&quot;구성 요소가 더 &quot;일반적인&quot;구성 요소를 렌더링하고 소품으로 구성하는 구성에 의해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="5f50da8ee138f52d6b59eebfb1b47338f96dd4b5" translate="yes" xml:space="preserve">
          <source>In React, this is usually solved by making a component &amp;ldquo;controlled&amp;rdquo;. Just like the DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; accepts both a &lt;code&gt;value&lt;/code&gt; and an &lt;code&gt;onChange&lt;/code&gt; prop, so can the custom &lt;code&gt;TemperatureInput&lt;/code&gt; accept both &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;onTemperatureChange&lt;/code&gt; props from its parent &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="translated">React에서, 이것은 일반적으로 컴포넌트를 &quot;제어 된&quot;것으로 만들어서 해결됩니다. DOM &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 은 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;onChange&lt;/code&gt; 소품을 모두 허용하는 &lt;code&gt;onTemperatureChange&lt;/code&gt; 사용자 정의 &lt;code&gt;TemperatureInput&lt;/code&gt; 은 부모 &lt;code&gt;Calculator&lt;/code&gt; 의 &lt;code&gt;temperature&lt;/code&gt; 및 onTemperatureChange 소품을 모두 수용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87275e536b566529b077b0ff131cc019d2d910ed" translate="yes" xml:space="preserve">
          <source>In React, transforming arrays into lists of &lt;a href=&quot;rendering-elements&quot;&gt;elements&lt;/a&gt; is nearly identical.</source>
          <target state="translated">React에서 배열을 &lt;a href=&quot;rendering-elements&quot;&gt;요소&lt;/a&gt; 목록으로 변환하는 것은 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="28e0e1f0e9359d0e312a435e081792d0bfb666a7" translate="yes" xml:space="preserve">
          <source>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</source>
          <target state="translated">React에서는 필요한 동작을 캡슐화하는 고유 한 구성 요소를 만들 수 있습니다. 그런 다음 응용 프로그램의 상태에 따라 일부만 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18d05ee6185a8ba49d29302bd632b76aa474a54" translate="yes" xml:space="preserve">
          <source>In React, you most likely write your components in a &lt;code&gt;.js&lt;/code&gt; file. In TypeScript we have 2 file extensions:</source>
          <target state="translated">React에서는 대부분 &lt;code&gt;.js&lt;/code&gt; 파일로 컴포넌트를 작성합니다 . TypeScript에는 2 개의 파일 확장자가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9f15ab1b0e75d6b53c4958487bbf30fca20cdcdd" translate="yes" xml:space="preserve">
          <source>In a React class, you would typically set up a subscription in &lt;code&gt;componentDidMount&lt;/code&gt;, and clean it up in &lt;code&gt;componentWillUnmount&lt;/code&gt;. For example, let&amp;rsquo;s say we have a &lt;code&gt;ChatAPI&lt;/code&gt; module that lets us subscribe to a friend&amp;rsquo;s online status. Here&amp;rsquo;s how we might subscribe and display that status using a class:</source>
          <target state="translated">A는 클래스 반응, 당신은 일반적으로 가입 설정할 것 &lt;code&gt;componentDidMount&lt;/code&gt; 을 , 그리고 그것을 정리 &lt;code&gt;componentWillUnmount&lt;/code&gt; . 예를 들어, 친구의 온라인 상태를 구독 할 수 있는 &lt;code&gt;ChatAPI&lt;/code&gt; 모듈이 있다고 가정하겠습니다 . 클래스를 사용하여 해당 상태를 구독하고 표시하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae59876c3b29c0877309b94f02f1bd1dffc61a49" translate="yes" xml:space="preserve">
          <source>In a class component, we would need to add &lt;code&gt;componentDidUpdate&lt;/code&gt; to handle this case:</source>
          <target state="translated">클래스 컴포넌트 에서이 경우를 처리하기 위해 &lt;code&gt;componentDidUpdate&lt;/code&gt; 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92c2ff44f620f5f28854f62d80affff3a499ba93" translate="yes" xml:space="preserve">
          <source>In a class, we initialize the &lt;code&gt;count&lt;/code&gt; state to &lt;code&gt;0&lt;/code&gt; by setting &lt;code&gt;this.state&lt;/code&gt; to &lt;code&gt;{ count: 0 }&lt;/code&gt; in the constructor:</source>
          <target state="translated">클래스에서는 생성자에서 &lt;code&gt;this.state&lt;/code&gt; 를 &lt;code&gt;{ count: 0 }&lt;/code&gt; 으로 설정 하여 &lt;code&gt;count&lt;/code&gt; 상태를 &lt;code&gt;0&lt;/code&gt; 으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="0f976be121765c87a20b8cbb91d05fe0f6e68773" translate="yes" xml:space="preserve">
          <source>In a class, we need to call &lt;code&gt;this.setState()&lt;/code&gt; to update the &lt;code&gt;count&lt;/code&gt; state:</source>
          <target state="translated">클래스 에서 &lt;code&gt;count&lt;/code&gt; 상태 를 업데이트하려면 &lt;code&gt;this.setState()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42f4e9921f51af97e4b657670a6fd71ed33571b6" translate="yes" xml:space="preserve">
          <source>In a function component, we have no &lt;code&gt;this&lt;/code&gt;, so we can&amp;rsquo;t assign or read &lt;code&gt;this.state&lt;/code&gt;. Instead, we call the &lt;code&gt;useState&lt;/code&gt; Hook directly inside our component:</source>
          <target state="translated">함수 컴포넌트에는 &lt;code&gt;this&lt;/code&gt; 가 없으므로 &lt;code&gt;this.state&lt;/code&gt; 를 할당하거나 읽을 수 없습니다 . 대신 컴포넌트 내부 에서 &lt;code&gt;useState&lt;/code&gt; Hook를 직접 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f02a6361f2d8d56c63358f0ea5c054c54d590ac2" translate="yes" xml:space="preserve">
          <source>In a function, we already have &lt;code&gt;setCount&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; as variables so we don&amp;rsquo;t need &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">함수에서 이미 &lt;code&gt;setCount&lt;/code&gt; 와 변수를 &lt;code&gt;count&lt;/code&gt; 했으므로 &lt;code&gt;this&lt;/code&gt; 필요로하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8baa32bfe1b6970407832863578c772af74c5714" translate="yes" xml:space="preserve">
          <source>In a function, we can use &lt;code&gt;count&lt;/code&gt; directly:</source>
          <target state="translated">함수에서 &lt;code&gt;count&lt;/code&gt; 를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e453bfad87294cd830086d87833eed893f7ed85e" translate="yes" xml:space="preserve">
          <source>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</source>
          <target state="translated">일반적인 React 애플리케이션에서 데이터는 소품을 통해 하향식 (자식 부모에게) 전달되지만, 애플리케이션 내의 많은 컴포넌트에 필요한 특정 유형의 소품 (예 : 로케일 기본 설정, UI 테마)에는 번거로울 수 있습니다. 컨텍스트는 모든 레벨의 트리를 통해 prop을 명시 적으로 전달하지 않고도 컴포넌트간에 이와 같은 값을 공유 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b9e54856b0d6dda52097e2ff1d03dbed8218a984" translate="yes" xml:space="preserve">
          <source>In addition to making code reuse and code organization more difficult, we&amp;rsquo;ve found that classes can be a large barrier to learning React. You have to understand how &lt;code&gt;this&lt;/code&gt; works in JavaScript, which is very different from how it works in most languages. You have to remember to bind the event handlers. Without unstable &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;syntax proposals&lt;/a&gt;, the code is very verbose. People can understand props, state, and top-down data flow perfectly well but still struggle with classes. The distinction between function and class components in React and when to use each one leads to disagreements even between experienced React developers.</source>
          <target state="translated">코드 재사용 및 코드 구성을 더욱 어렵게 만드는 것 외에도 클래스는 React 학습에 큰 장애가 될 수 있습니다. JavaScript에서 작동 하는 방식을 이해해야합니다. &lt;code&gt;this&lt;/code&gt; 대부분의 언어에서 작동하는 방식과 매우 다릅니다. 이벤트 핸들러를 바인드해야합니다. 불안정한 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-class-properties/&quot;&gt;구문 제안이&lt;/a&gt; 없으면 코드가 매우 장황합니다. 사람들은 소품, 상태 및 하향식 데이터 흐름을 완벽하게 이해할 수 있지만 여전히 수업에 어려움을 겪고 있습니다. React에서 함수와 클래스 구성 요소의 구분과 각각의 사용시기는 숙련 된 React 개발자들 사이에서도 의견이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="289e0d186dd0eceb3a53aed219c7fedfcae512fa" translate="yes" xml:space="preserve">
          <source>In addition, consider that the design of Hooks is more efficient in a couple ways:</source>
          <target state="translated">또한 후크 디자인이 몇 가지 측면에서 더 효율적이라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="cf07c2cb1d9764411791f25d366167bf2c6a4a7d" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">DOM을 시뮬레이션 할 &lt;em&gt;수없는&lt;/em&gt; 환경 (예 : Node.js에서 React Native 컴포넌트 테스트)에서 &lt;a href=&quot;test-utils#simulate&quot;&gt;이벤트 시뮬레이션 헬퍼&lt;/a&gt; 를 사용하여 요소와의 상호 작용을 시뮬레이션 할 수 있습니다 . 또는 &lt;a href=&quot;https://testing-library.com/docs/native-testing-library&quot;&gt; &lt;code&gt;@testing-library/react-native&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;fireEvent&lt;/code&gt; 헬퍼를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f063e3769c1f0ad77a1abd50a358ab7846c95c3" translate="yes" xml:space="preserve">
          <source>In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/react-native-testing-library/intro&quot;&gt;&lt;code&gt;@testing-library/react-native&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">In an environment where you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; simulate a DOM (e.g. testing React Native components on Node.js), you could use &lt;a href=&quot;test-utils#simulate&quot;&gt;event simulation helpers&lt;/a&gt; to simulate interactions with elements. Alternately, you could use the &lt;code&gt;fireEvent&lt;/code&gt; helper from &lt;a href=&quot;https://testing-library.com/docs/react-native-testing-library/intro&quot;&gt; &lt;code&gt;@testing-library/react-native&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dd08e59d935cb13b1f6c01dc28056496f6a9bc4e" translate="yes" xml:space="preserve">
          <source>In applications with many components, it&amp;rsquo;s very important to free up resources taken by the components when they are destroyed.</source>
          <target state="translated">구성 요소가 많은 응용 프로그램에서는 구성 요소가 파괴 될 때 사용하는 리소스를 확보하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6b767eadf5b4139629873d3d67b44c49dd15f7ed" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;e&lt;/code&gt; argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with &lt;code&gt;bind&lt;/code&gt; any further arguments are automatically forwarded.</source>
          <target state="translated">두 경우 모두 React 이벤트를 나타내는 &lt;code&gt;e&lt;/code&gt; 인수는 ID 다음에 두 번째 인수로 전달됩니다. 화살표 함수를 사용하면 명시 적으로 전달해야하지만 &lt;code&gt;bind&lt;/code&gt; 하면 추가 인수가 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d1802f47fc0c94f1304e39a33f567229bc6a0fe9" translate="yes" xml:space="preserve">
          <source>In cases where you cannot define the prop statically (e.g. because you need to close over the component&amp;rsquo;s props and/or state) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; should extend &lt;code&gt;React.Component&lt;/code&gt; instead.</source>
          <target state="translated">소품을 정적으로 정의 할 수없는 경우 (예 : 컴포넌트의 소품 및 / 또는 상태를 닫아야 함) &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;React.Component&lt;/code&gt; 를 확장 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d09f5ea2f719cb84240d22955b912b59e89f6fc3" translate="yes" xml:space="preserve">
          <source>In contrast, this function is impure because it changes its own input:</source>
          <target state="translated">반대로이 함수는 자체 입력을 변경하기 때문에 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="ba9a0d3186492384944825ac9b7292279498c6fb" translate="yes" xml:space="preserve">
          <source>In depth: When and why are &lt;code&gt;setState()&lt;/code&gt; calls batched?</source>
          <target state="translated">깊이 : 언제 그리고 왜 &lt;code&gt;setState()&lt;/code&gt; 호출이 일괄 처리됩니까?</target>
        </trans-unit>
        <trans-unit id="e28fdfcba350e9460a5b11538d17a9495f7864ad" translate="yes" xml:space="preserve">
          <source>In depth: Why isn&amp;rsquo;t &lt;code&gt;this.state&lt;/code&gt; updated immediately?</source>
          <target state="translated">심도 : 왜 &lt;code&gt;this.state&lt;/code&gt; 가 즉시 업데이트 되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="c1b95b07888beb397c1c34cba846e81f89eafcbe" translate="yes" xml:space="preserve">
          <source>In either case, we &lt;strong&gt;don&amp;rsquo;t recommend this pattern&lt;/strong&gt; and only show it here for completeness. Instead, it is preferable to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;avoid passing callbacks deep down&lt;/a&gt;.</source>
          <target state="translated">두 경우 &lt;strong&gt;모두이 패턴을 권장하지 않으며&lt;/strong&gt; 완전성을 위해 여기에만 표시하십시오. 대신 &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;콜백을 깊이 전달하지 않는&lt;/a&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f9d91c5022448dc96b7db04173ff7b2483babe71" translate="yes" xml:space="preserve">
          <source>In fact, if we open the console, we&amp;rsquo;ll see a warning:</source>
          <target state="translated">실제로 콘솔을 열면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f345dbdd77bde7a2de6d314ebebbeb5d11132d71" translate="yes" xml:space="preserve">
          <source>In fact, this is exactly how React is used at Facebook. This lets us write applications in React piece by piece, and combine them with our existing server-generated templates and other client-side code.</source>
          <target state="translated">사실, 이것이 바로 Facebook에서 React가 사용되는 방식입니다. 이를 통해 React로 응용 프로그램을 작성하고 기존 서버 생성 템플릿 및 기타 클라이언트 측 코드와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffdfd80e389f7e74a49541704e05ae80cc6fc69b" translate="yes" xml:space="preserve">
          <source>In general, we &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; bump the major version number for changes to:</source>
          <target state="translated">일반적으로 다음과 같은 변경 사항에 대한 주요 버전 번호는 변경 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7e0726e767128fb2eb99272298da3fc6afa9f477" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend &lt;em&gt;not&lt;/em&gt; passing a value for a prop, because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="translated">In general, we don&amp;rsquo;t recommend &lt;em&gt;not&lt;/em&gt; passing a value for a prop, because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt; &lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt; . This behavior is just there so that it matches the behavior of HTML.</target>
        </trans-unit>
        <trans-unit id="ee266aeffd83dee46d08b5a2d9e5dd0db59bd0ba" translate="yes" xml:space="preserve">
          <source>In general, we don&amp;rsquo;t recommend using this because it can be confused with the &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 object shorthand&lt;/a&gt;&lt;code&gt;{foo}&lt;/code&gt; which is short for &lt;code&gt;{foo: foo}&lt;/code&gt; rather than &lt;code&gt;{foo: true}&lt;/code&gt;. This behavior is just there so that it matches the behavior of HTML.</source>
          <target state="translated">일반적으로, 이것은 &lt;code&gt;{foo: true}&lt;/code&gt; 보다 {foo : &lt;code&gt;{foo: foo}&lt;/code&gt; 짧은 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015&quot;&gt;ES6 객체 속기 &lt;/a&gt; &lt;code&gt;{foo}&lt;/code&gt; 와 혼동 될 수 있으므로 사용하지 않는 것이 좋습니다 . 이 동작은 HTML의 동작과 일치하도록 존재합니다.</target>
        </trans-unit>
        <trans-unit id="fb1a71609500b2f5f9daba332366828dbac63210" translate="yes" xml:space="preserve">
          <source>In large component trees, an alternative we recommend is to pass down a &lt;code&gt;dispatch&lt;/code&gt; function from &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt;&lt;/a&gt; via context:</source>
          <target state="translated">큰 컴포넌트 트리에서 권장되는 대안은 컨텍스트를 통해 &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;dispatch&lt;/code&gt; 함수를 전달하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ba93ca3416f3cbfccc68a69a219fb2048e2dc7a7" translate="yes" xml:space="preserve">
          <source>In many cases it&amp;rsquo;s not possible to break these components into smaller ones because the stateful logic is all over the place. It&amp;rsquo;s also difficult to test them. This is one of the reasons many people prefer to combine React with a separate state management library. However, that often introduces too much abstraction, requires you to jump between different files, and makes reusing components more difficult.</source>
          <target state="translated">대부분의 경우 상태 저장 논리가 모든 곳에 있기 때문에 이러한 구성 요소를 더 작은 구성 요소로 나눌 수 없습니다. 테스트하기도 어렵습니다. 이것이 많은 사람들이 React를 별도의 상태 관리 라이브러리와 결합하는 것을 선호하는 이유 중 하나입니다. 그러나 종종 추상화가 너무 많이 발생하고 다른 파일 간을 이동해야하며 구성 요소를 재사용하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="c3440d610e4a5c2ec2cdeed99640aaa90c65f21a" translate="yes" xml:space="preserve">
          <source>In more complex cases (such as if one state depends on another state), try moving the state update logic outside the effect with the &lt;a href=&quot;hooks-reference#usereducer&quot;&gt;&lt;code&gt;useReducer&lt;/code&gt; Hook&lt;/a&gt;. &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;This article&lt;/a&gt; offers an example of how you can do this. &lt;strong&gt;The identity of the &lt;code&gt;dispatch&lt;/code&gt; function from &lt;code&gt;useReducer&lt;/code&gt; is always stable&lt;/strong&gt; &amp;mdash; even if the reducer function is declared inside the component and reads its props.</source>
          <target state="translated">보다 복잡한 경우 (예 : 한 상태가 다른 상태에 의존하는 경우) &lt;a href=&quot;hooks-reference#usereducer&quot;&gt; &lt;code&gt;useReducer&lt;/code&gt; Hook를&lt;/a&gt; 사용하여 상태 업데이트 로직을 효과 밖으로 이동하십시오 . &lt;a href=&quot;https://adamrackis.dev/state-and-use-reducer/&quot;&gt;이 기사&lt;/a&gt; 에서는이를 수행하는 방법의 예를 제공합니다. &lt;strong&gt; &lt;code&gt;useReducer&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 의 &lt;code&gt;dispatch&lt;/code&gt; 함수 ID는&lt;/strong&gt; 리듀서 함수가 컴포넌트 내부에서 선언되고 해당 소품을 읽는 경우에도 &lt;strong&gt;항상 안정적&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ea3661ac2ed158cad82144227101fb280362b435" translate="yes" xml:space="preserve">
          <source>In most cases you should use controlled components.</source>
          <target state="translated">대부분의 경우 제어 된 구성 요소를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a7abdefe6c187e6dc04e0d7f5c214840047bcdd" translate="yes" xml:space="preserve">
          <source>In most cases, instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand, you can inherit from &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt;. It is equivalent to implementing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; with a shallow comparison of current and previous props and state.</source>
          <target state="translated">대부분의 경우, 대신 쓰는 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 손으로, 당신은에서 상속 할 수 있습니다 &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt; &lt;code&gt;React.PureComponent&lt;/code&gt; &lt;/a&gt; . 현재 및 이전 소품과 상태를 &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 비교하여 shouldComponentUpdate () 를 구현하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cbad587d21c37cda62d8252410ab69d53dfcaebf" translate="yes" xml:space="preserve">
          <source>In most cases, jsdom behaves like a regular browser would, but doesn&amp;rsquo;t have features like &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout and navigation&lt;/a&gt;. This is still useful for most web-based component tests, since it runs quicker than having to start up a browser for each test. It also runs in the same process as your tests, so you can write code to examine and assert on the rendered DOM.</source>
          <target state="translated">대부분의 경우 jsdom은 일반 브라우저처럼 작동하지만 &lt;a href=&quot;https://github.com/jsdom/jsdom#unimplemented-parts-of-the-web-platform&quot;&gt;layout 및 navigation과&lt;/a&gt; 같은 기능은 없습니다 . 각 테스트마다 브라우저를 시작하는 것보다 빠르게 실행되므로 대부분의 웹 기반 구성 요소 테스트에 여전히 유용합니다. 또한 테스트와 동일한 프로세스에서 실행되므로 렌더링 된 DOM을 검사하고 주장하는 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1911017bb2356e24f2e7725ec8dd38cb5980645a" translate="yes" xml:space="preserve">
          <source>In most cases, we recommend using &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled components&lt;/a&gt; to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;forms#controlled-components&quot;&gt;제어 된 구성 요소&lt;/a&gt; 를 사용하여 양식을 구현하는 것이 좋습니다 . 제어되는 구성 요소에서 양식 데이터는 React 구성 요소에 의해 처리됩니다. 대안은 양식 데이터가 DOM 자체에 의해 처리되는 제어되지 않는 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="6d3c1b36b4f10f7bf6d14d76f2b5886538fe9af9" translate="yes" xml:space="preserve">
          <source>In order to solve this issue, React supports a &lt;code&gt;key&lt;/code&gt; attribute. When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. For example, adding a &lt;code&gt;key&lt;/code&gt; to our inefficient example above can make the tree conversion efficient:</source>
          <target state="translated">이 문제를 해결하기 위해 React는 &lt;code&gt;key&lt;/code&gt; 속성을 지원 합니다. 자식에 키가 있으면 React는이 키를 사용하여 원래 트리의 자식을 후속 트리의 자식과 일치시킵니다. 예를 들어, 위의 비효율적 인 예제에 &lt;code&gt;key&lt;/code&gt; 를 추가 하면 트리 변환이 효율적으로 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6804b7a0eea45b9845222ba70ab59b4cf0b8e7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;connect&lt;/code&gt; is a higher-order function that returns a higher-order component!</source>
          <target state="translated">다시 말해, &lt;code&gt;connect&lt;/code&gt; 는 고차 컴포넌트를 리턴하는 고차 함수입니다!</target>
        </trans-unit>
        <trans-unit id="80f812104a6e940fb1554b3b0a149eca257b5c85" translate="yes" xml:space="preserve">
          <source>In our example, we already have two state variables. The input text is in &lt;code&gt;query&lt;/code&gt;, and we read the translation from &lt;code&gt;resource&lt;/code&gt;. We want changes to the &lt;code&gt;query&lt;/code&gt; state to happen immediately, but changes to the &lt;code&gt;resource&lt;/code&gt; (i.e. fetching a new translation) should trigger a transition.</source>
          <target state="translated">이 예에서는 이미 두 가지 상태 변수가 있습니다. 입력 텍스트가 &lt;code&gt;query&lt;/code&gt; &lt;code&gt;resource&lt;/code&gt; 에서 번역을 읽습니다 . &lt;code&gt;query&lt;/code&gt; 상태 에 대한 변경 이 즉시 발생하기를 &lt;code&gt;resource&lt;/code&gt; 하지만 리소스 에 대한 변경 (즉, 새 번역 반입)은 전환을 트리거해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e399b2e569c6a0bcf071e62ad256ed5a3d201d7" translate="yes" xml:space="preserve">
          <source>In our experience, code that uses idiomatic React patterns and doesn&amp;rsquo;t rely on external state management solutions is the easiest to get running in the Concurrent Mode. We will describe common problems we&amp;rsquo;ve seen and the solutions to them separately in the coming weeks.</source>
          <target state="translated">경험상 관용적 리 액트 패턴을 사용하고 외부 상태 관리 솔루션에 의존하지 않는 코드는 동시 모드에서 실행하는 것이 가장 쉽습니다. 우리는 우리가 본 일반적인 문제와 앞으로 몇 주 안에 따로 해결책을 설명 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a945c86c779350192d3215abb4afd0b7e2b4ebf" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</source>
          <target state="translated">경험상 UI를 시간이 지남에 따라 변경하는 방법이 아니라 주어진 순간을 어떻게보아야하는지 생각하면 모든 종류의 버그가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2c952c1cb63d7f6dce2e3deb06b435fa75cedd7a" translate="yes" xml:space="preserve">
          <source>In our experience, thinking about how the UI should look at any given moment, rather than how to change it over time, eliminates a whole class of bugs.</source>
          <target state="translated">In our experience, thinking about how the UI should look at any given moment, rather than how to change it over time, eliminates a whole class of bugs.</target>
        </trans-unit>
        <trans-unit id="33d3facfdb5b3a33c51c1e47e735a86dc335c375" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;this.props.children&lt;/code&gt; is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.</source>
          <target state="translated">특히 &lt;code&gt;this.props.children&lt;/code&gt; 은 특수 소품으로, 일반적으로 태그 자체가 아닌 JSX 표현식에서 하위 태그로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ff52786b96cb28b8516c4c77d035f3f94ffa6e3e" translate="yes" xml:space="preserve">
          <source>In particular, the rule enforces that:</source>
          <target state="translated">특히이 규칙은 다음을 시행합니다.</target>
        </trans-unit>
        <trans-unit id="0d696f2b7ef6c0b071645ffc121cc67457984603" translate="yes" xml:space="preserve">
          <source>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</source>
          <target state="translated">실제로 키를 찾는 것은 일반적으로 어렵지 않습니다. 표시하려는 요소에는 이미 고유 한 ID가있을 수 있으므로 데이터에서 키를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43f54f78b227de9a41edca0fcd34399cba7c611" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="translated">In practice, most React apps only call &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ade1231470ce955a57c66a5a4a65595e2c307122" translate="yes" xml:space="preserve">
          <source>In practice, most React apps only call &lt;code&gt;ReactDOM.render()&lt;/code&gt; once. In the next sections we will learn how such code gets encapsulated into &lt;a href=&quot;state-and-lifecycle&quot;&gt;stateful components&lt;/a&gt;.</source>
          <target state="translated">실제로 대부분의 React 앱은 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 한 번만 호출 합니다. 다음 섹션에서는 이러한 코드가 &lt;a href=&quot;state-and-lifecycle&quot;&gt;상태 저장 구성 요소&lt;/a&gt; 로 캡슐화되는 방법을 배웁니다 .</target>
        </trans-unit>
        <trans-unit id="909459ee6d5f8fcf3afdeb0255be50e086b6e528" translate="yes" xml:space="preserve">
          <source>In practice, these assumptions are valid for almost all practical use cases.</source>
          <target state="translated">실제로 이러한 가정은 거의 모든 실제 사용 사례에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3d0b8aeba59f064eef6dc0b26b57e2face696137" translate="yes" xml:space="preserve">
          <source>In practice, we expect that most apps using Legacy Mode today should be able to migrate at least to the Blocking Mode (if not Concurrent Mode). This fragmentation can be annoying for libraries that aim to support all Modes in the short term. However, gradually moving the ecosystem away from the Legacy Mode will also &lt;em&gt;solve&lt;/em&gt; problems that affect major libraries in the React ecosystem, such as &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;confusing Suspense behavior when reading layout&lt;/a&gt; and &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;lack of consistent batching guarantees&lt;/a&gt;. There&amp;rsquo;s a number of bugs that can&amp;rsquo;t be fixed in Legacy Mode without changing semantics, but don&amp;rsquo;t exist in Blocking and Concurrent Modes.</source>
          <target state="translated">실제로 레거시 모드를 사용하는 대부분의 앱은 적어도 동시 모드가 아닌 경우 차단 모드로 마이그레이션 할 수 있어야합니다. 이 단편화는 모든 모드를 단기간에 지원하려는 라이브러리에 성 가실 수 있습니다. 그러나 레거시 모드에서 에코 시스템을 점진적으로 이동 시키면 &lt;a href=&quot;https://github.com/facebook/react/issues/14536&quot;&gt;레이아웃을 읽을 때 혼란스러운 서스펜스 동작&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/facebook/react/issues/15080&quot;&gt;일관된 배치 보장이없는&lt;/a&gt; 등 React 에코 시스템의 주요 라이브러리에 영향을 미치는 문제 도 &lt;em&gt;해결 &lt;/em&gt;됩니다 . 시맨틱을 변경하지 않고 레거시 모드에서 수정할 수 없지만 차단 및 동시 모드에는 존재하지 않는 많은 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b279656dca3be237f10a8565147d5f390d7e94e" translate="yes" xml:space="preserve">
          <source>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return &lt;code&gt;null&lt;/code&gt; instead of its render output.</source>
          <target state="translated">드문 경우이지만 다른 구성 요소에 의해 렌더링되었지만 구성 요소 자체를 숨길 수 있습니다. 이렇게하려면 렌더링 출력 대신 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0a098d464d31796bcdd791f834a68bda2df286c2" translate="yes" xml:space="preserve">
          <source>In rare cases, you may be running a test on a component that uses multiple renderers. For example, you may be running snapshot tests on a component with &lt;code&gt;react-test-renderer&lt;/code&gt;, that internally uses &lt;code&gt;ReactDOM.render&lt;/code&gt; inside a child component to render some content. In this scenario, you can wrap updates with &lt;code&gt;act()&lt;/code&gt;s corresponding to their renderers.</source>
          <target state="translated">드문 경우이지만 여러 렌더러를 사용하는 구성 요소에서 테스트를 실행하고있을 수 있습니다. 예를 들어, &lt;code&gt;react-test-renderer&lt;/code&gt; 가 있는 구성 요소에 대해 스냅 샷 테스트를 실행하는 경우 , 내부적 으로 하위 구성 요소 내에서 &lt;code&gt;ReactDOM.render&lt;/code&gt; 를 사용 하여 일부 내용을 렌더링 할 수 있습니다. 이 시나리오에서는 렌더러에 해당하는 &lt;code&gt;act()&lt;/code&gt; 업데이트를 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04d050c85bc701c68bd6d50bf673ea61647fdec4" translate="yes" xml:space="preserve">
          <source>In rare cases, you might want to have access to a child&amp;rsquo;s DOM node from a parent component. This is generally not recommended because it breaks component encapsulation, but it can occasionally be useful for triggering focus or measuring the size or position of a child DOM node.</source>
          <target state="translated">드문 경우지만 부모 구성 요소에서 자식의 DOM 노드에 액세스하려고 할 수 있습니다. 이것은 일반적으로 구성 요소 캡슐화를 중단하기 때문에 권장되지 않지만 때때로 포커스를 트리거하거나 하위 DOM 노드의 크기 또는 위치를 측정하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6863ffdd3d1c41a019b99c0ce9ef587c06e42de" translate="yes" xml:space="preserve">
          <source>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</source>
          <target state="translated">일부 브라우저에서는 접근성 트리에서 각 요소의 접근성 정보를 쉽게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7f108e140b39155a7e18cc38167a7857627734" translate="yes" xml:space="preserve">
          <source>In some cases formatting a value for display might be an expensive operation. It&amp;rsquo;s also unnecessary unless a Hook is actually inspected.</source>
          <target state="translated">경우에 따라 표시 할 값을 형식화하는 데 비용이 많이들 수 있습니다. 후크가 실제로 검사되지 않는 한 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="abfe23fc439cd1390e394329a6ecb1eeec14f4b5" translate="yes" xml:space="preserve">
          <source>In some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with &lt;code&gt;prevProps&lt;/code&gt; or &lt;code&gt;prevState&lt;/code&gt; inside &lt;code&gt;componentDidUpdate&lt;/code&gt;:</source>
          <target state="translated">경우에 따라 렌더링 할 때마다 효과를 정리하거나 적용하면 성능 문제가 발생할 수 있습니다. 클래스의 구성 요소에서, 우리는에 여분의 비교를 작성하여이 문제를 해결할 수 &lt;code&gt;prevProps&lt;/code&gt; 또는 &lt;code&gt;prevState&lt;/code&gt; 내부 &lt;code&gt;componentDidUpdate&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="110ae94bd79008897c0972ade096014f8e0302a9" translate="yes" xml:space="preserve">
          <source>In some rare cases you might need to memoize a callback with &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; but the memoization doesn&amp;rsquo;t work very well because the inner function has to be re-created too often. If the function you&amp;rsquo;re memoizing is an event handler and isn&amp;rsquo;t used during rendering, you can use &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref as an instance variable&lt;/a&gt;, and save the last committed value into it manually:</source>
          <target state="translated">드문 경우 지만 &lt;a href=&quot;hooks-reference#usecallback&quot;&gt; &lt;code&gt;useCallback&lt;/code&gt; 을 사용&lt;/a&gt; 하여 콜백을 메모 해야 할 수도 있지만 내부 함수를 너무 자주 다시 작성해야하므로 메모가 제대로 작동하지 않습니다. 기억하고있는 함수가 이벤트 핸들러이고 렌더링 중에 사용되지 않는 경우 &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;ref를 인스턴스 변수로&lt;/a&gt; 사용 하고 마지막으로 커밋 된 값을 수동으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c1cdbd6853a083ca4623e0db98a09dc4da4738b" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;development&lt;/strong&gt; mode, you can visualize how components mount, update, and unmount, using the performance tools in supported browsers. For example:</source>
          <target state="translated">에서 &lt;strong&gt;개발&lt;/strong&gt; 모드, 당신은 지원되는 브라우저의 성능 도구를 사용하여, 구성 요소, 업데이트, 마운트하는 방법을 시각화 및 마운트 해제 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0b550316b6eedb96eacfc072502ecdd2917564a" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">React 렌더링 라이프 사이클 에서 양식 요소 의 &lt;code&gt;value&lt;/code&gt; 속성은 DOM의 값을 대체합니다. 제어되지 않은 구성 요소를 사용하면 종종 React가 초기 값을 지정하지만 후속 업데이트는 제어되지 않은 상태로 유지하려고합니다. 이 경우를 처리하기 위해 &lt;code&gt;value&lt;/code&gt; 대신 &lt;code&gt;defaultValue&lt;/code&gt; 속성을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d3c7fd4b516fb9bcad29f73328ec8f65a7430fc" translate="yes" xml:space="preserve">
          <source>In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt;. Changing the value of &lt;code&gt;defaultValue&lt;/code&gt; attribute after a component has mounted will not cause any update of the value in the DOM.</source>
          <target state="translated">In the React rendering lifecycle, the &lt;code&gt;value&lt;/code&gt; attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a &lt;code&gt;defaultValue&lt;/code&gt; attribute instead of &lt;code&gt;value&lt;/code&gt; . Changing the value of &lt;code&gt;defaultValue&lt;/code&gt; attribute after a component has mounted will not cause any update of the value in the DOM.</target>
        </trans-unit>
        <trans-unit id="903bb48f1156a6b0ac31b18a1cbe3d5dc1be1cc3" translate="yes" xml:space="preserve">
          <source>In the above component, we have &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;fruit&lt;/code&gt;, and &lt;code&gt;todos&lt;/code&gt; as local variables, and we can update them individually:</source>
          <target state="translated">위의 구성 요소에서 우리는 &lt;code&gt;age&lt;/code&gt; , &lt;code&gt;fruit&lt;/code&gt; , &lt;code&gt;todos&lt;/code&gt; 를 지역 변수로 가지고 있으며 개별적으로 업데이트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4d1e3bc1269742bd242168387646a23702e59a34" translate="yes" xml:space="preserve">
          <source>In the above example, React passes a &lt;code&gt;ref&lt;/code&gt; given to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; element as a second argument to the rendering function inside the &lt;code&gt;React.forwardRef&lt;/code&gt; call. This rendering function passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">위의 예에서, 반작용이 통과 &lt;code&gt;ref&lt;/code&gt; 주어진 &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; 내부 렌더링 함수 번째 인수로서 요소 &lt;code&gt;React.forwardRef&lt;/code&gt; 의 전화. 이 렌더링 함수는 &lt;code&gt;ref&lt;/code&gt; 를 &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; 요소에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ccb9604592cfa6b12895f257ac0c24ea334d72d8" translate="yes" xml:space="preserve">
          <source>In the above example, strict mode checks will &lt;em&gt;not&lt;/em&gt; be run against the &lt;code&gt;Header&lt;/code&gt; and &lt;code&gt;Footer&lt;/code&gt; components. However, &lt;code&gt;ComponentOne&lt;/code&gt; and &lt;code&gt;ComponentTwo&lt;/code&gt;, as well as all of their descendants, will have the checks.</source>
          <target state="translated">위의 예에서 엄격 모드 검사는 &lt;code&gt;Header&lt;/code&gt; 및 &lt;code&gt;Footer&lt;/code&gt; 구성 요소 에 대해 실행 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그러나 &lt;code&gt;ComponentOne&lt;/code&gt; 및 &lt;code&gt;ComponentTwo&lt;/code&gt; 와 모든 하위 항목이 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="161b69b6d458031682de9bd001c8a47eb9f053a9" translate="yes" xml:space="preserve">
          <source>In the above examples, it is important to read the &lt;code&gt;scrollHeight&lt;/code&gt; property in &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; because there may be delays between &amp;ldquo;render&amp;rdquo; phase lifecycles (like &lt;code&gt;render&lt;/code&gt;) and &amp;ldquo;commit&amp;rdquo; phase lifecycles (like &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;).</source>
          <target state="translated">위의 예제에서 &quot;렌더링&quot;단계 라이프 사이클 ( &lt;code&gt;render&lt;/code&gt; 과 같은 )과 &quot;커밋&quot;단계 라이프 사이클 (예 : &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; ) 사이에 지연이있을 수 있으므로 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 에서 &lt;code&gt;scrollHeight&lt;/code&gt; 속성 을 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1492c41f81989404e70e8f6aae15b755c6639ac" translate="yes" xml:space="preserve">
          <source>In the beginning, our stated goal was to remove the duplicated logic from the &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt; components. Both of them want to know whether a friend is online.</source>
          <target state="translated">처음에 우리의 목표는 &lt;code&gt;FriendStatus&lt;/code&gt; 및 &lt;code&gt;FriendListItem&lt;/code&gt; 컴포넌트 에서 복제 된 로직을 제거하는 것이 었습니다 . 두 사람 모두 친구가 온라인 상태인지 알고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="c894c3353cd13202ba9261426d4b8ea1935aef6a" translate="yes" xml:space="preserve">
          <source>In the cron job, update your React packages to the most recent React release in the Next channel, using &lt;code&gt;next&lt;/code&gt; tag on npm. Using the npm cli:</source>
          <target state="translated">크론 작업 에서 npm의 &lt;code&gt;next&lt;/code&gt; 태그를 사용하여 React 패키지를 다음 채널의 최신 React 릴리스로 업데이트하십시오 . npm cli 사용 :</target>
        </trans-unit>
        <trans-unit id="2fe2f07417c38339db698cf1646bb4c866463cd8" translate="yes" xml:space="preserve">
          <source>In the event of an error, you can render a fallback UI with &lt;code&gt;componentDidCatch()&lt;/code&gt; by calling &lt;code&gt;setState&lt;/code&gt;, but this will be deprecated in a future release. Use &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; to handle fallback rendering instead.</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;setState&lt;/code&gt; 를 호출 하여 &lt;code&gt;componentDidCatch()&lt;/code&gt; 를 사용하여 대체 UI를 렌더링 할 수 있지만 향후 릴리스에서는 더 이상 사용되지 않습니다. 대신 &lt;code&gt;static getDerivedStateFromError()&lt;/code&gt; 렌더링을 처리 하려면 정적 getDerivedStateFromError () 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="81bc674a950124866a089232847d2007a365dc48" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;Parent&lt;/code&gt; passes its ref callback as an &lt;code&gt;inputRef&lt;/code&gt; prop to the &lt;code&gt;CustomTextInput&lt;/code&gt;, and the &lt;code&gt;CustomTextInput&lt;/code&gt; passes the same function as a special &lt;code&gt;ref&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. As a result, &lt;code&gt;this.inputElement&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt; will be set to the DOM node corresponding to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element in the &lt;code&gt;CustomTextInput&lt;/code&gt;.</source>
          <target state="translated">위의 예에서, &lt;code&gt;Parent&lt;/code&gt; 가 AS의 REF 콜백 전달 &lt;code&gt;inputRef&lt;/code&gt; 을 받는 소품 &lt;code&gt;CustomTextInput&lt;/code&gt; 을 하고 &lt;code&gt;CustomTextInput&lt;/code&gt; 는 특별한 동일한 기능 통과 &lt;code&gt;ref&lt;/code&gt; 받는 속성 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; . 그 결과, &lt;code&gt;this.inputElement&lt;/code&gt; 의 &lt;code&gt;Parent&lt;/code&gt; 에 대응하는 DOM 노드로 설정한다 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 의 요소 &lt;code&gt;CustomTextInput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78bb563116bb5963983d968cb91e61df5f00f963" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;kind&lt;/code&gt; prop is safely consumed and &lt;em&gt;is not&lt;/em&gt; passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element in the DOM. All other props are passed via the &lt;code&gt;...other&lt;/code&gt; object making this component really flexible. You can see that it passes an &lt;code&gt;onClick&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt; props.</source>
          <target state="translated">위의 예에서 &lt;code&gt;kind&lt;/code&gt; prop은 안전하게 소비되며 DOM 의 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 요소로 전달 &lt;em&gt;되지 않습니다&lt;/em&gt; . 다른 모든 소품은 &lt;code&gt;...other&lt;/code&gt; 객체 를 통해 전달 되어이 구성 요소를 실제로 유연하게 만듭니다. &lt;code&gt;onClick&lt;/code&gt; 및 &lt;code&gt;children&lt;/code&gt; 소품을 전달하는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50c03112f0e316b498156bed257c2771954012e9" translate="yes" xml:space="preserve">
          <source>In the example above, we pass &lt;code&gt;[count]&lt;/code&gt; as the second argument. What does this mean? If the &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;5&lt;/code&gt;, and then our component re-renders with &lt;code&gt;count&lt;/code&gt; still equal to &lt;code&gt;5&lt;/code&gt;, React will compare &lt;code&gt;[5]&lt;/code&gt; from the previous render and &lt;code&gt;[5]&lt;/code&gt; from the next render. Because all items in the array are the same (&lt;code&gt;5 === 5&lt;/code&gt;), React would skip the effect. That&amp;rsquo;s our optimization.</source>
          <target state="translated">위의 예 에서 두 번째 인수로 &lt;code&gt;[count]&lt;/code&gt; 를 전달합니다. 이것은 무엇을 의미 하는가? 경우] &lt;code&gt;count&lt;/code&gt; 이다 &lt;code&gt;5&lt;/code&gt; 후 우리 성분과 재 - 렌더링 &lt;code&gt;count&lt;/code&gt; 여전히 동일한 &lt;code&gt;5&lt;/code&gt; 비교한다 반작용 &lt;code&gt;[5]&lt;/code&gt; 이전에서 렌더링 &lt;code&gt;[5]&lt;/code&gt; 다음 렌더링에서. 배열의 모든 항목이 동일하기 때문에 ( &lt;code&gt;5 === 5&lt;/code&gt; ) React는 효과를 건너 뜁니다. 이것이 우리의 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="b7c3d10a47d45d9cf31357af92cb4eff75e31bc3" translate="yes" xml:space="preserve">
          <source>In the example below, &lt;code&gt;FancyButton&lt;/code&gt; uses &lt;code&gt;React.forwardRef&lt;/code&gt; to obtain the &lt;code&gt;ref&lt;/code&gt; passed to it, and then forward it to the DOM &lt;code&gt;button&lt;/code&gt; that it renders:</source>
          <target state="translated">아래 예제에서 &lt;code&gt;FancyButton&lt;/code&gt; 은 &lt;code&gt;React.forwardRef&lt;/code&gt; 를 사용하여 전달 된 &lt;code&gt;ref&lt;/code&gt; 를 얻은 다음 렌더링 하는 DOM &lt;code&gt;button&lt;/code&gt; 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="da172bb676090bc853f066f60868863ede80ccc2" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; is rendered depending on the value of the prop called &lt;code&gt;warn&lt;/code&gt;. If the value of the prop is &lt;code&gt;false&lt;/code&gt;, then the component does not render:</source>
          <target state="translated">아래 예에서 &lt;code&gt;&amp;lt;WarningBanner /&amp;gt;&lt;/code&gt; 는 &lt;code&gt;warn&lt;/code&gt; 이라는 prop의 값에 따라 렌더링됩니다 . prop 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 구성 요소가 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c9b0d091cbcaeb26aef58746ea16d7326d16599" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;List&lt;/code&gt; component renders a Backbone collection, using the &lt;code&gt;Item&lt;/code&gt; component to render individual items.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;List&lt;/code&gt; 구성 요소는 &lt;code&gt;Item&lt;/code&gt; 구성 요소를 사용하여 개별 항목을 렌더링 하는 Backbone 컬렉션 을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="132775b1447feeefec74e2f18536a9d528215b18" translate="yes" xml:space="preserve">
          <source>In the example below, we declare a variable called &lt;code&gt;name&lt;/code&gt; and then use it inside JSX by wrapping it in curly braces:</source>
          <target state="translated">아래 예제에서는 &lt;code&gt;name&lt;/code&gt; 이라는 변수를 선언 한 다음 중괄호로 묶어 JSX 내에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d7dd67cb57a4dc9f027ea3f3b201e027d6f0cf20" translate="yes" xml:space="preserve">
          <source>In the example below, we embed the result of calling a JavaScript function, &lt;code&gt;formatName(user)&lt;/code&gt;, into an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">아래의 예에서는, 자바 스크립트 함수 호출의 결과를 포함 &lt;code&gt;formatName(user)&lt;/code&gt; 로, &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="e50a991765ef6cc4009766a397d70d227449d563" translate="yes" xml:space="preserve">
          <source>In the example below, we use it to conditionally render a small block of text.</source>
          <target state="translated">아래 예제에서는 작은 텍스트 블록을 조건부로 렌더링하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3bfcd8d3b96478cd697022392b9e4b2c38089ff" translate="yes" xml:space="preserve">
          <source>In the example below, we will create a &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;stateful component&lt;/a&gt; called &lt;code&gt;LoginControl&lt;/code&gt;.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;LoginControl&lt;/code&gt; 이라는 &lt;a href=&quot;state-and-lifecycle#adding-local-state-to-a-class&quot;&gt;상태 저장 구성 요소를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6b92032c1bbddab0648c95b3163a2986b7e77271" translate="yes" xml:space="preserve">
          <source>In the example below, we will make a copy of the model&amp;rsquo;s attributes to form the initial state. We subscribe to the &lt;code&gt;change&lt;/code&gt; event (and unsubscribe on unmounting), and when it happens, we update the state with the model&amp;rsquo;s current attributes. Finally, we make sure that if the &lt;code&gt;model&lt;/code&gt; prop itself changes, we don&amp;rsquo;t forget to unsubscribe from the old model, and subscribe to the new one.</source>
          <target state="translated">아래 예에서는 모델 속성의 복사본을 만들어 초기 상태를 만듭니다. &lt;code&gt;change&lt;/code&gt; 이벤트에 가입하고 마운트 해제시 구독을 취소하고 , 해당 이벤트가 발생하면 모델의 현재 속성으로 상태를 업데이트합니다. 마지막으로 &lt;code&gt;model&lt;/code&gt; 소품 자체가 변경되면 이전 모델을 구독 취소하고 새 모델을 구독하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="63df20cb3c0206857b6eb72aa649ffbe4eec47b7" translate="yes" xml:space="preserve">
          <source>In the examples above we declared a separate &lt;code&gt;listItems&lt;/code&gt; variable and included it in JSX:</source>
          <target state="translated">위의 예제에서 우리는 별도의 &lt;code&gt;listItems&lt;/code&gt; 변수를 선언하고 JSX에 포함 시켰습니다 :</target>
        </trans-unit>
        <trans-unit id="ee218035757e1dcb006cf4b284261900739df97e" translate="yes" xml:space="preserve">
          <source>In the examples above, we only relied on features that are natively supported by the browsers. This is why we used a JavaScript function call to tell React what to display:</source>
          <target state="translated">위의 예에서는 브라우저가 기본적으로 지원하는 기능에만 의존했습니다. 이것이 우리가 JavaScript 함수 호출을 사용하여 React에게 표시 할 내용을 알려주는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="d4709b211731b0d98acf24cd2d4b4c0e25f437be" translate="yes" xml:space="preserve">
          <source>In the future, the second argument might get added automatically by a build-time transformation.</source>
          <target state="translated">앞으로 두 번째 인수는 빌드 타임 변환에 의해 자동으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be1cdda076b922dcae71dadf71ff42ad65b19bd" translate="yes" xml:space="preserve">
          <source>In the long term, we intend Suspense to become the primary way to read asynchronous data from components &amp;mdash; no matter where that data is coming from.</source>
          <target state="translated">장기적으로, 우리는 Suspense가 데이터의 출처에 관계없이 구성 요소에서 비동기 데이터를 읽는 주요 방법이 되길 원합니다.</target>
        </trans-unit>
        <trans-unit id="067bfddcfac5a573b68db915d05c5417e983d5ef" translate="yes" xml:space="preserve">
          <source>In the past, JavaScript errors inside components used to corrupt React&amp;rsquo;s internal state and cause it to &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;emit&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;cryptic&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;errors&lt;/a&gt; on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</source>
          <target state="translated">과거에는 손상에 사용되는 구성 요소 내부 자바 스크립트 오류의 내부 상태 반응과 원인 &lt;a href=&quot;https://github.com/facebook/react/issues/4026&quot;&gt;방출 &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/6895&quot;&gt;비밀 &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/react/issues/8579&quot;&gt;오류&lt;/a&gt; 다음은 렌더링에. 이러한 오류는 항상 응용 프로그램 코드의 이전 오류로 인해 발생했지만 React는 구성 요소에서 오류를 정상적으로 처리 할 수있는 방법을 제공하지 않아 복구 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="1d1757c6b2b83b26c148e1fe2455fe52c634722f" translate="yes" xml:space="preserve">
          <source>In the previous Suspense example, we only had one &lt;code&gt;resource&lt;/code&gt;, so we held it in a top-level variable. Now that we have multiple resources, we moved it to the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt;&amp;rsquo;s component state:</source>
          <target state="translated">이전 서스펜스 예제에서는 &lt;code&gt;resource&lt;/code&gt; 가 하나뿐 이므로 최상위 변수에 유지했습니다. 이제 여러 리소스가 있으므로 &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; 의 구성 요소 상태 로 옮겼습니다 .</target>
        </trans-unit>
        <trans-unit id="fbb97b6fdd583b9cf2c6eeadfbb049b439293e48" translate="yes" xml:space="preserve">
          <source>In the previous approach, we fetched data before we called &lt;code&gt;setState&lt;/code&gt;:</source>
          <target state="translated">이전 방식에서는 &lt;code&gt;setState&lt;/code&gt; 를 호출하기 전에 데이터를 가져 왔습니다 .</target>
        </trans-unit>
        <trans-unit id="c0baea048f9023ac78378921b5cbb9d00932c292" translate="yes" xml:space="preserve">
          <source>In the typical React dataflow, &lt;a href=&quot;components-and-props&quot;&gt;props&lt;/a&gt; are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</source>
          <target state="translated">일반적인 React 데이터 흐름에서 &lt;a href=&quot;components-and-props&quot;&gt;소품&lt;/a&gt; 은 부모 구성 요소가 자식과 상호 작용하는 유일한 방법입니다. 자식을 수정하려면 새 소품으로 다시 렌더링하십시오. 그러나 일반적인 데이터 흐름 외부에서 자식을 반드시 수정해야하는 경우가 있습니다. 수정 될 자식은 React 컴포넌트의 인스턴스이거나 DOM 요소 일 수 있습니다. 이 두 경우 모두 React는 탈출 해치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a86357d07cf0dbd879f2bd26a66e1afff5014629" translate="yes" xml:space="preserve">
          <source>In this code, &lt;code&gt;shouldComponentUpdate&lt;/code&gt; is just checking if there is any change in &lt;code&gt;props.color&lt;/code&gt; or &lt;code&gt;state.count&lt;/code&gt;. If those values don&amp;rsquo;t change, the component doesn&amp;rsquo;t update. If your component got more complex, you could use a similar pattern of doing a &amp;ldquo;shallow comparison&amp;rdquo; between all the fields of &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from &lt;code&gt;React.PureComponent&lt;/code&gt;. So this code is a simpler way to achieve the same thing:</source>
          <target state="translated">이 코드에서 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 는 &lt;code&gt;props.color&lt;/code&gt; 또는 &lt;code&gt;state.count&lt;/code&gt; 에 변경 사항이 있는지 확인합니다 . 해당 값이 변경되지 않으면 구성 요소가 업데이트되지 않습니다. 컴포넌트가 복잡해지면, &lt;code&gt;props&lt;/code&gt; 와 &lt;code&gt;state&lt;/code&gt; 의 모든 필드 사이에서 &quot;shallow compare&quot;를하는 유사한 패턴을 사용 하여 컴포넌트를 업데이트해야하는지 여부를 결정할 수 있습니다. 이 패턴은 React가이 로직을 사용할 수있는 도우미를 제공 할만큼 충분히 일반적 입니다. &lt;code&gt;React.PureComponent&lt;/code&gt; 에서 상속하기 만하면 됩니다. 따라서이 코드는 동일한 것을 달성하는 더 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9baf7530f7f1f0cc2de7e8a95550b370cd39a79c" translate="yes" xml:space="preserve">
          <source>In this code, we&amp;rsquo;ve wrapped our data fetching with &lt;code&gt;startTransition&lt;/code&gt;. This allows us to start fetching the profile data right away, while deferring the render of the next profile page and its associated &lt;code&gt;Spinner&lt;/code&gt; for 2 seconds (the time shown in &lt;code&gt;timeoutMs&lt;/code&gt;).</source>
          <target state="translated">이 코드에서는 데이터 페칭을 &lt;code&gt;startTransition&lt;/code&gt; 으로 래핑했습니다 . 이를 통해 다음 프로파일 페이지와 관련 &lt;code&gt;Spinner&lt;/code&gt; 의 렌더링 을 2 초 동안 ( &lt;code&gt;timeoutMs&lt;/code&gt; 에 표시된 시간) 지연시키면서 프로파일 데이터를 즉시 페치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a37905846a8f4c106d186eeaf752c69ecc60a20e" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why higher-order components are useful, and how to write your own.</source>
          <target state="translated">이 문서에서는 고차 컴포넌트가 유용한 이유와 직접 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cbf9764d5b2c9095bb5b4589f2f63cafc22cfd01" translate="yes" xml:space="preserve">
          <source>In this document, we&amp;rsquo;ll discuss why render props are useful, and how to write your own.</source>
          <target state="translated">이 문서에서는 렌더링 소품이 유용한 이유와 직접 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="600a8bed687912f2e4672cb1492ee6559ff93168" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; waits for both requests but starts them in parallel:</source>
          <target state="translated">이 예에서 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 는 두 요청을 모두 기다리지 만 동시에 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d9098805d0375365763e9b4152ec3e31f62f1c1a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ProfileDetails&lt;/code&gt; is waiting for an asynchronous API call to fetch some data. While we wait for &lt;code&gt;ProfileDetails&lt;/code&gt; and &lt;code&gt;ProfilePhoto&lt;/code&gt;, we will show the &lt;code&gt;Loading...&lt;/code&gt; fallback instead. It is important to note that until all children inside &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; has loaded, we will continue to show the fallback.</source>
          <target state="translated">이 예제에서 &lt;code&gt;ProfileDetails&lt;/code&gt; 는 일부 데이터를 페치하기 위해 비동기 API 호출을 기다리고 있습니다. &lt;code&gt;ProfileDetails&lt;/code&gt; 및 &lt;code&gt;ProfilePhoto&lt;/code&gt; 를 기다리는 동안 대신 &lt;code&gt;Loading...&lt;/code&gt; fallback 이 표시 됩니다. &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 내부의 모든 자식 이로드 될 때까지 폴백을 계속 표시 한다는 점에 유의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="782491ad80c95f67dcb2debb7f87f060c15672be" translate="yes" xml:space="preserve">
          <source>In this example, &lt;strong&gt;every item in &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; has an artificial slowdown &amp;mdash; each of them blocks the thread for a few milliseconds&lt;/strong&gt;. We&amp;rsquo;d never do this in a real app, but this helps us simulate what can happen in a deep component tree with no single obvious place to optimize.</source>
          <target state="translated">이 예 &lt;strong&gt;에서 &lt;code&gt;&amp;lt;MySlowList&amp;gt;&lt;/code&gt; 의 모든 항목 에는 인위적인 속도 저하가 있습니다. 각 항목 은 스레드를 몇 밀리 초 동안 차단합니다&lt;/strong&gt; . 실제 앱에서는이 작업을 수행하지 않았지만,이를 통해 최적화 할 명확한 위치가없는 딥 컴포넌트 트리에서 발생할 수있는 작업을 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e713cd57d3c728babeb0c18ce780cd3201c1805" translate="yes" xml:space="preserve">
          <source>In this example, React would unsubscribe from our &lt;code&gt;ChatAPI&lt;/code&gt; when the component unmounts, as well as before re-running the effect due to a subsequent render. (If you want, there&amp;rsquo;s a way to &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;tell React to skip re-subscribing&lt;/a&gt; if the &lt;code&gt;props.friend.id&lt;/code&gt; we passed to &lt;code&gt;ChatAPI&lt;/code&gt; didn&amp;rsquo;t change.)</source>
          <target state="translated">이 예제에서 React는 컴포넌트가 마운트 해제 될 때와 후속 렌더링으로 인해 효과를 다시 실행하기 전에 &lt;code&gt;ChatAPI&lt;/code&gt; 에서 구독을 취소 합니다. (원하는 경우 &lt;code&gt;props.friend.id&lt;/code&gt; 전달한 &lt;code&gt;ChatAPI&lt;/code&gt; 가 변경되지 않은 경우 &lt;a href=&quot;hooks-effect#tip-optimizing-performance-by-skipping-effects&quot;&gt;React에 재가입을 건너 뛰&lt;/a&gt; 도록 지시 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="be0484ff678e7e7fe151098cbd0937ebbd00eb82" translate="yes" xml:space="preserve">
          <source>In this example, a parent component that renders &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; would be able to call &lt;code&gt;inputRef.current.focus()&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;&amp;lt;FancyInput ref={inputRef} /&amp;gt;&lt;/code&gt; 를 렌더링하는 상위 컴포넌트는 &lt;code&gt;inputRef.current.focus()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d4bb4e68cbd0c4ac7dd0c4d7a725bdc64841434" translate="yes" xml:space="preserve">
          <source>In this example, each time &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; renders, it generates a new function as the value of the &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop, thus negating the effect of &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; extending &lt;code&gt;React.PureComponent&lt;/code&gt; in the first place!</source>
          <target state="translated">이 예제에서는 &lt;code&gt;&amp;lt;MouseTracker&amp;gt;&lt;/code&gt; 가 렌더링 될 때마다 &lt;code&gt;&amp;lt;Mouse render&amp;gt;&lt;/code&gt; prop 의 값으로 새로운 함수를 생성 하므로 &lt;code&gt;React.PureComponent&lt;/code&gt; 를 확장 하는 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 의 효과 는 처음부터 무시 됩니다!</target>
        </trans-unit>
        <trans-unit id="1a67a59e557a8bb22da36c7b17ee44b1abf8d495" translate="yes" xml:space="preserve">
          <source>In this example, the callback ref will be called only when the component mounts and unmounts, since the rendered &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; component stays present throughout any rerenders. If you want to be notified any time a component resizes, you may want to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt;&lt;code&gt;ResizeObserver&lt;/code&gt;&lt;/a&gt; or a third-party Hook built on it.</source>
          <target state="translated">이 예제에서는 렌더링 된 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 구성 요소가 다시 렌더링 전체에 존재하기 때문에 구성 요소가 마운트 및 마운트 해제 될 때만 콜백 참조가 호출됩니다 . 구성 요소의 크기를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver&quot;&gt; &lt;code&gt;ResizeObserver&lt;/code&gt; &lt;/a&gt; 때마다 알림을 받으려면 ResizeObserver 또는 타사 후크 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e22a8550914f5fd593b0e5202ccbe094289cbe2b" translate="yes" xml:space="preserve">
          <source>In this example, we are using a class component, but the same functionality could also be applied to function components, or components created by &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-api#reactforwardref&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">In this example, we are using a class component, but the same functionality could also be applied to function components, or components created by &lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;react-api#reactforwardref&quot;&gt; &lt;code&gt;React.forwardRef&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e55f1824db5d408d73e18ba03a5505618f145cbb" translate="yes" xml:space="preserve">
          <source>In this example, we manually thread through a &lt;code&gt;color&lt;/code&gt; prop in order to style the &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;Message&lt;/code&gt; components appropriately. Using context, we can pass this through the tree automatically:</source>
          <target state="translated">이 예에서는 &lt;code&gt;Button&lt;/code&gt; 및 &lt;code&gt;Message&lt;/code&gt; 구성 요소의 스타일을 적절하게 지정 하기 위해 &lt;code&gt;color&lt;/code&gt; 소품을 수동으로 연결합니다 . 컨텍스트를 사용하여 트리를 통해 자동으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d3462a96fdf5b6668c86137312037ef5107ef1" translate="yes" xml:space="preserve">
          <source>In this example, we render a component and format the rendered HTML with the &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/a&gt; package, before saving it as an inline snapshot:</source>
          <target state="translated">이 예제에서는 인라인 스냅 샷으로 저장하기 전에 컴포넌트를 렌더링하고 렌더링 된 HTML을 &lt;a href=&quot;https://www.npmjs.com/package/pretty&quot;&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/a&gt; 패키지로 형식화합니다 .</target>
        </trans-unit>
        <trans-unit id="a2a678be6ef80893f4443dae3189e07dc9af8576" translate="yes" xml:space="preserve">
          <source>In this example, we start data fetching at the load &lt;em&gt;and&lt;/em&gt; every time you press &amp;ldquo;Refresh&amp;rdquo;. We put the result of calling &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; into state so that components below can start reading the new data from the request we just kicked off.</source>
          <target state="translated">이 예에서는로드시 &lt;em&gt;및&lt;/em&gt; &quot;새로 고침&quot;을 누를 때마다 데이터 가져 오기를 시작합니다 . 아래 컴포넌트가 방금 시작한 요청에서 새 데이터를 읽을 수 있도록 &lt;code&gt;fetchUserAndPosts()&lt;/code&gt; 호출 결과 를 상태로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="40e5ce9d2c277949ff6850c2e07a7ce4249ad65e" translate="yes" xml:space="preserve">
          <source>In this example, we started our journey on the &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 &lt;code&gt;&amp;lt;HomePage&amp;gt;&lt;/code&gt; 에서 여정을 시작했습니다 .</target>
        </trans-unit>
        <trans-unit id="be16ebf22fd30a0569861e07662b2e8b026b4f83" translate="yes" xml:space="preserve">
          <source>In this guide, we will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</source>
          <target state="translated">이 가이드에서는 React 앱의 구성 요소 인 요소 및 구성 요소를 살펴 봅니다. 일단 마스터하면 재사용 가능한 작은 조각으로 복잡한 앱을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d2198505214dcf8ceed2b4c9ee7adaedd5197b" translate="yes" xml:space="preserve">
          <source>In this scenario, you would use a framework like &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; or a library like &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; so you can navigate between multiple routes and assert on side effects not just in the browser, but potentially on the backend as well.</source>
          <target state="translated">이 시나리오에서는 &lt;a href=&quot;https://www.cypress.io/&quot;&gt;Cypress&lt;/a&gt; 와 같은 프레임 워크 또는 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt; 와 같은 라이브러리 를 사용하여 여러 경로를 탐색하고 브라우저뿐만 아니라 백엔드에서도 부작용을 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="012fec99829ecc46c7a061a559b55cea20db4530" translate="yes" xml:space="preserve">
          <source>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</source>
          <target state="translated">이 섹션에서는 React를 처음 접하는 개발자가 종종 상속을 받기 위해 도달하는 몇 가지 문제를 고려하고 컴포지션으로 해결할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2354bfe7189104f2d54a127296a8b8ac4cb54d00" translate="yes" xml:space="preserve">
          <source>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</source>
          <target state="translated">이 섹션에서는 주어진 온도에서 물이 끓는지를 계산하는 온도 계산기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="83d7bcb20d79f9f405dc2a045c7b8717d8f1c228" translate="yes" xml:space="preserve">
          <source>In this section, we will learn how to make the &lt;code&gt;Clock&lt;/code&gt; component truly reusable and encapsulated. It will set up its own timer and update itself every second.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Clock&lt;/code&gt; 구성 요소를 재사용하고 캡슐화 하는 방법을 배웁니다 . 자체 타이머를 설정하고 매초마다 자체 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ce38739a991553b55a16fa00b7561acd9e3c69cd" translate="yes" xml:space="preserve">
          <source>In this section, we will show how to add a React component to an existing HTML page. You can follow along with your own website, or create an empty HTML file to practice.</source>
          <target state="translated">이 섹션에서는 기존 HTML 페이지에 React 컴포넌트를 추가하는 방법을 보여줍니다. 자신의 웹 사이트를 따라 가거나 연습 할 빈 HTML 파일을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c457ca26e31df4ff72bf75e4781f7e68170aaedf" translate="yes" xml:space="preserve">
          <source>In those rare cases where you need to apply a HOC dynamically, you can also do it inside a component&amp;rsquo;s lifecycle methods or its constructor.</source>
          <target state="translated">드문 경우이지만 HOC를 동적으로 적용해야하는 경우 구성 요소의 수명주기 메소드 또는 생성자 내에서 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="translated">포함 된 구성 요소</target>
        </trans-unit>
        <trans-unit id="1042f8600a94d974b83e4d369aaa4b17edb453b8" translate="yes" xml:space="preserve">
          <source>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</source>
          <target state="translated">화면 판독기 소프트웨어에서이를 사용하여 올바른 음성 설정을 선택할 때 페이지 텍스트의 사용자 언어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49a578fd2622c2582fc0bfccfa222e7fbdccd773" translate="yes" xml:space="preserve">
          <source>Initializing &lt;a href=&quot;state-and-lifecycle&quot;&gt;local state&lt;/a&gt; by assigning an object to &lt;code&gt;this.state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.state&lt;/code&gt; 에 객체를 할당하여 &lt;a href=&quot;state-and-lifecycle&quot;&gt;로컬 상태&lt;/a&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="308f934b533308c752b10e77267068798d66f567" translate="yes" xml:space="preserve">
          <source>Inline If with Logical &amp;amp;&amp;amp; Operator</source>
          <target state="translated">논리 &amp;amp;&amp;amp; 연산자를 사용한 인라인 경우</target>
        </trans-unit>
        <trans-unit id="bb9001f5844d8678a32c2945ed8a6fb7c63e0e2f" translate="yes" xml:space="preserve">
          <source>Inline If-Else with Conditional Operator</source>
          <target state="translated">조건부 연산자가있는 인라인 If-Else</target>
        </trans-unit>
        <trans-unit id="66528a87a38e1e59da8d23434a47ffa479d5a4ba" translate="yes" xml:space="preserve">
          <source>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if &lt;code&gt;id&lt;/code&gt; is the row ID, either of the following would work:</source>
          <target state="translated">루프 내에서 추가 매개 변수를 이벤트 핸들러로 전달하는 것이 일반적입니다. 예를 들어 &lt;code&gt;id&lt;/code&gt; 가 행 ID 인 경우 다음 중 하나가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4304c63954bdc246b29ab78b7a7b6fb0356bca4f" translate="yes" xml:space="preserve">
          <source>Inside the listener, call &lt;code&gt;setState&lt;/code&gt; whenever the data source changes.</source>
          <target state="translated">리스너 내에서 데이터 소스가 변경 될 때마다 &lt;code&gt;setState&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="1da0532bc1d42056af8f38805b51309a604715c0" translate="yes" xml:space="preserve">
          <source>Inside these methods, the &lt;code&gt;Calculator&lt;/code&gt; component asks React to re-render itself by calling &lt;code&gt;this.setState()&lt;/code&gt; with the new input value and the current scale of the input we just edited.</source>
          <target state="translated">이러한 메서드 내에서 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소는 방금 편집 한 입력의 새 입력 값과 현재 배율로 &lt;code&gt;this.setState()&lt;/code&gt; 를 호출하여 React에 다시 렌더링하도록 요청 합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="68b9166fcdb7337cee3b47f14be3169cc82acd61" translate="yes" xml:space="preserve">
          <source>Instead of artificially separating &lt;em&gt;technologies&lt;/em&gt; by putting markup and logic in separate files, React &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;separates &lt;em&gt;concerns&lt;/em&gt;&lt;/a&gt; with loosely coupled units called &amp;ldquo;components&amp;rdquo; that contain both. We will come back to components in a &lt;a href=&quot;components-and-props&quot;&gt;further section&lt;/a&gt;, but if you&amp;rsquo;re not yet comfortable putting markup in JS, &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;this talk&lt;/a&gt; might convince you otherwise.</source>
          <target state="translated">React는 마크 업과 논리를 별도의 파일에 넣음으로써 &lt;em&gt;기술&lt;/em&gt; 을 인위적으로 분리하는 대신 , 둘 다를 포함하는 &quot;컴포넌트&quot;라고하는 느슨하게 결합 된 단위와 &lt;a href=&quot;https://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;&lt;em&gt;관련된 문제&lt;/em&gt;&lt;/a&gt; 를 분리&lt;em&gt;&lt;/em&gt; 합니다. &lt;a href=&quot;components-and-props&quot;&gt;추가 섹션&lt;/a&gt; 에서 컴포넌트로 돌아올 것이다 . 그러나 JS에 마크 업을 작성하는 데 익숙하지 않다면 &lt;a href=&quot;https://www.youtube.com/watch?v=x7cQ3mrcKaY&quot;&gt;이 대화에서&lt;/a&gt; 다른 방법으로 확신 할 수있다.</target>
        </trans-unit>
        <trans-unit id="d025bac2dca752df204440cbc1297998e47df835" translate="yes" xml:space="preserve">
          <source>Instead of calling real APIs in all your tests, you can mock requests with dummy data. Mocking data fetching with &amp;ldquo;fake&amp;rdquo; data prevents flaky tests due to an unavailable backend, and makes them run faster. Note: you may still want to run a subset of tests using an &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&amp;ldquo;end-to-end&amp;rdquo;&lt;/a&gt; framework that tells whether the whole app is working together.</source>
          <target state="translated">모든 테스트에서 실제 API를 호출하는 대신 더미 데이터로 요청을 조롱 할 수 있습니다. &quot;가짜&quot;데이터를 사용하여 데이터를 가져 오는 것은 백엔드를 사용할 수 없기 때문에 비정상적인 테스트를 방지하고 더 빠르게 실행할 수 있습니다. 참고 : 전체 앱이 함께 작동하는지 여부를 알려주 는 &lt;a href=&quot;testing-environments#end-to-end-tests-aka-e2e-tests&quot;&gt;&quot;end-to-end&quot;&lt;/a&gt; 프레임 워크를 사용하여 테스트 하위 집합을 계속 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df48b0f4d5bf5819b9914fd6531ebe1dc8a79973" translate="yes" xml:space="preserve">
          <source>Instead of doing &lt;code&gt;useTransition&lt;/code&gt; in every other component, we can build it into our design system.</source>
          <target state="translated">다른 모든 구성 요소에서 &lt;code&gt;useTransition&lt;/code&gt; 을 수행하는 대신 디자인 시스템에 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aded08fa023761e3f1e6e5311a0cc3ddf79baf0" translate="yes" xml:space="preserve">
          <source>Instead of mutation, HOCs should use composition, by wrapping the input component in a container component:</source>
          <target state="translated">HOC는 돌연변이 대신 입력 구성 요소를 컨테이너 구성 요소에 포장하여 구성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5cf9d7c83880386192ebfbb360c2c6812d8bcf20" translate="yes" xml:space="preserve">
          <source>Instead of passing a &lt;code&gt;ref&lt;/code&gt; attribute created by &lt;code&gt;createRef()&lt;/code&gt;, you pass a function. The function receives the React component instance or HTML DOM element as its argument, which can be stored and accessed elsewhere.</source>
          <target state="translated">&lt;code&gt;createRef()&lt;/code&gt; 의해 생성 된 &lt;code&gt;ref&lt;/code&gt; 속성 을 전달하는 대신 함수를 전달합니다. 이 함수는 React 컴포넌트 인스턴스 또는 HTML DOM 요소를 인수로 받아 다른 곳에 저장하고 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c04ebdd8624a1412a2c00e3ee3be737187bc902" translate="yes" xml:space="preserve">
          <source>Instead of showing a spinner, can we add a visual effect like &amp;ldquo;greying out&amp;rdquo; the current screen?</source>
          <target state="translated">스피너를 표시하는 대신 현재 화면을 &quot;회색 처리&quot;와 같은 시각적 효과를 추가 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="54c51eb3d5154be37011a4c79e90fdae3d688bfd" translate="yes" xml:space="preserve">
          <source>Instead, &lt;em&gt;pass the function itself&lt;/em&gt; (without parens):</source>
          <target state="translated">대신, &lt;em&gt;함수 자체&lt;/em&gt; 를 parens없이 &lt;em&gt;전달하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf33354387d8bc0b95b73e1b637b872d08038c4" translate="yes" xml:space="preserve">
          <source>Instead, apply HOCs outside the component definition so that the resulting component is created only once. Then, its identity will be consistent across renders. This is usually what you want, anyway.</source>
          <target state="translated">대신 결과 구성 요소가 한 번만 작성되도록 구성 요소 정의 외부에 HOC를 적용하십시오. 그런 다음 그 정체성은 여러 렌더링에서 일관됩니다. 어쨌든 이것은 일반적으로 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14487f72778797d41aa4fbaf38ed77b989f65799" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;setState()&lt;/code&gt;:</source>
          <target state="translated">대신 &lt;code&gt;setState()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="441f654229a4276797437835009f1f108efbc02d" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;useEffect&lt;/code&gt;. The function passed to &lt;code&gt;useEffect&lt;/code&gt; will run after the render is committed to the screen. Think of effects as an escape hatch from React&amp;rsquo;s purely functional world into the imperative world.</source>
          <target state="translated">대신 &lt;code&gt;useEffect&lt;/code&gt; 를 사용 하십시오 . 렌더링이 화면에 커밋 된 후 &lt;code&gt;useEffect&lt;/code&gt; 에 전달 된 함수 가 실행됩니다. 효과는 React의 순전히 기능적인 세계에서 명령적인 세계로의 탈출구라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="6e5c222edd3cc915db386166adcd08d3c4524ced" translate="yes" xml:space="preserve">
          <source>Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.</source>
          <target state="translated">대신, 우리는 부 버전의 새로운 기능을 출시합니다. 즉, 마이너 릴리스는 이름이 불명확하더라도 메이저보다 흥미롭고 매력적입니다.</target>
        </trans-unit>
        <trans-unit id="9cad89ab27a31a43bc8bcabb4f1530a63711b236" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;d like to share this logic between &lt;code&gt;FriendStatus&lt;/code&gt; and &lt;code&gt;FriendListItem&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;FriendStatus&lt;/code&gt; 와 &lt;code&gt;FriendListItem&lt;/code&gt; 간에이 논리를 공유하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="1bc56bd7b51ec191a2b44a72405da8bdc2c8e271" translate="yes" xml:space="preserve">
          <source>Instead, we&amp;rsquo;ll look at Suspense as a logical next step in a sequence of approaches:</source>
          <target state="translated">대신 Suspense를 일련의 접근 방식에서 논리적 다음 단계로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="56e78cabfede8d071dad68a99417a1db55165ae4" translate="yes" xml:space="preserve">
          <source>Integrating with DOM Manipulation Plugins</source>
          <target state="translated">DOM 조작 플러그인과 통합</target>
        </trans-unit>
        <trans-unit id="fabcdcb5781cef22218fde185dcc3275b3caf232" translate="yes" xml:space="preserve">
          <source>Integrating with Model Layers</source>
          <target state="translated">모델 레이어와 통합</target>
        </trans-unit>
        <trans-unit id="2abfc3b773acf5210e59c6612eeb838ec30c6daf" translate="yes" xml:space="preserve">
          <source>Integrating with Other Libraries</source>
          <target state="translated">다른 라이브러리와 통합</target>
        </trans-unit>
        <trans-unit id="323ce191323fe812d9b2285405712a7540e602ee" translate="yes" xml:space="preserve">
          <source>Integrating with Other View Libraries</source>
          <target state="translated">다른 View 라이브러리와 통합</target>
        </trans-unit>
        <trans-unit id="a7ead22e923dd75533f31fb755b0096e8335cf4b" translate="yes" xml:space="preserve">
          <source>Integrating with jQuery Chosen Plugin</source>
          <target state="translated">jQuery Chosen 플러그인과 통합</target>
        </trans-unit>
        <trans-unit id="31f07fcd6fa5d6cf3bce211abaa7f9938b9f8b59" translate="yes" xml:space="preserve">
          <source>Integrating with third-party DOM libraries.</source>
          <target state="translated">타사 DOM 라이브러리와 통합</target>
        </trans-unit>
        <trans-unit id="d188e3da39485e86c68a2e47954789d012f3e98a" translate="yes" xml:space="preserve">
          <source>Intentional Loading Sequences</source>
          <target state="translated">의도적 인 로딩 순서</target>
        </trans-unit>
        <trans-unit id="458622e11438e28a4579aeaa119e2f6a90af7730" translate="yes" xml:space="preserve">
          <source>Interactions can be used to identify the cause of an update, although the API for tracing them is still experimental.</source>
          <target state="translated">상호 작용을 사용하여 업데이트 원인을 식별 할 수 있지만,이를 추적하기위한 API는 아직 실험 단계입니다.</target>
        </trans-unit>
        <trans-unit id="6896564dcbd1c525b78f98182de42c4bb2b09515" translate="yes" xml:space="preserve">
          <source>Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.</source>
          <target state="translated">내부적으로 React는 몇 가지 영리한 기술을 사용하여 UI를 업데이트하는 데 필요한 많은 비용이 드는 DOM 작업을 최소화합니다. 많은 응용 프로그램의 경우 React를 사용하면 성능을 최적화하기 위해 많은 작업을 수행하지 않고도 빠른 사용자 인터페이스로 연결됩니다. 그럼에도 불구하고 React 응용 프로그램의 속도를 높일 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78abc071449ad0da13e4d5e5a3f22e08fc793563" translate="yes" xml:space="preserve">
          <source>Interruptible Prerendering</source>
          <target state="translated">인터럽트 가능한 프리 렌더링</target>
        </trans-unit>
        <trans-unit id="5bdb65efee969d707c5e1bc2b4a881568f89c4af" translate="yes" xml:space="preserve">
          <source>Interruptible Rendering</source>
          <target state="translated">인터럽트 가능한 렌더링</target>
        </trans-unit>
        <trans-unit id="fe91e5b2febdee26a910e78fb467ec00cef2cc7f" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode</source>
          <target state="translated">동시 모드 소개</target>
        </trans-unit>
        <trans-unit id="8d1fa1c8913451a1f429075bf69c1c706857274d" translate="yes" xml:space="preserve">
          <source>Introducing Concurrent Mode (Experimental)</source>
          <target state="translated">동시 모드 소개 (실험적)</target>
        </trans-unit>
        <trans-unit id="2c358e3ea80007355c4cebac6d98e29b8a15fd58" translate="yes" xml:space="preserve">
          <source>Introducing Error Boundaries</source>
          <target state="translated">오류 경계 소개</target>
        </trans-unit>
        <trans-unit id="6752670ac4fd3d43c072341f57aeec0c7e6fa7d6" translate="yes" xml:space="preserve">
          <source>Introducing Hooks</source>
          <target state="translated">후크 소개</target>
        </trans-unit>
        <trans-unit id="99fc0e820b4798682e759dbf88cc8628f74605fc" translate="yes" xml:space="preserve">
          <source>Introducing JSX</source>
          <target state="translated">JSX 소개</target>
        </trans-unit>
        <trans-unit id="f9c770701ef9646b1634d74252668c51159f3855" translate="yes" xml:space="preserve">
          <source>Invokes a function on every immediate child contained within &lt;code&gt;children&lt;/code&gt; with &lt;code&gt;this&lt;/code&gt; set to &lt;code&gt;thisArg&lt;/code&gt;. If &lt;code&gt;children&lt;/code&gt; is an array it will be traversed and the function will be called for each child in the array. If children is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, this method will return &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; rather than an array.</source>
          <target state="translated">함수 호출 모든 직계 자식에 포함 &lt;code&gt;children&lt;/code&gt; 과 함께 &lt;code&gt;this&lt;/code&gt; 로 설정 &lt;code&gt;thisArg&lt;/code&gt; . 경우 &lt;code&gt;children&lt;/code&gt; 이 통과 될 배열이며, 함수는 배열의 각 자녀를 위해 호출됩니다. children이 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 인 경우이 메서드는 배열이 아닌 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="19019a267c68ec0d9a87bbfe53368307773f4e69" translate="yes" xml:space="preserve">
          <source>Is it OK to use arrow functions in render methods?</source>
          <target state="translated">렌더링 메소드에서 화살표 기능을 사용해도 괜찮습니까?</target>
        </trans-unit>
        <trans-unit id="b94bd0fbbd4ff5757505741937dacab45d2007bf" translate="yes" xml:space="preserve">
          <source>Is it passed in from a parent via props? If so, it probably isn&amp;rsquo;t state.</source>
          <target state="translated">소품을 통해 부모로부터 전달됩니까? 그렇다면 아마도 상태가 아닐 것입니다.</target>
        </trans-unit>
        <trans-unit id="b12fb0c98d31f06f2e894073d26a29b446b6105a" translate="yes" xml:space="preserve">
          <source>Is it safe to omit functions from the list of dependencies?</source>
          <target state="translated">종속성 목록에서 함수를 생략해도 안전합니까?</target>
        </trans-unit>
        <trans-unit id="36e2fa776e8e49d37a8c66174c7a287fbd5c8891" translate="yes" xml:space="preserve">
          <source>Is the Shadow DOM the same as the Virtual DOM?</source>
          <target state="translated">Shadow DOM은 Virtual DOM과 동일합니까?</target>
        </trans-unit>
        <trans-unit id="118a7d245e14f3d46907f813b32d6d32103aa8e9" translate="yes" xml:space="preserve">
          <source>Is there a recommended way to structure React projects?</source>
          <target state="translated">React 프로젝트를 구성하는 권장 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="431584afff8cf3078b613772134b8cf66a20ffd7" translate="yes" xml:space="preserve">
          <source>Is there something like forceUpdate?</source>
          <target state="translated">forceUpdate와 같은 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c240e644bcf66edddc303b13a6145795d52277ac" translate="yes" xml:space="preserve">
          <source>Is there something like instance variables?</source>
          <target state="translated">인스턴스 변수와 같은 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="85ab7deeb83142d16bed5604f08f86936f301d70" translate="yes" xml:space="preserve">
          <source>Is this page useful?</source>
          <target state="translated">Is this page useful?</target>
        </trans-unit>
        <trans-unit id="615079284bccc262002fb9d64da4565ad0ff149a" translate="yes" xml:space="preserve">
          <source>It accepts &lt;code&gt;author&lt;/code&gt; (an object), &lt;code&gt;text&lt;/code&gt; (a string), and &lt;code&gt;date&lt;/code&gt; (a date) as props, and describes a comment on a social media website.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; (객체), &lt;code&gt;text&lt;/code&gt; (문자열) 및 &lt;code&gt;date&lt;/code&gt; (날짜)를 소품으로 받아들이고 소셜 미디어 웹 사이트에 대한 설명을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fe1bc6eb63b54ec080a5b630f4c12685f9a1f7ff" translate="yes" xml:space="preserve">
          <source>It all begins with running one command in your terminal.</source>
          <target state="translated">그것은 모두 터미널에서 하나의 명령을 실행하는 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="188127c3aef7bdf7fd35fe7c856bcfd34c54e44a" translate="yes" xml:space="preserve">
          <source>It calls &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">It calls &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt; callback.</target>
        </trans-unit>
        <trans-unit id="c3cb8127bb9bd6695f9f71a7f9270c5ec20060df" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;ReactDOM.render()&lt;/code&gt; every second from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;&lt;code&gt;setInterval()&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">그것은 호출 &lt;code&gt;ReactDOM.render()&lt;/code&gt; A로부터 매초 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt; &lt;code&gt;setInterval()&lt;/code&gt; &lt;/a&gt; 콜백을.</target>
        </trans-unit>
        <trans-unit id="2cef424d8853229927def0460dc79c6c0ba401d9" translate="yes" xml:space="preserve">
          <source>It can also be used for larger expressions although it is less obvious what&amp;rsquo;s going on:</source>
          <target state="translated">무슨 일이 일어나고 있는지 명확하지 않지만 더 큰 표현식에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbe1ab611653ca85961be292443488b8a02544f" translate="yes" xml:space="preserve">
          <source>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;calculate an entire accessible color palette with Colorable&lt;/a&gt;.</source>
          <target state="translated">웹 사이트의 모든 경우에 적합한 색상 조합을 수동으로 계산하는 것이 지루할 수 있으므로 대신 &lt;a href=&quot;https://jxnblk.com/colorable/&quot;&gt;Colorable을 사용하여 액세스 가능한 전체 색상 팔레트를 계산할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62fd02389ef9525bb5984bc2a6e5af4ca327920" translate="yes" xml:space="preserve">
          <source>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled components&lt;/a&gt;, an alternative technique for implementing input forms.</source>
          <target state="translated">데이터를 변경하고 모든 입력 상태를 React 구성 요소를 통해 파이프 할 수있는 모든 방법에 대해 이벤트 핸들러를 작성해야하므로 제어 된 구성 요소를 사용하는 것이 지루한 경우가 있습니다. 기존 코드베이스를 React로 변환하거나 React 응용 프로그램을 비 React 라이브러리와 통합 할 때 특히 성 가실 수 있습니다. 이러한 상황에서는 입력 양식을 구현하기위한 대체 기술인 &lt;a href=&quot;uncontrolled-components&quot;&gt;제어되지 않는 구성 요소&lt;/a&gt; 를 점검 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2005e7f27cdc72de843371aaff7b32477d8c91bf" translate="yes" xml:space="preserve">
          <source>It conceptually makes sense for the filter text and checked value to live in &lt;code&gt;FilterableProductTable&lt;/code&gt;</source>
          <target state="translated">필터 텍스트와 선택된 값이 &lt;code&gt;FilterableProductTable&lt;/code&gt; 에 있는 것이 개념적으로 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="688f0ab18438d6d367169c900008f7481be7690d" translate="yes" xml:space="preserve">
          <source>It displays &amp;ldquo;Hello, world&amp;rdquo; on the page.</source>
          <target state="translated">페이지에 &quot;Hello, world&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="52ab860d9c544904ffaab788e02b64e8286beee6" translate="yes" xml:space="preserve">
          <source>It displays a heading saying &amp;ldquo;Hello, world!&amp;rdquo; on the page.</source>
          <target state="translated">&amp;ldquo;Hello, world!&amp;rdquo;라는 제목이 표시됩니다. 페이지에.</target>
        </trans-unit>
        <trans-unit id="e82647fae753dc8b035e66a8857ffb17ac2da33f" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t suffer from this bug. (But we also didn&amp;rsquo;t make any changes to it.)</source>
          <target state="translated">이 버그로 고통받지 않습니다. (그러나 우리는 또한 변경하지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="602a6efa84948afcddd9d1b66dd5be71479d7a38" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;only&lt;/strong&gt; safe to omit a function from the dependency list if nothing in it (or the functions called by it) references props, state, or values derived from them. This example has a bug:</source>
          <target state="translated">인 &lt;strong&gt;만&lt;/strong&gt; 에 아무것도 그것 (또는 호출 함수) 참조 소품, 상태 값 또는 그들로부터 유래하지 않는 경우는 종속성리스트로부터 기능을 생략하는 금고. 이 예에는 버그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ead55f0f98915b5c6f13c05726f2286aab42a96" translate="yes" xml:space="preserve">
          <source>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.</source>
          <target state="translated">Hooks의 초기시기이며 일부 타사 라이브러리는 현재 Hooks와 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50466c950e08c88b69e598ab61d92c2dc031d70e" translate="yes" xml:space="preserve">
          <source>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</source>
          <target state="translated">JSX라고하며 JavaScript의 구문 확장입니다. UI의 모양을 설명하기 위해 React와 함께 사용하는 것이 좋습니다. JSX는 템플릿 언어를 생각 나게하지만 JavaScript의 모든 기능을 갖추고 있습니다.</target>
        </trans-unit>
        <trans-unit id="92466150db2416a73798d13e0245efd07871c27a" translate="yes" xml:space="preserve">
          <source>It is common for CSS classes to depend on the component props or state:</source>
          <target state="translated">CSS 클래스는 컴포넌트 props 또는 state에 의존하는 것이 일반적입니다 :</target>
        </trans-unit>
        <trans-unit id="7e283c36c21325ef64876afd9194c0a0cb70a383" translate="yes" xml:space="preserve">
          <source>It is documented in our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting guide&lt;/a&gt;. Note that &lt;code&gt;lazy&lt;/code&gt; components can be deep inside the &lt;code&gt;Suspense&lt;/code&gt; tree &amp;mdash; it doesn&amp;rsquo;t have to wrap every one of them. The best practice is to place &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; where you want to see a loading indicator, but to use &lt;code&gt;lazy()&lt;/code&gt; wherever you want to do code splitting.</source>
          <target state="translated">&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;코드 분할 안내서에&lt;/a&gt; 문서화되어 있습니다. 참고 것을 &lt;code&gt;lazy&lt;/code&gt; 구성 요소가 깊숙한 될 수 &lt;code&gt;Suspense&lt;/code&gt; 트리 - 그것은 그들 모두를 포장 할 필요가 없습니다. 가장 좋은 방법은 로드 표시기를보고 싶은 곳에 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 를 배치 하는 것이지만 코드 분할을 수행하려는 경우에는 &lt;code&gt;lazy()&lt;/code&gt; 를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9b84f156dc2b1e8053f6383bcb338d839775393" translate="yes" xml:space="preserve">
          <source>It is equivalent to this ES5 code:</source>
          <target state="translated">이 ES5 코드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e8b287ce575a54f80be869742a5c4a51c76fe13e" translate="yes" xml:space="preserve">
          <source>It is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.</source>
          <target state="translated">앱에서 작업 할 때는 개발 모드를 사용하고 앱을 사용자에게 배포 할 때는 프로덕션 모드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c952a73f20c5f13e3de4b9d7ef50fbb5a61fc052" translate="yes" xml:space="preserve">
          <source>It is important that we also call &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; in the &lt;code&gt;remove&lt;/code&gt; method so that React unregisters event handlers and other resources associated with the component tree when it is detached.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 메소드 에서 &lt;code&gt;ReactDOM.unmountComponentAtNode()&lt;/code&gt; 를 호출 하여 React가 분리 될 때 컴포넌트 트리와 연관된 이벤트 핸들러 및 기타 자원을 등록 취소하도록하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="32d368243a184c2b8d827bcbfe71e38225d8ed76" translate="yes" xml:space="preserve">
          <source>It is important to remember that the reconciliation algorithm is an implementation detail. React could rerender the whole app on every action; the end result would be the same. Just to be clear, rerender in this context means calling &lt;code&gt;render&lt;/code&gt; for all components, it doesn&amp;rsquo;t mean React will unmount and remount them. It will only apply the differences following the rules stated in the previous sections.</source>
          <target state="translated">조정 알고리즘은 구현 세부 사항임을 기억하는 것이 중요합니다. React는 모든 작업에서 전체 앱을 다시 렌더링 할 수 있습니다. 최종 결과는 동일합니다. 명확하게 말하면,이 맥락에서 다시 &lt;code&gt;render&lt;/code&gt; 한다는 것은 모든 구성 요소에 대해 렌더링 을 호출 한다는 것을 의미하지만 React가 마운트 해제했다가 다시 마운트한다는 의미는 아닙니다. 이전 섹션에서 언급 한 규칙에 따른 차이점 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="061882208caaee20f8d6caf81dd052b896705df2" translate="yes" xml:space="preserve">
          <source>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</source>
          <target state="translated">구성 요소 트리의 깊은 곳에 중첩 된 구성 요소에서 컨텍스트를 업데이트해야하는 경우가 종종 있습니다. 이 경우 컨텍스트를 통해 함수를 전달하여 소비자가 컨텍스트를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f2025036d719ebb13936746e156dcb2e46aebc" translate="yes" xml:space="preserve">
          <source>It is safe to embed user input in JSX:</source>
          <target state="translated">JSX에 사용자 입력을 포함시키는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aa4e4c8c699f839e3d4430e49f56a9d08895180e" translate="yes" xml:space="preserve">
          <source>It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:</source>
          <target state="translated">리듀서 외부의 초기 상태를 계산하기위한 로직을 추출 할 수 있습니다. 또한 작업에 대한 응답으로 나중에 상태를 재설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="534a38fabcd6aaf35f04bf09e44ca89301bf0ea1" translate="yes" xml:space="preserve">
          <source>It might feel redundant to pass down the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt; props through many levels if in the end only the &lt;code&gt;Avatar&lt;/code&gt; component really needs it. It&amp;rsquo;s also annoying that whenever the &lt;code&gt;Avatar&lt;/code&gt; component needs more props from the top, you have to add them at all the intermediate levels too.</source>
          <target state="translated">결국 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소 만 실제로 필요한 경우 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;avatarSize&lt;/code&gt; 소품을 여러 수준 으로 전달하는 것이 불필요한 느낌이들 수 있습니다 . 또한 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소가 맨 위에서 더 많은 소품을 필요로 할 때마다 모든 중간 레벨에서 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="50fb2495198065234962cb4b4d0c32c48a17f7f2" translate="yes" xml:space="preserve">
          <source>It returns an empty string on an invalid &lt;code&gt;temperature&lt;/code&gt;, and it keeps the output rounded to the third decimal place:</source>
          <target state="translated">유효하지 않은 &lt;code&gt;temperature&lt;/code&gt; 에서 빈 문자열을 반환 하고 출력을 소수점 셋째 자리로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="72f61e484682b21e93d363b30d4566ea24fa8ee5" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6&lt;/a&gt; on your machine. To create a project, run:</source>
          <target state="translated">It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6&lt;/a&gt; on your machine. To create a project, run:</target>
        </trans-unit>
        <trans-unit id="e9057e6a7d66d1d7c47dc528ed3b3b130a69063f" translate="yes" xml:space="preserve">
          <source>It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You&amp;rsquo;ll need to have Node &amp;gt;= 8.10 and npm &amp;gt;= 5.6 on your machine. To create a project, run:</source>
          <target state="translated">최신 JavaScript 기능을 사용할 수 있도록 개발 환경을 설정하고 멋진 개발자 경험을 제공하며 제작을 위해 앱을 최적화합니다. 머신에서 노드&amp;gt; = 8.10 및 npm&amp;gt; = 5.6이 있어야합니다. 프로젝트를 만들려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="706a32880b71586a8d7aa0ac7d5f1463de4cb7ba" translate="yes" xml:space="preserve">
          <source>It takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether our friend is online.</source>
          <target state="translated">그것은 소요 &lt;code&gt;friendID&lt;/code&gt; 를 인수로, 우리의 친구가 온라인 상태인지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3161055d73426680e8d35bc1e7cbbe8e4104358e" translate="yes" xml:space="preserve">
          <source>It took us only seven lines of code to add this transition:</source>
          <target state="translated">이 전환을 추가하는 데 7 줄의 코드 만 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="45e77ef569a1f7d7c48e0e05eba962af9f6767c1" translate="yes" xml:space="preserve">
          <source>It will render either &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; depending on its current state. It will also render a &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; from the previous example:</source>
          <target state="translated">현재 상태에 따라 &lt;code&gt;&amp;lt;LoginButton /&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;LogoutButton /&amp;gt;&lt;/code&gt; 을 렌더링합니다 . 또한 이전 예제에서 &lt;code&gt;&amp;lt;Greeting /&amp;gt;&lt;/code&gt; 을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="2155bb73f8bf6451916989b5cbacb97df229da2a" translate="yes" xml:space="preserve">
          <source>It will use &lt;code&gt;this.setState()&lt;/code&gt; to schedule updates to the component local state:</source>
          <target state="translated">&lt;code&gt;this.setState()&lt;/code&gt; 를 사용 하여 구성 요소 로컬 상태에 대한 업데이트를 예약합니다.</target>
        </trans-unit>
        <trans-unit id="d02413defbcafdd99d3c520fd9d4aa148536aaf1" translate="yes" xml:space="preserve">
          <source>It works because in JavaScript, &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;expression&lt;/code&gt;, and &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; always evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">자바 스크립트에서, 때문에 작동 &lt;code&gt;true &amp;amp;&amp;amp; expression&lt;/code&gt; 항상로 평가 &lt;code&gt;expression&lt;/code&gt; 하고, &lt;code&gt;false &amp;amp;&amp;amp; expression&lt;/code&gt; 항상 평가 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df1035dc615a18406c02f413ad0f4e40e484e2b1" translate="yes" xml:space="preserve">
          <source>It would catch both rendering errors &lt;em&gt;and&lt;/em&gt; errors from Suspense data fetching. We can have as many error boundaries as we like but it&amp;rsquo;s best to &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;be intentional&lt;/a&gt; about their placement.</source>
          <target state="translated">렌더링 오류 &lt;em&gt;와&lt;/em&gt; Suspense 데이터 가져 오기의 오류를 모두 포착합니다 . 우리는 원하는만큼 오류 경계를 가질 수 있지만 &lt;a href=&quot;https://aweary.dev/fault-tolerance-react/&quot;&gt;의도적으로&lt;/a&gt; 배치 하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d53bef197f2d6ecda97fc0ca21c3fffc1a9ab88e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a good idea to get to know React first, before adding in additional libraries. You can build quite complex applications using only React.</source>
          <target state="translated">라이브러리를 추가하기 전에 먼저 React를 알아야합니다. React 만 사용하여 매우 복잡한 애플리케이션을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1069cd6014468c5f2a1a444828d18bfcd86ae157" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a result of several years of research and development, but it&amp;rsquo;s not finished. In the section on &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;adopting Concurrent Mode&lt;/a&gt;, we&amp;rsquo;ll describe how you can try it and what you can expect.</source>
          <target state="translated">그것은 수년간의 연구 개발의 결과이지만 아직 끝나지 않았습니다. &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;동시 모드 채택&lt;/a&gt; 섹션에서 시도 방법과 기대할 수있는 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5b97c1e1db1289e7c4f51d01cbfaea288680830c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s difficult to remember which props or state are used by functions outside of the effect. This is why &lt;strong&gt;usually you&amp;rsquo;ll want to declare functions needed by an effect &lt;em&gt;inside&lt;/em&gt; of it.&lt;/strong&gt; Then it&amp;rsquo;s easy to see what values from the component scope that effect depends on:</source>
          <target state="translated">효과 이외의 함수가 어떤 소품이나 상태를 사용하는지 기억하기는 어렵습니다. 그렇기 때문에 &lt;strong&gt;보통&lt;em&gt;&lt;/em&gt;&lt;/strong&gt; 그 &lt;strong&gt;&lt;em&gt;안에&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 효과가 필요한 함수를 선언하려고 &lt;/strong&gt;&lt;strong&gt;합니다. &lt;/strong&gt;그런 다음 구성 요소 범위에서 어떤 값이 영향을 받는지 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12d523ee0a8b2e43fbd774373dabc117b68d15fc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s hard to reuse stateful logic between components</source>
          <target state="translated">구성 요소 간 상태 저장 논리를 재사용하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e11305e8e0d8ed22ffeb90393f322ef30d355dd4" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that just because the pattern is called &amp;ldquo;render props&amp;rdquo; you don&amp;rsquo;t &lt;em&gt;have to use a prop named &lt;code&gt;render&lt;/code&gt; to use this pattern&lt;/em&gt;. In fact, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;any&lt;/em&gt; prop that is a function that a component uses to know what to render is technically a &amp;ldquo;render prop&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">패턴을 &quot;렌더 소품&quot;이라고하더라도이 &lt;em&gt;패턴을 사용하기 위해 &lt;/em&gt;&lt;em&gt; &lt;code&gt;render&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 라는 소품을 사용할&lt;/em&gt; 필요는 없습니다 . 사실, &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&lt;em&gt;어떤&lt;/em&gt; 구성 요소가 사용하는 렌더링을 알고있는 기능입니다 소품은 &quot;소품 렌더링&quot;기술적으로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abbcf3e467e64993c40145b58380cca00dde2358" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a Hook because it doesn&amp;rsquo;t compose like Hooks do. &lt;code&gt;React.memo&lt;/code&gt; is equivalent to &lt;code&gt;PureComponent&lt;/code&gt;, but it only compares props. (You can also add a second argument to specify a custom comparison function that takes the old and new props. If it returns true, the update is skipped.)</source>
          <target state="translated">후크처럼 구성되지 않기 때문에 후크가 아닙니다. &lt;code&gt;React.memo&lt;/code&gt; 은 동일합니다 &lt;code&gt;PureComponent&lt;/code&gt; 하지만, 그것은 단지 소품을 비교합니다. (두 번째 인수를 추가하여 이전 및 새 소품을 가져 오는 사용자 정의 비교 함수를 지정할 수도 있습니다. true를 반환하면 업데이트를 건너 뜁니다.)</target>
        </trans-unit>
        <trans-unit id="218c8c3fba795922b2f79061baba6ea0eea01f6d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that a minor release will not include new features. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;This is allowed by semver&lt;/a&gt;, which states &lt;strong&gt;&amp;rdquo;[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.&amp;rdquo;&lt;/strong&gt;</source>
          <target state="translated">부 릴리스에는 새로운 기능이 포함되지 않을 수 있습니다. &lt;a href=&quot;https://semver.org/#spec-item-7&quot;&gt;이것은 semver&lt;/a&gt; 에 의해 허용되며 &lt;strong&gt;, 개인 코드 내에 실질적으로 새로운 기능이나 개선이 도입 된 경우 &quot;[부 버전]이 증가 될 수 있습니다. 패치 레벨 변경이 포함될 수 있습니다.&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ed922784aa3b9ce3ee3dfd000c51ce8f2ddc5c7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible that in the future React will provide a &lt;code&gt;usePrevious&lt;/code&gt; Hook out of the box since it&amp;rsquo;s a relatively common use case.</source>
          <target state="translated">그것은 미래에 제공 할 것 반작용 가능성이 있습니다 &lt;code&gt;usePrevious&lt;/code&gt; 이 상대적으로 일반적인 사용 사례이기 때문에 상자 밖으로 훅을.</target>
        </trans-unit>
        <trans-unit id="4411f615cb9a34eac0782d89d41554e9d48dcddd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s typically better to make more specific assertions than to use snapshots. These kinds of tests include implementation details so they break easily, and teams can get desensitized to snapshot breakages. Selectively &lt;a href=&quot;#mocking-modules&quot;&gt;mocking some child components&lt;/a&gt; can help reduce the size of snapshots and keep them readable for the code review.</source>
          <target state="translated">일반적으로 스냅 샷을 사용하는 것보다 더 구체적인 어설 션을 만드는 것이 좋습니다. 이러한 종류의 테스트에는 구현 세부 정보가 포함되어있어 쉽게 중단 할 수 있으며 팀은 스냅 샷 손상에 민감하지 않을 수 있습니다. &lt;a href=&quot;#mocking-modules&quot;&gt;일부 하위 구성 요소를&lt;/a&gt; 선택적으로 조롱 하면 스냅 샷 크기를 줄이고 코드 검토를 위해 읽을 수 있도록 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1abbf23e01de1391e6e121af6cd34d1a85aa0356" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite other components updating), we can do this with trees that take too long to render.</source>
          <target state="translated">It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite other components updating), we can do this with trees that take too long to render.</target>
        </trans-unit>
        <trans-unit id="483a41989a3f28face460eaf57d7dae044787b9f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;useDeferredValue&lt;/code&gt; is not &lt;em&gt;only&lt;/em&gt; useful for data fetching. It also helps when an expensive component tree causes an interaction (e.g. typing in an input) to be sluggish. Just like we can &amp;ldquo;defer&amp;rdquo; a value that takes too long to fetch (and show its old value despite others components updating), we can do this with trees that take too long to render.</source>
          <target state="translated">있다는 지적이의 가치 &lt;code&gt;useDeferredValue&lt;/code&gt; 이 없는 &lt;em&gt;경우에만&lt;/em&gt; 데이터를 가져 오는 데 유용합니다. 또한 값 비싼 컴포넌트 트리로 인해 상호 작용 (예 : 입력 입력)이 느려지는 경우 도움이됩니다. 가져 오는 데 너무 오래 걸리는 값을 &quot;지연&quot;할 수 있고 (다른 구성 요소 업데이트에도 불구하고 이전 값을 표시하는 것처럼) 렌더링하는 데 너무 오래 걸리는 트리를 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b65216aa0540eaf6506a4435bb83e1e7f8f013" translate="yes" xml:space="preserve">
          <source>JAWS in Internet Explorer</source>
          <target state="translated">Internet Explorer의 JAWS</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="1390ed0a23d1a0f6a989a72f7740422bce623820" translate="yes" xml:space="preserve">
          <source>JSX Children</source>
          <target state="translated">JSX 어린이</target>
        </trans-unit>
        <trans-unit id="5a08e455cb80c9325d21ca392ead0811d7f7928f" translate="yes" xml:space="preserve">
          <source>JSX In Depth</source>
          <target state="translated">깊이있는 JSX</target>
        </trans-unit>
        <trans-unit id="d79f80b3f74dfa812404ff28047b6abd93ce00a8" translate="yes" xml:space="preserve">
          <source>JSX Prevents Injection Attacks</source>
          <target state="translated">JSX는 주입 공격을 방지</target>
        </trans-unit>
        <trans-unit id="201092e5747855ff7f46489df7db6fec3735acac" translate="yes" xml:space="preserve">
          <source>JSX Represents Objects</source>
          <target state="translated">JSX는 객체를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="f821c0797aa66329cd5b6a52d7b985154fb5e626" translate="yes" xml:space="preserve">
          <source>JSX allows &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embedding any expression&lt;/a&gt; in curly braces so we could inline the &lt;code&gt;map()&lt;/code&gt; result:</source>
          <target state="translated">JSX는 중괄호 안에 &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;식&lt;/a&gt; 을 포함 시켜 &lt;code&gt;map()&lt;/code&gt; 결과를 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f572ba8add6be836659fce1a76a91186f8683f81" translate="yes" xml:space="preserve">
          <source>JSX is a syntax extension to JavaScript. It is similar to a template language, but it has full power of JavaScript. JSX gets compiled to &lt;code&gt;React.createElement()&lt;/code&gt; calls which return plain JavaScript objects called &amp;ldquo;React elements&amp;rdquo;. To get a basic introduction to JSX &lt;a href=&quot;introducing-jsx&quot;&gt;see the docs here&lt;/a&gt; and find a more in-depth tutorial on JSX &lt;a href=&quot;jsx-in-depth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">JSX는 JavaScript의 구문 확장입니다. 템플릿 언어와 비슷하지만 JavaScript의 모든 기능을 갖추고 있습니다. JSX는 &quot;React elements&quot;라는 일반 JavaScript 객체를 반환 하는 &lt;code&gt;React.createElement()&lt;/code&gt; 호출로 컴파일됩니다 . JSX에 대한 기본 소개를 얻으려면 &lt;a href=&quot;introducing-jsx&quot;&gt;여기에서 문서를 참조하고&lt;/a&gt; JSX에 대한 자세한 자습서를 찾으 &lt;a href=&quot;jsx-in-depth&quot;&gt;십시오&lt;/a&gt; . here .</target>
        </trans-unit>
        <trans-unit id="2a6badf2480a79666ab2a50ef49c41eec53e3e92" translate="yes" xml:space="preserve">
          <source>JSX is an Expression Too</source>
          <target state="translated">JSX는 너무 표현이다</target>
        </trans-unit>
        <trans-unit id="a7d41082c94e0ade95a8097ecf33e2cb44acdb09" translate="yes" xml:space="preserve">
          <source>JSX is not a requirement for using React. Using React without JSX is especially convenient when you don&amp;rsquo;t want to set up compilation in your build environment.</source>
          <target state="translated">JSX는 React를 사용하기위한 요구 사항이 아닙니다. JSX없이 React를 사용하면 빌드 환경에서 컴파일을 설정하지 않을 때 특히 편리합니다.</target>
        </trans-unit>
        <trans-unit id="dd38b28ee1a9a309326f94891c1df14009e831fa" translate="yes" xml:space="preserve">
          <source>JSX produces React &amp;ldquo;elements&amp;rdquo;. We will explore rendering them to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;. Below, you can find the basics of JSX necessary to get you started.</source>
          <target state="translated">JSX는 React&amp;ldquo;요소&amp;rdquo;를 생성합니다. &lt;a href=&quot;rendering-elements&quot;&gt;다음 섹션&lt;/a&gt; 에서 DOM으로 렌더링하는 방법을 살펴 보겠습니다 . 아래에서 시작하는 데 필요한 JSX의 기본 사항을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c0788f2156485e43ec1aec3f13813b6ce0ec76" translate="yes" xml:space="preserve">
          <source>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</source>
          <target state="translated">JSX는 줄의 시작과 끝에서 공백을 제거합니다. 또한 빈 줄을 제거합니다. 태그에 인접한 새 줄이 제거됩니다. 문자열 리터럴 중간에 발생하는 새로운 행은 단일 공간으로 압축됩니다. 따라서 이것들은 모두 같은 것으로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="e557a0ad7b8dd428002b075a12a339460bf81183" translate="yes" xml:space="preserve">
          <source>JSX tags may contain children:</source>
          <target state="translated">JSX 태그에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88547a44d266cdafe70fec17001f13058415c5b" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Requirements</source>
          <target state="translated">자바 스크립트 환경 요구 사항</target>
        </trans-unit>
        <trans-unit id="191332a52bb73fc079e6c2be8fbab52a7b9b0c79" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Children</source>
          <target state="translated">어린이로서의 JavaScript 표현</target>
        </trans-unit>
        <trans-unit id="f86b0b485fe227f9926cd86119e4d67d9db9cb41" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions as Props</source>
          <target state="translated">소품으로서의 JavaScript 표현</target>
        </trans-unit>
        <trans-unit id="8262e0b313f4b908f2bfa1fa8c04c78e05342554" translate="yes" xml:space="preserve">
          <source>JavaScript Resources</source>
          <target state="translated">자바 스크립트 리소스</target>
        </trans-unit>
        <trans-unit id="3ab669d11c2053c3096b0ce975c409719b9ab1f3" translate="yes" xml:space="preserve">
          <source>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</source>
          <target state="translated">JavaScript 표현식은 다른 유형의 하위와 혼합 될 수 있습니다. 이것은 종종 문자열 템플릿 대신 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fdc6b5ae1ed04a526c0403c39f6d892a4884f28f" translate="yes" xml:space="preserve">
          <source>Jest is widely compatible with React projects, supporting features like mocked &lt;a href=&quot;#mocking-modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;#mocking-timers&quot;&gt;timers&lt;/a&gt;, and &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt; support. &lt;strong&gt;If you use Create React App, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest is already included out of the box&lt;/a&gt; with useful defaults.&lt;/strong&gt;</source>
          <target state="translated">Jest는 React 프로젝트와 광범위하게 호환 되며 &lt;a href=&quot;#mocking-a-rendering-surface&quot;&gt; &lt;code&gt;jsdom&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#mocking-modules&quot;&gt; 모듈&lt;/a&gt; 및 &lt;a href=&quot;#mocking-timers&quot;&gt;타이머&lt;/a&gt; 및 jsdom 지원 과 같은 기능을 지원합니다. &lt;strong&gt;React 앱 생성을 사용하는 경우 &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/running-tests&quot;&gt;Jest는 이미&lt;/a&gt; 유용한 기본값으로 기본 제공됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains는 React 커뮤니티를 위해 특별히 다음과 같은 몇 가지 도구를 개발하고 유지 관리합니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React 바인딩&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;React Kotlin App 작성&lt;/a&gt; . 후자는 빌드 구성없이 Kotlin으로 React 앱을 빌드하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="26f4f29dc54a0429c9c6356ba883190a57985b95" translate="yes" xml:space="preserve">
          <source>Just because it&amp;rsquo;s possible, doesn&amp;rsquo;t mean that it&amp;rsquo;s the best approach for React apps. We encourage you to use React components when you can. React components are easier to reuse in React applications, and often provide more control over their behavior and appearance.</source>
          <target state="translated">가능하다고해서 이것이 React 앱에 가장 적합한 방법이라는 의미는 아닙니다. 가능하면 React 컴포넌트를 사용하는 것이 좋습니다. React 구성 요소는 React 응용 프로그램에서 재사용하기가 더 쉬우 며 종종 동작 및 모양을보다 잘 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c6c9a90cc15a2b6bbb52187ffa7d5c291abb80" translate="yes" xml:space="preserve">
          <source>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="translated">JavaScript와 마찬가지로, 귀하와 팀이 더 읽기 쉬운 것으로 간주하는 내용에 따라 적절한 스타일을 선택하는 것은 귀하의 몫입니다. 또한 조건이 너무 복잡해질 때마다 &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;구성 요소&lt;/a&gt; 를 추출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e19fb11d1b21bc4e9e11220a38333f6f51bc6998" translate="yes" xml:space="preserve">
          <source>Just like in a real browser, jsdom lets us model user interactions; tests can dispatch events on DOM nodes, and then observe and assert on the side effects of these actions &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="translated">실제 브라우저와 마찬가지로 jsdom을 사용하면 사용자 상호 작용을 모델링 할 수 있습니다. 테스트는 DOM 노드에서 이벤트를 전달한 다음 이러한 조치의 부작용을 관찰하고 주장 할 수 있습니다 &lt;a href=&quot;testing-recipes#events&quot;&gt;&lt;small&gt;(예)&lt;/small&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04a953b2cc6af815cf1d538af4ea7e0cdd73a8c9" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;useState&lt;/code&gt;, you can use more than a single effect in a component:</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; 와 마찬가지로 구성 요소에서 여러 효과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0417f986bcfb4e8e2b6c2b20736543a236a42518" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; is composable, like anything in React. For example, you can create a grid by putting several &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; rows inside a &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; table.</source>
          <target state="translated">명심 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; IS 작성 가능, 반작용의 어떤있다. 예를 들어 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 테이블 안에 여러 &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; 행 을 넣어 그리드를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07019d7742ef51cadec0c4168d9dbc4ff41a327c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;useRef&lt;/code&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; notify you when its content changes. Mutating the &lt;code&gt;.current&lt;/code&gt; property doesn&amp;rsquo;t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;callback ref&lt;/a&gt; instead.</source>
          <target state="translated">있다는 사실을 숙지 &lt;code&gt;useRef&lt;/code&gt; 이&lt;em&gt;되지 않는&lt;/em&gt; 경우 컨텐츠 변경을 통지합니다. 돌연변이 &lt;code&gt;.current&lt;/code&gt; 재산 것은 재 렌더링이 발생하지 않습니다. React가 DOM 노드에 참조를 첨부하거나 분리 할 때 일부 코드를 실행하려면 &lt;a href=&quot;hooks-faq#how-can-i-measure-a-dom-node&quot;&gt;콜백 참조를&lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fa659e6371af8e34371298a054c6fa0b8e3f4e6" translate="yes" xml:space="preserve">
          <source>Keep scrolling down, and you&amp;rsquo;ll find the link to the &lt;a href=&quot;introducing-jsx&quot;&gt;next chapter of this guide&lt;/a&gt; right before the website footer.</source>
          <target state="translated">아래로 스크롤 하면 웹 사이트 바닥 글 바로 앞에이 &lt;a href=&quot;introducing-jsx&quot;&gt;가이드&lt;/a&gt; 의 다음 장으로 연결되는 링크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a277208935542103e33cce1ec94231bfcbe2812" translate="yes" xml:space="preserve">
          <source>Keep using &lt;code&gt;createReactClass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;createReactClass&lt;/code&gt; 를 계속 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3961da9502b1e99387aff089f5c83ca94c5c588d" translate="yes" xml:space="preserve">
          <source>Keyboard Events</source>
          <target state="translated">키보드 이벤트</target>
        </trans-unit>
        <trans-unit id="a63562f9dc59d3d173ce1da297fea061eda935fe" translate="yes" xml:space="preserve">
          <source>Keyboard focus and focus outline</source>
          <target state="translated">키보드 포커스 및 포커스 개요</target>
        </trans-unit>
        <trans-unit id="71a38cea4a8ef2893215c7068a770d00cbeee9f2" translate="yes" xml:space="preserve">
          <source>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</source>
          <target state="translated">키보드 포커스는 키보드에서 입력을 받도록 선택된 DOM의 현재 요소를 나타냅니다. 우리는 어디에서나 다음 이미지에 표시된 것과 유사한 초점 개요로 본다.</target>
        </trans-unit>
        <trans-unit id="7ea41b7bfa6e4c0a74c593ca76797a28b26b665e" translate="yes" xml:space="preserve">
          <source>Keyed Fragments</source>
          <target state="translated">열쇠 조각</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="033fe9e03aa157b184cec9c5c36765ae681fc7ed" translate="yes" xml:space="preserve">
          <source>Keys Must Only Be Unique Among Siblings</source>
          <target state="translated">키는 형제 사이에서만 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="58d08b1dcb85c35147a1b3441c0c392efd3a8241" translate="yes" xml:space="preserve">
          <source>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</source>
          <target state="translated">키는 React가 어떤 항목이 변경, 추가 또는 제거되었는지 식별하는 데 도움이됩니다. 배열 내부의 요소에 키를 지정하여 요소를 안정적으로 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="c207367e515ac72a16c2932ecfa02b3376650bf0" translate="yes" xml:space="preserve">
          <source>Keys only make sense in the context of the surrounding array.</source>
          <target state="translated">키는 주변 배열의 상황에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b4e388c860748250255ac3aec6577a53bb08ca" translate="yes" xml:space="preserve">
          <source>Keys only need to be unique among sibling elements in the same array. They don&amp;rsquo;t need to be unique across the whole application or even a single component.</source>
          <target state="translated">키는 동일한 배열의 형제 요소 중에서 고유해야합니다. 전체 응용 프로그램 또는 단일 구성 요소에서 고유하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="f269f84d4b420a7eccc734c9f3e4bbe7ec1e654b" translate="yes" xml:space="preserve">
          <source>Keys serve as a hint to React but they don&amp;rsquo;t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</source>
          <target state="translated">키는 React에 대한 힌트로 사용되지만 구성 요소에는 전달되지 않습니다. 구성 요소에 동일한 값이 필요한 경우 다른 이름을 가진 소품으로 명시 적으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb803361f1db02c12313aa22ea43364fef308c9" translate="yes" xml:space="preserve">
          <source>Keys should be stable, predictable, and unique. Unstable keys (like those produced by &lt;code&gt;Math.random()&lt;/code&gt;) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</source>
          <target state="translated">키는 안정적이고 예측 가능하며 고유해야합니다. 불안정한 키 ( &lt;code&gt;Math.random()&lt;/code&gt; 의해 생성 된 것과 같은 키 )는 많은 구성 요소 인스턴스와 DOM 노드가 불필요하게 다시 만들어져 하위 구성 요소의 성능 저하 및 상태 손실을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d2b02a27e73ea54e2ad8018f1f566c76419e35" translate="yes" xml:space="preserve">
          <source>Keys used within arrays should be unique among their siblings. However they don&amp;rsquo;t need to be globally unique. We can use the same keys when we produce two different arrays:</source>
          <target state="translated">배열 내에서 사용되는 키는 형제 사이에서 고유해야합니다. 그러나 전 세계적으로 고유 할 필요는 없습니다. 두 개의 다른 배열을 생성 할 때 동일한 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b950ddccc3180b1568a4677560f1be2e72ae0d05" translate="yes" xml:space="preserve">
          <source>Knowledge Level Assumptions</source>
          <target state="translated">지식 수준 가정</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="087f43dec679500a381105d8177480d92e5bc6f7" translate="yes" xml:space="preserve">
          <source>Labeling</source>
          <target state="translated">Labeling</target>
        </trans-unit>
        <trans-unit id="86ade0000eab7713840cb80442178dbad165e1c7" translate="yes" xml:space="preserve">
          <source>Later, you write a component for subscribing to a single blog post, which follows a similar pattern:</source>
          <target state="translated">나중에 단일 블로그 게시물을 구독하기위한 구성 요소를 작성합니다. 다음과 유사한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="4e81f878f11e9186c40f41b370cbeff1223f6553" translate="yes" xml:space="preserve">
          <source>Latest Channel</source>
          <target state="translated">최신 채널</target>
        </trans-unit>
        <trans-unit id="801295034f8f587a8731684b0829ce3fafe33d56" translate="yes" xml:space="preserve">
          <source>Latest is the channel used for stable React releases. It corresponds to the &lt;code&gt;latest&lt;/code&gt; tag on npm. It is the recommended channel for all React apps that are shipped to real users.</source>
          <target state="translated">최신은 안정적인 React 릴리스에 사용되는 채널입니다. npm 의 &lt;code&gt;latest&lt;/code&gt; 태그에 해당합니다 . 실제 사용자에게 제공되는 모든 React 앱에 권장되는 채널입니다.</target>
        </trans-unit>
        <trans-unit id="09dea8b1934495cf50be92926eded5430df29f58" translate="yes" xml:space="preserve">
          <source>Lazy initial state</source>
          <target state="translated">게으른 초기 상태</target>
        </trans-unit>
        <trans-unit id="0aa93a4477a941d54e9e6489ff5a7fb43a5339e0" translate="yes" xml:space="preserve">
          <source>Lazy initialization</source>
          <target state="translated">지연 초기화</target>
        </trans-unit>
        <trans-unit id="e1c5a8ff2c0a4cee2266af52e69d8ea217bc6355" translate="yes" xml:space="preserve">
          <source>Learn Gatsby from &lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;its official guide&lt;/a&gt; and a &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;gallery of starter kits&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.gatsbyjs.org/docs/&quot;&gt;공식 안내서&lt;/a&gt; 와 &lt;a href=&quot;https://www.gatsbyjs.org/docs/gatsby-starters/&quot;&gt;스타터 키트 갤러리&lt;/a&gt; 에서 개츠비를 배우십시오 .</target>
        </trans-unit>
        <trans-unit id="378cbbf54cbb2e3f3bd201f02c1b946ec3601eba" translate="yes" xml:space="preserve">
          <source>Learn More</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="47738a476129c3a8cb6d980e52a9a75eb86f2183" translate="yes" xml:space="preserve">
          <source>Learn Next.js from &lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;its official guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://nextjs.org/learn/&quot;&gt;공식 가이드&lt;/a&gt; 에서 Next.js를 배우십시오 .</target>
        </trans-unit>
        <trans-unit id="802c853c766c4a1fb751dfe0a5007088efb8fff9" translate="yes" xml:space="preserve">
          <source>Learn React</source>
          <target state="translated">반응 배우기</target>
        </trans-unit>
        <trans-unit id="6c1aff18b114655a3728004f5ddf84acf496ed61" translate="yes" xml:space="preserve">
          <source>Learn more about it at &lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://fb.me/react-interaction-tracing&quot;&gt;fb.me/react-interaction-tracing&lt;/a&gt; 에서 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="74783fcd98611ef8c679d0b35c17456b50fdbdab" translate="yes" xml:space="preserve">
          <source>Learn more about setState</source>
          <target state="translated">setState에 대해 더 알아보기</target>
        </trans-unit>
        <trans-unit id="3d9e1ea32612926012e0f27c2e2d3bc9d3504c65" translate="yes" xml:space="preserve">
          <source>Learn more about the new &lt;code&gt;createRef&lt;/code&gt; API here.</source>
          <target state="translated">새로운 &lt;code&gt;createRef&lt;/code&gt; API 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="d12363dec3cec522658520bb14b574d2c38d4a9b" translate="yes" xml:space="preserve">
          <source>Legacy API</source>
          <target state="translated">레거시 API</target>
        </trans-unit>
        <trans-unit id="dde4f866b5827a3ecdb1b59f566920d28fc762d3" translate="yes" xml:space="preserve">
          <source>Legacy API: String Refs</source>
          <target state="translated">레거시 API : 문자열 참조</target>
        </trans-unit>
        <trans-unit id="e5b92b7804190333f8d5aa0581703f3b2664d74b" translate="yes" xml:space="preserve">
          <source>Legacy Context</source>
          <target state="translated">레거시 컨텍스트</target>
        </trans-unit>
        <trans-unit id="673ce3a3969d34565237049f3b8553b6bff614da" translate="yes" xml:space="preserve">
          <source>Legacy Lifecycle Methods</source>
          <target state="translated">레거시 라이프 사이클 방법</target>
        </trans-unit>
        <trans-unit id="0ebe4f64c19e892054a7737b95e642e4103d4505" translate="yes" xml:space="preserve">
          <source>Legacy Mode</source>
          <target state="translated">레거시 모드</target>
        </trans-unit>
        <trans-unit id="e41df52dcff2d5fb3f135df9c40c44c902c43f73" translate="yes" xml:space="preserve">
          <source>Lessons Learned</source>
          <target state="translated">교훈</target>
        </trans-unit>
        <trans-unit id="59538c378635dc8630feb1d884595472a4a714c5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s Get Started!</source>
          <target state="translated">시작하자!</target>
        </trans-unit>
        <trans-unit id="83ad68c13a4560eb3e6da14fe3991a29f25a12c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s assign a &lt;code&gt;key&lt;/code&gt; to our list items inside &lt;code&gt;numbers.map()&lt;/code&gt; and fix the missing key issue.</source>
          <target state="translated">&lt;code&gt;numbers.map()&lt;/code&gt; 내부의 목록 항목에 &lt;code&gt;key&lt;/code&gt; 를 할당 하고 누락 된 키 문제를 해결해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="62e35c44c6745b986cc311a397ff72118a2f50c3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s compare how different data fetching strategies deal with this requirement.</source>
          <target state="translated">서로 다른 데이터 페칭 전략이이 요구 사항을 처리하는 방식을 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="45e9d17f03076a3ad9477b82b07a51d4ce77f838" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get back to our &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;first Suspense demo&lt;/a&gt; where there was just one profile. Currently, it fetches the data only once. We&amp;rsquo;ll add a &amp;ldquo;Refresh&amp;rdquo; button to check for server updates.</source>
          <target state="translated">프로필이 하나만있는 &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;첫 번째 Suspense 데모&lt;/a&gt; 로 돌아가 봅시다 . 현재 데이터를 한 번만 가져옵니다. &quot;새로 고침&quot;버튼을 추가하여 서버 업데이트를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f2172c9119c229d11c473d5df9aa8d5d8d41b93a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go over these in detail.</source>
          <target state="translated">이것들에 대해 자세히 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="c35b4f5f51eb24f390b73104414deef66768949e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go through each one and figure out which one is state. Ask three questions about each piece of data:</source>
          <target state="translated">각각을 살펴보고 어느 것이 상태인지 알아 봅시다. 각 데이터에 대해 세 가지 질문을하십시오.</target>
        </trans-unit>
        <trans-unit id="efb2b5e509c3f39d850f9c0bc68afe5b00ce8cbb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now &lt;strong&gt;recap what we learned line by line&lt;/strong&gt; and check our understanding.</source>
          <target state="translated">이제 &lt;strong&gt;배운 내용을 한 줄씩&lt;/strong&gt; 살펴보고 이해를 확인해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="2db586e06ea830a0bf5bd7eba403ec7c7c1d5191" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s quickly recap what&amp;rsquo;s going on and the order in which the methods are called:</source>
          <target state="translated">진행 상황과 메소드 호출 순서를 신속하게 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b731235df3a08f9cefe099e4a2b6bfde68c1ff0c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap the two examples above and see how Concurrent Mode unifies them. &lt;strong&gt;In Concurrent Mode, React can work on several state updates &lt;em&gt;concurrently&lt;/em&gt;&lt;/strong&gt; &amp;mdash; just like branches let different team members work independently:</source>
          <target state="translated">위의 두 예제를 다시 살펴보고 Concurrent Mode가 어떻게 통합되는지 봅시다. &lt;strong&gt;동시 모드에서 React는 여러&lt;em&gt;&lt;/em&gt;&lt;/strong&gt; 팀 구성원이 독립적으로 작업 할 수 있도록 분기와 같이 &lt;strong&gt;여러 상태 업데이트를 &lt;/strong&gt;&lt;strong&gt;&lt;em&gt;동시에 수행&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; 할 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="27b3965c34758d4b1e54e8fcc6e8e8d971b07cb2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens in this example:</source>
          <target state="translated">이 예제에서 어떤 일이 발생하는지 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="87dc62cffe0ac1c4c5391c6f0828660b4dd4a79a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what happens when you edit an input:</source>
          <target state="translated">입력을 편집 할 때 발생하는 상황을 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3eca8e8ef68c829498c7d9e68354b1472e530462" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s revisit &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;this demo&lt;/a&gt; from the previous page about &lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;concurrent-mode-suspense&quot;&gt;Suspense for Data Fetching&lt;/a&gt; 에 대한 이전 페이지 &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;에서이 데모&lt;/a&gt; 를 다시 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="31e57dda434c35263f11856e0672be5db88ed7e8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite this example again, but using Suspense only:</source>
          <target state="translated">이 예제를 다시 작성하지만 Suspense 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e68a7b21d6c5f27413fdb9eda1dd97e5fd7b5762" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run through this strategy for our application:</source>
          <target state="translated">우리의 응용 프로그램에 대해이 전략을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="85ef0e00ecbe33d94c5d49e91e16ab5645be9c88" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that fetching the user details is very fast and only takes 300 milliseconds. Currently, we&amp;rsquo;re waiting a whole second because we need both user details and posts to display a consistent profile page. But what if we want to show the details faster?</source>
          <target state="translated">사용자 세부 정보를 가져 오는 것이 매우 빠르며 300 밀리 초 만 걸립니다. 현재 일관된 프로필 페이지를 표시하려면 사용자 세부 정보와 게시물이 모두 필요하기 때문에 1 초 동안 기다립니다. 그러나 세부 정보를 더 빨리 표시하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4991d5eafd8e8e062c0f087c85c40c1ea2d4cc4e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that this is the API we&amp;rsquo;re striving for with our &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; wrapper React component:</source>
          <target state="translated">이것이 &lt;code&gt;&amp;lt;Chosen&amp;gt;&lt;/code&gt; 래퍼 React 컴포넌트로 우리가 노력하고있는 API라고 가정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="2036fedebbcaf2b79f375bedb67a4420e6a7e60a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say there is a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; somewhere in your HTML file:</source>
          <target state="translated">HTML 파일 어딘가에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="e0dc0ebd0f6824d83a50f1aeaa18d1eaaf7cabfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works step by step.</source>
          <target state="translated">이것이 어떻게 작동하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="65e8fb3a23f53b18cf26df347e321256ab7c212c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we could write this component with Hooks.</source>
          <target state="translated">Hooks로이 컴포넌트를 작성하는 방법을 보자.</target>
        </trans-unit>
        <trans-unit id="af6fa6b57cf391318ac0bf024b8e3823314cbcfa" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see why this matters.</source>
          <target state="translated">왜 이것이 중요한지 봅시다.</target>
        </trans-unit>
        <trans-unit id="b577a0e161bcf81a4e96e3f3a99c76d5a54c4977" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a closer look at each of the props:</source>
          <target state="translated">각 소품을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a23b9ea82a3fd528716ce8cd73af2430db7a55e4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take another look at all the changes we&amp;rsquo;ve made since the &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;original example&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;원래 예제&lt;/a&gt; 이후에 우리가 변경 한 모든 내용을 다시 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5910b527fe0e81b1ac837051111d1cfb45c48766" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, &lt;code&gt;FilterableProductTable&lt;/code&gt; will pass callbacks to &lt;code&gt;SearchBar&lt;/code&gt; that will fire whenever the state should be updated. We can use the &lt;code&gt;onChange&lt;/code&gt; event on the inputs to be notified of it. The callbacks passed by &lt;code&gt;FilterableProductTable&lt;/code&gt; will call &lt;code&gt;setState()&lt;/code&gt;, and the app will be updated.</source>
          <target state="translated">우리가 원하는 것을 생각합시다. 사용자가 양식을 변경할 때마다 사용자 입력을 반영하기 위해 상태를 업데이트하고 싶습니다. 구성 요소는 자신의 상태를 업데이트해야하기 때문에, &lt;code&gt;FilterableProductTable&lt;/code&gt; 은 에 콜백을 전달합니다 &lt;code&gt;SearchBar&lt;/code&gt; 에 상태를 업데이트해야 할 때마다 실행됩니다. 입력에 &lt;code&gt;onChange&lt;/code&gt; 이벤트를 사용하여 이를 알릴 수 있습니다. &lt;code&gt;FilterableProductTable&lt;/code&gt; 이 전달한 콜백은 &lt;code&gt;setState()&lt;/code&gt; 를 호출 하고 앱이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1e893f82b5ddbd897be82bf493ce9e81174e5eb4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try that:</source>
          <target state="translated">시도해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b5f77d8b5f6dfc038e27b746c7a414fe97a3630d" translate="yes" xml:space="preserve">
          <source>Libraries can prevent waterfalls by offering a more centralized way to do data fetching. For example, Relay solves this problem by moving the information about the data a component needs to statically analyzable &lt;em&gt;fragments&lt;/em&gt;, which later get composed into a single query.</source>
          <target state="translated">라이브러리는 데이터 가져 오기를 수행하는 중앙 집중식 방법을 제공하여 폭포를 방지 할 수 있습니다. 예를 들어, Relay는 구성 요소가 정적으로 분석 가능한 &lt;em&gt;프래그먼트로&lt;/em&gt; 필요한 데이터에 대한 정보를 이동하여 나중에이 문제를 단일 쿼리로 구성 함으로써이 문제를 해결 합니다.</target>
        </trans-unit>
        <trans-unit id="46000d17b247964f6470d045921aa1d6334b0a4b" translate="yes" xml:space="preserve">
          <source>Libraries like &lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; work well in real browser environments, and could help for tests that explicitly need it.</source>
          <target state="translated">&lt;a href=&quot;https://mochajs.org/#running-mocha-in-the-browser&quot;&gt;mocha&lt;/a&gt; 와 같은 라이브러리 는 실제 브라우저 환경에서 잘 작동하며 명시 적으로 필요로하는 테스트에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041313632fc218e701e7df8b55493ecd8a5123e5" translate="yes" xml:space="preserve">
          <source>Libraries that use render props include &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; and &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik&lt;/a&gt;.</source>
          <target state="translated">렌더 소품을 사용하는 라이브러리에는 &lt;a href=&quot;https://reacttraining.com/react-router/web/api/Route/render-func&quot;&gt;React Router&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/downshift&quot;&gt;Downshift&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/jaredpalmer/formik&quot;&gt;Formik가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="40721cc170a6bfccd149edbfe1dc276de96ccd33" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution 4.0 International Public License.</source>
          <target state="translated">Creative Commons Attribution 4.0 International Public License에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="17ff789df886ac8c1ebe62bba2f20adc6571666a" translate="yes" xml:space="preserve">
          <source>Lifecycle Methods</source>
          <target state="translated">수명주기 방법</target>
        </trans-unit>
        <trans-unit id="17ec3a03bfeda0f665ab03b38f3ed1016d195b0e" translate="yes" xml:space="preserve">
          <source>Lifecycle methods are custom functionality that gets executed during the different phases of a component. There are methods available when the component gets created and inserted into the DOM (&lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt;), when the component updates, and when the component gets unmounted or removed from the DOM.</source>
          <target state="translated">수명주기 방법은 구성 요소의 여러 단계에서 실행되는 사용자 지정 기능입니다. 구성 요소가 작성되어 DOM에 삽입 될 때 ( &lt;a href=&quot;react-component#mounting&quot;&gt;mounting&lt;/a&gt; ), 구성 요소가 업데이트 될 때, 구성 요소가 DOM에서 마운트 해제되거나 제거 될 때 사용 가능한 메소드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe2783625398c73ad59607a3ac0e2c10a16bd848" translate="yes" xml:space="preserve">
          <source>Lifting State Up</source>
          <target state="translated">리프팅 상태</target>
        </trans-unit>
        <trans-unit id="60f96af2feedeafd8240d4e2179b169296b1ab38" translate="yes" xml:space="preserve">
          <source>Lifting state involves writing more &amp;ldquo;boilerplate&amp;rdquo; code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state &amp;ldquo;lives&amp;rdquo; in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</source>
          <target state="translated">리프팅 상태에는 양방향 바인딩 방식보다 더 많은 &quot;보일러 플레이트&quot;코드를 작성하는 것이 포함되지만, 이점으로 버그를 찾아 격리하는 데 드는 작업이 줄어 듭니다. 어떤 구성 요소에서 어떤 상태가&amp;ldquo;살아남&amp;rdquo;고 그 구성 요소만으로도 변경 될 수 있기 때문에 버그의 표면적이 크게 줄어 듭니다. 또한 사용자 정의 논리를 구현하여 사용자 입력을 거부하거나 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6205c7daf26478bf62962f9d33d7bc15dfc34968" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#reactchildrenmap&quot;&gt;&lt;code&gt;React.Children.map()&lt;/code&gt;&lt;/a&gt; but does not return an array.</source>
          <target state="translated">&lt;a href=&quot;#reactchildrenmap&quot;&gt; &lt;code&gt;React.Children.map()&lt;/code&gt; &lt;/a&gt; 과 같지만 배열을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a7b45e8f4e6108d3cd632f0d9032c3748a2b4eb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrendereddomcomponentswithclass&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithClass()&lt;/code&gt; &lt;/a&gt; 와 같지만 하나의 결과가있을 것으로 예상하고 그 결과를 반환하거나 다른 수의 일치 항목이 없으면 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="fbfeab98f1492d3cbd4fe154e243495eb88fd5bc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt;&lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt;&lt;/a&gt; but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="translated">&lt;a href=&quot;#scryrendereddomcomponentswithtag&quot;&gt; &lt;code&gt;scryRenderedDOMComponentsWithTag()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 하나의 결과가있을 것으로 예상하고 해당 결과를 반환하거나 다른 수의 일치 항목이 없으면 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="f9229dd48cd84c65e22bacddf9669feed15d9307" translate="yes" xml:space="preserve">
          <source>Like Next, the Experimental channel is a prerelease channel that tracks the master branch of the React repository. Unlike Next, Experimental releases include additional features and APIs that are not ready for wider release.</source>
          <target state="translated">다음과 같이 Experimental 채널은 React 리포지토리의 마스터 분기를 추적하는 시험판 채널입니다. 다음과 달리 실험용 릴리스에는 더 넓은 릴리스를 위해 준비되지 않은 추가 기능 및 API가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b243b275e73df60e527af74a2a1e22222d9d870a" translate="yes" xml:space="preserve">
          <source>Like any unfamiliar technology, React does have a learning curve. With practice and some patience, you &lt;em&gt;will&lt;/em&gt; get the hang of it.</source>
          <target state="translated">익숙하지 않은 기술과 마찬가지로 React에는 학습 곡선이 있습니다. 연습과 약간의 인내심으로, 당신 &lt;em&gt;은&lt;/em&gt; 그것을 끊을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b06e3b678326306ca6aedaf4c7b742dbd8cc493" translate="yes" xml:space="preserve">
          <source>Like components, the contract between &lt;code&gt;withSubscription&lt;/code&gt; and the wrapped component is entirely props-based. This makes it easy to swap one HOC for a different one, as long as they provide the same props to the wrapped component. This may be useful if you change data-fetching libraries, for example.</source>
          <target state="translated">컴포넌트와 마찬가지로 &lt;code&gt;withSubscription&lt;/code&gt; 과 랩핑 된 컴포넌트 간의 계약 은 전적으로 소품을 기반으로합니다. 이렇게하면 래핑 된 구성 요소에 동일한 소품을 제공하는 한 하나의 HOC를 다른 HOC로 쉽게 교체 할 수 있습니다. 예를 들어 데이터 페치 라이브러리를 변경하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8756ee6b18f3a0b99d47c3487ab6bf4153dc005f" translate="yes" xml:space="preserve">
          <source>Likewise, &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; support &lt;code&gt;defaultChecked&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; supports &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&amp;lt;input type=&quot;checkbox&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;input type=&quot;radio&quot;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;defaultChecked&lt;/code&gt; 를 지원 하고 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 는 &lt;code&gt;defaultValue&lt;/code&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="64b1d121df3542e14f97acaa2800f9f76542cac7" translate="yes" xml:space="preserve">
          <source>Linting in Flow</source>
          <target state="translated">흐름에 보풀</target>
        </trans-unit>
        <trans-unit id="f3b64dc10b36fcc65c0d847eaaa62fd7fe512239" translate="yes" xml:space="preserve">
          <source>Lists and Keys</source>
          <target state="translated">리스트와 키</target>
        </trans-unit>
        <trans-unit id="110bfe58a1735dfc3135bc1d5e016924d60c0744" translate="yes" xml:space="preserve">
          <source>Live Demo</source>
          <target state="translated">라이브 데모</target>
        </trans-unit>
        <trans-unit id="5f00bd7dc65bd809a53f2303fb70b92320c36fa6" translate="yes" xml:space="preserve">
          <source>Live-editing CSS and JS in development.</source>
          <target state="translated">개발중인 실시간 편집 CSS 및 JS.</target>
        </trans-unit>
        <trans-unit id="dc841064cbfd066e159686f41aef96834b0e8bf6" translate="yes" xml:space="preserve">
          <source>Looking at the now generated &lt;code&gt;tsconfig.json&lt;/code&gt;, you can see that there are many options you can use to configure the compiler. For a detailed description of all the options, check &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이제 생성 된 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 보면 컴파일러를 구성하는 데 사용할 수있는 많은 옵션이 있음을 알 수 있습니다. 모든 옵션에 대한 자세한 설명은 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&quot;&gt;여기를&lt;/a&gt; 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f500ff46d146daea76d615ff5daed4f1aeaa0d00" translate="yes" xml:space="preserve">
          <source>MDN HTML elements reference</source>
          <target state="translated">MDN HTML 요소 참조</target>
        </trans-unit>
        <trans-unit id="d5beafe9207c5520f3ac09a7866f79c87d68f07b" translate="yes" xml:space="preserve">
          <source>MDN Web Docs takes a look at this and describes how we can build &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;keyboard-navigable JavaScript widgets&lt;/a&gt;.</source>
          <target state="translated">MDN Web Docs는이를 살펴보고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets&quot;&gt;키보드 탐색 가능한 JavaScript 위젯을 작성&lt;/a&gt; 하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="48b1316849f970c5b3e2af20718278c5b7793286" translate="yes" xml:space="preserve">
          <source>Main Concepts</source>
          <target state="translated">주요 개념</target>
        </trans-unit>
        <trans-unit id="02ff3711bd667ed46bace9ec4c6ec8190ecebfcc" translate="yes" xml:space="preserve">
          <source>Major releases can also contain new features, and any release can include bug fixes.</source>
          <target state="translated">주요 릴리스에는 새로운 기능이 포함될 수 있으며 모든 릴리스에는 버그 수정이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18f93964d446c1e6ba3cd266eb85e86312f1773" translate="yes" xml:space="preserve">
          <source>Make sure you aren&amp;rsquo;t &lt;em&gt;calling the function&lt;/em&gt; when you pass it to the component:</source>
          <target state="translated">컴포넌트에 &lt;em&gt;함수&lt;/em&gt; 를 전달할 때 &lt;em&gt;함수를 호출&lt;/em&gt; 하지 않는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1908a834f7fac54b702b7157c4e6dc90e16f736a" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re familiar with simpler alternatives:</source>
          <target state="translated">더 간단한 대안에 익숙해 지십시오.</target>
        </trans-unit>
        <trans-unit id="90e7115a4c3ac435e928084df77c98aa6a10ab0d" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;re running the application in the development mode.</source>
          <target state="translated">개발 모드에서 응용 프로그램을 실행하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="16f51d22d8fb5f4e18c7b9a43a14aa00fb1d1d71" translate="yes" xml:space="preserve">
          <source>Managing focus, text selection, or media playback.</source>
          <target state="translated">초점, 텍스트 선택 또는 미디어 재생 관리</target>
        </trans-unit>
        <trans-unit id="63ee04fb3d96bb1368dfb5a70eed53b537b4cf07" translate="yes" xml:space="preserve">
          <source>Many React users credit reading &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; as the moment React finally &amp;ldquo;clicked&amp;rdquo; for them. It&amp;rsquo;s probably the oldest React walkthrough but it&amp;rsquo;s still just as relevant.</source>
          <target state="translated">많은 React 사용자가 React에서 마지막으로&amp;ldquo;클릭&amp;rdquo;한 순간으로 &lt;a href=&quot;thinking-in-react&quot;&gt;Thinking in React&lt;/a&gt; 를 읽 습니다. 아마도 가장 오래된 React 연습이지만 여전히 관련성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25207d84725584b98b20c010ae4e867354803e86" translate="yes" xml:space="preserve">
          <source>Maybe.</source>
          <target state="translated">Maybe.</target>
        </trans-unit>
        <trans-unit id="5279878671cef1bbee173e636b630698108458c0" translate="yes" xml:space="preserve">
          <source>Mechanisms to skip to desired content</source>
          <target state="translated">원하는 컨텐츠로 건너 뛰는 메커니즘</target>
        </trans-unit>
        <trans-unit id="80ebd3a5b45a9f5adf87a363ab82624e164a1745" translate="yes" xml:space="preserve">
          <source>Media Events</source>
          <target state="translated">미디어 이벤트</target>
        </trans-unit>
        <trans-unit id="2fce9fc1bba59eae6ae511090a30e9f9acda79af" translate="yes" xml:space="preserve">
          <source>Migration Step: Blocking Mode</source>
          <target state="translated">마이그레이션 단계 : 차단 모드</target>
        </trans-unit>
        <trans-unit id="c51e9091bf1aa90a7dc06f8b80d1cf4f79106e04" translate="yes" xml:space="preserve">
          <source>Minor releases are the most common type of release.</source>
          <target state="translated">부 릴리스는 가장 일반적인 릴리스 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e609b515d8887ae3c0a2bcd948b76d5eb888dcae" translate="yes" xml:space="preserve">
          <source>Mocking Modules</source>
          <target state="translated">조롱 모듈</target>
        </trans-unit>
        <trans-unit id="5fd5e79fcfd93473fe47f93cc81171186377bc01" translate="yes" xml:space="preserve">
          <source>Mocking a rendering surface</source>
          <target state="translated">렌더링 표면 조롱</target>
        </trans-unit>
        <trans-unit id="9f9db431c0932c551ce8ea2f4c40d441d4aa97a6" translate="yes" xml:space="preserve">
          <source>Mocking functions</source>
          <target state="translated">조롱 기능</target>
        </trans-unit>
        <trans-unit id="7e3ebffe5140fcd669b91ded83765eee7cd79ed7" translate="yes" xml:space="preserve">
          <source>Mocking modules</source>
          <target state="translated">조롱 모듈</target>
        </trans-unit>
        <trans-unit id="dfc6f7ed11adb29245ad928339ee3fe94bf8f96c" translate="yes" xml:space="preserve">
          <source>Mocking timers</source>
          <target state="translated">조롱 타이머</target>
        </trans-unit>
        <trans-unit id="c5ab7c68a15742b6ace6a0b59f0802cd56989f9d" translate="yes" xml:space="preserve">
          <source>More Complex Widgets</source>
          <target state="translated">더 복잡한 위젯</target>
        </trans-unit>
        <trans-unit id="ae1e9c89527fbc96f2921cbe93fbfc11e6a52a9a" translate="yes" xml:space="preserve">
          <source>More Flexible Toolchains</source>
          <target state="translated">보다 유연한 툴체인</target>
        </trans-unit>
        <trans-unit id="c42df7c665642f754f240ed7f247eeed80d1ceb3" translate="yes" xml:space="preserve">
          <source>More concretely, &lt;strong&gt;a render prop is a function prop that a component uses to know what to render.&lt;/strong&gt;</source>
          <target state="translated">보다 구체적으로, &lt;strong&gt;렌더 소품은 컴포넌트가 렌더링 대상을 알기 위해 사용하는 함수 소품입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4184dc3093adbdaf5a60e796e014a24e3eb74b2" translate="yes" xml:space="preserve">
          <source>Most React apps will have their files &amp;ldquo;bundled&amp;rdquo; using tools like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Bundling is the process of following imported files and merging them into a single file: a &amp;ldquo;bundle&amp;rdquo;. This bundle can then be included on a webpage to load an entire app at once.</source>
          <target state="translated">대부분의 React 앱에는 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; 또는 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 도구를 사용하여 파일이 &quot;번들&quot;로 표시 됩니다. 번들링은 가져온 파일을 따라 단일 파일로 병합하는 프로세스입니다 ( &quot;번들&quot;). 그런 다음이 번들을 웹 페이지에 포함시켜 전체 앱을 한 번에로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f5a32a23f908873850adbc01e3bfc083647f135" translate="yes" xml:space="preserve">
          <source>Most of the time, you can use &lt;code&gt;React.PureComponent&lt;/code&gt; instead of writing your own &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. It only does a shallow comparison, so you can&amp;rsquo;t use it if the props or state may have been mutated in a way that a shallow comparison would miss.</source>
          <target state="translated">대부분의 경우 자신의 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 작성하는 대신 &lt;code&gt;React.PureComponent&lt;/code&gt; 를 사용할 수 있습니다 . 얕은 비교 만 수행하므로 소품이나 상태가 얕은 비교에서 놓칠 수있는 방식으로 변형 된 경우에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d6ec3d67d6c3f4388c5225ce97b912bc6998b9b" translate="yes" xml:space="preserve">
          <source>Most people who use React don&amp;rsquo;t use Web Components, but you may want to, especially if you are using third-party UI components that are written using Web Components.</source>
          <target state="translated">React를 사용하는 대부분의 사람들은 웹 구성 요소를 사용하지 않지만 특히 웹 구성 요소를 사용하여 작성된 타사 UI 구성 요소를 사용하는 경우 원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="26ae06ab481b93e012f7ab95465638d5fb60ed34" translate="yes" xml:space="preserve">
          <source>Mounting</source>
          <target state="translated">Mounting</target>
        </trans-unit>
        <trans-unit id="b239ecd4f1b125963a812db57dc3cec60573502b" translate="yes" xml:space="preserve">
          <source>Mouse Events</source>
          <target state="translated">마우스 이벤트</target>
        </trans-unit>
        <trans-unit id="7b20c10dce51324fb107e751c01666324956e394" translate="yes" xml:space="preserve">
          <source>Mouse and pointer events</source>
          <target state="translated">마우스 및 포인터 이벤트</target>
        </trans-unit>
        <trans-unit id="4d1e7bad76871046ddf523d9fe663dd3a621512b" translate="yes" xml:space="preserve">
          <source>Move the body of the function into the &lt;code&gt;render()&lt;/code&gt; method.</source>
          <target state="translated">함수 본문을 &lt;code&gt;render()&lt;/code&gt; 메소드 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b29de6bcd589e86e040638485090ea2a9bf182d" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;Profiler&lt;/code&gt; components can be used to measure different parts of an application:</source>
          <target state="translated">여러 &lt;code&gt;Profiler&lt;/code&gt; 구성 요소를 사용하여 응용 프로그램의 다른 부분을 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e23b3461f95ee737c2d746ec92f09e64df8c67e" translate="yes" xml:space="preserve">
          <source>Multiple Renderers</source>
          <target state="translated">다중 렌더러</target>
        </trans-unit>
        <trans-unit id="b0479fd15fec4ef8ee834648226853be71fdeda8" translate="yes" xml:space="preserve">
          <source>Mutating HOCs are a leaky abstraction&amp;mdash;the consumer must know how they are implemented in order to avoid conflicts with other HOCs.</source>
          <target state="translated">돌연변이 HOC는 누출되는 추상화입니다. 소비자는 다른 HOC와의 충돌을 피하기 위해 구현 방법을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="6b4fb500f3d1079177a94f12b723a038f9d11e9c" translate="yes" xml:space="preserve">
          <source>Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React&amp;rsquo;s &lt;em&gt;render phase&lt;/em&gt;). Doing so will lead to confusing bugs and inconsistencies in the UI.</source>
          <target state="translated">함수 구성 요소의 본체 내에서는 돌연변이, 구독, 타이머, 로깅 및 기타 부작용이 허용되지 않습니다 (React의 &lt;em&gt;렌더링 단계&lt;/em&gt; 라고 함 ). 그렇게하면 UI에서 혼란스럽고 버그와 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298fe7648153e9ef9747060691f787af56551508" translate="yes" xml:space="preserve">
          <source>NVDA in Firefox</source>
          <target state="translated">Firefox의 NVDA</target>
        </trans-unit>
        <trans-unit id="88f2f30ba49708ae97f8d92b8a8a72e7ddff53df" translate="yes" xml:space="preserve">
          <source>Named Exports</source>
          <target state="translated">명명 된 수출</target>
        </trans-unit>
        <trans-unit id="8223c4ee1ebba2ecb6739e2c07dbe5aef3df91b4" translate="yes" xml:space="preserve">
          <source>Naming Changes from React 15</source>
          <target state="translated">반응 15에서 이름 변경</target>
        </trans-unit>
        <trans-unit id="e41e56840d69bd1bdd31e27707dc3a8b970413df" translate="yes" xml:space="preserve">
          <source>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn&amp;rsquo;t care whether it is defined as a function or a class.</source>
          <target state="translated">부모 또는 자식 구성 요소는 특정 구성 요소가 상태 저장인지 또는 상태 비 저장인지 알 수 없으며, 구성 요소가 함수 또는 클래스로 정의되어 있는지 상관하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c44dcd3a4ac0c4c177b3fafe8b75ff34a66cc079" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.state&lt;/code&gt; directly, as calling &lt;code&gt;setState()&lt;/code&gt; afterwards may replace the mutation you made. Treat &lt;code&gt;this.state&lt;/code&gt; as if it were immutable.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 를 호출 하면 변경 한 내용이 바뀔 수 있으므로 &lt;code&gt;this.state&lt;/code&gt; 를 직접 변경하지 마십시오 . 취급 &lt;code&gt;this.state&lt;/code&gt; 이 불변 인 것처럼.</target>
        </trans-unit>
        <trans-unit id="2cb61bead103f4e57375ed4a4afb6cfadf7e8a73" translate="yes" xml:space="preserve">
          <source>New Behavior for Uncaught Errors</source>
          <target state="translated">잡히지 않은 오류에 대한 새로운 동작</target>
        </trans-unit>
        <trans-unit id="9840d3214efbf61f44cf5554641966293bd9f3a1" translate="yes" xml:space="preserve">
          <source>Next Channel</source>
          <target state="translated">다음 채널</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="0ed8ca892cbf39b577e860e50cdb6e102751578f" translate="yes" xml:space="preserve">
          <source>Next, add three &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags to the HTML page right before the closing &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; tag:</source>
          <target state="translated">다음으로 닫는 &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt; 태그 바로 앞에 HTML 페이지 에 세 개의 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="87cb58c13d37c6cc1855c1dd32d1fed18cfeb93f" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;render()&lt;/code&gt; method is called and the diff algorithm recurses on the previous result and the new result.</source>
          <target state="translated">다음으로 &lt;code&gt;render()&lt;/code&gt; 메소드가 호출되고 diff 알고리즘이 이전 결과와 새 결과에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="3e81212e5ac19cfc9b59fe21a631d3753e83f2b5" translate="yes" xml:space="preserve">
          <source>Next, we will create a component called &lt;code&gt;Calculator&lt;/code&gt;. It renders an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; that lets you enter the temperature, and keeps its value in &lt;code&gt;this.state.temperature&lt;/code&gt;.</source>
          <target state="translated">다음으로 &lt;code&gt;Calculator&lt;/code&gt; 라는 구성 요소를 만듭니다 . 온도를 입력하고 값을 &lt;code&gt;this.state.temperature&lt;/code&gt; 로 유지 하는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="773f24daf1da57217e2f8e8567bf1bc9016af437" translate="yes" xml:space="preserve">
          <source>Next, we will extract a &lt;code&gt;UserInfo&lt;/code&gt; component that renders an &lt;code&gt;Avatar&lt;/code&gt; next to the user&amp;rsquo;s name:</source>
          <target state="translated">다음으로, 사용자 이름 옆에 &lt;code&gt;Avatar&lt;/code&gt; 를 렌더링하는 &lt;code&gt;UserInfo&lt;/code&gt; 컴포넌트를 추출합니다 :</target>
        </trans-unit>
        <trans-unit id="72d6961628775828349729a4be218018b6d3a3ac" translate="yes" xml:space="preserve">
          <source>Next, we will implement the lifecycle methods. We need to initialize Chosen with the ref to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node in &lt;code&gt;componentDidMount&lt;/code&gt;, and tear it down in &lt;code&gt;componentWillUnmount&lt;/code&gt;:</source>
          <target state="translated">다음으로 라이프 사이클 메소드를 구현합니다. &lt;code&gt;componentDidMount&lt;/code&gt; 의 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 노드에 대한 참조를 사용하여 Chosen을 초기화 하고 componentWillUnmount 에서 분리해야 &lt;code&gt;componentWillUnmount&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce34474eda0627488f7dc85176d87bf118e6e53d" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add an import for the &lt;code&gt;useTransition&lt;/code&gt; Hook from React:</source>
          <target state="translated">다음 으로 React 에서 &lt;code&gt;useTransition&lt;/code&gt; Hook에 대한 가져 오기를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="00d7070daf25a2f645c41cd51b24e95c602ef3cd" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll make the &lt;code&gt;Clock&lt;/code&gt; set up its own timer and update itself every second.</source>
          <target state="translated">다음으로 &lt;code&gt;Clock&lt;/code&gt; 이 자체 타이머를 설정하고 매초마다 자체 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="83e778abae94d2dfc988da43bf316d54e5851ca7" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll tell the compiler where our source code is and where the output should go.</source>
          <target state="translated">다음으로 컴파일러에게 소스 코드의 위치와 출력 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="694fd7bdca2fabcac6a912607368e98378b0b39b" translate="yes" xml:space="preserve">
          <source>Next.js</source>
          <target state="translated">Next.js</target>
        </trans-unit>
        <trans-unit id="aa4786474b1f9c2b27bbf660fd976c2e3f9e0c0b" translate="yes" xml:space="preserve">
          <source>No Breaking Changes</source>
          <target state="translated">주요 변경 사항 없음</target>
        </trans-unit>
        <trans-unit id="ea583f6afe9b6e25e50f115711dd0b56142fcb36" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;React Without ES6&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">아니! 자세한 내용은 &lt;a href=&quot;react-without-es6&quot;&gt;&amp;ldquo;ES6없이 반응&amp;rdquo;을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="65b196a9e021f5013ed7f97aab941425359e880d" translate="yes" xml:space="preserve">
          <source>No! Check out &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;React Without JSX&amp;rdquo;&lt;/a&gt; to learn more.</source>
          <target state="translated">아니! 자세한 내용은 &lt;a href=&quot;react-without-jsx&quot;&gt;&amp;ldquo;JSX없이 반응&amp;rdquo;을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9848de506504aee3698fb2303cc082341679f4dc" translate="yes" xml:space="preserve">
          <source>No, they are different. The Shadow DOM is a browser technology designed primarily for scoping variables and CSS in web components. The virtual DOM is a concept implemented by libraries in JavaScript on top of browser APIs.</source>
          <target state="translated">아니요, 다릅니다. Shadow DOM은 주로 웹 구성 요소의 변수 및 CSS 범위를 지정하기 위해 설계된 브라우저 기술입니다. 가상 DOM은 브라우저 API 위에 JavaScript의 라이브러리로 구현되는 개념입니다.</target>
        </trans-unit>
        <trans-unit id="e4ec72f282ae4d51f6663dfafe02a89ddbd53865" translate="yes" xml:space="preserve">
          <source>No. In modern browsers, the raw performance of closures compared to classes doesn&amp;rsquo;t differ significantly except in extreme scenarios.</source>
          <target state="translated">아니요. 최신 브라우저에서는 클래스와 비교하여 클로저의 원시 성능이 극단적 인 시나리오를 제외하고 크게 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e489b277ff2e842c4240cf5198329ad064dfd60" translate="yes" xml:space="preserve">
          <source>No. There are &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;no plans&lt;/a&gt; to remove classes from React &amp;mdash; we all need to keep shipping products and can&amp;rsquo;t afford rewrites. We recommend trying Hooks in new code.</source>
          <target state="translated">아니요. React에서 클래스를 제거 &lt;a href=&quot;hooks-intro#gradual-adoption-strategy&quot;&gt;할 계획&lt;/a&gt; 이 없습니다. 모두 배송 제품을 유지해야하며 다시 쓸 수 없습니다. 새 코드에서 후크를 사용해 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a407ef4de7c3c16900e064cfde1c40d6f88459c3" translate="yes" xml:space="preserve">
          <source>Normally you should try to avoid all uses of &lt;code&gt;forceUpdate()&lt;/code&gt; and only read from &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; in &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">일반적으로 당신의 모든 사용을 피하려고한다 &lt;code&gt;forceUpdate()&lt;/code&gt; 만 읽고 &lt;code&gt;this.props&lt;/code&gt; 및 &lt;code&gt;this.state&lt;/code&gt; 의 &lt;code&gt;render()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99653f5245ac5639a7989484c01146c83245683b" translate="yes" xml:space="preserve">
          <source>Normally you would define a React component as a plain JavaScript class:</source>
          <target state="translated">일반적으로 React 컴포넌트를 일반 JavaScript 클래스로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="183009a95c48cc3c8552b8d193bc55733a9da03e" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, &lt;code&gt;props.children&lt;/code&gt; works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as &lt;code&gt;props.children&lt;/code&gt;:</source>
          <target state="translated">일반적으로 JSX에 삽입 된 JavaScript 표현식은 문자열, React 요소 또는 해당 항목의 목록으로 평가됩니다. 그러나 &lt;code&gt;props.children&lt;/code&gt; 은 React가 렌더링 방법을 알고있는 정렬뿐만 아니라 모든 종류의 데이터를 전달할 수 있다는 점에서 다른 소품과 동일하게 작동합니다. 예를 들어, 사용자 정의 컴포넌트가있는 경우 &lt;code&gt;props.children&lt;/code&gt; 으로 콜백 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="190f214c6271f32c16616efc1edf4a598d1724d4" translate="yes" xml:space="preserve">
          <source>Normally, there is a warning when an element with children is also marked as &lt;code&gt;contentEditable&lt;/code&gt;, because it won&amp;rsquo;t work. This attribute suppresses that warning. Don&amp;rsquo;t use this unless you are building a library like &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; that manages &lt;code&gt;contentEditable&lt;/code&gt; manually.</source>
          <target state="translated">일반적으로 하위 요소가있는 요소가 작동하지 않기 때문에 &lt;code&gt;contentEditable&lt;/code&gt; 로 표시되면 경고가 발생합니다 . 이 속성은 해당 경고를 억제합니다. &lt;code&gt;contentEditable&lt;/code&gt; 을 수동으로 관리하는 &lt;a href=&quot;https://facebook.github.io/draft-js/&quot;&gt;Draft.js&lt;/a&gt; 와 같은 라이브러리를 작성하지 않는 한 이것을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0cd4b09c96906d68937c9412b6fd82a68a4314a7" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use in new code without making any changes to the existing code.</source>
          <target state="translated">일반적으로 React에 기능을 추가하면 즉시 사용할 수 있습니다. 프래그먼트, 컨텍스트 및 후크는 이러한 기능의 예입니다. 기존 코드를 변경하지 않고 새 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6b777eeab761f59c9850ff240a2c5f5aa55549" translate="yes" xml:space="preserve">
          <source>Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use them in new code without making any changes to the existing code.</source>
          <target state="translated">Normally, when we add features to React, you can start using them immediately. Fragments, Context, and even Hooks are examples of such features. You can use them in new code without making any changes to the existing code.</target>
        </trans-unit>
        <trans-unit id="a2dec545b1bcbcdd30f45e8128cc1dc979967845" translate="yes" xml:space="preserve">
          <source>Normally, when you return an element from a component&amp;rsquo;s render method, it&amp;rsquo;s mounted into the DOM as a child of the nearest parent node:</source>
          <target state="translated">일반적으로 컴포넌트의 render 메소드에서 요소를 반환하면 가장 가까운 상위 노드의 자식으로 DOM에 마운트됩니다.</target>
        </trans-unit>
        <trans-unit id="b36f36a60ec7e988ebd6b0da0589f77cbff203cc" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t mutate local state in React. However, as an escape hatch, you can use an incrementing counter to force a re-render even if the state has not changed:</source>
          <target state="translated">일반적으로 React에서 로컬 상태를 변경해서는 안됩니다. 그러나 이스케이프 해치로서 증분 카운터를 사용하여 상태가 변경되지 않은 경우에도 다시 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65436a84c77556cccffc3de4f952f08eb5996b2a" translate="yes" xml:space="preserve">
          <source>Normally, you shouldn&amp;rsquo;t need to think about this. But it matters for HOCs because it means you can&amp;rsquo;t apply a HOC to a component within the render method of a component:</source>
          <target state="translated">일반적으로, 당신은 이것에 대해 생각할 필요가 없습니다. 그러나 구성 요소의 렌더링 방법 내에서 구성 요소에 HOC를 적용 할 수 없기 때문에 HOC에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b634d41d383d2c2c85fe24302f5a62774271b079" translate="yes" xml:space="preserve">
          <source>Not all HOCs look the same. Sometimes they accept only a single argument, the wrapped component:</source>
          <target state="translated">모든 HOC가 동일하게 보이지는 않습니다. 때로는 래핑 된 구성 요소 인 단일 인수 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="81b40478626081aff6b6152a5ac2bc60a347ba9e" translate="yes" xml:space="preserve">
          <source>Not all style properties are converted to pixel strings though. Certain ones remain unitless (eg &lt;code&gt;zoom&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;flex&lt;/code&gt;). A complete list of unitless properties can be seen &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">모든 스타일 속성이 픽셀 문자열로 변환되는 것은 아닙니다. 어떤 것들은 단위가없는 상태로 남아 있습니다 (예 : &lt;code&gt;zoom&lt;/code&gt; , &lt;code&gt;order&lt;/code&gt; , &lt;code&gt;flex&lt;/code&gt; ). 단위없는 속성의 전체 목록은 &lt;a href=&quot;https://github.com/facebook/react/blob/4131af3e4bf52f3a003537ec95a1655147c81270/src/renderers/dom/shared/CSSProperty.js#L15-L59&quot;&gt;여기에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3dce74d24f02b63c13638f91d2e8c790ee44211" translate="yes" xml:space="preserve">
          <source>Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;&lt;code&gt;CHANGELOG.md&lt;/code&gt; file in the React repository&lt;/a&gt;, as well as on the &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">모든 React 릴리스에 자체 블로그 게시물이 필요한 것은 아니지만 &lt;a href=&quot;https://github.com/facebook/react/releases&quot;&gt;릴리스&lt;/a&gt; 페이지 뿐만 아니라 &lt;a href=&quot;https://github.com/facebook/react/blob/master/CHANGELOG.md&quot;&gt;React 저장소&lt;/a&gt; 의 &lt;code&gt;CHANGELOG.md&lt;/code&gt; 파일에서 모든 릴리스에 대한 자세한 변경 로그를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b703ebbf1b1cf4f4af246b8831b3304e1ea7b732" translate="yes" xml:space="preserve">
          <source>Note for component library maintainers</source>
          <target state="translated">컴포넌트 라이브러리 관리자에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="61f07fc00eca63f479177f8f24ebc20765f4ab58" translate="yes" xml:space="preserve">
          <source>Note how &lt;strong&gt;we have to duplicate the code between these two lifecycle methods in class.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;클래스에서이 두 수명주기 메소드간에 코드를&lt;/strong&gt; 어떻게 &lt;strong&gt;복제&lt;/strong&gt; 해야하는지 참고하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="136a652f0357162f7faa10211f6de25fc285e258" translate="yes" xml:space="preserve">
          <source>Note how the logic that sets &lt;code&gt;document.title&lt;/code&gt; is split between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. The subscription logic is also spread between &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;. And &lt;code&gt;componentDidMount&lt;/code&gt; contains code for both tasks.</source>
          <target state="translated">&lt;code&gt;document.title&lt;/code&gt; 을 설정하는 논리가 &lt;code&gt;componentDidMount&lt;/code&gt; 와 &lt;code&gt;componentDidUpdate&lt;/code&gt; 로 어떻게 분리 되는지 확인하십시오 . 구독 논리는 &lt;code&gt;componentDidMount&lt;/code&gt; 와 &lt;code&gt;componentWillUnmount&lt;/code&gt; 사이에 분산 됩니다 . 그리고 &lt;code&gt;componentDidMount&lt;/code&gt; 에는 두 작업을위한 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af859993c451cb0b08b7e66c1d591884e0bd7b2b" translate="yes" xml:space="preserve">
          <source>Note how this would work for props, state, or any other calculated value.</source>
          <target state="translated">props, state 또는 기타 계산 된 값에 어떻게 작동하는지 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="81f0076b98d34a6e29be0cedd7cf07479dcc0f97" translate="yes" xml:space="preserve">
          <source>Note how we also changed the effect dependencies from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;[id]&lt;/code&gt; &amp;mdash; because we want the effect to re-run when the &lt;code&gt;id&lt;/code&gt; changes. Otherwise, we wouldn&amp;rsquo;t refetch new data.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 변경 될 때 효과를 다시 실행하기를 원하기 때문에 효과 종속성을 &lt;code&gt;[]&lt;/code&gt; 에서 &lt;code&gt;[id]&lt;/code&gt; 로 어떻게 변경했는지 참고하십시오 . 그렇지 않으면 새 데이터를 다시 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66e67313f6ff24b0ac9427a27eaa56f7a14b86fb" translate="yes" xml:space="preserve">
          <source>Note how we eliminated the &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;is loading&amp;rdquo; checks from our components. This doesn&amp;rsquo;t only remove boilerplate code, but it also simplifies making quick design changes. For example, if we wanted profile details and posts to always &amp;ldquo;pop in&amp;rdquo; together, we could delete the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary between them. Or we could make them independent from each other by giving each &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary. Suspense lets us change the granularity of our loading states and orchestrate their sequencing without invasive changes to our code.</source>
          <target state="translated">컴포넌트에서 &lt;code&gt;if (...)&lt;/code&gt; &amp;ldquo;loading&amp;rdquo;검사를 어떻게 제거했는지 참고하십시오 . 이는 상용구 코드를 제거 할뿐만 아니라 빠른 설계 변경을 단순화합니다. 예를 들어 프로필 세부 정보와 게시물이 항상 &quot;팝인&quot;되도록하려면 이들 사이 의 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계를 삭제할 수 있습니다. 또는 각각 &lt;em&gt;고유 한 &lt;/em&gt; &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계를 지정 하여 서로 독립적으로 만들 수 있습니다 . 서스펜스를 사용하면로드 상태의 세분성을 변경하고 코드를 침범하지 않고 시퀀싱을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a102e3bac932a4b73c9dad4c0a7268f562de444e" translate="yes" xml:space="preserve">
          <source>Note how we pass &lt;code&gt;props&lt;/code&gt; to the base constructor:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 을 기본 생성자에 전달하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2582d2e45f28b6c6e7c9a5f4534087c1aa30ef02" translate="yes" xml:space="preserve">
          <source>Note how we save the timer ID right on &lt;code&gt;this&lt;/code&gt; (&lt;code&gt;this.timerID&lt;/code&gt;).</source>
          <target state="translated">주 우리가 타이머 ID를 오른쪽으로 저장하는 방법 &lt;code&gt;this&lt;/code&gt; ( &lt;code&gt;this.timerID&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7abe7d49c5110b0b495bee7ab2bbbd92a50f878a" translate="yes" xml:space="preserve">
          <source>Note how we used the ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;computed property name&lt;/a&gt; syntax to update the state key corresponding to the given input name:</source>
          <target state="translated">ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names&quot;&gt;계산 속성 이름&lt;/a&gt; 구문을 사용하여 주어진 입력 이름에 해당하는 상태 키를 업데이트 한 방법에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="b008f8350f4cfc8fc1ac8218af3644148e094014" translate="yes" xml:space="preserve">
          <source>Note how we were able to move the &lt;code&gt;useState&lt;/code&gt; call for the &lt;code&gt;position&lt;/code&gt; state variable and the related effect into a custom Hook without changing their code. If all state was in a single object, extracting it would be more difficult.</source>
          <target state="translated">&lt;code&gt;position&lt;/code&gt; 상태 변수에 대한 &lt;code&gt;useState&lt;/code&gt; 호출 및 관련 효과를 코드를 변경하지 않고 사용자 정의 후크 로 이동시키는 방법에 주목 하십시오 . 모든 상태가 단일 객체에 있었다면 추출하기가 더 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b1a921c73e886405b533b71309555191e0dd804" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SuspenseList&lt;/code&gt; only operates on the closest &lt;code&gt;Suspense&lt;/code&gt; and &lt;code&gt;SuspenseList&lt;/code&gt; components below it. It does not search for boundaries deeper than one level. However, it is possible to nest multiple &lt;code&gt;SuspenseList&lt;/code&gt; components in each other to build grids.</source>
          <target state="translated">&lt;code&gt;SuspenseList&lt;/code&gt; 는 그 아래 가장 가까운 &lt;code&gt;Suspense&lt;/code&gt; 및 &lt;code&gt;SuspenseList&lt;/code&gt; 구성 요소 에서만 작동 합니다. 한 수준보다 깊은 경계를 검색하지 않습니다. 그러나 여러 &lt;code&gt;SuspenseList&lt;/code&gt; 구성 요소를 서로 중첩 하여 그리드를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5369d72764239c963258ac4860d4222756071b86" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;error boundaries only catch errors in the components below them in the tree&lt;/strong&gt;. An error boundary can&amp;rsquo;t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</source>
          <target state="translated">참고 &lt;strong&gt;오류 경계는 트리에서 그 아래의 구성 요소의 오류를 잡아&lt;/strong&gt; . 오류 경계는 자체적으로 오류를 포착 할 수 없습니다. 오류 경계가 오류 메시지를 렌더링하는 데 실패하면 오류는 그 위에있는 가장 가까운 오류 경계로 전파됩니다. 이것도 JavaScript에서 catch {} 블록이 작동하는 방식과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="056385a2ed6637b481ae142bf0a46d9f70a318a3" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;the numbers are relative so components will render faster in production&lt;/strong&gt;. Still, this should help you realize when unrelated UI gets updated by mistake, and how deep and how often your UI updates occur.</source>
          <target state="translated">참고 &lt;strong&gt;구성 요소가 더 빨리 생산에 렌더링 할 수 있도록 번호를 기준으로합니다&lt;/strong&gt; . 그래도 관련없는 UI가 실수로 업데이트되는시기와 UI 업데이트 발생 빈도 및 빈도를 파악하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="89ff4a5e91c66b9d6944b9d99f0d60617bdf219c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;to enable Hooks, all React packages need to be 16.8.0 or higher&lt;/strong&gt;. Hooks won&amp;rsquo;t work if you forget to update, for example, React DOM.</source>
          <target state="translated">참고 것을 &lt;strong&gt;후크를 사용하려면, 모든 패키지가 16.8.0 이상 할 필요가 반작용&lt;/strong&gt; . 예를 들어 React DOM과 같은 업데이트를 잊어 버린 경우 후크가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a58c552c3d3190dd2fb91ca8e1639154f214426b" translate="yes" xml:space="preserve">
          <source>Note that React assigns no special meaning to the &lt;code&gt;this.el&lt;/code&gt; field. It only works because we have previously assigned this field from a &lt;code&gt;ref&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="translated">React는 &lt;code&gt;this.el&lt;/code&gt; 필드에 특별한 의미를 부여하지 않습니다 . 우리는 이전부터이 필드를 할당하기 때문에에만 작동 &lt;code&gt;ref&lt;/code&gt; 에서 &lt;code&gt;render()&lt;/code&gt; 방법 :</target>
        </trans-unit>
        <trans-unit id="47b82595a068571374ab58a7ca07015bf588a435" translate="yes" xml:space="preserve">
          <source>Note that React may still need to render that specific component again before bailing out. That shouldn&amp;rsquo;t be a concern because React won&amp;rsquo;t unnecessarily go &amp;ldquo;deeper&amp;rdquo; into the tree. If you&amp;rsquo;re doing expensive calculations while rendering, you can optimize them with &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="translated">리액션을 수행하기 전에 React에서 해당 특정 컴포넌트를 다시 렌더링해야 할 수도 있습니다. React가 불필요하게 나무에 더 깊숙이 들어 가지 않기 때문에 걱정할 필요가 없습니다. 렌더링하는 동안 값 비싼 계산을 수행하는 경우 &lt;code&gt;useMemo&lt;/code&gt; 로 계산을 최적화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20548fe21065f678631f41f93e7e5b0293cf3638" translate="yes" xml:space="preserve">
          <source>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2&amp;rsquo;s subtree and C7, it didn&amp;rsquo;t even have to compare the elements as we bailed out on &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and &lt;code&gt;render&lt;/code&gt; was not called.</source>
          <target state="translated">React는 C6에 대한 DOM 돌연변이 만 수행해야했으며, 이는 불가피했습니다. C8를 들어, 그것은 반작용 렌더링 요소를 비교하여 구제 및 C2의 하위 트리와 C7을 위해, 심지어는 우리가 구제로 요소를 비교하지 않았다 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 및 &lt;code&gt;render&lt;/code&gt; 호출되지 않은.</target>
        </trans-unit>
        <trans-unit id="cd5e25e3c06e2e0a9f837231ef8545ceec20aa21" translate="yes" xml:space="preserve">
          <source>Note that a HOC doesn&amp;rsquo;t modify the input component, nor does it use inheritance to copy its behavior. Rather, a HOC &lt;em&gt;composes&lt;/em&gt; the original component by &lt;em&gt;wrapping&lt;/em&gt; it in a container component. A HOC is a pure function with zero side-effects.</source>
          <target state="translated">HOC는 입력 구성 요소를 수정하지 않으며 상속을 사용하여 해당 동작을 복사하지 않습니다. 오히려하는 HOC &lt;em&gt;작곡&lt;/em&gt; 에 의해 원래의 요소 &lt;em&gt;포장&lt;/em&gt; 용기의 구성에있다. HOC는 부작용이 전혀없는 순수한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b0e7b7a2953e10e5ee351f37db62af70ce535d29" translate="yes" xml:space="preserve">
          <source>Note that all &lt;code&gt;aria-*&lt;/code&gt; HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be hyphen-cased (also known as kebab-case, lisp-case, etc) as they are in plain HTML:</source>
          <target state="translated">모든 &lt;code&gt;aria-*&lt;/code&gt; HTML 속성은 JSX에서 완벽하게 지원됩니다. React의 대부분의 DOM 속성 및 속성이 camelCased 인 반면, 이러한 속성은 일반 HTML에서와 같이 하이픈으로 묶어야합니다 (케밥 케이스, lisp 케이스 등).</target>
        </trans-unit>
        <trans-unit id="7624acea1a9c060576a9f15d678ecc769a9b76e6" translate="yes" xml:space="preserve">
          <source>Note that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.</source>
          <target state="translated">부모 구성 요소로 인해 구성 요소가 다시 렌더링되는 경우 소품이 변경되지 않은 경우에도이 메서드가 호출됩니다. 변경 사항 만 처리하려면 현재 값과 다음 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="c974944cb18d8a4b4d98d26cf2d4b75e73525b1b" translate="yes" xml:space="preserve">
          <source>Note that in the above example we &lt;strong&gt;need&lt;/strong&gt; to keep the function in the dependencies list. This ensures that a change in the &lt;code&gt;productId&lt;/code&gt; prop of &lt;code&gt;ProductPage&lt;/code&gt; automatically triggers a refetch in the &lt;code&gt;ProductDetails&lt;/code&gt; component.</source>
          <target state="translated">위의 예제 에서 함수를 의존성 목록에 유지 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 이렇게하면 &lt;code&gt;ProductPage&lt;/code&gt; 의 &lt;code&gt;productId&lt;/code&gt; prop가 변경 되면 &lt;code&gt;ProductDetails&lt;/code&gt; 구성 요소 에서 다시 가져 오기가 자동으로 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="15064b1b66df67d34d5a232d98bfeba9ea33bea0" translate="yes" xml:space="preserve">
          <source>Note that rendering &lt;code&gt;lazy&lt;/code&gt; components requires that there&amp;rsquo;s a &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; component higher in the rendering tree. This is how you specify a loading indicator.</source>
          <target state="translated">&lt;code&gt;lazy&lt;/code&gt; 구성 요소 를 렌더링 하려면 렌더링 트리에 &lt;code&gt;&amp;lt;React.Suspense&amp;gt;&lt;/code&gt; 구성 요소가 더 높아야합니다. 로드 표시기를 지정하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aa4c033446ec6662e8a38df6618cdc398a3612d3" translate="yes" xml:space="preserve">
          <source>Note that returning a falsy expression will still cause the element after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to be skipped but will return the falsy expression. In the example below, &lt;code&gt;&amp;lt;div&amp;gt;0&amp;lt;/div&amp;gt;&lt;/code&gt; will be returned by the render method.</source>
          <target state="translated">Note that returning a falsy expression will still cause the element after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to be skipped but will return the falsy expression. In the example below, &lt;code&gt;&amp;lt;div&amp;gt;0&amp;lt;/div&amp;gt;&lt;/code&gt; will be returned by the render method.</target>
        </trans-unit>
        <trans-unit id="bca9869270c610c84eca37a4188271b709cfb625" translate="yes" xml:space="preserve">
          <source>Note that styles are not autoprefixed. To support older browsers, you need to supply corresponding style properties:</source>
          <target state="translated">스타일은 자동 접두사가 아닙니다. 구형 브라우저를 지원하려면 해당 스타일 속성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="067b30a981f559502026a96e0fc3941571707473" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;read()&lt;/code&gt; call in this example doesn&amp;rsquo;t &lt;em&gt;start&lt;/em&gt; fetching. It only tries to read the data that is &lt;strong&gt;already being fetched&lt;/strong&gt;. This difference is crucial to creating fast applications with Suspense. We don&amp;rsquo;t want to delay loading data until a component starts rendering. As a data fetching library author, you can enforce this by making it impossible to get a &lt;code&gt;resource&lt;/code&gt; object without also starting a fetch. Every demo on this page using our &amp;ldquo;fake API&amp;rdquo; enforces this.</source>
          <target state="translated">참고 &lt;code&gt;read()&lt;/code&gt; 이 예에서는 호출이되지 않습니다 &lt;em&gt;시작&lt;/em&gt; 페치. &lt;strong&gt;이미 가져온&lt;/strong&gt; 데이터 만 읽으려고합니다 . 이러한 차이점은 Suspense로 빠른 응용 프로그램을 만드는 데 중요합니다. 컴포넌트 렌더링이 시작될 때까지 데이터로드를 지연시키고 싶지 않습니다. 데이터 페치 라이브러리 작성자 는 페치를 시작하지 않고 &lt;code&gt;resource&lt;/code&gt; 오브젝트 를 가져올 수 없도록하여이를 강제 할 수 있습니다 . &quot;가짜 API&quot;를 사용하는이 페이지의 모든 데모는이를 시행합니다.</target>
        </trans-unit>
        <trans-unit id="dd2a771e4fad07ffb446c282efadcd2888cbe8e6" translate="yes" xml:space="preserve">
          <source>Note that the Coconut option is initially selected, because of the &lt;code&gt;selected&lt;/code&gt; attribute. React, instead of using this &lt;code&gt;selected&lt;/code&gt; attribute, uses a &lt;code&gt;value&lt;/code&gt; attribute on the root &lt;code&gt;select&lt;/code&gt; tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 속성으로 인해 코코넛 옵션이 처음에 선택 됩니다. 이 &lt;code&gt;selected&lt;/code&gt; 속성을 사용하는 대신 반응 은 루트 &lt;code&gt;select&lt;/code&gt; 태그 의 &lt;code&gt;value&lt;/code&gt; 속성을 사용합니다 . 한 곳에서 업데이트하기 만하면되기 때문에 제어되는 구성 요소에서 더 편리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5999130fbdfde82a85986a35fe0795798389c68" translate="yes" xml:space="preserve">
          <source>Note that the above example is demonstrating regular JavaScript behavior and doesn&amp;rsquo;t use error boundaries.</source>
          <target state="translated">위의 예제는 일반적인 JavaScript 동작을 보여 주며 오류 경계를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61cff9e21e25a4670560f3ba3575f47b51bc9f0f" translate="yes" xml:space="preserve">
          <source>Note that the button doesn&amp;rsquo;t care &lt;em&gt;what&lt;/em&gt; state we&amp;rsquo;re updating. It&amp;rsquo;s wrapping &lt;em&gt;any&lt;/em&gt; state updates that happen during its &lt;code&gt;onClick&lt;/code&gt; handler into a transition. Now that our &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; takes care of setting up the transition, the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component doesn&amp;rsquo;t need to set up its own:</source>
          <target state="translated">버튼은 우리가 업데이트 &lt;em&gt;하는&lt;/em&gt; 상태를 신경 쓰지 않습니다 . &lt;code&gt;onClick&lt;/code&gt; 핸들러 중에 발생하는 상태 업데이트를 전환으로 래핑 &lt;em&gt;합니다&lt;/em&gt; . 이제 우리의 것을 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 전환 설정을 담당는 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 구성 요소까지 자신을 설정할 필요는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="23b6882327e1c317b3769b724af427c65f26d7de" translate="yes" xml:space="preserve">
          <source>Note that this approach won&amp;rsquo;t work in a loop because Hook calls &lt;a href=&quot;hooks-rules&quot;&gt;can&amp;rsquo;t&lt;/a&gt; be placed inside loops. But you can extract a separate component for the list item, and call &lt;code&gt;useMemo&lt;/code&gt; there.</source>
          <target state="translated">후크 호출 &lt;a href=&quot;hooks-rules&quot;&gt;을&lt;/a&gt; 루프 내부에 배치 할 수 없으므로이 방법은 루프에서 작동 하지 않습니다 . 그러나 목록 항목에 대해 별도의 구성 요소를 추출하고 거기에서 &lt;code&gt;useMemo&lt;/code&gt; 를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3bb49079ffd95590ce09e3d67d7befe22d9e2ab" translate="yes" xml:space="preserve">
          <source>Note that this example is not meant to be exhaustive with regards to working with Backbone, but it should give you an idea for how to approach this in a generic way:</source>
          <target state="translated">이 예제는 백본 작업과 관련하여 완전한 것은 아니지만 일반적인 방법으로이 방법에 접근하는 방법에 대한 아이디어를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c41ae3592459d184c8cfe8a8c9a865858f7f5834" translate="yes" xml:space="preserve">
          <source>Note that this method is fired on &lt;em&gt;every&lt;/em&gt; render, regardless of the cause. This is in contrast to &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt;, which only fires when the parent causes a re-render and not as a result of a local &lt;code&gt;setState&lt;/code&gt;.</source>
          <target state="translated">이 방법은 원인에 관계없이 &lt;em&gt;모든&lt;/em&gt; 렌더 에서 시작 &lt;em&gt;됩니다&lt;/em&gt; . 이는 &lt;code&gt;UNSAFE_componentWillReceiveProps&lt;/code&gt; 와 달리 , 부모가 로컬 &lt;code&gt;setState&lt;/code&gt; 의 결과가 아닌 다시 렌더링 을 일으킬 때만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="293936fb383c744f2f9630271a7efb4989979625" translate="yes" xml:space="preserve">
          <source>Note that this only works if &lt;code&gt;CustomTextInput&lt;/code&gt; is declared as a class:</source>
          <target state="translated">이는 &lt;code&gt;CustomTextInput&lt;/code&gt; 이 클래스로 선언 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d6de8667681c14632896b78b9f59b00902732f9a" translate="yes" xml:space="preserve">
          <source>Note that we defined both &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt;. Many jQuery plugins attach event listeners to the DOM so it&amp;rsquo;s important to detach them in &lt;code&gt;componentWillUnmount&lt;/code&gt;. If the plugin does not provide a method for cleanup, you will probably have to provide your own, remembering to remove any event listeners the plugin registered to prevent memory leaks.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentWillUnmount&lt;/code&gt; &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;수명주기 메소드를&lt;/a&gt; 모두 정의했습니다 . 많은 jQuery 플러그인은 이벤트 리스너를 DOM에 연결하므로 &lt;code&gt;componentWillUnmount&lt;/code&gt; 에서 분리하는 것이 중요합니다 . 플러그인이 정리 방법을 제공하지 않는 경우, 메모리 누수를 방지하기 위해 플러그인이 등록한 이벤트 리스너를 제거해야한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e7bd878200c78bd50ee3d98b684ecb341171678" translate="yes" xml:space="preserve">
          <source>Note that we pass &lt;code&gt;[]&lt;/code&gt; as a dependency array to &lt;code&gt;useCallback&lt;/code&gt;. This ensures that our ref callback doesn&amp;rsquo;t change between the re-renders, and so React won&amp;rsquo;t call it unnecessarily.</source>
          <target state="translated">우리는 &lt;code&gt;useCallback&lt;/code&gt; 에 &lt;code&gt;[]&lt;/code&gt; 를 의존성 배열로 전달 합니다. 이렇게하면 리퍼 렌더간에 참조 콜백이 변경되지 않으므로 React가 불필요하게 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3da62d793b8e6e725893da6d74020b9b0c1d282" translate="yes" xml:space="preserve">
          <source>Note that you can still choose whether to pass the application &lt;em&gt;state&lt;/em&gt; down as props (more explicit) or as context (more convenient for very deep updates). If you use context to pass down the state too, use two different context types &amp;mdash; the &lt;code&gt;dispatch&lt;/code&gt; context never changes, so components that read it don&amp;rsquo;t need to rerender unless they also need the application state.</source>
          <target state="translated">애플리케이션 &lt;em&gt;상태&lt;/em&gt; 를 props (보다 명시 적) 또는 컨텍스트 (매우 깊은 업데이트에 더 편리)로 전달할 수 있습니다 . 컨텍스트를 사용하여 상태를 전달하는 경우 &lt;code&gt;dispatch&lt;/code&gt; 컨텍스트가 절대 변경되지 않으므로 컨텍스트를 읽는 구성 요소는 응용 프로그램 상태가 필요하지 않은 경우 다시 렌더링 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5438c62ee57f24fd4d0711d668e74ee64c6002c5" translate="yes" xml:space="preserve">
          <source>Note that you cannot call &lt;code&gt;this.setState()&lt;/code&gt; here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; returns.</source>
          <target state="translated">여기서 &lt;code&gt;this.setState()&lt;/code&gt; 호출 할 수는 없습니다 . &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt; 반환 되기 전에 React 구성 요소에 대한 업데이트를 트리거하는 다른 작업 (예 : Redux 작업 디스패치)을 수행해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bcdc977b06fb5be1faf45e2966b7781759aee94" translate="yes" xml:space="preserve">
          <source>Note there are other statically typed languages that compile to JavaScript and are thus React compatible. For example, &lt;a href=&quot;https://fable.io/&quot;&gt;F#/Fable&lt;/a&gt; with &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react&lt;/a&gt;. Check out their respective sites for more information, and feel free to add more statically typed languages that work with React to this page!</source>
          <target state="translated">JavaScript로 컴파일되고 따라서 React와 호환되는 다른 정적으로 형식화 된 언어가 있습니다. 예를 들어 &lt;a href=&quot;https://elmish.github.io/react&quot;&gt;elmish-react가있는 &lt;/a&gt;&lt;a href=&quot;https://fable.io/&quot;&gt;F # / Fable&lt;/a&gt; 입니다 . 자세한 내용은 해당 사이트를 확인하고 React와 함께 작동하는 정적으로 유형이 지정된 언어를 자유롭게 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="04e9b4dc0a682c919374be737463c7b46bbd33ef" translate="yes" xml:space="preserve">
          <source>Note we passed a configuration object to &lt;code&gt;useTransition&lt;/code&gt;. Its &lt;code&gt;timeoutMs&lt;/code&gt; property specifies &lt;strong&gt;how long we&amp;rsquo;re willing to wait for the transition to finish&lt;/strong&gt;. By passing &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt;, we say &amp;ldquo;If the next profile takes more than 3 seconds to load, show the big spinner &amp;mdash; but before that timeout it&amp;rsquo;s okay to keep showing the previous screen&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 에 구성 객체를 전달했습니다 . &lt;code&gt;timeoutMs&lt;/code&gt; 속성 &lt;strong&gt;은 전환&lt;/strong&gt; 이 끝나기 &lt;strong&gt;를 기다릴 시간을&lt;/strong&gt; 지정 &lt;strong&gt;합니다&lt;/strong&gt; . &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; 을 통과 하면 &quot;다음 프로필을로드하는 데 3 초 이상 걸리면 큰 스피너를 표시합니다. 그러나 시간 초과 전에 이전 화면을 계속 표시해도됩니다&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="3d0510089477e2c3202ca52ed149fc2903a72e31" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt; need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.</source>
          <target state="translated">&lt;code&gt;componentDidMount&lt;/code&gt; 와 &lt;code&gt;componentWillUnmount&lt;/code&gt; 가 서로를 미러링 하는 방법에 주목하십시오 . 라이프 사이클 방법을 사용하면 개념적으로 두 코드의 코드가 동일한 효과와 관련되어 있어도이 로직을 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="87bf57ef650f61bb6153e8d1ccb5545722813ea9" translate="yes" xml:space="preserve">
          <source>Notice how we wrapped &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; in an extra &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. This is necessary because Chosen will append another DOM element right after the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; node we passed to it. However, as far as React is concerned, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; always only has a single child. This is how we ensure that React updates won&amp;rsquo;t conflict with the extra DOM node appended by Chosen. It is important that if you modify the DOM outside of React flow, you must ensure React doesn&amp;rsquo;t have a reason to touch those DOM nodes.</source>
          <target state="translated">&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 를 여분의 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 로 감싼 방법에 주목 하십시오 . 이것은 Chosen이 전달한 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 노드 바로 다음에 또 다른 DOM 요소를 추가하기 때문에 필요 합니다. 그러나 React와 관련하여 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에는 항상 하나의 자식 만 있습니다. 이것이 React 업데이트가 Chosen이 추가 한 추가 DOM 노드와 충돌하지 않도록하는 방법입니다. React 플로우 외부에서 DOM을 수정하는 경우 React가 해당 DOM 노드를 만질 이유가 없는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4059c045862b5d2fc7b27115084fa8f80b3c32e" translate="yes" xml:space="preserve">
          <source>Notice how when you type into the input, the &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; component suspends, and we see the &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; fallback until we get fresh results. This is not ideal. It would be better if we could see the &lt;em&gt;previous&lt;/em&gt; translation for a bit while we&amp;rsquo;re fetching the next one.</source>
          <target state="translated">입력 내용을 입력 할 때 &lt;code&gt;&amp;lt;Translation&amp;gt;&lt;/code&gt; 구성 요소가 일시 중단되고 새로운 결과가 나올 때까지 &lt;code&gt;&amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;&lt;/code&gt; 대체가 표시됩니다. 이것은 이상적이지 않습니다. 다음 번역을 가져 오는 동안 &lt;em&gt;이전&lt;/em&gt; 번역을 조금 볼 수 있다면 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e41a0eb10d6b00e47a2107e31a6fe602367acaa9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;this.state.value&lt;/code&gt; is initialized in the constructor, so that the text area starts off with some text in it.</source>
          <target state="translated">것을 알 수 &lt;code&gt;this.state.value&lt;/code&gt; 는 , 생성자에서 초기화는 그래서 텍스트 영역은에 텍스트로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c48101c52bcbacc9cc53778eb2bf3edb99dccc8c" translate="yes" xml:space="preserve">
          <source>Notifying the user of errors</source>
          <target state="translated">사용자에게 오류 알림</target>
        </trans-unit>
        <trans-unit id="c404d41fa7846adb181731741a44bd59410207d8" translate="yes" xml:space="preserve">
          <source>Now React knows that the element with key &lt;code&gt;'2014'&lt;/code&gt; is the new one, and the elements with the keys &lt;code&gt;'2015'&lt;/code&gt; and &lt;code&gt;'2016'&lt;/code&gt; have just moved.</source>
          <target state="translated">이제 React는 &lt;code&gt;'2014'&lt;/code&gt; 키가있는 요소가 새로운 것이며 &lt;code&gt;'2015'&lt;/code&gt; 및 &lt;code&gt;'2016'&lt;/code&gt; 키가있는 요소 가 이제 막 이동 했음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a823d334901d2890efe56f8ef0b2a72eeceac120" translate="yes" xml:space="preserve">
          <source>Now consider the version of this component that uses Hooks:</source>
          <target state="translated">이제 후크를 사용하는이 컴포넌트의 버전을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8183f56b4559e51b16e97bdcb7a1243573a8bd1d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say that our chat application also has a contact list, and we want to render names of online users with a green color. We could copy and paste similar logic above into our &lt;code&gt;FriendListItem&lt;/code&gt; component but it wouldn&amp;rsquo;t be ideal:</source>
          <target state="translated">이제 채팅 애플리케이션에도 연락처 목록이 있으며 온라인 사용자의 이름을 녹색으로 렌더링하려고합니다. 비슷한 로직을 &lt;code&gt;FriendListItem&lt;/code&gt; 컴포넌트에 복사하여 붙여 넣을 수는 있지만 이상적이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="925974ac4f4434d5e39f807c69d3762bcfdfc9e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s say we want to write some logic that changes &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; when the user moves their mouse. Note how we have to merge these fields into the previous state object manually:</source>
          <target state="translated">이제 사용자가 마우스를 움직일 때 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;top&lt;/code&gt; 바뀌는 논리를 작성한다고 가정 해 봅시다 . 이러한 필드를 이전 상태 객체에 수동으로 병합하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="6e4daa5c187fd27dc1d98689209a36560e567ee5" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can do the same with the &lt;code&gt;useEffect&lt;/code&gt; Hook.</source>
          <target state="translated">이제 &lt;code&gt;useEffect&lt;/code&gt; Hook로 어떻게 똑같이 할 수 있는지 봅시다 .</target>
        </trans-unit>
        <trans-unit id="3f0c36b18073d97246d1ae6fdd941d78bd84aa02" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s see how we can use our custom Hook.</source>
          <target state="translated">이제 커스텀 훅을 어떻게 사용할 수 있는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="4ff24b1ed7e4290e5868df543207689b4f4b743a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s turn to the &lt;code&gt;Calculator&lt;/code&gt; component.</source>
          <target state="translated">이제 &lt;code&gt;Calculator&lt;/code&gt; 구성 요소 를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="844b2d5f9df9b2eb6e433eb964cbaab4370de078" translate="yes" xml:space="preserve">
          <source>Now that we know more about effects, these lines should make sense:</source>
          <target state="translated">이제 효과에 대해 더 많이 알았으므로 다음 줄이 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0970d0ace9e4ccf49f5bb229273af5230ad8a4" translate="yes" xml:space="preserve">
          <source>Now that we know what the &lt;code&gt;useState&lt;/code&gt; Hook does, our example should make more sense:</source>
          <target state="translated">이제 &lt;code&gt;useState&lt;/code&gt; Hook가 무엇을하는지 알았으므로 예제가 더 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="8a8788b2f194e8402d2a42fc02e179198bb60d53" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve extracted this logic to a &lt;code&gt;useFriendStatus&lt;/code&gt; hook, we can &lt;em&gt;just use it:&lt;/em&gt;</source>
          <target state="translated">이제이 로직을 &lt;code&gt;useFriendStatus&lt;/code&gt; 후크 로 추출 했으므로 다음 과 같이 사용할 수 있습니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ad30db96883edc2b1c98cb238c68962796e03d5" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve identified the components in our mock, let&amp;rsquo;s arrange them into a hierarchy. Components that appear within another component in the mock should appear as a child in the hierarchy:</source>
          <target state="translated">모의에서 구성 요소를 식별 했으므로 구성 요소를 계층 구조로 정렬하겠습니다. 모의의 다른 구성 요소 내에 나타나는 구성 요소는 계층 구조에서 자식으로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5fb8a97af0340e1169bfb8c33de464ee1f6338c0" translate="yes" xml:space="preserve">
          <source>Now that you have your component hierarchy, it&amp;rsquo;s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It&amp;rsquo;s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We&amp;rsquo;ll see why.</source>
          <target state="translated">이제 컴포넌트 계층 구조를 갖추 었으므로 이제 앱을 구현할 차례입니다. 가장 쉬운 방법은 데이터 모델을 가져와 UI를 렌더링하지만 상호 작용이없는 버전을 작성하는 것입니다. 정적 버전을 작성하려면 많은 타이핑과 사고가 필요하지 않으며 상호 작용을 추가하려면 많은 타이핑이 아닌 많은 사고가 필요하므로 이러한 프로세스를 분리하는 것이 가장 좋습니다. 우리는 이유를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48ab459928ce6ebd5489677a0e93ec9929ee70a3" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component encapsulates all behavior associated with listening for &lt;code&gt;mousemove&lt;/code&gt; events and storing the (x, y) position of the cursor, but it&amp;rsquo;s not yet truly reusable.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 구성 요소는 &lt;code&gt;mousemove&lt;/code&gt; 이벤트 수신 및 커서의 (x, y) 위치 저장과 관련된 모든 동작을 캡슐화 하지만 아직 재사용 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8290d2b0cd763be0c1cff68b5b8f6a2022e9e2e1" translate="yes" xml:space="preserve">
          <source>Now the clock ticks every second.</source>
          <target state="translated">이제 시계가 1 초마다 틱합니다.</target>
        </trans-unit>
        <trans-unit id="445b4c42d80c61abe526efe3707111a846581295" translate="yes" xml:space="preserve">
          <source>Now the question is: How can we reuse this behavior in another component? In other words, if another component needs to know about the cursor position, can we encapsulate that behavior so that we can easily share it with that component?</source>
          <target state="translated">이제 문제는 : 다른 컴포넌트에서이 동작을 어떻게 재사용 할 수 있습니까? 다시 말해, 다른 구성 요소가 커서 위치에 대해 알아야 할 경우 해당 구성 요소와 쉽게 공유 할 수 있도록 해당 동작을 캡슐화 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1024ae8f19583bac76078bc0bd6540db20a2ec73" translate="yes" xml:space="preserve">
          <source>Now the subscription will only be recreated when &lt;code&gt;props.source&lt;/code&gt; changes.</source>
          <target state="translated">이제 &lt;code&gt;props.source&lt;/code&gt; 가 변경 될 때만 구독이 다시 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="54d03c366729e2d81c1e64f36f6b07756f996b09" translate="yes" xml:space="preserve">
          <source>Now typing has a lot less stutter &amp;mdash; although we pay for this by showing the results with a lag.</source>
          <target state="translated">이제 타이핑이 훨씬 쉬워졌지만 결과는 지연되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dcc5b4606d16f6fd9f79e37463ac776146ee84f2" translate="yes" xml:space="preserve">
          <source>Now we can use it from both components:</source>
          <target state="translated">이제 두 구성 요소 모두에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb51804f6cb1c7460d60f186cd080f9b9a70bf5" translate="yes" xml:space="preserve">
          <source>Now we could use it in our component, and let the reducer drive its state management:</source>
          <target state="translated">이제 컴포넌트에서이를 사용할 수 있고 리듀서가 상태 관리를 주도하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe952474b56ef3cb4e5c17adcf45971d3250970" translate="yes" xml:space="preserve">
          <source>Now you can use JSX in any &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag by adding &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attribute to it. Here is &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;an example HTML file with JSX&lt;/a&gt; that you can download and play with.</source>
          <target state="translated">이제 &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; 속성을 추가하여 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 에서 JSX를 사용할 수 있습니다 . 다음은 다운로드하여 재생할 수 &lt;a href=&quot;https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html&quot;&gt;있는 JSX&lt;/a&gt; 가 포함 된 HTML 파일의 예 입니다.</target>
        </trans-unit>
        <trans-unit id="8ad6204428141993d5d0c80a5aa20caa71f41e56" translate="yes" xml:space="preserve">
          <source>Now you know what Concurrent Mode is all about!</source>
          <target state="translated">이제 동시 모드가 무엇인지 알았습니다!</target>
        </trans-unit>
        <trans-unit id="a0921c0c4a9937c51a84cd82cfb41ca7387c23e1" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;re all set! We recommend to check out the following resources to learn more about Flow:</source>
          <target state="translated">이제 모두 준비되었습니다! 흐름에 대해 자세히 알아 보려면 다음 리소스를 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a49e11731f8fb793b2ecb4306067e3e3083ea67" translate="yes" xml:space="preserve">
          <source>Now, add &lt;code&gt;flow&lt;/code&gt; to the &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; section of your &lt;code&gt;package.json&lt;/code&gt; to be able to use this from the terminal:</source>
          <target state="translated">이제 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 섹션에 &lt;code&gt;flow&lt;/code&gt; 를 추가 하여 터미널에서이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8086f34489af74ae217e4df5aa3be615d57812e" translate="yes" xml:space="preserve">
          <source>Now, instead of effectively cloning the &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component and hard-coding something else in its &lt;code&gt;render&lt;/code&gt; method to solve for a specific use case, we provide a &lt;code&gt;render&lt;/code&gt; prop that &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; can use to dynamically determine what it renders.</source>
          <target state="translated">이제 특정 사용 사례를 해결하기 위해 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 구성 요소 를 효과적으로 복제 하고 &lt;code&gt;render&lt;/code&gt; 방법으로 다른 것을 하드 코딩 하는 대신 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 가 렌더링 내용을 동적으로 결정하는 데 사용할 수 있는 &lt;code&gt;render&lt;/code&gt; 소품을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2f73936a74018552ceacc64aa326e02fb6cf0a5b" translate="yes" xml:space="preserve">
          <source>Now, no matter which input you edit, &lt;code&gt;this.state.temperature&lt;/code&gt; and &lt;code&gt;this.state.scale&lt;/code&gt; in the &lt;code&gt;Calculator&lt;/code&gt; get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</source>
          <target state="translated">이제, 편집, 입력에 상관없이 &lt;code&gt;this.state.temperature&lt;/code&gt; 및 &lt;code&gt;this.state.scale&lt;/code&gt; 에 &lt;code&gt;Calculator&lt;/code&gt; 업데이트됩니다. 입력 중 하나는 그대로 값을 가져 오므로 모든 사용자 입력이 유지되고 다른 입력 값은이를 기준으로 항상 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="301eea1e7c8206fb45c541acd3e524bf4a699d97" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;setInterval&lt;/code&gt; callback executes once a second, but each time the inner call to &lt;code&gt;setCount&lt;/code&gt; can use an up-to-date value for &lt;code&gt;count&lt;/code&gt; (called &lt;code&gt;c&lt;/code&gt; in the callback here.)</source>
          <target state="translated">이제 &lt;code&gt;setInterval&lt;/code&gt; 콜백이 1 초에 한 번 실행되지만 &lt;code&gt;setCount&lt;/code&gt; 에 대한 내부 호출이 &lt;code&gt;count&lt;/code&gt; 대한 최신 값을 사용할 수 있습니다 ( 여기서는 콜백에서 &lt;code&gt;c&lt;/code&gt; 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="9e8130cbd3e360ebc980c05ecf896eace815977b" translate="yes" xml:space="preserve">
          <source>Now, this feels a lot better! When we click Next, it gets disabled because clicking it multiple times doesn&amp;rsquo;t make sense. And the new &amp;ldquo;Loading&amp;hellip;&amp;rdquo; tells the user that the app didn&amp;rsquo;t freeze.</source>
          <target state="translated">자, 이것은 훨씬 나아졌습니다! 다음을 클릭하면 여러 번 클릭해도 의미가 없으므로 비활성화됩니다. 그리고 새로운&amp;ldquo;Loading&amp;hellip;&amp;rdquo;은 사용자에게 앱이 멈추지 않았다는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b0f788b2b09588e404d0447b39bd5c7c761184f0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;TemperatureInput&lt;/code&gt; wants to update its temperature, it calls &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;TemperatureInput&lt;/code&gt; 이 온도 를 업데이트하려고 할 때 &lt;code&gt;this.props.onTemperatureChange&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e7446f170a663a7c78e802aab1ac1a7cb9040dd" translate="yes" xml:space="preserve">
          <source>OK, so we&amp;rsquo;ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or &lt;em&gt;owns&lt;/em&gt;, this state.</source>
          <target state="translated">이제 앱 상태의 최소 집합이 무엇인지 확인했습니다. 다음으로 어떤 구성 요소 가이 상태를 변경하거나 &lt;em&gt;소유&lt;/em&gt; 하는지 식별해야합니다 .</target>
        </trans-unit>
        <trans-unit id="585a7418eed63f477ec8bd53089988cc7e4a12c6" translate="yes" xml:space="preserve">
          <source>Of course, application UIs are dynamic and change over time. In the &lt;a href=&quot;state-and-lifecycle&quot;&gt;next section&lt;/a&gt;, we will introduce a new concept of &amp;ldquo;state&amp;rdquo;. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</source>
          <target state="translated">물론 응용 프로그램 UI는 동적이며 시간이 지남에 따라 변경됩니다. 에서 &lt;a href=&quot;state-and-lifecycle&quot;&gt;다음 섹션&lt;/a&gt; , 우리는 &quot;상태&quot;의 새로운 개념을 소개합니다. 상태는 React 구성 요소가이 규칙을 위반하지 않고 사용자 조치, 네트워크 응답 및 기타 다른 것에 응답하여 시간이 지남에 따라 출력을 변경할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3132cb0b79eb69074dc3e62af86660efd5589630" translate="yes" xml:space="preserve">
          <source>Of course, this is possible to fix in this particular example. We could remove the &lt;code&gt;Promise.all()&lt;/code&gt; call, and wait for both Promises separately. However, this approach gets progressively more difficult as the complexity of our data and component tree grows. It&amp;rsquo;s hard to write reliable components when arbitrary parts of the data tree may be missing or stale. So fetching all data for the new screen and &lt;em&gt;then&lt;/em&gt; rendering is often a more practical option.</source>
          <target state="translated">물론, 이것은이 특정 예에서 고칠 수 있습니다. &lt;code&gt;Promise.all()&lt;/code&gt; 호출을 제거하고 두 약속을 별도로 기다릴 수 있습니다. 그러나이 접근 방식은 데이터 및 구성 요소 트리의 복잡성이 증가함에 따라 점차 어려워집니다. 데이터 트리의 임의의 부분이 없거나 오래되었을 경우 신뢰할 수있는 구성 요소를 작성하기가 어렵습니다. 새 화면에 대한 모든 데이터를 가져 오는 그래서 &lt;em&gt;다음&lt;/em&gt; 렌더링 종종 더 실용적인 선택지입니다.</target>
        </trans-unit>
        <trans-unit id="a4a2711c46e947081b52625c85320ddf4541e19b" translate="yes" xml:space="preserve">
          <source>Of course, two versions of the tree rendering &lt;em&gt;at the same time&lt;/em&gt; is an illusion, just like the idea that all programs run on your computer at the same time is an illusion. An operating system switches between different applications very fast. Similarly, React can switch between the version of the tree you see on the screen and the version that it&amp;rsquo;s &amp;ldquo;preparing&amp;rdquo; to show next.</source>
          <target state="translated">물론, 나무 렌더링의 두 가지 버전 &lt;em&gt;을 동시에는&lt;/em&gt; 바로 같은 시간에 컴퓨터에서 실행되는 모든 프로그램은 환상이라는 생각처럼, 환상입니다. 운영 체제는 다른 응용 프로그램간에 매우 빠르게 전환됩니다. 마찬가지로 React는 화면에 표시되는 트리 버전과 다음에 표시 할 &quot;준비&quot;버전 사이를 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6825e0a32d926930eddf56f84b2970fa58fb08" translate="yes" xml:space="preserve">
          <source>Of the many options, we&amp;rsquo;ll look at &lt;code&gt;rootDir&lt;/code&gt; and &lt;code&gt;outDir&lt;/code&gt;. In its true fashion, the compiler will take in typescript files and generate javascript files. However we don&amp;rsquo;t want to get confused with our source files and the generated output.</source>
          <target state="translated">많은 옵션 중에서 우리는 &lt;code&gt;rootDir&lt;/code&gt; 과 &lt;code&gt;outDir&lt;/code&gt; 을 살펴볼 것 입니다. 진정한 방식으로, 컴파일러는 타입 스크립트 파일을 가져 와서 자바 스크립트 파일을 생성합니다. 그러나 소스 파일 및 생성 된 출력과 혼동되기를 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd20357e3644302dde97b2ad62dcb95ce1daedfd" translate="yes" xml:space="preserve">
          <source>Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to &lt;code&gt;useEffect&lt;/code&gt; may return a clean-up function. For example, to create a subscription:</source>
          <target state="translated">종종 효과는 구독 또는 타이머 ID와 같이 구성 요소가 화면을 떠나기 전에 정리해야하는 리소스를 만듭니다. 이를 위해 &lt;code&gt;useEffect&lt;/code&gt; 에 전달 된 함수 가 정리 함수를 리턴 할 수 있습니다. 예를 들어, 구독을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2eb2d11868ae24a92e334900c6ad022490e23cc8" translate="yes" xml:space="preserve">
          <source>Often, render props and higher-order components render only a single child. We think Hooks are a simpler way to serve this use case. There is still a place for both patterns (for example, a virtual scroller component might have a &lt;code&gt;renderItem&lt;/code&gt; prop, or a visual container component might have its own DOM structure). But in most cases, Hooks will be sufficient and can help reduce nesting in your tree.</source>
          <target state="translated">종종 렌더 소품과 고차 컴포넌트는 하나의 자식 만 렌더링합니다. 우리는 Hooks가이 사용 사례를 처리하는 가장 간단한 방법이라고 생각합니다. 여전히 두 패턴 모두에 대한 위치가 있습니다 (예 : 가상 스크롤러 구성 요소에 &lt;code&gt;renderItem&lt;/code&gt; 소품이 있거나 시각적 컨테이너 구성 요소에 고유 한 DOM 구조가있을 수 있음). 그러나 대부분의 경우 후크는 충분하며 트리의 중첩을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e238d62aafad5d06561c0c307e341349b7b49d0a" translate="yes" xml:space="preserve">
          <source>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let&amp;rsquo;s see how this works in action.</source>
          <target state="translated">종종 여러 구성 요소가 동일한 변경 데이터를 반영해야합니다. 공유 상태를 가장 가까운 공통 조상까지 올리는 것이 좋습니다. 이것이 어떻게 작동하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="2a50db4683ea185c93852b3e2a65a8212128837a" translate="yes" xml:space="preserve">
          <source>On Node.js, runners like Jest &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;support mocking modules&lt;/a&gt;. You could also use libraries like &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt;&lt;code&gt;mock-require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Node.js에서 Jest와 같은 러너는 &lt;a href=&quot;https://jestjs.io/docs/en/manual-mocks&quot;&gt;모의 모듈을 지원합니다&lt;/a&gt; . &lt;a href=&quot;https://www.npmjs.com/package/mock-require&quot;&gt; &lt;code&gt;mock-require&lt;/code&gt; &lt;/a&gt; 와 같은 라이브러리를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0710c7b04d45a11f0492b116459fb4abc9eedba3" translate="yes" xml:space="preserve">
          <source>On mount, add a change listener to &lt;code&gt;DataSource&lt;/code&gt;.</source>
          <target state="translated">마운트시 변경 리스너를 &lt;code&gt;DataSource&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="82c91bbc6306c5630c222b9dcf2187c2dc2ae099" translate="yes" xml:space="preserve">
          <source>On the next pages, you&amp;rsquo;ll learn more details about specific topics:</source>
          <target state="translated">다음 페이지에서 특정 주제에 대한 자세한 내용을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="9d62e4f730620eef1f3de85e2d6c3131a9b4dfea" translate="yes" xml:space="preserve">
          <source>On this page we&amp;rsquo;ve learned about one of the Hooks provided by React, called &lt;code&gt;useState&lt;/code&gt;. We&amp;rsquo;re also sometimes going to refer to it as the &amp;ldquo;State Hook&amp;rdquo;. It lets us add local state to React function components &amp;mdash; which we did for the first time ever!</source>
          <target state="translated">이 페이지에서 React가 제공하는 후크 중 하나 인 &lt;code&gt;useState&lt;/code&gt; 에 대해 배웠습니다 . 우리는 때때로 이것을&amp;ldquo;상태 후크&amp;rdquo;라고도합니다. 이를 통해 React 함수 컴포넌트에 로컬 상태를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c2cd7a4d0e65ff37df2b337e658e2df9075d64a" translate="yes" xml:space="preserve">
          <source>On this page, we don&amp;rsquo;t assume knowledge of Relay, so we won&amp;rsquo;t be using it for this example. Instead, we&amp;rsquo;ll write something similar manually by combining our data fetching methods:</source>
          <target state="translated">이 페이지에서는 Relay에 대한 지식이 없다고 가정하므로이 예제에서는 사용하지 않을 것입니다. 대신 데이터 가져 오기 방법을 결합하여 비슷한 것을 수동으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="fb59abe30c04acfe966b6c95ce457faf73c79f0f" translate="yes" xml:space="preserve">
          <source>On this page, we will primarily use function components. However, these testing strategies don&amp;rsquo;t depend on implementation details, and work just as well for class components too.</source>
          <target state="translated">이 페이지에서는 주로 기능 구성 요소를 사용합니다. 그러나 이러한 테스트 전략은 구현 세부 사항에 의존하지 않으며 클래스 구성 요소에 대해서도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4d9354d5334212c4fa7c510917e4a36aa72a9176" translate="yes" xml:space="preserve">
          <source>On unmount, remove the change listener.</source>
          <target state="translated">마운트 해제시 변경 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="06dfbc05cf68b1af9ef7e3eb0c666319a41ff504" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re comfortable with the &lt;a href=&quot;index&quot;&gt;main concepts&lt;/a&gt; and played with React a little bit, you might be interested in more advanced topics. This section will introduce you to the powerful, but less commonly used React features like &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; and &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;주요 개념에&lt;/a&gt; 익숙하고 React와 약간 연주하면 고급 주제에 관심이있을 수 있습니다. 이 섹션에서는 &lt;a href=&quot;context&quot;&gt;context&lt;/a&gt; 및 &lt;a href=&quot;refs-and-the-dom&quot;&gt;refs&lt;/a&gt; 와 같이 강력하지만 덜 일반적으로 사용되는 React 기능을 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="26db98adea48b68a169ca2de0e843e2459313e88" translate="yes" xml:space="preserve">
          <source>One caveat is that some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&amp;ldquo;falsy&amp;rdquo; values&lt;/a&gt;, such as the &lt;code&gt;0&lt;/code&gt; number, are still rendered by React. For example, this code will not behave as you might expect because &lt;code&gt;0&lt;/code&gt; will be printed when &lt;code&gt;props.messages&lt;/code&gt; is an empty array:</source>
          <target state="translated">한 가지주의 사항은 &lt;code&gt;0&lt;/code&gt; 숫자 와 같은 일부 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Falsy&quot;&gt;&quot;거짓&quot;값&lt;/a&gt; 은 여전히 ​​React에 의해 렌더링된다는 것입니다. 예를 들어 &lt;code&gt;props.messages&lt;/code&gt; 가 빈 배열 &lt;code&gt;0&lt;/code&gt; 이 인쇄 되므로이 코드는 예상대로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="92d29f167487a4fbbd927e887cecef3d212e829f" translate="yes" xml:space="preserve">
          <source>One common confusion is that Web Components use &amp;ldquo;class&amp;rdquo; instead of &amp;ldquo;className&amp;rdquo;.</source>
          <target state="translated">하나의 일반적인 혼란은 웹 구성 요소가 &quot;className&quot;대신 &quot;class&quot;를 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d84c92ddc298e496ea4adc3bf91cf1363cd458a5" translate="yes" xml:space="preserve">
          <source>One common use case is a component wanting to update itself on a time interval. It&amp;rsquo;s easy to use &lt;code&gt;setInterval()&lt;/code&gt;, but it&amp;rsquo;s important to cancel your interval when you don&amp;rsquo;t need it anymore to save memory. React provides &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;lifecycle methods&lt;/a&gt; that let you know when a component is about to be created or destroyed. Let&amp;rsquo;s create a simple mixin that uses these methods to provide an easy &lt;code&gt;setInterval()&lt;/code&gt; function that will automatically get cleaned up when your component is destroyed.</source>
          <target state="translated">일반적인 유스 케이스는 시간 간격으로 자체 업데이트하려는 구성 요소입니다. &lt;code&gt;setInterval()&lt;/code&gt; 을 사용하는 것은 쉽지만 메모리를 절약하기 위해 더 이상 필요하지 않은 경우 간격을 취소하는 것이 중요합니다. React는 구성 요소가 작성되거나 파괴 될시기를 알려주 는 &lt;a href=&quot;react-component#the-component-lifecycle&quot;&gt;라이프 사이클 방법&lt;/a&gt; 을 제공합니다 . 이러한 메소드를 사용 하여 컴포넌트가 파괴 될 때 자동으로 정리 되는 쉬운 &lt;code&gt;setInterval()&lt;/code&gt; 함수 를 제공하는 간단한 믹스 인을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="91fca79071097d684ed292ccb8f4ce6e063eb595" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="translated">프로젝트를 구성하는 일반적인 방법 중 하나는 CSS, JS를 찾고 기능 또는 경로별로 그룹화 된 폴더 내에서 함께 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eecfa7e254d87da6b100134e8a7e164ed183eec7" translate="yes" xml:space="preserve">
          <source>One common way to structure projects is to locate CSS, JS, and tests together inside folders grouped by feature or route.</source>
          <target state="translated">One common way to structure projects is to locate CSS, JS, and tests together inside folders grouped by feature or route.</target>
        </trans-unit>
        <trans-unit id="3294950b9d1114486b86edac639fe247ba41031e" translate="yes" xml:space="preserve">
          <source>One interesting thing to note about render props is that you can implement most &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (HOC) using a regular component with a render prop. For example, if you would prefer to have a &lt;code&gt;withMouse&lt;/code&gt; HOC instead of a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component, you could easily create one using a regular &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a render prop:</source>
          <target state="translated">렌더 소품에 대해 주목해야 할 흥미로운 점은 렌더 소품 과 함께 일반 구성 요소를 사용하여 대부분의 &lt;a href=&quot;higher-order-components&quot;&gt;상위 구성 요소&lt;/a&gt; (HOC)를 구현할 수 있다는 것 입니다. 예를 들어 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 컴포넌트 대신 &lt;code&gt;withMouse&lt;/code&gt; HOC를 사용 하려면 render prop과 함께 일반 &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; 를 사용하여 쉽게 컴포넌트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89bb7b23e1cfb796ff7ccb3c5631654a6d5d4429" translate="yes" xml:space="preserve">
          <source>One might confuse elements with a more widely known concept of &amp;ldquo;components&amp;rdquo;. We will introduce components in the &lt;a href=&quot;components-and-props&quot;&gt;next section&lt;/a&gt;. Elements are what components are &amp;ldquo;made of&amp;rdquo;, and we encourage you to read this section before jumping ahead.</source>
          <target state="translated">보다 널리 알려진 &quot;구성 요소&quot;개념과 요소를 혼동 할 수 있습니다. &lt;a href=&quot;components-and-props&quot;&gt;다음 섹션&lt;/a&gt; 에서 컴포넌트를 소개 합니다 . 구성 요소는 구성 요소로 구성되는 요소이므로 앞으로 이동하기 전에이 섹션을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7588b233fbe6695c0a65bfe0ca7544cc4e57a4ac" translate="yes" xml:space="preserve">
          <source>One might think that this is a problem specific to &lt;code&gt;useEffect&lt;/code&gt; or Hooks. Maybe if we port this code to classes or use convenient syntax like &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;, it will solve the problem?</source>
          <target state="translated">이것이 &lt;code&gt;useEffect&lt;/code&gt; 또는 후크 를 사용하는 데 특정한 문제라고 생각할 수도 있습니다 . 이 코드를 클래스로 이식하거나 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 와 같은 편리한 구문을 사용 하면 문제가 해결 될까요?</target>
        </trans-unit>
        <trans-unit id="c0f348c5b745ab1da4b86972cf956fe2d397217e" translate="yes" xml:space="preserve">
          <source>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we&amp;rsquo;ll walk you through the thought process of building a searchable product data table using React.</source>
          <target state="translated">React의 많은 장점 중 하나는 앱을 빌드 할 때 앱에 대해 어떻게 생각하는지입니다. 이 문서에서는 React를 사용하여 검색 가능한 제품 데이터 테이블을 작성하는 사고 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7ac2374e3473c6ff21b1231d986c7761ceb4980d" translate="yes" xml:space="preserve">
          <source>One of the problems we outlined in the &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;Motivation&lt;/a&gt; for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:</source>
          <target state="translated">우리가 후크 에 대한 &lt;a href=&quot;hooks-intro#complex-components-become-hard-to-understand&quot;&gt;동기 부여&lt;/a&gt; 에서 설명한 문제점 중 하나는 클래스 라이프 사이클 메소드에 종종 관련없는 로직이 포함되지만 관련 로직이 여러 메소드로 분리된다는 것입니다. 다음은 이전 예의 카운터와 친구 상태 표시기 논리를 결합한 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a418baabb2a2970b5f712a2f3fec059c69ada5c1" translate="yes" xml:space="preserve">
          <source>One possible solution to this is to &lt;em&gt;delay the spinner itself&lt;/em&gt; from displaying:</source>
          <target state="translated">이에 대한 한 가지 가능한 해결책 &lt;em&gt;은 스피너 자체&lt;/em&gt; 의 표시 를 &lt;em&gt;지연시키는 것&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b271b0f7d1b61e9056e53697bfa59e66ec53dabf" translate="yes" xml:space="preserve">
          <source>One rudimentary way to measure the position or size of a DOM node is to use a &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;callback ref&lt;/a&gt;. React will call that callback whenever the ref gets attached to a different node. Here is a &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;small demo&lt;/a&gt;:</source>
          <target state="translated">DOM 노드의 위치 또는 크기를 측정하는 기본적인 방법 중 하나는 &lt;a href=&quot;refs-and-the-dom#callback-refs&quot;&gt;콜백 ref&lt;/a&gt; 를 사용하는 것 입니다. React는 참조가 다른 노드에 연결될 때마다 해당 콜백을 호출합니다. 다음은 &lt;a href=&quot;https://codesandbox.io/s/l7m0v5x4v9&quot;&gt;작은 데모입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fa8706f6009f63753c15a5df17eaaa0d7f204a0" translate="yes" xml:space="preserve">
          <source>One solution to this is to extract the model&amp;rsquo;s attributes as plain data whenever it changes, and keep this logic in a single place. The following is &lt;a href=&quot;higher-order-components&quot;&gt;a higher-order component&lt;/a&gt; that extracts all attributes of a Backbone model into state, passing the data to the wrapped component.</source>
          <target state="translated">이에 대한 한 가지 해결책은 모델 속성이 변경 될 때마다 일반 데이터로 추출하고이 논리를 한 곳에 유지하는 것입니다. 다음은 백본 모델의 모든 속성을 상태로 추출하여 데이터를 랩핑 된 구성 요소에 전달 &lt;a href=&quot;higher-order-components&quot;&gt;하는 상위&lt;/a&gt; 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="58b79eb7fa7ae8bb13eed6fa689b5ce8ed867366" translate="yes" xml:space="preserve">
          <source>One way to solve this issue &lt;strong&gt;without context&lt;/strong&gt; is to &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;pass down the &lt;code&gt;Avatar&lt;/code&gt; component itself&lt;/a&gt; so that the intermediate components don&amp;rsquo;t need to know about the &lt;code&gt;user&lt;/code&gt; or &lt;code&gt;avatarSize&lt;/code&gt; props:</source>
          <target state="translated">&lt;strong&gt;컨텍스트없이이&lt;/strong&gt; 문제를 해결하는 한 가지 방법 &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;은 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소 자체&lt;/a&gt; 를 전달 하여 중간 구성 요소가 &lt;code&gt;user&lt;/code&gt; 또는 &lt;code&gt;avatarSize&lt;/code&gt; 소품에 대해 알 필요가 없도록하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c6299e6ee53c4fc7bdfb602433272b7a519918fc" translate="yes" xml:space="preserve">
          <source>One way we could fix it is by putting them both in a single boundary:</source>
          <target state="translated">우리가 고칠 수있는 한 가지 방법은 둘 다 하나의 경계에 두는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c05b9709100b2a39470a0603a95728131ccfa2e0" translate="yes" xml:space="preserve">
          <source>Online Playgrounds</source>
          <target state="translated">온라인 운동장</target>
        </trans-unit>
        <trans-unit id="68c313b91ba43cdce9e6230021dd3cc44332356e" translate="yes" xml:space="preserve">
          <source>Only Call Hooks at the Top Level</source>
          <target state="translated">최상위 수준에서만 전화 걸기</target>
        </trans-unit>
        <trans-unit id="980e73ef860f23909c36445661b606d8b3e93697" translate="yes" xml:space="preserve">
          <source>Only Call Hooks from React Functions</source>
          <target state="translated">반응 함수의 콜 후크 만</target>
        </trans-unit>
        <trans-unit id="5acf9b36b7f149f65b12a00c58b688239df37660" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;at the top level&lt;/strong&gt;. Don&amp;rsquo;t call Hooks inside loops, conditions, or nested functions.</source>
          <target state="translated">&lt;strong&gt;최상위 레벨&lt;/strong&gt; 에서만 후크 &lt;strong&gt;를&lt;/strong&gt; 호출 &lt;strong&gt;하십시오&lt;/strong&gt; . 루프, 조건 또는 중첩 함수 내부에서 후크를 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c8bacc2bc0cd7f69fa0df071e2e600234a8896fe" translate="yes" xml:space="preserve">
          <source>Only call Hooks &lt;strong&gt;from React function components&lt;/strong&gt;. Don&amp;rsquo;t call Hooks from regular JavaScript functions. (There is just one other valid place to call Hooks &amp;mdash; your own custom Hooks. We&amp;rsquo;ll learn about them in a moment.)</source>
          <target state="translated">&lt;strong&gt;React 함수 구성 요소의&lt;/strong&gt; 후크 만 호출하십시오 . 일반 JavaScript 함수에서 후크를 호출하지 마십시오. 후크를 호출 할 수있는 다른 유효한 장소가 있습니다. 사용자 정의 후크입니다. 잠시 후에 이들에 대해 알아볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="78f87a20c05bef10c0fc20bc0609245bc0128bed" translate="yes" xml:space="preserve">
          <source>Only do this if you couldn&amp;rsquo;t find a better alternative, as relying on mutation makes components less predictable. If there&amp;rsquo;s a specific pattern that doesn&amp;rsquo;t translate well, &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;file an issue&lt;/a&gt; with a runnable example code and we can try to help.</source>
          <target state="translated">돌연변이에 의존하면 성분을 예측하기 어렵게하므로 더 나은 대안을 찾을 수없는 경우에만이 방법을 사용하십시오. 잘 번역되지 않는 특정 패턴이 있는 경우 실행 가능한 예제 코드 &lt;a href=&quot;https://github.com/facebook/react/issues/new&quot;&gt;로 문제&lt;/a&gt; 를 제기 하면 도와 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="c28575a6029fc70e57860e000b695cc6f0b3e57e" translate="yes" xml:space="preserve">
          <source>Only ever use CSS that removes this outline, for example by setting &lt;code&gt;outline: 0&lt;/code&gt;, if you are replacing it with another focus outline implementation.</source>
          <target state="translated">예를 들어 다른 포커스 아웃 라인 구현으로 바꾸는 경우 &lt;code&gt;outline: 0&lt;/code&gt; 을 설정하여이 아웃 라인을 제거하는 CSS 만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7322dbc7cc37c39174edd21f985b523446462851" translate="yes" xml:space="preserve">
          <source>Only use error boundaries for recovering from unexpected exceptions; &lt;strong&gt;don&amp;rsquo;t try to use them for control flow.&lt;/strong&gt;</source>
          <target state="translated">예기치 않은 예외를 복구 할 때는 오류 경계 만 사용하십시오. &lt;strong&gt;제어 흐름에 사용하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b1b25a5af502c4955acf005be6d083dc1a30602" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;this example&lt;/a&gt;. When you press a button, you&amp;rsquo;ll see the Pending state for a second before moving on. This transition feels nice and fluid.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/nameless-butterfly-fkw5q&quot;&gt;이 예제를&lt;/a&gt; 엽니 다 . 버튼을 누르면 1 초 동안 보류 상태가 표시됩니다. 이 전환은 훌륭하고 유동적입니다.</target>
        </trans-unit>
        <trans-unit id="82faec880ab06096a12df754c31b316dbff6580b" translate="yes" xml:space="preserve">
          <source>Open &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;this example&lt;/a&gt; and click &amp;ldquo;Open Profile&amp;rdquo;. You will see several visual states one by one:</source>
          <target state="translated">열 &lt;a href=&quot;https://codesandbox.io/s/prod-grass-g1lh5&quot;&gt;이 예제를&lt;/a&gt; 하고 &quot;열기 프로필&quot;을 클릭합니다. 여러 가지 시각적 상태가 하나씩 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f911658ce7d859922d5257b0b036abe5292fca9b" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;this starter code&lt;/a&gt;&lt;/strong&gt; and paste it into the file you created.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://gist.github.com/gaearon/0b180827c190fe4fd98b4c7f570ea4a8/raw/b9157ce933c79a4559d2aa9ff3372668cce48de7/LikeButton.js&quot;&gt;이 시작 코드를&lt;/a&gt;&lt;/strong&gt; 열고 작성한 파일에 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="55d9ece27ec32d8829711be1a1d3afea9c2dafd2" translate="yes" xml:space="preserve">
          <source>Open the Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;Performance&lt;/a&gt;&lt;/strong&gt; tab and press &lt;strong&gt;Record&lt;/strong&gt;.</source>
          <target state="translated">Chrome DevTools &lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool&quot;&gt;성능&lt;/a&gt;&lt;/strong&gt; 탭을 열고 &lt;strong&gt;기록을&lt;/strong&gt; 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="a45e17e011c01ffe2a91ced4f7a209475dd8d2a0" translate="yes" xml:space="preserve">
          <source>Optimizing Performance</source>
          <target state="translated">성능 최적화</target>
        </trans-unit>
        <trans-unit id="db92a3f80d780ad79d58ccf80d95c08e0583866f" translate="yes" xml:space="preserve">
          <source>Optimizing the output for production.</source>
          <target state="translated">생산을위한 출력 최적화</target>
        </trans-unit>
        <trans-unit id="ebed446427427efeada77fb1de8555c343d3531f" translate="yes" xml:space="preserve">
          <source>Opting into Concurrent Mode introduces semantic changes to how React works. This means that you can&amp;rsquo;t use Concurrent Mode in just a few components. Because of this, some apps may not be able to migrate directly to Concurrent Mode.</source>
          <target state="translated">동시 모드를 선택하면 React 작동 방식에 의미가 변경됩니다. 즉, 몇 가지 구성 요소에서만 동시 모드를 사용할 수 없습니다. 이로 인해 일부 앱은 동시 모드로 직접 마이그레이션하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6793ee41543d3424f0cf56f0cf4f4c5c5d0813" translate="yes" xml:space="preserve">
          <source>Optional: &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;Download the full example (2KB zipped)&lt;/a&gt;</source>
          <target state="translated">선택 사항 : &lt;a href=&quot;https://gist.github.com/gaearon/6668a1f6986742109c00a581ce704605/archive/f6c882b6ae18bde42dcf6fdb751aae93495a2275.zip&quot;&gt;전체 예제 다운로드 (2KB 압축)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee3267798d0259e5dd98aa26c31e33223e26cac3" translate="yes" xml:space="preserve">
          <source>Optional: Try React with JSX</source>
          <target state="translated">선택 사항 : JSX로 반응 시도</target>
        </trans-unit>
        <trans-unit id="3a09e35972dfc007bcd7aa10e05cf800743e8354" translate="yes" xml:space="preserve">
          <source>Or yarn:</source>
          <target state="translated">또는 털실 :</target>
        </trans-unit>
        <trans-unit id="160496746ed70b43025c17e2f2433373eef18b6a" translate="yes" xml:space="preserve">
          <source>Other APIs</source>
          <target state="translated">다른 API</target>
        </trans-unit>
        <trans-unit id="1b361bfb2d40f2fa584dfe16d7abd56931268577" translate="yes" xml:space="preserve">
          <source>Other Build Setups</source>
          <target state="translated">다른 빌드 설정</target>
        </trans-unit>
        <trans-unit id="718591843f9ba65a328acf7e21cfb68fa2042427" translate="yes" xml:space="preserve">
          <source>Other Events</source>
          <target state="translated">기타 행사</target>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="translated">다른 언어</target>
        </trans-unit>
        <trans-unit id="b1866d3283a2c6b4f31b7bd94d302109ad919e6f" translate="yes" xml:space="preserve">
          <source>Other Patterns</source>
          <target state="translated">다른 패턴</target>
        </trans-unit>
        <trans-unit id="670876f3113d937960727ed05a2f82e686590502" translate="yes" xml:space="preserve">
          <source>Other Points for Consideration</source>
          <target state="translated">고려해야 할 기타 사항</target>
        </trans-unit>
        <trans-unit id="c8298a228f42e1a844433af47c0c496b7ae9065b" translate="yes" xml:space="preserve">
          <source>Other Screen Readers</source>
          <target state="translated">다른 스크린 리더</target>
        </trans-unit>
        <trans-unit id="a6a3346524b28d21d18a28316c1731fc127a349f" translate="yes" xml:space="preserve">
          <source>Other Utilities</source>
          <target state="translated">다른 유틸리티</target>
        </trans-unit>
        <trans-unit id="4715125742dd4e459dcb1cbb3b644f3692b0c443" translate="yes" xml:space="preserve">
          <source>Other approaches to this, such as composing Promises in a special way, are increasingly difficult to pull off when the loading states are located in different components down the tree.</source>
          <target state="translated">특별한 방식으로 약속을 구성하는 것과 같은 다른 접근 방식은 로딩 상태가 트리 아래의 다른 구성 요소에있을 때 점점 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="b17f43760c19635a2cfeb450e22843e0fca3cca3" translate="yes" xml:space="preserve">
          <source>Other effects might not have a cleanup phase, and don&amp;rsquo;t return anything.</source>
          <target state="translated">다른 효과는 정리 단계가없고 아무 것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efe0a2f2b6a088b22020eedfca1f8171b23b1b2a" translate="yes" xml:space="preserve">
          <source>Other libraries might support hooks in the future too.</source>
          <target state="translated">다른 라이브러리도 나중에 후크를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb1c9f1eb4ca77b950c7272aaa7baca69202c49" translate="yes" xml:space="preserve">
          <source>Our &amp;ldquo;Next&amp;rdquo; button click handler sets the state that switches the current profile in the state:</source>
          <target state="translated">&amp;ldquo;Next&amp;rdquo;버튼 클릭 핸들러는 상태에서 현재 프로파일을 전환하는 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d8d512d8960f76b07e5be884686cf1a1860c585e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Button&lt;/code&gt; component will immediately show the Pending state indicator on click:</source>
          <target state="translated">우리의 &lt;code&gt;Button&lt;/code&gt; 구성 요소는 바로 클릭에 보류 상태 표시기를 표시합니다 :</target>
        </trans-unit>
        <trans-unit id="5564b57b9c8ed5194280102aa6b272b6ace8690e" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;Welcome&lt;/code&gt; component returns a &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; element as the result.</source>
          <target state="translated">우리 &lt;code&gt;Welcome&lt;/code&gt; 구성 요소를 반환은 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, Sara&amp;lt;/h1&amp;gt;&lt;/code&gt; 결과로 요소입니다.</target>
        </trans-unit>
        <trans-unit id="24e602677bd730cb72e7da761f1b1f89e01b70c7" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;useTransition()&lt;/code&gt; call returns two values: &lt;code&gt;startTransition&lt;/code&gt; and &lt;code&gt;isPending&lt;/code&gt;.</source>
          <target state="translated">우리의 &lt;code&gt;useTransition()&lt;/code&gt; 호출은 &lt;code&gt;startTransition&lt;/code&gt; 과 &lt;code&gt;isPending&lt;/code&gt; 두 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b96521a8515cede856d54400c09ad380c0daf2e3" translate="yes" xml:space="preserve">
          <source>Our JSON API returns some data that looks like this:</source>
          <target state="translated">JSON API는 다음과 같은 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bef855825370735f30744e8e204330946ef7b36c" translate="yes" xml:space="preserve">
          <source>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</source>
          <target state="translated">우리의 React 응용 프로그램은 런타임 동안 HTML DOM을 지속적으로 수정하여 키보드 포커스가 손실되거나 예기치 않은 요소로 설정되는 경우가 있습니다. 이를 복구하려면 프로그래밍 방식으로 키보드 포커스를 올바른 방향으로 조금씩 움직여야합니다. 예를 들어, 모달 창을 닫은 후 모달 창을 연 버튼으로 키보드 포커스를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="74299bea00c013faee08bac03735a9e8eb9da361" translate="yes" xml:space="preserve">
          <source>Our first attempt might look like this:</source>
          <target state="translated">첫 번째 시도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfdb46afa859b90b54e6db2005a9424a33bafd62" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="translated">우리의 목표는 후크가 클래스의 모든 사용 사례를 가능한 빨리 다루는 것입니다. 드문 &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; 및 &lt;code&gt;componentDidCatch&lt;/code&gt; 라이프 사이클에 해당하는 후크는 아직 없지만 곧 추가 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="4fbbff78891e0fe3161c5f1fa839d8f83c89e351" translate="yes" xml:space="preserve">
          <source>Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt;, &lt;code&gt;getDerivedStateFromError&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</source>
          <target state="translated">Our goal is for Hooks to cover all use cases for classes as soon as possible. There are no Hook equivalents to the uncommon &lt;code&gt;getSnapshotBeforeUpdate&lt;/code&gt; , &lt;code&gt;getDerivedStateFromError&lt;/code&gt; and &lt;code&gt;componentDidCatch&lt;/code&gt; lifecycles yet, but we plan to add them soon.</target>
        </trans-unit>
        <trans-unit id="6f7bdd68f3093bdd85231792c356d3a08261c101" translate="yes" xml:space="preserve">
          <source>Our new example starts by importing the &lt;code&gt;useState&lt;/code&gt; Hook from React:</source>
          <target state="translated">새로운 예제는 React 에서 &lt;code&gt;useState&lt;/code&gt; Hook를 가져 오는 것으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="1fc98859f39fc7662d2321203db3a057fbfc1f78" translate="yes" xml:space="preserve">
          <source>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</source>
          <target state="translated">우리의 새로운 요구 사항은 섭씨 입력 외에도 화씨 입력을 제공하고 동기화 상태를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bdbaf73bc5cb4adf782290fa0e9328bf03a93107" translate="yes" xml:space="preserve">
          <source>Our old experiments with functional APIs in the &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; repository.</source>
          <target state="translated">우리의 기존 실험은 &lt;a href=&quot;https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State&quot;&gt;react-future&lt;/a&gt; 저장소 에서 기능적 API를 사용하여 실험했습니다 .</target>
        </trans-unit>
        <trans-unit id="ecead6fae262a6840fa100e15a353465a381857e" translate="yes" xml:space="preserve">
          <source>Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself &amp;ndash; if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;automated scripts&lt;/a&gt; to upgrade component syntax, which we then include in the open-source release for everyone to use.</source>
          <target state="translated">백만 명 이상의 개발자가 React를 사용하여 수백만 개의 구성 요소를 총체적으로 관리합니다. Facebook 코드베이스에만 50,000 개 이상의 React 구성 요소가 있습니다. 즉, 새로운 버전의 React로 쉽게 업그레이드 할 수 있어야합니다. 마이그레이션 경로없이 크게 변경하면 사람들은 이전 버전을 고수하게됩니다. Facebook 자체에서 이러한 업그레이드 경로를 테스트합니다. 10 명 미만의 팀이 50,000 개 이상의 구성 요소 만 업데이트 할 수 있다면 React를 사용하는 모든 사람이 업그레이드를 관리 할 수 ​​있기를 바랍니다. 많은 경우에, 우리는 컴포넌트 구문을 업그레이드하기 위해 &lt;a href=&quot;https://github.com/reactjs/react-codemod&quot;&gt;자동화 된 스크립트&lt;/a&gt; 를 작성 하고, 누구나 사용할 수 있도록 오픈 소스 릴리스에 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="67ee80037726319e2173c25a2b8a820cdf39330c" translate="yes" xml:space="preserve">
          <source>Over the next several months, many libraries will appear with different takes on Suspense APIs. &lt;strong&gt;If you prefer to learn when things are more stable, you might prefer to ignore this work for now, and come back when the Suspense ecosystem is more mature.&lt;/strong&gt;</source>
          <target state="translated">앞으로 몇 개월 동안 많은 라이브러리가 Suspense API에 대한 다른 테이크와 함께 나타날 것입니다. &lt;strong&gt;일이 더 안정적인시기를 배우기를 원한다면 지금 당장이 작업을 무시하고 서스펜스 생태계가 성숙 할 때 다시 오기를 원할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33b00a214a218165c819825f50d811fd28c59d9c" translate="yes" xml:space="preserve">
          <source>Overall, this makes it so that &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; all work very similarly - they all accept a &lt;code&gt;value&lt;/code&gt; attribute that you can use to implement a controlled component.</source>
          <target state="translated">전반적으로 이렇게하면 &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 가 모두 비슷하게 작동합니다. 모두 제어 된 구성 요소를 구현하는 데 사용할 수 있는 &lt;code&gt;value&lt;/code&gt; 특성을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="ac6ae6a452c9a133b258c63f82756651e2997eaf" translate="yes" xml:space="preserve">
          <source>Package Managers</source>
          <target state="translated">패키지 관리자</target>
        </trans-unit>
        <trans-unit id="20ec6193c88aaa60a810f707fb624f400dab682a" translate="yes" xml:space="preserve">
          <source>Package managers are tools that allow you to manage dependencies in your project. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; are two package managers commonly used in React applications. Both of them are clients for the same npm package registry.</source>
          <target state="translated">패키지 관리자는 프로젝트의 종속성을 관리 할 수있는 도구입니다. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 과 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; 은 React 애플리케이션에서 일반적으로 사용되는 두 개의 패키지 관리자입니다. 둘 다 동일한 npm 패키지 레지스트리의 클라이언트입니다.</target>
        </trans-unit>
        <trans-unit id="7dca5f8363324ed0f27645a7b9839654bdd31f45" translate="yes" xml:space="preserve">
          <source>Parent-Child Coupling</source>
          <target state="translated">부모-자식 커플 링</target>
        </trans-unit>
        <trans-unit id="60bd5e09f1e5e3ba47a58c7db16fad72304e43c8" translate="yes" xml:space="preserve">
          <source>Pass a &amp;ldquo;create&amp;rdquo; function and an array of dependencies. &lt;code&gt;useMemo&lt;/code&gt; will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.</source>
          <target state="translated">&quot;만들기&quot;기능과 종속성 배열을 전달하십시오. &lt;code&gt;useMemo&lt;/code&gt; 는 종속성 중 하나가 변경된 경우에만 메모 된 값을 다시 계산합니다. 이 최적화는 모든 렌더에서 값 비싼 계산을 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dd926194677835b376654a809999d830104e7b63" translate="yes" xml:space="preserve">
          <source>Pass a function instead of an object to &lt;code&gt;setState&lt;/code&gt; to ensure the call always uses the most updated version of state (see below).</source>
          <target state="translated">호출이 항상 가장 업데이트 된 상태 버전을 사용하도록하기 위해 객체 대신 함수를 &lt;code&gt;setState&lt;/code&gt; 에 전달하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2780570791c9ee7131760cf13185af6586f6a67f" translate="yes" xml:space="preserve">
          <source>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (or other tag if &lt;code&gt;mockTagName&lt;/code&gt; is provided) containing any provided children.</source>
          <target state="translated">모형 컴포넌트 모듈을이 메소드에 전달하여 더미 React 컴포넌트로 사용될 수있는 유용한 메소드로 기능을 보강하십시오. 평소와 같이 렌더링하는 대신 구성 요소는 제공된 자식을 포함 하는 간단한 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; (또는 &lt;code&gt;mockTagName&lt;/code&gt; 이 제공되는 경우 다른 태그 )가됩니다.</target>
        </trans-unit>
        <trans-unit id="fdde832b0e4e25e7efa528b27f908118f6bfa769" translate="yes" xml:space="preserve">
          <source>Pass a string as the &lt;code&gt;className&lt;/code&gt; prop:</source>
          <target state="translated">&lt;code&gt;className&lt;/code&gt; 소품 으로 문자열을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="534c9e580a2811b44edf2a15e3bc0f460c0a7212" translate="yes" xml:space="preserve">
          <source>Pass an inline callback and an array of dependencies. &lt;code&gt;useCallback&lt;/code&gt; will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. &lt;code&gt;shouldComponentUpdate&lt;/code&gt;).</source>
          <target state="translated">인라인 콜백 및 종속성 배열을 전달하십시오. &lt;code&gt;useCallback&lt;/code&gt; 은 종속성 중 하나가 변경된 경우에만 변경되는 메모 버전의 콜백을 반환합니다. 불필요한 렌더링을 방지하기 위해 참조 동등성에 의존하는 최적화 된 자식 구성 요소에 콜백을 전달할 때 유용합니다 (예 : &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b1ecfde360ca670c99a034b3467938615912d18" translate="yes" xml:space="preserve">
          <source>Pass event handlers and other functions as props to child components:</source>
          <target state="translated">이벤트 핸들러 및 기타 함수를 하위 구성 요소에 대한 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="7977cb8dad2d6673088b4722d378da8582b6ab23" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Event Handlers</source>
          <target state="translated">이벤트 처리기에 인수 전달</target>
        </trans-unit>
        <trans-unit id="7731b6038ead3e4f42010f183a92cc0e8e663535" translate="yes" xml:space="preserve">
          <source>Passing Functions to Components</source>
          <target state="translated">구성 요소에 함수 전달</target>
        </trans-unit>
        <trans-unit id="47c211ae4a2b3b47216fe468fbd82f27983e4011" translate="yes" xml:space="preserve">
          <source>Passing an update function allows you to access the current state value inside the updater. Since &lt;code&gt;setState&lt;/code&gt; calls are batched, this lets you chain updates and ensure they build on top of each other instead of conflicting:</source>
          <target state="translated">업데이트 기능을 전달하면 업데이터 내부의 현재 상태 값에 액세스 할 수 있습니다. &lt;code&gt;setState&lt;/code&gt; 호출은 일괄 처리 되므로 업데이트를 연결하고 충돌 대신 서로 위에 빌드되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a6194136e1fc05bb75b0051025e3237f9608a70" translate="yes" xml:space="preserve">
          <source>People come to React from different backgrounds and with different learning styles. Whether you prefer a more theoretical or a practical approach, we hope you&amp;rsquo;ll find this section helpful.</source>
          <target state="translated">사람들은 다른 배경과 다른 학습 스타일로 반응합니다. 보다 이론적이거나 실용적인 접근 방식을 선호하든이 섹션이 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="a454c4946afe6de8abb7a71c3c543078037ceb08" translate="yes" xml:space="preserve">
          <source>Perform the actions you want to profile. Don&amp;rsquo;t record more than 20 seconds or Chrome might hang.</source>
          <target state="translated">프로파일 링하려는 조치를 수행하십시오. 20 초 이상 기록하지 않으면 Chrome이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1456888f4e0889c6c1362473e30e3fb8f16a2193" translate="yes" xml:space="preserve">
          <source>Performance Optimizations</source>
          <target state="translated">성능 최적화</target>
        </trans-unit>
        <trans-unit id="afe33e97d445c1aa01afdea12de2c8a6bf6ef536" translate="yes" xml:space="preserve">
          <source>Phew, that was fast! If some things didn&amp;rsquo;t quite make sense or you&amp;rsquo;d like to learn more in detail, you can read the next pages, starting with the &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; documentation.</source>
          <target state="translated">휴, 그것은 빠르다! 일부 이해가되지 않았거나 더 자세히 배우려면 &lt;a href=&quot;hooks-state&quot;&gt;State Hook&lt;/a&gt; 문서 부터 시작하여 다음 페이지를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="649b0aad2e87bf224c37505fbd45954d6ae44866" translate="yes" xml:space="preserve">
          <source>Play a bit more with the &lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;demo&lt;/a&gt;, and try to imagine it happening.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/jovial-lalande-26yep&quot;&gt;데모&lt;/a&gt; 로 조금 더 연주하고 , 그것이 일어나고 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e22243b7987a499744ba5d18f9114f54c25fe1f4" translate="yes" xml:space="preserve">
          <source>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</source>
          <target state="translated">브라우저 / 스크린 리더 조합은 중요합니다. 선택한 화면 판독기에 가장 적합한 브라우저에서 응용 프로그램을 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e61307201646dc8a1687dacab76a450772d3c680" translate="yes" xml:space="preserve">
          <source>Please note that the syntax above is &lt;strong&gt;experimental&lt;/strong&gt; and the syntax may change, or the proposal might not make it into the language.</source>
          <target state="translated">위의 구문은 &lt;strong&gt;실험적&lt;/strong&gt; 이므로 구문이 변경되거나 제안서가 언어로 작성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a84c3942bb67e056a4c3f6552e902c1c6de812f7" translate="yes" xml:space="preserve">
          <source>Pointer Events</source>
          <target state="translated">포인터 이벤트</target>
        </trans-unit>
        <trans-unit id="51c36c348e5c25ede527a987ca5d7e15ef86c339" translate="yes" xml:space="preserve">
          <source>Pointer events are not yet supported in every browser (at the time of writing this article, supported browsers include: Chrome, Firefox, Edge, and Internet Explorer). React deliberately does not polyfill support for other browsers because a standard-conform polyfill would significantly increase the bundle size of &lt;code&gt;react-dom&lt;/code&gt;.</source>
          <target state="translated">포인터 이벤트는 모든 브라우저에서 아직 지원되지는 않습니다 (이 기사를 작성할 당시 지원되는 브라우저에는 Chrome, Firefox, Edge 및 Internet Explorer가 포함됨). 표준 준수 polyfill은 &lt;code&gt;react-dom&lt;/code&gt; 의 번들 크기를 크게 증가시키기 때문에 React는 의도적으로 다른 브라우저에 대한 지원을 polyfill하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a0c88242e813893ab8ad50b7e16808768f9baafb" translate="yes" xml:space="preserve">
          <source>Portals</source>
          <target state="translated">Portals</target>
        </trans-unit>
        <trans-unit id="4b918b44974a1664555fe8092f41a8a9c3c7132e" translate="yes" xml:space="preserve">
          <source>Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</source>
          <target state="translated">포털은 하위 컴포넌트를 상위 컴포넌트의 DOM 계층 외부에있는 DOM 노드로 렌더링하는 일류 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="029998f5e0e501dc2ec70d705846fadf01f5078f" translate="yes" xml:space="preserve">
          <source>Practical Tutorial</source>
          <target state="translated">실용 튜토리얼</target>
        </trans-unit>
        <trans-unit id="0da325394f7b2561f269c38b5353a62787615dc5" translate="yes" xml:space="preserve">
          <source>Prefer the standard &lt;code&gt;useEffect&lt;/code&gt; when possible to avoid blocking visual updates.</source>
          <target state="translated">시각적 업데이트를 차단하지 않으 &lt;code&gt;useEffect&lt;/code&gt; 가능한 경우 표준 사용을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="87cfce24dccded60294e74f312a7bb64c4e35de4" translate="yes" xml:space="preserve">
          <source>Preferred: Pending &amp;rarr; Skeleton &amp;rarr; Complete</source>
          <target state="translated">선호 : 보류 중 &amp;rarr; 스켈레톤 &amp;rarr; 완료</target>
        </trans-unit>
        <trans-unit id="fb1323678aee55ea7816c8e30aa6f1bdb912fb64" translate="yes" xml:space="preserve">
          <source>Press &amp;ldquo;Next&amp;rdquo; a few times. Notice it already feels very different. &lt;strong&gt;Instead of immediately seeing an empty screen on click, we now keep seeing the previous page for a while.&lt;/strong&gt; When the data has loaded, React transitions us to the new screen.</source>
          <target state="translated">&amp;ldquo;다음&amp;rdquo;을 몇 번 누르십시오. 이미 매우 다른 느낌을받습니다. &lt;strong&gt;클릭시 빈 화면이 즉시 표시되는 대신 이전 페이지가 계속 표시됩니다. &lt;/strong&gt;데이터가로드되면 React가 새 화면으로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ef2165e905ee1367c14a6f33243da7d43b8b7584" translate="yes" xml:space="preserve">
          <source>Preventing Component from Rendering</source>
          <target state="translated">구성 요소 렌더링 방지</target>
        </trans-unit>
        <trans-unit id="3efe0b4e061393bdaf49e8a579601b4bd4ce78de" translate="yes" xml:space="preserve">
          <source>Previously, React provided two ways for managing refs: the legacy string ref API and the callback API. Although the string ref API was the more convenient of the two, it had &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;several downsides&lt;/a&gt; and so our official recommendation was to &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;use the callback form instead&lt;/a&gt;.</source>
          <target state="translated">이전에 React는 레거시 문자열 ref API와 콜백 API라는 두 가지 ref 관리 방법을 제공했습니다. 문자열 참조 API가 두 가지 중 더 편리하지만 &lt;a href=&quot;https://github.com/facebook/react/issues/1373&quot;&gt;몇 가지 단점이&lt;/a&gt; 있으므로 공식 권장 사항은 &lt;a href=&quot;refs-and-the-dom#legacy-api-string-refs&quot;&gt;콜백 양식을 대신 사용하는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f508d98b08c23e21ae8ba502e34faaa9bf61dd9" translate="yes" xml:space="preserve">
          <source>Previously, we only encountered React elements that represent DOM tags:</source>
          <target state="translated">이전에는 DOM 태그를 나타내는 React 요소 만 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="886739715565d2665d39c8366ec2d10dc344405d" translate="yes" xml:space="preserve">
          <source>Priority-based Rendering</source>
          <target state="translated">우선 순위 기반 렌더링</target>
        </trans-unit>
        <trans-unit id="bb2e2459a0759f7d2b3b0d9811210079874a39cc" translate="yes" xml:space="preserve">
          <source>Profiler API</source>
          <target state="translated">프로파일 러 API</target>
        </trans-unit>
        <trans-unit id="5f47591c38d90876e84e5a679c6dc16b4b65918a" translate="yes" xml:space="preserve">
          <source>Profiling Components with the Chrome Performance Tab</source>
          <target state="translated">Chrome 성능 탭을 사용하여 구성 요소 프로파일 링</target>
        </trans-unit>
        <trans-unit id="e9edfd9d87db8eb1b7c2fee04f3c7d3c4f51081d" translate="yes" xml:space="preserve">
          <source>Profiling Components with the DevTools Profiler</source>
          <target state="translated">DevTools 프로파일 러를 사용하여 구성 요소 프로파일 링</target>
        </trans-unit>
        <trans-unit id="38e01723f7448dcb8aa35875d9f81ee04d125e7e" translate="yes" xml:space="preserve">
          <source>Profiling adds some additional overhead, so &lt;strong&gt;it is disabled in &lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;the production build&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">프로파일 링은 추가 오버 헤드를 추가하므로 &lt;strong&gt;&lt;a href=&quot;optimizing-performance#use-the-production-build&quot;&gt;프로덕션 빌드&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 에서 비활성화됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a865967da74c8436b8d176a76b2002d968e98151" translate="yes" xml:space="preserve">
          <source>Programmatically managing focus</source>
          <target state="translated">프로그래밍 방식으로 초점 관리</target>
        </trans-unit>
        <trans-unit id="86cd3058a8d5775df18dce4ea57b680ca5e164b6" translate="yes" xml:space="preserve">
          <source>Progressive Hydration</source>
          <target state="translated">프로그레시브 하이드 레이션</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="2187830d82c3a1f4829ffcf9703990399389ecd1" translate="yes" xml:space="preserve">
          <source>Props Default to &amp;ldquo;True&amp;rdquo;</source>
          <target state="translated">소품은 기본적으로 &quot;참&quot;</target>
        </trans-unit>
        <trans-unit id="9c2d9ce6b30a5f9172862e1e2a2103f1545aae76" translate="yes" xml:space="preserve">
          <source>Props and composition give you all the flexibility you need to customize a component&amp;rsquo;s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</source>
          <target state="translated">소품과 구성은 명시적이고 안전한 방식으로 구성 요소의 모양과 동작을 사용자 정의하는 데 필요한 모든 유연성을 제공합니다. 컴포넌트는 프리미티브 값, React 요소 또는 함수를 포함한 임의의 소품을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78feac20bb5fc62e7459d810b7135fef805d6854" translate="yes" xml:space="preserve">
          <source>Props are Read-Only</source>
          <target state="translated">소품은 읽기 전용입니다</target>
        </trans-unit>
        <trans-unit id="b33f3c7f743fb12f6a11e786a2fcb6e13d6efcfa" translate="yes" xml:space="preserve">
          <source>Props in JSX</source>
          <target state="translated">JSX의 소품</target>
        </trans-unit>
        <trans-unit id="5e8dad475166c2eac08c646b3ebdf3559b8f22bb" translate="yes" xml:space="preserve">
          <source>Props vs State</source>
          <target state="translated">소품 대 주</target>
        </trans-unit>
        <trans-unit id="ef11665379e87b4432e89567d3144207597dde64" translate="yes" xml:space="preserve">
          <source>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</source>
          <target state="translated">키보드 탐색을 지원하고 속도를 높이기 때문에 사용자가 애플리케이션의 과거 탐색 섹션을 건너 뛸 수있는 메커니즘을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="65135d5ec4d5950c26be85cdc6405b0542ba4616" translate="yes" xml:space="preserve">
          <source>Putting Research into Production</source>
          <target state="translated">연구를 생산에 투입</target>
        </trans-unit>
        <trans-unit id="4ee9c42d60235c923278d5e44bad794e0fe45c13" translate="yes" xml:space="preserve">
          <source>Quickly Try JSX</source>
          <target state="translated">JSX를 빠르게 시도</target>
        </trans-unit>
        <trans-unit id="723a59bfbd4916773b778eea25c500ba0e2055e2" translate="yes" xml:space="preserve">
          <source>Race Conditions with &lt;code&gt;componentDidUpdate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;componentDidUpdate&lt;/code&gt; 를 사용한 경쟁 조건</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
