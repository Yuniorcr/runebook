<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="0bfe11fb0bd23f69ef55dfbf3a328a415deca1e1" translate="yes" xml:space="preserve">
          <source>We also can&amp;rsquo;t display the &lt;code&gt;BoilingVerdict&lt;/code&gt; from &lt;code&gt;Calculator&lt;/code&gt;. The &lt;code&gt;Calculator&lt;/code&gt; doesn&amp;rsquo;t know the current temperature because it is hidden inside the &lt;code&gt;TemperatureInput&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;Calculator&lt;/code&gt; 에서 &lt;code&gt;BoilingVerdict&lt;/code&gt; 를 표시 할 수 없습니다 . &lt;code&gt;Calculator&lt;/code&gt; 그것이 내부에 숨겨져 있기 때문에 현재의 온도를 알 수 없습니다 &lt;code&gt;TemperatureInput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2280d133c53709865c8f43e30cdfb593c6f1a9" translate="yes" xml:space="preserve">
          <source>We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them.</source>
          <target state="translated">또한 처리 중에 처리되지 않은 예외에 대해 배우고 수정할 수 있도록 JS 오류보고 서비스를 사용하거나 직접 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="81cce18154015640ed2a3912f965c20c89cc804d" translate="yes" xml:space="preserve">
          <source>We also learned a little bit more about what Hooks are. Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React features from function components. Their names always start with &lt;code&gt;use&lt;/code&gt;, and there are more Hooks we haven&amp;rsquo;t seen yet.</source>
          <target state="translated">또한 Hooks가 무엇인지에 대해 조금 더 배웠습니다. 후크는 기능 구성 요소의 기능을 &quot;후크&quot;할 수있는 기능입니다. 이름은 항상 &lt;code&gt;use&lt;/code&gt; 로 시작하며 아직 보지 못한 후크가 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a06b4800bed82086df99569fc99b049a8f536a2" translate="yes" xml:space="preserve">
          <source>We also recommend checking out Enzyme&amp;rsquo;s &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt;. It provides a nicer higher-level API over the same functionality.</source>
          <target state="translated">Enzyme의 &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt; 도 확인하는 것이 좋습니다 . 동일한 기능보다 우수한 고급 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d2acd14c5f1177e3efc803ef0c6bfa85043eff0c" translate="yes" xml:space="preserve">
          <source>We also recommend to verify that the CDN you are using sets the &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP header:</source>
          <target state="translated">또한 사용중인 CDN이 &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP 헤더 를 설정했는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9f90673956b6b1153d069bebc4fcb338546634e9" translate="yes" xml:space="preserve">
          <source>We also understand that the bar for adding a new primitive to React is extremely high. For curious readers, we have prepared a &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;detailed RFC&lt;/a&gt; that dives into motivation with more details, and provides extra perspective on the specific design decisions and related prior art.</source>
          <target state="translated">또한 React에 새로운 프리미티브를 추가하는 기준이 매우 높다는 것을 이해합니다. 호기심 많은 독자들을 위해 &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;세부적인 RFC&lt;/a&gt; 를 준비하여 세부적인 내용 으로 동기를 부여하고 특정 설계 결정 및 관련 선행 기술에 대한 추가 관점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e88e0a56f6ad5a5eb9d99b0270eccb4e024c1a34" translate="yes" xml:space="preserve">
          <source>We also want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;clear that timer&lt;/a&gt; whenever the DOM produced by the &lt;code&gt;Clock&lt;/code&gt; is removed. This is called &amp;ldquo;unmounting&amp;rdquo; in React.</source>
          <target state="translated">또한 &lt;code&gt;Clock&lt;/code&gt; 에서 생성 된 DOM 이 제거 될 때마다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;해당 타이머&lt;/a&gt; 를 지우고 싶습니다 . 이것을 React에서&amp;ldquo;언 마운트&amp;rdquo;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5365ad1fb8e8f2e33ecc7188b78c50f5f0e7479f" translate="yes" xml:space="preserve">
          <source>We are regularly refining the heuristics in order to make common use cases faster. In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree.</source>
          <target state="translated">우리는 일반적인 사용 사례를 더 빨리 만들기 위해 휴리스틱을 정기적으로 개선하고 있습니다. 현재 구현에서는 하위 트리가 형제 사이에서 이동했다는 사실을 표현할 수 있지만 다른 트리로 이동했다는 것을 알 수는 없습니다. 알고리즘은 해당 전체 하위 트리를 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="d116c83b89af6cbda01c9512b005b983349cadd5" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; with the &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; 요소 와 함께 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="0687fbf49286c2ec12b4f4678698a178afc11fdd" translate="yes" xml:space="preserve">
          <source>We call this a &amp;ldquo;root&amp;rdquo; DOM node because everything inside it will be managed by React DOM.</source>
          <target state="translated">우리는 이것을 &quot;루트&quot;DOM 노드라고 부릅니다. 그 안에있는 모든 것이 React DOM에 의해 관리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dea916ead1ececf4e26bb88719ffd02a287439fb" translate="yes" xml:space="preserve">
          <source>We call this approach &amp;ldquo;fetch-on-render&amp;rdquo; because it doesn&amp;rsquo;t start fetching until &lt;em&gt;after&lt;/em&gt; the component has rendered on the screen. This leads to a problem known as a &amp;ldquo;waterfall&amp;rdquo;.</source>
          <target state="translated">우리는이 방법을 전화 &quot;가져 오기 - 렌더링에&quot;그 때까지 가져 오는 시작되지 않기 때문에 &lt;em&gt;이후에&lt;/em&gt; 구성 요소가 화면에 렌더링하고있다. 이로 인해 &quot;폭포&quot;라고 알려진 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="801ca9e396c70ea52ff8cfbd3f95c4e9d3304075" translate="yes" xml:space="preserve">
          <source>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE&amp;rsquo;s for the ARIA roles, states and properties. We also have access to the following tool:</source>
          <target state="translated">JSX 코드에서 일부 접근성 기능을 직접 확인할 수 있습니다. ARIA 역할, 상태 및 속성에 대한 인텔리전스 검사는 JSX 인식 IDE에서 이미 제공됩니다. 또한 다음 도구에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0315740899889aaecb6fca0ac9d4299c0036235a" translate="yes" xml:space="preserve">
          <source>We can combine the two by making the React state be the &amp;ldquo;single source of truth&amp;rdquo;. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a &amp;ldquo;controlled component&amp;rdquo;.</source>
          <target state="translated">우리는 React 상태를&amp;ldquo;단일 진실 소스&amp;rdquo;로 만들어 두 가지를 결합 할 수 있습니다. 그런 다음 양식을 렌더링하는 React 구성 요소는 후속 사용자 입력에서 해당 양식에서 발생하는 사항도 제어합니다. 이러한 방식으로 React에 의해 값이 제어되는 입력 양식 요소를 &quot;제어 구성 요소&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="d318ed6f5f31fef5a0927c77ba11af495ad3b8e8" translate="yes" xml:space="preserve">
          <source>We can declare special methods on the component class to run some code when a component mounts and unmounts:</source>
          <target state="translated">컴포넌트가 마운트 및 마운트 해제 될 때 일부 코드를 실행하기 위해 컴포넌트 클래스에 특수 메소드를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38da4b536bf1075811107d57f35f3c7ec26e707d" translate="yes" xml:space="preserve">
          <source>We can now change the &lt;code&gt;Calculator&lt;/code&gt; to render two separate temperature inputs:</source>
          <target state="translated">이제 두 개의 별도 온도 입력을 렌더링 하도록 &lt;code&gt;Calculator&lt;/code&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73fada2c6ee0dde707d8d724cd500dba20459065" translate="yes" xml:space="preserve">
          <source>We can now see that the need for &lt;code&gt;useTransition&lt;/code&gt; is &lt;em&gt;very&lt;/em&gt; common. Pretty much any button click or interaction that can lead to a component suspending needs to be wrapped in &lt;code&gt;useTransition&lt;/code&gt; to avoid accidentally hiding something the user is interacting with.</source>
          <target state="translated">우리는 지금의 필요성 것을 볼 수 있습니다 &lt;code&gt;useTransition&lt;/code&gt; 가 있다 &lt;em&gt;매우&lt;/em&gt; 일반적인. 구성 요소 현탁 요구로 이어질 수있는 거의 모든 버튼 클릭 또는 상호 작용에 싸여 할 &lt;code&gt;useTransition&lt;/code&gt; 사용자와 상호 작용 뭔가 숨기고 실수하지 않도록.</target>
        </trans-unit>
        <trans-unit id="240673c357597499949284e0383f4fe5f428ec57" translate="yes" xml:space="preserve">
          <source>We can now simplify &lt;code&gt;Comment&lt;/code&gt; a tiny bit:</source>
          <target state="translated">우리는 이제 &lt;code&gt;Comment&lt;/code&gt; 를 약간 단순화 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1651e3cc930105fbd7c7f2a069537f4573a560c" translate="yes" xml:space="preserve">
          <source>We can refactor the previous example into a component that accepts an array of &lt;code&gt;numbers&lt;/code&gt; and outputs a list of elements.</source>
          <target state="translated">이전 예제를 &lt;code&gt;numbers&lt;/code&gt; 배열을 허용하고 요소 목록을 출력하는 컴포넌트로 리팩토링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b8395d3ccd48364a5e95de668d92822952ff915" translate="yes" xml:space="preserve">
          <source>We can see how typing in the input causes stutter. Now let&amp;rsquo;s add &lt;code&gt;useDeferredValue&lt;/code&gt;:</source>
          <target state="translated">입력을 입력하면 말더듬이 어떻게 발생하는지 확인할 수 있습니다. 이제 &lt;code&gt;useDeferredValue&lt;/code&gt; 를 추가 하자 :</target>
        </trans-unit>
        <trans-unit id="ac714531d13810a1f186c53455166ed3abd9b760" translate="yes" xml:space="preserve">
          <source>We can see in &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;this example&lt;/a&gt; that pressing &amp;ldquo;Refresh&amp;rdquo; works. The &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components receive a new &lt;code&gt;resource&lt;/code&gt; prop that represents the fresh data, they &amp;ldquo;suspend&amp;rdquo; because we don&amp;rsquo;t have a response yet, and we see the fallbacks. When the response loads, we can see the updated posts (our fake API adds them every 3 seconds).</source>
          <target state="translated">우리는에서 볼 수있는 &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;예&lt;/a&gt; &quot;새로 고침&quot;작품을 눌러 있음. &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; 구성 요소는 새 수신 &lt;code&gt;resource&lt;/code&gt; 아직 응답이 없기 때문에 그들은 &quot;중단&quot;, 신선한 데이터를 나타내는 소품을, 우리는 폴백 (fallback)을 참조하십시오. 응답이로드되면 업데이트 된 게시물을 볼 수 있습니다 (가짜 API가 3 초마다 추가 함).</target>
        </trans-unit>
        <trans-unit id="1ea1ede495fd5963c31b6ef743c03c777ac3dc91" translate="yes" xml:space="preserve">
          <source>We can see now how Concurrent Mode helps us achieve a good user experience without sacrificing isolation and modularity of components. React coordinates the transition.</source>
          <target state="translated">이제 Concurrent Mode가 구성 요소의 격리 및 모듈성을 희생하지 않고도 우수한 사용자 경험을 얻는 방법을 알 수 있습니다. 반응은 전환을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="4f967ab5065b900688a0c0d89c66176628622a03" translate="yes" xml:space="preserve">
          <source>We can set this in React using the &lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component를&lt;/a&gt; 사용하여 이것을 React에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2bd80e65c62c614b84617e1716cdcc13cdf9204" translate="yes" xml:space="preserve">
          <source>We can start by encapsulating how the clock looks:</source>
          <target state="translated">시계 모양을 캡슐화하여 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="062efaa9ef4ef374ba95e07a8f7fbb0094129c10" translate="yes" xml:space="preserve">
          <source>We can start by extracting a &lt;code&gt;TemperatureInput&lt;/code&gt; component from &lt;code&gt;Calculator&lt;/code&gt;. We will add a new &lt;code&gt;scale&lt;/code&gt; prop to it that can either be &lt;code&gt;&quot;c&quot;&lt;/code&gt; or &lt;code&gt;&quot;f&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Calculator&lt;/code&gt; 에서 &lt;code&gt;TemperatureInput&lt;/code&gt; 컴포넌트를 추출하여 시작할 수 있습니다 . &lt;code&gt;&quot;c&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;f&quot;&lt;/code&gt; 일 수 있는 새로운 &lt;code&gt;scale&lt;/code&gt; 소품을 추가 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b2c05e2cbfb5369191e544f39acda01e6250d465" translate="yes" xml:space="preserve">
          <source>We can use it in three steps.</source>
          <target state="translated">3 단계로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2446e404b6ead27ad20b61ec7f4e53599aafb6" translate="yes" xml:space="preserve">
          <source>We can write a function that creates components, like &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt;, that subscribe to &lt;code&gt;DataSource&lt;/code&gt;. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let&amp;rsquo;s call the function &lt;code&gt;withSubscription&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;CommentList&lt;/code&gt; 및 &lt;code&gt;BlogPost&lt;/code&gt; 와 같이 &lt;code&gt;DataSource&lt;/code&gt; 를 구독하는 컴포넌트를 작성하는 함수를 작성할 수 있습니다 . 이 함수는 구독 한 데이터를 소품으로받는 하위 구성 요소를 인수 중 하나로 받아들입니다. &lt;code&gt;withSubscription&lt;/code&gt; 함수를 호출 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="89ba067a3566a17960dd50516dca67227912a77a" translate="yes" xml:space="preserve">
          <source>We can write a test for this component:</source>
          <target state="translated">이 컴포넌트에 대한 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e41c4d141e5855cbde52500c24c257c93ac43e" translate="yes" xml:space="preserve">
          <source>We can write tests for it:</source>
          <target state="translated">테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd9941e6ca2b2bcc146e2e3bddb7ece3c0bfd372" translate="yes" xml:space="preserve">
          <source>We can write tests for this component by leveraging &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&amp;rsquo;s timer mocks&lt;/a&gt;, and testing the different states it can be in.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest의 타이머 모의&lt;/a&gt; 를 활용 하고 다른 상태를 테스트 하여이 구성 요소에 대한 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7a8c823c57fed4ff580d4dbf33ecaf747d353f" translate="yes" xml:space="preserve">
          <source>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; alone.</source>
          <target state="translated">두 입력의 값을 모두 저장할 수 있었지만 불필요합니다. 가장 최근에 변경된 입력 값과 입력하는 스케일을 저장하기에 충분합니다. 그런 다음 현재 &lt;code&gt;temperature&lt;/code&gt; 와 &lt;code&gt;scale&lt;/code&gt; 만으로 다른 입력 값을 유추 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acfdbd4f44790b2811125b8ac3c5fb8fee686a44" translate="yes" xml:space="preserve">
          <source>We could introduce Suspense without mentioning the popular data fetching approaches. However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</source>
          <target state="translated">우리는 널리 사용되는 데이터 가져 오기 접근법을 언급하지 않고 서스펜스를 도입 할 수있었습니다. 그러나 이렇게하면 Suspense가 해결하는 문제, 이러한 문제를 해결할 가치가있는 이유 및 Suspense가 기존 솔루션과 어떻게 다른지 파악하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="585fc27656bad76f723c37445c9bb4da260c11b5" translate="yes" xml:space="preserve">
          <source>We could write tests for it:</source>
          <target state="translated">테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e58e1cd19c11a614603dedfb8a316a8e141d81a" translate="yes" xml:space="preserve">
          <source>We create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt; by calling &lt;code&gt;React.createRef&lt;/code&gt; and assign it to a &lt;code&gt;ref&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;React.createRef&lt;/code&gt; 를 호출 하여 &lt;a href=&quot;refs-and-the-dom&quot;&gt;React 참조&lt;/a&gt; 를 생성하고 이를 &lt;code&gt;ref&lt;/code&gt; 변수에 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="480f6cdda7556b73ac82824cc7b0bb1d95bbd4f0" translate="yes" xml:space="preserve">
          <source>We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing.</source>
          <target state="translated">우리는이 결정에 대해 토론했지만, 경험 상으로는 손상된 UI를 완전히 제거하는 것보다 손상된 상태로 두는 것이 더 나쁩니다. 예를 들어, 메신저와 같은 제품에서 깨진 UI를 그대로두면 누군가에게 잘못된 사람에게 메시지를 보낼 수 있습니다. 마찬가지로 결제 앱이 아무것도 렌더링하지 않는 것보다 잘못된 금액을 표시하는 것이 더 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="1781a89c81643968a25cd7b4d162af832e4f691e" translate="yes" xml:space="preserve">
          <source>We declare a state variable called &lt;code&gt;count&lt;/code&gt;, and set it to &lt;code&gt;0&lt;/code&gt;. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current &lt;code&gt;count&lt;/code&gt;, we can call &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 라는 상태 변수를 선언하고 &lt;code&gt;0&lt;/code&gt; 으로 설정합니다 . React는 다시 렌더링 사이의 현재 가치를 기억하고 가장 최근의 가치를 우리의 기능에 제공합니다. 현재 &lt;code&gt;count&lt;/code&gt; 를 업데이트하려면 &lt;code&gt;setCount&lt;/code&gt; 를 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="1157d2f6d524a9bab78d01f0f931451f950ee13e" translate="yes" xml:space="preserve">
          <source>We declare the &lt;code&gt;count&lt;/code&gt; state variable, and then we tell React we need to use an effect. We pass a function to the &lt;code&gt;useEffect&lt;/code&gt; Hook. This function we pass &lt;em&gt;is&lt;/em&gt; our effect. Inside our effect, we set the document title using the &lt;code&gt;document.title&lt;/code&gt; browser API. We can read the latest &lt;code&gt;count&lt;/code&gt; inside the effect because it&amp;rsquo;s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 상태 변수를 선언 한 다음 React에 효과를 사용해야한다고 알려줍니다. 우리는 &lt;code&gt;useEffect&lt;/code&gt; Hook에 함수를 전달합니다 . 우리가 전달하는이 기능 &lt;em&gt;은&lt;/em&gt; 우리의 효과입니다. 효과 안에서 &lt;code&gt;document.title&lt;/code&gt; 브라우저 API를 사용하여 문서 제목을 설정합니다 . 함수의 범위 내에 있기 때문에 효과 내부 의 최신 &lt;code&gt;count&lt;/code&gt; 읽을 수 있습니다 . React가 컴포넌트를 렌더링 할 때 사용했던 효과를 기억하고 DOM을 업데이트 한 후에 효과를 실행합니다. 이는 첫 번째 렌더링을 포함하여 모든 렌더링에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="054642f59673a4f5210fd696dfb50dd0fc393abd" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t choose &lt;code&gt;useRef&lt;/code&gt; in this example because an object ref doesn&amp;rsquo;t notify us about &lt;em&gt;changes&lt;/em&gt; to the current ref value. Using a callback ref ensures that &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;even if a child component displays the measured node later&lt;/a&gt; (e.g. in response to a click), we still get notified about it in the parent component and can update the measurements.</source>
          <target state="translated">이 예제에서는 객체 참조가 현재 참조 값의 &lt;em&gt;변경&lt;/em&gt; 에 대해 &lt;code&gt;useRef&lt;/code&gt; 않기 때문에 useRef 를 선택 하지 않았습니다 . 콜백 참조를 사용하면 &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;하위 구성 요소가 나중에 측정 노드를 표시하더라도&lt;/a&gt; (예 : 클릭에 대한 응답으로) 상위 구성 요소에서 해당 구성 요소에 대한 알림을 받고 측정을 업데이트 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b9a31c8e7a657381cb91a3a3efbc87ae1284206" translate="yes" xml:space="preserve">
          <source>We do not recommend doing deep equality checks or using &lt;code&gt;JSON.stringify()&lt;/code&gt; in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. It is very inefficient and will harm performance.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate()&lt;/code&gt; 에서 심도 동등 검사를 수행하거나 &lt;code&gt;JSON.stringify()&lt;/code&gt; 를 사용하지 않는 것이 좋습니다 . 매우 비효율적이며 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="f8a90d5ff1e8d82817c939402d5e44da6170a7a2" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t have to return a named function from the effect. We called it &lt;code&gt;cleanup&lt;/code&gt; here to clarify its purpose, but you could return an arrow function or call it something different.</source>
          <target state="translated">효과에서 명명 된 함수를 반환 할 필요는 없습니다. 목적을 명확하게하기 위해 여기 에서는 &lt;code&gt;cleanup&lt;/code&gt; 라고 했지만 화살표 함수를 반환하거나 다른 것으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d21059cf406cb5e8fbc1297f3553a843f44e80d3" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend adding debug values to every custom Hook. It&amp;rsquo;s most valuable for custom Hooks that are part of shared libraries.</source>
          <target state="translated">모든 사용자 정의 후크에 디버그 값을 추가하지 않는 것이 좋습니다. 공유 라이브러리의 일부인 사용자 정의 후크에 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c256b313bdb7417edd7396978a005028a790c640" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny&amp;rsquo;s article for an &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;in-depth explanation on the negative impacts of using an index as a key&lt;/a&gt;. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.</source>
          <target state="translated">항목 순서가 변경 될 수있는 경우 키에 색인을 사용하지 않는 것이 좋습니다. 이는 성능에 부정적인 영향을 줄 수 있으며 구성 요소 상태에 문제를 일으킬 수 있습니다. &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;인덱스를 키로 사용했을 때의 부정적인 영향에 대한 자세한 설명은&lt;/a&gt; Robin Pokorny의 기사를 확인하십시오 . 항목을 나열하기 위해 명시 적 키를 지정하지 않으면 React는 기본적으로 인덱스를 키로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f7a2c32757c53f98e7f15fd8320c8286a85f7b74" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t support older browsers that don&amp;rsquo;t support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim and es5-sham&lt;/a&gt; are included in the page. You&amp;rsquo;re on your own if you choose to take this path.</source>
          <target state="translated">ES5 방법을 지원하지 않는 구형 브라우저는 지원하지 않지만 &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim 및 es5-sham&lt;/a&gt; 와 같은 폴리 필 이 페이지에 포함 된 경우 앱이 구형 브라우저에서 작동하는 것을 알 수 있습니다 . 이 길을 택하기로 선택했다면 당신은 스스로입니다.</target>
        </trans-unit>
        <trans-unit id="d7054c5c327eab83e8a538c07a37096fc9ba86ae" translate="yes" xml:space="preserve">
          <source>We expect to see a lot of experimentation in the community with other libraries. There is one important thing to note for data fetching library authors.</source>
          <target state="translated">우리는 다른 도서관과의 커뮤니티에서 많은 실험을 할 것으로 기대합니다. 데이터 페치 라이브러리 작성자에게 유의해야 할 중요한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1811475d8d5e4bfca6bcc31a35dddff5ea826ba4" translate="yes" xml:space="preserve">
          <source>We finish fetching posts</source>
          <target state="translated">게시물 가져 오기가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd1d02bb8014d90531045031402948fe7570892b" translate="yes" xml:space="preserve">
          <source>We finish fetching user details</source>
          <target state="translated">사용자 정보 가져 오기가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="abe12286a3512c8899854e56ae85e9c6930b655f" translate="yes" xml:space="preserve">
          <source>We forward this &lt;code&gt;ref&lt;/code&gt; argument down to &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">이 &lt;code&gt;ref&lt;/code&gt; 인수를 JSX 속성으로 지정 하여 &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; 로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1c1b58e7b12eec27541e758845c7fe3cd4ed8a68" translate="yes" xml:space="preserve">
          <source>We gave this &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; a unique &lt;code&gt;id&lt;/code&gt; HTML attribute. This will allow us to find it from the JavaScript code later and display a React component inside of it.</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 고유 한 &lt;code&gt;id&lt;/code&gt; HTML 속성을 부여했습니다. 이를 통해 나중에 JavaScript 코드에서 찾은 다음 그 안에 React 구성 요소를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c245c7bd223dde0a276aa2c9b895f7664846e5a6" translate="yes" xml:space="preserve">
          <source>We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.</source>
          <target state="translated">우리는 React 릴리스에 버그가없는 것을 기록한 기록이 꽤 많지만 대부분의 개발자는 부작용없이 채택 할 수 있다고 가정하기 때문에 패치 릴리스의 안정성이 훨씬 높습니다.</target>
        </trans-unit>
        <trans-unit id="33f48ef96719930c7b83f5ac73cec67a078fa4ec" translate="yes" xml:space="preserve">
          <source>We have two inputs now, but when you enter the temperature in one of them, the other doesn&amp;rsquo;t update. This contradicts our requirement: we want to keep them in sync.</source>
          <target state="translated">이제 두 개의 입력이 있지만 그중 하나에 온도를 입력하면 다른 하나는 업데이트되지 않습니다. 이것은 우리의 요구 사항과 모순됩니다 : 우리는 그것들을 동기화시키기 원합니다.</target>
        </trans-unit>
        <trans-unit id="24b615fc96a058b3af22def911e880fa3fa06a51" translate="yes" xml:space="preserve">
          <source>We include the entire &lt;code&gt;listItems&lt;/code&gt; array inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element, and &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;render it to the DOM&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 요소 내에 전체 &lt;code&gt;listItems&lt;/code&gt; 배열 &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;을 포함시켜 DOM으로 렌더링합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f264ce8ea8b9422cb05320c59c32289e8a41d8fa" translate="yes" xml:space="preserve">
          <source>We intend for Hooks to cover all existing use cases for classes, but &lt;strong&gt;we will keep supporting class components for the foreseeable future.&lt;/strong&gt; At Facebook, we have tens of thousands of components written as classes, and we have absolutely no plans to rewrite them. Instead, we are starting to use Hooks in the new code side by side with classes.</source>
          <target state="translated">우리는 Hooks가 클래스에 대한 기존의 모든 사용 사례를 다룰 예정이지만 &lt;strong&gt;가까운 미래에 클래스 컴포넌트를 계속 지원할 것입니다. &lt;/strong&gt;Facebook에는 수만 개의 구성 요소가 클래스로 작성되어 있으며이를 다시 작성할 계획이 전혀 없습니다. 대신 새 코드에서 클래스와 함께 후크를 사용하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="c713f1e114aac40ce80667421a2a28046e3cfa12" translate="yes" xml:space="preserve">
          <source>We keep the currently chosen friend ID in the &lt;code&gt;recipientID&lt;/code&gt; state variable, and update it if the user chooses a different friend in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; picker.</source>
          <target state="translated">현재 선택된 친구 ID를 &lt;code&gt;recipientID&lt;/code&gt; ID 상태 변수에 유지하고 사용자가 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 선택기 에서 다른 친구를 선택하면 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="bebd065febb63c4c26c6d9264a1ea50385c149ba" translate="yes" xml:space="preserve">
          <source>We know that &lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;props are read-only&lt;/a&gt;. When the &lt;code&gt;temperature&lt;/code&gt; was in the local state, the &lt;code&gt;TemperatureInput&lt;/code&gt; could just call &lt;code&gt;this.setState()&lt;/code&gt; to change it. However, now that the &lt;code&gt;temperature&lt;/code&gt; is coming from the parent as a prop, the &lt;code&gt;TemperatureInput&lt;/code&gt; has no control over it.</source>
          <target state="translated">&lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;소품이 읽기 전용&lt;/a&gt; 이라는 것을 알고 있습니다. 때 &lt;code&gt;temperature&lt;/code&gt; 로컬 상태에의 &lt;code&gt;TemperatureInput&lt;/code&gt; 은 단지 부를 수 &lt;code&gt;this.setState()&lt;/code&gt; 를 변경할 수 있습니다. 그러나 이제 &lt;code&gt;temperature&lt;/code&gt; 가 모체에서 소품으로 나오기 때문에 &lt;code&gt;TemperatureInput&lt;/code&gt; 은 온도 를 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="876790cf7c1befea3d21048ec699314173e464db" translate="yes" xml:space="preserve">
          <source>We know that React developers are focused on shipping products and don&amp;rsquo;t have time to look into every new API that&amp;rsquo;s being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them.</source>
          <target state="translated">우리는 React 개발자들이 제품 배송에 집중하고 있으며 출시되는 모든 새로운 API를 조사 할 시간이 없다는 것을 알고 있습니다. 후크는 매우 새롭기 때문에 학습이나 채택을 고려하기 전에 더 많은 예제와 자습서를 기다리는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a3eff7a79862d5e529eb12353784eb51ca7e1aff" translate="yes" xml:space="preserve">
          <source>We moved the function inside the effect so it doesn&amp;rsquo;t need to be in its dependency list.</source>
          <target state="translated">함수 내부로 함수를 옮겼으므로 종속성 목록에있을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d56e8fa2275dad4f8e035a0280660359a418e87" translate="yes" xml:space="preserve">
          <source>We offer production-ready versions of React and React DOM as single files:</source>
          <target state="translated">프로덕션 준비 버전의 React 및 React DOM을 단일 파일로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="173d3966a33df8916b07b6198d8a3107fe3fdd80" translate="yes" xml:space="preserve">
          <source>We pass our &lt;code&gt;ref&lt;/code&gt; down to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="translated">우리는 우리의 통과 &lt;code&gt;ref&lt;/code&gt; 아래 &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; JSX의 속성으로 지정하여.</target>
        </trans-unit>
        <trans-unit id="0fd48e29a186685285cacd537ec278624c56cfec" translate="yes" xml:space="preserve">
          <source>We previously recommended mixins as a way to handle cross-cutting concerns. We&amp;rsquo;ve since realized that mixins create more trouble than they are worth. &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;Read more&lt;/a&gt; about why we&amp;rsquo;ve moved away from mixins and how you can transition your existing components.</source>
          <target state="translated">교차 절단 문제를 처리하기 위해 믹스 인을 권장했습니다. 우리는 그 후 믹스 인이 가치있는 것보다 더 많은 문제를 일으킨다는 것을 깨달았습니다. 우리가 믹스 인에서 벗어난 이유와 기존 구성 요소를 전환 할 수있는 방법에 대해 &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;자세히&lt;/a&gt; 알아 보십시오 .</target>
        </trans-unit>
        <trans-unit id="b732ce77a4e21236193d4ed1a3cfdc1759dbca1e" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">변환을 자동화 &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;하는 codemod 스크립트&lt;/a&gt; 를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="7f537600ac475b0e28fd9838f0994971eb587cef" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="translated">변환을 자동화 &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;하는 codemod 스크립트&lt;/a&gt; 를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="2369cb3e294a76670599da056d0a5f3e1999ae3a" translate="yes" xml:space="preserve">
          <source>We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.</source>
          <target state="translated">이러한 규칙을 자동으로 시행 하기위한 &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;린터 플러그인&lt;/a&gt; 을 제공합니다 . 이러한 규칙은 처음에는 제한적이거나 혼란스러워 보일 수 있지만 후크가 제대로 작동하는 데 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="0938ce335cf46095dc66994cff21751a2cbd8d1a" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; 패키지 의 일부로 &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; 딥 ESLint 규칙을 제공 합니다. 종속성이 잘못 지정된 경우 경고하고 수정 사항을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ab72bfddf6528413d326567c0887f4498b85d602" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint plugin&lt;/a&gt; that enforces &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; to avoid bugs. It assumes that any function starting with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and a capital letter right after it is a Hook. We recognize this heuristic isn&amp;rsquo;t perfect and there may be some false positives, but without an ecosystem-wide convention there is just no way to make Hooks work well &amp;mdash; and longer names will discourage people from either adopting Hooks or following the convention.</source>
          <target state="translated">버그를 피하기 위해 &lt;a href=&quot;hooks-rules&quot;&gt;후크 규칙&lt;/a&gt; 을 적용 하는 &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint 플러그인&lt;/a&gt; 을 제공합니다 . &amp;rdquo; &lt;code&gt;use&lt;/code&gt; &amp;rdquo;로 시작하는 모든 함수와 훅 직후의 대문자로 가정합니다 . 우리는이 휴리스틱이 완벽하지 않고 오 탐지가있을 수 있다는 점을 인식하지만, 생태계 전반에 걸친 협약이 없으면 후크를 제대로 작동시킬 수있는 방법이 없습니다. 더 긴 이름은 사람들이 후크를 채택하거나 협약을 따르지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="e678ec6a3cf91996c6dfc88cfd13ce2bedcc8a3b" translate="yes" xml:space="preserve">
          <source>We provide more recommendations on splitting independent state variables &lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;in the FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;FAQ에서&lt;/a&gt; 독립 상태 변수를 분할하는 것에 대한 추가 권장 사항을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="54061fe31bd1eb76ce19d28df0f5e134c8d482c7" translate="yes" xml:space="preserve">
          <source>We provide the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It helps you find components that don&amp;rsquo;t handle updates consistently.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; 패키지 의 일부로 &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; 딥 ESLint 규칙을 제공합니다 . 업데이트를 일관되게 처리하지 않는 구성 요소를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="89b928f0f765e5ca5c0cf26a707c679396e87061" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;introducing-jsx&quot;&gt;using JSX&lt;/a&gt; to describe what your UI should look like. Each JSX element is just syntactic sugar for calling &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;. You will not typically invoke the following methods directly if you are using JSX.</source>
          <target state="translated">&lt;a href=&quot;introducing-jsx&quot;&gt;UIX의 모양&lt;/a&gt; 을 설명하기 위해 JSX 를 사용하는 것이 좋습니다 . 각 JSX 요소는 &lt;a href=&quot;#createelement&quot;&gt; &lt;code&gt;React.createElement()&lt;/code&gt; &lt;/a&gt; 를 호출하기위한 구문 설탕입니다 . JSX를 사용하는 경우 일반적으로 다음 메소드를 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cc25672e0f55ea9b98f9dd9e96289f1e47e413c" translate="yes" xml:space="preserve">
          <source>We recommend dispatching real DOM events on DOM elements, and then asserting on the result. Consider a &lt;code&gt;Toggle&lt;/code&gt; component:</source>
          <target state="translated">DOM 요소에 실제 DOM 이벤트를 전달한 다음 결과를 확인하는 것이 좋습니다. &lt;code&gt;Toggle&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="36b1daa5d9b179778ea122685bd4a019f602d46b" translate="yes" xml:space="preserve">
          <source>We recommend going through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;this JavaScript overview&lt;/a&gt; to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning React.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;이 JavaScript 개요&lt;/a&gt; 를 통해 지식 수준을 확인하는 것이 좋습니다 . 30 분에서 1 시간이 걸리지 만 React를 배우는 것이 더 자신감이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c51aa488fbf01c0bfe43f52e75c750fe6169a43" translate="yes" xml:space="preserve">
          <source>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</source>
          <target state="translated">대문자로 구성 요소의 이름을 지정하는 것이 좋습니다. 소문자로 시작하는 구성 요소가있는 경우 JSX에서 사용하기 전에 대문자로 변수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7db5b6288d689438ea763cca5989dd7db15ed6d2" translate="yes" xml:space="preserve">
          <source>We recommend naming props from the component&amp;rsquo;s own point of view rather than the context in which it is being used.</source>
          <target state="translated">컴포넌트를 사용하는 컨텍스트가 아닌 컴포넌트 자체 관점에서 소품의 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4e15764df958d424fa327a0c196872978d94f795" translate="yes" xml:space="preserve">
          <source>We recommend that such components use the special &lt;code&gt;children&lt;/code&gt; prop to pass children elements directly into their output:</source>
          <target state="translated">이러한 구성 요소는 특수 &lt;code&gt;children&lt;/code&gt; 소품을 사용하여 하위 요소를 출력에 직접 전달 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c066bd0b31ba19b1ea60f7d180f0c929fb5bfc2b" translate="yes" xml:space="preserve">
          <source>We recommend that you don&amp;rsquo;t skip topics because they build on each other.</source>
          <target state="translated">주제가 서로 구축되므로 주제를 건너 뛰지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7378b8164ba09b0803d591f679c436a1534386de" translate="yes" xml:space="preserve">
          <source>We recommend to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;pass &lt;code&gt;dispatch&lt;/code&gt; down in context&lt;/a&gt; rather than individual callbacks in props. The approach below is only mentioned here for completeness and as an escape hatch.</source>
          <target state="translated">소품의 개별 콜백이 아닌 &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;상황에 따라 &lt;/a&gt; &lt;code&gt;dispatch&lt;/code&gt; 를 전달하는 것이 좋습니다 . 아래의 접근 방식은 완전성과 탈출구로 여기에서만 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="38df0f4397ee97f12fb96f12d239661a17367c93" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to enable and encourage writing tests that use your components as the end users do.</source>
          <target state="translated">최종 사용자와 마찬가지로 구성 요소를 사용하는 테스트 작성을 활성화하고 장려하도록 설계된 &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4c6b613a8456e9f6cb8c62aa576baeb43c5ccbbd" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="translated">ES6 및 JSX 코드가 올바르게 강조 표시되도록 선택한 편집기에 &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&quot;Babel&quot;언어 정의&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="87a9dda197e65da63033ba548fda02343c3b83df" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/en/next/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="translated">We recommend using the &lt;a href=&quot;https://babeljs.io/docs/en/next/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</target>
        </trans-unit>
        <trans-unit id="d8f79aded3b19e2f5ffe654e038c348525259095" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; rule as part of our &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; 패키지의 일부로 &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt; &lt;code&gt;exhaustive-deps&lt;/code&gt; &lt;/a&gt; 규칙을 사용하는 것이 좋습니다 . 종속성이 잘못 지정된 경우 경고하고 수정 사항을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ea209ebd83cc25229df26adf48f3d2ced0664327" translate="yes" xml:space="preserve">
          <source>We released an ESLint plugin called &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; that enforces these two rules. You can add this plugin to your project if you&amp;rsquo;d like to try it:</source>
          <target state="translated">이 두 규칙을 적용하는 &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt; &lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt; &lt;/a&gt; 라는 ESLint 플러그인을 출시했습니다 . 이 플러그인을 사용하려는 경우 프로젝트에이 플러그인을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b062bd2fdca7e9e1ab4dd5cb060c69707aef4fe" translate="yes" xml:space="preserve">
          <source>We split JSX over multiple lines for readability. While it isn&amp;rsquo;t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;automatic semicolon insertion&lt;/a&gt;.</source>
          <target state="translated">가독성을 위해 JSX를 여러 줄로 나눕니다. 필요하지는 않지만 &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;자동 세미콜론 삽입&lt;/a&gt; 의 함정을 피하기 위해 괄호로 묶는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2979eccc260e51754eafcade66e564e9baada836" translate="yes" xml:space="preserve">
          <source>We start fetching posts</source>
          <target state="translated">게시물을 가져 오기 시작합니다</target>
        </trans-unit>
        <trans-unit id="ca6bb754623f873e0a4dcdef4ad2532d3958b1fc" translate="yes" xml:space="preserve">
          <source>We start fetching user details</source>
          <target state="translated">사용자 정보를 가져 오기 시작합니다</target>
        </trans-unit>
        <trans-unit id="04adad35ca195632fb236b9657e9704ced9d2d7c" translate="yes" xml:space="preserve">
          <source>We think it is better to offer a &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;gradual migration strategy&lt;/a&gt; than to make huge breaking changes &amp;mdash; or to let React stagnate into irrelevance.</source>
          <target state="translated">큰 변화를 주거나 React를 무관하게 만드는 것보다 &lt;a href=&quot;faq-versioning#commitment-to-stability&quot;&gt;점진적인 마이그레이션 전략&lt;/a&gt; 을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9950cb366a5eeff7d38fd73f4a0d3de60ab1d902" translate="yes" xml:space="preserve">
          <source>We used an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow function&lt;/a&gt; above, but it also works with regular functions:</source>
          <target state="translated">위 의 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 기능을&lt;/a&gt; 사용 했지만 일반 기능에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d06765809acf74687f0fa91ffe1041b5eaa0934" translate="yes" xml:space="preserve">
          <source>We wait&amp;hellip;</source>
          <target state="translated">우리는 기다립니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="883db07b441bd1cc42aaa22c4d8c5fa1d14f3d84" translate="yes" xml:space="preserve">
          <source>We want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;set up a timer&lt;/a&gt; whenever the &lt;code&gt;Clock&lt;/code&gt; is rendered to the DOM for the first time. This is called &amp;ldquo;mounting&amp;rdquo; in React.</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 이 DOM에 처음 렌더링 될 때마다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval&quot;&gt;타이머&lt;/a&gt; 를 설정 하려고합니다 . 이것을 React에서&amp;ldquo;마운팅&amp;rdquo;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e60a58cd26da36dc6344202c0599d60697f33fbb" translate="yes" xml:space="preserve">
          <source>We will attach a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; to the root DOM element. Inside &lt;code&gt;componentDidMount&lt;/code&gt;, we will get a reference to it so we can pass it to the jQuery plugin.</source>
          <target state="translated">루트 DOM 요소에 &lt;a href=&quot;refs-and-the-dom&quot;&gt;참조&lt;/a&gt; 를 첨부 할 것 입니다. &lt;code&gt;componentDidMount&lt;/code&gt; 내부 에서 참조를 가져 와서 jQuery 플러그인으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74b07ae6f3f43fb223a13322a5557fa91ee2240" translate="yes" xml:space="preserve">
          <source>We will explain these steps below in detail.</source>
          <target state="translated">아래에서 이러한 단계를 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="44e2af1182c660aac62472f00fe7cd374c0bec16" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;.</source>
          <target state="translated">We will explore rendering React elements to the DOM in the &lt;a href=&quot;rendering-elements&quot;&gt;next section&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="727da5b71551ddb95c401e73e8e543adf070a83e" translate="yes" xml:space="preserve">
          <source>We will explore rendering React elements to the DOM in the next section.</source>
          <target state="translated">다음 섹션에서 React 요소를 DOM에 렌더링하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="971788bde50fd928ed6ba8e3bf2b7bb52780ffe5" translate="yes" xml:space="preserve">
          <source>We will implement it as an &lt;a href=&quot;uncontrolled-components&quot;&gt;uncontrolled component&lt;/a&gt; for simplicity.</source>
          <target state="translated">단순성을 위해 &lt;a href=&quot;uncontrolled-components&quot;&gt;제어되지 않은 구성 요소&lt;/a&gt; 로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1a236deb13b0671afe90e0152c0f4b89aa0714eb" translate="yes" xml:space="preserve">
          <source>We will later add the timer code back to the component itself.</source>
          <target state="translated">나중에 타이머 코드를 구성 요소 자체에 다시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b0a6b047e5052fd0d39b2c6745d932b87cc1c444" translate="yes" xml:space="preserve">
          <source>We will move the &lt;code&gt;date&lt;/code&gt; from props to state in three steps:</source>
          <target state="translated">3 단계로 &lt;code&gt;date&lt;/code&gt; 를 소품에서 상태 로 옮길 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c76792b9c2d19f72980bcb3b0acff6bb2647f253" translate="yes" xml:space="preserve">
          <source>We will now add a brand new feature to the profile page &amp;mdash; a list of fun facts about a person:</source>
          <target state="translated">이제 프로필 페이지에 사람에 대한 재미있는 사실 목록 인 새로운 기능을 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dbb37dfdc07e84f9e43a35660e37fc112399531" translate="yes" xml:space="preserve">
          <source>We will post to the &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React blog&lt;/a&gt; when we&amp;rsquo;re ready to announce new experiments, but that doesn&amp;rsquo;t mean we will publicize every experiment.</source>
          <target state="translated">우리는 새로운 실험을 발표 할 준비가되었을 때 &lt;a href=&quot;https://reactjs.org/blog&quot;&gt;React 블로그에 게시&lt;/a&gt; 할 것이지만 모든 실험을 공개한다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2a8482ef7156081f1581eefc773bc336f6981bd6" translate="yes" xml:space="preserve">
          <source>We will start with a component called &lt;code&gt;BoilingVerdict&lt;/code&gt;. It accepts the &lt;code&gt;celsius&lt;/code&gt; temperature as a prop, and prints whether it is enough to boil the water:</source>
          <target state="translated">&lt;code&gt;BoilingVerdict&lt;/code&gt; 라는 구성 요소로 시작 하겠습니다 . 그것은 &lt;code&gt;celsius&lt;/code&gt; 온도를 소품으로 받아들이고 물을 끓일 정도로 충분한 지 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="dadee525eff6a00a825d77ee71e7e982946df9ab" translate="yes" xml:space="preserve">
          <source>We will store the current input&amp;rsquo;s &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; in its local state. This is the state we &amp;ldquo;lifted up&amp;rdquo; from the inputs, and it will serve as the &amp;ldquo;source of truth&amp;rdquo; for both of them. It is the minimal representation of all the data we need to know in order to render both inputs.</source>
          <target state="translated">현재 입력의 &lt;code&gt;temperature&lt;/code&gt; 와 &lt;code&gt;scale&lt;/code&gt; 을 로컬 상태로 저장합니다. 이것은 우리가 입력에서 &quot;올려 진&quot;상태이며, 둘 다에 대한 &quot;진리의 근원&quot;이 될 것입니다. 두 입력을 모두 렌더링하기 위해 알아야 할 모든 데이터의 최소 표현입니다.</target>
        </trans-unit>
        <trans-unit id="d01910e116749e98643c489148eb7de5ffdd9fe0" translate="yes" xml:space="preserve">
          <source>We will tear down the timer in the &lt;code&gt;componentWillUnmount()&lt;/code&gt; lifecycle method:</source>
          <target state="translated">&lt;code&gt;componentWillUnmount()&lt;/code&gt; 라이프 사이클 메소드 에서 타이머를 분리합니다 .</target>
        </trans-unit>
        <trans-unit id="e654907385791ce9020004666c8f0606387ea52d" translate="yes" xml:space="preserve">
          <source>We will use them right below.</source>
          <target state="translated">바로 아래에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="8554f0c6b7512278a4491bcbd1d0b8d3364d7dec" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t pass &lt;code&gt;this.props.onChange&lt;/code&gt; directly to Chosen because component&amp;rsquo;s props might change over time, and that includes event handlers. Instead, we will declare a &lt;code&gt;handleChange()&lt;/code&gt; method that calls &lt;code&gt;this.props.onChange&lt;/code&gt;, and subscribe it to the jQuery &lt;code&gt;change&lt;/code&gt; event:</source>
          <target state="translated">컴포넌트의 props는 시간이 지남에 따라 변경 될 수 있으며 여기에는 이벤트 핸들러가 포함되어 있으므로 &lt;code&gt;this.props.onChange&lt;/code&gt; 를 Chosen에 직접 전달하지 않습니다 . 대신 &lt;code&gt;this.props.onChange&lt;/code&gt; 를 호출 하는 &lt;code&gt;handleChange()&lt;/code&gt; 메소드를 선언 하고 jQuery &lt;code&gt;change&lt;/code&gt; 이벤트에 가입합니다 .</target>
        </trans-unit>
        <trans-unit id="1dca911b430b3370f62cdffc47de7a06fdd5c7b6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll address this in two steps:</source>
          <target state="translated">이 문제를 두 단계로 해결하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e57f940373fd0c5266442a10be93fdb7e4add9cd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue this page with an in-depth look at some aspects of &lt;code&gt;useEffect&lt;/code&gt; that experienced React users will likely be curious about. Don&amp;rsquo;t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.</source>
          <target state="translated">이 페이지는 계속해서 사용의 일부 측면에 &lt;code&gt;useEffect&lt;/code&gt; 심도있게 살펴볼 것입니다. 경험이있는 React 사용자가 궁금 할 것입니다. 지금 그들에게 파헤칠 의무를 느끼지 마십시오. 언제든지이 페이지로 돌아와서 효과 후크에 대한 자세한 내용을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cbd6e1d166c852966f9e06d4a20311c24f2202" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a &lt;code&gt;Greeting&lt;/code&gt; component that displays either of these components depending on whether a user is logged in:</source>
          <target state="translated">사용자 로그인 여부에 따라 다음 구성 요소 중 하나를 표시 하는 &lt;code&gt;Greeting&lt;/code&gt; 구성 요소를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="949801e315854c5c1f32189a838ce3882724d1cc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480d6951f304afe90e50d8db2ae84d223b006104" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss this more in &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용 &lt;a href=&quot;hooks-effect#tip-use-multiple-effects-to-separate-concerns&quot;&gt;은 Effect Hook 사용에서 설명합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127966720e15953e98cccc3796d46bce910c94fb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start learning about Hooks by comparing this code to an equivalent class example.</source>
          <target state="translated">이 코드를 동등한 클래스 예제와 비교하여 Hooks에 대해 배우기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2e722f3732f23870f1c4ff8fe747d22265714de2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test it using React DOM. To make sure that the behavior matches what happens in the browser, we&amp;rsquo;ll wrap the code rendering and updating it into &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;ReactTestUtils.act()&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">우리는 React DOM을 사용하여 테스트 할 것입니다. 브라우저에서 발생하는 동작과 동작이 일치하는지 확인하기 위해 코드 렌더링을 래핑하고이를 &lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;ReactTestUtils.act()&lt;/code&gt; &lt;/a&gt; 호출 로 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="a76fcdcb61157f6e0610c1005c5c3f29ebd7936e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll wrap that state update into &lt;code&gt;startTransition&lt;/code&gt;. That&amp;rsquo;s how we tell React &lt;strong&gt;we don&amp;rsquo;t mind React delaying that state update&lt;/strong&gt; if it leads to an undesirable loading state:</source>
          <target state="translated">우리는 그 상태 업데이트를 &lt;code&gt;startTransition&lt;/code&gt; 으로 감쌀 것입니다 . 그것이 React에게 바람직하지 않은 로딩 상태로 이어질 경우 &lt;strong&gt;React가 상태 업데이트를 지연시키는 것을 신경 쓰지 않는&lt;/strong&gt; 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="cb815fabe0b5ab52d41ee9b7ea186de1f4f0109c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re &lt;strong&gt;using npm here only to install the JSX preprocessor;&lt;/strong&gt; you won&amp;rsquo;t need it for anything else. Both React and the application code can stay as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags with no changes.</source>
          <target state="translated">우리는하고 있습니다 &lt;strong&gt;만 JSX 처리기를 설치하려면 여기를 NPM을 사용하여; &lt;/strong&gt;다른 것에는 필요하지 않습니다. React와 애플리케이션 코드는 모두 변경없이 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 유지 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b0310a310cf06f594a40e03c38a430ad9503681" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re Still Figuring This Out</source>
          <target state="translated">우리는 여전히 이것을 알아내는 중입니다.</target>
        </trans-unit>
        <trans-unit id="ed67ce78b0f3e99b0d082bb50f326185eb0b81b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also starting to see how Hooks solve problems outlined in &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt;. We&amp;rsquo;ve seen how effect cleanup avoids duplication in &lt;code&gt;componentDidUpdate&lt;/code&gt; and &lt;code&gt;componentWillUnmount&lt;/code&gt;, brings related code closer together, and helps us avoid bugs. We&amp;rsquo;ve also seen how we can separate effects by their purpose, which is something we couldn&amp;rsquo;t do in classes at all.</source>
          <target state="translated">또한 후크에서 &lt;a href=&quot;hooks-intro#motivation&quot;&gt;동기 부여에&lt;/a&gt; 설명 된 문제를 어떻게 해결하는지 살펴보기 시작했습니다 . effect cleanup이 &lt;code&gt;componentDidUpdate&lt;/code&gt; 와 &lt;code&gt;componentWillUnmount&lt;/code&gt; 에서 중복을 피하고 관련 코드를 더 가깝게 만들고 버그를 피하는 방법을 보았습니다 . 또한 우리는 수업에서 할 수 없었던 목적에 따라 효과를 분리하는 방법을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="6da9903b5d3ba7eb4397ce158c0f6108377a0f35" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using &lt;code&gt;isPending&lt;/code&gt; to communicate the state transition progress to the user and to disable the button.</source>
          <target state="translated">우리가 사용하고있는 &lt;code&gt;isPending&lt;/code&gt; 사용자에게 상태 전이 진행 상황을 의사 소통을하고 버튼을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6735373f84ab2dadb0420bcc149f487be0787431" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using this code in production (and it works for us) but there are still some bugs, missing features, and gaps in the documentation. We&amp;rsquo;d like to hear more about what breaks in Concurrent Mode so we can better prepare it for an official stable release in the future.</source>
          <target state="translated">우리는 프로덕션 환경에서이 코드를 사용하고 있지만 우리에게는 효과가 있지만 문서에는 여전히 몇 가지 버그, 누락 된 기능 및 차이가 있습니다. Concurrent Mode에서 발생하는 문제에 대해 더 많이 듣고 싶습니다. 향후 공식적인 안정적인 릴리스를 위해 더 잘 준비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1092279dfe88e8ae37dd255b457e80f4fcd016f8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already kicked off the requests in &lt;code&gt;fetchProfileData()&lt;/code&gt;. It gave us a special &amp;ldquo;resource&amp;rdquo; instead of a Promise. In a realistic example, it would be provided by our data library&amp;rsquo;s Suspense integration, like Relay.</source>
          <target state="translated">&lt;code&gt;fetchProfileData()&lt;/code&gt; 의 요청을 이미 시작했습니다 . 그것은 우리에게 약속 대신 특별한&amp;ldquo;자원&amp;rdquo;을 주었다. 실제 예에서는 Relay와 같은 데이터 라이브러리의 Suspense 통합을 통해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d3fc6ac18f17043ca4acd94bf8d17f2db51154a1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen this example at the top of this page, but let&amp;rsquo;s take a closer look at it:</source>
          <target state="translated">이 페이지 상단에서이 예제를 이미 보았지만 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e057c5796230f4d10c4ca87533025e33e8d57483" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already used &lt;code&gt;startTransition&lt;/code&gt; to wrap the state update. Now we&amp;rsquo;re going to use &lt;code&gt;isPending&lt;/code&gt; too. React gives this boolean to us so we can tell whether &lt;strong&gt;we&amp;rsquo;re currently waiting for this transition to finish&lt;/strong&gt;. We&amp;rsquo;ll use it to indicate that something is happening:</source>
          <target state="translated">우리는 이미 &lt;code&gt;startTransition&lt;/code&gt; 을 사용 하여 상태 업데이트를 래핑했습니다. 이제 &lt;code&gt;isPending&lt;/code&gt; 도 사용할 것 입니다. 리 액트는이 부울을 우리에게 제공하므로 &lt;strong&gt;현재이 전환이 끝나기를 기다리고&lt;/strong&gt; 있는지 알 수 있습니다 . 우리는 무언가가 일어나고 있음을 나타 내기 위해 그것을 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="9aced3aa1f133d3833efd40f37731bb88c66df03" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve fixed the first problem (suspending outside of a transition). But now because of the transition, our state doesn&amp;rsquo;t update immediately, and it can&amp;rsquo;t &amp;ldquo;drive&amp;rdquo; a controlled input!</source>
          <target state="translated">첫 번째 문제가 해결되었습니다 (전환 외부에서 중단됨). 그러나 이제 전환으로 인해 상태가 즉시 업데이트되지 않으며 제어 된 입력을 &quot;구동&quot;할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="82123073614b7e2a1707ace493cbc03906ee8fa4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve found that most people don&amp;rsquo;t enjoy manually passing callbacks through every level of a component tree. Even though it is more explicit, it can feel like a lot of &amp;ldquo;plumbing&amp;rdquo;.</source>
          <target state="translated">우리는 대부분의 사람들이 컴포넌트 트리의 모든 레벨을 통해 수동으로 콜백을 전달하는 것을 좋아하지 않는다는 것을 알게되었습니다. 더 명시 적이지만 많은&amp;ldquo;배관&amp;rdquo;처럼 느낄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b337075185a61e05c782a8165f31c63d15e390" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it in the component that updates the state.</source>
          <target state="translated">We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it in the component that updates the state.</target>
        </trans-unit>
        <trans-unit id="20a8f1d5554de07fa29800d8a4ff750db37e3153" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve imported the &lt;code&gt;useTransition&lt;/code&gt; Hook and used it the component that updates the state.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; Hook를 가져 와서 상태를 업데이트하는 구성 요소를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="f001cf0b3f4cc8ba635fdca602bd1a42ea0135b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve learned that &lt;code&gt;useEffect&lt;/code&gt; lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:</source>
          <target state="translated">우리는 &lt;code&gt;useEffect&lt;/code&gt; 를 통해 컴포넌트 렌더링 후 다양한 종류의 부작용을 표현할 수 있다는 것을 배웠습니다 . 일부 효과는 정리가 필요할 수 있으므로 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78fbd837f605a563c276531668570643feff866d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered the basics of Suspense for Data Fetching! Importantly, we now better understand &lt;em&gt;why&lt;/em&gt; Suspense works this way, and how it fits into the data fetching space.</source>
          <target state="translated">이제 Suspense for Data Fetching의 기본 사항을 다뤘습니다! 중요한 것은 이제 Suspense가 이러한 방식으로 작동 하는 &lt;em&gt;이유&lt;/em&gt; 와 데이터 가져 오기 공간에 어떻게 적용되는지 이해 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b9d77fbf8650ce9fdf27f7587fe7efc208425285" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve often had to maintain components that started out simple but grew into an unmanageable mess of stateful logic and side effects. Each lifecycle method often contains a mix of unrelated logic. For example, components might perform some data fetching in &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. However, the same &lt;code&gt;componentDidMount&lt;/code&gt; method might also contain some unrelated logic that sets up event listeners, with cleanup performed in &lt;code&gt;componentWillUnmount&lt;/code&gt;. Mutually related code that changes together gets split apart, but completely unrelated code ends up combined in a single method. This makes it too easy to introduce bugs and inconsistencies.</source>
          <target state="translated">우리는 종종 간단하게 시작되었지만 상태 저장 논리 및 부작용으로 관리 할 수없는 혼란으로 성장한 구성 요소를 유지해야했습니다. 각 수명주기 방법에는 종종 관련없는 논리가 혼합되어 있습니다. 예를 들어, 구성 요소는 &lt;code&gt;componentDidMount&lt;/code&gt; 및 &lt;code&gt;componentDidUpdate&lt;/code&gt; 에서 일부 데이터 페치를 수행 할 수 있습니다 . 그러나 동일한 &lt;code&gt;componentDidMount&lt;/code&gt; 메소드에는 &lt;code&gt;componentWillUnmount&lt;/code&gt; 에서 정리를 수행하여 이벤트 리스너를 설정하는 관련되지 않은 일부 논리가 포함될 수도 있습니다 . 함께 변경되는 상호 관련된 코드는 분리되지만 완전히 관련되지 않은 코드는 단일 방법으로 결합됩니다. 이것은 버그와 불일치를 도입하기가 너무 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="37efc1571cdaa97dd3e90e2682390ebf13fff680" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve passed &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; to stay on the previous screen for at most 3 seconds.</source>
          <target state="translated">우리는 통과했습니다 &lt;code&gt;{timeoutMs: 3000}&lt;/code&gt; 최대 3 초 이전 화면에 머물.</target>
        </trans-unit>
        <trans-unit id="f3cab8c9ea1114a4c30f14c35d44b604fb9099d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve prepared a &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ page&lt;/a&gt; that answers the most common questions about Hooks.</source>
          <target state="translated">&lt;a href=&quot;hooks-faq&quot;&gt;후크&lt;/a&gt; 에 대한 가장 일반적인 질문에 답변 하는 후크 FAQ 페이지 를 준비했습니다 .</target>
        </trans-unit>
        <trans-unit id="602a0253fdc011ba6ec4f21c8ecf132af5c3bcd0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve said before that Concurrent Mode is like React working &amp;ldquo;on a branch&amp;rdquo;. Branches are useful not only for short-term fixes, but also for long-running features. Sometimes you might work on a feature, but it could take weeks before it&amp;rsquo;s in a &amp;ldquo;good enough state&amp;rdquo; to merge into master. This side of our version control metaphor applies to rendering too.</source>
          <target state="translated">우리는 Concurrent Mode가 React가&amp;ldquo;지점에서&amp;rdquo;일하는 것과 같다고 전에 말했습니다. 분기는 단기 수정뿐만 아니라 장기 실행 기능에도 유용합니다. 경우에 따라 기능에 대해 작업 할 수도 있지만 마스터에 병합하기에 &quot;충분한 상태&quot;가되기까지 몇 주가 걸릴 수 있습니다. 버전 관리 비유의이 측면은 렌더링에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc522ebd2ef515724e353941f7b4486ad297dcb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve solved the previous network &amp;ldquo;waterfall&amp;rdquo;, but accidentally introduced a different one. We wait for &lt;em&gt;all&lt;/em&gt; data to come back with &lt;code&gt;Promise.all()&lt;/code&gt; inside &lt;code&gt;fetchProfileData&lt;/code&gt;, so now we can&amp;rsquo;t render profile details until the posts have been fetched too. We have to wait for both.</source>
          <target state="translated">이전 네트워크 &quot;폭포&quot;를 해결했지만 실수로 다른 네트워크를 도입했습니다. &lt;em&gt;모든&lt;/em&gt; 데이터가 &lt;code&gt;Promise.all()&lt;/code&gt; 내부에 Promise.all () 으로 돌아올 때까지 기다리 므로 게시물도 가져 &lt;code&gt;fetchProfileData&lt;/code&gt; 전까지는 프로필 세부 정보를 렌더링 할 수 없습니다. 우리는 둘 다 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="fc4e74fbf1eee3d969dbfb73e0089d683c0dcc2e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve wrapped our state update into &lt;code&gt;startTransition&lt;/code&gt; to tell React it&amp;rsquo;s okay to delay it.</source>
          <target state="translated">상태 업데이트를 &lt;code&gt;startTransition&lt;/code&gt; 에 래핑 하여 React에게 지연해도 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="7d934364c9313824f6e77d311ab14f3ddd86f222" translate="yes" xml:space="preserve">
          <source>Web Components</source>
          <target state="translated">웹 컴포넌트</target>
        </trans-unit>
        <trans-unit id="89462d36c40b3b8c651a2fecd29c6a47d67d8652" translate="yes" xml:space="preserve">
          <source>Web Components often expose an imperative API. For instance, a &lt;code&gt;video&lt;/code&gt; Web Component might expose &lt;code&gt;play()&lt;/code&gt; and &lt;code&gt;pause()&lt;/code&gt; functions. To access the imperative APIs of a Web Component, you will need to use a ref to interact with the DOM node directly. If you are using third-party Web Components, the best solution is to write a React component that behaves as a wrapper for your Web Component.</source>
          <target state="translated">웹 구성 요소는 종종 명령형 API를 노출합니다. 예를 들어, &lt;code&gt;video&lt;/code&gt; 웹 컴포넌트는 &lt;code&gt;play()&lt;/code&gt; 및 &lt;code&gt;pause()&lt;/code&gt; 함수를 노출 할 수 있습니다 . 웹 컴포넌트의 필수 API에 액세스하려면 참조를 사용하여 DOM 노드와 직접 상호 작용해야합니다. 타사 웹 구성 요소를 사용하는 경우 가장 좋은 해결책은 웹 구성 요소의 래퍼로 동작하는 React 구성 요소를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e00b9f789bd874e0ed643701b463e09b446cea8c" translate="yes" xml:space="preserve">
          <source>Web accessibility (also referred to as &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt;) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</source>
          <target state="translated">웹 접근성 ( &lt;a href=&quot;https://en.wiktionary.org/wiki/a11y&quot;&gt;&lt;strong&gt;a11y&lt;/strong&gt;&lt;/a&gt; 라고도 함 )은 모든 사람이 사용할 수있는 웹 사이트의 디자인 및 제작입니다. 보조 기술이 웹 페이지를 해석 할 수있게하려면 내게 필요한 옵션 지원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92d4811d4665c317fc3c6c88f65cc53f18cc4519" translate="yes" xml:space="preserve">
          <source>WebAIM - Color Contrast Checker</source>
          <target state="translated">WebAIM-색상 대비 검사기</target>
        </trans-unit>
        <trans-unit id="f16c2ab8bf1a5aa2f65c3997b33b403520906211" translate="yes" xml:space="preserve">
          <source>WebAIM - Document Language</source>
          <target state="translated">WebAIM-문서 언어</target>
        </trans-unit>
        <trans-unit id="433235ab1e74117e5fc4f15627618af7d9236d56" translate="yes" xml:space="preserve">
          <source>WebAIM - Skip Navigation Links</source>
          <target state="translated">WebAIM-탐색 링크 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="3352c721cf8b15e3c5ba7494a77646493b7d5d12" translate="yes" xml:space="preserve">
          <source>WebAIM - Using JAWS to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-JAWS를 사용하여 웹 액세스 가능성 평가</target>
        </trans-unit>
        <trans-unit id="0fc47857541ad45199770ccef6d4b96d6599031d" translate="yes" xml:space="preserve">
          <source>WebAIM - Using NVDA to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-NVDA를 사용하여 웹 접근성 평가</target>
        </trans-unit>
        <trans-unit id="813fcd4a26c1f886c1d65397d9ec24b2e1c6f3ee" translate="yes" xml:space="preserve">
          <source>WebAIM - Using VoiceOver to Evaluate Web Accessibility</source>
          <target state="translated">WebAIM-VoiceOver를 사용하여 웹 접근성 평가</target>
        </trans-unit>
        <trans-unit id="30fc76fba519e636eb93a339a1826e6626a74fa8" translate="yes" xml:space="preserve">
          <source>WebAIM WAVE</source>
          <target state="translated">WebAIM 웨이브</target>
        </trans-unit>
        <trans-unit id="c6dd3413876261d9d5dfa5f7c1dc00a9a234d113" translate="yes" xml:space="preserve">
          <source>WebAIM looks at form validation</source>
          <target state="translated">WebAIM은 양식 유효성 검사를 봅니다.</target>
        </trans-unit>
        <trans-unit id="9a2d1a6a5c28bcf72a8eb9de74d12f7b9c20191c" translate="yes" xml:space="preserve">
          <source>WebAIM shows us how to label elements</source>
          <target state="translated">WebAIM은 요소에 레이블을 지정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fc2e6cbaeaac02696deef92a72e32fd4e674290a" translate="yes" xml:space="preserve">
          <source>WebAIM talks about keyboard accessibility</source>
          <target state="translated">키보드 접근성에 대한 WebAIM 이야기</target>
        </trans-unit>
        <trans-unit id="122c8865b61493b6f789d0524edf7ac87efe4d03" translate="yes" xml:space="preserve">
          <source>Webpack v4+ will minify your code by default in production mode.</source>
          <target state="translated">Webpack v4 +는 기본적으로 프로덕션 모드에서 코드를 축소합니다.</target>
        </trans-unit>
        <trans-unit id="91b3f9b7f9ed1db7fbbff897990621a1f329c6b8" translate="yes" xml:space="preserve">
          <source>What Counts as a Breaking Change?</source>
          <target state="translated">주요 변화로 간주되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="306cd9673550a7548afb1d28d13a9e4ab675260a" translate="yes" xml:space="preserve">
          <source>What Goes Into an Experimental Release?</source>
          <target state="translated">실험용 릴리스에는 무엇이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c1c5f3b99c4945dd281accfdc44da90d90092580" translate="yes" xml:space="preserve">
          <source>What If I Don&amp;rsquo;t Use Relay?</source>
          <target state="translated">릴레이를 사용하지 않으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="8f3ce40e7f755e7f9bd29a4ca2ef4eb8d9b5ec5b" translate="yes" xml:space="preserve">
          <source>What Is Concurrent Mode?</source>
          <target state="translated">동시 모드 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3a27620fdbb167ecbd14c72dcff5ace0f1c64383" translate="yes" xml:space="preserve">
          <source>What Is Suspense, Exactly?</source>
          <target state="translated">서스펜스 란 무엇인가?</target>
        </trans-unit>
        <trans-unit id="e8a22cac534b1f2cd30ed5f98b635c16f790eab2" translate="yes" xml:space="preserve">
          <source>What Suspense Is Not</source>
          <target state="translated">서스펜스가 아닌 것</target>
        </trans-unit>
        <trans-unit id="c783af8d30d3e4364690860bb0374ea57809d4d3" translate="yes" xml:space="preserve">
          <source>What Suspense Lets You Do</source>
          <target state="translated">서스펜스가 할 수있는 일</target>
        </trans-unit>
        <trans-unit id="07167e206dc36076e1208fc57a82343e684c51c1" translate="yes" xml:space="preserve">
          <source>What can I do if my effect dependencies change too often?</source>
          <target state="translated">효과 의존성이 너무 자주 바뀌면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="1cc6659d6c04ea72141e5d4aadbf96b176eef644" translate="yes" xml:space="preserve">
          <source>What can I do with Hooks that I couldn&amp;rsquo;t with classes?</source>
          <target state="translated">수업으로는 할 수 없었던 갈고리로 무엇을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cd3446a7312aac2facf235718a5ffd50e69c7d4a" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux &lt;code&gt;connect()&lt;/code&gt; and React Router?</source>
          <target state="translated">후크는 Redux &lt;code&gt;connect()&lt;/code&gt; 및 React Router와 같은 널리 사용되는 API에서 무엇을 의미 합니까?</target>
        </trans-unit>
        <trans-unit id="f691d89eec058d6953da17f694984d9b247497b5" translate="yes" xml:space="preserve">
          <source>What do Hooks mean for popular APIs like Redux connect() and React Router?</source>
          <target state="translated">후크는 Redux connect () 및 React Router와 같은 널리 사용되는 API에서 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="319d6cb4f612b1898af74f1d58e55bb9a00c7f16" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; mean?</source>
          <target state="translated">무엇 않습니다 &lt;code&gt;const [thing, setThing] = useState()&lt;/code&gt; 말인가요?</target>
        </trans-unit>
        <trans-unit id="64945305af0a0fa7d3c6dbaa11aaf7b00d606169" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;setState&lt;/code&gt; do?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 는 무엇을 합니까?</target>
        </trans-unit>
        <trans-unit id="f8684f51532e8049d48a76354c4c251f1768106b" translate="yes" xml:space="preserve">
          <source>What does const [thing, setThing] = useState() mean?</source>
          <target state="translated">const [thing, setThing] = useState ()는 무슨 뜻입니까?</target>
        </trans-unit>
        <trans-unit id="b4f867b8bb7e53e8c3b6611c9f1d46df6d3e89f0" translate="yes" xml:space="preserve">
          <source>What exactly do the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;lint rules&lt;/a&gt; enforce?</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;보푸라기 규칙&lt;/a&gt; 은 정확히 무엇을 시행합니까?</target>
        </trans-unit>
        <trans-unit id="07ef000a203cb6f931243d3fceed10fdf912e2fc" translate="yes" xml:space="preserve">
          <source>What exactly do the lint rules enforce?</source>
          <target state="translated">보푸라기 규칙은 정확히 무엇을 시행합니까?</target>
        </trans-unit>
        <trans-unit id="e3b196d959a7d912e75414dca815d74e2142c718" translate="yes" xml:space="preserve">
          <source>What if we want to show a spinner in a different place than &amp;ldquo;above&amp;rdquo; the component in a tree?</source>
          <target state="translated">트리에서 구성 요소를 &quot;위&quot;와 다른 위치에 스피너를 표시하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="d37eb6cbe5fc394050b5ba4dd59e15bb9146d921" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;React Fiber&amp;rdquo;?</source>
          <target state="translated">&amp;ldquo;반응 섬유&amp;rdquo;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="126626903bfa28709f9dc97154ed4c6b318643af" translate="yes" xml:space="preserve">
          <source>What is CSS-in-JS?</source>
          <target state="translated">CSS-in-JS 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b9b10ee223edff6297e6ec9600bac8dd2ffc48ff" translate="yes" xml:space="preserve">
          <source>What is the Virtual DOM?</source>
          <target state="translated">가상 DOM이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="44ad1d597a94eb0351fcc2bab4f5bc2476770773" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 와 &lt;code&gt;props&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="2153ca8a7eb6c240a2df099c7e84b57dedd442bd" translate="yes" xml:space="preserve">
          <source>What is the difference between passing an object or a function in &lt;code&gt;setState&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 에서 객체 또는 함수를 전달하는 것의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="ad6b021f6d6be586c97a85a04cd00cea15ecc6a0" translate="yes" xml:space="preserve">
          <source>What is the lifetime of a response? Should caching be global or local? Who manages the cache?</source>
          <target state="translated">응답의 수명은 얼마입니까? 캐싱은 글로벌 또는 로컬이어야합니까? 캐시는 누가 관리합니까?</target>
        </trans-unit>
        <trans-unit id="a7846b7c3a9328a7abfc787060ce35a9d897ee0d" translate="yes" xml:space="preserve">
          <source>What is the prior art for Hooks?</source>
          <target state="translated">후크의 선행 기술은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="84fa9a10d5b5938a5cfd5dcd3fbd211cd8ea85e2" translate="yes" xml:space="preserve">
          <source>What to Expect</source>
          <target state="translated">뭘 기대 할까</target>
        </trans-unit>
        <trans-unit id="e9a68218a8babe539cd10930840d839404a2a222" translate="yes" xml:space="preserve">
          <source>What would the equivalent of composing GraphQL queries look like for arbitrary Suspense data?</source>
          <target state="translated">임의의 서스펜스 데이터에 대해 GraphQL 쿼리를 구성하는 것과 동등한 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2482c806af9f88ec9421505cdbfb9c23ef1bde71" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Hook?</source>
          <target state="translated">후크 란?</target>
        </trans-unit>
        <trans-unit id="c0a7cdef0637bc5ca89d70c3638524e01a053b8e" translate="yes" xml:space="preserve">
          <source>Wheel Events</source>
          <target state="translated">휠 이벤트</target>
        </trans-unit>
        <trans-unit id="83b5d183aae32b6135d8bdcde578d304743623d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; is passed to &lt;code&gt;ReactDOM.render()&lt;/code&gt;, React calls the constructor of the &lt;code&gt;Clock&lt;/code&gt; component. Since &lt;code&gt;Clock&lt;/code&gt; needs to display the current time, it initializes &lt;code&gt;this.state&lt;/code&gt; with an object including the current time. We will later update this state.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; 에 전달됩니다 &lt;code&gt;ReactDOM.render()&lt;/code&gt; , 통화의 생성자 반작용 &lt;code&gt;Clock&lt;/code&gt; 구성 요소를. &lt;code&gt;Clock&lt;/code&gt; 은 현재 시간을 표시해야 하므로 현재 시간을 포함하는 객체로 &lt;code&gt;this.state&lt;/code&gt; 를 초기화 합니다. 나중에이 상태를 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="adb220ab22b57e8d612d3d8256e10868b648ed39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CommentListWithSubscription&lt;/code&gt; and &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; are rendered, &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt; will be passed a &lt;code&gt;data&lt;/code&gt; prop with the most current data retrieved from &lt;code&gt;DataSource&lt;/code&gt;:</source>
          <target state="translated">때 &lt;code&gt;CommentListWithSubscription&lt;/code&gt; 및 &lt;code&gt;BlogPostWithSubscription&lt;/code&gt; 이 렌더링, &lt;code&gt;CommentList&lt;/code&gt; 와 &lt;code&gt;BlogPost&lt;/code&gt; 전달 된 것 &lt;code&gt;data&lt;/code&gt; 에서 검색 한 최신 데이터와 소품 &lt;code&gt;DataSource&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0ccf62e1b79fa9fa20a9abbc82844e2c6ed7de3" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="translated">When React sees an element representing a user-defined component, it passes JSX attributes and children to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="f63f5b998c37b2aac7d34a276c80403e6fbede6f" translate="yes" xml:space="preserve">
          <source>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object &amp;ldquo;props&amp;rdquo;.</source>
          <target state="translated">React는 사용자 정의 컴포넌트를 나타내는 요소를 볼 때 단일 컴포넌트로 JSX 속성을이 컴포넌트에 전달합니다. 우리는이 객체를 &quot;props&quot;라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="b5267c08cb1e8413e3450f6204da4ef3df0d7972" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://create-react-app.dev/docs/code-splitting/&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://nextjs.org/docs/advanced-features/dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://create-react-app.dev/docs/code-splitting/&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://nextjs.org/docs/advanced-features/dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cd960a41239540628263b007251ff1ce228a4975" translate="yes" xml:space="preserve">
          <source>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you&amp;rsquo;re using Create React App, this is already configured for you and you can &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;start using it&lt;/a&gt; immediately. It&amp;rsquo;s also supported out of the box in &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt;.</source>
          <target state="translated">Webpack이이 구문을 발견하면 자동으로 앱을 코드 분할하기 시작합니다. React 앱 생성을 사용하는 경우 이미 구성되어 있으므로 즉시 &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/code-splitting&quot;&gt;사용할 수&lt;/a&gt; 있습니다. &lt;a href=&quot;https://github.com/zeit/next.js/#dynamic-import&quot;&gt;Next.js&lt;/a&gt; 에서도 기본적으로 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="24308061c4ea79dc3398cfc8567de4c5dd49d65a" translate="yes" xml:space="preserve">
          <source>When a button gets clicked, it starts a transition and calls &lt;code&gt;props.onClick()&lt;/code&gt; inside of it &amp;mdash; which triggers &lt;code&gt;handleRefreshClick&lt;/code&gt; in the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component. We start fetching the fresh data, but it doesn&amp;rsquo;t trigger a fallback because we&amp;rsquo;re inside a transition, and the 10 second timeout specified in the &lt;code&gt;useTransition&lt;/code&gt; call hasn&amp;rsquo;t passed yet. While a transition is pending, the button displays an inline loading indicator.</source>
          <target state="translated">버튼을 클릭하면 전환이 시작되고 내부에서 &lt;code&gt;props.onClick()&lt;/code&gt; 호출 하여 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 구성 요소 에서 &lt;code&gt;handleRefreshClick&lt;/code&gt; 을 트리거합니다 . 새로운 데이터를 가져 오기 시작하지만 전환 내부에 있기 때문에 폴백을 트리거하지 않으며 &lt;code&gt;useTransition&lt;/code&gt; 호출에 지정된 10 초 시간 초과 가 아직 지나지 않았습니다. 전환이 보류중인 동안 버튼에 인라인 로딩 표시기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88c0e0d8605eedba926805cc491ffa3edad3fcca" translate="yes" xml:space="preserve">
          <source>When a component is removed &lt;em&gt;from within&lt;/em&gt; a React tree, the cleanup is performed automatically, but because we are removing the entire tree by hand, we must call this method.</source>
          <target state="translated">React 트리 &lt;em&gt;내에서&lt;/em&gt; 컴포넌트를 제거 하면 정리가 자동으로 수행되지만 전체 트리를 손으로 제거하기 때문에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa03685bfee385115f05a87525bb34183aa7d3b6" translate="yes" xml:space="preserve">
          <source>When a component renders to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;findDOMNode&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. When a component renders to a string, &lt;code&gt;findDOMNode&lt;/code&gt; returns a text DOM node containing that value. As of React 16, a component may return a fragment with multiple children, in which case &lt;code&gt;findDOMNode&lt;/code&gt; will return the DOM node corresponding to the first non-empty child.</source>
          <target state="translated">구성 요소가 렌더링 할 때 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;findDOMNode&lt;/code&gt; 는 반환 &lt;code&gt;null&lt;/code&gt; . 구성 요소가 문자열로 렌더링되면 &lt;code&gt;findDOMNode&lt;/code&gt; 는 해당 값을 포함하는 텍스트 DOM 노드를 반환합니다. 반응 16에서, 컴포넌트는 다수의 하위를 가진 프래그먼트를 리턴 할 수 있으며,이 경우 &lt;code&gt;findDOMNode&lt;/code&gt; 는 비어 있지 않은 첫 번째 하위에 해당하는 DOM 노드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ebba8cb76e6c7b141346c24f24674447a518526e" translate="yes" xml:space="preserve">
          <source>When a component suspends, React needs to show the closest fallback. But the closest fallback to &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; is at the top level:</source>
          <target state="translated">구성 요소가 일시 중단되면 React는 가장 가까운 폴백을 표시해야합니다. 그러나 &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; 에 가장 가까운 대체 는 최상위 수준입니다.</target>
        </trans-unit>
        <trans-unit id="43f8277f42239eae9424a66a512a2fcabb104e3b" translate="yes" xml:space="preserve">
          <source>When a component updates, the instance stays the same, so that state is maintained across renders. React updates the props of the underlying component instance to match the new element, and calls &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; and &lt;code&gt;componentWillUpdate()&lt;/code&gt; on the underlying instance.</source>
          <target state="translated">구성 요소가 업데이트 될 때 인스턴스는 동일하게 유지되므로 렌더에서 상태가 유지됩니다. React는 새 요소와 일치하도록 기본 컴포넌트 인스턴스의 prop을 업데이트하고 기본 인스턴스에서 &lt;code&gt;componentWillReceiveProps()&lt;/code&gt; 및 &lt;code&gt;componentWillUpdate()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="29700bd1b2576f98f84deff1ab59eda1ac5d916a" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.</source>
          <target state="translated">컴포넌트의 props 또는 state가 변경되면 React는 새로 반환 된 요소를 이전에 렌더링 된 요소와 비교하여 실제 DOM 업데이트가 필요한지 여부를 결정합니다. 동일하지 않으면 React가 DOM을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="71688bf085f5be3641ad0e7683c86eab151bc2ac" translate="yes" xml:space="preserve">
          <source>When a component&amp;rsquo;s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called &amp;ldquo;reconciliation&amp;rdquo;.</source>
          <target state="translated">컴포넌트의 props 또는 state가 변경되면 React는 새로 반환 된 요소를 이전에 렌더링 된 요소와 비교하여 실제 DOM 업데이트가 필요한지 여부를 결정합니다. 동일하지 않으면 React가 DOM을 업데이트합니다. 이 과정을&amp;ldquo;조정&amp;rdquo;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="4a658d61a32f67b5097f57314a0f3ffb42c9b802" translate="yes" xml:space="preserve">
          <source>When a ref is passed to an element in &lt;code&gt;render&lt;/code&gt;, a reference to the node becomes accessible at the &lt;code&gt;current&lt;/code&gt; attribute of the ref.</source>
          <target state="translated">ref가 &lt;code&gt;render&lt;/code&gt; 의 요소에 전달되면 ref 의 &lt;code&gt;current&lt;/code&gt; 속성 에서 노드에 대한 참조에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="092bbc82c0f9752a97e3de82e29d782cdf9f9183" translate="yes" xml:space="preserve">
          <source>When an element type starts with a lowercase letter, it refers to a built-in component like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and results in a string &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt; passed to &lt;code&gt;React.createElement&lt;/code&gt;. Types that start with a capital letter like &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; compile to &lt;code&gt;React.createElement(Foo)&lt;/code&gt; and correspond to a component defined or imported in your JavaScript file.</source>
          <target state="translated">요소 유형이 소문자로 시작하면 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 과 같은 내장 컴포넌트 를 참조하고 문자열 &lt;code&gt;'div'&lt;/code&gt; 또는 &lt;code&gt;'span'&lt;/code&gt; 이 &lt;code&gt;React.createElement&lt;/code&gt; 로 전달됩니다 . &lt;code&gt;&amp;lt;Foo /&amp;gt;&lt;/code&gt; 와 같이 대문자로 시작하는 유형은 &lt;code&gt;React.createElement(Foo)&lt;/code&gt; 컴파일되며 JavaScript 파일에서 정의되거나 가져온 구성 요소에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f3b3db069005ff6eb433c8c7e16d92582e642386" translate="yes" xml:space="preserve">
          <source>When called, it should examine &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt; and return one of the following types:</source>
          <target state="translated">호출되면 &lt;code&gt;this.props&lt;/code&gt; 및 &lt;code&gt;this.state&lt;/code&gt; 를 검사 하고 다음 유형 중 하나를 리턴 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3e932a8184d9d49299869706c6d5892582b63c0e" translate="yes" xml:space="preserve">
          <source>When choosing testing tools, it is worth considering a few tradeoffs:</source>
          <target state="translated">테스트 도구를 선택할 때는 몇 가지 장단점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dffbe923ddf378219923364d4231ca60a1015b6" translate="yes" xml:space="preserve">
          <source>When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. For example:</source>
          <target state="translated">동일한 유형의 두 React DOM 요소를 비교할 때 React는 두 속성을 모두보고 동일한 기본 DOM 노드를 유지하며 변경된 속성 만 업데이트합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0950dde1c2700e4c81c02a18f0ea0517525ca827" translate="yes" xml:space="preserve">
          <source>When converting between these two elements, React knows to only modify the &lt;code&gt;color&lt;/code&gt; style, not the &lt;code&gt;fontWeight&lt;/code&gt;.</source>
          <target state="translated">이 두 요소 사이를 변환 할 때 React는 &lt;code&gt;fontWeight&lt;/code&gt; 가 아닌 &lt;code&gt;color&lt;/code&gt; 스타일 만 수정한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="684d074ff1bc6db8a43e7868a40828d155492a57" translate="yes" xml:space="preserve">
          <source>When diffing two trees, React first compares the two root elements. The behavior is different depending on the types of the root elements.</source>
          <target state="translated">두 개의 나무를 비교할 때 React는 먼저 두 개의 루트 요소를 비교합니다. 루트 요소의 유형에 따라 동작이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b3f4316f1f0610218ae53493262f1b06012ea13b" translate="yes" xml:space="preserve">
          <source>When is &lt;code&gt;setState&lt;/code&gt; asynchronous?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 는 언제 비동기입니까?</target>
        </trans-unit>
        <trans-unit id="eb68f1b04a107d4cc5de744e2d26501dbb590d6c" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; had specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="translated">When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; had specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt; &amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt; &amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</target>
        </trans-unit>
        <trans-unit id="9986343101ee6da7851b9828f0c4a4eaf4dce38b" translate="yes" xml:space="preserve">
          <source>When it previously rendered, the &lt;code&gt;Calculator&lt;/code&gt; has specified that &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Celsius &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleCelsiusChange&lt;/code&gt; method, and &lt;code&gt;onTemperatureChange&lt;/code&gt; of the Fahrenheit &lt;code&gt;TemperatureInput&lt;/code&gt; is the &lt;code&gt;Calculator&lt;/code&gt;&amp;rsquo;s &lt;code&gt;handleFahrenheitChange&lt;/code&gt; method. So either of these two &lt;code&gt;Calculator&lt;/code&gt; methods gets called depending on which input we edited.</source>
          <target state="translated">그 이전에 렌더링 할 때, &lt;code&gt;Calculator&lt;/code&gt; 것을 지정한 &lt;code&gt;onTemperatureChange&lt;/code&gt; 섭씨의 &lt;code&gt;TemperatureInput&lt;/code&gt; 이 는 IS &lt;code&gt;Calculator&lt;/code&gt; 의 &lt;code&gt;handleCelsiusChange&lt;/code&gt; 의 방법 및 &lt;code&gt;onTemperatureChange&lt;/code&gt; 화씨의 &lt;code&gt;TemperatureInput&lt;/code&gt; 은 은 IS &lt;code&gt;Calculator&lt;/code&gt; 의 &lt;code&gt;handleFahrenheitChange&lt;/code&gt; 의 방법. 따라서이 두 &lt;code&gt;Calculator&lt;/code&gt; 방법 중 하나 는 편집 한 입력에 따라 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b2aac6423622e177393a29a45bdfea31a200f8" translate="yes" xml:space="preserve">
          <source>When multiple components need to fetch data, this data may arrive in an unpredictable order. However, if you wrap these items in a &lt;code&gt;SuspenseList&lt;/code&gt;, React will not show an item in the list until previous items have been displayed (this behavior is adjustable).</source>
          <target state="translated">여러 구성 요소가 데이터를 가져와야하는 경우이 데이터는 예측할 수없는 순서로 도착할 수 있습니다. 그러나 이러한 항목을 &lt;code&gt;SuspenseList&lt;/code&gt; 에 랩하면 이전 항목이 표시 될 때까지 React가 목록에 항목을 표시하지 않습니다 (이 동작은 조정 가능함).</target>
        </trans-unit>
        <trans-unit id="42a683f16be3b2ba0e15fb0b13b5fd965aa7a2f8" translate="yes" xml:space="preserve">
          <source>When possible, we advise against exposing DOM nodes, but it can be a useful escape hatch. Note that this approach requires you to add some code to the child component. If you have absolutely no control over the child component implementation, your last option is to use &lt;a href=&quot;react-dom#finddomnode&quot;&gt;&lt;code&gt;findDOMNode()&lt;/code&gt;&lt;/a&gt;, but it is discouraged and deprecated in &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt;&lt;code&gt;StrictMode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능하면 DOM 노드 노출을 피하는 것이 좋지만 유용한 이스케이프 해치가 될 수 있습니다. 이 방법을 사용하려면 하위 구성 요소에 코드를 추가해야합니다. 하위 구성 요소 구현을 전혀 제어 할 수없는 경우 마지막 옵션은 &lt;a href=&quot;react-dom#finddomnode&quot;&gt; &lt;code&gt;findDOMNode()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이지만 &lt;a href=&quot;strict-mode#warning-about-deprecated-finddomnode-usage&quot;&gt; &lt;code&gt;StrictMode&lt;/code&gt; &lt;/a&gt; 에서 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="60dc9558f9f54b804963bf45bd2054c08d64c066" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;breaking changes&lt;/strong&gt;, we make a &lt;strong&gt;major release&lt;/strong&gt; by changing the &lt;strong&gt;x&lt;/strong&gt; number (ex: 15.6.2 to 16.0.0).</source>
          <target state="translated">풀어 주면 &lt;strong&gt;깨는 변화를&lt;/strong&gt; , 우리는 할 &lt;strong&gt;주요 릴리스를&lt;/strong&gt; 변화에 의해 &lt;strong&gt;X의&lt;/strong&gt; (: 15.6.2 16.0.0에 예) 수입니다.</target>
        </trans-unit>
        <trans-unit id="c51bee886f54f565c856364002a6f5a65ec91ed6" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;critical bug fixes&lt;/strong&gt;, we make a &lt;strong&gt;patch release&lt;/strong&gt; by changing the &lt;strong&gt;z&lt;/strong&gt; number (ex: 15.6.2 to 15.6.3).</source>
          <target state="translated">놓으면 &lt;strong&gt;중요한 버그 수정&lt;/strong&gt; , 우리는하게 &lt;strong&gt;패치 릴리스를&lt;/strong&gt; 변화하여 &lt;strong&gt;Z의&lt;/strong&gt; (: 15.6.2 15.6.3에 예) 참조.</target>
        </trans-unit>
        <trans-unit id="da463cb8c8960a42b7c6c641c9cd92e1a9c910f5" translate="yes" xml:space="preserve">
          <source>When releasing &lt;strong&gt;new features&lt;/strong&gt; or &lt;strong&gt;non-critical fixes&lt;/strong&gt;, we make a &lt;strong&gt;minor release&lt;/strong&gt; by changing the &lt;strong&gt;y&lt;/strong&gt; number (ex: 15.6.2 to 15.7.0).</source>
          <target state="translated">풀어 주면 &lt;strong&gt;새로운 기능&lt;/strong&gt; 또는 &lt;strong&gt;중요하지 않은 수정을&lt;/strong&gt; , 우리가 만드는 &lt;strong&gt;작은 릴리스&lt;/strong&gt; 변화에 의한 &lt;strong&gt;Y&lt;/strong&gt; (: 15.6.2 15.7.0에 예) 수입니다.</target>
        </trans-unit>
        <trans-unit id="4c4ce5e89fb709cdcfcdafac99ab55a42fcb22c8" translate="yes" xml:space="preserve">
          <source>When starting a React project, a &lt;a href=&quot;add-react-to-a-website&quot;&gt;simple HTML page with script tags&lt;/a&gt; might still be the best option. It only takes a minute to set up!</source>
          <target state="translated">React 프로젝트를 시작할 때 &lt;a href=&quot;add-react-to-a-website&quot;&gt;스크립트 태그&lt;/a&gt; 가 포함 된 간단한 HTML 페이지 가 여전히 가장 좋은 옵션 일 수 있습니다. 설정하는 데 1 분 밖에 걸리지 않습니다!</target>
        </trans-unit>
        <trans-unit id="b761467ad522f1cc9758e17d70a4c8a9a2a07e67" translate="yes" xml:space="preserve">
          <source>When strict mode is enabled, React compiles a list of all class components using the unsafe lifecycles, and logs a warning message with information about these components, like so:</source>
          <target state="translated">엄격 모드가 활성화되면 React는 안전하지 않은 수명주기를 사용하여 모든 클래스 구성 요소 목록을 컴파일하고 다음과 같이 이러한 구성 요소에 대한 정보와 함께 경고 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="347743a185cce0b0e36269b13516e6388d551e77" translate="yes" xml:space="preserve">
          <source>When tearing down a tree, old DOM nodes are destroyed. Component instances receive &lt;code&gt;componentWillUnmount()&lt;/code&gt;. When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive &lt;code&gt;componentWillMount()&lt;/code&gt; and then &lt;code&gt;componentDidMount()&lt;/code&gt;. Any state associated with the old tree is lost.</source>
          <target state="translated">트리를 분해하면 오래된 DOM 노드가 파괴됩니다. 컴포넌트 인스턴스는 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 를받습니다 . 새로운 트리를 구축 할 때 새로운 DOM 노드가 DOM에 삽입됩니다. 컴포넌트 인스턴스는 &lt;code&gt;componentWillMount()&lt;/code&gt; 를 수신 한 다음 &lt;code&gt;componentDidMount()&lt;/code&gt; 를 수신 합니다 . 이전 트리와 관련된 모든 상태가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="30d8a42b09cbe7fd1ec6f1e31e28559adfac664f" translate="yes" xml:space="preserve">
          <source>When testing your rate limiting code works correctly it is helpful to have the ability to fast forward time. If you are using &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt;&lt;code&gt;jest&lt;/code&gt;&lt;/a&gt; then you can use &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt;&lt;code&gt;mock timers&lt;/code&gt;&lt;/a&gt; to fast forward time. If you are using &lt;code&gt;requestAnimationFrame&lt;/code&gt; throttling then you may find &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt;&lt;code&gt;raf-stub&lt;/code&gt;&lt;/a&gt; to be a useful tool to control the ticking of animation frames.</source>
          <target state="translated">속도 제한 코드를 올바르게 테스트하면 시간을 빠르게 전달할 수 있습니다. 당신이 사용하는 경우 &lt;a href=&quot;https://facebook.github.io/jest/&quot;&gt; &lt;code&gt;jest&lt;/code&gt; &lt;/a&gt; 당신은 사용할 수있는 &lt;a href=&quot;https://facebook.github.io/jest/docs/en/timer-mocks.html&quot;&gt; &lt;code&gt;mock timers&lt;/code&gt; &lt;/a&gt; 빨리 감기 시간을. &lt;code&gt;requestAnimationFrame&lt;/code&gt; 조절을 사용하는 경우 &lt;a href=&quot;https://github.com/alexreardon/raf-stub&quot;&gt; &lt;code&gt;raf-stub&lt;/code&gt; &lt;/a&gt; 이 애니메이션 프레임의 눈금을 제어하는 ​​유용한 도구가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778feebbad29d6b5513a63ee18a925568f6d6163" translate="yes" xml:space="preserve">
          <source>When that&amp;rsquo;s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</source>
          <target state="translated">그렇지 않은 경우 모델에 새 ID 속성을 추가하거나 콘텐츠의 일부를 해시하여 키를 생성 할 수 있습니다. 열쇠는 전 세계적으로 독특하지 않고 형제들 사이에서만 독특해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0c23aa39d66eaa9a54e2e5df7c6fc165ebfd607" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Clock&lt;/code&gt; output is inserted in the DOM, React calls the &lt;code&gt;componentDidMount()&lt;/code&gt; lifecycle method. Inside it, the &lt;code&gt;Clock&lt;/code&gt; component asks the browser to set up a timer to call the component&amp;rsquo;s &lt;code&gt;tick()&lt;/code&gt; method once a second.</source>
          <target state="translated">때 &lt;code&gt;Clock&lt;/code&gt; 출력은 DOM에 삽입되어, 통화량 반작용 &lt;code&gt;componentDidMount()&lt;/code&gt; 주기 방법. 그 안에 &lt;code&gt;Clock&lt;/code&gt; 구성 요소는 브라우저에 구성 요소의 &lt;code&gt;tick()&lt;/code&gt; 메서드를 1 초에 한 번 호출하도록 타이머를 설정하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="cf10aa37dfd027d0b674dd7f80a8d15edd1555cb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on a custom class component, the &lt;code&gt;ref&lt;/code&gt; object receives the mounted instance of the component as its &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">때는 &lt;code&gt;ref&lt;/code&gt; 속성이 정의 클래스 구성 요소를 사용하는 경우, &lt;code&gt;ref&lt;/code&gt; 목적은 그와 같은 구성 요소의 인스턴스를 탑재 수신 &lt;code&gt;current&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1196abe0d02468ca061784efb41273736ae2775d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ref&lt;/code&gt; attribute is used on an HTML element, the &lt;code&gt;ref&lt;/code&gt; created in the constructor with &lt;code&gt;React.createRef()&lt;/code&gt; receives the underlying DOM element as its &lt;code&gt;current&lt;/code&gt; property.</source>
          <target state="translated">HTML 요소에 &lt;code&gt;ref&lt;/code&gt; 속성이 사용 되면 &lt;code&gt;React.createRef()&lt;/code&gt; 를 사용하여 생성자에서 생성 된 &lt;code&gt;ref&lt;/code&gt; 는 기본 DOM 요소를 &lt;code&gt;current&lt;/code&gt; 속성으로받습니다.</target>
        </trans-unit>
        <trans-unit id="4842e3714ef564d446a08145facb86d1faac4e3f" translate="yes" xml:space="preserve">
          <source>When the nearest &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; above the component updates, this Hook will trigger a rerender with the latest context &lt;code&gt;value&lt;/code&gt; passed to that &lt;code&gt;MyContext&lt;/code&gt; provider. Even if an ancestor uses &lt;a href=&quot;react-api#reactmemo&quot;&gt;&lt;code&gt;React.memo&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/a&gt;, a rerender will still happen starting at the component itself using &lt;code&gt;useContext&lt;/code&gt;.</source>
          <target state="translated">구성 요소 위 의 가장 가까운 &lt;code&gt;&amp;lt;MyContext.Provider&amp;gt;&lt;/code&gt; 가 업데이트되면이 후크는 해당 &lt;code&gt;MyContext&lt;/code&gt; 제공자 에게 전달 된 최신 컨텍스트 &lt;code&gt;value&lt;/code&gt; 으로 다시 렌더링을 트리거합니다 . 조상이 사용하는 경우에도 &lt;a href=&quot;react-api#reactmemo&quot;&gt; &lt;code&gt;React.memo&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt; &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를&lt;/a&gt; 하는 다시 쓰게 여전히 사용하여 구성 요소 자체에서 시작 일어날 &lt;code&gt;useContext&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5f136dce5bc69460397f4de5f24b415b64d0e59e" translate="yes" xml:space="preserve">
          <source>When the ref is attached, &lt;code&gt;ref.current&lt;/code&gt; will point to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM node.</source>
          <target state="translated">참조가 첨부되면 &lt;code&gt;ref.current&lt;/code&gt; 는 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; DOM 노드를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="5004319c4160942e0f6547bee0d83e11339e4331" translate="yes" xml:space="preserve">
          <source>When to Use Context</source>
          <target state="translated">컨텍스트를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="8d9501cf2be99ddf15d3221bfb5919dd4b8ef921" translate="yes" xml:space="preserve">
          <source>When to Use Refs</source>
          <target state="translated">Refs를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="ce86eaeb59a0d973185f25e1918297ceadd0737d" translate="yes" xml:space="preserve">
          <source>When updating &lt;code&gt;style&lt;/code&gt;, React also knows to update only the properties that changed. For example:</source>
          <target state="translated">&lt;code&gt;style&lt;/code&gt; 을 업데이트 할 때 React는 변경된 속성 만 업데이트한다는 것을 알고 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3910d9d7e05c337c7e8ee06cb5f7ecbfe75a93ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import&quot;&gt;@babel/plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="translated">When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://classic.yarnpkg.com/en/package/@babel/plugin-syntax-dynamic-import&quot;&gt;@babel/plugin-syntax-dynamic-import&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f686dfc377beeaa047e439ce00efd438744a39e1" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, you&amp;rsquo;ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel을&lt;/a&gt; 사용할 때는 Babel 이 동적 가져 오기 구문을 구문 분석 할 수 있지만 변환하지는 않는지 확인해야합니다. 이를 위해서는 &lt;a href=&quot;https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import&quot;&gt;babel-plugin-syntax-dynamic-import&lt;/a&gt; 가 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="eba57241352930e4939e8b3898ace71b33c7ff40" translate="yes" xml:space="preserve">
          <source>When using React, you generally don&amp;rsquo;t need to call &lt;code&gt;addEventListener&lt;/code&gt; to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</source>
          <target state="translated">React를 사용할 때 일반적으로 &lt;code&gt;addEventListener&lt;/code&gt; 를 호출 하여 리스너를 작성한 후 DOM 요소에 리스너를 추가 할 필요는 없습니다 . 대신 요소가 처음 렌더링 될 때 리스너를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="093f2c7f6c3ba701ba5ea625a4f27b321d9a5fb9" translate="yes" xml:space="preserve">
          <source>When using a HOC to extend components, it is recommended to &lt;a href=&quot;forwarding-refs&quot;&gt;forward the ref&lt;/a&gt; to the wrapped component using the &lt;code&gt;forwardRef&lt;/code&gt; function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</source>
          <target state="translated">HOC를 사용하여 구성 요소를 확장 하는 경우 React 의 &lt;code&gt;forwardRef&lt;/code&gt; 기능을 사용하여 랩핑 된 구성 요소에 &lt;a href=&quot;forwarding-refs&quot;&gt;참조&lt;/a&gt; 를 전달하는 것이 좋습니다 . 타사 HOC가 참조 전달을 구현하지 않는 경우에도 위 패턴을 대체로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e906275be6eecf52c0afbd564f7672d05ee4159" translate="yes" xml:space="preserve">
          <source>When we &lt;code&gt;useTransition&lt;/code&gt;, React will let us &amp;ldquo;stay&amp;rdquo; on the previous screen &amp;mdash; and show a progress indicator there. We call that a &lt;strong&gt;Pending&lt;/strong&gt; state. It feels much better than the Receded state because none of our existing content disappears, and the page stays interactive.</source>
          <target state="translated">우리가 &lt;code&gt;useTransition&lt;/code&gt; 때 , React는 이전 화면에&amp;ldquo;체재&amp;rdquo;하게하고 진행 표시기를 보여줄 것입니다. 이를 &lt;strong&gt;보류&lt;/strong&gt; 상태 라고합니다 . 기존 컨텐츠가 사라지지 않고 페이지가 대화식으로 유지되므로 Receded 상태보다 훨씬 나아졌습니다.</target>
        </trans-unit>
        <trans-unit id="4854d06865881970adc4acde9ae2a92249e7a3ea" translate="yes" xml:space="preserve">
          <source>When we click &amp;ldquo;Next&amp;rdquo;, the &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component kicks off a request for the next profile, and passes &lt;em&gt;that&lt;/em&gt; object down to the &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">&quot;다음&quot;을 클릭하면 &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; 구성 요소가 다음 프로필에 대한 요청을 시작하고 &lt;em&gt;해당&lt;/em&gt; 개체를 &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; 구성 요소 로 전달 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fca1cc82f8e24916153432702dbf9b64cc55319c" translate="yes" xml:space="preserve">
          <source>When we click the &amp;ldquo;Next&amp;rdquo; button to switch the active profile, the existing page data immediately disappears, and we see the loading indicator for the whole page again. We can call this an &amp;ldquo;undesirable&amp;rdquo; loading state. &lt;strong&gt;It would be nice if we could &amp;ldquo;skip&amp;rdquo; it and wait for some content to load before transitioning to the new screen.&lt;/strong&gt;</source>
          <target state="translated">&amp;ldquo;Next&amp;rdquo;버튼을 클릭하여 활성 프로파일을 전환하면 기존 페이지 데이터가 즉시 사라지고 전체 페이지의 로딩 표시기가 다시 나타납니다. 이것을 &quot;바람직하지 않은&quot;로딩 상태라고 부를 수 있습니다. &lt;strong&gt;새 화면으로 전환하기 전에&amp;ldquo;건너 뛰어&amp;rdquo;일부 콘텐츠가로드 될 때까지 기다릴 수 있다면 좋을 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a9b7e3341f89a25468d35a1902a98055ebd40a4" translate="yes" xml:space="preserve">
          <source>When we declare a state variable with &lt;code&gt;useState&lt;/code&gt;, it returns a pair &amp;mdash; an array with two items. The first item is the current value, and the second is a function that lets us update it. Using &lt;code&gt;[0]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt; to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.</source>
          <target state="translated">&lt;code&gt;useState&lt;/code&gt; 로 상태 변수를 선언하면 두 항목이있는 배열 인 쌍을 반환합니다. 첫 번째 항목은 현재 값이고 두 번째 항목은이를 업데이트 할 수있는 기능입니다. 사용 &lt;code&gt;[0]&lt;/code&gt; 과 &lt;code&gt;[1]&lt;/code&gt; 에 액세스하는 것은 그들이 특정 의미를 가지고 있기 때문에 약간 혼란이다. 이것이 우리가 대신 배열 파괴를 사용하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="48f1197e89ad2a45509e77a5dc2018726e3c6911" translate="yes" xml:space="preserve">
          <source>When we fetch data for a page, can the API encourage including data for instant transitions &lt;em&gt;from&lt;/em&gt; it?</source>
          <target state="translated">우리는 페이지에 대한 데이터를 가져올 때, API는 즉시 전환에 대한 데이터를 포함하여 격려 할 수 &lt;em&gt;에서&lt;/em&gt; 그것?</target>
        </trans-unit>
        <trans-unit id="ed6581c215df6a3091c26a4c2bdef00a960a4785" translate="yes" xml:space="preserve">
          <source>When we render with &lt;code&gt;count&lt;/code&gt; updated to &lt;code&gt;6&lt;/code&gt;, React will compare the items in the &lt;code&gt;[5]&lt;/code&gt; array from the previous render to items in the &lt;code&gt;[6]&lt;/code&gt; array from the next render. This time, React will re-apply the effect because &lt;code&gt;5 !== 6&lt;/code&gt;. If there are multiple items in the array, React will re-run the effect even if just one of them is different.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 가 &lt;code&gt;6&lt;/code&gt; 으로 업데이트 된 상태에서 렌더링하면 React는 이전 렌더링 의 &lt;code&gt;[5]&lt;/code&gt; 배열에있는 항목 과 다음 렌더링 의 &lt;code&gt;[6]&lt;/code&gt; 배열 에있는 항목을 비교합니다 . 이번에는 React가 &lt;code&gt;5 !== 6&lt;/code&gt; 이므로 효과를 다시 적용합니다 . 배열에 여러 항목이있는 경우 React는 그 중 하나만 다른 경우에도 효과를 다시 실행합니다.</target>
        </trans-unit>
        <trans-unit id="15dd239dd01373f359404e41d5b7a62dacbb76d9" translate="yes" xml:space="preserve">
          <source>When we want to display the current count in a class, we read &lt;code&gt;this.state.count&lt;/code&gt;:</source>
          <target state="translated">클래스에 현재 카운트를 표시하려면 &lt;code&gt;this.state.count&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7e772ea53410ed97f311017baf25729ac436eb7e" translate="yes" xml:space="preserve">
          <source>When we want to share logic between two JavaScript functions, we extract it to a third function. Both components and Hooks are functions, so this works for them too!</source>
          <target state="translated">두 JavaScript 함수간에 논리를 공유하려면이를 세 번째 함수로 추출하십시오. 구성 요소와 후크는 모두 기능이므로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b6891052b12cc29726c0f0b0279ac50a1c1387f8" translate="yes" xml:space="preserve">
          <source>When we were learning about &lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;using the Effect Hook&lt;/a&gt;, we saw this component from a chat application that displays a message indicating whether a friend is online or offline:</source>
          <target state="translated">&lt;a href=&quot;hooks-effect#example-using-hooks-1&quot;&gt;Effect Hook 사용에&lt;/a&gt; 대해 배우면서 채팅 응용 프로그램에서 친구가 온라인인지 오프라인인지를 나타내는 메시지를 표시하는이 구성 요소를 보았습니다.</target>
        </trans-unit>
        <trans-unit id="5b9387f6a30d7fe6f52f7bcb771030991372ac72" translate="yes" xml:space="preserve">
          <source>When we write code with Promises, we might use &lt;code&gt;catch()&lt;/code&gt; to handle errors. How does this work with Suspense, given that we don&amp;rsquo;t &lt;em&gt;wait&lt;/em&gt; for Promises to start rendering?</source>
          <target state="translated">Promises로 코드를 작성할 때 &lt;code&gt;catch()&lt;/code&gt; 를 사용 하여 오류를 처리 할 수 ​​있습니다. 약속이 렌더링을 시작할 &lt;em&gt;때까지 기다리지&lt;/em&gt; 않는다면 Suspense에서 어떻게 작동 합니까?</target>
        </trans-unit>
        <trans-unit id="dbbba4fb5bc3bc71466275b51ebcb399bc61b8c2" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re already on the next screen, sometimes the data needed to &amp;ldquo;unlock&amp;rdquo; different &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries arrives in quick succession. For example, two different responses might arrive after 1000ms and 1050ms, respectively. If you&amp;rsquo;ve already waited for a second, waiting another 50ms is not going to be perceptible. This is why React reveals &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundaries on a schedule, like a &amp;ldquo;train&amp;rdquo; that arrives periodically. This trades a small delay for reducing the layout thrashing and the number of visual changes presented to the user.</source>
          <target state="translated">우리가 이미 다음 화면에있을 때 때때로 다른 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계 를 &quot;잠금 해제&quot;하는 데 필요한 데이터 가 빠르게 연속적으로 도착합니다. 예를 들어, 두 개의 서로 다른 응답이 각각 1000ms와 1050ms 후에 도착할 수 있습니다. 이미 1 초 동안 기다렸다면 50ms 더 기다릴 수 없습니다. 이것이 React 가 정기적으로 도착하는&amp;ldquo;기차&amp;rdquo;와 같이 일정에 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 경계를 표시하는 이유 입니다. 이것은 레이아웃 스 래싱 및 사용자에게 제시된 시각적 변화의 수를 줄이기 위해 약간의 지연을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="1b060390d4cb54331e0099d906d42df3b0d12cba" translate="yes" xml:space="preserve">
          <source>When working with portals, remember that &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;managing keyboard focus&lt;/a&gt; becomes very important.</source>
          <target state="translated">포털 작업시 &lt;a href=&quot;accessibility#programmatically-managing-focus&quot;&gt;키보드 초점 관리&lt;/a&gt; 가 매우 중요하다는 점을 기억하십시오 .</target>
        </trans-unit>
        <trans-unit id="8db3a4bc3fdaeca77d8e51c126c8d263c7425a94" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. &lt;code&gt;react-dom/test-utils&lt;/code&gt; provides a helper called &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt;&lt;/a&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="translated">When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. &lt;code&gt;react-dom/test-utils&lt;/code&gt; provides a helper called &lt;a href=&quot;test-utils#act&quot;&gt; &lt;code&gt;act()&lt;/code&gt; &lt;/a&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</target>
        </trans-unit>
        <trans-unit id="1b92b098726d1ea5fd34d3c3b1ae6f350cac787b" translate="yes" xml:space="preserve">
          <source>When writing UI tests, tasks like rendering, user events, or data fetching can be considered as &amp;ldquo;units&amp;rdquo; of interaction with a user interface. React provides a helper called &lt;code&gt;act()&lt;/code&gt; that makes sure all updates related to these &amp;ldquo;units&amp;rdquo; have been processed and applied to the DOM before you make any assertions:</source>
          <target state="translated">UI 테스트를 작성할 때 렌더링, 사용자 이벤트 또는 데이터 가져 오기와 같은 작업은 사용자 인터페이스와의 상호 작용의 &quot;단위&quot;로 간주 될 수 있습니다. React는 &lt;code&gt;act()&lt;/code&gt; 라는 도우미를 제공하여 어설 션을 만들기 전에 이러한 &quot;단위&quot;와 관련된 모든 업데이트가 처리되고 DOM에 적용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="815dd6740e6e9c5d08dcb3ad258c5e94e50158fe" translate="yes" xml:space="preserve">
          <source>When writing tests, we&amp;rsquo;d like to mock out the parts of our code that don&amp;rsquo;t have equivalents inside our testing environment (e.g. checking &lt;code&gt;navigator.onLine&lt;/code&gt; status inside Node.js). Tests could also spy on some functions, and observe how other parts of the test interact with them. It is then useful to be able to selectively mock these functions with test-friendly versions.</source>
          <target state="translated">테스트를 작성할 때 테스트 환경 내에 해당 요소가없는 코드 부분 (예 : Node.js의 &lt;code&gt;navigator.onLine&lt;/code&gt; 상태 확인)을 조롱하고 싶습니다 . 테스트는 일부 기능을 감시하고 테스트의 다른 부분이 어떻게 상호 작용하는지 관찰 할 수 있습니다. 그런 다음 테스트 용 버전으로 이러한 기능을 선택적으로 조롱 할 수있는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="54186af6fe93abf508be013c58f7c15e821c2212" translate="yes" xml:space="preserve">
          <source>When writing unit tests for React, shallow rendering can be helpful. Shallow rendering lets you render a component &amp;ldquo;one level deep&amp;rdquo; and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</source>
          <target state="translated">React에 대한 단위 테스트를 작성할 때 얕은 렌더링이 도움이 될 수 있습니다. 얕은 렌더링을 사용하면 인스턴스화되거나 렌더링되지 않은 자식 구성 요소의 동작에 대해 걱정하지 않고 구성 요소를 &quot;한 수준 수준&quot;으로 렌더링하고 렌더링 방법이 반환하는 내용에 대한 사실을 확인할 수 있습니다. 이것은 DOM이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82a14329dae74e66f4aea2bb76056b1aafd3fd03" translate="yes" xml:space="preserve">
          <source>When you apply a HOC to a component, though, the original component is wrapped with a container component. That means the new component does not have any of the static methods of the original component.</source>
          <target state="translated">그러나 구성 요소에 HOC를 적용하면 원래 구성 요소는 컨테이너 구성 요소로 포장됩니다. 즉, 새 구성 요소에는 원래 구성 요소의 정적 메소드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d789f6dd4fbb7df7db5b972518ccd2f457118883" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;setState()&lt;/code&gt;, React merges the object you provide into the current state.</source>
          <target state="translated">&lt;code&gt;setState()&lt;/code&gt; 를 호출하면 React는 제공 한 객체를 현재 상태로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="93a56c926d74b4e963b27be254ec9ba6d291fd30" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;useEffect&lt;/code&gt;, you&amp;rsquo;re telling React to run your &amp;ldquo;effect&amp;rdquo; function after flushing changes to the DOM. Effects are declared inside the component so they have access to its props and state. By default, React runs the effects after every render &amp;mdash; &lt;em&gt;including&lt;/em&gt; the first render. (We&amp;rsquo;ll talk more about how this compares to class lifecycles in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 를 호출하면 React에게 DOM 변경 사항을 플러시 한 후 &quot;효과&quot;기능을 실행하라고 지시합니다. 구성 요소 내부에 효과가 선언되어 소품과 상태에 액세스 할 수 있습니다. 기본적으로 React는 첫 번째 렌더링을 &lt;em&gt;포함&lt;/em&gt; 하여 모든 렌더링 후에 효과를 실행합니다 . ( &lt;a href=&quot;hooks-effect&quot;&gt;이펙트 후크 사용에서&lt;/a&gt; 클래스 수명주기와 비교하는 방법에 대해 자세히 설명합니다 .)</target>
        </trans-unit>
        <trans-unit id="5dc1f9c6d9a1899bf29a171b9ce6e79ac82836a8" translate="yes" xml:space="preserve">
          <source>When you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; or &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;. These libraries let you write highly readable code without losing the benefits of immutability.</source>
          <target state="translated">깊이 중첩 된 객체를 처리 할 때 변경 불가능한 방식으로 객체를 업데이트하면 복잡한 느낌이들 수 있습니다. 이 문제가 발생하면 &lt;a href=&quot;https://github.com/mweststrate/immer&quot;&gt;Immer&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper를&lt;/a&gt; 확인하십시오 . 이 라이브러리를 사용하면 불변성의 이점을 잃지 않고 읽을 수있는 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a24b1ec6fc11433896d187e1f658c70a7099a2ad" translate="yes" xml:space="preserve">
          <source>When you define a component using an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt;, a common pattern is for an event handler to be a method on the class. For example, this &lt;code&gt;Toggle&lt;/code&gt; component renders a button that lets the user toggle between &amp;ldquo;ON&amp;rdquo; and &amp;ldquo;OFF&amp;rdquo; states:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스를&lt;/a&gt; 사용하여 컴포넌트를 정의 할 때 일반적인 패턴은 이벤트 핸들러가 클래스의 메소드가되는 것입니다. 예를 &lt;code&gt;Toggle&lt;/code&gt; 구성 요소는 사용자가 &quot;ON&quot;과 &quot;OFF&quot;상태를 전환 할 수있는 버튼을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="01abc8d4d76c5d3b29a56fbabd9fa795ee92ceb3" translate="yes" xml:space="preserve">
          <source>When you design React components, it is usually best to find the &amp;ldquo;minimal representation&amp;rdquo; of state. For example, instead of keeping &lt;code&gt;firstName&lt;/code&gt;, &lt;code&gt;lastName&lt;/code&gt;, and &lt;code&gt;fullName&lt;/code&gt; in state, it&amp;rsquo;s usually better keep only &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;, and then calculate &lt;code&gt;fullName&lt;/code&gt; during rendering. This lets us avoid mistakes where we update one state but forget the other state.</source>
          <target state="translated">React 컴포넌트를 디자인 할 때 일반적으로 상태의 &quot;최소한 표현&quot;을 찾는 것이 가장 좋습니다. 예를 들어 &lt;code&gt;firstName&lt;/code&gt; , &lt;code&gt;lastName&lt;/code&gt; 및 &lt;code&gt;fullName&lt;/code&gt; 을 상태 로 유지하는 대신 일반적으로 &lt;code&gt;firstName&lt;/code&gt; 과 &lt;code&gt;lastName&lt;/code&gt; 만 유지 한 다음 렌더링 중에 &lt;code&gt;fullName&lt;/code&gt; 을 계산하는 것이 좋습니다 . 이를 통해 하나의 상태를 업데이트하는 실수를 피할 수 있지만 다른 상태는 잊을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0e176fb66cf11f7e27af0bcb2e55372392f43e" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t have stable IDs for rendered items, you may use the item index as a key as a last resort:</source>
          <target state="translated">렌더링 된 항목에 대해 안정적인 ID가없는 경우 최후의 수단으로 항목 색인을 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82a0d500de82ea773a24f53e694f0f8c714eaf2" translate="yes" xml:space="preserve">
          <source>When you don&amp;rsquo;t need any props on the Fragment tag you can use the &lt;a href=&quot;fragments#short-syntax&quot;&gt;short syntax&lt;/a&gt;, if your tooling supports it:</source>
          <target state="translated">Fragment 태그에 소품이 필요하지 않은 경우 툴링에서 지원하는 경우 &lt;a href=&quot;fragments#short-syntax&quot;&gt;짧은 구문을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f5d758f7a13f26df949720818e29795ba408fea" translate="yes" xml:space="preserve">
          <source>When you need to handle multiple controlled &lt;code&gt;input&lt;/code&gt; elements, you can add a &lt;code&gt;name&lt;/code&gt; attribute to each element and let the handler function choose what to do based on the value of &lt;code&gt;event.target.name&lt;/code&gt;.</source>
          <target state="translated">여러 개의 제어 된 &lt;code&gt;input&lt;/code&gt; 요소 를 처리해야하는 경우 각 요소에 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하고 핸들러 함수가 &lt;code&gt;event.target.name&lt;/code&gt; 값에 따라 수행 할 작업을 선택하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c75b2134369a0a04fe58dd9360ac61d55ca554e4" translate="yes" xml:space="preserve">
          <source>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</source>
          <target state="translated">문자열 리터럴을 전달하면 해당 값이 HTML 이스케이프 처리되지 않습니다. 따라서이 두 JSX 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="231c33cc0825db7915ff2676aa0c0c45eb40c0bc" translate="yes" xml:space="preserve">
          <source>When you run this code, you&amp;rsquo;ll be given a warning that a key should be provided for list items. A &amp;ldquo;key&amp;rdquo; is a special string attribute you need to include when creating lists of elements. We&amp;rsquo;ll discuss why it&amp;rsquo;s important in the next section.</source>
          <target state="translated">이 코드를 실행하면 목록 항목에 키가 제공되어야한다는 경고가 표시됩니다. &quot;키&quot;는 요소 목록을 작성할 때 포함해야하는 특수 문자열 속성입니다. 다음 섹션에서 왜 중요한지 논의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="392e1c61d6fc0a80b224eb56286bbae56068d9da" translate="yes" xml:space="preserve">
          <source>When you see something wrong in the UI, you can use &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</source>
          <target state="translated">UI에 문제가 있으면 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; 를 사용 하여 소품을 검사하고 상태 업데이트를 담당하는 구성 요소를 찾을 때까지 트리를 위로 이동할 수 있습니다. 이를 통해 버그를 소스로 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6c278736c7925bc9c4014f782054c15bd13051c" translate="yes" xml:space="preserve">
          <source>When you use React, at a single point in time you can think of the &lt;code&gt;render()&lt;/code&gt; function as creating a tree of React elements. On the next state or props update, that &lt;code&gt;render()&lt;/code&gt; function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.</source>
          <target state="translated">React를 사용할 때 특정 시점에서 &lt;code&gt;render()&lt;/code&gt; 함수를 React 요소 트리를 만드는 것으로 생각할 수 있습니다 . 다음 상태 또는 props 업데이트에서 &lt;code&gt;render()&lt;/code&gt; 함수는 다른 React 요소 트리를 반환합니다. 그런 다음 React는 최신 트리에 맞게 UI를 효율적으로 업데이트하는 방법을 알아 내야합니다.</target>
        </trans-unit>
        <trans-unit id="3918d1668774c6039a7d4c11830322620a548fcf" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to deploy to production, running &lt;code&gt;npm run build&lt;/code&gt; will create an optimized build of your app in the &lt;code&gt;build&lt;/code&gt; folder. You can learn more about Create React App &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;from its README&lt;/a&gt; and the &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;User Guide&lt;/a&gt;.</source>
          <target state="translated">프로덕션 환경에 배포 할 준비가되면 &lt;code&gt;npm run build&lt;/code&gt; 를 실행 하면 &lt;code&gt;build&lt;/code&gt; 폴더에 앱의 최적화 된 빌드가 생성됩니다 . &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#create-react-app--&quot;&gt;README&lt;/a&gt; 및 &lt;a href=&quot;https://facebook.github.io/create-react-app/&quot;&gt;사용자 안내서 &lt;/a&gt;에서 React 앱 작성에 대해 자세히 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bebff40c8b08402b37ab557fa24c08cc19a40f98" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, we&amp;rsquo;d encourage you to start trying Hooks in new components you write. Make sure everyone on your team is on board with using them and familiar with this documentation. We don&amp;rsquo;t recommend rewriting your existing classes to Hooks unless you planned to rewrite them anyway (e.g. to fix bugs).</source>
          <target state="translated">준비가되면 작성하는 새 구성 요소에서 후크를 시도해 보는 것이 좋습니다. 팀원 모두가 사용하고이 문서에 익숙해 지도록하십시오. 어쨌든 버그를 수정하기 위해 기존 클래스를 다시 작성하지 않는 한 후크에 기존 클래스를 다시 쓰지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60ca1c6e2220d3dcd5eb8ee37e9e869e14d685d1" translate="yes" xml:space="preserve">
          <source>Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. Going from &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt;, or from &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - any of those will lead to a full rebuild.</source>
          <target state="translated">루트 요소가 다른 유형을 가질 때마다 React는 이전 트리를 분해하고 처음부터 새 트리를 만듭니다. 에서가는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , 또는에서 &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt; , 또는에서 &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; - 그 중 하나가 다시 전체로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="6dd9bbf6973367e79eeae18b9bbda9418cafb732" translate="yes" xml:space="preserve">
          <source>Whenever you get confused by something in JavaScript, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; and &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; are great websites to check. There are also &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;community support forums&lt;/a&gt; where you can ask for help.</source>
          <target state="translated">JavaScript에서 무언가 혼동 될 때마다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt; 과 &lt;a href=&quot;https://javascript.info/&quot;&gt;javascript.info&lt;/a&gt; 는 확인하기 좋은 웹 사이트입니다. 도움을 요청할 수있는 &lt;a href=&quot;https://reactjs.org/community/support.html&quot;&gt;커뮤니티 지원 포럼&lt;/a&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8f9e5d66d270d8259063ea04783c1ae12b8c1c6" translate="yes" xml:space="preserve">
          <source>Where Does the Update Happen?</source>
          <target state="translated">업데이트는 어디에서 발생합니까?</target>
        </trans-unit>
        <trans-unit id="ef742a7bbdd48469bd1b3855fd8bf22859df98d5" translate="yes" xml:space="preserve">
          <source>Where in the component lifecycle should I make an AJAX call?</source>
          <target state="translated">컴포넌트 라이프 사이클에서 AJAX 호출은 어디에해야합니까?</target>
        </trans-unit>
        <trans-unit id="ae2b962ed56663e8ecdd89ac3430db8cddb1f349" translate="yes" xml:space="preserve">
          <source>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</source>
          <target state="translated">필요한 경우 키보드 화살표 키를 사용하여 메뉴 및 드롭 다운과 같은 일부 요소와 상호 작용하십시오.</target>
        </trans-unit>
        <trans-unit id="88a90f10ab7ebe7a5678e36f1ceddd076dd13ba2" translate="yes" xml:space="preserve">
          <source>Where to Place Error Boundaries</source>
          <target state="translated">오류 경계를 배치 할 위치</target>
        </trans-unit>
        <trans-unit id="5efb59c3c22d68fc4a99b342c9b256a6b2820f68" translate="yes" xml:space="preserve">
          <source>Whereas a component transforms props into UI, a higher-order component transforms a component into another component.</source>
          <target state="translated">컴포넌트가 소품을 UI로 변환하는 반면, 상위 컴포넌트는 컴포넌트를 다른 컴포넌트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6e766e695d0adc0641fe24c8e239dc1edab04b55" translate="yes" xml:space="preserve">
          <source>Whether or not it&amp;rsquo;s an appropriate tradeoff depends on the situation. But it&amp;rsquo;s a handy tool, especially when the content doesn&amp;rsquo;t change noticeably between items, and the user might not even realize they were looking at a stale version for a second.</source>
          <target state="translated">그것이 적절한 상충인지 여부는 상황에 따라 다릅니다. 그러나 특히 도구간에 내용이 눈에 띄게 변경되지 않고 사용자가 오래 된 버전을보고 있다는 사실조차 사용자가 알지 못하는 편리한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="5313bb949a427d6a34ce0619291d083860ef68d3" translate="yes" xml:space="preserve">
          <source>Whether you declare a component &lt;a href=&quot;#function-and-class-components&quot;&gt;as a function or a class&lt;/a&gt;, it must never modify its own props. Consider this &lt;code&gt;sum&lt;/code&gt; function:</source>
          <target state="translated">컴포넌트 &lt;a href=&quot;#function-and-class-components&quot;&gt;를 함수로&lt;/a&gt; 선언하든 클래스로 선언하든 자체 소품을 수정해서는 안됩니다. 이 &lt;code&gt;sum&lt;/code&gt; 함수를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cfad9062c1b8c8d17794fcb8f3a2452cc2e5ab6" translate="yes" xml:space="preserve">
          <source>Which versions of React include Hooks?</source>
          <target state="translated">후크를 포함하는 React 버전은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="911be78ca9d90df9dbf3aeb3c82775a99547aee6" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;this.props&lt;/code&gt; is set up by React itself and &lt;code&gt;this.state&lt;/code&gt; has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn&amp;rsquo;t participate in the data flow (like a timer ID).</source>
          <target state="translated">하지만 &lt;code&gt;this.props&lt;/code&gt; 가 자체 반응에 의해 설정되고 &lt;code&gt;this.state&lt;/code&gt; 은 특별한 의미를 가지고, 당신은 당신이 타이머 ID (같은 데이터 흐름에 참여하지 않는 저장 뭔가해야 할 경우에는 수동으로 클래스에 필드를 추가 무료입니다 ).</target>
        </trans-unit>
        <trans-unit id="1aba78d4a4d0f9fe12fa522d168cd8b574a0e353" translate="yes" xml:space="preserve">
          <source>While declaring a variable and using an &lt;code&gt;if&lt;/code&gt; statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</source>
          <target state="translated">변수를 선언하고 &lt;code&gt;if&lt;/code&gt; 문을 사용하는 것이 조건부로 구성 요소를 렌더링하는 좋은 방법이지만 때로는 더 짧은 구문을 사용해야 할 수도 있습니다. JSX에서 조건을 인라인하는 몇 가지 방법이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e78dcc3d744f87f73cd2a47f9767fd1932daf4" translate="yes" xml:space="preserve">
          <source>While it is generally recommended to use unidirectional data flow such as &lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt;, &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt;, or &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;, React components can use a model layer from other frameworks and libraries.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;lifting-state-up&quot;&gt;React state&lt;/a&gt; , &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; 또는 &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; 와 같은 단방향 데이터 흐름을 사용하는 것이 좋지만 React 구성 요소는 다른 프레임 워크 및 라이브러리의 모델 계층을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb5eb9a797258730eedaeda45aa9df92fecc85e" translate="yes" xml:space="preserve">
          <source>While the convention for higher-order components is to pass through all props to the wrapped component, this does not work for refs. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not really a prop &amp;mdash; like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled specially by React. If you add a ref to an element whose component is the result of a HOC, the ref refers to an instance of the outermost container component, not the wrapped component.</source>
          <target state="translated">상위 구성 요소의 규칙은 모든 소품을 래핑 된 구성 요소로 전달하는 것이지만 참조에는 적용되지 않습니다. 이것은 &lt;code&gt;ref&lt;/code&gt; 가 실제로 &lt;code&gt;key&lt;/code&gt; 와 같은 소품이 아니기 때문에 React에 의해 특별히 처리됩니다. 구성 요소가 HOC의 결과 인 요소에 참조를 추가하는 경우 참조는 랩핑 된 구성 요소가 아닌 가장 바깥 쪽 컨테이너 구성 요소의 인스턴스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="80619f6a762505ca83687945b18212f2b9eaa056" translate="yes" xml:space="preserve">
          <source>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</source>
          <target state="translated">이것은 매우 중요한 접근성 기능이지만 신중하게 사용해야하는 기술이기도합니다. 사용자가 응용 프로그램을 사용하려는 방식을 시도하지 말고 방해받지 않고 키보드 포커스 흐름을 복구하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd59be0b1a677335857ab70d19708469811c4d18" translate="yes" xml:space="preserve">
          <source>While this is less common, sometimes you might need multiple &amp;ldquo;holes&amp;rdquo; in a component. In such cases you may come up with your own convention instead of using &lt;code&gt;children&lt;/code&gt;:</source>
          <target state="translated">일반적이지 않지만 구성 요소에 여러 개의 &quot;구멍&quot;이 필요할 수 있습니다. 이러한 경우 &lt;code&gt;children&lt;/code&gt; 를 사용하는 대신 자신의 협약을 제시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceea2b7f2101d3dab298a7e0940196ece8e3cb89" translate="yes" xml:space="preserve">
          <source>While this is not supported today, in the future we plan to let &lt;code&gt;Suspense&lt;/code&gt; handle more scenarios such as data fetching. You can read about this in &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;our roadmap&lt;/a&gt;.</source>
          <target state="translated">현재는 지원되지 않지만 향후 &lt;code&gt;Suspense&lt;/code&gt; 에서 데이터 가져 오기와 같은 더 많은 시나리오를 처리 하도록 할 계획 입니다. &lt;a href=&quot;https://reactjs.org/blog/2018/11/27/react-16-roadmap.html&quot;&gt;로드맵&lt;/a&gt; 에서 이에 대해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2a90b6d038e43771f66fdf8ac4ad272e8778019" translate="yes" xml:space="preserve">
          <source>While this is possible today, it can be difficult to orchestrate. In Concurrent Mode, this feature is built-in. React starts preparing the new screen in memory first &amp;mdash; or, as our metaphor goes, &amp;ldquo;on a different branch&amp;rdquo;. So React can wait before updating the DOM so that more content can load. In Concurrent Mode, we can tell React to keep showing the old screen, fully interactive, with an inline loading indicator. And when the new screen is ready, React can take us to it.</source>
          <target state="translated">이것이 오늘날 가능하지만 조정이 어려울 수 있습니다. 동시 모드에서는이 기능이 내장되어 있습니다. React는 메모리에서 새 화면을 먼저 준비하기 시작하거나 은유가&amp;ldquo;다른 지점에서&amp;rdquo;시작합니다. 따라서 React는 더 많은 컨텐츠를로드 할 수 있도록 DOM을 업데이트하기 전에 기다릴 수 있습니다. Concurrent Mode에서는 React에 인라인 로딩 표시기와 함께 대화식으로 이전 화면을 계속 표시하도록 지시 할 수 있습니다. 그리고 새로운 화면이 준비되면 React가 우리를 데려 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d7e7d15375515d6dc839c8d2bfd40fc2b4dadb" translate="yes" xml:space="preserve">
          <source>While you could &lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;add a ref to the child component&lt;/a&gt;, this is not an ideal solution, as you would only get a component instance rather than a DOM node. Additionally, this wouldn&amp;rsquo;t work with function components.</source>
          <target state="translated">&lt;a href=&quot;#adding-a-ref-to-a-class-component&quot;&gt;자식 구성 요소에 참조를 추가&lt;/a&gt; 할 수는 있지만 DOM 노드가 아닌 구성 요소 인스턴스 만 얻을 수 있으므로 이상적인 솔루션은 아닙니다. 또한 함수 구성 요소에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="495b742205ad82447d68cc34f99288cca84b04a8" translate="yes" xml:space="preserve">
          <source>While you probably &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;don&amp;rsquo;t need it&lt;/a&gt;, in rare cases that you do (such as implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component), you can update the state right during rendering. React will re-run the component with updated state immediately after exiting the first render so it wouldn&amp;rsquo;t be expensive.</source>
          <target state="translated">당신은 아마 동안 &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;할 필요하지&lt;/a&gt; 당신이 (예 : 구현으로 수행하는 것이 드문 경우에, &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; , 당신은 렌더링시 상태 권리를 업데이트 할 수 있습니다 구성 요소). React는 첫 번째 렌더링을 종료 한 직후 업데이트 된 상태로 구성 요소를 다시 실행하므로 비용이 많이 들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ad1fd6b46143604bd95b453287adc7e23e0fcff" translate="yes" xml:space="preserve">
          <source>While you shouldn&amp;rsquo;t need this often, you may expose some imperative methods to a parent component with the &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt;&lt;code&gt;useImperativeHandle&lt;/code&gt;&lt;/a&gt; Hook.</source>
          <target state="translated">이것을 자주 필요로하지는 않지만 &lt;a href=&quot;hooks-reference#useimperativehandle&quot;&gt; &lt;code&gt;useImperativeHandle&lt;/code&gt; &lt;/a&gt; Hook 를 사용하여 일부 필수 메소드를 상위 컴포넌트에 노출시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fb67a6e3ebb0c4884c03542ed4d02cc6e3b26d7" translate="yes" xml:space="preserve">
          <source>Who Is This Experimental Release For?</source>
          <target state="translated">이 실험용 릴리스의 대상은 누구입니까?</target>
        </trans-unit>
        <trans-unit id="49c3abb6796bdac1acab2ff039684dce6186a9f6" translate="yes" xml:space="preserve">
          <source>Why Accessibility?</source>
          <target state="translated">왜 접근성이 좋은가요?</target>
        </trans-unit>
        <trans-unit id="f8b6dc9d0e248f1aca599f0014bcad47284d99a8" translate="yes" xml:space="preserve">
          <source>Why JSX?</source>
          <target state="translated">왜 JSX인가?</target>
        </trans-unit>
        <trans-unit id="3fec80c558c9db1e52790dd2506e452dfd97b669" translate="yes" xml:space="preserve">
          <source>Why So Many Modes?</source>
          <target state="translated">왜 그렇게 많은 모드?</target>
        </trans-unit>
        <trans-unit id="ce0a06b1d50f03b0c1677ffc7fc4f387ed59572e" translate="yes" xml:space="preserve">
          <source>Why am I seeing stale props or state inside my function?</source>
          <target state="translated">함수 내부에 오래된 소품이나 상태가 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="0492b756ff8e4f6df5b3fc7ff6de3541b68d8908" translate="yes" xml:space="preserve">
          <source>Why does our &lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;last Suspense example&lt;/a&gt; log a warning when clicking the &amp;ldquo;Next&amp;rdquo; button?</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/infallible-feather-xjtbu&quot;&gt;마지막 Suspense 예제&lt;/a&gt; 가&amp;ldquo;다음&amp;rdquo;버튼을 클릭 할 때 경고 를 기록하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="65762af3a54e62fab1249620c4413deaa6a70304" translate="yes" xml:space="preserve">
          <source>Why doesn&amp;rsquo;t React update &lt;code&gt;this.state&lt;/code&gt; synchronously?</source>
          <target state="translated">React가 &lt;code&gt;this.state&lt;/code&gt; 를 동기식으로 업데이트하지 않는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="edf9c3c0fe5bd6b0114a879913f827631f515543" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;setState&lt;/code&gt; giving me the wrong value?</source>
          <target state="translated">&lt;code&gt;setState&lt;/code&gt; 가 왜 잘못된 값을 제공합니까?</target>
        </trans-unit>
        <trans-unit id="148cbb2bff9a010f21a0ad216df38f1c5d2cd471" translate="yes" xml:space="preserve">
          <source>Why is binding necessary at all?</source>
          <target state="translated">바인딩이 왜 필요한가?</target>
        </trans-unit>
        <trans-unit id="f119dd9eafd6f8c4ac0cc157b3a167f93ba90cf5" translate="yes" xml:space="preserve">
          <source>Why is my function being called every time the component renders?</source>
          <target state="translated">컴포넌트가 렌더링 될 때마다 내 함수가 호출되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c2085905cfd406c9e6d8d4068c20801835544c3f" translate="yes" xml:space="preserve">
          <source>Why the &lt;code&gt;crossorigin&lt;/code&gt; Attribute?</source>
          <target state="translated">&lt;code&gt;crossorigin&lt;/code&gt; 속성 이 필요한 이유</target>
        </trans-unit>
        <trans-unit id="aab036cb04b8ab29e50f15ba17971446021a2255" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PropTypes.element&lt;/code&gt; you can specify that only a single child can be passed to a component as children.</source>
          <target state="translated">&lt;code&gt;PropTypes.element&lt;/code&gt; 를 사용하면 단일 하위 만 컴포넌트로 하위로 전달할 수 있도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b569b9d21bf8d1be58d672f5980773d97d54e66" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, this is not necessary because it binds all methods:</source>
          <target state="translated">&lt;code&gt;createReactClass()&lt;/code&gt; 사용하면 모든 메소드를 바인딩하므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4883092ff15971d97a8aa837d13ef100a68d5eb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you have to provide a separate &lt;code&gt;getInitialState&lt;/code&gt; method that returns the initial state:</source>
          <target state="translated">함께 &lt;code&gt;createReactClass()&lt;/code&gt; 별도 제공해야 &lt;code&gt;getInitialState&lt;/code&gt; 의 초기 상태를 반환 방법 :</target>
        </trans-unit>
        <trans-unit id="50f377ba092fa5d0a0d282bc37a4c8ec440e268f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;createReactClass()&lt;/code&gt;, you need to define &lt;code&gt;getDefaultProps()&lt;/code&gt; as a function on the passed object:</source>
          <target state="translated">함께 &lt;code&gt;createReactClass()&lt;/code&gt; , 당신은 정의해야 &lt;code&gt;getDefaultProps()&lt;/code&gt; 전달 된 객체에 함수를 :</target>
        </trans-unit>
        <trans-unit id="df984bf31d472187d2e254fc8283606d23024bfe" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;useTransition&lt;/code&gt;, we can opt into showing a Pending state first instead. This will keep us on the previous screen while the next screen is being prepared.</source>
          <target state="translated">&lt;code&gt;useTransition&lt;/code&gt; 을 사용하면 먼저 Pending 상태를 먼저 표시하도록 선택할 수 있습니다. 다음 화면이 준비되는 동안 이전 화면으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0ece6ef7273f365ef2fee3cd6066494eec178a85" translate="yes" xml:space="preserve">
          <source>With Hooks, you can extract stateful logic from a component so it can be tested independently and reused. &lt;strong&gt;Hooks allow you to reuse stateful logic without changing your component hierarchy.&lt;/strong&gt; This makes it easy to share Hooks among many components or with the community.</source>
          <target state="translated">후크를 사용하면 구성 요소에서 상태 저장 논리를 추출하여 독립적으로 테스트하고 재사용 할 수 있습니다. &lt;strong&gt;후크를 사용하면 구성 요소 계층을 변경하지 않고도 상태 저장 논리를 재사용 할 수 있습니다. &lt;/strong&gt;이를 통해 많은 구성 요소간에 또는 커뮤니티와 후크를 쉽게 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1aed9937b8f4a875f46194f502d03b524dc6dd" translate="yes" xml:space="preserve">
          <source>With JSX you pass a function as the event handler, rather than a string.</source>
          <target state="translated">JSX를 사용하면 문자열 대신 함수를 이벤트 핸들러로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ed4bd933c03f851c13ccd2147932475182887d8e" translate="yes" xml:space="preserve">
          <source>With React, typically you only need to bind the methods you &lt;em&gt;pass&lt;/em&gt; to other components. For example, &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; passes &lt;code&gt;this.handleClick&lt;/code&gt; so you want to bind it. However, it is unnecessary to bind the &lt;code&gt;render&lt;/code&gt; method or the lifecycle methods: we don&amp;rsquo;t pass them to other components.</source>
          <target state="translated">React를 사용하면 일반적으로 다른 구성 요소에 &lt;em&gt;전달&lt;/em&gt; 하는 메소드 만 바인딩하면됩니다 . 예를 들어 &lt;code&gt;&amp;lt;button onClick={this.handleClick}&amp;gt;&lt;/code&gt; 은 &lt;code&gt;this.handleClick&lt;/code&gt; 을 전달 하여 바인딩하려고합니다. 그러나 &lt;code&gt;render&lt;/code&gt; 메소드 또는 라이프 사이클 메소드 를 바인드 할 필요는 없습니다. 다른 컴포넌트로 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7344e4dadc3909a3335b74575ebf433ba99c5ed" translate="yes" xml:space="preserve">
          <source>With Suspense, handling fetching errors works the same way as handling rendering errors &amp;mdash; you can render an &lt;a href=&quot;error-boundaries&quot;&gt;error boundary&lt;/a&gt; anywhere to &amp;ldquo;catch&amp;rdquo; errors in components below.</source>
          <target state="translated">서스펜스으로 가져 오는 오류를 처리하는 렌더링 오류를 처리와 같은 방식으로 작동합니다 - 당신은 렌더링 할 수있는 &lt;a href=&quot;error-boundaries&quot;&gt;오류 경계&lt;/a&gt; 아래 구성 요소 &quot;캐치&quot;오류로 어디서나.</target>
        </trans-unit>
        <trans-unit id="9efd00870544783d51928530a161bc172e3d880f" translate="yes" xml:space="preserve">
          <source>With Suspense, we still start fetching first, but we flip the last two steps around:</source>
          <target state="translated">Suspense를 사용하면 먼저 가져 오기를 시작하지만 마지막 두 단계를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="71a13a4bc9a257a4e9bafbaa0cf86edb5925dd2a" translate="yes" xml:space="preserve">
          <source>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write &lt;code&gt;handleChange&lt;/code&gt; as:</source>
          <target state="translated">제어 된 구성 요소를 사용하면 모든 상태 변이에 연관된 처리기 기능이 있습니다. 이를 통해 사용자 입력을 수정하거나 검증 할 수 있습니다. 예를 들어 이름을 모두 대문자로 쓰 &lt;code&gt;handleChange&lt;/code&gt; 를 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33f666c5c50a02b68cc5f1089d8d956529654dee" translate="yes" xml:space="preserve">
          <source>With a controlled component, the input&amp;rsquo;s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.</source>
          <target state="translated">With a controlled component, the input&amp;rsquo;s value is always driven by the React state. While this means you have to type a bit more code, you can now pass the value to other UI elements too, or reset it from other event handlers.</target>
        </trans-unit>
        <trans-unit id="67500667906c2a530542da2c6f7b33bdea261d21" translate="yes" xml:space="preserve">
          <source>With functions and ES6 classes &lt;code&gt;defaultProps&lt;/code&gt; is defined as a property on the component itself:</source>
          <target state="translated">함수와 ES6 클래스를 사용하면 &lt;code&gt;defaultProps&lt;/code&gt; 가 구성 요소 자체의 속성으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="88886f54534112497ad51083107a11f86e743c51" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;a href=&quot;react-dom#render&quot;&gt;&lt;code&gt;ReactDOM.render()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;a href=&quot;react-dom#render&quot;&gt; &lt;code&gt;ReactDOM.render()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cb4872f49b4f73a2d9aa1f1ea9382a37bb1b4523" translate="yes" xml:space="preserve">
          <source>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">지금까지 우리가 아는 한, UI를 업데이트하는 유일한 방법은 새 요소를 작성하여 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="061b1b684b37fa6e01cf5d46650b25478b6d35f1" translate="yes" xml:space="preserve">
          <source>With that out of the way, let&amp;rsquo;s get started!</source>
          <target state="translated">그 방법으로 시작하자!</target>
        </trans-unit>
        <trans-unit id="e970431e1cb945a83be8e8c9ff751a9c325a5c21" translate="yes" xml:space="preserve">
          <source>With the example above, the &lt;code&gt;Post&lt;/code&gt; component can read &lt;code&gt;props.id&lt;/code&gt;, but not &lt;code&gt;props.key&lt;/code&gt;.</source>
          <target state="translated">위의 예제로, &lt;code&gt;Post&lt;/code&gt; 구성 요소는 읽을 수 &lt;code&gt;props.id&lt;/code&gt; 하지만, &lt;code&gt;props.key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7a845306b0978a35ad4c18a5ccd1c03f8079bcf" translate="yes" xml:space="preserve">
          <source>With this approach, we can &lt;strong&gt;fetch code and data in parallel&lt;/strong&gt;. When we navigate between pages, we don&amp;rsquo;t need to wait for a page&amp;rsquo;s code to load to start loading its data. We can start fetching both code and data at the same time (during the link click), delivering a much better user experience.</source>
          <target state="translated">이 방법을 사용하면 &lt;strong&gt;코드와 데이터를 병렬로 가져올&lt;/strong&gt; 수 있습니다 . 페이지를 탐색 할 때 페이지 코드가로드되어 데이터로드가 시작될 때까지 기다릴 필요가 없습니다. 링크 클릭시 코드와 데이터를 동시에 가져 오기 시작하여 훨씬 나은 사용자 경험을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca794ea7a32fb93f5c86146905ba234d1fd33e3a" translate="yes" xml:space="preserve">
          <source>With this change, even though we&amp;rsquo;re in the Pending state, we don&amp;rsquo;t display any indication to the user until 500ms has passed. This may not seem like much of an improvement when the API responses are slow. But compare how it feels &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;before&lt;/a&gt; and &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;after&lt;/a&gt; when the API call is fast. Even though the rest of the code hasn&amp;rsquo;t changed, suppressing a &amp;ldquo;too fast&amp;rdquo; loading state improves the perceived performance by not calling attention to the delay.</source>
          <target state="translated">이 변경으로 인해 보류 상태에 있더라도 500ms가 경과 할 때까지 사용자에게 표시가 표시되지 않습니다. API 응답이 느리면 개선되지 않은 것처럼 보일 수 있습니다. 그러나 어떤 느낌인지 비교 &lt;a href=&quot;https://codesandbox.io/s/thirsty-liskov-1ygph&quot;&gt;이전&lt;/a&gt; 과 &lt;a href=&quot;https://codesandbox.io/s/hardcore-http-s18xr&quot;&gt;이후&lt;/a&gt; API 호출이 빠른 경우. 나머지 코드는 변경되지 않았지만 &quot;너무 빠른&quot;로드 상태를 억제하면 지연에주의를 기울이지 않으면 서 인식 된 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="5635b27b3f3a955ac587a6317f7e72991a8317f4" translate="yes" xml:space="preserve">
          <source>With this change, it works as expected. We can type into the input immediately, and the translation later &amp;ldquo;catches up&amp;rdquo; to what we have typed.</source>
          <target state="translated">이 변경으로 예상대로 작동합니다. 입력을 즉시 입력 할 수 있으며 번역은 나중에 입력 한 내용을 &quot;잡습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="ce08b851d8dd00fc80cae81cb3eb7b40fcfc82a3" translate="yes" xml:space="preserve">
          <source>With this change, only the top-most Page component needs to know about the &lt;code&gt;Link&lt;/code&gt; and &lt;code&gt;Avatar&lt;/code&gt; components&amp;rsquo; use of &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;avatarSize&lt;/code&gt;.</source>
          <target state="translated">이 변경으로, 최상위 Page 구성 요소 만 &lt;code&gt;Link&lt;/code&gt; 및 &lt;code&gt;Avatar&lt;/code&gt; 구성 요소의 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;avatarSize&lt;/code&gt; 사용에 대해 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3eccd6c7aebe3ee7b1033ca2e41432db51ce2ee2" translate="yes" xml:space="preserve">
          <source>Wrap Lazy Features in &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 에서 지연 기능 래핑</target>
        </trans-unit>
        <trans-unit id="a87b9174801725911157c6c5b05263b9d0b4efa5" translate="yes" xml:space="preserve">
          <source>Wrapping setState in a Transition</source>
          <target state="translated">전환에서 setState 래핑</target>
        </trans-unit>
        <trans-unit id="560b6056cd03b4bbd6db601b466123014a92c0b9" translate="yes" xml:space="preserve">
          <source>Writing Conversion Functions</source>
          <target state="translated">변환 함수 작성</target>
        </trans-unit>
        <trans-unit id="62d53daf650bb95bca68a82e9c932fea369dd88e" translate="yes" xml:space="preserve">
          <source>Yes! The &lt;a href=&quot;hooks-reference#useref&quot;&gt;&lt;code&gt;useRef()&lt;/code&gt;&lt;/a&gt; Hook isn&amp;rsquo;t just for DOM refs. The &amp;ldquo;ref&amp;rdquo; object is a generic container whose &lt;code&gt;current&lt;/code&gt; property is mutable and can hold any value, similar to an instance property on a class.</source>
          <target state="translated">예! &lt;a href=&quot;hooks-reference#useref&quot;&gt; &lt;code&gt;useRef()&lt;/code&gt; &lt;/a&gt; 후크는 DOM의 심판 아닙니다. &quot;ref&quot;객체는 &lt;code&gt;current&lt;/code&gt; 속성이 변경 가능하고 클래스의 인스턴스 속성과 유사한 값을 보유 할 수 있는 일반 컨테이너입니다 .</target>
        </trans-unit>
        <trans-unit id="d3e5b9e5308a5e4ac25712b025d561cb9020c6ad" translate="yes" xml:space="preserve">
          <source>Yes, see the docs on styling &lt;a href=&quot;dom-elements#style&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">예, 스타일링 관련 문서는 &lt;a href=&quot;dom-elements#style&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c94219b317ac261806da31fa074e0f23cb0d9f1" translate="yes" xml:space="preserve">
          <source>Yes. See &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;conditionally firing an effect&lt;/a&gt;. Note that forgetting to handle updates often &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;introduces bugs&lt;/a&gt;, which is why this isn&amp;rsquo;t the default behavior.</source>
          <target state="translated">예. &lt;a href=&quot;hooks-reference#conditionally-firing-an-effect&quot;&gt;조건부 효과 실행을&lt;/a&gt; 참조하십시오 . 업데이트 처리를 잊어 버리면 종종 &lt;a href=&quot;hooks-effect#explanation-why-effects-run-on-each-update&quot;&gt;버그&lt;/a&gt; 가 발생하기 때문에 이것이 기본 동작이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4dcce6c1701948f7d9bfd3db4ed94bd67e027e5c" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;don&amp;rsquo;t have to&lt;/strong&gt; use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike &lt;code&gt;this.setState&lt;/code&gt; in a class, updating a state variable always &lt;em&gt;replaces&lt;/em&gt; it instead of merging it.</source>
          <target state="translated">당신은 &lt;strong&gt;필요가 없습니다&lt;/strong&gt; 많은 상태 변수를 사용합니다. 상태 변수는 객체와 배열을 잘 유지할 수 있으므로 관련 데이터를 그룹화 할 수 있습니다. 그러나 클래스의 &lt;code&gt;this.setState&lt;/code&gt; 와 달리 상태 변수를 업데이트하면 병합하지 않고 항상 &lt;em&gt;대체&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9a4b1f324495e2f088e3d6f0cdc9f89fb5cd9262" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidMount()&lt;/code&gt;. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the &lt;code&gt;render()&lt;/code&gt; will be called twice in this case, the user won&amp;rsquo;t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the &lt;code&gt;constructor()&lt;/code&gt; instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.</source>
          <target state="translated">&lt;code&gt;componentDidMount()&lt;/code&gt; 에서 &lt;strong&gt;즉시 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 호출 할&lt;/strong&gt; 수 &lt;strong&gt;있습니다&lt;/strong&gt; . 추가 렌더링을 트리거하지만 브라우저가 화면을 업데이트하기 전에 발생합니다. 이 경우 &lt;code&gt;render()&lt;/code&gt; 가 두 번 호출 되더라도 사용자에게는 중간 상태가 표시되지 않습니다. 이 패턴은 성능 문제가 자주 발생하므로주의해서 사용하십시오. 대부분의 경우 &lt;code&gt;constructor()&lt;/code&gt; 에서 초기 상태를 대신 할당 할 수 있어야합니다 . 그러나 크기 나 위치에 따라 무언가를 렌더링하기 전에 DOM 노드를 측정해야 할 때 모달 및 툴팁과 같은 경우에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fffd92980fb270dfc644a9073a729e972320668" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;may call &lt;code&gt;setState()&lt;/code&gt; immediately&lt;/strong&gt; in &lt;code&gt;componentDidUpdate()&lt;/code&gt; but note that &lt;strong&gt;it must be wrapped in a condition&lt;/strong&gt; like in the example above, or you&amp;rsquo;ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you&amp;rsquo;re trying to &amp;ldquo;mirror&amp;rdquo; some state to a prop coming from above, consider using the prop directly instead. Read more about &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;why copying props into state causes bugs&lt;/a&gt;.</source>
          <target state="translated">당신은 &lt;strong&gt;호출 할 수 있습니다 &lt;code&gt;setState()&lt;/code&gt; 즉시&lt;/strong&gt; 에 &lt;code&gt;componentDidUpdate()&lt;/code&gt; 것을하지만주의 &lt;strong&gt;가 조건에 싸여해야&lt;/strong&gt; 위의 예처럼, 또는 당신은 무한 루프가 발생할 수 있습니다. 또한 사용자가 볼 수는 없지만 구성 요소 성능에 영향을 줄 수있는 추가 렌더링을 다시 수행 할 수 있습니다. 위에서 오는 소품에 어떤 상태를 &quot;미러링&quot;하려고한다면, 대신 직접 소품을 사용하는 것을 고려하십시오. &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;소품을 상태로 복사하면 버그가 발생&lt;/a&gt; 하는 이유 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="603dad85523484256e65c5bb07930c069dda7af2" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in &lt;code&gt;componentWillUnmount()&lt;/code&gt; because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.</source>
          <target state="translated">당신은 &lt;strong&gt;전화를 안 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt; 에 &lt;code&gt;componentWillUnmount()&lt;/code&gt; 구성 요소가 다시 렌더링 할 수 없습니다 때문입니다. 구성 요소 인스턴스가 마운트 해제되면 다시 마운트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="303da79a4d02468a439c95546cb936fc2ff452ef" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;should not call &lt;code&gt;setState()&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;constructor()&lt;/code&gt;. Instead, if your component needs to use local state, &lt;strong&gt;assign the initial state to &lt;code&gt;this.state&lt;/code&gt;&lt;/strong&gt; directly in the constructor:</source>
          <target state="translated">당신은 &lt;strong&gt;호출하지 않아야합니다 &lt;code&gt;setState()&lt;/code&gt; &lt;/strong&gt; 에 &lt;code&gt;constructor()&lt;/code&gt; . 대신, 구성 요소가 로컬 상태를 사용해야 하는 경우 생성자에서 직접 &lt;strong&gt;초기 상태를 &lt;code&gt;this.state&lt;/code&gt; 에&lt;/strong&gt;&lt;strong&gt; 할당하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b1f32119d9afed969fb6dda4b28934eeedec90f3" translate="yes" xml:space="preserve">
          <source>You Might Not Need a Toolchain</source>
          <target state="translated">툴체인이 필요하지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="67b66c50d30ba90262826fe97b9b36429e378815" translate="yes" xml:space="preserve">
          <source>You are now ready to code! We recommend to check out the following resources to learn more about TypeScript:</source>
          <target state="translated">이제 코딩 할 준비가되었습니다! TypeScript에 대한 자세한 내용은 다음 리소스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="973e5c03c0fd9a741a0042c982cebb565ec5f9df" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;add-react-to-a-website&quot;&gt;add React to an HTML page in one minute&lt;/a&gt;. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="translated">&lt;a href=&quot;add-react-to-a-website&quot;&gt;1 분 안에 HTML 페이지에 React를 추가&lt;/a&gt; 할 수 있습니다 . 그런 다음 점진적으로 그 존재를 확장하거나 동적 위젯 몇 개에 포함되도록 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa0979344c5bce99fe8cd2033a94efe89e8fc6a" translate="yes" xml:space="preserve">
          <source>You can also add a wrapper DOM node in your component and attach a ref directly to it.</source>
          <target state="translated">컴포넌트에 랩퍼 DOM 노드를 추가하고 참조를 직접 첨부 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="349b87f9aabf27468c7550f23c44ba9943c43e8f" translate="yes" xml:space="preserve">
          <source>You can also add it to an &lt;strong&gt;existing Create React App project&lt;/strong&gt;, &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;as documented here&lt;/a&gt;.</source>
          <target state="translated">당신은 또한에 추가 할 수 있습니다 &lt;strong&gt;기존의 반작용 만들기 응용 프로그램 프로젝트&lt;/strong&gt; , &lt;a href=&quot;https://facebook.github.io/create-react-app/docs/adding-typescript&quot;&gt;여기에 설명 된대로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc81e5ea9298f4348d258492ffdc2b7046f666c1" translate="yes" xml:space="preserve">
          <source>You can also check out the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt; and the &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hooks-reference&quot;&gt;Hooks API 참조&lt;/a&gt; 및 &lt;a href=&quot;hooks-faq&quot;&gt;Hooks FAQ&lt;/a&gt; 도 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d10268304c0a25dd7504dbf0c423bd8a4ff9a0c" translate="yes" xml:space="preserve">
          <source>You can also create the initial state lazily. To do this, you can pass an &lt;code&gt;init&lt;/code&gt; function as the third argument. The initial state will be set to &lt;code&gt;init(initialArg)&lt;/code&gt;.</source>
          <target state="translated">초기 상태를 느리게 만들 수도 있습니다. 이를 위해 &lt;code&gt;init&lt;/code&gt; 함수를 세 번째 인수로 전달할 수 있습니다 . 초기 상태는 &lt;code&gt;init(initialArg)&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ce8997748b7b364b2a5b8fa6eb06cb5298fac78" translate="yes" xml:space="preserve">
          <source>You can also follow the &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs account&lt;/a&gt; on Twitter, but you won&amp;rsquo;t miss anything essential if you only read the blog.</source>
          <target state="translated">Twitter 에서 &lt;a href=&quot;https://twitter.com/reactjs&quot;&gt;@reactjs 계정&lt;/a&gt; 을 팔로우 할 수도 있지만 블로그 만 읽으면 필수 항목을 놓치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c56670d911da74ad4acea3f7f57edb7a5fe3c872" translate="yes" xml:space="preserve">
          <source>You can also pick specific props that your component will consume while passing all other props using the spread operator.</source>
          <target state="translated">스프레드 연산자를 사용하여 다른 모든 소품을 전달하면서 구성 요소가 사용할 특정 소품을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e229f290934869795a385808e0402ed8f11b8ceb" translate="yes" xml:space="preserve">
          <source>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; is a component, you can use it directly from JSX with:</source>
          <target state="translated">JSX 내에서 점 표기법을 사용하여 React 컴포넌트를 참조 할 수도 있습니다. 많은 React 컴포넌트를 내보내는 단일 모듈이있는 경우 편리합니다. 예를 들어 &lt;code&gt;MyComponents.DatePicker&lt;/code&gt; 가 구성 요소 인 경우 다음을 사용하여 JSX에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8623b3d7d4d43f6c6f405c02d8001ad9f14ba623" translate="yes" xml:space="preserve">
          <source>You can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let&amp;rsquo;s say we have an object named &lt;code&gt;colormap&lt;/code&gt; and we want to write a function that changes &lt;code&gt;colormap.right&lt;/code&gt; to be &lt;code&gt;'blue'&lt;/code&gt;. We could write:</source>
          <target state="translated">비슷한 방식으로 객체를 변형시켜 돌연변이를 피하는 코드를 다시 작성할 수도 있습니다. 예를 들어, &lt;code&gt;colormap&lt;/code&gt; 이라는 객체 가 있고 &lt;code&gt;colormap.right&lt;/code&gt; 를 &lt;code&gt;'blue'&lt;/code&gt; 로 변경하는 함수를 작성하려고한다고 가정 합니다. 우리는 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6e352e946162df801daa33ab297c25026fd93b28" translate="yes" xml:space="preserve">
          <source>You can also see the filenames and line numbers in the component stack trace. This works by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt; projects:</source>
          <target state="translated">구성 요소 스택 추적에서 파일 이름과 줄 번호를 볼 수도 있습니다. 이것은 기본적으로 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;React App&lt;/a&gt; 프로젝트 생성 에서 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="44310bf2359ee79a622ac37b32c6721ba10337eb" translate="yes" xml:space="preserve">
          <source>You can also traverse the output to find specific nodes and make assertions about them.</source>
          <target state="translated">또한 출력을 탐색하여 특정 노드를 찾고 이에 대한 어설 션을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d16f115884d19dbbe73652d9e5c447e2ecf104b" translate="yes" xml:space="preserve">
          <source>You can also use an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 class&lt;/a&gt; to define a component:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스&lt;/a&gt; 를 사용하여 구성 요소를 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd4f33bcd9d3c0110be7b31954290c1a836db0c" translate="yes" xml:space="preserve">
          <source>You can also use it with the shorthand &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; syntax. For more information, see &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0: Improved Support for Fragments&lt;/a&gt;.</source>
          <target state="translated">속기 &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; 구문 과 함께 사용할 수도 있습니다 . 자세한 정보는 &lt;a href=&quot;https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html&quot;&gt;React v16.2.0 : 조각 지원 개선을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3aeee99f3a099cb1560c2cd739565a340f73dde" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt; module to report these accessibility findings directly to the console while developing and debugging.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dylanb/react-axe&quot;&gt;react-axe&lt;/a&gt; 모듈을 사용하여 이러한 접근성 결과를 개발 및 디버깅하는 동안 콘솔에 직접보고 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0eed65ed081006404dbb7accb393e90c7e592705" translate="yes" xml:space="preserve">
          <source>You can also use the self-closing form of the tag if there are no children. So:</source>
          <target state="translated">자녀가없는 경우 자체 폐쇄 양식의 태그를 사용할 수도 있습니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="9295f68bc1efa13ff8ed4a3e2fdaca0db413bd6c" translate="yes" xml:space="preserve">
          <source>You can also write your own integration for a data fetching library, if you&amp;rsquo;d like.</source>
          <target state="translated">원하는 경우 데이터 가져 오기 라이브러리에 대한 고유 한 통합을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e2eed831e6bee471a1b051322603084a6ff5dd" translate="yes" xml:space="preserve">
          <source>You can always refer to our public GitHub repository&amp;rsquo;s &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;history&lt;/a&gt; for a comprehensive list of changes.</source>
          <target state="translated">포괄적 인 변경 사항 목록은 언제든지 공개 GitHub 리포지토리 &lt;a href=&quot;https://github.com/facebook/react/commits/master&quot;&gt;내역&lt;/a&gt; 을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b009a9003a97078d2cc35e3df5d168b43b897374" translate="yes" xml:space="preserve">
          <source>You can build collections of elements and &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;include them in JSX&lt;/a&gt; using curly braces &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">중괄호 &lt;code&gt;{}&lt;/code&gt; 를 사용하여 요소 콜렉션을 빌드 &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;하고 JSX에 포함시킬&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aef58e0c6c697aada939945a0796364fbd8020a1" translate="yes" xml:space="preserve">
          <source>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with &lt;code&gt;FilterableProductTable&lt;/code&gt;) or with the ones lower in it (&lt;code&gt;ProductRow&lt;/code&gt;). In simpler examples, it&amp;rsquo;s usually easier to go top-down, and on larger projects, it&amp;rsquo;s easier to go bottom-up and write tests as you build.</source>
          <target state="translated">하향식 또는 상향식을 작성할 수 있습니다. 즉, 계층에서 상위 구성 요소를 빌드하는 것부터 시작하거나 (예 : &lt;code&gt;FilterableProductTable&lt;/code&gt; 로 시작 ) 구성 요소가 낮은 구성 요소 ( &lt;code&gt;ProductRow&lt;/code&gt; )로 시작할 수 있습니다 . 간단한 예제에서는 일반적으로 하향식으로 진행하는 것이 더 쉽고 대규모 프로젝트에서는 상향식으로 작성하고 테스트를 작성하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ced09d20e0733b6dd23b81aeb615198bfbc46731" translate="yes" xml:space="preserve">
          <source>You can compare these two examples to feel the difference:</source>
          <target state="translated">차이를 느끼기 위해이 두 가지 예를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96723e62d1953ac566e2ea02b39f6c1b0247dd57" translate="yes" xml:space="preserve">
          <source>You can continue to use the exact same APIs as you always have; they&amp;rsquo;ll continue to work.</source>
          <target state="translated">항상 똑같은 API를 계속 사용할 수 있습니다. 그들은 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="65b678af9f2bf41e57cf3a9425ebf0baf1058ffd" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at a time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt; , we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at a time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="568c5b42327ce78962e0349e0bc941c13aa391bb" translate="yes" xml:space="preserve">
          <source>You can control how many loading states are visible at once with the &lt;code&gt;tail&lt;/code&gt; prop. If we specify &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt;, we&amp;rsquo;ll see &lt;em&gt;at most one&lt;/em&gt; fallback at the time. You can play with it &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tail&lt;/code&gt; 소품으로 한 번에 몇 개의 로딩 상태를 볼 수 있는지 제어 할 수 있습니다 . 우리가 지정하는 경우 &lt;code&gt;tail=&quot;collapsed&quot;&lt;/code&gt; , 우리가 나타납니다 &lt;em&gt;최대 하나의&lt;/em&gt; 시점에서 대체합니다. &lt;a href=&quot;https://codesandbox.io/s/adoring-almeida-1zzjh&quot;&gt;여기서&lt;/a&gt; 재생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="259f2bd3a3238bf87405bdcfaaa102614b981ebf" translate="yes" xml:space="preserve">
          <source>You can convert a function component like &lt;code&gt;Clock&lt;/code&gt; to a class in five steps:</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 과 같은 함수 구성 요소 를 5 단계로 클래스 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99aa21f209e1d4380b74a754381c1adecc7d6d46" translate="yes" xml:space="preserve">
          <source>You can define default values for your &lt;code&gt;props&lt;/code&gt; by assigning to the special &lt;code&gt;defaultProps&lt;/code&gt; property:</source>
          <target state="translated">특별한 &lt;code&gt;defaultProps&lt;/code&gt; 속성 에 할당 하여 &lt;code&gt;props&lt;/code&gt; 기본값을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="060ad8196b66eae31d457e14f600fdc295c2b991" translate="yes" xml:space="preserve">
          <source>You can enable strict mode for any part of your application. For example:</source>
          <target state="translated">애플리케이션의 모든 부분에 대해 엄격 모드를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31a484513ad8dd340d05d4eedab4cba055bb08f5" translate="yes" xml:space="preserve">
          <source>You can even set the function&amp;rsquo;s &lt;code&gt;displayName&lt;/code&gt; property to include the component you&amp;rsquo;re wrapping:</source>
          <target state="translated">랩핑 할 구성 요소를 포함하도록 함수의 &lt;code&gt;displayName&lt;/code&gt; 속성을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d4cf37b373742281f14985d8f8a9c6a764f4af0" translate="yes" xml:space="preserve">
          <source>You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme. Learn more about our commitment to stability and incremental migration in our &lt;a href=&quot;faq-versioning&quot;&gt;versioning policy&lt;/a&gt;.</source>
          <target state="translated">최신 업데이트는 매우 안정적 일 것으로 예상 할 수 있습니다. 버전은 시맨틱 버전 관리 체계를 따릅니다. &lt;a href=&quot;faq-versioning&quot;&gt;버전 관리 정책&lt;/a&gt; 에서 안정성 및 증분 마이그레이션에 대한 약속에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="43486125276c666e322a5707b38de7e0642f9408" translate="yes" xml:space="preserve">
          <source>You can find instructions for building your app for production below.</source>
          <target state="translated">아래에서 프로덕션 용 앱 빌드에 대한 지침을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b669ecfca0f474a332753750307b5170f4d3d5ab" translate="yes" xml:space="preserve">
          <source>You can have as many such isolated components as you like, and use &lt;code&gt;ReactDOM.render()&lt;/code&gt; to render them to different DOM containers. Gradually, as you convert more of your app to React, you will be able to combine them into larger components, and move some of the &lt;code&gt;ReactDOM.render()&lt;/code&gt; calls up the hierarchy.</source>
          <target state="translated">격리 된 구성 요소를 원하는만큼 가질 수 있으며 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 를 사용 하여 다른 DOM 컨테이너로 렌더링 할 수 있습니다. 점차적으로 더 많은 앱을 React로 변환하면 더 큰 구성 요소로 결합하여 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 중 일부를 계층 구조 로 이동시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59a095baf122e4a8f541350370263b19ef77da11" translate="yes" xml:space="preserve">
          <source>You can imagine that in a large app, this same pattern of subscribing to &lt;code&gt;DataSource&lt;/code&gt; and calling &lt;code&gt;setState&lt;/code&gt; will occur over and over again. We want an abstraction that allows us to define this logic in a single place and share it across many components. This is where higher-order components excel.</source>
          <target state="translated">큰 앱에서 &lt;code&gt;DataSource&lt;/code&gt; 를 구독하고 &lt;code&gt;setState&lt;/code&gt; 를 호출하는 동일한 패턴이 반복해서 발생할 것이라고 상상할 수 있습니다 . 우리는이 논리를 한 곳에서 정의하고 여러 구성 요소에서 공유 할 수있는 추상화를 원합니다. 이것은 고차 부품이 탁월한 곳입니다.</target>
        </trans-unit>
        <trans-unit id="c2607b19c795cb6467d715b76b65c4f83582007c" translate="yes" xml:space="preserve">
          <source>You can instead make this explicit by passing a ref to your custom component and pass that along to the DOM using &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref forwarding&lt;/a&gt;.</source>
          <target state="translated">대신 ref를 사용자 정의 구성 요소에 전달하고 &lt;a href=&quot;forwarding-refs#forwarding-refs-to-dom-components&quot;&gt;ref forwarding을&lt;/a&gt; 사용하여 DOM에 전달하여 명시 적으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e58d88ea64ac854e8b852850131003a5b38dfe8b" translate="yes" xml:space="preserve">
          <source>You can learn how to use it from our &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;code splitting documentation&lt;/a&gt;. You might also want to check out &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;this article&lt;/a&gt; explaining how to use it in more detail.</source>
          <target state="translated">&lt;a href=&quot;code-splitting#reactlazy&quot;&gt;코드 분할 문서&lt;/a&gt; 에서 사용 방법을 배울 수 있습니다 . 더 자세히 사용하는 방법을 설명하는 &lt;a href=&quot;https://medium.com/@pomber/lazy-loading-and-preloading-components-in-react-16-6-804de091c82d&quot;&gt;이 기사&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0405db67bd6f9d08d2f8547c2ca89d3bc11fef3e" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;a href=&quot;conditional-rendering&quot;&gt;conditional rendering&lt;/a&gt; and &lt;a href=&quot;lists-and-keys&quot;&gt;loops&lt;/a&gt; in the corresponding sections.</source>
          <target state="translated">해당 섹션에서 &lt;a href=&quot;conditional-rendering&quot;&gt;조건부 렌더링&lt;/a&gt; 및 &lt;a href=&quot;lists-and-keys&quot;&gt;루프&lt;/a&gt; 에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdc3d81678cb41b857c269d907b419fc833fc42" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;useEffect&lt;/code&gt; on a dedicated page: &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.</source>
          <target state="translated">전용 페이지에서 &lt;code&gt;useEffect&lt;/code&gt; 에 대한 자세한 내용을 볼 수 있습니다 : &lt;a href=&quot;hooks-effect&quot;&gt;효과 후크 사용&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2190fea105b1a5c2c5132e45309d084e938f0fab" translate="yes" xml:space="preserve">
          <source>You can learn more about all the built-in Hooks on a dedicated page: &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API Reference&lt;/a&gt;.</source>
          <target state="translated">전용 페이지에서 모든 내장 후크에 대해 자세히 학습 할 수 있습니다. &lt;a href=&quot;hooks-reference&quot;&gt;후크 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd76f44fa000769bfbb88ab6451d678fd499b34e" translate="yes" xml:space="preserve">
          <source>You can learn more about custom Hooks on a dedicated page: &lt;a href=&quot;hooks-custom&quot;&gt;Building Your Own Hooks&lt;/a&gt;.</source>
          <target state="translated">전용 페이지에서 사용자 정의 후크에 대해 자세히 알아볼 수 있습니다 : &lt;a href=&quot;hooks-custom&quot;&gt;자신 만의 후크 만들기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44e6a6a3a05e18341e61e8b581459673e8664c2b" translate="yes" xml:space="preserve">
          <source>You can learn more about the State Hook on a dedicated page: &lt;a href=&quot;hooks-state&quot;&gt;Using the State Hook&lt;/a&gt;.</source>
          <target state="translated">전용 페이지에서 State Hook에 대한 자세한 내용은 State Hook &lt;a href=&quot;hooks-state&quot;&gt;사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ded04d381f1d8a8f1862e047aac6e2b430518c7" translate="yes" xml:space="preserve">
          <source>You can learn more about these rules on a dedicated page: &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="translated">이러한 규칙에 대한 자세한 내용은 전용 페이지에서 확인할 수 있습니다 : &lt;a href=&quot;hooks-rules&quot;&gt;규칙 규칙&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a8afdfc0befb4880f75b37590103ef140b8332" translate="yes" xml:space="preserve">
          <source>You can learn more about this in &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;webpack documentation&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;https://webpack.js.org/guides/production/&quot;&gt;웹팩 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6defc311d97882551acc89862aaa8211b5ccb8bf" translate="yes" xml:space="preserve">
          <source>You can map a collection of items to an array of fragments as you would any other type of element as well:</source>
          <target state="translated">다른 유형의 요소와 마찬가지로 항목 컬렉션을 조각 배열에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c39e023484eeec5fc7042f79a35e6d4e7bc21cde" translate="yes" xml:space="preserve">
          <source>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</source>
          <target state="translated">서로 다른 유형의 하위를 함께 사용할 수 있으므로 JSX 하위와 함께 문자열 리터럴을 사용할 수 있습니다. 이것은 JSX가 HTML과 유사한 또 다른 방법이므로 유효한 JSX 및 유효한 HTML입니다.</target>
        </trans-unit>
        <trans-unit id="68923457893fc208ce455a8d754f8df854066e43" translate="yes" xml:space="preserve">
          <source>You can only subscribe to a single context using this API. If you need to read more than one see &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;Consuming Multiple Contexts&lt;/a&gt;.</source>
          <target state="translated">이 API를 사용하여 단일 컨텍스트에만 가입 할 수 있습니다. &lt;a href=&quot;#consuming-multiple-contexts&quot;&gt;여러&lt;/a&gt; 개를 읽어야 하는 경우 여러 컨텍스트 소비를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0539a6d8aab194914bf2c1b637a40462054bec" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;createNodeMock&lt;/code&gt; function to &lt;code&gt;TestRenderer.create&lt;/code&gt; as the option, which allows for custom mock refs. &lt;code&gt;createNodeMock&lt;/code&gt; accepts the current element and should return a mock ref object. This is useful when you test a component that relies on refs.</source>
          <target state="translated">&lt;code&gt;createNodeMock&lt;/code&gt; 함수를 옵션 으로 &lt;code&gt;TestRenderer.create&lt;/code&gt; 에 전달 하여 사용자 정의 모의 참조를 허용합니다. &lt;code&gt;createNodeMock&lt;/code&gt; 은 현재 요소를 받아들이고 mock ref 객체를 반환해야합니다. 이것은 참조에 의존하는 구성 요소를 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60a31b4af9209c82ad0c032eb8bd56c3135e3e31" translate="yes" xml:space="preserve">
          <source>You can pass a string literal as a prop. These two JSX expressions are equivalent:</source>
          <target state="translated">문자열 리터럴을 소품으로 전달할 수 있습니다. 이 두 JSX 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98e2514deb58f721583921f9f4558ca15319f866" translate="yes" xml:space="preserve">
          <source>You can pass an array into the &lt;code&gt;value&lt;/code&gt; attribute, allowing you to select multiple options in a &lt;code&gt;select&lt;/code&gt; tag:</source>
          <target state="translated">배열을 &lt;code&gt;value&lt;/code&gt; 속성에 전달하면 &lt;code&gt;select&lt;/code&gt; 태그 에서 여러 옵션을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c0dca775a62dc92cd4d4ca42033a80bb40b933d" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as a prop, by surrounding it with &lt;code&gt;{}&lt;/code&gt;. For example, in this JSX:</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 로 묶어 JavaScript 표현식을 소품으로 전달할 수 있습니다 . 예를 들어,이 JSX에서 :</target>
        </trans-unit>
        <trans-unit id="820386db58d5b70925ee607029782118c88bd411" translate="yes" xml:space="preserve">
          <source>You can pass any JavaScript expression as children, by enclosing it within &lt;code&gt;{}&lt;/code&gt;. For example, these expressions are equivalent:</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 안에 포함하여 JavaScript 표현식을 하위로 전달할 수 있습니다 . 예를 들어 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2ca332aa888156d7e208d864ef99671f87200fd7" translate="yes" xml:space="preserve">
          <source>You can pass callback refs between components like you can with object refs that were created with &lt;code&gt;React.createRef()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;React.createRef()&lt;/code&gt; 로 만든 객체 참조와 마찬가지로 구성 요소간에 콜백 참조를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="184b23ee4cb82f84aaf58aa94da5ac57b911db50" translate="yes" xml:space="preserve">
          <source>You can place a &amp;ldquo;container&amp;rdquo; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; like this &lt;strong&gt;anywhere&lt;/strong&gt; inside the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag. You may have as many independent DOM containers on one page as you need. They are usually empty &amp;mdash; React will replace any existing content inside DOM containers.</source>
          <target state="translated">당신은 &quot;컨테이너&quot;배치 할 수 있습니다 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 를 다음과 같이 &lt;strong&gt;어디&lt;/strong&gt; 내부 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그입니다. 한 페이지에 필요한만큼 독립 DOM 컨테이너가있을 수 있습니다. 일반적으로 비어 있습니다. React는 DOM 컨테이너 내의 기존 내용을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="93edf3c48f793906a4695cc4a4c1f501ab4bdbd0" translate="yes" xml:space="preserve">
          <source>You can play with JSX using &lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;this online converter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/en/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=DwIwrgLhD2B2AEcDCAbAlgYwNYF4DeAFAJTw4B88EAFmgM4B0tAphAMoQCGETBe86WJgBMAXJQBOYJvAC-RGWQBQ8FfAAyaQYuAB6cFDhkgA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=es2015%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.3&quot;&gt;이 온라인 변환기를&lt;/a&gt; 사용하여 JSX를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d1545332973b55902e4255143d257c96974bde4" translate="yes" xml:space="preserve">
          <source>You can provide more JSX elements as the children. This is useful for displaying nested components:</source>
          <target state="translated">자식으로 더 많은 JSX 요소를 제공 할 수 있습니다. 중첩 된 구성 요소를 표시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65f15691188f600d9d12d5f168ed2e31e352f23e" translate="yes" xml:space="preserve">
          <source>You can put a string between the opening and closing tags and &lt;code&gt;props.children&lt;/code&gt; will just be that string. This is useful for many of the built-in HTML elements. For example:</source>
          <target state="translated">여는 태그와 닫는 태그 사이에 문자열을 넣을 수 있으며 &lt;code&gt;props.children&lt;/code&gt; 은 해당 문자열입니다. 이것은 많은 내장 HTML 요소에 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f565c43f4e7f61294704c4616bb4fff2035deea9" translate="yes" xml:space="preserve">
          <source>You can put any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript expression&lt;/a&gt; inside the curly braces in JSX. For example, &lt;code&gt;2 + 2&lt;/code&gt;, &lt;code&gt;user.firstName&lt;/code&gt;, or &lt;code&gt;formatName(user)&lt;/code&gt; are all valid JavaScript expressions.</source>
          <target state="translated">JSX의 중괄호 안에 유효한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions&quot;&gt;JavaScript 표현식을&lt;/a&gt; 넣을 수 있습니다 . 예를 들어, &lt;code&gt;2 + 2&lt;/code&gt; , &lt;code&gt;user.firstName&lt;/code&gt; 또는 &lt;code&gt;formatName(user)&lt;/code&gt; 은 모두 유효한 JavaScript 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="dea19bc48d1099e474ed6fa06e3adca5d08b7bb8" translate="yes" xml:space="preserve">
          <source>You can see a demo of this &lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;here&lt;/a&gt;. The &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;fun facts&amp;rdquo; responses come within 100ms of each other. But React coalesces them and &amp;ldquo;reveals&amp;rdquo; their Suspense boundaries together.</source>
          <target state="translated">&lt;a href=&quot;https://codesandbox.io/s/admiring-mendeleev-y54mk&quot;&gt;여기서&lt;/a&gt; 데모를 볼 수 있습니다 . &amp;ldquo;게시물&amp;rdquo;과&amp;ldquo;재미있는 사실&amp;rdquo;응답은 서로 100ms 이내에 있습니다. 그러나 React는 이들을 통합하고 서스펜스 경계를 ​​함께 &quot;공개&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="ecfa9132bdc5d45f7bea98f2b20a650f4c2adcdf" translate="yes" xml:space="preserve">
          <source>You can start seeing how your application will behave: set &lt;code&gt;filterText&lt;/code&gt; to &lt;code&gt;&quot;ball&quot;&lt;/code&gt; and refresh your app. You&amp;rsquo;ll see that the data table is updated correctly.</source>
          <target state="translated">애플리케이션의 작동 방식을 확인할 수 있습니다. &lt;code&gt;filterText&lt;/code&gt; 를 &lt;code&gt;&quot;ball&quot;&lt;/code&gt; 로 설정 하고 앱을 새로 고 칩니다 . 데이터 테이블이 올바르게 업데이트 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96719fed07645c37bccf1baf5ade2085d5b7d9e4" translate="yes" xml:space="preserve">
          <source>You can test React components similar to testing other JavaScript code.</source>
          <target state="translated">다른 JavaScript 코드를 테스트하는 것과 유사한 React 구성 요소를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="319b7a4aae21ffc530a5c776ce1c452ea524854a" translate="yes" xml:space="preserve">
          <source>You can then begin to assert facts about the output.</source>
          <target state="translated">그런 다음 출력에 대한 사실을 주장하기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d172c0255df0dcbddf210708de9b34e44a7b2d31" translate="yes" xml:space="preserve">
          <source>You can think of the Blocking Mode as a &amp;ldquo;gracefully degraded&amp;rdquo; version of the Concurrent Mode. &lt;strong&gt;As a result, in longer term we should be able to converge and stop thinking about different Modes altogether.&lt;/strong&gt; But for now, Modes are an important migration strategy. They let everyone decide when a migration is worth it, and upgrade at their own pace.</source>
          <target state="translated">차단 모드는 동시 모드의 &quot;정상적으로 저하 된&quot;버전으로 생각할 수 있습니다. &lt;strong&gt;결과적으로 장기적으로 다른 모드에 대한 생각을 수렴하고 중단 할 수 있어야합니다. &lt;/strong&gt;그러나 현재로서는 모드가 중요한 마이그레이션 전략입니다. 마이그레이션이 가치가있는시기를 결정하고 각자의 속도대로 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c64d3564a9301555ca04b03520026aa7c6bddae" translate="yes" xml:space="preserve">
          <source>You can think of the shallowRenderer as a &amp;ldquo;place&amp;rdquo; to render the component you&amp;rsquo;re testing, and from which you can extract the component&amp;rsquo;s output.</source>
          <target state="translated">shallowRenderer를 테스트중인 구성 요소를 렌더링하고 구성 요소의 출력을 추출 할 수있는 &quot;장소&quot;로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0590e174a395555a3c9bb1cf3a4ffa86c9488267" translate="yes" xml:space="preserve">
          <source>You can try out the new JSX fragment syntax with this &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;https://codepen.io/reactjs/pen/VrEbjE?editors=1000&quot;&gt;CodePen으로&lt;/a&gt; 새로운 JSX 프래그먼트 구문을 시험해 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="206b1d043bff35e73dffc40254662fddd860491d" translate="yes" xml:space="preserve">
          <source>You can try these builds on personal projects or in a branch, but we don&amp;rsquo;t recommend running them in production. At Facebook, we &lt;em&gt;do&lt;/em&gt; run them in production, but that&amp;rsquo;s because we&amp;rsquo;re also there to fix bugs when something breaks. You&amp;rsquo;ve been warned!</source>
          <target state="translated">이러한 빌드는 개인 프로젝트 나 지점에서 시도 할 수 있지만 프로덕션 환경에서는 실행하지 않는 것이 좋습니다. 페이스 북에서, 우리는 &lt;em&gt;어떻게&lt;/em&gt; 생산을 실행할 수 있지만 우리가 수정 버그 뭔가를 나누기에가도있어의 때문이다. 경고를 받았습니다!</target>
        </trans-unit>
        <trans-unit id="1bf129fcc87d9c8703b3fc987efff35eebff0bb7" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; the same way you&amp;rsquo;d use any other element except that it doesn&amp;rsquo;t support keys or attributes.</source>
          <target state="translated">키나 속성을 지원하지 않는다는 점을 제외하고 다른 요소를 사용하는 것과 동일한 방법으로 &lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fc4bfbc3568b2331ad90a50be1e5e88a5ee3938" translate="yes" xml:space="preserve">
          <source>You can use Jest&amp;rsquo;s snapshot testing feature to automatically save a copy of the JSON tree to a file and check in your tests that it hasn&amp;rsquo;t changed: &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;Learn more about it&lt;/a&gt;.</source>
          <target state="translated">Jest의 스냅 샷 테스트 기능을 사용하여 JSON 트리 사본을 파일에 자동으로 저장하고 변경되지 않은 테스트를 확인할 수 있습니다. &lt;a href=&quot;https://jestjs.io/docs/en/snapshot-testing&quot;&gt;자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4056132b8d01c6d2d7bac67f0daa9dca693db05e" translate="yes" xml:space="preserve">
          <source>You can use an arrow function to wrap around an event handler and pass parameters:</source>
          <target state="translated">화살표 함수를 사용하여 이벤트 핸들러를 감싸고 매개 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576e418bcc1c573f894bd565b26325d02a2c7944" translate="yes" xml:space="preserve">
          <source>You can use any AJAX library you like with React. Some popular ones are &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt;, &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt;, and the browser built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt;.</source>
          <target state="translated">React에서 원하는 AJAX 라이브러리를 사용할 수 있습니다. 인기있는 것은 &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;Axios&lt;/a&gt; , &lt;a href=&quot;https://api.jquery.com/jQuery.ajax/&quot;&gt;jQuery AJAX&lt;/a&gt; 및 브라우저 내장 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;window.fetch&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="071ccad1f37e1a2aa152780b53244d333e2c6010" translate="yes" xml:space="preserve">
          <source>You can use fake timers only in some tests. Above, we enabled them by calling &lt;code&gt;jest.useFakeTimers()&lt;/code&gt;. The main advantage they provide is that your test doesn&amp;rsquo;t actually have to wait five seconds to execute, and you also didn&amp;rsquo;t need to make the component code more convoluted just for testing.</source>
          <target state="translated">일부 테스트에서만 가짜 타이머를 사용할 수 있습니다. 위의 &lt;code&gt;jest.useFakeTimers()&lt;/code&gt; 를 호출하여 활성화했습니다 . 그들이 제공하는 주요 장점은 테스트가 실제로 5 초 동안 실행될 필요가 없으며 테스트를 위해 구성 요소 코드를 더 복잡하게 만들 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="313bb057a2f63bdbdabbce1010d70a283298f2c0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; package to shim &lt;code&gt;requestAnimationFrame&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.npmjs.com/package/raf&quot;&gt;raf&lt;/a&gt; 패키지를 사용하여 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 을 shim 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="14fd80619cfa4c8a757789fd180eb2c35fdf8b6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;currentTarget&lt;/code&gt; and &lt;code&gt;relatedTarget&lt;/code&gt; to differentiate if the focusing or blurring events originated from &lt;em&gt;outside&lt;/em&gt; of the parent element. Here is a demo you can copy and paste that shows how to detect focusing a child, focusing the element itself, and focus entering or leaving the whole subtree.</source>
          <target state="translated">You can use the &lt;code&gt;currentTarget&lt;/code&gt; and &lt;code&gt;relatedTarget&lt;/code&gt; to differentiate if the focusing or blurring events originated from &lt;em&gt;outside&lt;/em&gt; of the parent element. Here is a demo you can copy and paste that shows how to detect focusing a child, focusing the element itself, and focus entering or leaving the whole subtree.</target>
        </trans-unit>
        <trans-unit id="d18f7d2685e7d062c1678298785cd06becb18092" translate="yes" xml:space="preserve">
          <source>You can use the State Hook more than once in a single component:</source>
          <target state="translated">단일 구성 요소에서 상태 후크를 두 번 이상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b13cc97b72a37b2c0f156c7b3969fddf1f026f25" translate="yes" xml:space="preserve">
          <source>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn&amp;rsquo;t change.</source>
          <target state="translated">변수를 사용하여 요소를 저장할 수 있습니다. 이렇게하면 나머지 출력이 변경되지 않고 구성 요소의 일부를 조건부로 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad2ebdcc22b0a305902796e8d6c0c5dc695b0fc" translate="yes" xml:space="preserve">
          <source>You can verify by inspecting the &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;last example&lt;/a&gt; with the browser tools:</source>
          <target state="translated">브라우저 도구 &lt;a href=&quot;https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element&quot;&gt;를&lt;/a&gt; 사용하여 마지막 예 를 검사하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fed7cbf84ae5ac541a4e8a4231d62ef5696a99e1" translate="yes" xml:space="preserve">
          <source>You can wrap a function component with &lt;code&gt;React.memo&lt;/code&gt; to shallowly compare its props:</source>
          <target state="translated">함수 구성 요소를 &lt;code&gt;React.memo&lt;/code&gt; 로 감싸서 소품을 얕게 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76f54fde37523874b455579c8df068962295d11b" translate="yes" xml:space="preserve">
          <source>You can write custom Hooks that cover a wide range of use cases like form handling, animation, declarative subscriptions, timers, and probably many more we haven&amp;rsquo;t considered. We are excited to see what custom Hooks the React community will come up with.</source>
          <target state="translated">양식 처리, 애니메이션, 선언적 구독, 타이머 및 고려하지 않은 훨씬 더 많은 사용 사례를 포괄하는 사용자 정의 후크를 작성할 수 있습니다. 우리는 React 커뮤니티가 어떤 커스텀 훅을 만들어 낼지 기대됩니다.</target>
        </trans-unit>
        <trans-unit id="43bcb3dd583d6b2dd0d35900294f9bc74472de69" translate="yes" xml:space="preserve">
          <source>You can write to it from inside &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;useEffect&lt;/code&gt; 내부에서 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47255993d7f3732c79a6c98cd3fe5fc53875788f" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t opt into Concurrent Mode on a per-subtree basis. Instead, to opt in, you have to do it in the place where today you call &lt;code&gt;ReactDOM.render()&lt;/code&gt;.</source>
          <target state="translated">서브 트리별로 동시 모드를 선택할 수 없습니다. 대신, 선택하려면 오늘 &lt;code&gt;ReactDOM.render()&lt;/code&gt; 를 호출하는 위치에서 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1aa9c95956bb20366a3bf7354777516586cb672a" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="translated">You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</target>
        </trans-unit>
        <trans-unit id="c32390cb7781d4c45dceb903ef23ef22e363cf1d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t use Hooks &lt;em&gt;inside&lt;/em&gt; of a class component, but you can definitely mix classes and function components with Hooks in a single tree. Whether a component is a class or a function that uses Hooks is an implementation detail of that component. In the longer term, we expect Hooks to be the primary way people write React components.</source>
          <target state="translated">클래스 구성 요소 &lt;em&gt;내&lt;/em&gt; 에서 후크를 사용할 수는 없지만 단일 트리에서 클래스와 함수 구성 요소를 후크와 확실히 혼합 할 수 있습니다. 컴포넌트가 클래스인지 후크를 사용하는 함수인지 여부는 해당 컴포넌트의 구현 세부 사항입니다. 장기적으로 우리는 후크가 사람들이 React 컴포넌트를 작성하는 주요 방법이 될 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="0dd0330331639f73df7bfd7107d5bd9297f8602e" translate="yes" xml:space="preserve">
          <source>You can, however, &lt;strong&gt;use the &lt;code&gt;ref&lt;/code&gt; attribute inside a function component&lt;/strong&gt; as long as you refer to a DOM element or a class component:</source>
          <target state="translated">그러나 DOM 요소 또는 클래스 구성 요소를 참조 &lt;strong&gt;하는 한 함수 구성 요소 내 &lt;/strong&gt;&lt;strong&gt;에서 &lt;code&gt;ref&lt;/code&gt; 속성을 사용할&lt;/strong&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f38342d82347d389f86bdf83fa1f0ab8b63d28a" translate="yes" xml:space="preserve">
          <source>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</source>
          <target state="translated">일반 표현식을 React 요소 유형으로 사용할 수 없습니다. 요소의 유형을 나타 내기 위해 일반 표현식을 사용하려면 먼저 대문자로 변수를 지정하십시오. 소품을 기반으로 다른 구성 요소를 렌더링하려고 할 때 종종 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33243c0a4126f37be4f3131649cc1eacea5c2f2f" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to replace callback refs in your components. They are slightly more flexible, so they will remain as an advanced feature.</source>
          <target state="translated">컴포넌트에서 콜백 참조를 교체 할 필요는 없습니다. 약간 더 유연하므로 고급 기능으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea32ee627ff275bafe9ffb6dfbbc18214bc629f" translate="yes" xml:space="preserve">
          <source>You have to be careful about the meaning of &lt;code&gt;this&lt;/code&gt; in JSX callbacks. In JavaScript, class methods are not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;bound&lt;/a&gt; by default. If you forget to bind &lt;code&gt;this.handleClick&lt;/code&gt; and pass it to &lt;code&gt;onClick&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; when the function is actually called.</source>
          <target state="translated">JSX 콜백에서 &lt;code&gt;this&lt;/code&gt; 의 의미에주의해야합니다 . JavaScript에서 클래스 메소드는 기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;바인드&lt;/a&gt; 되지 않습니다 . 당신이 결합하는 것을 잊지 경우 &lt;code&gt;this.handleClick&lt;/code&gt; 을 하고에 전달할 &lt;code&gt;onClick&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 됩니다 &lt;code&gt;undefined&lt;/code&gt; 함수가 실제로 호출 될 때.</target>
        </trans-unit>
        <trans-unit id="127ac3f6dd7ddcb0012f37436e79376815c0bff1" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed any expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="translated">중괄호 &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;로 묶어 표현을 JSX&lt;/a&gt; 에 포함시킬 수 있습니다 . 이것은 자바 스크립트의 논리가 포함 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 의 연산자를. 조건부로 요소를 포함하는 데 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="329bb2ebce4c30c002ff2d23c58926794b4e569e" translate="yes" xml:space="preserve">
          <source>You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</source>
          <target state="translated">You may &lt;a href=&quot;introducing-jsx#embedding-expressions-in-jsx&quot;&gt;embed expressions in JSX&lt;/a&gt; by wrapping them in curly braces. This includes the JavaScript logical &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator. It can be handy for conditionally including an element:</target>
        </trans-unit>
        <trans-unit id="42a0cc95c37e0601bd484fc3858b0de8b575529a" translate="yes" xml:space="preserve">
          <source>You may also use curly braces to embed a JavaScript expression in an attribute:</source>
          <target state="translated">중괄호를 사용하여 속성에 JavaScript 표현식을 포함시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d89345f3ccb99c4b8cb79403d5d95c6c80c7c2" translate="yes" xml:space="preserve">
          <source>You may also use custom attributes as long as they&amp;rsquo;re fully lowercase.</source>
          <target state="translated">완전히 소문자 인 한 맞춤 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="75904665efa8694a25758036e4a724ac6e5801a8" translate="yes" xml:space="preserve">
          <source>You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Next. &lt;strong&gt;We do not guarantee any stability between Experimental releases.&lt;/strong&gt;</source>
          <target state="translated">Experimental에 대해 통합 테스트를 실행하는 것이 중요 할 수 있습니다. 이것은 당신에게 달려 있습니다. 그러나 실험은 다음보다 훨씬 안정적이지 않습니다. &lt;strong&gt;우리는 실험 릴리스 사이에 어떠한 안정성도 보장하지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d32c9e3fbc0fdfb2d416e23ef95ad43e35517849" translate="yes" xml:space="preserve">
          <source>You may have noticed similarities between HOCs and a pattern called &lt;strong&gt;container components&lt;/strong&gt;. Container components are part of a strategy of separating responsibility between high-level and low-level concerns. Containers manage things like subscriptions and state, and pass props to components that handle things like rendering UI. HOCs use containers as part of their implementation. You can think of HOCs as parameterized container component definitions.</source>
          <target state="translated">HOC와 &lt;strong&gt;컨테이너 구성 요소&lt;/strong&gt; 라는 패턴 사이의 유사성을 발견했을 수 있습니다 . 컨테이너 구성 요소는 상위 수준과 하위 수준의 우려를 구분하는 전략의 일부입니다. 컨테이너는 구독 및 상태와 같은 것을 관리하고 렌더링 UI와 같은 것을 처리하는 구성 요소에 소품을 전달합니다. HOC는 컨테이너를 구현의 일부로 사용합니다. HOC를 매개 변수화 된 컨테이너 구성 요소 정의로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fc1bfd2853f4054b7a51c82c1449e76256a431" translate="yes" xml:space="preserve">
          <source>You may optionally pass an object as the first argument to &lt;code&gt;setState()&lt;/code&gt; instead of a function:</source>
          <target state="translated">선택적 으로 함수 대신 객체를 &lt;code&gt;setState()&lt;/code&gt; 의 첫 번째 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee6c85272ea4b9d75ad324a8fc559394991e1935" translate="yes" xml:space="preserve">
          <source>You may use a different pattern, but keep in mind that we want to execute the cleanup &lt;em&gt;even if a test fails&lt;/em&gt;. Otherwise, tests can become &amp;ldquo;leaky&amp;rdquo;, and one test can change the behavior of another test. That makes them difficult to debug.</source>
          <target state="translated">다른 패턴을 사용할 수도 있지만 &lt;em&gt;테스트가 실패하더라도&lt;/em&gt; 정리를 실행하려고 &lt;em&gt;합니다&lt;/em&gt; . 그렇지 않으면 테스트가 &quot;누설&quot;상태가되고 한 테스트에서 다른 테스트의 동작이 변경 될 수 있습니다. 따라서 디버그하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="6c68df6de15e5de9ad7a0e61d3aae233a125ac08" translate="yes" xml:space="preserve">
          <source>You may use quotes to specify string literals as attributes:</source>
          <target state="translated">따옴표를 사용하여 문자열 리터럴을 속성으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c4ab2bcc9cce4e4f2f236a0689d5a30836ea67d" translate="yes" xml:space="preserve">
          <source>You might be curious how React knows which component &lt;code&gt;useState&lt;/code&gt; corresponds to since we&amp;rsquo;re not passing anything like &lt;code&gt;this&lt;/code&gt; back to React. We&amp;rsquo;ll answer &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;this question&lt;/a&gt; and many others in the FAQ section.</source>
          <target state="translated">반작용이있는 구성 요소를 알고 어떻게 당신은 호기심 수 있습니다 &lt;code&gt;useState&lt;/code&gt; 의 우리처럼 아무것도 통과하지 않을 이후에 해당 &lt;code&gt;this&lt;/code&gt; 반응 다시. FAQ 섹션 &lt;a href=&quot;hooks-faq#how-does-react-associate-hook-calls-with-components&quot;&gt;에서이 질문&lt;/a&gt; 과 다른 많은 질문에 대답 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="39c09441c3e7a9a767a8d286f34ad0922dfcdde2" translate="yes" xml:space="preserve">
          <source>You might be familiar with refs primarily as a way to &lt;a href=&quot;refs-and-the-dom&quot;&gt;access the DOM&lt;/a&gt;. If you pass a ref object to React with &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt;, React will set its &lt;code&gt;.current&lt;/code&gt; property to the corresponding DOM node whenever that node changes.</source>
          <target state="translated">&lt;a href=&quot;refs-and-the-dom&quot;&gt;DOM&lt;/a&gt; 에 액세스 하는 방법으로 주로 참조에 익숙 할 수 있습니다 . &lt;code&gt;&amp;lt;div ref={myRef} /&amp;gt;&lt;/code&gt; 하여 ref 객체를 React에 전달하면 React는 해당 노드가 변경 될 때마다 해당 &lt;code&gt;.current&lt;/code&gt; 속성을 해당 DOM 노드로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="843432bbccf637d5c3a245ab223ad53e54801d6b" translate="yes" xml:space="preserve">
          <source>You might be thinking that we&amp;rsquo;d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that &lt;code&gt;useEffect&lt;/code&gt; is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:</source>
          <target state="translated">정리를 수행하기 위해 별도의 효과가 필요하다고 생각할 수도 있습니다. 그러나 서브 스크립 션을 추가하고 제거하는 코드는 너무 밀접하게 관련되어 &lt;code&gt;useEffect&lt;/code&gt; 는이를 함께 유지하도록 설계되었습니다. 효과가 함수를 반환하면 정리할 때 React가 함수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="af3f101aa60ab2f4218f9c28b6ee51cac9e89fff" translate="yes" xml:space="preserve">
          <source>You might be wondering why we&amp;rsquo;re using a counter here instead of a more realistic example. This is to help us focus on the API while we&amp;rsquo;re still making our first steps with Hooks.</source>
          <target state="translated">더 현실적인 예제 대신 왜 카운터를 사용하는지 궁금 할 것입니다. 이것은 여전히 ​​Hooks를 사용하여 첫 번째 단계를 수행하는 동안 API에 집중하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="83ba6a9a4f28b7236b5b6943244a0b8d6c86dde5" translate="yes" xml:space="preserve">
          <source>You might be wondering: why is &lt;code&gt;useState&lt;/code&gt; not named &lt;code&gt;createState&lt;/code&gt; instead?</source>
          <target state="translated">궁금 할 수도 있습니다. &lt;code&gt;useState&lt;/code&gt; 가 대신 &lt;code&gt;createState&lt;/code&gt; 로 이름 지정된 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3be6e25b6d0f7c01938be3f1f55926afa3c29409" translate="yes" xml:space="preserve">
          <source>You might find using &lt;code&gt;act()&lt;/code&gt; directly a bit too verbose. To avoid some of the boilerplate, you could use a library like &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt;, whose helpers are wrapped with &lt;code&gt;act()&lt;/code&gt;.</source>
          <target state="translated">당신이 사용 찾을 수있는 &lt;code&gt;act()&lt;/code&gt; 직접 조금 너무 자세한. 상용구의 일부를 피하기 위해 헬퍼가 &lt;code&gt;act()&lt;/code&gt; 로 감싸 진 &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; 와 같은 라이브러리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0db33983cd7798b4c863f844b1e5e18fe94fdbe6" translate="yes" xml:space="preserve">
          <source>You might have noticed the square brackets when we declare a state variable:</source>
          <target state="translated">상태 변수를 선언 할 때 대괄호가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329e92de263dd0e71122a46b673d8f3a5c8c8351" translate="yes" xml:space="preserve">
          <source>You might have previously known these as &amp;ldquo;stateless components&amp;rdquo;. We&amp;rsquo;re now introducing the ability to use React state from these, so we prefer the name &amp;ldquo;function components&amp;rdquo;.</source>
          <target state="translated">이전에는 이러한 상태를 &quot;상태 비 저장 구성 요소&quot;라고했습니다. 우리는 이제 이것들로부터 React 상태를 사용하는 기능을 소개하고 있으므로&amp;ldquo;함수 컴포넌트&amp;rdquo;라는 이름을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="4ef4a753921a678c61c3979f95fe4cdf4be39d17" translate="yes" xml:space="preserve">
          <source>You might object that fetching &amp;ldquo;at the top level&amp;rdquo; like in this example is impractical. What are we going to do if we navigate to another profile&amp;rsquo;s page? We might want to fetch based on props. The answer to this is &lt;strong&gt;we want to start fetching in the event handlers instead&lt;/strong&gt;. Here is a simplified example of navigating between user&amp;rsquo;s pages:</source>
          <target state="translated">이 예제에서와 같이 &quot;최상위 수준에서&quot;가져 오기는 실용적이지 않을 수도 있습니다. 다른 프로필 페이지로 이동하면 어떻게해야합니까? 소품을 기반으로 가져오고 싶을 수도 있습니다. 이에 대한 답은 &lt;strong&gt;대신 이벤트 핸들러에서 페치를 시작하려고합니다&lt;/strong&gt; . 다음은 사용자 페이지를 탐색하는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="e076b28b9370ba50b790e58f9f840b591db7ff32" translate="yes" xml:space="preserve">
          <source>You should populate data with AJAX calls in the &lt;a href=&quot;react-component#mounting&quot;&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/a&gt; lifecycle method. This is so you can use &lt;code&gt;setState&lt;/code&gt; to update your component when the data is retrieved.</source>
          <target state="translated">&lt;a href=&quot;react-component#mounting&quot;&gt; &lt;code&gt;componentDidMount&lt;/code&gt; &lt;/a&gt; 라이프 사이클 메소드 에서 AJAX 호출로 데이터를 채워야합니다 . 데이터를 검색 할 때 &lt;code&gt;setState&lt;/code&gt; 를 사용하여 구성 요소를 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0100f35a274466dbd299b52916e0b9bb563005fd" translate="yes" xml:space="preserve">
          <source>You should see a message like:</source>
          <target state="translated">다음과 같은 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="13d510fce1888c91efd69e647dbd0b1304d066fb" translate="yes" xml:space="preserve">
          <source>You should use the File API to interact with the files. The following example shows how to create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref to the DOM node&lt;/a&gt; to access file(s) in a submit handler:</source>
          <target state="translated">파일과 상호 작용하려면 파일 API를 사용해야합니다. 다음 예제는 제출 핸들러에서 파일에 액세스 &lt;a href=&quot;refs-and-the-dom&quot;&gt;하기 위해 DOM 노드&lt;/a&gt; 에 대한 참조 를 작성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d1ca77292c866d9beccf3afb5cd22e409404eefd" translate="yes" xml:space="preserve">
          <source>You will have to provide any event property that you&amp;rsquo;re using in your component (e.g. keyCode, which, etc&amp;hellip;) as React is not creating any of these for you.</source>
          <target state="translated">React가 사용자를 위해 아무것도 생성하지 않으므로 컴포넌트에서 사용중인 이벤트 속성 (예 : keyCode 등)을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="38e40adba52fc6a8328c5cb7d32f1ed6f48158d5" translate="yes" xml:space="preserve">
          <source>You will need to have &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;window.document&lt;/code&gt; and &lt;code&gt;window.document.createElement&lt;/code&gt; globally available &lt;strong&gt;before&lt;/strong&gt; you import &lt;code&gt;React&lt;/code&gt;. Otherwise React will think it can&amp;rsquo;t access the DOM and methods like &lt;code&gt;setState&lt;/code&gt; won&amp;rsquo;t work.</source>
          <target state="translated">당신은 있어야합니다 &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;window.document&lt;/code&gt; 및 &lt;code&gt;window.document.createElement&lt;/code&gt; 는 전 세계적으로 사용할 수 &lt;strong&gt;전에&lt;/strong&gt; 가져올 &lt;code&gt;React&lt;/code&gt; . 그렇지 않으면 React는 DOM에 액세스 할 수 없다고 생각하고 &lt;code&gt;setState&lt;/code&gt; 와 같은 메소드 가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="178e11c227368aa687fcf840c5bb6cce64f8f141" translate="yes" xml:space="preserve">
          <source>You will not typically invoke &lt;code&gt;React.createFactory()&lt;/code&gt; directly if you are using JSX. See &lt;a href=&quot;react-without-jsx&quot;&gt;React Without JSX&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;React.createFactory()&lt;/code&gt; 를 사용하는 경우 일반적으로 React.createFactory ()를 직접 호출하지 않습니다 . 자세한 내용은 &lt;a href=&quot;react-without-jsx&quot;&gt;JSX없이 반응을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6c37686a4d152354398670fa644ad54c4e1c2e0" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see here that we have five components in our app. We&amp;rsquo;ve italicized the data each component represents.</source>
          <target state="translated">여기에 앱에 5 개의 구성 요소가 있음을 알 수 있습니다. 각 구성 요소가 나타내는 데이터를 기울임 꼴로 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="ca95950510b4946724893118d47847f0a2b910dc" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see this technique used in the &lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chenglou/react-motion&quot;&gt;react-motion&lt;/a&gt; API 에서이 기술이 사용되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1251760a9d7461170b9cdba14cf50e2f7d2632a4" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to a single child for a component. You may pass multiple children, or even have multiple separate &amp;ldquo;slots&amp;rdquo; for children, &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;as documented here&lt;/a&gt;:</source>
          <target state="translated">구성 요소의 단일 자식으로 제한되지 않습니다. &lt;a href=&quot;composition-vs-inheritance#containment&quot;&gt;여기에 설명 된대로&lt;/a&gt; 여러 자녀를 전달하거나 자녀를위한 별도의 여러 &quot;슬롯&quot;이있을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2b5019f33196f854492a20c611041c35f250ae6" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve likely performed data fetching, subscriptions, or manually changing the DOM from React components before. We call these operations &amp;ldquo;side effects&amp;rdquo; (or &amp;ldquo;effects&amp;rdquo; for short) because they can affect other components and can&amp;rsquo;t be done during rendering.</source>
          <target state="translated">데이터 가져 오기, 구독 또는 React 구성 요소에서 DOM을 수동으로 변경 한 적이있을 수 있습니다. 이러한 작업은 다른 구성 요소에 영향을 줄 수 있고 렌더링 중에 수행 할 수 없기 때문에 &quot;부작용&quot;(또는 &quot;효과&quot;)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9a73bce14cb5ed5814b4d3c8caccbf0a4c71d18f" translate="yes" xml:space="preserve">
          <source>Your bundles will end up looking a lot different than this.</source>
          <target state="translated">번들은 이것과 많이 다르게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce6353440854dcd821602f8c565c81d1de3f299a" translate="yes" xml:space="preserve">
          <source>Your code might use timer-based functions like &lt;code&gt;setTimeout&lt;/code&gt; to schedule more work in the future. In this example, a multiple choice panel waits for a selection and advances, timing out if a selection isn&amp;rsquo;t made in 5 seconds:</source>
          <target state="translated">코드는 &lt;code&gt;setTimeout&lt;/code&gt; 과 같은 타이머 기반 함수를 사용 하여 향후 더 많은 작업을 예약 할 수 있습니다. 이 예에서 다중 선택 패널은 선택을 기다렸다가 5 초 이내에 선택하지 않으면 시간이 초과됩니다.</target>
        </trans-unit>
        <trans-unit id="9b44d57e851b7cfb9edddaba0f27c8b365611372" translate="yes" xml:space="preserve">
          <source>Your event handlers will be passed instances of &lt;code&gt;SyntheticEvent&lt;/code&gt;, a cross-browser wrapper around the browser&amp;rsquo;s native event. It has the same interface as the browser&amp;rsquo;s native event, including &lt;code&gt;stopPropagation()&lt;/code&gt; and &lt;code&gt;preventDefault()&lt;/code&gt;, except the events work identically across all browsers.</source>
          <target state="translated">이벤트 핸들러는 브라우저의 기본 이벤트를 중심으로하는 브라우저 간 랩퍼 인 &lt;code&gt;SyntheticEvent&lt;/code&gt; 인스턴스를 전달합니다 . 이벤트가 모든 브라우저에서 동일하게 작동한다는 점을 제외하면 &lt;code&gt;stopPropagation()&lt;/code&gt; 및 &lt;code&gt;preventDefault()&lt;/code&gt; 포함하여 브라우저의 기본 이벤트와 동일한 인터페이스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="417ad6992902ba487e093b897d3f6d549a9842ce" translate="yes" xml:space="preserve">
          <source>Your first inclination may be to use refs to &amp;ldquo;make things happen&amp;rdquo; in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to &amp;ldquo;own&amp;rdquo; that state is at a higher level in the hierarchy. See the &lt;a href=&quot;lifting-state-up&quot;&gt;Lifting State Up&lt;/a&gt; guide for examples of this.</source>
          <target state="translated">첫 번째 성향은 앱에서 '일이 발생하도록'심판을 사용하는 것일 수 있습니다. 이 경우 잠시 시간을내어 구성 요소 계층에서 상태를 소유해야하는 위치에 대해보다 비판적으로 생각하십시오. 종종 해당 상태를 &quot;소유&quot;하는 적절한 장소가 계층 구조에서 더 높은 수준에 있다는 것이 분명해집니다. 이에 대한 예 는 &lt;a href=&quot;lifting-state-up&quot;&gt;Lifting State Up&lt;/a&gt; 가이드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e168dcadd81316b93e30e3fb63c119e3eacea3d" translate="yes" xml:space="preserve">
          <source>aXe, aXe-core and react-axe</source>
          <target state="translated">도끼, 도끼 코어 및 반응 도끼</target>
        </trans-unit>
        <trans-unit id="30044d924582132945f46916ec2d07125a58cf2d" translate="yes" xml:space="preserve">
          <source>act()</source>
          <target state="translated">act()</target>
        </trans-unit>
        <trans-unit id="ff492a83ee72d534e12a356ac58617fc5344b70b" translate="yes" xml:space="preserve">
          <source>at a Glance</source>
          <target state="translated">한눈에</target>
        </trans-unit>
        <trans-unit id="27d975804229db5d33e99922cefc38d130415317" translate="yes" xml:space="preserve">
          <source>can be compiled to this code that does not use JSX:</source>
          <target state="translated">JSX를 사용하지 않는이 코드로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e4aedce48faf384f3535ffeb842e9a0718a25c" translate="yes" xml:space="preserve">
          <source>checked</source>
          <target state="translated">checked</target>
        </trans-unit>
        <trans-unit id="d80a05355eb77272dccf26e73f9d554a520a954d" translate="yes" xml:space="preserve">
          <source>className</source>
          <target state="translated">className</target>
        </trans-unit>
        <trans-unit id="f1808e1fcdfb51765245f7ae10e6d0f7d45dfdb0" translate="yes" xml:space="preserve">
          <source>cloneElement()</source>
          <target state="translated">cloneElement()</target>
        </trans-unit>
        <trans-unit id="d2ac721e1714aa0c2ba51ae76a737a394508c705" translate="yes" xml:space="preserve">
          <source>compiles into:</source>
          <target state="translated">다음으로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="e04a959dd07839da3d76b649c2746a372ae67d26" translate="yes" xml:space="preserve">
          <source>componentDidCatch()</source>
          <target state="translated">componentDidCatch()</target>
        </trans-unit>
        <trans-unit id="4cbc3930cb5ae51bf4c7c376a47c4a0303cc508f" translate="yes" xml:space="preserve">
          <source>componentDidMount()</source>
          <target state="translated">componentDidMount()</target>
        </trans-unit>
        <trans-unit id="81560e4b9f7ed9f695cb560e570f84260f6da228" translate="yes" xml:space="preserve">
          <source>componentDidUpdate()</source>
          <target state="translated">componentDidUpdate()</target>
        </trans-unit>
        <trans-unit id="040d2c710c56b213bb8d9a190f9d819d99838912" translate="yes" xml:space="preserve">
          <source>componentWillUnmount()</source>
          <target state="translated">componentWillUnmount()</target>
        </trans-unit>
        <trans-unit id="a5cb5262d854a45e4891ceed1de0d0dce3abd1e6" translate="yes" xml:space="preserve">
          <source>constructor()</source>
          <target state="translated">constructor()</target>
        </trans-unit>
        <trans-unit id="6b181ca2ce1831814647e1033acd0415b7894d36" translate="yes" xml:space="preserve">
          <source>createBlockingRoot</source>
          <target state="translated">createBlockingRoot</target>
        </trans-unit>
        <trans-unit id="f4b3ab4f5c383ec52f890d704e0e8f5effedd508" translate="yes" xml:space="preserve">
          <source>createElement()</source>
          <target state="translated">createElement()</target>
        </trans-unit>
        <trans-unit id="6d39c1e12808130963fbdf6fe78aff2f7954e5cd" translate="yes" xml:space="preserve">
          <source>createFactory()</source>
          <target state="translated">createFactory()</target>
        </trans-unit>
        <trans-unit id="225f66482bb6fa2162c71f4678803312729ce679" translate="yes" xml:space="preserve">
          <source>createPortal()</source>
          <target state="translated">createPortal()</target>
        </trans-unit>
        <trans-unit id="3fa4909ead21a618529dabdaf33aa6c9589a71cb" translate="yes" xml:space="preserve">
          <source>createRoot</source>
          <target state="translated">createRoot</target>
        </trans-unit>
        <trans-unit id="b96f7c4dfd5ac22f73a862391a14b9ad9d087ae5" translate="yes" xml:space="preserve">
          <source>dangerouslySetInnerHTML</source>
          <target state="translated">dangerouslySetInnerHTML</target>
        </trans-unit>
        <trans-unit id="4ffa4d174c4a4c8d2e8354a953a93d148fccc03f" translate="yes" xml:space="preserve">
          <source>defaultProps</source>
          <target state="translated">defaultProps</target>
        </trans-unit>
        <trans-unit id="226e8ab97c399ef7e520a8c77ae9ce3fd60b449f" translate="yes" xml:space="preserve">
          <source>displayName</source>
          <target state="translated">displayName</target>
        </trans-unit>
        <trans-unit id="5c7cef6a6a6ef7a482a82974ea4726169eae6264" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jsx-a11y</source>
          <target state="translated">eslint-plugin-jsx-a11y</target>
        </trans-unit>
        <trans-unit id="c230c9b793507553af38b22847c967a1651daabd" translate="yes" xml:space="preserve">
          <source>findAllInRenderedTree()</source>
          <target state="translated">findAllInRenderedTree()</target>
        </trans-unit>
        <trans-unit id="7ebff84a87431408d85d2c3f89d84055a39bd086" translate="yes" xml:space="preserve">
          <source>findDOMNode</source>
          <target state="translated">findDOMNode</target>
        </trans-unit>
        <trans-unit id="d274d46accd6cdefe4324778fc78f215f1e4c91a" translate="yes" xml:space="preserve">
          <source>findDOMNode()</source>
          <target state="translated">findDOMNode()</target>
        </trans-unit>
        <trans-unit id="e9174cad96a72c7e0c1ad1cd53a888fb02ea7804" translate="yes" xml:space="preserve">
          <source>findRenderedComponentWithType()</source>
          <target state="translated">findRenderedComponentWithType()</target>
        </trans-unit>
        <trans-unit id="c9c73f42f55648fc38ef00e038ae1321d85fbc5d" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithClass()</source>
          <target state="translated">findRenderedDOMComponentWithClass()</target>
        </trans-unit>
        <trans-unit id="325c7573aec2c9a01bf497f8e01ea68e75fcfe2e" translate="yes" xml:space="preserve">
          <source>findRenderedDOMComponentWithTag()</source>
          <target state="translated">findRenderedDOMComponentWithTag()</target>
        </trans-unit>
        <trans-unit id="f634efed29f9466600dce13d06f22a65c4394c9c" translate="yes" xml:space="preserve">
          <source>forceUpdate()</source>
          <target state="translated">forceUpdate()</target>
        </trans-unit>
        <trans-unit id="48c0d6c8247cdebbadbfb27472c725be283719d3" translate="yes" xml:space="preserve">
          <source>getSnapshotBeforeUpdate()</source>
          <target state="translated">getSnapshotBeforeUpdate()</target>
        </trans-unit>
        <trans-unit id="9f9bed174e7ceb8dd32127ea809e17154176a0fe" translate="yes" xml:space="preserve">
          <source>htmlFor</source>
          <target state="translated">htmlFor</target>
        </trans-unit>
        <trans-unit id="2b70ee25b5685a847d42fd561cddbb0347240ffb" translate="yes" xml:space="preserve">
          <source>hydrate()</source>
          <target state="translated">hydrate()</target>
        </trans-unit>
        <trans-unit id="e607f2c2f3a88ee9efc521cc3eb5a8db451bdb56" translate="yes" xml:space="preserve">
          <source>is slightly different in React:</source>
          <target state="translated">React에서 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="38913b96ec33406bdc107dc1a67355715c31b42c" translate="yes" xml:space="preserve">
          <source>isCompositeComponent()</source>
          <target state="translated">isCompositeComponent()</target>
        </trans-unit>
        <trans-unit id="2d0f44b4556319617244d8e3c0101188b4e9d334" translate="yes" xml:space="preserve">
          <source>isCompositeComponentWithType()</source>
          <target state="translated">isCompositeComponentWithType()</target>
        </trans-unit>
        <trans-unit id="e5db90c47987aedfcd4e6b88a002a4d096541964" translate="yes" xml:space="preserve">
          <source>isDOMComponent()</source>
          <target state="translated">isDOMComponent()</target>
        </trans-unit>
        <trans-unit id="1ff3f8d3e07c1aa64975ff6c37b27b245fec7a06" translate="yes" xml:space="preserve">
          <source>isElement()</source>
          <target state="translated">isElement()</target>
        </trans-unit>
        <trans-unit id="cda9aaf24e1c261b047f9583d068a59d6146a5c1" translate="yes" xml:space="preserve">
          <source>isElementOfType()</source>
          <target state="translated">isElementOfType()</target>
        </trans-unit>
        <trans-unit id="8d189028ca88af62009de3301ce91b75ee91f71d" translate="yes" xml:space="preserve">
          <source>isValidElement()</source>
          <target state="translated">isValidElement()</target>
        </trans-unit>
        <trans-unit id="031703ceb37d4e467e3b4873c48829fe96e8be85" translate="yes" xml:space="preserve">
          <source>mockComponent()</source>
          <target state="translated">mockComponent()</target>
        </trans-unit>
        <trans-unit id="6346291a5b44a7e5edb37e6ad83b5d6d14b97973" translate="yes" xml:space="preserve">
          <source>of React Terms</source>
          <target state="translated">반응 조건</target>
        </trans-unit>
        <trans-unit id="7fe3c585b87fdfd619db73b230eb60673928e282" translate="yes" xml:space="preserve">
          <source>onBlur</source>
          <target state="translated">onBlur</target>
        </trans-unit>
        <trans-unit id="59897a9118de38c1f4300bf9b771b3280b32c69d" translate="yes" xml:space="preserve">
          <source>onChange</source>
          <target state="translated">onChange</target>
        </trans-unit>
        <trans-unit id="33070cf900f7cbaea369fd3262ef1707dbf7b576" translate="yes" xml:space="preserve">
          <source>onFocus</source>
          <target state="translated">onFocus</target>
        </trans-unit>
        <trans-unit id="53cf26e91fa509e97555428c86572d99948c5513" translate="yes" xml:space="preserve">
          <source>or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="aa60968734f4f4d402439b0e033649c02834cb03" translate="yes" xml:space="preserve">
          <source>props</source>
          <target state="translated">props</target>
        </trans-unit>
        <trans-unit id="a51a890001a811c94e4fda62e34296855ddfb140" translate="yes" xml:space="preserve">
          <source>props.children</source>
          <target state="translated">props.children</target>
        </trans-unit>
        <trans-unit id="4a8d7ba2ca12dcaf16af003dba0a21a54145f550" translate="yes" xml:space="preserve">
          <source>render()</source>
          <target state="translated">render()</target>
        </trans-unit>
        <trans-unit id="e30b6dae1ced5ea662137753850941aae38407fb" translate="yes" xml:space="preserve">
          <source>renderIntoDocument()</source>
          <target state="translated">renderIntoDocument()</target>
        </trans-unit>
        <trans-unit id="3eeeddfe744d288f2a7cc0b1b5d27869afa633bd" translate="yes" xml:space="preserve">
          <source>renderToNodeStream()</source>
          <target state="translated">renderToNodeStream()</target>
        </trans-unit>
        <trans-unit id="5fb112b72758bd2b1c27c4056814291d3fc57875" translate="yes" xml:space="preserve">
          <source>renderToStaticMarkup()</source>
          <target state="translated">renderToStaticMarkup()</target>
        </trans-unit>
        <trans-unit id="5371d3d06de40c111adfa63626996723a8574fd0" translate="yes" xml:space="preserve">
          <source>renderToStaticNodeStream()</source>
          <target state="translated">renderToStaticNodeStream()</target>
        </trans-unit>
        <trans-unit id="a1e2c92c6bbcd7c635f3fc1dec2fadb6e5d28ee3" translate="yes" xml:space="preserve">
          <source>renderToString()</source>
          <target state="translated">renderToString()</target>
        </trans-unit>
        <trans-unit id="d73fd7553e41429de67252dc32008ee31e7dc96a" translate="yes" xml:space="preserve">
          <source>requestAnimationFrame</source>
          <target state="translated">requestAnimationFrame</target>
        </trans-unit>
        <trans-unit id="5fef477110a77ece862b497872e19102ce62d1d3" translate="yes" xml:space="preserve">
          <source>results in a &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">A의 결과를 &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; 의 출력 :</target>
        </trans-unit>
        <trans-unit id="b93c8e43f94949f681de9d694b201cebad28cd67" translate="yes" xml:space="preserve">
          <source>scryRenderedComponentsWithType()</source>
          <target state="translated">scryRenderedComponentsWithType()</target>
        </trans-unit>
        <trans-unit id="aebb7ccb3b46e0525adf0006807bf12321942ae4" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithClass()</source>
          <target state="translated">scryRenderedDOMComponentsWithClass()</target>
        </trans-unit>
        <trans-unit id="611b9475f3c4c5708aa2d088c24cb54bdd8d5eac" translate="yes" xml:space="preserve">
          <source>scryRenderedDOMComponentsWithTag()</source>
          <target state="translated">scryRenderedDOMComponentsWithTag()</target>
        </trans-unit>
        <trans-unit id="835f3b50e33719422d6faca2d01d99417afea46b" translate="yes" xml:space="preserve">
          <source>selected</source>
          <target state="translated">selected</target>
        </trans-unit>
        <trans-unit id="612b427e6504ad2778fa6e4e5081fa2cfdfe48b0" translate="yes" xml:space="preserve">
          <source>setState()</source>
          <target state="translated">setState()</target>
        </trans-unit>
        <trans-unit id="ce05a867c6397422a23f2df9528118a63884828f" translate="yes" xml:space="preserve">
          <source>shallowRenderer.getRenderOutput()</source>
          <target state="translated">shallowRenderer.getRenderOutput()</target>
        </trans-unit>
        <trans-unit id="d9683e6218d9950582c31235c789381795b9a6a7" translate="yes" xml:space="preserve">
          <source>shallowRenderer.render()</source>
          <target state="translated">shallowRenderer.render()</target>
        </trans-unit>
        <trans-unit id="470481efa1f485463319f0673bb633affe7ebd19" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate In Action</source>
          <target state="translated">shouldComponentUpdate 작동 중</target>
        </trans-unit>
        <trans-unit id="912f2ad5b0b4be590e85fc8aaad17da9d9b8bae5" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate()</source>
          <target state="translated">shouldComponentUpdate()</target>
        </trans-unit>
        <trans-unit id="aa4a5f8125f234182e2dea92805afdfb747a86be" translate="yes" xml:space="preserve">
          <source>state</source>
          <target state="translated">state</target>
        </trans-unit>
        <trans-unit id="6f21255dfbf5dc0666959c7a4d5ec0f7cb311c84" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromError()</source>
          <target state="translated">정적 getDerivedStateFromError ()</target>
        </trans-unit>
        <trans-unit id="a8a1daf7425520001825ba5ee0f62272e1942058" translate="yes" xml:space="preserve">
          <source>static getDerivedStateFromProps()</source>
          <target state="translated">정적 getDerivedStateFromProps ()</target>
        </trans-unit>
        <trans-unit id="26ec8d00fb6b55466b3a115f1d559422a7fa7aac" translate="yes" xml:space="preserve">
          <source>style</source>
          <target state="translated">style</target>
        </trans-unit>
        <trans-unit id="ec9c9f0131a2a03ef9592dbbf5b6f941e6f067f8" translate="yes" xml:space="preserve">
          <source>suppressContentEditableWarning</source>
          <target state="translated">suppressContentEditableWarning</target>
        </trans-unit>
        <trans-unit id="8c4c14e070b03ee334f69ae4652b54634b91962e" translate="yes" xml:space="preserve">
          <source>suppressHydrationWarning</source>
          <target state="translated">suppressHydrationWarning</target>
        </trans-unit>
        <trans-unit id="c01f3c9d4dbfd20df94186b9bedc6b8ba8cdbabf" translate="yes" xml:space="preserve">
          <source>testInstance.children</source>
          <target state="translated">testInstance.children</target>
        </trans-unit>
        <trans-unit id="4c915ddcb2a485beede7f30f0a39993ca3eaccfb" translate="yes" xml:space="preserve">
          <source>testInstance.find()</source>
          <target state="translated">testInstance.find()</target>
        </trans-unit>
        <trans-unit id="ef7541e9aa2a73eedf7685db30d9d4b2a52e1346" translate="yes" xml:space="preserve">
          <source>testInstance.findAll()</source>
          <target state="translated">testInstance.findAll()</target>
        </trans-unit>
        <trans-unit id="a18a2aa20f4ff41cfbe29515880a5420b8cb7caf" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByProps()</source>
          <target state="translated">testInstance.findAllByProps()</target>
        </trans-unit>
        <trans-unit id="0563b370095c727ef03938afce647600d255d300" translate="yes" xml:space="preserve">
          <source>testInstance.findAllByType()</source>
          <target state="translated">testInstance.findAllByType()</target>
        </trans-unit>
        <trans-unit id="a80d58798674cc0d4d16f85d332446b150cf2508" translate="yes" xml:space="preserve">
          <source>testInstance.findByProps()</source>
          <target state="translated">testInstance.findByProps()</target>
        </trans-unit>
        <trans-unit id="e6726e57ddc7239270aed690310887f17c4ed5a0" translate="yes" xml:space="preserve">
          <source>testInstance.findByType()</source>
          <target state="translated">testInstance.findByType()</target>
        </trans-unit>
        <trans-unit id="24e32ceafa0199c0e634d8a09f601bf4c75dc6ea" translate="yes" xml:space="preserve">
          <source>testInstance.instance</source>
          <target state="translated">testInstance.instance</target>
        </trans-unit>
        <trans-unit id="6fc49889f4c4cf74fb4892e3812cb5238efc37af" translate="yes" xml:space="preserve">
          <source>testInstance.parent</source>
          <target state="translated">testInstance.parent</target>
        </trans-unit>
        <trans-unit id="991a6b588a17504199fd15ee9a6f4d447180a3a0" translate="yes" xml:space="preserve">
          <source>testInstance.props</source>
          <target state="translated">testInstance.props</target>
        </trans-unit>
        <trans-unit id="59239c90818698c1ff479fb8f72464b55fc9ae0e" translate="yes" xml:space="preserve">
          <source>testInstance.type</source>
          <target state="translated">testInstance.type</target>
        </trans-unit>
        <trans-unit id="9ba87352e263ec108b8cb84015e69b21ec153df3" translate="yes" xml:space="preserve">
          <source>testRenderer.getInstance()</source>
          <target state="translated">testRenderer.getInstance()</target>
        </trans-unit>
        <trans-unit id="321ae1cad7565cf2c094665daccc3a626e875bf6" translate="yes" xml:space="preserve">
          <source>testRenderer.root</source>
          <target state="translated">testRenderer.root</target>
        </trans-unit>
        <trans-unit id="cacb1190f356919021ffa862e4827f65254f8342" translate="yes" xml:space="preserve">
          <source>testRenderer.toJSON()</source>
          <target state="translated">testRenderer.toJSON()</target>
        </trans-unit>
        <trans-unit id="838b9c04859c929c640cb6679ed6e88dee0ad2e2" translate="yes" xml:space="preserve">
          <source>testRenderer.toTree()</source>
          <target state="translated">testRenderer.toTree()</target>
        </trans-unit>
        <trans-unit id="3d1450103c3366cf9be062ef311d80a4b548a39f" translate="yes" xml:space="preserve">
          <source>testRenderer.unmount()</source>
          <target state="translated">testRenderer.unmount()</target>
        </trans-unit>
        <trans-unit id="c93dde1e0b286d37d40077ae8c79ff09c3a8b28d" translate="yes" xml:space="preserve">
          <source>testRenderer.update()</source>
          <target state="translated">testRenderer.update()</target>
        </trans-unit>
        <trans-unit id="2d1c22c80fa325ca4df815d1ebdc1147925b2af3" translate="yes" xml:space="preserve">
          <source>unmountComponentAtNode()</source>
          <target state="translated">unmountComponentAtNode()</target>
        </trans-unit>
        <trans-unit id="0bedb35c3b8a80ac3f44b9bac14dfbc4e37efdb9" translate="yes" xml:space="preserve">
          <source>useCallback</source>
          <target state="translated">useCallback</target>
        </trans-unit>
        <trans-unit id="eae3826cdf2f6c64c219ecbd30dd771505bb87ed" translate="yes" xml:space="preserve">
          <source>useContext</source>
          <target state="translated">useContext</target>
        </trans-unit>
        <trans-unit id="8231dd7a518591bf2d9d957972cf313c1109e75b" translate="yes" xml:space="preserve">
          <source>useDebugValue</source>
          <target state="translated">useDebugValue</target>
        </trans-unit>
        <trans-unit id="3e0fe2934c5acc6440f9c9169e5d9a241b6d23cf" translate="yes" xml:space="preserve">
          <source>useDeferredValue</source>
          <target state="translated">useDeferredValue</target>
        </trans-unit>
        <trans-unit id="b70d205ec49487a219eb853fe1054028bf43991e" translate="yes" xml:space="preserve">
          <source>useDeferredValue Config</source>
          <target state="translated">useDeferredValue 구성</target>
        </trans-unit>
        <trans-unit id="26c55908ffcc066654803d696c358e2631cf940d" translate="yes" xml:space="preserve">
          <source>useEffect</source>
          <target state="translated">useEffect</target>
        </trans-unit>
        <trans-unit id="45040bb8abbff5eebf6ea2143e010c489b1650bb" translate="yes" xml:space="preserve">
          <source>useImperativeHandle</source>
          <target state="translated">useImperativeHandle</target>
        </trans-unit>
        <trans-unit id="babcde59d67ee82a21532cbed73f4914eeae6430" translate="yes" xml:space="preserve">
          <source>useLayoutEffect</source>
          <target state="translated">useLayoutEffect</target>
        </trans-unit>
        <trans-unit id="7134ae428d908b7a4b3d2527d83ec7a81d55f99d" translate="yes" xml:space="preserve">
          <source>useMemo</source>
          <target state="translated">useMemo</target>
        </trans-unit>
        <trans-unit id="aba72ff13cf2cb2f8078b149e16a9774c992fe86" translate="yes" xml:space="preserve">
          <source>useReducer</source>
          <target state="translated">useReducer</target>
        </trans-unit>
        <trans-unit id="17ab3e5a1cb289c329720c8fd155c9bc8f22bedc" translate="yes" xml:space="preserve">
          <source>useRef</source>
          <target state="translated">useRef</target>
        </trans-unit>
        <trans-unit id="7aa25205d04ad57a2b7896eb24dd7f3407d332cf" translate="yes" xml:space="preserve">
          <source>useState</source>
          <target state="translated">useState</target>
        </trans-unit>
        <trans-unit id="d7705f0ea90572940d0eb8f6df4eeb064570303d" translate="yes" xml:space="preserve">
          <source>useTransition</source>
          <target state="translated">useTransition</target>
        </trans-unit>
        <trans-unit id="d1eb6757e6abcda4059f5f0fdd80f7ca6d09ab3b" translate="yes" xml:space="preserve">
          <source>useTransition Config</source>
          <target state="translated">전환 구성 사용</target>
        </trans-unit>
        <trans-unit id="f32b67c7e26342af42efabc674d441dca0a281c5" translate="yes" xml:space="preserve">
          <source>value</source>
          <target state="translated">value</target>
        </trans-unit>
        <trans-unit id="057b6197438cfa301937d3f5cb47577adb242a9e" translate="yes" xml:space="preserve">
          <source>webpack</source>
          <target state="translated">webpack</target>
        </trans-unit>
        <trans-unit id="7ce83ec9cfed7121529d2fe247b4421dd66a5342" translate="yes" xml:space="preserve">
          <source>which results in a correct &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; output of:</source>
          <target state="translated">올바른 &lt;code&gt;&amp;lt;Table /&amp;gt;&lt;/code&gt; 출력 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aca8ac649e8becdb6a0f2276dad67b03cc039c67" translate="yes" xml:space="preserve">
          <source>⚡️ Effect Hook</source>
          <target state="translated">⚡️ 효과 후크</target>
        </trans-unit>
        <trans-unit id="1cee944946bff8d51e351ab4c7bd42a5de041a84" translate="yes" xml:space="preserve">
          <source>✅</source>
          <target state="translated">✅</target>
        </trans-unit>
        <trans-unit id="f3c3656b9154abf44c13c92e6fda9c4ec21209f2" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from React function components.</source>
          <target state="translated">Re React 기능 컴포넌트의 호출 후크.</target>
        </trans-unit>
        <trans-unit id="17d726472261fbbf511f74b762b9ac0c2abbd8e9" translate="yes" xml:space="preserve">
          <source>✅ Call Hooks from custom Hooks (we&amp;rsquo;ll learn about them &lt;a href=&quot;hooks-custom&quot;&gt;on the next page&lt;/a&gt;).</source>
          <target state="translated">custom 사용자 정의 후크에서 후크를 호출 &lt;a href=&quot;hooks-custom&quot;&gt;합니다 (다음 페이지에서 이에&lt;/a&gt; 대해 알아볼 것 입니다 ).</target>
        </trans-unit>
        <trans-unit id="05eb764599eda96ea06ff7639bc59541f5e05465" translate="yes" xml:space="preserve">
          <source>✌️ Rules of Hooks</source>
          <target state="translated">훅의 규칙</target>
        </trans-unit>
        <trans-unit id="45c8b34a57dcfe0d9f8bd262c7212971fccdb70c" translate="yes" xml:space="preserve">
          <source>💡 Building Your Own Hooks</source>
          <target state="translated">💡 자신 만의 고리 만들기</target>
        </trans-unit>
        <trans-unit id="aee90788022779419adf70a0034f4341d4663fc9" translate="yes" xml:space="preserve">
          <source>📌 State Hook</source>
          <target state="translated">📌 상태 후크</target>
        </trans-unit>
        <trans-unit id="466bf681aeece7094a8988a08d9ebde47be027ac" translate="yes" xml:space="preserve">
          <source>🔌 Other Hooks</source>
          <target state="translated">🔌 기타 훅</target>
        </trans-unit>
        <trans-unit id="1fee3b4a52f8bbba1ae107f01184ad871cfe4a4b" translate="yes" xml:space="preserve">
          <source>🚫</source>
          <target state="translated">🚫</target>
        </trans-unit>
        <trans-unit id="982828f9c89097fe661e44f5d2fe2056691fa614" translate="yes" xml:space="preserve">
          <source>🚫*</source>
          <target state="translated">🚫*</target>
        </trans-unit>
        <trans-unit id="9cc8c9733dba90ff1738546ec90ea16e4ef8489f" translate="yes" xml:space="preserve">
          <source>🚫**</source>
          <target state="translated">🚫**</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
