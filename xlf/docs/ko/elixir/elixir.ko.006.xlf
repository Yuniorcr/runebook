<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="f248a387f0f37e77ff666c2a85a59f7074c24d85" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;@deprecated&lt;/code&gt; only supports functions and macros. However you can use the &lt;code&gt;:deprecated&lt;/code&gt; key in the annotation metadata to annotate the docs of modules, types and callbacks too.</source>
          <target state="translated">현재 &lt;code&gt;@deprecated&lt;/code&gt; 는 함수와 매크로 만 지원합니다. 그러나 주석 메타 데이터에서 &lt;code&gt;:deprecated&lt;/code&gt; 키를 사용하여 모듈, 유형 및 콜백 문서에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f90102aa9d37408ac2a331660c80b3de845ceb" translate="yes" xml:space="preserve">
          <source>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</source>
          <target state="translated">현재는 Elixir에서 달력 동작의 유형과 최소 구현을 정의합니다. Elixir의 캘린더 기능의 목표는 완전한 기능을 갖춘 datetime API 대신 상호 운용성을위한 기반을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58e947fb9b58beb32c0020272eaa3d95ced9ee44" translate="yes" xml:space="preserve">
          <source>Currently the only accepted PID is &lt;code&gt;self()&lt;/code&gt;.</source>
          <target state="translated">현재 허용되는 유일한 PID는 &lt;code&gt;self()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f26076c7ac35014e638bc9d9a7df511fa73b4d" translate="yes" xml:space="preserve">
          <source>Currently we have two tests tagged with &lt;code&gt;@tag :distributed&lt;/code&gt;. The &amp;ldquo;server interaction&amp;rdquo; test in &lt;code&gt;KVServerTest&lt;/code&gt;, and the &amp;ldquo;route requests across nodes&amp;rdquo; in &lt;code&gt;KV.RouterTest&lt;/code&gt;. Both tests are failing since they require a routing table, which is currently empty.</source>
          <target state="translated">현재 &lt;code&gt;@tag :distributed&lt;/code&gt; 태그가있는 두 가지 테스트가 있습니다 . 의 &quot;서버 상호 작용&quot;테스트 &lt;code&gt;KVServerTest&lt;/code&gt; 과의 &quot;노드에서 요청을 라우팅&quot; &lt;code&gt;KV.RouterTest&lt;/code&gt; . 현재 비어있는 라우팅 테이블이 필요하므로 두 테스트 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fb478f5ec7bb7da049009c9e3df88349c2f53b74" translate="yes" xml:space="preserve">
          <source>Currently, there is no official way to cross-compile a release from one target triple to another, due to the complexities involved in the process.</source>
          <target state="translated">현재 프로세스와 관련된 복잡성으로 인해 하나의 타겟 트리플에서 다른 타겟으로 릴리스를 크로스 컴파일하는 공식적인 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bdaaebe2bbb603df00e4573b0900ccd99aa7d09" translate="yes" xml:space="preserve">
          <source>Custom Sigils</source>
          <target state="translated">맞춤형시길</target>
        </trans-unit>
        <trans-unit id="d797cab8a29cd6c10dc9372d1ab9213b989caf7f" translate="yes" xml:space="preserve">
          <source>Custom and overridden operators</source>
          <target state="translated">맞춤형 및 재정의 된 연산자</target>
        </trans-unit>
        <trans-unit id="00146f5b748062fe67c9600ecfcdf444284e0bcf" translate="yes" xml:space="preserve">
          <source>Custom attributes</source>
          <target state="translated">맞춤 속성</target>
        </trans-unit>
        <trans-unit id="e3fd71a31afaaf057b0fedc28ba72336f1780a64" translate="yes" xml:space="preserve">
          <source>Custom backends</source>
          <target state="translated">커스텀 백엔드</target>
        </trans-unit>
        <trans-unit id="abe70270d1f6e2920fe2d28c23289b5295fb962a" translate="yes" xml:space="preserve">
          <source>Custom configuration</source>
          <target state="translated">맞춤 구성</target>
        </trans-unit>
        <trans-unit id="170bc5dc5f750c41d4def27ed27eed6bf3c468fb" translate="yes" xml:space="preserve">
          <source>Custom editors are supported by using the &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; notations, for example:</source>
          <target state="translated">사용자 정의 편집기는 다음 과 같이 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 표기법 을 사용하여 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="642fb7c499e4524f98e2922e90ae2a2b071cfd52" translate="yes" xml:space="preserve">
          <source>Custom formatting</source>
          <target state="translated">맞춤 형식</target>
        </trans-unit>
        <trans-unit id="cfa121c3915c8b4ef6e8270f4ee6bf76b09bdab9" translate="yes" xml:space="preserve">
          <source>Custom patterns and guards expressions</source>
          <target state="translated">사용자 정의 패턴 및 가드 표현식</target>
        </trans-unit>
        <trans-unit id="8eb31d3e78f5111c059041eed039c75877655487" translate="yes" xml:space="preserve">
          <source>Custom sigils</source>
          <target state="translated">맞춤형시길</target>
        </trans-unit>
        <trans-unit id="39876974b7f78aa10c505abd0ccf4a46df612fca" translate="yes" xml:space="preserve">
          <source>Custom types defined through &lt;code&gt;@type&lt;/code&gt; are exported and are available outside the module they&amp;rsquo;re defined in:</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; 을 통해 정의 된 사용자 정의 유형 은 내보내지며 정의 된 모듈 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b447a4b2b4a5635d3f0dd6f81cbcc0d90e8e4a6d" translate="yes" xml:space="preserve">
          <source>Custom types defined through &lt;code&gt;@type&lt;/code&gt; are exported and available outside the module they&amp;rsquo;re defined in:</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; 을 통해 정의 된 사용자 정의 유형 은 다음에 정의 된 모듈 외부에서 내보내고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="a43ab69a51d511753170a537818f222e76faeaa7" translate="yes" xml:space="preserve">
          <source>Customization and configuration summary</source>
          <target state="translated">사용자 정의 및 구성 요약</target>
        </trans-unit>
        <trans-unit id="8b25d03b9dabe02b1fafe8ede605cce72a76c6c5" translate="yes" xml:space="preserve">
          <source>Customization per environment can be done by accessing &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;the &lt;code&gt;Mix.env&lt;/code&gt; function&lt;/a&gt; in your &lt;code&gt;mix.exs&lt;/code&gt; file, which returns the current environment as an atom. That&amp;rsquo;s what we have used in the &lt;code&gt;:start_permanent&lt;/code&gt; options:</source>
          <target state="translated">현재 환경을 원자로 리턴하는 &lt;code&gt;mix.exs&lt;/code&gt; 파일 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;의 &lt;code&gt;Mix.env&lt;/code&gt; 함수&lt;/a&gt; 에 액세스 하여 환경 별 사용자 정의를 수행 할 수 있습니다 . 이것이 우리가 &lt;code&gt;:start_permanent&lt;/code&gt; 옵션 에서 사용한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="6908397a2d8b0784b2ec70f0d5374964dc182a77" translate="yes" xml:space="preserve">
          <source>Daemon mode (Unix-like)</source>
          <target state="translated">데몬 모드 (유닉스 계열)</target>
        </trans-unit>
        <trans-unit id="303c85db56e6f90f1fcaafbed47e91067f22fbe9" translate="yes" xml:space="preserve">
          <source>Data structures</source>
          <target state="translated">데이터 구조</target>
        </trans-unit>
        <trans-unit id="696ae3d17016ea7046f1ce357ae0b1f6103499a3" translate="yes" xml:space="preserve">
          <source>Data structures such as lists, tuples, and binaries are marked respectively by the delimiters &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;{...}&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;. Each element is separated by comma. A trailing comma is also allowed, such as in &lt;code&gt;[1, 2, 3,]&lt;/code&gt;.</source>
          <target state="translated">목록, 튜플 및 이진과 같은 데이터 구조는 각각 구분 기호 &lt;code&gt;[...]&lt;/code&gt; , &lt;code&gt;{...}&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; 로 표시 됩니다. 각 요소는 쉼표로 구분됩니다. &lt;code&gt;[1, 2, 3,]&lt;/code&gt; 과 같이 후행 쉼표도 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">자료형</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="904c0db9491168bf7b0f96a8127a1e2e956e54ec" translate="yes" xml:space="preserve">
          <source>Date.Range</source>
          <target state="translated">Date.Range</target>
        </trans-unit>
        <trans-unit id="f1e5baf5ecc3589631088c40cbdd43061976ed8f" translate="yes" xml:space="preserve">
          <source>DateTime</source>
          <target state="translated">DateTime</target>
        </trans-unit>
        <trans-unit id="067497ecd979a531adeb039b5c57048e6702a8f2" translate="yes" xml:space="preserve">
          <source>Day of the month</source>
          <target state="translated">이달의 날</target>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="translated">요일</target>
        </trans-unit>
        <trans-unit id="7c9881c0cb27c6197626d060644aab99eb05aa54" translate="yes" xml:space="preserve">
          <source>Day of the year</source>
          <target state="translated">올해의 날</target>
        </trans-unit>
        <trans-unit id="d0c32ae37c8ec0c5b70c6fbada27ade3b4484def" translate="yes" xml:space="preserve">
          <source>Debug options supported by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수가 지원하는 디버그 옵션</target>
        </trans-unit>
        <trans-unit id="3dea78e2b42ff6c53cdfe32a0caf66a693083f61" translate="yes" xml:space="preserve">
          <source>Debugger</source>
          <target state="translated">Debugger</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="4dbfbf2c1ca5c9cbf7ff86eebf9f1e60dfaae3c2" translate="yes" xml:space="preserve">
          <source>Debugging with the :sys module</source>
          <target state="translated">: sys 모듈로 디버깅</target>
        </trans-unit>
        <trans-unit id="49bac63211bb6e767f6bd201454a7033e302753a" translate="yes" xml:space="preserve">
          <source>Decodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 을 &quot;x-www-form-urlencoded&quot;로 디코딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d7142bd19e1c0ea0198316fec06393f6cb0ea2" translate="yes" xml:space="preserve">
          <source>Decodes a base 16 encoded string into a binary string.</source>
          <target state="translated">기본 16 인코딩 된 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="fb034015ded81968d20fd5f7e210338ebd758879" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string into a binary string.</source>
          <target state="translated">기본 32 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="885c7e9658ad97e9a9af45bd4781416e206a6334" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string.</source>
          <target state="translated">확장 된 16 진 알파벳이있는 기본 32 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="4b608e75a46b84e1feb5de2f9f73f4f8523e9f1d" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string into a binary string.</source>
          <target state="translated">기본 64 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b945eb1852da433ae69fcf285b6a56aed338e16f" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string.</source>
          <target state="translated">URL 및 파일 이름 안전 알파벳이있는 기본 64 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="12cd61b38813ead53840f88994a5a092cca61e7f" translate="yes" xml:space="preserve">
          <source>Decodes a query string into a map.</source>
          <target state="translated">쿼리 문자열을 맵으로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="624612278a208a23a0e8ccd36697aaa475bd3192" translate="yes" xml:space="preserve">
          <source>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</source>
          <target state="translated">로컬 또는 원격 호출을 원격 부분 (제공된 경우), 함수 이름 및 인수 목록으로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="7151035c3114809bda0193c2a85fa1a470935213" translate="yes" xml:space="preserve">
          <source>Default Unit</source>
          <target state="translated">기본 단위</target>
        </trans-unit>
        <trans-unit id="6bcca2541d3f4eb99df509a0ef05a98d2f536b6d" translate="yes" xml:space="preserve">
          <source>Default arguments</source>
          <target state="translated">기본 인수</target>
        </trans-unit>
        <trans-unit id="6593ff7fb992a5e5072fa654c1b194d94010d120" translate="yes" xml:space="preserve">
          <source>Default background color.</source>
          <target state="translated">기본 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="6e98c72a394abdbcd4b12051bb239d5b6259e9ce" translate="yes" xml:space="preserve">
          <source>Default text color.</source>
          <target state="translated">기본 텍스트 색상.</target>
        </trans-unit>
        <trans-unit id="89487e7c33b83cf47b069ff9b1fec8587ba1c7a6" translate="yes" xml:space="preserve">
          <source>Default translation for Erlang log messages.</source>
          <target state="translated">Erlang 로그 메시지의 기본 번역.</target>
        </trans-unit>
        <trans-unit id="e19bd89011e61a7bb0e77dd718395ff863fa6b57" translate="yes" xml:space="preserve">
          <source>Default values and required keys</source>
          <target state="translated">기본값 및 필수 키</target>
        </trans-unit>
        <trans-unit id="0b6846959c6ecef6294ea2738ab118ae06eb0104" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; for Elixir projects, &lt;code&gt;false&lt;/code&gt; for Erlang projects.</source>
          <target state="translated">Elixir 프로젝트의 &lt;code&gt;true&lt;/code&gt; 기본값은 true 이고 Erlang 프로젝트의 경우 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86bc280a68c01f58573355e9cc73f727e31ec7ae" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; for Elixir projects, &lt;code&gt;false&lt;/code&gt; for Erlang projects. Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="translated">Elixir 프로젝트의 &lt;code&gt;true&lt;/code&gt; 기본값은 true , Erlang 프로젝트의 경우 &lt;code&gt;false&lt;/code&gt; 입니다. 참고 : Elixir 프로젝트에 대해 이것을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 코드 로더가 &lt;code&gt;:elixir&lt;/code&gt; 애플리케이션과 그 자식 을 찾을 수 있도록 결과 escript를 실행할 때 Elixir의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리 경로 를 &lt;code&gt;ERL_LIBS&lt;/code&gt; 환경 변수 에 추가해야합니다 . 응용 프로그램 (사용되는 경우).</target>
        </trans-unit>
        <trans-unit id="9d8d69c2362401ce4e3ef9f4dba08bffc1bb4866" translate="yes" xml:space="preserve">
          <source>Define a function from a string (&lt;a href=&quot;#function_from_string/5&quot;&gt;&lt;code&gt;function_from_string/5&lt;/code&gt;&lt;/a&gt;) or a file (&lt;a href=&quot;#function_from_file/5&quot;&gt;&lt;code&gt;function_from_file/5&lt;/code&gt;&lt;/a&gt;). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</source>
          <target state="translated">문자열 ( &lt;a href=&quot;#function_from_string/5&quot;&gt; &lt;code&gt;function_from_string/5&lt;/code&gt; &lt;/a&gt; ) 또는 파일 ( &lt;a href=&quot;#function_from_file/5&quot;&gt; &lt;code&gt;function_from_file/5&lt;/code&gt; &lt;/a&gt; ) 에서 함수를 정의합니다 . 이렇게하면 컴파일 될 모듈 내부의 함수로 템플릿을 임베드 할 수 있습니다. 컴파일 시간에 템플릿에 액세스 할 수있는 경우 선호되는 API입니다.</target>
        </trans-unit>
        <trans-unit id="d3da7d067c0e2af23683cd3618963a0c016ef27c" translate="yes" xml:space="preserve">
          <source>Define a function from a string (&lt;code&gt;function_from_string&lt;/code&gt;) or a file (&lt;code&gt;function_from_file&lt;/code&gt;). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</source>
          <target state="translated">문자열 ( &lt;code&gt;function_from_string&lt;/code&gt; ) 또는 파일 ( &lt;code&gt;function_from_file&lt;/code&gt; ) 에서 함수를 정의하십시오 . 이를 통해 템플릿 내에 함수로 템플릿을 포함시켜 컴파일 할 수 있습니다. 컴파일 타임에 템플릿에 액세스 할 수있는 경우이 API가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="02454c3ef87373b5da454ba33a54d81ec93d84e1" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;@shortdoc&lt;/code&gt; attribute if you wish to make the task publicly visible on &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;. Omit this attribute if you do not want your task to be listed via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업을 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 에 공개적으로 표시 하려면 &lt;code&gt;@shortdoc&lt;/code&gt; 속성을 정의하십시오 . &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 통해 작업을 나열하지 않으려면이 속성을 생략하십시오 .</target>
        </trans-unit>
        <trans-unit id="7af570fa4ced5be1c1e832e70770e29cb3378f42" translate="yes" xml:space="preserve">
          <source>Define the function explicitly (v1.0)</source>
          <target state="translated">함수를 명시 적으로 정의하십시오 (v1.0)</target>
        </trans-unit>
        <trans-unit id="bc125b89387e69b38c0b71432e6451758cd10e9b" translate="yes" xml:space="preserve">
          <source>Define the rollover moment for the given calendar.</source>
          <target state="translated">주어진 캘린더에 대한 롤오버 모멘트를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc8ce38051bdb795b598be018ffa7c0e1241cd3" translate="yes" xml:space="preserve">
          <source>Defined as</source>
          <target state="translated">로써 정의 된</target>
        </trans-unit>
        <trans-unit id="0e6d691613c83b20a4bdec6dda26151ba97d0294" translate="yes" xml:space="preserve">
          <source>Defines &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Shell&lt;/code&gt;&lt;/a&gt; contract.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Shell&lt;/code&gt; &lt;/a&gt; 계약을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2c159947b8552c14519d220c3a6ddfaa0e00eeec" translate="yes" xml:space="preserve">
          <source>Defines ExUnit callbacks.</source>
          <target state="translated">ExUnit 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3fba28715c151409c38236ee7000eb4ed16c82f1" translate="yes" xml:space="preserve">
          <source>Defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; 에서&lt;/a&gt; 반환 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="83a9409d00bd2dad95a1afabb5663ee3e1f46569" translate="yes" xml:space="preserve">
          <source>Defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="718b6b621786a1acc4c26d42dbc485e26faf7eec" translate="yes" xml:space="preserve">
          <source>Defines a callback that runs once the test exits.</source>
          <target state="translated">테스트가 종료되면 실행되는 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9200a3742bfb9e88c562c9f6f3ed2f69e18c6f67" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before all tests in a case.</source>
          <target state="translated">사례에서 모든 테스트 전에 실행될 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4b6166591f75c5a4bf0202583ee95cba035668e8" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before each test in a case.</source>
          <target state="translated">사례에서 각 테스트 전에 실행될 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d5bc2aab7b6f9616afc524a405cb7757608452d9" translate="yes" xml:space="preserve">
          <source>Defines a function callback according to the given type specification.</source>
          <target state="translated">주어진 형식 사양에 따라 함수 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c5db38a50b427e41d0ad25365053a42c56f8a1f7" translate="yes" xml:space="preserve">
          <source>Defines a function that delegates to another module.</source>
          <target state="translated">다른 모듈에 위임하는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="307e106c43982d5b12630cb72b848406b819c6c6" translate="yes" xml:space="preserve">
          <source>Defines a function with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f063e0d1325de98da63498e5fe376536a4c88d2c" translate="yes" xml:space="preserve">
          <source>Defines a macro callback according to the given type specification.</source>
          <target state="translated">주어진 형식 사양에 따라 매크로 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d1bdce6fb82524ea6dca239a6d1b4282ce120736" translate="yes" xml:space="preserve">
          <source>Defines a macro with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="45436ad823527d91893ee57c61d5208fd54f8f28" translate="yes" xml:space="preserve">
          <source>Defines a module given by name with the given contents.</source>
          <target state="translated">주어진 내용으로 이름으로 주어진 모듈을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2b7b7c71d4c9f86dc9189095ea6eb365a7951119" translate="yes" xml:space="preserve">
          <source>Defines a module template to be used throughout your test suite.</source>
          <target state="translated">테스트 스위트 전체에서 사용할 모듈 템플릿을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf550b43951705ff60d293e8451b26e72a1b3d68" translate="yes" xml:space="preserve">
          <source>Defines a new bitstring.</source>
          <target state="translated">새로운 비트 열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e5448d0355663eca910a26c7f674b96bdfb1318" translate="yes" xml:space="preserve">
          <source>Defines a not implemented test with a string.</source>
          <target state="translated">문자열로 구현되지 않은 테스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3c2d3289caf113cf07d04f07d984ecc30b13bea4" translate="yes" xml:space="preserve">
          <source>Defines a private function with the given name and body.</source>
          <target state="translated">주어진 이름과 본문을 가진 개인 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="08a09270f00cde41495279c24131c417ef5be1db" translate="yes" xml:space="preserve">
          <source>Defines a private macro with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 개인 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="234e236e77f17928fa5de859398ddc5049a5ff60" translate="yes" xml:space="preserve">
          <source>Defines a protocol.</source>
          <target state="translated">프로토콜을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="49de89ada1df4216656fd082e602510e9a3bfba6" translate="yes" xml:space="preserve">
          <source>Defines a public function with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 공용 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="eb0c62dc473198ec220624054b59c8e5facbee00" translate="yes" xml:space="preserve">
          <source>Defines a public macro with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 공용 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf0422852f7761d300210619550ed122f7749dee" translate="yes" xml:space="preserve">
          <source>Defines a range.</source>
          <target state="translated">범위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="84d0bf0e5d21a052c34ad1cf8cc4fd2c0b2d922d" translate="yes" xml:space="preserve">
          <source>Defines a remote call, a call to an anonymous function, or an alias.</source>
          <target state="translated">원격 호출, 익명 함수 호출 또는 별명을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="148ce01689924171178db559eb8519855c18cbf6" translate="yes" xml:space="preserve">
          <source>Defines a set of macros to create, access, and pattern match on a record.</source>
          <target state="translated">레코드에서 작성, 액세스 및 패턴 일치를위한 매크로 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d43aa789386d3da190d548740ece58b49c1b5c28" translate="yes" xml:space="preserve">
          <source>Defines a struct.</source>
          <target state="translated">구조체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e8fc9a0e945bdfdd9fe422d72e6867459e1dd52d" translate="yes" xml:space="preserve">
          <source>Defines a test with &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 로 테스트를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6ff008b3bfc5f520079685bb6518c7f8c263c332" translate="yes" xml:space="preserve">
          <source>Defines a test with a string.</source>
          <target state="translated">문자열로 테스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e440b3cbec6e05424773317aba5a8cdb773dabba" translate="yes" xml:space="preserve">
          <source>Defines an &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#stream/2&quot;&gt;&lt;code&gt;IO.stream/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#stream/2&quot;&gt; &lt;code&gt;IO.stream/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; 에서&lt;/a&gt; 반환 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="81a4f177d77d4b3501935507c322bb13c914958e" translate="yes" xml:space="preserve">
          <source>Defines an &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;io#stream/2&quot;&gt;&lt;code&gt;IO.stream/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;io#stream/2&quot;&gt; &lt;code&gt;IO.stream/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; 에서&lt;/a&gt; 반환 한 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="61d9e7c667e3e371baebf26eb4a1e174baee751d" translate="yes" xml:space="preserve">
          <source>Defines an anonymous function.</source>
          <target state="translated">익명 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1f336908a8420d524aec43e1dfa0a8c9f56be6ac" translate="yes" xml:space="preserve">
          <source>Defines an exception.</source>
          <target state="translated">예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="47c4eab1a12c9a4e9e5bfc15095c4f5f1e7f8420" translate="yes" xml:space="preserve">
          <source>Defines an implementation for the given protocol.</source>
          <target state="translated">주어진 프로토콜에 대한 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7574e6578cdcbcf5986b0221d662d60206450586" translate="yes" xml:space="preserve">
          <source>Defines and manipulates Mix projects.</source>
          <target state="translated">믹스 프로젝트를 정의하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="c87324807b8cf7ca458804ea8ef4c07d69ba7fe6" translate="yes" xml:space="preserve">
          <source>Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools. For example:</source>
          <target state="translated">모듈 컴파일 옵션을 정의합니다. 이것은 외부 도구에 의해 추가 된 다른 컴파일 패스와 같이 Elixir 및 Erlang 컴파일러를 모두 구성하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51d68b5790fad1de6d84cef24485698c5aa44718" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a supervisor which will be started with the given arguments.</source>
          <target state="translated">주어진 인수로 시작될 수퍼바이저로 주어진 &lt;code&gt;module&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a74b181531a071dccf103975ef9b5f457594135a" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a worker which will be started with the given arguments.</source>
          <target state="translated">주어진 &lt;code&gt;module&lt;/code&gt; 을 주어진 인수로 시작할 작업자로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba739f06f65411df500be4fe361a087cd34108a" translate="yes" xml:space="preserve">
          <source>Defines the options used by the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜에서 사용하는 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1e7e7a56a0498c33eb4666ce267e88fdd0443785" translate="yes" xml:space="preserve">
          <source>Defines the options used by the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜에서 사용하는 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="706e656786be6150857ba9d00e3f4736e1b09e1e" translate="yes" xml:space="preserve">
          <source>Defines the release structure and convenience for assembling releases.</source>
          <target state="translated">릴리스 조립을위한 릴리스 구조 및 편의성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f752321778df74391c3378581723efb4dca5e78b" translate="yes" xml:space="preserve">
          <source>Defines warnings to request or suppress when using a version of &lt;code&gt;:dialyzer&lt;/code&gt; that supports module attributes.</source>
          <target state="translated">모듈 속성을 지원 하는 &lt;code&gt;:dialyzer&lt;/code&gt; 버전을 사용할 때 요청하거나 억제 할 경고를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="99cdfc3cbea74f1f4372e3c3f255ee42a2f77809" translate="yes" xml:space="preserve">
          <source>Defining a protocol automatically defines a type named &lt;code&gt;t&lt;/code&gt;, which can be used as follows:</source>
          <target state="translated">프로토콜을 정의하면 다음과 같이 사용될 수있는 &lt;code&gt;t&lt;/code&gt; 유형이 자동으로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="eed610b2a524f1fea8a5a11a6b90ab2b660a40c7" translate="yes" xml:space="preserve">
          <source>Defining a specification</source>
          <target state="translated">사양 정의</target>
        </trans-unit>
        <trans-unit id="375bfa92ccfe2bd509e0a5a5c9ecb19ed5761bbc" translate="yes" xml:space="preserve">
          <source>Defining behaviours</source>
          <target state="translated">행동 정의</target>
        </trans-unit>
        <trans-unit id="1ea27e7345dd55520e1c3fd955a1961190ab35d0" translate="yes" xml:space="preserve">
          <source>Defining custom guard expressions</source>
          <target state="translated">사용자 정의 가드 식 정의</target>
        </trans-unit>
        <trans-unit id="67ee31ce55d3432708e003e7896d5c65897de368" translate="yes" xml:space="preserve">
          <source>Defining custom operators</source>
          <target state="translated">사용자 정의 연산자 정의</target>
        </trans-unit>
        <trans-unit id="88f1538130a6f0b0a36142a4e1e014b6b0b27ac0" translate="yes" xml:space="preserve">
          <source>Defining custom types</source>
          <target state="translated">사용자 정의 유형 정의</target>
        </trans-unit>
        <trans-unit id="fbb6738813740f5989865f0caccc2aedd14ecd4c" translate="yes" xml:space="preserve">
          <source>Defining custom types can help communicate the intention of your code and increase its readability. Custom types can be defined within modules via the &lt;code&gt;@type&lt;/code&gt; attribute.</source>
          <target state="translated">사용자 정의 유형을 정의하면 코드의 의도를 전달하고 가독성을 높일 수 있습니다. 사용자 정의 유형은 &lt;code&gt;@type&lt;/code&gt; 속성을 통해 모듈 내에서 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da279c1a631ba36a0429ee2b6ef866ee7c040663" translate="yes" xml:space="preserve">
          <source>Defining extracted records with anonymous functions in the values</source>
          <target state="translated">값에 익명 함수를 사용하여 추출 된 레코드 정의</target>
        </trans-unit>
        <trans-unit id="d271da3ed06fd6bd866bb6e79184abd537c3512e" translate="yes" xml:space="preserve">
          <source>Defining function specs this way works, but it quickly becomes annoying since we&amp;rsquo;re repeating the type &lt;code&gt;{number, String.t}&lt;/code&gt; over and over. We can use the &lt;code&gt;@type&lt;/code&gt; directive in order to declare our own custom type.</source>
          <target state="translated">이 방법으로 함수 사양을 정의하면 작동하지만 &lt;code&gt;{number, String.t}&lt;/code&gt; 유형을 반복해서 반복하기 때문에 빠르게 성가 시게됩니다 . 우리는 우리 자신의 커스텀 타입을 선언하기 위해 &lt;code&gt;@type&lt;/code&gt; 지시자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b772a8609651705eb8dde2b64b91c2000ee893a" translate="yes" xml:space="preserve">
          <source>Defining function specs this way works, but we end up repeating the type &lt;code&gt;{number, String.t}&lt;/code&gt; over and over. We can use the &lt;code&gt;@type&lt;/code&gt; attribute to declare our own custom type and cut down on the repetition.</source>
          <target state="translated">이러한 방식으로 함수 사양을 정의하는 것은 작동하지만 결국 &lt;code&gt;{number, String.t}&lt;/code&gt; 유형을 계속 반복합니다 . &lt;code&gt;@type&lt;/code&gt; 속성을 사용하여 사용자 정의 유형을 선언하고 반복을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fec1dfeb38c397bddde90cce354ec968be3e685" translate="yes" xml:space="preserve">
          <source>Defining structs</source>
          <target state="translated">구조체 정의</target>
        </trans-unit>
        <trans-unit id="ac3516b411710c30e4cd006454c7f1994a4da34a" translate="yes" xml:space="preserve">
          <source>Delegation only works with functions; delegating macros is not supported.</source>
          <target state="translated">위임은 기능에서만 작동합니다. 위임 매크로는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e726a77011c0fe0cd388991d477e194ae9fd7af2" translate="yes" xml:space="preserve">
          <source>Deletes &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;map_set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; 에서 &lt;code&gt;value&lt;/code&gt; 을 삭제 합니다 .</target>
        </trans-unit>
        <trans-unit id="7197d992ec2d7887544bc401d08055b1f065eeeb" translate="yes" xml:space="preserve">
          <source>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">Erlang VM 코드 경로 목록에서 경로를 삭제합니다. Erlang VM이 모듈 코드를 찾는 데 사용하는 디렉토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="23800ac90aacec2911367a4560daa8ed5fec9cb1" translate="yes" xml:space="preserve">
          <source>Deletes an environment variable.</source>
          <target state="translated">환경 변수를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="28cada09dd4174a63836f40b25ecf14ff7e1c534" translate="yes" xml:space="preserve">
          <source>Deletes generated application files.</source>
          <target state="translated">생성 된 응용 프로그램 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e6a3899638112ac7460e060d887ef65128ba4bb0" translate="yes" xml:space="preserve">
          <source>Deletes logging level for all modules to primary level</source>
          <target state="translated">모든 모듈의 로깅 수준을 기본 수준으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e51596caccd970cb4a08314add121664dd042408" translate="yes" xml:space="preserve">
          <source>Deletes logging level for given module to primary level.</source>
          <target state="translated">주어진 모듈에 대한 로깅 수준을 기본 수준으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="666b6e6f3ed57f226d5de485fc7c0243f6bedb5a" translate="yes" xml:space="preserve">
          <source>Deletes registry metadata for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">삭제는 주어진에 대한 메타 데이터 레지스트리 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;registry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6511b55cc1b351a9cd395e58f52ffa508ee0de39" translate="yes" xml:space="preserve">
          <source>Deletes the &lt;code&gt;key&lt;/code&gt; from the given &lt;code&gt;app&lt;/code&gt; environment.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 환경 에서 &lt;code&gt;key&lt;/code&gt; 를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="cda458e47c2adb906a94c0b5117cdc3d628bc0de" translate="yes" xml:space="preserve">
          <source>Deletes the child specification identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; 로 식별 된 하위 스펙을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="06519f5a98d8a9576fa45c95f0c76ae133cbfd51" translate="yes" xml:space="preserve">
          <source>Deletes the element at the given &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;tuple&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than or equal to the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">주어진 &lt;code&gt;index&lt;/code&gt; 의 요소 를 &lt;code&gt;tuple&lt;/code&gt; 에서 삭제합니다 . 상승 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;index&lt;/code&gt; 네거티브 이상이 초과 또는 길이와 동일한 &lt;code&gt;tuple&lt;/code&gt; . 인덱스는 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fd3c9b264d49ac26b30c967deba1cf019e912877" translate="yes" xml:space="preserve">
          <source>Deletes the element at the given &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;tuple&lt;/code&gt;. Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than or equal to the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">주어진에있는 요소 삭제 &lt;code&gt;index&lt;/code&gt; 에서 &lt;code&gt;tuple&lt;/code&gt; . 상승 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;index&lt;/code&gt; 네거티브 이상이 초과 또는 길이와 동일한 &lt;code&gt;tuple&lt;/code&gt; . 인덱스는 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="768479db33c4ea83d038f3e75c0b46d08cfff3a1" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">A의 키워드 목록에서 항목을 삭제 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f8ea2c4a41f9ff990549664a0c3e8cc979a2f3" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">키워드 목록에서 특정 &lt;code&gt;key&lt;/code&gt; 대한 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="e356fc985f5b4c45501dcdd4bf05b2d169dc820a" translate="yes" xml:space="preserve">
          <source>Deletes the entry in &lt;code&gt;map&lt;/code&gt; for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 대한 &lt;code&gt;map&lt;/code&gt; 의 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="84bf7f6c44bf7d1a25fea2eb0b485822b94e4057" translate="yes" xml:space="preserve">
          <source>Deletes the first entry in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">키워드 목록에서 특정 &lt;code&gt;key&lt;/code&gt; 대한 첫 번째 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="f8205134472497de5f123b07ed4ca04623561776" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;element&lt;/code&gt; from the &lt;code&gt;list&lt;/code&gt;. Returns a new list without the element.</source>
          <target state="translated">주어진 &lt;code&gt;element&lt;/code&gt; 를 &lt;code&gt;list&lt;/code&gt; 에서 삭제합니다 . 요소가없는 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6931640e5585d21423be80c31e8281e15f83ebe2" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;key&lt;/code&gt; from the process dictionary.</source>
          <target state="translated">프로세스 사전에서 지정된 &lt;code&gt;key&lt;/code&gt; 를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="96c74c6ec914e8875fe5447015216dd83996fdd6" translate="yes" xml:space="preserve">
          <source>Deletes the given dependencies' files, including build artifacts and fetched sources.</source>
          <target state="translated">빌드 아티팩트 및 가져온 소스를 포함하여 지정된 종속성의 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="241d39fd9168ac37f5f1398b699e96cae08161ab" translate="yes" xml:space="preserve">
          <source>Deletes the module attribute that matches the given key.</source>
          <target state="translated">주어진 키와 일치하는 모듈 속성을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a7699468279a4b12f6e55a5ad1b8c725c2c3ca8c" translate="yes" xml:space="preserve">
          <source>Demonitors the monitor identified by the given &lt;code&gt;reference&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;reference&lt;/code&gt; 식별 된 모니터를 모니터 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="ca0bdefd221fdbfd10bc0f3013fa9c019ef6808e" translate="yes" xml:space="preserve">
          <source>Dependencies and umbrella projects</source>
          <target state="translated">의존성 및 우산 프로젝트</target>
        </trans-unit>
        <trans-unit id="a491fbe030b9498ae78cd8f4bbd75506aa4b23b5" translate="yes" xml:space="preserve">
          <source>Dependencies are loaded again, now with an updated env environment</source>
          <target state="translated">이제 업데이트 된 환경 환경으로 종속성이 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="0aeab4e8a30c470967346544f8d2eeabc88b3b63" translate="yes" xml:space="preserve">
          <source>Dependencies between applications in an umbrella project must still be explicitly defined and Mix makes it easy to do so. Open up &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; and change the &lt;code&gt;deps/0&lt;/code&gt; function to the following:</source>
          <target state="translated">우산 프로젝트에서 응용 프로그램 간의 종속성은 여전히 ​​명시 적으로 정의해야하며 Mix를 사용하면 쉽게 할 수 있습니다. &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; 를 열고 &lt;code&gt;deps/0&lt;/code&gt; 기능을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="20c4e61613e0bb2759ad45cedce4f0b014181be0" translate="yes" xml:space="preserve">
          <source>Dependencies must be specified in the &lt;code&gt;mix.exs&lt;/code&gt; file in one of the following formats:</source>
          <target state="translated">다음 형식 중 하나로 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 종속성을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc73fac5fc75582095a6f843e32787bf5448edd3" translate="yes" xml:space="preserve">
          <source>Dependencies types</source>
          <target state="translated">종속성 유형</target>
        </trans-unit>
        <trans-unit id="1313d46d93e4456c33c34bdf877a2b31296e6f6b" translate="yes" xml:space="preserve">
          <source>Dependencies within an umbrella project</source>
          <target state="translated">우산 프로젝트 내의 종속성</target>
        </trans-unit>
        <trans-unit id="2ae4f4df59c1f88916b85e951202eefbff4c7b68" translate="yes" xml:space="preserve">
          <source>Dependency definition options</source>
          <target state="translated">종속성 정의 옵션</target>
        </trans-unit>
        <trans-unit id="8ef7583b0e7ed117ec9a27cd09f5e8d10632bf4f" translate="yes" xml:space="preserve">
          <source>Depending on the accumulator value, the result returned by &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; will change. Please check the &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt; type documentation for more information.</source>
          <target state="translated">누산기 값에 따라 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; 에서&lt;/a&gt; 반환 된 결과 가 변경됩니다. 자세한 내용은 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt; 유형 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ac1bc59655cdca7840ee9bf9d55721f13ebb7a55" translate="yes" xml:space="preserve">
          <source>Depending on the accumulator value, the result returned by &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; will change. Please check the &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt; type documentation for more information.</source>
          <target state="translated">누산기 값에 따라 &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 가 반환 한 결과 가 변경됩니다. 자세한 정보 는 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt; 유형 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d458ed0bd596292bbe634a9b96cac2cab2e4961" translate="yes" xml:space="preserve">
          <source>Deployments</source>
          <target state="translated">Deployments</target>
        </trans-unit>
        <trans-unit id="4962f760a0cc6ed936dcedffadba8733dd81e124" translate="yes" xml:space="preserve">
          <source>Deploys a given module's BEAM code to a list of nodes.</source>
          <target state="translated">주어진 모듈의 BEAM 코드를 노드 목록에 배포합니다.</target>
        </trans-unit>
        <trans-unit id="f6ef72731d9f2999dced5cdda829d282f60229ed" translate="yes" xml:space="preserve">
          <source>Deprecated feature</source>
          <target state="translated">더 이상 사용되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="e5135ac9aa0f3adf0ead688638a7cada98f65645" translate="yes" xml:space="preserve">
          <source>Deprecated function to retrieve old documentation format.</source>
          <target state="translated">오래된 문서 형식을 검색하는 데 사용되지 않는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="355cf2e1caeb8e5de974f3e0ee6f449e9a16967c" translate="yes" xml:space="preserve">
          <source>Deprecated mechanism to retrieve the last exception stacktrace.</source>
          <target state="translated">마지막 예외 스택 추적을 검색하기 위해 사용되지 않는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="8189415262d9b40fadd78cc759dd14fdb9868384" translate="yes" xml:space="preserve">
          <source>Deps task</source>
          <target state="translated">뎁스 작업</target>
        </trans-unit>
        <trans-unit id="1751cb6240f8427862c44d9fda1a1acebc588f2b" translate="yes" xml:space="preserve">
          <source>Derives the &lt;code&gt;protocol&lt;/code&gt; for &lt;code&gt;module&lt;/code&gt; with the given options.</source>
          <target state="translated">주어진 옵션으로 &lt;code&gt;module&lt;/code&gt; 의 &lt;code&gt;protocol&lt;/code&gt; 을 도출합니다 .</target>
        </trans-unit>
        <trans-unit id="b1f507cfab066377ebfd776c06ce8c6ae1d1dfae" translate="yes" xml:space="preserve">
          <source>Deriving</source>
          <target state="translated">Deriving</target>
        </trans-unit>
        <trans-unit id="469b2320b22b8de425b1224d561debab3b7e4eec" translate="yes" xml:space="preserve">
          <source>Describes tests together.</source>
          <target state="translated">테스트를 함께 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="373b67a9ef6e15b48984d2e64ecfb18feb928f40" translate="yes" xml:space="preserve">
          <source>Design principles</source>
          <target state="translated">설계 원칙</target>
        </trans-unit>
        <trans-unit id="9c5959e7ab4938c2e1595e724f3e5f686f3d536b" translate="yes" xml:space="preserve">
          <source>Destructures two lists, assigning each term in the right one to the matching term in the left one.</source>
          <target state="translated">오른쪽에있는 각 용어를 왼쪽에있는 일치하는 용어에 할당하여 두 개의 목록을 구성 해제합니다.</target>
        </trans-unit>
        <trans-unit id="55519a961a5691717096efcabf1914eee5dab5a5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;integer&lt;/code&gt; is odd.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 가 홀수 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="026e5ca0dfda1ad25fabda732fd35af3e32e25b5" translate="yes" xml:space="preserve">
          <source>Determines if an &lt;code&gt;integer&lt;/code&gt; is even.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 가 짝수 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ada7ef5eac5cda7b071d8c84d536d21adaaabe11" translate="yes" xml:space="preserve">
          <source>Determines if the &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="240590c512304822fc6f9051f63c5097957b51d1" translate="yes" xml:space="preserve">
          <source>Determines if the date given is valid according to the proleptic Gregorian calendar.</source>
          <target state="translated">주어진 날짜가 다발성 그레고리력에 따라 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="76efef7f9a49f47616dc673a59a2c3e837af4cb0" translate="yes" xml:space="preserve">
          <source>Determines whether a given file path (supplied to ExUnit/Mix as arguments on the command line) includes a line number filter, and if so returns the appropriate ExUnit configuration options.</source>
          <target state="translated">지정된 파일 경로 (명령 줄의 인수로 ExUnit / Mix에 제공됨)에 줄 번호 필터가 포함되어 있는지 여부를 확인하고 해당하는 경우 적절한 ExUnit 구성 옵션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ecb9b726f00ef60a6a7e35454782b134568f041" translate="yes" xml:space="preserve">
          <source>Developers can also use &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; to build &lt;strong&gt;releases&lt;/strong&gt;. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</source>
          <target state="translated">개발자는 사용할 수있는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 빌드에 &lt;strong&gt;출시&lt;/strong&gt; . 릴리스는 모든 소스 코드와 Erlang VM을 단일 디렉터리에 패키징 할 수 있습니다. 릴리스는 또한 각 애플리케이션이 시작되는 방법과 순서를 명시 적으로 제어 할 수 있습니다. 또한 시스템 시작 및 중지, 디버깅, 로깅 및 시스템 모니터링을위한보다 간소화 된 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b906ed370d76a314f78611272f97a7c5324fbfb8" translate="yes" xml:space="preserve">
          <source>Developers can also use tools like &lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery&lt;/a&gt; that build &lt;strong&gt;releases&lt;/strong&gt;. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</source>
          <target state="translated">개발자는 &lt;strong&gt;릴리스&lt;/strong&gt; 를 빌드하는 &lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery&lt;/a&gt; 와 같은 도구를 사용할 수도 있습니다 . 릴리스는 Erlang VM뿐만 아니라 모든 소스 코드를 단일 디렉토리에 패키지 할 수 있습니다. 또한 각 응용 프로그램의 시작 방법과 순서를 명시 적으로 제어 할 수 있습니다. 또한 시스템 시작 및 중지, 디버깅, 로깅 및 시스템 모니터링을위한보다 간소화 된 메커니즘을 제공합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17f25608342d4ab77bb1907f884cfe439bc54de0" translate="yes" xml:space="preserve">
          <source>Developers may also implement their own backends, an option that is explored in more detail below.</source>
          <target state="translated">개발자는 또한 자체 백엔드를 구현할 수도 있습니다.이 옵션은 아래에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0f26c5755a434f3e16da5992d7fb7b82ce5cc7eb" translate="yes" xml:space="preserve">
          <source>Developers may also use umbrella projects to break large business domains apart. The caution here is to make sure the domains don&amp;rsquo;t depend on each other (also known as cyclic dependencies). If you run into such situations, it means those applications are not as isolated from each other as you originally thought, and you have architectural and design issues to solve.</source>
          <target state="translated">개발자는 대규모 프로젝트 영역을 분리하기 위해 우산 프로젝트를 사용할 수도 있습니다. 여기서주의해야 할 것은 도메인이 서로 의존하지 않도록하는 것입니다 (순환 종속성이라고도 함). 이러한 상황이 발생하면 해당 응용 프로그램이 원래 생각했던 것처럼 서로 격리되어 있지 않으며 해결해야 할 아키텍처 및 디자인 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8e1b365eba8e74b8bfe96cbfcdf64fb1b529aa8" translate="yes" xml:space="preserve">
          <source>Developers may want to customize the VM flags and environment variables given when the release starts. This is typically done by customizing two files inside your release: &lt;code&gt;releases/RELEASE_VSN/vm.args&lt;/code&gt; and &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (or &lt;code&gt;env.bat&lt;/code&gt; on Windows).</source>
          <target state="translated">개발자는 출시가 시작될 때 제공되는 VM 플래그 및 환경 변수를 맞춤 설정할 수 있습니다. 이는 일반적으로 릴리스 내에서 &lt;code&gt;releases/RELEASE_VSN/vm.args&lt;/code&gt; 및 &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (또는 Windows의 &lt;code&gt;env.bat&lt;/code&gt; ) 두 파일을 사용자 지정하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4df092ce16103b5263190978f954da4abebc038" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9399f0af7289ccae2bbfba26b54d6beaa45eceaa" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 Date 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="372765583e2c62003b134d7cd14c816d752b1af8" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 NaiveDateTime 구조체를 직접 만드는 대신이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="055215a2dc231830ec70e2ea3ed245f009feefc1" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 Time 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9189bcb16b1c4a850379e209c0a8399dce99e6b1" translate="yes" xml:space="preserve">
          <source>Developers typically interact with the application environment and its callback module. Therefore those will be the topics we will cover first before jumping into details about the application resource file and life-cycle.</source>
          <target state="translated">개발자는 일반적으로 애플리케이션 환경 및 해당 콜백 모듈과 상호 작용합니다. 따라서 응용 프로그램 리소스 파일 및 수명주기에 대한 세부 정보로 이동하기 전에 먼저 다룰 주제가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="99b414f7b11d4d2f5dc034b2a293c66c101f5ce2" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 init 콜백 끝에 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="49670694b8769b5d39822cc3c17e46c76506631f" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 초기 콜백 끝에 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="a0f9f33bf587fbe7754189054b93906eb196c38a" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 초기화 콜백이 끝날 때 &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c23ae07b94722ec4976e1fcb3346ba8a18a11515" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 초기화 콜백이 끝날 때 &lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c943b3eb860130726114a82a12d17559028bcef9" translate="yes" xml:space="preserve">
          <source>Developing in Elixir does not make your code free of race conditions. However, Elixir&amp;rsquo;s abstractions where nothing is shared by default make it easier to spot a race condition&amp;rsquo;s root cause.</source>
          <target state="translated">Elixir에서 개발한다고해서 코드에 경쟁 조건이없는 것은 아닙니다. 그러나 기본적으로 아무 것도 공유하지 않는 Elixir의 추상화는 경쟁 조건의 근본 원인을 쉽게 발견 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">Development</target>
        </trans-unit>
        <trans-unit id="6b689de83c32738e6559500bab1e32306f72a975" translate="yes" xml:space="preserve">
          <source>Diagnostic information such as a warning or compilation error.</source>
          <target state="translated">경고 또는 컴파일 오류와 같은 진단 정보.</target>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="28a9d7ddb98e082ecef8831bdb74b74701f20d77" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;defmodule&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defmodule&lt;/code&gt; 과의 차이점</target>
        </trans-unit>
        <trans-unit id="951f149c561762e46794ae9088e9246ba02fb48d" translate="yes" xml:space="preserve">
          <source>Differences to &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; 차이 / 1</target>
        </trans-unit>
        <trans-unit id="5d20542733f8e0c7eb21a37d3a9649be5cfd67f9" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows. You may call &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; to normalize the path before invoking this function.</source>
          <target state="translated">디렉토리 구분 기호는 Windows에서도 항상 &lt;code&gt;/&lt;/code&gt; 로 작성되어야합니다 . 이 함수를 호출하기 전에 &lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 경로를 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7664bc212e56811cb62a63d951c16c5ee311e137" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows. You may call &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; to normalize the path before invoking this function.</source>
          <target state="translated">디렉토리 구분자는 Windows에서도 항상 &lt;code&gt;/&lt;/code&gt; 로 작성해야합니다 . 이 함수를 호출하기 전에 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 경로를 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07461fdd8bbd77721cfe447edf9e4bd20cbd0023" translate="yes" xml:space="preserve">
          <source>Directory structure</source>
          <target state="translated">디렉토리 구조</target>
        </trans-unit>
        <trans-unit id="5095c2a8d43020f623949798775e0dea6df3427e" translate="yes" xml:space="preserve">
          <source>Disables logging for the current process.</source>
          <target state="translated">현재 프로세스에 대한 로깅을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3243542aa799d7700902fa9d17f21c898a51bd23" translate="yes" xml:space="preserve">
          <source>Dispatching happens in the process that calls &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; either serially or concurrently in case of multiple partitions (via spawned tasks). The registered processes are not involved in dispatching unless involving them is done explicitly (for example, by sending them a message in the callback).</source>
          <target state="translated">디스패치 는 여러 파티션의 경우 (스폰 된 작업을 통해) &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 을 직렬 또는 동시에 호출하는 프로세스 에서 발생합니다. 등록 된 프로세스는 명시 적으로 수행되지 않은 경우 (예 : 콜백에 메시지를 보내는 등) 디스패치에 관여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="129dd56090745e370bed845813615f5c08f21b2a" translate="yes" xml:space="preserve">
          <source>Distributed tasks</source>
          <target state="translated">분산 작업</target>
        </trans-unit>
        <trans-unit id="aef0124ef44afd7de1feb0a9b09b0c6ee2798fe2" translate="yes" xml:space="preserve">
          <source>Distributed tasks and tags</source>
          <target state="translated">분산 작업 및 태그</target>
        </trans-unit>
        <trans-unit id="b4c7a18ac5c24ec1029c892a8a7fb3fbcc59af1d" translate="yes" xml:space="preserve">
          <source>Distributed tasks are exactly the same as supervised tasks. The only difference is that we pass the node name when spawning the task on the supervisor. Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; from the &lt;code&gt;:kv&lt;/code&gt; application. Let&amp;rsquo;s add a task supervisor as the last child of the tree:</source>
          <target state="translated">분산 작업은 감독 작업과 동일합니다. 유일한 차이점은 수퍼바이저에서 작업을 생성 할 때 노드 이름을 전달한다는 것입니다. 열고 &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 로부터 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램을. 트리의 마지막 자식으로 작업 관리자를 추가합시다 :</target>
        </trans-unit>
        <trans-unit id="98348afa0d882c80ed7d05917265b30ff93c136a" translate="yes" xml:space="preserve">
          <source>Divides a string into parts based on a pattern.</source>
          <target state="translated">패턴을 기반으로 문자열을 여러 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="4f19d3c5ba97dc473a0dd975ca453b2aa1eeca76" translate="yes" xml:space="preserve">
          <source>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</source>
          <target state="translated">선행 및 후행 공백은 무시하고 각 유니 코드 공백 발생시 문자열을 하위 문자열로 나눕니다. 공백 그룹은 단일 항목으로 취급됩니다. 공백이 아닌 공백에서는 나누기가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d81ee0347de2d9ae77f2a442736c72a2f69253b7" translate="yes" xml:space="preserve">
          <source>Do not call this function at the tail of another function. Due to tail call optimization, a stacktrace entry would not be added and the stacktrace would be incorrectly trimmed. Therefore make sure at least one expression (or an atom such as &lt;code&gt;:ok&lt;/code&gt;) follows the &lt;a href=&quot;#warn/1&quot;&gt;&lt;code&gt;IO.warn/1&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">다른 함수의 끝에이 함수를 호출하지 마십시오. 마무리 호출 최적화로 인해 스택 추적 항목이 추가되지 않고 스택 추적이 잘못 트리밍됩니다. 따라서 최소한 하나의 표현식 (또는 &lt;code&gt;:ok&lt;/code&gt; 와 같은 원자 )이 &lt;a href=&quot;#warn/1&quot;&gt; &lt;code&gt;IO.warn/1&lt;/code&gt; &lt;/a&gt; 호출 뒤에 오는지 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="6e4d17c0fddf7977be47a1ef9b14e7b1d0cef265" translate="yes" xml:space="preserve">
          <source>Do not rely on the particular format returned by the &lt;code&gt;format*&lt;/code&gt; functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.</source>
          <target state="translated">이 모듈 의 &lt;code&gt;format*&lt;/code&gt; 함수가 반환 한 특정 형식에 의존하지 마십시오 . Elixir의 툴 체인에 더 적합하도록 이후 릴리스에서 변경 될 수 있습니다. 즉,이 모듈의 기능을 사용하면 사용중인 현재 Elixir 버전에서와 같이 예외를 형식화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed32458ab08d1762c48c121c3b7d606e8351db4" translate="yes" xml:space="preserve">
          <source>Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt; and the compiler to provide features like hygiene, better error messages, and so forth.</source>
          <target state="translated">이후 버전의 언어에서 변경되거나 완전히 제거 될 수 있으므로 의존하지 마십시오. 그것들은 종종 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; 및 컴파일러에서 위생, 더 나은 오류 메시지 등과 같은 기능을 제공하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc7bc96b42e95f7c693c3ce91032568e412218c3" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt; to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</source>
          <target state="translated">런타임 구성을 찾기 위해 &lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 . 응용 프로그램 런타임이 아닌 프로젝트의 측면 (예 : 컴파일 디렉터리)을 구성하는 데만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f4fd1f0a9baed4ec08ef8c1f9bda3731a7c9d57" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E=/2&quot;&gt;&lt;code&gt;&amp;gt;=/2&lt;/code&gt;&lt;/a&gt; and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates:</source>
          <target state="translated">구조체를 정렬 할 때 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E=/2&quot;&gt; &lt;code&gt;&amp;gt;=/2&lt;/code&gt; &lt;/a&gt; 및 friends를 사용하지 마십시오 . 이는 위의 내장 연산자가 의미 론적 비교가 아닌 구조적 비교를 수행하기 때문입니다. 다음 날짜 목록을 정렬한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="5be89a1272cff39c64911be3f9a33057d2a2263c" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt; to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</source>
          <target state="translated">런타임 구성을 찾기 위해 &lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 . 응용 프로그램 런타임이 아닌 프로젝트 측면 (컴파일 디렉토리와 같은)을 구성 할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d3dcf5e3a5a8a9d6963913c532d9b07e33dbf9" translate="yes" xml:space="preserve">
          <source>Do not use special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because they might not work as expected.</source>
          <target state="translated">특수 일치 변수 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; 는 예상대로 작동하지 않을 수 있으므로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9078c7f338a72de9ec9a277913417c733a31c6ad" translate="yes" xml:space="preserve">
          <source>Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; instead.</source>
          <target state="translated">이 함수를 사용하여 일련의 숫자를 생성하지 마십시오. 발신자 프로세스를 차단할 필요가 없으면 &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c967365f49cb78e9480b70b6bc54898d3348c0d" translate="yes" xml:space="preserve">
          <source>Doctest will looking for a line starting with &lt;code&gt;** (&lt;/code&gt; and it will parse it accordingly to extract the exception name and message. The exception parser will consider all following lines part of the exception message until there is an empty line or there is a new expression prefixed with &lt;code&gt;iex&amp;gt;&lt;/code&gt;. Therefore, it is possible to match on multiline messages as long as there are no empty lines on the message itself.</source>
          <target state="translated">Doctest는 &lt;code&gt;** (&lt;/code&gt; 시작하는 줄을 찾고 예외 이름과 메시지를 추출하기 위해 적절하게 구문 분석합니다. 예외 구문 분석기는 빈 줄이 있거나 새식이있을 때까지 예외 메시지의 모든 다음 줄 부분을 고려합니다. &lt;code&gt;iex&amp;gt;&lt;/code&gt; 접두사가 붙기 때문에 메시지 자체에 빈 줄이없는 한 여러 줄 메시지에서 일치하는 것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="54cc8e778254d8263003ab87576a482705e9e652" translate="yes" xml:space="preserve">
          <source>Doctests allow us to generate tests from code examples found in &lt;code&gt;@moduledoc&lt;/code&gt; and &lt;code&gt;@doc&lt;/code&gt; attributes. To do this, invoke the &lt;a href=&quot;#doctest/1&quot;&gt;&lt;code&gt;doctest/1&lt;/code&gt;&lt;/a&gt; macro from within your test case and ensure your code examples are written according to the syntax and guidelines below.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; 를 사용 &lt;code&gt;@doc&lt;/code&gt; @moduledoc 및 @doc 속성에 있는 코드 예제에서 테스트를 생성 할 수 있습니다. 이를 수행하려면 테스트 케이스 내에서 &lt;a href=&quot;#doctest/1&quot;&gt; &lt;code&gt;doctest/1&lt;/code&gt; &lt;/a&gt; 매크로를 호출하고 코드 예제가 아래 구문 및 지침에 따라 작성되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fd6f84b7484c0cf7709bebbb23583c23abf1b083" translate="yes" xml:space="preserve">
          <source>Doctests are specified by an indentation of four spaces followed by the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt in a documentation string. If a command spans multiple lines, you can use &lt;code&gt;...&amp;gt;&lt;/code&gt;, as in IEx. The expected result should start at the next line after &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and is terminated either by a newline or a new &lt;code&gt;iex&amp;gt;&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;iex&amp;gt;&lt;/code&gt; 는 문서 문자열에서 4 개의 공백 들여 쓰기와 iex&amp;gt; 프롬프트로 지정됩니다 . 명령이 여러 줄에 걸쳐 있으면 IEx에서와 같이 &lt;code&gt;...&amp;gt;&lt;/code&gt; 을 사용할 수 있습니다 . 예상 된 결과는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;...&amp;gt;&lt;/code&gt; 행 다음 줄에서 시작해야 하며 개행 또는 새 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 접두어 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="acfc0021db2710ad6e5c5976444819b508e6a8e7" translate="yes" xml:space="preserve">
          <source>Doctests, patterns and with</source>
          <target state="translated">Doctests, 패턴 및</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="dbeb3b73b289a45968e86a1c4e28757eddbb7b21" translate="yes" xml:space="preserve">
          <source>Documentation != Code comments</source>
          <target state="translated">문서! = 코드 주석</target>
        </trans-unit>
        <trans-unit id="dc66ec30a9e7992a7f99224cd60ef6a9e6f7c515" translate="yes" xml:space="preserve">
          <source>Documentation in Elixir is usually attached to module attributes. Let's see an example:</source>
          <target state="translated">Elixir의 문서는 일반적으로 모듈 속성에 첨부됩니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d46677a0ad1e404b917f0ea8b3b31b80c34ffa5f" translate="yes" xml:space="preserve">
          <source>Documentation metadata</source>
          <target state="translated">설명서 메타 데이터</target>
        </trans-unit>
        <trans-unit id="fcb85c951e6d656fcd603d110a64fcd8866200d9" translate="yes" xml:space="preserve">
          <source>Documents in a group are attempted to be rendered together to the best of the renderer ability.</source>
          <target state="translated">그룹의 문서는 최상의 렌더러 기능으로 함께 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="e86919b582b64b77ec53c038e64ee362a74d9398" translate="yes" xml:space="preserve">
          <source>Does not include fractional seconds.</source>
          <target state="translated">분수 초는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bd6d91ba0fc6656f3596671325c2a8e0bccb23f" translate="yes" xml:space="preserve">
          <source>Does not load any of the implementations.</source>
          <target state="translated">구현을로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1c5568ff1b2696956a80de3fbdad95c454b1c9a" translate="yes" xml:space="preserve">
          <source>Does not load any of the protocols.</source>
          <target state="translated">프로토콜을로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c263be485f93e4de275853028d24c5388efd78f6" translate="yes" xml:space="preserve">
          <source>Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014, the result is 0.010000000000000002, and because this is not the closest representable number to 0.01, you'll get the wrong result for this operation</source>
          <target state="translated">0.1 * 0.1을 수행하면 0.01이 반환되지만 0.1이 실제로 0.1000000014이므로 결과는 0.010000000000000002이며 이는 0.01에 가장 가까운 대표 숫자가 아니기 때문에이 작업에 대한 잘못된 결과를 얻습니다</target>
        </trans-unit>
        <trans-unit id="576aa93d193455e3276b07f4cd2af71d8167c617" translate="yes" xml:space="preserve">
          <source>Doing it in reverse order will raise a syntax error:</source>
          <target state="translated">역순으로 수행하면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a56ad56b6280b6eca6747cdcbe707267d3443caf" translate="yes" xml:space="preserve">
          <source>Domain-specific languages</source>
          <target state="translated">도메인 별 언어</target>
        </trans-unit>
        <trans-unit id="e6ab4e40cdc60406c301246d5709b2813b1c0221" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t drink the kool aid</source>
          <target state="translated">쿨 원조를 마시지 마십시오</target>
        </trans-unit>
        <trans-unit id="bfd4ab20e5eed869032f79c7d0b2472213257269" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that you can also check the &lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;source code of Elixir itself&lt;/a&gt;, which is mostly written in Elixir (mainly the &lt;code&gt;lib&lt;/code&gt; directory), or &lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;explore Elixir&amp;rsquo;s documentation&lt;/a&gt;.</source>
          <target state="translated">Elixir (주로 &lt;code&gt;lib&lt;/code&gt; 디렉토리)로 작성된 &lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;Elixir 자체&lt;/a&gt; 의 소스 코드를 확인 하거나 &lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;Elixir의 문서를 탐색 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db8bef0a01561d7d57f3c78471d1ef61330dd5e" translate="yes" xml:space="preserve">
          <source>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</source>
          <target state="translated">점 연산자. 원격 호출, 익명 함수 호출 또는 별칭을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8e3dff4b81533f75ceec6a97ebb6191aa309061e" translate="yes" xml:space="preserve">
          <source>Drops elements at the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 는 진실한 가치를 반환 하면서 &lt;code&gt;enumerable&lt;/code&gt; 시작 부분에 요소를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="594f287d9f0bd3fb9ea891584418c737436dd38e" translate="yes" xml:space="preserve">
          <source>Drops the &lt;code&gt;amount&lt;/code&gt; of elements from the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소에서 요소 의 &lt;code&gt;amount&lt;/code&gt; 을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="ab32b2e5c71cd1c17d36b26a0d25edc63a27b074" translate="yes" xml:space="preserve">
          <source>Drops the given &lt;code&gt;keys&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;keys&lt;/code&gt; 를 &lt;code&gt;map&lt;/code&gt; 에서 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb8b8343fe7d1adbf36b056e528d2571ea6a12c" translate="yes" xml:space="preserve">
          <source>Drops the given keys from the keyword list.</source>
          <target state="translated">키워드 목록에서 지정된 키를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="69c0475e80c404bbdc2d49a7a643fb10c6ace760" translate="yes" xml:space="preserve">
          <source>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:</source>
          <target state="translated">불변성으로 인해 Elixir의 루프 (모든 기능적 프로그래밍 언어에서와 같이)는 명령형 언어와 다르게 작성됩니다. 예를 들어 C와 같은 명령형 언어에서는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5cf07ff6fe7f2d796d09183c5eda29bcd66f1127" translate="yes" xml:space="preserve">
          <source>Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):</source>
          <target state="translated">cons 셀 기반 표현으로 인해 목록에 요소를 추가하는 것은 항상 빠르며 (일정한 시간), 목록의 크기가 커짐에 따라 추가하는 속도가 느려집니다 (선형 시간).</target>
        </trans-unit>
        <trans-unit id="4f1ef09b3bb7845a809a8a0e2e38529155ed603e" translate="yes" xml:space="preserve">
          <source>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, intermediate lists are created, while &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; creates a recipe of computations that are executed at a later moment. Let's see another example:</source>
          <target state="translated">게으름으로 인해 스트림은 대규모 (또는 무한한) 컬렉션으로 작업 할 때 유용합니다. 많은 연산을 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 과 연결하면 중간 목록이 생성되고 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 은 나중에 실행되는 계산 레시피를 생성합니다. 다른 예를 보자.</target>
        </trans-unit>
        <trans-unit id="bb320794ee00a758f7983100b77521dd3b189d58" translate="yes" xml:space="preserve">
          <source>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, intermediate lists are created, while &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; creates a recipe of computations that are executed at a later moment. Let's see another example:</source>
          <target state="translated">게으름으로 인해 스트림은 대규모 (또는 무한한) 컬렉션으로 작업 할 때 유용합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 으로&lt;/a&gt; 많은 작업을 연결하면 중간 목록이 생성되고 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 은 나중에 실행되는 계산 레시피를 생성합니다. 다른 예를 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1d4a3188c65902a880f35052cd6e431c13b80b5a" translate="yes" xml:space="preserve">
          <source>Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the &lt;code&gt;__foo__&lt;/code&gt; format. For example, every module in Elixir has an &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이 속성으로 인해 Elixir는 밑줄로 시작하는 함수를 사용하여 컴파일 타임 메타 데이터를 모듈에 연결합니다. 이러한 함수는 대부분 &lt;code&gt;__foo__&lt;/code&gt; 형식입니다. 예를 들어 Elixir의 모든 모듈에는 &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9895fb241f7b45a9dc3e35cea835d242910bcea5" translate="yes" xml:space="preserve">
          <source>Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the &lt;code&gt;__foo__&lt;/code&gt; format. For example, every module in Elixir has an &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이 속성으로 인해 Elixir는 밑줄로 시작하는 함수를 사용하여 컴파일 타임 메타 데이터를 모듈에 첨부합니다. 이러한 함수는 대부분 &lt;code&gt;__foo__&lt;/code&gt; 형식입니다. 예를 들어, Elixir의 모든 모듈에는 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e98f40360712c64e6a04a39d7c38770f1fe9b496" translate="yes" xml:space="preserve">
          <source>Duplicate keys and ordering</source>
          <target state="translated">중복 키 및 순서</target>
        </trans-unit>
        <trans-unit id="7d17d072820769c205a9be99134b8181cc1f8d63" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">중복 된 항목이 제거되고 최신 항목이 우선합니다. 달리 &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt; , &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; 키가 고유 보장한다.</target>
        </trans-unit>
        <trans-unit id="076f63ae0f418e3862988b172f7c4cc5852450a8" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">중복 된 항목이 제거되고 최신 항목이 우선합니다. 달리 &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt; , &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; 키가 고유 보장합니다.</target>
        </trans-unit>
        <trans-unit id="64aa4fe0da505292ed7a57df0b239e0d4183ccec" translate="yes" xml:space="preserve">
          <source>Duplicated keys appear duplicated in the final list of keys.</source>
          <target state="translated">중복 키는 최종 키 목록에 중복 된 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="efdd2fd6681b594f9b79a82e9b5aa48b4fbf5e9b" translate="yes" xml:space="preserve">
          <source>Duplicated keys are not removed.</source>
          <target state="translated">중복 키는 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac53e68a8e0e729bf98aeec7ce7b6340de177d35" translate="yes" xml:space="preserve">
          <source>Duplicated keys are preserved in the new keyword list.</source>
          <target state="translated">중복 된 키는 새 키워드 목록에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b6f1eeffe99ed90517ec6eae526962d142636d" translate="yes" xml:space="preserve">
          <source>Duplicated keys are removed; the latest one prevails.</source>
          <target state="translated">중복 키가 제거됩니다. 최신이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9ba8d07a9bc46aeb1c779fab12a8b4dd715ff170" translate="yes" xml:space="preserve">
          <source>Duplicates the given element &lt;code&gt;n&lt;/code&gt; times in a list.</source>
          <target state="translated">주어진 요소를 목록에서 &lt;code&gt;n&lt;/code&gt; 번 복제합니다 .</target>
        </trans-unit>
        <trans-unit id="612d35050e691a1a2b9f22fe6b8f2fde9cb8f9d1" translate="yes" xml:space="preserve">
          <source>Dynamic dispatch</source>
          <target state="translated">동적 디스패치</target>
        </trans-unit>
        <trans-unit id="edd7dafc098b4b13db6ad466bd4e821198c0337f" translate="yes" xml:space="preserve">
          <source>Dynamic names</source>
          <target state="translated">동적 이름</target>
        </trans-unit>
        <trans-unit id="46d2782a295d697a8b9e27c2d91c25f66bfd854d" translate="yes" xml:space="preserve">
          <source>Dynamic supervisors</source>
          <target state="translated">동적 감독자</target>
        </trans-unit>
        <trans-unit id="3aa9130077fcc44c7eb24ab3a909359998b572f0" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor</source>
          <target state="translated">DynamicSupervisor</target>
        </trans-unit>
        <trans-unit id="4981d257018e7d749e02934b79c0b6bdb94f8f95" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">DynamicSupervisor &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7ba279830cac8f3b7ac440b34f16c258d525250e" translate="yes" xml:space="preserve">
          <source>Dynamically adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">자식 사양을 &lt;code&gt;supervisor&lt;/code&gt; 에게 동적으로 추가하고 해당 자식을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="887cf55c60fc1c9af6689bd5e2a2c3b3766133c3" translate="yes" xml:space="preserve">
          <source>Dynamically supervised tasks</source>
          <target state="translated">동적으로 감독되는 작업</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="5b16ec2483e166fe049f665c022763eabe66f30f" translate="yes" xml:space="preserve">
          <source>EEx</source>
          <target state="translated">EEx</target>
        </trans-unit>
        <trans-unit id="af3993684170f3f24c787f9d7ffb881775da9c68" translate="yes" xml:space="preserve">
          <source>EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file.</source>
          <target state="translated">EEx에는 주어진 문자열이나 파일에서 추출 된 코드를 수정하거나 변형 할 수있는 엔진 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="818fc332cfd248836c5442317677dfe04bdbbd73" translate="yes" xml:space="preserve">
          <source>EEx stands for Embedded Elixir. It allows you to embed Elixir code inside a string in a robust way.</source>
          <target state="translated">EEx는 Embedded Elixir의 약자입니다. 강력한 방식으로 문자열 안에 Elixir 코드를 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22a24f67ecb347cc9015ff6237454fdbf0669653" translate="yes" xml:space="preserve">
          <source>EEx.Engine &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">EEx 엔진 &lt;small&gt;작동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eebf2acaee05e7c09c816457012d68bbfc96c6f3" translate="yes" xml:space="preserve">
          <source>EEx.SmartEngine</source>
          <target state="translated">EEx.SmartEngine</target>
        </trans-unit>
        <trans-unit id="674e9c18d21c34b87c83982cf9afa4d95159a4be" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError</source>
          <target state="translated">EEx.SyntaxError</target>
        </trans-unit>
        <trans-unit id="49bba56082c8e3c9fff304ab7864ed3cb3a25fb5" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">EEx.SyntaxError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="98d18c239604c617df6f8788536838fd25d8c03d" translate="yes" xml:space="preserve">
          <source>EEx: &lt;code&gt;&amp;lt;%=&lt;/code&gt; in middle and end expressions</source>
          <target state="translated">EEx : 중간 및 끝 표현식에서 &lt;code&gt;&amp;lt;%=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b4d835a11a6493d1e10defe1536a05fda39d532" translate="yes" xml:space="preserve">
          <source>ELixir tracks three types of dependencies between modules: compile, exports, and runtime. If a module has a compile time dependency on another module, the caller module has to be recompiled whenever the callee changes. Compile-time dependencies are typically added when using macros or when invoking functions in the module body (outside of functions).</source>
          <target state="translated">ELixir는 컴파일, 내보내기 및 런타임의 세 가지 유형의 모듈 간의 종속성을 추적합니다. 모듈에 다른 모듈에 대한 컴파일 시간 종속성이있는 경우 호출 수신자가 변경 될 때마다 호출자 모듈을 다시 컴파일해야합니다. 컴파일 시간 종속성은 일반적으로 매크로를 사용하거나 모듈 본문 (함수 외부)에서 함수를 호출 할 때 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7eceb14d6ed554f3e39c3487db659c8d63e28acd" translate="yes" xml:space="preserve">
          <source>ETS</source>
          <target state="translated">ETS</target>
        </trans-unit>
        <trans-unit id="1500176ef8cc8bfbbaf08eb4c1316bcf890f3395" translate="yes" xml:space="preserve">
          <source>ETS (Erlang Term Storage)</source>
          <target state="translated">ETS (Erlang 용어 저장소)</target>
        </trans-unit>
        <trans-unit id="4f5a2cc3fa91eb59c67ada064593bcea69c5e3b4" translate="yes" xml:space="preserve">
          <source>ETS allows us to store any Elixir term in an in-memory table. Working with ETS tables is done via &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:ets&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">ETS를 사용하면 메모리 내 테이블에 Elixir 용어를 저장할 수 있습니다. ETS 테이블 작업은 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang의 &lt;code&gt;:ets&lt;/code&gt; 모듈을&lt;/a&gt; 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e8dd8378100a7f6cf535d73f581bb5835a296a0" translate="yes" xml:space="preserve">
          <source>ETS as a cache</source>
          <target state="translated">캐시로서의 ETS</target>
        </trans-unit>
        <trans-unit id="0c6b672feadc74b2fa303a786fd5682cec52505f" translate="yes" xml:space="preserve">
          <source>ETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.</source>
          <target state="translated">ETS를 사용하면 튜플이 포함 된 테이블을 만들 수 있습니다. 기본적으로 ETS 테이블은 보호되므로 소유자 프로세스 만 테이블에 쓸 수 있지만 다른 프로세스는 읽을 수 있습니다. ETS에는 테이블을 간단한 데이터베이스, 키-값 저장소 또는 캐시 메커니즘으로 사용할 수있는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52adb6284390fce5741221672f061e71df403d05" translate="yes" xml:space="preserve">
          <source>ETS tables can also be named, allowing us to access them by a given name:</source>
          <target state="translated">ETS 테이블의 이름도 지정할 수 있으므로 지정된 이름으로 테이블에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="362cea4d522d64f424e9ad3e438c8000b26fb5c9" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;enumerable&lt;/code&gt; element is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be linked to the current process, similarly to &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 과 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="c70223b508f5fb20c656733438516d9c4a38e207" translate="yes" xml:space="preserve">
          <source>Each application has an environment that stores the application&amp;rsquo;s specific configuration by key. For example, we could store the routing table in the &lt;code&gt;:kv&lt;/code&gt; application environment, giving it a default value and allowing other applications to change the table as needed.</source>
          <target state="translated">각 응용 프로그램에는 키별로 응용 프로그램의 특정 구성을 저장하는 환경이 있습니다. 예를 들어 라우팅 테이블을 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 환경 에 저장하여 기본값을 제공하고 필요에 따라 다른 응용 프로그램에서 테이블을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3405035bc16c9169ba3e4eb3a0b15b99fd33b0e0" translate="yes" xml:space="preserve">
          <source>Each application has its own environment. The environment is a keyword list that maps atoms to terms. Note that this environment is unrelated to the operating system environment.</source>
          <target state="translated">각 응용 프로그램에는 고유 한 환경이 있습니다. 환경은 원자를 용어에 매핑하는 키워드 목록입니다. 이 환경은 운영 체제 환경과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="30b77596010e1d94e168b64218473fa0c4476548" translate="yes" xml:space="preserve">
          <source>Each application in our system can be started and stopped. The rules for starting and stopping an application are also defined in the &lt;code&gt;.app&lt;/code&gt; file. When we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, Mix compiles our application and then starts it.</source>
          <target state="translated">시스템의 각 응용 프로그램을 시작하고 중지 할 수 있습니다. 응용 프로그램 시작 및 중지 규칙도 &lt;code&gt;.app&lt;/code&gt; 파일에 정의되어 있습니다. &lt;code&gt;iex -S mix&lt;/code&gt; 를 호출하면 Mix가 응용 프로그램을 컴파일 한 다음 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6ee7cee4e35c13e97e0b113c7ad93de2b2e9f9ff" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/2&quot;&gt;&lt;code&gt;async/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 아래에 생성되고 &lt;a href=&quot;#async/2&quot;&gt; &lt;code&gt;async/2&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bff2b054449ef93f88ae378fceaa7c3773b512d" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성 되며 &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f8ff31374c6e0e1792073cfd7bf59921a2ee8196" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성 되며 &lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e074b39ec3a1ed372a909c0a3201829b19421e8" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be linked to an intermediate process that is then linked to the current process. This means a failure in a task terminates the current process and a failure in the current process terminates all tasks.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 중간 프로세스에 연결되고 현재 프로세스에 연결됩니다. 이는 작업 실패가 현재 프로세스를 종료하고 현재 프로세스가 실패하면 모든 작업이 종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ea81b39bec07b5eca51e7cb8e73b08cc88b185e5" translate="yes" xml:space="preserve">
          <source>Each element will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/4&quot;&gt;&lt;code&gt;async/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 요소는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 주어진 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성되고 &lt;a href=&quot;#async/4&quot;&gt; &lt;code&gt;async/4&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6a3bdb3211b725603f1e420065f9f512a455e5f" translate="yes" xml:space="preserve">
          <source>Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">레지스트리의 각 항목은 키를 등록한 프로세스와 연결됩니다. 프로세스가 충돌하면 해당 프로세스와 관련된 키가 자동으로 제거됩니다. 레지스트리의 모든 키 비교는 일치 작업 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; )을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="77459e85ee4402d66fd92ef0b7844cafe8faeccd" translate="yes" xml:space="preserve">
          <source>Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">레지스트리의 각 항목은 키를 등록한 프로세스와 연관됩니다. 프로세스가 충돌하면 해당 프로세스와 관련된 키가 자동으로 제거됩니다. 레지스트리의 모든 키 비교는 일치 작업 ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; )을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f51dcc2b38618bcc3fe87f6cb31bfc9d58a91577" translate="yes" xml:space="preserve">
          <source>Each item in the list is a map with the following keys:</source>
          <target state="translated">목록의 각 항목은 다음 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="532f0099dc0a59c8142722d964bd46289ef70cfc" translate="yes" xml:space="preserve">
          <source>Each key-value pair in the map is converted to a two-element tuple &lt;code&gt;{key, value}&lt;/code&gt; in the resulting list.</source>
          <target state="translated">맵의 각 키-값 쌍 은 결과 목록에서 두 요소 튜플 &lt;code&gt;{key, value}&lt;/code&gt; 로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4934170f741619738531430df9405d17c3b39b24" translate="yes" xml:space="preserve">
          <source>Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:</source>
          <target state="translated">각 모듈은 하나 이상의 속성으로 꾸밀 수 있습니다. 다음은 현재 Elixir에서 정의한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ac8e172618067a3e6bc12be54b49bfe15535ac3" translate="yes" xml:space="preserve">
          <source>Each module gets an &lt;code&gt;__info__/1&lt;/code&gt; function when it's compiled. The function takes one of the following items:</source>
          <target state="translated">각 모듈은 컴파일 될 때 &lt;code&gt;__info__/1&lt;/code&gt; 함수를 얻습니다 . 이 기능은 다음 항목 중 하나를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e4ebc93808a7013b1682e04607e3d5c0727d33dc" translate="yes" xml:space="preserve">
          <source>Each number given to a binary is meant to represent a byte and therefore must go up to 255. Binaries allow modifiers to be given to store numbers bigger than 255 or to convert a code point to its UTF-8 representation:</source>
          <target state="translated">바이너리에 주어진 각 숫자는 바이트를 나타 내기 때문에 255까지 올라 가야합니다. 바이너리는 수정자가 255보다 큰 숫자를 저장하거나 코드 포인트를 UTF-8 표현으로 변환 할 수 있도록합니다 :</target>
        </trans-unit>
        <trans-unit id="86d9329e1ed2a43e214726a374900569c7bc6fae" translate="yes" xml:space="preserve">
          <source>Each process started with the application must be listed as a child under the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">신청서와 함께 시작된 각 프로세스는 위 의 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 아래에 하위로 나열되어야합니다 . 이러한 프로세스는 미리 알려져 있기 때문에 &quot;정적 프로세스&quot;라고 부릅니다. 요청 및 기타 사용자 입력 중에 시작된 것과 같은 동적 프로세스를 처리하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="372725c1f82abeb98e09b054fcea454db1d9af25" translate="yes" xml:space="preserve">
          <source>Each process started with the application must be listed as a child under the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">응용 프로그램으로 시작된 각 프로세스는 위 의 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 아래 자식으로 표시되어야합니다 . 이를 &quot;정적 프로세스&quot;라고합니다. 요청 및 기타 사용자 입력 중에 시작된 것과 같은 동적 프로세스를 처리하려면 &lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b076bdb70baef474140c948c212f1de89050946f" translate="yes" xml:space="preserve">
          <source>Each registered SCM will be asked if they consume this dependency, receiving &lt;code&gt;[github: &quot;foo/bar&quot;]&lt;/code&gt; as argument. Since this option makes sense for the Git SCM, it will return an update list of options while other SCMs would simply return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">등록 된 각 SCM은이 종속성을 사용하는지 묻고 &lt;code&gt;[github: &quot;foo/bar&quot;]&lt;/code&gt; 를 인수로받습니다. 이 옵션은 Git SCM에 적합하므로 다른 SCM은 단순히 &lt;code&gt;nil&lt;/code&gt; 을 반환하는 반면 업데이트 옵션 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0c52364e96da340fb31c3249f2e8693baeb5686f" translate="yes" xml:space="preserve">
          <source>Each task has its own options and sometimes specific configuration to be defined in the &lt;code&gt;project/0&lt;/code&gt; function. You can use &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; to list all available tasks and &lt;code&gt;mix help NAME&lt;/code&gt; to show help for a particular task.</source>
          <target state="translated">각 작업에는 자체 옵션이 있으며 때로는 &lt;code&gt;project/0&lt;/code&gt; 기능 에서 정의 할 특정 구성이 있습니다 . &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 을 사용하여 사용 가능한 모든 작업을 나열하고 &lt;code&gt;mix help NAME&lt;/code&gt; 을 혼합 하여 특정 작업에 대한 도움말을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a597396bbd78d869061e9cc988eca475a9257e" translate="yes" xml:space="preserve">
          <source>Each task has its own options and sometimes specific configuration to be defined in the &lt;code&gt;project/0&lt;/code&gt; function. You can use &lt;a href=&quot;mix.tasks.help&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; to list all available tasks and &lt;code&gt;mix help NAME&lt;/code&gt; to show help for a particular task.</source>
          <target state="translated">각 작업에는 고유 한 옵션이 있으며 때로는 &lt;code&gt;project/0&lt;/code&gt; 기능 에서 정의 할 특정 구성이 있습니다 . &lt;a href=&quot;mix.tasks.help&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 을 사용하여 사용 가능한 모든 작업을 나열하고 &lt;code&gt;mix help NAME&lt;/code&gt; 을 사용하여 특정 작업에 대한 도움말을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcac1b6f9d120c9722086c7e508489b0226da684" translate="yes" xml:space="preserve">
          <source>Each variable is identified by a tuple of two elements, where the first element is the variable name as an atom and the second element is its context, which may be an atom or an integer.</source>
          <target state="translated">각 변수는 두 요소의 튜플로 식별되며, 첫 번째 요소는 변수 이름이며 원자는 두 번째 요소이며 컨텍스트는 원자 또는 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68310c7d97bd5e9d47967e9e9edcb285e94d70ff" translate="yes" xml:space="preserve">
          <source>Eager to learn more? Keep reading!</source>
          <target state="translated">더 배우고 싶어? 계속 읽으세요!</target>
        </trans-unit>
        <trans-unit id="773015863b8b24712e29c53fe98994b9728f6381" translate="yes" xml:space="preserve">
          <source>Eager vs Lazy</source>
          <target state="translated">열망 대 지연</target>
        </trans-unit>
        <trans-unit id="28ac06af2cb7839cf14f9821c41dfad421032a0a" translate="yes" xml:space="preserve">
          <source>Echo server</source>
          <target state="translated">에코 서버</target>
        </trans-unit>
        <trans-unit id="eeccb169551120a3e6a633e63e844185e028c154" translate="yes" xml:space="preserve">
          <source>Edit the file at &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, filling in the blanks for the client API:</source>
          <target state="translated">&lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 파일을 편집하여 클라이언트 API의 공백을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ddd5726bf13c26ce5252aef42e6ba8f0c851bd53" translate="yes" xml:space="preserve">
          <source>Elements are compared using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 요소를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="25857c2157bff6e7a9f798c89b04873173125f2d" translate="yes" xml:space="preserve">
          <source>Elements are compared using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 요소를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="b1bc7fb1f226e6f6f3ef7ee47c49d49289229118" translate="yes" xml:space="preserve">
          <source>Elements are only emitted when &lt;code&gt;fun&lt;/code&gt; returns a new value or the &lt;code&gt;enum&lt;/code&gt; finishes.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 fun 이 새로운 값을 반환하거나 &lt;code&gt;enum&lt;/code&gt; 이 완료 될 때만 방출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a38ddcfce78b5b0835df229de1f7e325877919bd" translate="yes" xml:space="preserve">
          <source>Elements can be inserted using &lt;a href=&quot;#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#put/2&quot;&gt; &lt;code&gt;MapSet.put/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 요소를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9167aadfec3df02db420d4d2b50af0ffd51604f5" translate="yes" xml:space="preserve">
          <source>Elements in a set don't have to be of the same type and they can be populated from an &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#t:t/0&quot;&gt;enumerable&lt;/a&gt; using &lt;a href=&quot;#new/1&quot;&gt;&lt;code&gt;MapSet.new/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">집합의 요소는 동일한 유형일 필요가 &lt;a href=&quot;#new/1&quot;&gt; &lt;code&gt;MapSet.new/1&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#t:t/0&quot;&gt;열거 가능 항목&lt;/a&gt; 에서 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0c7bf14304705b88f3bf9ecdfcf919293c76e53" translate="yes" xml:space="preserve">
          <source>Elixir</source>
          <target state="translated">Elixir</target>
        </trans-unit>
        <trans-unit id="e5c4daa79e73a93f8dc527746d72ef1e1f99e8dd" translate="yes" xml:space="preserve">
          <source>Elixir 1.5.0 onwards</source>
          <target state="translated">엘릭서 1.5.0 이상</target>
        </trans-unit>
        <trans-unit id="67dd209de0ff8f0eac333c13b028cb684c348812" translate="yes" xml:space="preserve">
          <source>Elixir 1.9.0 onwards</source>
          <target state="translated">엘릭서 1.9.0 이후</target>
        </trans-unit>
        <trans-unit id="bff9443fa7cf4ae0bab8d5c8f1f4dab57c2d5acf" translate="yes" xml:space="preserve">
          <source>Elixir Forum</source>
          <target state="translated">엘릭서 포럼</target>
        </trans-unit>
        <trans-unit id="de61752fa33c065b078b47c60fdefbfedf94b579" translate="yes" xml:space="preserve">
          <source>Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as &lt;code&gt;@moduledoc&lt;/code&gt;, &lt;code&gt;@typedoc&lt;/code&gt;, and &lt;code&gt;@doc&lt;/code&gt;). A commonly used metadata is &lt;code&gt;:since&lt;/code&gt;, which annotates in which version that particular module, function, type, or callback was added, as shown in the example above.</source>
          <target state="translated">Elixir를 사용하면 개발자가 임의의 메타 데이터를 문서에 첨부 할 수 있습니다. 키워드 목록을 관련 속성 (예 : &lt;code&gt;@moduledoc&lt;/code&gt; , &lt;code&gt;@typedoc&lt;/code&gt; 및 &lt;code&gt;@doc&lt;/code&gt; )에 전달하면됩니다. 일반적으로 사용되는 메타 데이터는 &lt;code&gt;:since&lt;/code&gt; 이며, 위의 예와 같이 특정 모듈, 함수, 유형 또는 콜백이 추가 된 버전에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3c0ee4efd422df64d926e1699ce27c5bdf0b25e6" translate="yes" xml:space="preserve">
          <source>Elixir allows integers to contain &lt;code&gt;_&lt;/code&gt; to separate digits and provides conveniences to represent integers in other bases:</source>
          <target state="translated">Elixir는 정수에 &lt;code&gt;_&lt;/code&gt; 를 포함 하여 숫자를 구분하고 다른 기준에서 정수를 표현할 수있는 편의성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f75c26877ef871217ff6769618e4b459e83b4aa9" translate="yes" xml:space="preserve">
          <source>Elixir allows us to derive a protocol implementation based on the &lt;code&gt;Any&lt;/code&gt; implementation. Let&amp;rsquo;s first implement &lt;code&gt;Any&lt;/code&gt; as follows:</source>
          <target state="translated">Elixir를 사용하면 &lt;code&gt;Any&lt;/code&gt; 구현을 기반으로 프로토콜 구현을 도출 할 수 있습니다 . 먼저 다음과 같이 &lt;code&gt;Any&lt;/code&gt; 를 구현해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="83c382416abbdb750f7a0b52274c72d3eeffa512" translate="yes" xml:space="preserve">
          <source>Elixir allows variables to be rebound via static single assignment:</source>
          <target state="translated">Elixir를 사용하면 정적 단일 할당을 통해 변수를 리바운드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0d77b67e657e2b9066c1ff6972927494c31617" translate="yes" xml:space="preserve">
          <source>Elixir allows you to skip the leading &lt;code&gt;:&lt;/code&gt; for the atoms &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">비약은 최고의 건너 뛸 수 있습니다 &lt;code&gt;:&lt;/code&gt; 원자에 대한 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="413742c1494e68731a98eab50395aa0ab07b3d83" translate="yes" xml:space="preserve">
          <source>Elixir allows you to skip the leading &lt;code&gt;:&lt;/code&gt; for the atoms &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">비약은 최고의 건너 뛸 수 있습니다 &lt;code&gt;:&lt;/code&gt; 원자에 대한 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; , 그리고 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39ff842a6a4a3cf98a11fae4fd4498e3695c470e" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code.&lt;/strong&gt;</source>
          <target state="translated">Elixir는 이미 데이터 구조와 함수를 사용하여 일상의 코드를 간단하고 읽기 쉬운 방식으로 작성하는 메커니즘을 제공합니다. 매크로는 최후의 수단으로 만 사용해야합니다. &lt;strong&gt;명시 적이 암시 적보다 낫다는&lt;/strong&gt; 것을 기억하십시오 . &lt;strong&gt;명확한 코드는 간결한 코드보다 낫습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c84bd869e800cf00a0f15faeb1fec6f09ff020" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code&lt;/strong&gt;.</source>
          <target state="translated">Elixir는 이미 데이터 구조와 함수를 사용하여 일상의 코드를 간단하고 읽기 쉬운 방식으로 작성하는 메커니즘을 제공합니다. 매크로는 최후의 수단으로 만 사용해야합니다. &lt;strong&gt;명시 적이 암시 적보다 낫다는&lt;/strong&gt; 것을 기억하십시오 . &lt;strong&gt;명확한 코드는 간결한 코드보다 낫습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="04d508ddfa3159bfde64248d0cbc115d950cb551" translate="yes" xml:space="preserve">
          <source>Elixir also accepts by default the segment to be a literal string or a literal charlist, which are by default expanded to integers:</source>
          <target state="translated">또한 엘릭서는 기본적으로 세그먼트를 리터럴 문자열 또는 리터럴 문자리스트로 받아들이며, 기본적으로 정수로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="738cbc7a97733fcad20b5d4c9dce828da97453d5" translate="yes" xml:space="preserve">
          <source>Elixir also allows developers to enforce certain keys must always be given when building the struct:</source>
          <target state="translated">Elixir는 또한 개발자가 구조체를 만들 때 항상 특정 키를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2aeb44fb689a73ee1106300bdf2d7f03241fd14" translate="yes" xml:space="preserve">
          <source>Elixir also contains an &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; function that is a superset of &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir는 또한 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; 의 수퍼 셋 인 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 함수를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="1ca22ed394bb9b18d990dbe14484b3d50b19e9ce" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir에는 항상 가져 와서 건너 뛸 수없는 특수 양식이 있습니다. 이것들은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; &lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bac89af66dd6a427b4aa3efe3deb03cf5a1fe14" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;kernel.specialforms&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">엘릭서에는 또한 항상 가져 와서 건너 뛸 수없는 특수 양식이 있습니다. 이것들은 &lt;a href=&quot;kernel.specialforms&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; &lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d27fae45dd0d77eb7585ffc475445da313d3682e" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="translated">: 엘릭서는 이중 밑줄 형식에 따라 5 개 개의 특수 형태 포함 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; 현재 환경에 대한 컴파일 시간 정보를 검색하는 동안 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 를 검색 현재 예외의 스택 트레이스.</target>
        </trans-unit>
        <trans-unit id="f6faa91bfb900d671613a6ab47e73da0ae09fa34" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="translated">또한 Elixir는 이중 밑줄 형식을 따르는 5 가지 특수 형식을 포함합니다. &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; 현재 환경에 대한 컴파일 타임 정보를 검색하는 반면 &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 은 현재 예외에 대한 스택 추적을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="243375bae75a446726d90d677eb7c983b489e516" translate="yes" xml:space="preserve">
          <source>Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given.</source>
          <target state="translated">또한 Elixir는 유효하지 않은 인수가 제공 될 경우 명확한 오류 메시지를 제공하기 위해 함수 절의 패턴 일치 및 가드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e898bf471d8f0d3097ac913073c090b0a995d7eb" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; to manipulate lists:</source>
          <target state="translated">또한 Elixir는 &lt;code&gt;++&lt;/code&gt; 및 &lt;code&gt;--&lt;/code&gt; 를 제공하여 목록을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="ac31c787a75befbe1897dbbb6fdd942221f00c86" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; as comparison operators:</source>
          <target state="translated">엘릭서 또한 제공 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;===&lt;/code&gt; , &lt;code&gt;!==&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 비교 연산자로서 :</target>
        </trans-unit>
        <trans-unit id="969c208849fcc11446141a26b255b57b75a2b0ba" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;Reference&lt;/code&gt;, and &lt;code&gt;PID&lt;/code&gt; as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let&amp;rsquo;s take a look at some of the basic operators that go with our basic types.</source>
          <target state="translated">또한 Elixir는 &lt;code&gt;Port&lt;/code&gt; , &lt;code&gt;Reference&lt;/code&gt; 및 &lt;code&gt;PID&lt;/code&gt; 를 데이터 유형 (일반적으로 프로세스 통신에 사용)으로 제공하며 프로세스에 대해 이야기 할 때이를 살펴볼 것입니다. 지금은 기본 유형과 함께 제공되는 기본 연산자 중 일부를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dd8a8082108a2f1897c7e7583cc32113fdc162fe" translate="yes" xml:space="preserve">
          <source>Elixir also provides anonymous functions. Anonymous functions allow us to store and pass executable code around as if it was an integer or a string. They are delimited by the keywords &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">엘릭서는 또한 익명의 기능을 제공합니다. 익명 함수를 사용하면 실행 코드를 마치 정수 나 문자열 인 것처럼 저장하고 전달할 수 있습니다. 키워드 &lt;code&gt;fn&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6f4bfc221320e14428c9be4379f06c74f568d51" translate="yes" xml:space="preserve">
          <source>Elixir also provides other data types that are built on top of the types listed above. Some of them are:</source>
          <target state="translated">Elixir는 위에 나열된 유형 위에 구축 된 다른 데이터 유형도 제공합니다. 그들 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cf0686be60034d3cedafe5362a85407c3741f2a" translate="yes" xml:space="preserve">
          <source>Elixir also provides ranges:</source>
          <target state="translated">엘릭서는 또한 다음과 같은 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5fcce84b0f48ff34d06fe32176864fe647eb61ef" translate="yes" xml:space="preserve">
          <source>Elixir also provides three boolean operators: &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;. These operators are strict in the sense that they expect something that evaluates to a boolean (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) as their first argument:</source>
          <target state="translated">엘릭서는 세 가지 부울 연산자를 제공 &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;not&lt;/code&gt; . 이 연산자는 첫 번째 인수로 부울 ( &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )로 평가되는 것을 기대한다는 점에서 엄격합니다 .</target>
        </trans-unit>
        <trans-unit id="8d3fab2e2b3e4ed4bda1748059118a3b75cf1e13" translate="yes" xml:space="preserve">
          <source>Elixir also supports &lt;code&gt;left not in right&lt;/code&gt;, which evaluates to &lt;code&gt;not(left in right)&lt;/code&gt;:</source>
          <target state="translated">비약도 지원이 &lt;code&gt;left not in right&lt;/code&gt; 으로 평가, &lt;code&gt;not(left in right)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5a36737e425de601f0dbbe73bf7e68eed9cd0ed3" translate="yes" xml:space="preserve">
          <source>Elixir also supports Unicode in identifiers since Elixir v1.5, as defined in the &lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode Annex #31&lt;/a&gt;. The focus of this document is to describe how Elixir implements the requirements outlined in the Unicode Annex. These requirements are referred to as R1, R6 and so on.</source>
          <target state="translated">Elixir는 또한 &lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode Annex # 31에&lt;/a&gt; 정의 된 것처럼 Elixir v1.5부터 식별자에서 유니 코드를 지원합니다 . 이 문서의 초점은 Elixir가 Unicode Annex에 요약 된 요구 사항을 구현하는 방법을 설명하는 것입니다. 이러한 요구 사항을 R1, R6 등이라고합니다.</target>
        </trans-unit>
        <trans-unit id="831831bd1adbcc4e3da08a8f57e2923a4e93799a" translate="yes" xml:space="preserve">
          <source>Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following:</source>
          <target state="translated">Elixir는 또한 호출의 마지막 인수가 키워드 목록 인 경우 대괄호를 건너 뛸 수있는 구문을 지원합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e5d64f0301ab6ac559b63f1c82cbf0dfd37dce82" translate="yes" xml:space="preserve">
          <source>Elixir also supports formatting Erlang reports using Elixir syntax. This can be controlled with two configurations:</source>
          <target state="translated">Elixir는 또한 Elixir 구문을 사용하여 Erlang 보고서 형식을 지원합니다. 이는 두 가지 구성으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51de5cd58455d962f06640f299cca5e324e9a622" translate="yes" xml:space="preserve">
          <source>Elixir also supports private macros via &lt;code&gt;defmacrop&lt;/code&gt;. As private functions, these macros are only available inside the module that defines them, and only at compilation time.</source>
          <target state="translated">Elixir는 또한 &lt;code&gt;defmacrop&lt;/code&gt; 을 통해 개인 매크로를 지원합니다 . 전용 함수로서,이 매크로는 모듈을 정의하는 모듈 내에서만 컴파일 타임에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11824c210053777bec7ddf3a89c32be210d45f2" translate="yes" xml:space="preserve">
          <source>Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:</source>
          <target state="translated">Elixir는 이진수, 8 진수 및 16 진수를 입력하기위한 단축키 표기법도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6b48fb3c07925bbce80ec4c8c677ff0705ab892b" translate="yes" xml:space="preserve">
          <source>Elixir also supports string interpolation:</source>
          <target state="translated">엘릭서는 문자열 보간도 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="f27c2220090ae1ef4a23c356a5a485deee8ca35d" translate="yes" xml:space="preserve">
          <source>Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:</source>
          <target state="translated">Elixir는 최신 부 지점에만 버그 수정을 적용합니다. 최근 5 개의 부 지점에 대한 보안 패치가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cda5c07ad4a993425301fa7396f1616f92211ddb" translate="yes" xml:space="preserve">
          <source>Elixir backends can be configured directly under the &lt;code&gt;:logger&lt;/code&gt; application in your &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">Elixir 백엔드는 &lt;code&gt;config/config.exs&lt;/code&gt; 의 &lt;code&gt;:logger&lt;/code&gt; 응용 프로그램 아래에서 직접 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e561bb8baee392958755d80698909955398d5251" translate="yes" xml:space="preserve">
          <source>Elixir backends run in a separate process which comes with overload protection. However, because this process is a single GenEvent, any long running action should be avoided, as it can lead to bottlenecks in the system</source>
          <target state="translated">Elixir 백엔드는 과부하 보호와 함께 제공되는 별도의 프로세스에서 실행됩니다. 그러나이 프로세스는 단일 GenEvent이므로 시스템에 병목 현상이 발생할 수 있으므로 장기 실행 작업은 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="1480fcb21427da507d41fe00e9730d3102cc1601" translate="yes" xml:space="preserve">
          <source>Elixir brings the concept of module attributes from Erlang. For example:</source>
          <target state="translated">Elixir는 Erlang의 모듈 속성 개념을 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f52903a1f8e7fe32784dca96bfb06586e6419189" translate="yes" xml:space="preserve">
          <source>Elixir build information.</source>
          <target state="translated">엘릭서 빌드 정보.</target>
        </trans-unit>
        <trans-unit id="b2a6e08225deb1351d7c526d4a6fc2d20b9e7df8" translate="yes" xml:space="preserve">
          <source>Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:</source>
          <target state="translated">Elixir에는 유형 및 사양을 선언하는 표기법이 있습니다. Elixir는 동적으로 유형이 지정된 언어이므로 컴파일러에서 코드를 최적화하거나 수정하기 위해 형식 사양을 사용하지 않습니다. 여전히 타입 스펙을 사용하면 다음과 같은 이유로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="93e98cb33410c274eb01c0b51b9f879f209f597d" translate="yes" xml:space="preserve">
          <source>Elixir converts switches to underscored atoms, so &lt;code&gt;--source-path&lt;/code&gt; becomes &lt;code&gt;:source_path&lt;/code&gt;. This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches.</source>
          <target state="translated">Elixir는 스위치를 밑줄이있는 원자로 변환하므로 &lt;code&gt;--source-path&lt;/code&gt; 는 &lt;code&gt;:source_path&lt;/code&gt; 가 됩니다. 이것은 엘릭서 관습에 더 잘 맞게하기 위해 수행됩니다. 그러나 이는 스위치에 밑줄을 포함 할 수없고 밑줄을 포함하는 스위치는 항상 유효하지 않은 스위치 목록으로 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c34f7340cb61df5785bd5c3a3996417777eeba7" translate="yes" xml:space="preserve">
          <source>Elixir custom backends</source>
          <target state="translated">Elixir 커스텀 백엔드</target>
        </trans-unit>
        <trans-unit id="515cdde695b80400042e85d03697fe8c3de3f321" translate="yes" xml:space="preserve">
          <source>Elixir deprecations happen in 3 steps:</source>
          <target state="translated">엘릭서 지원 중단은 3 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="408fc2d27b6f9604c990c32c8ff3bc032eba3849" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, and the like:</source>
          <target state="translated">Elixir 개발자는 변수, 함수 이름, 모듈 속성 등을 정의 할 때 &lt;code&gt;snake_case&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ea52283db054d97df43a259e29d9ebc73278a8f" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, etc.:</source>
          <target state="translated">엘릭서 개발자는 변수, 함수 이름, 모듈 속성 등을 정의 할 때 &lt;code&gt;snake_case&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fdde18bd0e2fa1e6f5b249dcbd96934a496c8e2" translate="yes" xml:space="preserve">
          <source>Elixir developers often use module attributes when they wish to make a value more visible or reusable:</source>
          <target state="translated">Elixir 개발자는 값을 더 잘 보이게하거나 재사용 할 수 있도록 모듈 속성을 자주 사용합니다.</target>
        </trans-unit>
        <trans-unit id="67460a48d2b2975fa71d28207c9deda3618cb78d" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;This blog post&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="translated">Elixir 개발자는 일반적으로 맵 작업시 &lt;code&gt;Map&lt;/code&gt; 모듈 의 함수 대신 &lt;code&gt;map.field&lt;/code&gt; 구문 및 패턴 일치 를 사용하는 것이 선호됩니다 . 이는 독창적 인 스타일의 프로그래밍으로 이어지기 때문입니다. &lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;이 블로그 포스트&lt;/a&gt; 는 Elixir에서 주장 코드를 작성하여보다 간결하고 빠른 소프트웨어를 얻는 방법에 대한 통찰력과 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a06f21bbf8d0fbad80b3654800782c5ec40cbcc7" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;https://dashbit.co/blog/writing-assertive-code-with-elixir&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="translated">Elixir 개발자는 일반적으로 &lt;code&gt;Map&lt;/code&gt; 작업 할 때 Map 모듈 의 함수 대신 &lt;code&gt;map.field&lt;/code&gt; 구문 및 패턴 일치 를 사용하는 것을 선호합니다. 이는 확실한 프로그래밍 스타일로 이어지기 때문입니다. &lt;a href=&quot;https://dashbit.co/blog/writing-assertive-code-with-elixir&quot;&gt;Jos&amp;eacute; Valim의이 블로그 게시물&lt;/a&gt; 은 Elixir에서 단정적 인 코드를 작성하여보다 간결하고 빠른 소프트웨어를 얻는 방법에 대한 통찰력과 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c6ccd31147a48e978a78387a61b5eaefec5c15c1" translate="yes" xml:space="preserve">
          <source>Elixir developers will often use module attributes as constants:</source>
          <target state="translated">엘릭서 개발자들은 종종 모듈 속성을 상수로 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="7edf337af4809fac0491b9f969182b600dc4a216" translate="yes" xml:space="preserve">
          <source>Elixir discourages the use of the &lt;code&gt;string()&lt;/code&gt; type. The &lt;code&gt;string()&lt;/code&gt; type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type &lt;code&gt;string()&lt;/code&gt;, Elixir will emit a warning. You should use &lt;code&gt;charlist()&lt;/code&gt;, &lt;code&gt;nonempty_charlist()&lt;/code&gt;, &lt;code&gt;binary()&lt;/code&gt; or &lt;code&gt;String.t()&lt;/code&gt; accordingly, or any of the several literal representations for these types.</source>
          <target state="translated">엘릭서는 &lt;code&gt;string()&lt;/code&gt; 타입 의 사용을 권장하지 않습니다 . &lt;code&gt;string()&lt;/code&gt; 타입의 만능 &quot;charlists&quot;라고도 얼랑 문자열을 말한다. UTF-8로 인코딩 된 바이너리 인 Elixir 문자열은 참조하지 않습니다. 혼동을 피하기 위해 &lt;code&gt;string()&lt;/code&gt; 유형을 사용하려고하면 Elixir에서 경고를 표시합니다. 따라서 &lt;code&gt;charlist()&lt;/code&gt; , &lt;code&gt;nonempty_charlist()&lt;/code&gt; , &lt;code&gt;binary()&lt;/code&gt; 또는 &lt;code&gt;String.t()&lt;/code&gt; 또는 이러한 유형에 대한 여러 리터럴 표현을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d6df36f3b70e0d4fb5ddb48d10dbf25423b1cc5a" translate="yes" xml:space="preserve">
          <source>Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are:</source>
          <target state="translated">Elixir 문서에는 &quot;페이지&quot;섹션에있는 지원 문서도 포함되어 있습니다. 사람들은:</target>
        </trans-unit>
        <trans-unit id="dfbdabad266a6ed24abe7282e3054447cc34c95a" translate="yes" xml:space="preserve">
          <source>Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the ones available at GitHub as a getting started point:</source>
          <target state="translated">Elixir 문서는 Markdown을 사용하여 작성되었습니다. Markdown 온라인에는 많은 가이드가 있으므로 GitHub에서 시작하기위한 가이드를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="b8ad464d7c3f98c28d6c1301d748b4474f625349" translate="yes" xml:space="preserve">
          <source>Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. R1b is guaranteed for backwards compatibility purposes.</source>
          <target state="translated">Elixir는 식별자에 ZWJ 또는 ZWNJ를 사용할 수 없으므로 R1a를 구현하지 않습니다. R1b는 이전 버전과의 호환성을 위해 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="d746cd61df3db6f2fe47fafb3741869cc1431ba6" translate="yes" xml:space="preserve">
          <source>Elixir does not contain a function similar to &lt;code&gt;printf&lt;/code&gt; found in C and other languages. Luckily, the Erlang standard library functions &lt;code&gt;:io.format/2&lt;/code&gt; and &lt;code&gt;:io_lib.format/2&lt;/code&gt; may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from &lt;code&gt;printf&lt;/code&gt;, &lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;refer to the Erlang documentation for details&lt;/a&gt;.</source>
          <target state="translated">Elixir에는 C 및 다른 언어에서 볼 수있는 &lt;code&gt;printf&lt;/code&gt; 와 유사한 기능이 없습니다 . 다행히 Erlang 표준 라이브러리 함수 인 &lt;code&gt;:io.format/2&lt;/code&gt; 및 &lt;code&gt;:io_lib.format/2&lt;/code&gt; 를 사용할 수 있습니다. 첫 번째는 터미널 출력으로, 두 번째는 iolist로 포맷합니다. 형식 지정자는 다를 &lt;code&gt;printf&lt;/code&gt; 와 , &lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;자세한 내용은 얼랑 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="979dd9d85c61d8b521a5dc2ef6b2263883c16c08" translate="yes" xml:space="preserve">
          <source>Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:</source>
          <target state="translated">엘릭서에는 몇 가지 예약 된 속성이 있습니다. 가장 일반적으로 사용되는 몇 가지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da143eaa5f18150282df48049071c1cc1a0e242a" translate="yes" xml:space="preserve">
          <source>Elixir has functions, like &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, that &lt;em&gt;only&lt;/em&gt; work with booleans, but also functions that work with these truthy/falsy values, like &lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir에는 부울 &lt;em&gt;에서만&lt;/em&gt; 작동 하는 &lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; 와&lt;/a&gt; 같은 함수가 있지만 &lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#!/1&quot;&gt; &lt;code&gt;!/1&lt;/code&gt; &lt;/a&gt; 과 같은 진실 / 거짓 값으로 작동하는 함수도 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="88f2b25faa45986049480c976c00dd5855a6e36c" translate="yes" xml:space="preserve">
          <source>Elixir has three error mechanisms: errors, throws, and exits. In this chapter, we will explore each of them and include remarks about when each should be used.</source>
          <target state="translated">Elixir에는 오류, 던지기 및 종료의 세 가지 오류 메커니즘이 있습니다. 이 장에서는 각각을 살펴보고 언제 사용해야하는지에 대한 설명을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0713d95ea58614452d3bd4a78be0cb70359f5d00" translate="yes" xml:space="preserve">
          <source>Elixir has three options for endianness: &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, and &lt;code&gt;native&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;:</source>
          <target state="translated">엘릭서에는 엔디안을위한 3 가지 옵션이 있습니다 : &lt;code&gt;big&lt;/code&gt; , &lt;code&gt;little&lt;/code&gt; , &lt;code&gt;native&lt;/code&gt; . 디폴트는 &lt;code&gt;big&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe30cf194fcc420b9fc8698a6260db192b62dfe9" translate="yes" xml:space="preserve">
          <source>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</source>
          <target state="translated">Elixir에는 함수 호출을위한 두 가지 구문이 있습니다. 파 렌스가 있고 파 렌스가 없습니다. 기본적으로 Elixir는 다음을 제외한 모든 통화에 Parens를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9c36cafc5f1778cc6d258e84e87e60d138fd12a4" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are checked at runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="translated">Elixir는 동적으로 입력되는 언어이므로 Elixir의 모든 유형은 런타임에 확인됩니다. 그럼에도 불구하고 Elixir는 다음에 사용되는 표기법 인 &lt;strong&gt;typespecs&lt;/strong&gt; 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ea9e99a9db02305c5b70e98171ae53976e93c92" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are inferred by the runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="translated">Elixir는 동적으로 유형이 지정된 언어이므로 Elixir의 모든 유형은 런타임에 의해 유추됩니다. 그럼에도 불구하고, Elixir는 &lt;strong&gt;typespecs&lt;/strong&gt; 와 함께 제공되며 , 이는 다음에 사용되는 표기법입니다.</target>
        </trans-unit>
        <trans-unit id="e56a48282c5929f27448e4f74f02e189acbe3204" translate="yes" xml:space="preserve">
          <source>Elixir is an extensible and very customizable programming language thanks to its meta-programming support. Most meta-programming in Elixir is done through macros, which are very useful in several situations, especially for writing DSLs. We have written a short guide that explains the basic mechanisms behind macros, shows how to write macros, and how to use macros to create DSLs:</source>
          <target state="translated">Elixir는 메타 프로그래밍 지원 덕분에 확장 가능하고 매우 사용자 정의 가능한 프로그래밍 언어입니다. Elixir에서 대부분의 메타 프로그래밍은 매크로를 통해 이루어지며, 이는 특히 DSL 작성과 같은 여러 상황에서 매우 유용합니다. 매크로의 기본 메커니즘을 설명하고 매크로를 작성하는 방법과 매크로를 사용하여 DSL을 만드는 방법을 보여주는 간단한 안내서를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="63771eaf5ff6c9a6bd6258b28e240e5f31e971be" translate="yes" xml:space="preserve">
          <source>Elixir is an immutable language where nothing is shared by default. If we want to share information, which can be read and modified from multiple places, we have two main options in Elixir:</source>
          <target state="translated">엘릭서는 기본적으로 아무것도 공유되지 않는 불변 언어입니다. 여러 곳에서 읽고 수정할 수있는 정보를 공유하려면 Elixir에는 두 가지 주요 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c491dbf300477fadaef34d4fecd5fbbc6358fa" translate="yes" xml:space="preserve">
          <source>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are &lt;em&gt;used&lt;/em&gt; by Elixir: for example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are used by Elixir for addition and boolean &lt;em&gt;or&lt;/em&gt;, but &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; is not used (but valid).</source>
          <target state="translated">Elixir는 사전 정의 된 연산자 세트를 구문 분석 할 수 있습니다. 이것은 예를 들어 Haskell에서와 같이 새로운 연산자를 정의 할 수 없다는 것을 의미합니다. 그러나 Elixir가 구문 분석 할 수있는 모든 연산자가 Elixir에서 &lt;em&gt;사용&lt;/em&gt; 되는 것은 아닙니다 ( 예 : &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; Elixir는 더하기 및 부울 &lt;em&gt;또는&lt;/em&gt; 로 사용하지만 &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; 는 사용되지 않지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="119a6b69354b723a3119d7eb9b274e46b1a606de" translate="yes" xml:space="preserve">
          <source>Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.</source>
          <target state="translated">Elixir는 현재 메이저 버전 v1입니다. 새로운 이전 버전과 호환되는 부 릴리스는 6 개월마다 발생합니다. 패치 릴리스는 예약되지 않으며 버그 수정 또는 보안 패치가있을 때마다 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5569a08dfbe33692762e6efedcb5c7ea0454136a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="translated">Elixir는 가능한 최신 순간으로 해결을 지연시킬만큼 똑똑합니다. 따라서 따옴표 안에 &lt;code&gt;length([1, 2, 3])&lt;/code&gt; 를 호출 했지만 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 없는 경우 호출자에서 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="92e6a9f7e2024169f36143b3110efa2bf4ec167a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="translated">Elixir는 해상도를 최신 순간까지 지연시킬 수있을만큼 똑똑합니다. 따라서 인용 부호 안에 &lt;code&gt;length([1, 2, 3])&lt;/code&gt; 을 호출 하지만 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 없으면 호출자에서 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="94be6db8aa623aad96175d2a4f009eb3d49d1f72" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to recompile only files that have changed and their dependencies. This means if &lt;code&gt;lib/a.ex&lt;/code&gt; is invoking a function defined over &lt;code&gt;lib/b.ex&lt;/code&gt;, whenever &lt;code&gt;lib/b.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; is also recompiled.</source>
          <target state="translated">Elixir는 변경된 파일과 해당 파일의 종속성 만 다시 컴파일 할 수있을 정도로 똑똑합니다. 이 수단은 경우 &lt;code&gt;lib/a.ex&lt;/code&gt; 위에 정의 된 함수를 호출하는 &lt;code&gt;lib/b.ex&lt;/code&gt; , 언제 &lt;code&gt;lib/b.ex&lt;/code&gt; 변경 &lt;code&gt;lib/a.ex&lt;/code&gt; IS 또한 컴파일.</target>
        </trans-unit>
        <trans-unit id="a352a9b0a3e5c7519c223a1075bc3428e61e0561" translate="yes" xml:space="preserve">
          <source>Elixir is versioned according to a vMAJOR.MINOR.PATCH schema.</source>
          <target state="translated">Elixir는 vMAJOR.MINOR.PATCH 스키마에 따라 버전이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d990d24327822ea7a421e913e80e0202d0dfa1bb" translate="yes" xml:space="preserve">
          <source>Elixir macros have late resolution. This guarantees that a variable defined inside a quote won&amp;rsquo;t conflict with a variable defined in the context where that macro is expanded. For example:</source>
          <target state="translated">엘릭서 매크로는 해상도가 늦습니다. 이렇게하면 따옴표 안에 정의 된 변수가 해당 매크로가 확장 된 컨텍스트에 정의 된 변수와 충돌하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c0929a451e1f448275dcbe066bf77535364105c" translate="yes" xml:space="preserve">
          <source>Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions.</source>
          <target state="translated">Elixir 부 버전 및 패치 릴리스는 이전 버전과 호환됩니다. 특정 버전의 잘 정의 된 동작 및 문서화 된 API는 향후 버전에서 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f4a72643c7a8a6ed5341995de6e14044af2a034d" translate="yes" xml:space="preserve">
          <source>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</source>
          <target state="translated">엘릭서 모듈 이름은 동적으로 생성 될 수 있습니다. 매크로로 작업 할 때 매우 유용합니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3135e8d914a8aafb03877d33ea9a4b0de24e09f7" translate="yes" xml:space="preserve">
          <source>Elixir offers several sigils to deal with various flavors of times and dates.</source>
          <target state="translated">Elixir는 다양한 시간과 날짜를 처리 할 수있는 여러 인장을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e063af00bef300726332e4ffbf98de73c83bdc5a" translate="yes" xml:space="preserve">
          <source>Elixir on Discord</source>
          <target state="translated">불화의 비약</target>
        </trans-unit>
        <trans-unit id="005e7c25a3d3787c9fd9aad492021fe09a8bd012" translate="yes" xml:space="preserve">
          <source>Elixir on Slack</source>
          <target state="translated">슬랙스의 비약</target>
        </trans-unit>
        <trans-unit id="6ec353d0b43e8fcc2bae198d8d18d71fc59a96c0" translate="yes" xml:space="preserve">
          <source>Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library.</source>
          <target state="translated">Elixir 프로그램은 가능한 한 최종 사용자와 가까운 곳에서 데이터의 유효성을 검사해야하므로 오류를 쉽게 찾아 수정할 수 있습니다. 이 방법을 사용하면 라이브러리 내부에서 방어 코드를 작성하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="34badf132890db803056b8a329274a11ed6c00d4" translate="yes" xml:space="preserve">
          <source>Elixir projects are usually organized into three directories:</source>
          <target state="translated">엘릭서 프로젝트는 일반적으로 세 개의 디렉토리로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd498b5c0b475852faf005a008b3295d3968391d" translate="yes" xml:space="preserve">
          <source>Elixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text. We can access the documentation of any compiled module directly from IEx:</source>
          <target state="translated">Elixir는 heredocs와 함께 Markdown을 사용하여 읽을 수있는 문서를 작성하도록 권장합니다. Heredocs는 여러 줄로 된 문자열로, 삼중 따옴표로 시작하고 끝나며 내부 텍스트의 서식을 유지합니다. IEx에서 직접 컴파일 된 모듈의 문서에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd089c42b27bd178061d32f4f832a4a6ee4ad2d" translate="yes" xml:space="preserve">
          <source>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library. Regexes also support modifiers. For example, the &lt;code&gt;i&lt;/code&gt; modifier makes a regular expression case insensitive:</source>
          <target state="translated">Elixir는 &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; 라이브러리에 의해 구현 된 Perl 호환 정규 표현식 (regexe)을 제공합니다 . 정규 표현식도 수정자를 지원합니다. 예를 들어, &lt;code&gt;i&lt;/code&gt; 수정자는 정규식 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea04f299ea8e7d138416f7682d04dace2f8332f3" translate="yes" xml:space="preserve">
          <source>Elixir provides a bunch of predicate functions to check for a value type. For example, the &lt;code&gt;is_boolean/1&lt;/code&gt; function can be used to check if a value is a boolean or not:</source>
          <target state="translated">Elixir는 값 유형을 확인하기위한 많은 술어 함수를 제공합니다. 예를 들어, &lt;code&gt;is_boolean/1&lt;/code&gt; 함수를 사용하여 값이 부울인지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d0324f32083b4357effd55af42179e669e80ba" translate="yes" xml:space="preserve">
          <source>Elixir provides a special and more concise syntax for keyword lists that looks like this:</source>
          <target state="translated">Elixir는 다음과 같은 키워드 목록을위한 특별하고 간결한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3fb7d8bf0ef1942795033493f666d84321055fe3" translate="yes" xml:space="preserve">
          <source>Elixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.</source>
          <target state="translated">Elixir는 Erlang 라이브러리와의 뛰어난 상호 운용성을 제공합니다. 실제로, Elixir는 Erlang 코드와 직접 인터페이싱하기 위해 Erlang 라이브러리를 단순히 래핑하는 것을 권장하지 않습니다. 이 섹션에서는 Elixir에는없는 가장 일반적이고 유용한 Erlang 기능을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="b3b982e7fff9bd521206b036c548d296e906492a" translate="yes" xml:space="preserve">
          <source>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.</source>
          <target state="translated">Elixir는 메타 프로그래밍 (코드를 생성하는 코드 작성)을위한 메커니즘으로 매크로를 제공합니다. 컴파일 타임에 매크로가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="449df725d4d68a46665d86a115b480918573511c" translate="yes" xml:space="preserve">
          <source>Elixir provides many &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;built-in types&lt;/a&gt;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;pid&lt;/code&gt;, that can be used to document function signatures. For example, the &lt;code&gt;round/1&lt;/code&gt; function, which rounds a number to its nearest integer. As you can see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;in its documentation&lt;/a&gt;, &lt;code&gt;round/1&lt;/code&gt;&amp;rsquo;s typed signature is written as:</source>
          <target state="translated">Elixir는 함수 서명을 문서화하는 데 사용할 수있는 &lt;code&gt;integer&lt;/code&gt; 또는 &lt;code&gt;pid&lt;/code&gt; 와 같은 많은 &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;내장 유형을&lt;/a&gt; 제공합니다 . 예를 들어, 숫자를 가장 가까운 정수로 반올림하는 &lt;code&gt;round/1&lt;/code&gt; 함수입니다. 당신이 볼 수 있듯이 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;그 문서에&lt;/a&gt; , &lt;code&gt;round/1&lt;/code&gt; 의 입력 된 서명으로 작성된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="2c38afe5476b8521de1ce73619db182fce82f5c4" translate="yes" xml:space="preserve">
          <source>Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below.</source>
          <target state="translated">Elixir는 포트 작업과 몇 가지 단점에 대해 많은 편의를 제공합니다. 아래 내용을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="86797814ddc42c874f88a51b77e92d177f55b7bc" translate="yes" xml:space="preserve">
          <source>Elixir provides optional parentheses for non-qualified and qualified calls.</source>
          <target state="translated">Elixir는 규정되지 않은 정규 통화에 대해 선택적 괄호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1d9a8b35858a0497976075a187083dacc1314354" translate="yes" xml:space="preserve">
          <source>Elixir provides pattern matching, which allows us to assert on the shape or extract values from data-structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.</source>
          <target state="translated">Elixir는 패턴 매칭을 제공하여 모양을 주장하거나 데이터 구조에서 값을 추출 할 수 있습니다. 패턴은 종종 가드로 보강되어 개발자에게 제한적이지만 더 복잡한 검사를 수행 할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab1e334b03a647f5918bb69c761fab411cd3e870" translate="yes" xml:space="preserve">
          <source>Elixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like &lt;code&gt;var!/2&lt;/code&gt; and &lt;code&gt;alias!/1&lt;/code&gt;, although one must be careful when using those as they directly change the user environment.</source>
          <target state="translated">Elixir는 가져 오기 및 별명에도 유사한 메커니즘을 제공합니다. 이를 통해 매크로가 확장 된 대상 모듈과 충돌하지 않고 소스 모듈에서 지정한대로 매크로가 작동합니다. &lt;code&gt;var!/2&lt;/code&gt; 및 &lt;code&gt;alias!/1&lt;/code&gt; 과 같은 매크로를 사용하여 특정 상황에서 위생을 우회 할 수 있지만, 사용자 환경을 직접 변경하는 매크로를 사용할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ee83992e184ceb0497492aa46813f6e12944aa3" translate="yes" xml:space="preserve">
          <source>Elixir provides the concept of enumerables and &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;the &lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt; to work with them. We have already learned two enumerables: lists and maps.</source>
          <target state="translated">Elixir는 열거 형의 개념 과 함께 사용할 수 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;있는 &lt;code&gt;Enum&lt;/code&gt; 모듈&lt;/a&gt; 을 제공합니다. 리스트와 맵이라는 두 가지 열거 형을 이미 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="56408c183550d2230f17bffa1fd59dd5a2aa2dd3" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators (all of which can be used in guards):</source>
          <target state="translated">Elixir는 다음과 같은 내장 비교 연산자를 제공합니다 (모두 가드에서 사용할 수 있음) :</target>
        </trans-unit>
        <trans-unit id="c38b66bd0f1f07df9af68419dad5d7545d3eb5b0" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators:</source>
          <target state="translated">Elixir는 다음과 같은 내장 비교 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a073541c1c4061c5b62e401a691e0182a896f380" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in operators that are defined as functions that can be overridden:</source>
          <target state="translated">Elixir는 재정의 할 수있는 함수로 정의 된 다음과 같은 기본 제공 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac046d5521e866f330d69759ab8c6306ded55946" translate="yes" xml:space="preserve">
          <source>Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</source>
          <target state="translated">엘릭서 인용 / 인용 인용 메커니즘은 인용 인용 조각이라는 기능을 제공합니다. 따옴표가없는 조각은 즉시 함수를 생성하는 쉬운 방법을 제공합니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8d30f35ec7987f572743e95ef255bb1ce5bee72e" translate="yes" xml:space="preserve">
          <source>Elixir relies on underscores in different situations.</source>
          <target state="translated">엘릭서는 서로 다른 상황에서 밑줄에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="ecffee7d986ded673e3f20c49d26acf93d1febaf" translate="yes" xml:space="preserve">
          <source>Elixir represents &lt;code&gt;Foo.Bar&lt;/code&gt; as &lt;code&gt;__aliases__&lt;/code&gt; so calls can be unambiguously identified by the operator &lt;code&gt;:.&lt;/code&gt;. For example:</source>
          <target state="translated">Elixir는 &lt;code&gt;Foo.Bar&lt;/code&gt; 를 __aliases__ 로 &lt;code&gt;__aliases__&lt;/code&gt; 므로 호출자 가 연산자를 명확하게 식별 할 수 있습니다 &lt;code&gt;:.&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6bdbab87b861494b0b9df9b50e56bb5cc5d2563" translate="yes" xml:space="preserve">
          <source>Elixir requires all atoms and variables to be in NFC form. Any other form will fail with a relevant error message. Quoted-atoms and strings can, however, be in any form and are not verified by the parser.</source>
          <target state="translated">Elixir는 모든 원자와 변수가 NFC 형식이어야합니다. 다른 형식은 관련 오류 메시지와 함께 실패합니다. 그러나 인용 된 원자 및 문자열은 모든 형식 일 수 있으며 구문 분석기에 의해 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edacc18f14ad696b0fd9cee85daa785d105406a3" translate="yes" xml:space="preserve">
          <source>Elixir reserves the following module names: &lt;code&gt;Elixir&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;BitString&lt;/code&gt;, &lt;code&gt;PID&lt;/code&gt;, and &lt;code&gt;Reference&lt;/code&gt;.</source>
          <target state="translated">Elixir는 &lt;code&gt;Elixir&lt;/code&gt; , &lt;code&gt;Any&lt;/code&gt; , &lt;code&gt;BitString&lt;/code&gt; , &lt;code&gt;PID&lt;/code&gt; 및 &lt;code&gt;Reference&lt;/code&gt; 모듈 이름을 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="6a2a631e623ec7dcc0aeb7c643dc24be890d814b" translate="yes" xml:space="preserve">
          <source>Elixir runs on the Erlang Virtual Machine and, sooner or later, an Elixir developer will want to interface with existing Erlang libraries. Here&amp;rsquo;s a list of online resources that cover Erlang&amp;rsquo;s fundamentals and its more advanced features:</source>
          <target state="translated">Elixir는 Erlang 가상 머신에서 실행되며 조만간 Elixir 개발자는 기존 Erlang 라이브러리와 인터페이스하기를 원할 것입니다. 다음은 Erlang의 기본 사항과 고급 기능을 다루는 온라인 리소스 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4a5fefa1f8798cec1647f9fe4a71993a0c63afa5" translate="yes" xml:space="preserve">
          <source>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</source>
          <target state="translated">Elixir는 오른쪽이 함수 호출이며 파이프로 인식됩니다. 즉, 익명 또는 캡처 된 함수로 파이프하려면 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8974a1be92f4c12c0a0c52c8b32e2ca1e35088a" translate="yes" xml:space="preserve">
          <source>Elixir ships with facilities to connect nodes and exchange information between them. In fact, we use the same concepts of processes, message passing and receiving messages when working in a distributed environment because Elixir processes are &lt;em&gt;location transparent&lt;/em&gt;. This means that when sending a message, it doesn&amp;rsquo;t matter if the recipient process is on the same node or on another node, the</source>
          <target state="translated">Elixir는 노드를 연결하고 노드간에 정보를 교환 할 수있는 기능을 제공합니다. 사실, 우리는 분산 환경에서 작업 할 때 동일한 개념의 프로세스, 메시지 전달 및 메시지 수신을 사용합니다 . Elixir 프로세스는 &lt;em&gt;투명&lt;/em&gt; 합니다. 즉, 메시지를 보낼 때 수신자 프로세스가 동일한 노드 또는 다른 노드에 있는지 여부는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c11d827abbb7cde35b0a581d6299d5d74cd7a62" translate="yes" xml:space="preserve">
          <source>Elixir ships with some built-in protocols. In previous chapters, we have discussed the &lt;code&gt;Enum&lt;/code&gt; module which provides many functions that work with any data structure that implements the &lt;code&gt;Enumerable&lt;/code&gt; protocol:</source>
          <target state="translated">Elixir는 일부 내장 프로토콜과 함께 제공됩니다. 이전 장에서는 &lt;code&gt;Enumerable&lt;/code&gt; 프로토콜 을 구현하는 모든 데이터 구조에서 작동하는 많은 기능을 제공 하는 &lt;code&gt;Enum&lt;/code&gt; 모듈에 대해 설명했습니다 .</target>
        </trans-unit>
        <trans-unit id="dd2cbcbe1872ea6a04fdc11aaa0e830351ff7c7a" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) knows all of the output should be sent back to the original node!</source>
          <target state="translated">Elixir는 다른 노드에서 프로세스를 생성하고 pid를 반환했습니다. 그런 다음 코드는 &lt;code&gt;Hello.world/0&lt;/code&gt; 함수가 있는 다른 노드에서 실행되고 해당 함수를 호출합니다. &quot;hello world&quot;의 결과는 &lt;code&gt;foo&lt;/code&gt; 가 아닌 현재 노드 &lt;code&gt;bar&lt;/code&gt; 에 인쇄되었습니다 . 즉, 인쇄 할 메시지가 &lt;code&gt;foo&lt;/code&gt; 에서 &lt;code&gt;bar&lt;/code&gt; 로 다시 전송되었습니다 . 이것은 다른 노드 ( &lt;code&gt;foo&lt;/code&gt; ) 에서 생성 된 프로세스 가 모든 출력이 원래 노드로 다시 전송되어야한다는 것을 알고 있기 때문에 발생 합니다!</target>
        </trans-unit>
        <trans-unit id="8d3a064f8543389f89760aca91a7bf4bd3fe1730" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) still has the group leader of the current node (&lt;code&gt;bar&lt;/code&gt;). We have briefly talked about group leaders in the &lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO chapter&lt;/a&gt;.</source>
          <target state="translated">엘릭서는 다른 노드에서 프로세스를 생성하고 그 pid를 반환했습니다. 그런 다음 코드는 &lt;code&gt;Hello.world/0&lt;/code&gt; 함수가 존재 하는 다른 노드에서 실행되어 해당 함수를 호출했습니다. &amp;ldquo;hello world&amp;rdquo;의 결과는 &lt;code&gt;foo&lt;/code&gt; 가 아닌 현재 노드 &lt;code&gt;bar&lt;/code&gt; 인쇄되었습니다 . 즉, 인쇄 할 메시지가 &lt;code&gt;foo&lt;/code&gt; 에서 &lt;code&gt;bar&lt;/code&gt; 로 다시 전송되었습니다 . 다른 노드 ( &lt;code&gt;foo&lt;/code&gt; ) 에 생성 된 프로세스에 여전히 현재 노드 ( &lt;code&gt;bar&lt;/code&gt; ) 의 그룹 리더 가 있기 때문에 이런 일이 발생합니다 . 우리는 &lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO 장&lt;/a&gt; 에서 그룹 리더에 대해 간단히 이야기했습니다 .</target>
        </trans-unit>
        <trans-unit id="cdde1bffc734f7ff0a1635ad03d752544e76408f" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="translated">Elixir는 바이트 코드의 사전 정의 된 청크 안에 문서를 저장합니다. &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Elixir에서 액세스 할 수 있습니다 . 이는 가상 머신이 모듈을로드 할 때가 아니라 필요한 경우에만 문서에 액세스한다는 것을 의미합니다. 유일한 단점은 IEx에 정의 된 것과 같이 메모리에 정의 된 모듈은 디스크에 바이트 코드가 기록되어 있지 않으므로 문서에 액세스 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73308596a035e74f58128367e181ad0b11e8c767" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="translated">Elixir는 바이트 코드의 미리 정의 된 청크 안에 문서를 저장합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Elixir에서 액세스 할 수 있습니다 . 이는 또한 가상 머신이 모듈을로드 할 때가 아니라 필요할 때만 문서에 액세스 할 수 있음을 의미합니다. 유일한 단점은 IEx에 정의 된 것과 같이 메모리에 정의 된 모듈은 디스크에 기록 된 바이트 코드가 없기 때문에 문서에 액세스 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba4784f8c761fcb64ca50be28ca3ee0726dd1e34" translate="yes" xml:space="preserve">
          <source>Elixir supports &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; as booleans:</source>
          <target state="translated">Elixir는 부울로 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 를 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="c1fca4af1967c47f797a528ad384a0b6142eeed4" translate="yes" xml:space="preserve">
          <source>Elixir supports Unicode throughout the language.</source>
          <target state="translated">Elixir는 언어 전체에서 유니 코드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6e32af56db37e615dec6eaffbd92d992d378d08f" translate="yes" xml:space="preserve">
          <source>Elixir supports compilation tracers, which allows modules to observe constructs handled by the Elixir compiler when compiling files. A tracer is a module that implements the &lt;code&gt;trace/2&lt;/code&gt; function. The function receives the event name as first argument and &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; as second and it must return &lt;code&gt;:ok&lt;/code&gt;. It is very important for a tracer to do as little work as possible synchronously and dispatch the bulk of the work to a separate process. &lt;strong&gt;Slow tracers will slow down compilation&lt;/strong&gt;.</source>
          <target state="translated">Elixir는 모듈이 파일을 컴파일 할 때 Elixir 컴파일러가 처리하는 구조를 관찰 할 수 있도록하는 컴파일 추적 프로그램을 지원합니다. 추적 프로그램은 &lt;code&gt;trace/2&lt;/code&gt; 기능 을 구현하는 모듈입니다 . 이 함수는 이벤트 이름을 첫 번째 인수로 받고 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 를 두 번째로 받으며 &lt;code&gt;:ok&lt;/code&gt; 를 반환해야합니다 . 추적 프로그램이 동기식으로 가능한 한 적은 작업을 수행하고 대부분의 작업을 별도의 프로세스로 보내는 것은 매우 중요합니다. &lt;strong&gt;느린 추적 프로그램은 컴파일 속도를 늦 춥니 다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="649a2834ec800cb52f399145f24bccb3f23afbc9" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;, or maps that define keys and types (see the example below).</source>
          <target state="translated">Elixir는 복합 유형도 지원합니다. 예를 들어 정수 목록에는 유형 &lt;code&gt;[integer]&lt;/code&gt; 또는 키와 유형을 정의하는 맵이 있습니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="1f173b2bc2f5965b36c7172e06c818c7bd04ae05" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;. You can see all the built-in types provided by Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;in the typespecs docs&lt;/a&gt;.</source>
          <target state="translated">엘릭서는 복합 유형도 지원합니다. 예를 들어 정수 목록의 유형은 &lt;code&gt;[integer]&lt;/code&gt; 입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;typespecs docs에서&lt;/a&gt; Elixir 가 제공하는 모든 내장 유형을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96cc8eea24e4342cdb1b99a08ca9183edff74d45" translate="yes" xml:space="preserve">
          <source>Elixir supports conversions from charlists which contains any Unicode code point.</source>
          <target state="translated">Elixir는 모든 유니 코드 코드 포인트가 포함 된 문자 목록에서의 변환을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c47342d7972fff0f119dd077cbc8a84f69c35e4d" translate="yes" xml:space="preserve">
          <source>Elixir supports only code points &lt;code&gt;\t&lt;/code&gt; (0009), &lt;code&gt;\n&lt;/code&gt; (000A), &lt;code&gt;\r&lt;/code&gt; (000D) and &lt;code&gt;\s&lt;/code&gt; (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.</source>
          <target state="translated">Elixir는 공백으로 코드 포인트 &lt;code&gt;\t&lt;/code&gt; (0009), &lt;code&gt;\n&lt;/code&gt; (000A), &lt;code&gt;\r&lt;/code&gt; (000D) 및 &lt;code&gt;\s&lt;/code&gt; (0020) 만 지원하므로 요구 사항 R3을 따르지 않습니다. R3은보다 다양한 공백 및 구문 문자를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="01176f0775592b687fb8331c0702b3ffd6028d87" translate="yes" xml:space="preserve">
          <source>Elixir supports some sigil variants to deal with escaping characters and interpolation. In particular, uppercase letters sigils do not perform interpolation nor escaping. For example, although both &lt;code&gt;~s&lt;/code&gt; and &lt;code&gt;~S&lt;/code&gt; will return strings, the former allows escape codes and interpolation while the latter does not:</source>
          <target state="translated">Elixir는 이스케이프 문자 및 보간을 처리하기 위해 몇 가지시길 변형을 지원합니다. 특히 대문자시길은 보간이나 이스케이프를 수행하지 않습니다. 예를 들어 &lt;code&gt;~s&lt;/code&gt; 와 &lt;code&gt;~S&lt;/code&gt; 는 모두 문자열을 반환하지만 전자는 이스케이프 코드와 보간을 허용하지만 후자는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="310bbc013224b7904b922e667f4bf7001bdc5fa3" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements:</source>
          <target state="translated">엘릭서 구문은 추상 구문 트리 (AST)로 간단하게 변환되도록 설계되었습니다. Elixir의 AST는 다음 요소로 구성된 일반 Elixir 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="ff71b1cca0c9586eb958681a7c3aaf58f79bc884" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms.</source>
          <target state="translated">엘릭서 구문은 추상 구문 트리 (AST)로 간단하게 변환되도록 설계되었습니다. 이것은 엘릭서 구문이 일반적인 엘릭서 관용구에서 노이즈를 줄이기 위해 소수의 &quot;구문 설탕&quot;구성으로 대부분 균일하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ce4861615a3c3b43c097938810a51ecb7a613f3a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.</source>
          <target state="translated">Elixir는 문서와 코드 주석을 다른 개념으로 취급합니다. 설명서는 API (Application Programming Interface) 사용자와 타사 개발자, 동료 또는 미래의 자아 간의 명시 적 계약입니다. 모듈 및 함수는 API의 일부인 경우 항상 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="94ab78733fcffaa0c8d9d75151f47ea7434ea05a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation as a first-class citizen. This means documentation should be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices and doctests.</source>
          <target state="translated">Elixir는 문서를 일류 시민으로 취급합니다. 즉, 문서는 작성하기 쉽고 읽기 쉬워야합니다. 이 문서에서는 모듈 속성, 스타일 관행 및 문서 테스트와 같은 구문을 다루는 Elixir로 문서를 작성하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="3977a0d710ac9b9b84f6c1288fefa9a0d84df520" translate="yes" xml:space="preserve">
          <source>Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a &lt;strong&gt;variable width&lt;/strong&gt; character encoding that uses one to four bytes to store each code point; it is capable of encoding all valid Unicode code points.</source>
          <target state="translated">Elixir는 UTF-8을 사용하여 문자열을 인코딩합니다. 즉, 코드 포인트가 일련의 8 비트 바이트로 인코딩됩니다. UTF-8은 각 코드 포인트를 저장하는 데 1-4 바이트를 사용 하는 &lt;strong&gt;가변 너비&lt;/strong&gt; 문자 인코딩입니다. 유효한 모든 유니 코드 코드 포인트를 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c067ad566a52ceb3738f6cd14c05e81b89ddb512" translate="yes" xml:space="preserve">
          <source>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:</source>
          <target state="translated">엘릭서는 중괄호를 사용하여 튜플을 정의합니다. 리스트와 같이 튜플은 모든 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7437bc89e4d7cd42e4777ca92ac246386afa15d" translate="yes" xml:space="preserve">
          <source>Elixir uses single quotes to define charlists:</source>
          <target state="translated">Elixir는 작은 따옴표를 사용하여 문자 목록을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0a0c9ca226ff9075b8b4027dc040b09a7fc4c136" translate="yes" xml:space="preserve">
          <source>Elixir uses square brackets to specify a list of values. Values can be of any type:</source>
          <target state="translated">Elixir는 대괄호를 사용하여 값 목록을 지정합니다. 값은 모든 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca97f233cf2ddf0b1c0bf0e2277569cae997e55" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Elixir v1.7 은 모든 BEAM 언어에서 공유되는 새로운 문서 형식 인 &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; 을 채택 합니다. &lt;a href=&quot;#get_docs/2&quot;&gt; &lt;code&gt;Code.get_docs/2&lt;/code&gt; &lt;/a&gt; 에서 사용하는 이전 형식 은 더 이상 사용할 수 없으므로이 함수는 항상 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 대신 &lt;a href=&quot;#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7410ee1b8baed2ca63c0da7fbd59f8909583c454" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;code#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Elixir v1.7 은 모든 BEAM 언어에서 공유 할 수있는 새로운 문서 형식 인 &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; 을 채택 합니다. &lt;a href=&quot;code#get_docs/2&quot;&gt; &lt;code&gt;Code.get_docs/2&lt;/code&gt; 가&lt;/a&gt; 사용하는 이전 형식 은 더 이상 사용할 수 없으므로이 함수는 항상 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 대신 &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2c8e7ddf395da597d9d7092789c372c5e9cb894" translate="yes" xml:space="preserve">
          <source>Elixir version</source>
          <target state="translated">엘릭서 버전</target>
        </trans-unit>
        <trans-unit id="3ef1a22d73c732ddfb0e37deb22c5920363b7ef9" translate="yes" xml:space="preserve">
          <source>Elixir version information.</source>
          <target state="translated">엘릭서 버전 정보.</target>
        </trans-unit>
        <trans-unit id="2d1a3e13eeda4320739159e4214187b33436ad5e" translate="yes" xml:space="preserve">
          <source>Elixir will accept any module name as long as the expression passed as the first argument to &lt;a href=&quot;#defmodule/2&quot;&gt;&lt;code&gt;defmodule/2&lt;/code&gt;&lt;/a&gt; evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.</source>
          <target state="translated">Elixir는 &lt;a href=&quot;#defmodule/2&quot;&gt; &lt;code&gt;defmodule/2&lt;/code&gt; 에&lt;/a&gt; 대한 첫 번째 인수가 원자로 평가 되는 동안 전달 된 표현식 인 경우 모든 모듈 이름을 허용합니다 . 동적 이름이 사용될 때, Elixir는 현재 모듈 아래에 이름을 내포하거나 별칭을 자동으로 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c3a96ef15c7b10a131a32d7fe611882ee9f141c" translate="yes" xml:space="preserve">
          <source>Elixir will automatically wrap the function body in a &lt;code&gt;try&lt;/code&gt; whenever one of &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; is specified.</source>
          <target state="translated">Elixir는 &lt;code&gt;after&lt;/code&gt; , &lt;code&gt;rescue&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 중 하나 가 지정 될 때마다 자동으로 함수 바디를 &lt;code&gt;try&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a85970e0faad243447c5114389dcdeb0a39d337f" translate="yes" xml:space="preserve">
          <source>Elixir&amp;rsquo;s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</source>
          <target state="translated">Elixir의 프로세스는 운영 체제 프로세스와 혼동되어서는 안됩니다. Elixir의 프로세스는 메모리 및 CPU 측면에서 매우 가볍습니다 (다른 많은 프로그래밍 언어에서 사용되는 스레드에 비해). 이 때문에 수만 또는 수십만 개의 프로세스가 동시에 실행되는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="74afface970af5cae73731659047f9af84feb478" translate="yes" xml:space="preserve">
          <source>Elixir's AST (Abstract Syntax Tree)</source>
          <target state="translated">엘릭서 AST (Abstract Syntax Tree)</target>
        </trans-unit>
        <trans-unit id="ce6d269d872319624d23c6d1f8a1436923e77f5d" translate="yes" xml:space="preserve">
          <source>Elixir's interactive shell.</source>
          <target state="translated">엘릭서의 대화식 쉘.</target>
        </trans-unit>
        <trans-unit id="b500d25431abdc8af2398b8e041e9fe8f8aee8f4" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;application&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 표준 라이브러리에는 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;application&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 과 같이 자주 사용되는 몇 가지 동작이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b38f6b406adad2c4ad9a3c750691827797402b8" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 표준 라이브러리에는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 과 같이 자주 사용되는 몇 가지 동작이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9c075ef1bb96e78c3aeb788db6fdaa2ad6900d8" translate="yes" xml:space="preserve">
          <source>Else</source>
          <target state="translated">Else</target>
        </trans-unit>
        <trans-unit id="a956e2fd0a59819b9e171fd2f4db600228e545a0" translate="yes" xml:space="preserve">
          <source>Embeds a template given by &lt;code&gt;contents&lt;/code&gt; into the current module.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 에 의해 제공된 템플릿을 현재 모듈에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e3fd52b24df6fd39026fb28f8524cf6ca06d78cf" translate="yes" xml:space="preserve">
          <source>Embeds a text given by &lt;code&gt;contents&lt;/code&gt; into the current module.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 로 주어진 텍스트를 현재 모듈 에 임베드합니다 .</target>
        </trans-unit>
        <trans-unit id="5b3a40099a2074128eab39c61a99ee9cc8c97d42" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given accumulator.</source>
          <target state="translated">지정된 누산기에 대해 일련의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13f5c3f168a677e832d55a71220e8084e5ebb435" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given resource.</source>
          <target state="translated">주어진 자원에 대한 일련의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ee36a1b257d40c27de1319e9f52bd4df213a780a" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values, starting with &lt;code&gt;start_value&lt;/code&gt;. Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; on the previous value.</source>
          <target state="translated">&lt;code&gt;start_value&lt;/code&gt; 로 시작하여 일련의 값을 생성 합니다. 이전 값에서 &lt;code&gt;next_fun&lt;/code&gt; 을 호출하여 연속 값이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c167634bd4b2e54cc64b0ca7da7acd698bd3f926" translate="yes" xml:space="preserve">
          <source>Empty list elements are discarded.</source>
          <target state="translated">빈 목록 요소는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2965dae66a63ca2f32957370b2d3c71d31f0404a" translate="yes" xml:space="preserve">
          <source>Empty list elements from &lt;code&gt;list&lt;/code&gt; are discarded, but not the ones from &lt;code&gt;tail&lt;/code&gt;.</source>
          <target state="translated">에서 빈리스트 요소 &lt;code&gt;list&lt;/code&gt; 에서 사람 폐기 것이 아니라, &lt;code&gt;tail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e62ffd3f17608b67830975574d7151f053f3b91e" translate="yes" xml:space="preserve">
          <source>Empty strings are only removed from the result if the &lt;code&gt;:trim&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 빈 문자열은 결과에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="55e69718479729085dd821e5465e25f44c0324fa" translate="yes" xml:space="preserve">
          <source>Enables logging for the current process.</source>
          <target state="translated">현재 프로세스에 대한 로깅을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e2d19b78121686bc349ccaa09a8452830a7f9140" translate="yes" xml:space="preserve">
          <source>Encircled.</source>
          <target state="translated">Encircled.</target>
        </trans-unit>
        <trans-unit id="c616c5fe7020dabc2f93906e0a5f2e05bdc7d8a9" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 을 &quot;x-www-form-urlencoded&quot;로 인코딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="89ea780eda521b71e81ed735656c9b61d9499afc" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 16 encoded string.</source>
          <target state="translated">이진 문자열을 기본 16 인코딩 된 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b7e8311ecf9de60bb4c8128af17fdd4f6e19c5bd" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet.</source>
          <target state="translated">이진 문자열을 확장 된 16 진 알파벳이있는 기본 32 인코딩 된 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="36e80d95ff066a33ec7f84aa78c9dbee7b1c006d" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string.</source>
          <target state="translated">이진 문자열을 기본 32 인코딩 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="02f9836e91d8d8f20631bf25f980c01911623202" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet.</source>
          <target state="translated">이진 문자열을 URL 및 파일 이름 안전 알파벳을 사용하여 기본 64 인코딩 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="598559f4be54955449341d6458c6b1bc5c089d2a" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string.</source>
          <target state="translated">이진 문자열을 기본 64 인코딩 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="669885d2c33e97774bece663078c5982ab0c0947" translate="yes" xml:space="preserve">
          <source>Encodes an enumerable into a query string.</source>
          <target state="translated">열거 형을 쿼리 문자열로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="322c5d3730703ae50125a473e7a7c3d0e9ef2301" translate="yes" xml:space="preserve">
          <source>Endianness</source>
          <target state="translated">Endianness</target>
        </trans-unit>
        <trans-unit id="2ea89f176d80e61e2fa991e7665230fc139bc40d" translate="yes" xml:space="preserve">
          <source>Enforcing keys</source>
          <target state="translated">시행 키</target>
        </trans-unit>
        <trans-unit id="c1f65ddb75ed7d97e701168af35171410be8f9e7" translate="yes" xml:space="preserve">
          <source>Engine</source>
          <target state="translated">Engine</target>
        </trans-unit>
        <trans-unit id="428bd921a8f300c3b20c8266821204a755c68434" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; and its applications are started.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 과 해당 애플리케이션이 시작되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="555514beae7482d6d57cd04de49cfc7d3710c06c" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is loaded.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 이로드 되었는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5fb7dedc1a9428584a4069438797a9ae78f66928" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is started.</source>
          <target state="translated">주어진 &lt;code&gt;app&lt;/code&gt; 이 시작되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="23ee0124a924556d787c30d38fea8fafda3318c2" translate="yes" xml:space="preserve">
          <source>Ensures the given module is compiled and loaded.</source>
          <target state="translated">주어진 모듈이 컴파일되고로드되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c639ba03accf3baf6f605c3c0a367752ac1ba4b8" translate="yes" xml:space="preserve">
          <source>Ensures the given module is loaded.</source>
          <target state="translated">주어진 모듈이로드되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="02d3338a85e66444166e14ec820ab3f756bc5765" translate="yes" xml:space="preserve">
          <source>Ensures the project structure for the given project exists.</source>
          <target state="translated">주어진 프로젝트의 프로젝트 구조가 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dd06dfc909fbc0c4ad3d2dc1fed376ba517fa970" translate="yes" xml:space="preserve">
          <source>Entries with duplicated keys end up in the same keyword list.</source>
          <target state="translated">키가 중복 된 항목은 동일한 키워드 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="44a9d3cb7758b69424c29688d3733784f2d7beb8" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError</source>
          <target state="translated">Enum.EmptyError</target>
        </trans-unit>
        <trans-unit id="203f8ecd57ba73b4d911d61ce2b2e0bbecd88546" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.EmptyError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92ff846ccb27bb1237f0fe73dffd1111a34febfd" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError</source>
          <target state="translated">Enum.OutOfBoundsError</target>
        </trans-unit>
        <trans-unit id="64fce429b4436d311f9ed265caf9dbd13748ca8e" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Enum.OutOfBoundsError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="83df7a7ef8fa21dd3116045758d3e9407ca3149d" translate="yes" xml:space="preserve">
          <source>Enumerable</source>
          <target state="translated">Enumerable</target>
        </trans-unit>
        <trans-unit id="a8bd4b8016c41ed593121704b28a0f638927292f" translate="yes" xml:space="preserve">
          <source>Enumerable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">열거 가능한 &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d949b006b0cb6700716702ddad84d81584b294d8" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#drop/2&quot;&gt; &lt;code&gt;Map.drop/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#split/2&quot;&gt; &lt;code&gt;Map.split/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html#take/2&quot;&gt; &lt;code&gt;Map.take/2&lt;/code&gt; 의&lt;/a&gt; 열거 가능한 키</target>
        </trans-unit>
        <trans-unit id="f5c0dbf914d64832e2d144e52e6254adb376dd46" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;map#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;map#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;map#drop/2&quot;&gt; &lt;code&gt;Map.drop/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;map#split/2&quot;&gt; &lt;code&gt;Map.split/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map#take/2&quot;&gt; &lt;code&gt;Map.take/2&lt;/code&gt; 의&lt;/a&gt; 열거 가능한 키</target>
        </trans-unit>
        <trans-unit id="140efbf707d0a7d6c39e74eac70140aecd0e5c56" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈에서 사용하는 열거 가능한 프로토콜 입니다.</target>
        </trans-unit>
        <trans-unit id="a08785570fea867f5f88ca2ee2af7ae3e1313ca0" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈에서 사용하는 열거 가능한 프로토콜 입니다.</target>
        </trans-unit>
        <trans-unit id="d50ecedb47e87b1d9271881d5fe0a9349ed165af" translate="yes" xml:space="preserve">
          <source>Enumerable.acc (0)</source>
          <target state="translated">Enumerable.acc (0)</target>
        </trans-unit>
        <trans-unit id="165c38b0e896ed9f5159922dce36f171ef2320bb" translate="yes" xml:space="preserve">
          <source>Enumerable.continuation (0)</source>
          <target state="translated">열거 가능한 연속성 (0)</target>
        </trans-unit>
        <trans-unit id="ba612d94bc0277c74713f344be3f6d833e339b91" translate="yes" xml:space="preserve">
          <source>Enumerable.count (1)</source>
          <target state="translated">열거 가능한 수 (1)</target>
        </trans-unit>
        <trans-unit id="c8a16ef4893a246c5d44ffbd9b826395af284553" translate="yes" xml:space="preserve">
          <source>Enumerable.member? (2)</source>
          <target state="translated">열거 가능한 멤버? (2)</target>
        </trans-unit>
        <trans-unit id="a9bae250bd6ab01ed637153931cbca7969a9d2fd" translate="yes" xml:space="preserve">
          <source>Enumerable.reduce (3)</source>
          <target state="translated">열거 가능 감소 (3)</target>
        </trans-unit>
        <trans-unit id="ee6aa06bf997d33de46b0f36134133d251942cde" translate="yes" xml:space="preserve">
          <source>Enumerable.reducer (0)</source>
          <target state="translated">열거 형 감속기 (0)</target>
        </trans-unit>
        <trans-unit id="642806a29777279924e9371db22138badd652470" translate="yes" xml:space="preserve">
          <source>Enumerable.result (0)</source>
          <target state="translated">열거 가능한 결과 (0)</target>
        </trans-unit>
        <trans-unit id="67feaa35a2d44a604538ef39106d006cede14270" translate="yes" xml:space="preserve">
          <source>Enumerable.slice (1)</source>
          <target state="translated">열거 가능. 슬라이스 (1)</target>
        </trans-unit>
        <trans-unit id="976e95d4d549c47ec6aacfa3aeb87430d06ae485" translate="yes" xml:space="preserve">
          <source>Enumerable.slicing_fun (0)</source>
          <target state="translated">Enumerable.slicing_fun (0)</target>
        </trans-unit>
        <trans-unit id="8099438503374b0f111ad8c4312c5674efd4704f" translate="yes" xml:space="preserve">
          <source>Enumerable.t (0)</source>
          <target state="translated">열거 가능 t (0)</target>
        </trans-unit>
        <trans-unit id="7d2e28d9448f286359bfee7b46440bedbb9fdf58" translate="yes" xml:space="preserve">
          <source>Enumerables</source>
          <target state="translated">Enumerables</target>
        </trans-unit>
        <trans-unit id="1dc0acb1a8bb4c81550d3ac71c2122f2718c66f7" translate="yes" xml:space="preserve">
          <source>Enumerables and Streams</source>
          <target state="translated">열거 형 및 스트림</target>
        </trans-unit>
        <trans-unit id="30d600c6cc439356af01777f989e3d24add2e962" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, by removing the elements for which function &lt;code&gt;fun&lt;/code&gt; returned duplicate elements.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수가 중복 요소를 반환 한 요소를 제거 하여 &lt;code&gt;enumerable&lt;/code&gt; 형을 열거합니다 .</target>
        </trans-unit>
        <trans-unit id="0710d3c7a9e2c2a7ab19f785bc7e4ac156c8c8ae" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, removing all duplicated elements.</source>
          <target state="translated">열거 된 모든 요소를 ​​제거 하고 &lt;code&gt;enumerable&lt;/code&gt; 열거합니다 .</target>
        </trans-unit>
        <trans-unit id="d63d851ffe5d4b54e805b90b32ec2610b7cdc775" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, returning a list where all consecutive duplicated elements are collapsed to a single element.</source>
          <target state="translated">열거 &lt;code&gt;enumerable&lt;/code&gt; 모든 열거 형을 열거하고 모든 연속 복제 된 요소가 단일 요소로 축소 된 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="e22b06d69ee07489bc27f1054e5551d2fb3ffec1" translate="yes" xml:space="preserve">
          <source>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;, for example:</source>
          <target state="translated">값을 보유하지 않고 기본적으로 플래그 역할을하는 환경 변수는 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;true&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="8263704ec4e031f9cd98ed43d056f7db9e2fa14d" translate="yes" xml:space="preserve">
          <source>Equal to operator. Returns &lt;code&gt;true&lt;/code&gt; if the two terms are equal.</source>
          <target state="translated">연산자와 같음. 두 항이 같으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5d9ca98304ae0b29eb5edae09971f0cda610aca2" translate="yes" xml:space="preserve">
          <source>Erlang Term Storage</source>
          <target state="translated">얼랭 용어 저장소</target>
        </trans-unit>
        <trans-unit id="873eaae56cb75c28c82e887676a81c9c926d3d76" translate="yes" xml:space="preserve">
          <source>Erlang VM process identifier.</source>
          <target state="translated">Erlang VM 프로세스 식별자.</target>
        </trans-unit>
        <trans-unit id="0f56eeaacbf7d4f4fe215cd958650ad712192183" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode code points. Bytes (&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode code points (&lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="translated">Erlang과 Elixir도 &lt;a href=&quot;#t:chardata/0&quot;&gt; &lt;code&gt;chardata/0&lt;/code&gt; &lt;/a&gt; 아이디어를 가지고 있습니다 . Chardata는 IO 데이터와 매우 유사합니다. 유일한 차이점은 IO 데이터의 정수는 바이트를 나타내고 chardata의 정수는 유니 코드 코드 포인트를 나타낸다는 것입니다. 바이트 ( &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;byte/0&lt;/code&gt; &lt;/a&gt; )는 &lt;code&gt;0..255&lt;/code&gt; 범위의 정수이고 유니 코드 코드 포인트 ( &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;char/0&lt;/code&gt; &lt;/a&gt; )는 &lt;code&gt;0..0x10FFFF&lt;/code&gt; 범위의 정수입니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈은 제공 &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt; 의은 &quot;카운터 파트&quot;로서 chardata 펑션 &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; IO 데이터 기능.</target>
        </trans-unit>
        <trans-unit id="5d81fb4bfd2d9c41c1a7ce9b604e0403471792c0" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode codepoints. Bytes (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode codepoints (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="translated">Erlang과 Elixir도 &lt;a href=&quot;#t:chardata/0&quot;&gt; &lt;code&gt;chardata/0&lt;/code&gt; 에&lt;/a&gt; 대한 아이디어를 가지고 있습니다 . Chardata는 IO 데이터와 매우 유사합니다. 유일한 차이점은 IO 데이터의 정수는 바이트를 나타내고 chardata의 정수는 유니 코드 코드 포인트를 나타냅니다. 바이트 ( &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;byte/0&lt;/code&gt; &lt;/a&gt; )는 &lt;code&gt;0..255&lt;/code&gt; 범위의 정수인 반면 유니 코드 코드 포인트 ( &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;char/0&lt;/code&gt; &lt;/a&gt; )는 &lt;code&gt;0..0x10FFFF&lt;/code&gt; 범위의 정수입니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈은 제공 &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; &lt;/a&gt; 의은 &quot;카운터 파트&quot;로서 chardata 펑션 &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; IO 데이터 기능.</target>
        </trans-unit>
        <trans-unit id="257cd41d0a52105a1f464fecff0c7474573eaa0b" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir are sometimes known for the capability of upgrading a node that is running in production without shutting down that node. However, this feature is not supported out of the box by Elixir releases.</source>
          <target state="translated">Erlang 및 Elixir는 때때로 해당 노드를 종료하지 않고 프로덕션에서 실행중인 노드를 업그레이드하는 기능으로 알려져 있습니다. 그러나이 기능은 Elixir 릴리스에서 즉시 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ad841c6351d40f6ce14b1c3365f66f45cf90f9a" translate="yes" xml:space="preserve">
          <source>Erlang configuration - options that handle integration with Erlang's logging facilities</source>
          <target state="translated">Erlang 구성-Erlang의 로깅 기능과의 통합을 처리하는 옵션</target>
        </trans-unit>
        <trans-unit id="dcdbc42e4590fc1cd5b2780008879d7043463df9" translate="yes" xml:space="preserve">
          <source>Erlang errors</source>
          <target state="translated">얼랭 오류</target>
        </trans-unit>
        <trans-unit id="afd9042ead7605c46c0058e1b4e52ac063ec4da4" translate="yes" xml:space="preserve">
          <source>Erlang errors are transformed into Elixir ones when rescuing:</source>
          <target state="translated">Erlang 오류는 구조 할 때 Elixir 오류로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef09a5110ea182804c30762b32ada9f7c5b439dd" translate="yes" xml:space="preserve">
          <source>Erlang handlers run in the same process as the process logging the message/event. This gives developers more flexibility but they should avoid performing any long running action in such handlers, as it may slow down the action being executed considerably. At the moment, there is no built-in overload protection for Erlang handlers, so it is your responsibility to implement it</source>
          <target state="translated">Erlang 핸들러는 메시지 / 이벤트를 기록하는 프로세스와 동일한 프로세스에서 실행됩니다. 이는 개발자에게 더 많은 유연성을 제공하지만 실행되는 작업이 상당히 느려질 수 있으므로 이러한 핸들러에서 장기 실행 작업을 수행하지 않아야합니다. 현재 Erlang 핸들러에 대한 기본 제공 과부하 보호 기능이 없으므로이를 구현하는 것은 귀하의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="80e47b987c75aeed2cf56f80f3a45202d7a9cade" translate="yes" xml:space="preserve">
          <source>Erlang has two modes to load code: interactive and embedded.</source>
          <target state="translated">Erlang에는 코드를로드하는 두 가지 모드 (대화식 및 임베디드)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4aea0a9415c252cca77b12b8e68bf25c0600b44" translate="yes" xml:space="preserve">
          <source>Erlang libraries</source>
          <target state="translated">Erlang 라이브러리</target>
        </trans-unit>
        <trans-unit id="947adf59db0f5074b68cab24e83d10f84084f65d" translate="yes" xml:space="preserve">
          <source>Erlang projects</source>
          <target state="translated">얼랭 프로젝트</target>
        </trans-unit>
        <trans-unit id="353a427c9c3948990fb1397e32a17449450dd341" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;tutorial&lt;/a&gt; with pictures that briefly describe Erlang&amp;rsquo;s primitives for concurrent programming.</source>
          <target state="translated">Erlang의 공식 웹 사이트에는 동시 프로그래밍을위한 Erlang의 기본 사항을 간략하게 설명하는 그림 이 포함 된 간단한 &lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;자습서&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2924249c9d3eeb99cc39153818164a0a08c129f2" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;https://www.erlang.org/course&quot;&gt;tutorial&lt;/a&gt;. There is chapter with pictures briefly describing Erlang&amp;rsquo;s primitives for &lt;a href=&quot;https://www.erlang.org/course/concurrent_programming.html&quot;&gt;concurrent programming&lt;/a&gt;.</source>
          <target state="translated">Erlang의 공식 웹 사이트에는 짧은 &lt;a href=&quot;https://www.erlang.org/course&quot;&gt;튜토리얼이&lt;/a&gt; 있습니다. &lt;a href=&quot;https://www.erlang.org/course/concurrent_programming.html&quot;&gt;동시 프로그래밍을&lt;/a&gt; 위한 Erlang의 기본 요소를 간략하게 설명하는 그림이있는 장이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64b602b5d1c8c7cedbd11a4c46c7bec0f2ef6328" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 19 onwards</source>
          <target state="translated">Erlang / OTP 19 이후</target>
        </trans-unit>
        <trans-unit id="9f3b0640f155508325d5fd627bb055c21f7b1145" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 20 onwards</source>
          <target state="translated">Erlang / OTP 20 이상</target>
        </trans-unit>
        <trans-unit id="3c959257e030332549e20072b5db96d3e0320669" translate="yes" xml:space="preserve">
          <source>Erlang/OTP handlers</source>
          <target state="translated">Erlang / OTP 핸들러</target>
        </trans-unit>
        <trans-unit id="e3d3ba354eaa3fdf7c394b986d2d13ceb0a09b7f" translate="yes" xml:space="preserve">
          <source>Erlang/OTP handlers must be listed under your own application:</source>
          <target state="translated">Erlang / OTP 핸들러는 자신의 애플리케이션 아래에 나열되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e20c6b34c6701bebbb6bc88a9d6f49d957b3f1ee" translate="yes" xml:space="preserve">
          <source>Erlang/OTP integration</source>
          <target state="translated">Erlang / OTP 통합</target>
        </trans-unit>
        <trans-unit id="0240f7d16642d7d18aa4135e9508d4430ca6ed28" translate="yes" xml:space="preserve">
          <source>Erlang/OTP versioning is independent from the versioning of Elixir. Each version of Elixir supports a specific range of Erlang/OTP versions. The compatibility table is shown below.</source>
          <target state="translated">Erlang / OTP 버전 관리는 Elixir 버전 관리와 무관합니다. 각 버전의 Elixir는 특정 범위의 Erlang / OTP 버전을 지원합니다. 호환성 표는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="95b539190ee1df5b25c9d30c7a60632c2c6242b6" translate="yes" xml:space="preserve">
          <source>ErlangError</source>
          <target state="translated">ErlangError</target>
        </trans-unit>
        <trans-unit id="eb887d05f639b63c61d49ed79af8fbf4426605b6" translate="yes" xml:space="preserve">
          <source>ErlangError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ErlangError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="6a37b79ee438a25b4b00f639862f12f01079bb8d" translate="yes" xml:space="preserve">
          <source>Error logger configuration</source>
          <target state="translated">오류 로거 구성</target>
        </trans-unit>
        <trans-unit id="9497fa3a6a15769b096afdea76d16a9bb93c4394" translate="yes" xml:space="preserve">
          <source>Error reasons</source>
          <target state="translated">오류 이유</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e4b51562d8691be50e95ec4d102a96ec94cfc7fc" translate="yes" xml:space="preserve">
          <source>Errors (or &lt;em&gt;exceptions&lt;/em&gt;) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number into an atom:</source>
          <target state="translated">코드에서 예외적 인 상황이 발생하면 오류 (또는 &lt;em&gt;예외&lt;/em&gt; )가 사용됩니다. 원자에 숫자를 추가하여 샘플 오류를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e769d29496e91df4803194e858296cef49f583c" translate="yes" xml:space="preserve">
          <source>Errors can be &lt;strong&gt;rescued&lt;/strong&gt; using the &lt;code&gt;try/rescue&lt;/code&gt; construct:</source>
          <target state="translated">오류가 될 수있다 &lt;strong&gt;구출&lt;/strong&gt; 사용하여 &lt;code&gt;try/rescue&lt;/code&gt; 구조를 :</target>
        </trans-unit>
        <trans-unit id="ace44333765fe041260545be00bfe6b34903e900" translate="yes" xml:space="preserve">
          <source>Errors in guards</source>
          <target state="translated">경비원의 오류</target>
        </trans-unit>
        <trans-unit id="6d7f25adbd68385b52715a0e769e2e3468d082ed" translate="yes" xml:space="preserve">
          <source>Escape characters</source>
          <target state="translated">이스케이프 문자</target>
        </trans-unit>
        <trans-unit id="7cf06e4f5765ec1423667355b26bedd03532387d" translate="yes" xml:space="preserve">
          <source>Escapes a string to be literally matched in a regex.</source>
          <target state="translated">정규식에서 문자 그대로 일치하도록 문자열을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="7e30234707fb1dda8ea3159dd78fbf5f465fb228" translate="yes" xml:space="preserve">
          <source>Escripts are installed at &lt;code&gt;~/.mix/escripts&lt;/code&gt;. Add that path to your &lt;code&gt;PATH&lt;/code&gt; environment variable to be able to run installed escripts from any directory.</source>
          <target state="translated">Escripts는 &lt;code&gt;~/.mix/escripts&lt;/code&gt; 에 설치됩니다 . 모든 디렉토리에서 설치된 escript를 실행할 수 있도록 해당 경로를 &lt;code&gt;PATH&lt;/code&gt; 환경 변수에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfc5f1f3afc3241e14ccf2fda82512fad9553a23" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="translated">Escript는 배포 메커니즘이 아닌 개발자간에 스크립트를 공유하는 메커니즘으로 사용해야합니다. 라이브 시스템을 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 또는 빌드 릴리스 사용을 고려하십시오 . 시스템 수명주기에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef08760354a34230fab73487dfba3c92eef3db07" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="translated">스크립트는 배포 메커니즘이 아니라 개발자간에 스크립트를 공유하는 메커니즘으로 사용해야합니다. 라이브 시스템을 &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 또는 빌딩 릴리스를 사용하십시오. 시스템 수명주기에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a5a63b505c94b9715c6cb22738effadf43970a2" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 에 연결 합니다 .</target>
        </trans-unit>
        <trans-unit id="5197d13a701e91968e7385a64eaafa020ebb9b3e" translate="yes" xml:space="preserve">
          <source>Evals the given file.</source>
          <target state="translated">주어진 파일을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a80e33a10ee3ca88cd7700527b66fae439803baa" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt;) or a file (&lt;a href=&quot;#eval_file/3&quot;&gt;&lt;code&gt;eval_file/3&lt;/code&gt;&lt;/a&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="translated">문자열 ( &lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt; ) 또는 파일 ( &lt;a href=&quot;#eval_file/3&quot;&gt; &lt;code&gt;eval_file/3&lt;/code&gt; &lt;/a&gt; )을 직접 평가하십시오. 이것은 사용하기 가장 간단한 API이지만 코드가 평가되고 전에 컴파일되지 않았기 때문에 가장 느립니다.</target>
        </trans-unit>
        <trans-unit id="c61e6ac1811baae3135839c7b54f099f020838b7" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;code&gt;eval_string&lt;/code&gt;) or a file (&lt;code&gt;eval_file&lt;/code&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="translated">문자열 ( &lt;code&gt;eval_string&lt;/code&gt; ) 또는 파일 ( &lt;code&gt;eval_file&lt;/code&gt; )을 직접 평가하십시오. 코드는 이전에 평가되지 않고 컴파일되지 않았으므로 사용하기 가장 간단한 API이지만 가장 느립니다.</target>
        </trans-unit>
        <trans-unit id="b6b73d4e37c0e2fc6bcd10607ad1cdb1b13313ab" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">평가됩니다의 &lt;code&gt;fun&lt;/code&gt; 에서와 풋 결과를 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; 않는 &lt;code&gt;key&lt;/code&gt; 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="47fea9e50d94c5ba5334f9182ab4da272971ff69" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in keyword list unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 이미 존재 하지 않는 한 &lt;code&gt;fun&lt;/code&gt; 평가 하고 키워드 목록의 &lt;code&gt;key&lt;/code&gt; 아래에 결과를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="378c49e24c10c27a713c2ca33d351716056ef24a" translate="yes" xml:space="preserve">
          <source>Evaluates and copy templates at &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 에서 &lt;code&gt;target&lt;/code&gt; 템플릿을 평가하고 복사 합니다.</target>
        </trans-unit>
        <trans-unit id="40a2755ea234063a3a9b34d6399df316742199aa" translate="yes" xml:space="preserve">
          <source>Evaluates the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; filters against the given &lt;code&gt;tags&lt;/code&gt; to determine if tests should be skipped or excluded.</source>
          <target state="translated">주어진 &lt;code&gt;tags&lt;/code&gt; 에 대해 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 필터를 평가하여 테스트를 건너 뛰거나 제외해야하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a872b79753ae8c15cc036688d28a6487ac1713c4" translate="yes" xml:space="preserve">
          <source>Evaluates the configuration &lt;code&gt;contents&lt;/code&gt; for the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 대한 구성 &lt;code&gt;contents&lt;/code&gt; 을 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="6d2ad4fd562a8770695759664566e68c79e896d7" translate="yes" xml:space="preserve">
          <source>Evaluates the contents given by &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 으로 주어진 내용을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="3f66e28bdcb030fa5267d28739b480d4ccf00895" translate="yes" xml:space="preserve">
          <source>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</source>
          <target state="translated">정확한 값으로 평가되는 첫 번째 절에 해당하는 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1ba5f7241081077b03b80183e469003ca9d8656f" translate="yes" xml:space="preserve">
          <source>Evaluates the given configuration file.</source>
          <target state="translated">주어진 구성 파일을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="f9da9d74593adcfa13d94962a59c2dd76ee78247" translate="yes" xml:space="preserve">
          <source>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</source>
          <target state="translated">주어진 표현식을 평가하고 발생한 오류, 종료 또는 발생을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8c971533ea3061f79d23aaa5efa90e539f841e09" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents in the given module's context.</source>
          <target state="translated">주어진 모듈의 컨텍스트에서 인용 된 내용을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="faed542c6d7a022474593aebff34b62313141b57" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents.</source>
          <target state="translated">인용 된 내용을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="211455d468ff468d1666caa77c6ea4a591130f77" translate="yes" xml:space="preserve">
          <source>Evaluating configuration</source>
          <target state="translated">구성 평가</target>
        </trans-unit>
        <trans-unit id="af2f0cacf83a79f7f113163a613ddccc7608558d" translate="yes" xml:space="preserve">
          <source>Even a map is represented as a call to &lt;code&gt;%{}&lt;/code&gt;:</source>
          <target state="translated">지도조차도 &lt;code&gt;%{}&lt;/code&gt; 대한 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9379ba740718a45c562052c55dae060f6e11aa7a" translate="yes" xml:space="preserve">
          <source>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</source>
          <target state="translated">타이머가 만료되어 메시지가 전송 된 경우에도이 기능은 타임 아웃 메시지가 목적지에 도착했는지 여부를 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27ed9c8d1ab5b1899cff5f812cb51b56f1af0736" translate="yes" xml:space="preserve">
          <source>Even if we have type-specific functions for getting the size built into Elixir (such as &lt;code&gt;tuple_size/1&lt;/code&gt;), we could implement a generic &lt;code&gt;Size&lt;/code&gt; protocol that all data structures for which size is pre-computed would implement.</source>
          <target state="translated">Elixir에 내장 된 크기 (예 : &lt;code&gt;tuple_size/1&lt;/code&gt; ) 를 가져 오는 유형별 함수가 있더라도 크기가 사전 계산 된 모든 데이터 구조 가 구현하는 일반 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8348e73cb5ab059583fd7f108ed8a332dfe09b" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it&amp;rsquo;s considered to be bad style to use them when they&amp;rsquo;re not necessary. So write macros responsibly.</source>
          <target state="translated">Elixir는 매크로에 안전한 환경을 제공하기 위해 최선을 다하지만 매크로를 사용하여 깨끗한 코드를 작성하는 주요 책임은 개발자에게 있습니다. 매크로는 일반 Elixir 함수보다 쓰기가 어렵고 필요하지 않을 때 사용하기에는 좋지 않은 스타일로 간주됩니다. 따라서 책임감있게 매크로를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="52a8ac08291fe93f3d696a3c45b1d1387494b7dc" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly.</source>
          <target state="translated">Elixir는 매크로에 안전한 환경을 제공하기 위해 최선을 다하지만 매크로를 사용하여 깨끗한 코드를 작성하는 주요 책임은 개발자에게 있습니다. 매크로는 일반 Elixir 함수보다 쓰기가 어렵고 필요하지 않을 때는 사용하기에 좋지 않은 스타일로 간주됩니다. 따라서 책임감있게 매크로를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b287135931c568aaa11f51a4123249a43f85f9eb" translate="yes" xml:space="preserve">
          <source>Even though lists preserve the user ordering, the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any ordering. For example, if you invoke &lt;code&gt;Keyword.put(opts, new_key, new_value)&lt;/code&gt;, there is no guarantee to where &lt;code&gt;new_key&lt;/code&gt; will be added (to the front, to the end, or anywhere else).</source>
          <target state="translated">목록은 사용자 순서를 유지하지만 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 의 함수는 순서를 보장하지 않습니다. 예를 들어 &lt;code&gt;Keyword.put(opts, new_key, new_value)&lt;/code&gt; 를 호출하면 &lt;code&gt;new_key&lt;/code&gt; 가 추가 될 위치 (앞쪽, 끝쪽 또는 다른 위치)가 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="028b9d4259c03a084cc43fe3d1014cc325f783d4" translate="yes" xml:space="preserve">
          <source>Even though the directory is empty and there is no &lt;code&gt;.app&lt;/code&gt; file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash &lt;code&gt;-&lt;/code&gt; which is considered to be the app version and it is removed for the lookup purposes:</source>
          <target state="translated">디렉토리가 비어 있고 &lt;code&gt;.app&lt;/code&gt; 파일 이 없더라도 &quot;foo / ebin&quot;이라는 이름을 기준으로 응용 프로그램 디렉토리로 간주됩니다. 이름은 대시를 포함 할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 대시 는 앱 버전으로 간주되며 조회 목적으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c198b47773d307f8ee645f6d155cb12a7d81efef" translate="yes" xml:space="preserve">
          <source>Even though the head of the list is not &lt;code&gt;nil&lt;/code&gt;, the first clause for &lt;code&gt;not_nil_head?/1&lt;/code&gt; fails because the expression does not evaluate to &lt;code&gt;true&lt;/code&gt;, but to &lt;code&gt;&quot;some_value&quot;&lt;/code&gt;, therefore triggering the second clause which returns &lt;code&gt;false&lt;/code&gt;. To make the guard behave correctly, you must ensure that the guard evaluates to &lt;code&gt;true&lt;/code&gt;, like so:</source>
          <target state="translated">목록의 헤드가 &lt;code&gt;nil&lt;/code&gt; 이 아니더라도 식이 &lt;code&gt;true&lt;/code&gt; 로 평가되지 않고 &lt;code&gt;&quot;some_value&quot;&lt;/code&gt; 로 평가되기 때문에 &lt;code&gt;not_nil_head?/1&lt;/code&gt; 의 첫 번째 절이 실패하여 &lt;code&gt;false&lt;/code&gt; 를 반환하는 두 번째 절이 트리거 됩니다. 가드가 올바르게 작동하도록하려면 가드가 &lt;code&gt;true&lt;/code&gt; 평가되는지 확인해야 합니다. 과 같이 .</target>
        </trans-unit>
        <trans-unit id="0521395297ab7a58030d272e2c72be5c8cdef7df" translate="yes" xml:space="preserve">
          <source>Even though the match works, &lt;code&gt;assert&lt;/code&gt; still expects a truth value. In such cases, simply use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;Kernel.==/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">성냥은 효과가 있지만, &lt;code&gt;assert&lt;/code&gt; 여전히 진실의 가치를 기대합니다. 이러한 경우에는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;Kernel.==/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; 를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e115b0b23e56d703ace76f71257a63ef9824a34f" translate="yes" xml:space="preserve">
          <source>Even though the representation changed, the raw data does remain a list of numbers, which can be handled as such:</source>
          <target state="translated">표현이 변경 되더라도 원시 데이터는 숫자 목록으로 유지되며 다음과 같이 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="84e3c9de2ccf9da0f358458d3784bc3f849f3c2c" translate="yes" xml:space="preserve">
          <source>Even though we haven't specified &lt;code&gt;--debug&lt;/code&gt; in the list of switches, it is part of the returned options. This would also work:</source>
          <target state="translated">스위치 목록에 &lt;code&gt;--debug&lt;/code&gt; 를 지정하지 않았지만 반환 된 옵션의 일부입니다. 이것은 또한 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="7cb4e4b7449c91102c58fcbb978127750613197b" translate="yes" xml:space="preserve">
          <source>Even with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:</source>
          <target state="translated">이러한 보장이 있더라도 개발자는 책임감있게 매크로를 작성할 때 큰 역할을합니다. 매크로에 의지해야한다고 확신한다면 매크로는 API가 아님을 기억하십시오. 인용 된 내용을 포함하여 매크로 정의를 짧게 유지하십시오. 예를 들어, 다음과 같은 매크로를 작성하는 대신 :</target>
        </trans-unit>
        <trans-unit id="f153167a1bbb1f584f7f422c6cb126c95946d20e" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="translated">모든 describe 블록은 다가오는 테스트의 접두사로 사용되는 이름을받습니다. 블록 내에서 &lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt; &lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt; &lt;/a&gt; 이 호출 될 수 있으며 현재 블록에 대해서만 실행되도록 설정 콜백을 정의합니다. 설명 이름도 태그로 추가되어 개발자가 특정 블록에 대한 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46c9a7fca545c132d8df109dd8dcaca95a3c354" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="translated">모든 설명 블록은 향후 테스트의 접두사로 사용되는 이름을받습니다. 블록 내에서 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#setup/1&quot;&gt; &lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt; &lt;/a&gt; 이 호출 될 수 있으며 현재 블록에 대해서만 실행되도록 설정 콜백을 정의합니다. 설명 이름도 태그로 추가되어 개발자가 특정 블록에 대한 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef3d6f408824f6647a6e0d3de1a30549693b5c2" translate="yes" xml:space="preserve">
          <source>Every function clause dispatches the appropriate command to the &lt;code&gt;KV.Registry&lt;/code&gt; server that we registered during the &lt;code&gt;:kv&lt;/code&gt; application startup. Since our &lt;code&gt;:kv_server&lt;/code&gt; depends on the &lt;code&gt;:kv&lt;/code&gt; application, it is completely fine to depend on the services it provides.</source>
          <target state="translated">모든 함수 절은 적절한 명령을 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 시작 중에 등록한 &lt;code&gt;KV.Registry&lt;/code&gt; 서버에 전달합니다 . 우리의 &lt;code&gt;:kv_server&lt;/code&gt; 는 &lt;code&gt;:kv&lt;/code&gt; 어플리케이션에 의존하기 때문에 제공하는 서비스에 의존하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="40baf8ceb490ed83843fc93e589192534f9511aa" translate="yes" xml:space="preserve">
          <source>Every new test starts on a new line, with an &lt;code&gt;iex&amp;gt;&lt;/code&gt; prefix. Multiline expressions can be used by prefixing subsequent lines with either &lt;code&gt;...&amp;gt;&lt;/code&gt; (recommended) or &lt;code&gt;iex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">모든 새 테스트는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 접두사를 사용하여 새 줄에서 시작됩니다 . 다음 줄 앞에 &lt;code&gt;...&amp;gt;&lt;/code&gt; (권장) 또는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 를 붙여 여러 줄 식을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76e353e9635feb9762b1896c7c1b95987d4b25d4" translate="yes" xml:space="preserve">
          <source>Every project has a &lt;code&gt;mix.exs&lt;/code&gt; file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a &lt;code&gt;lib&lt;/code&gt; directory, which includes Elixir source code, and a &lt;code&gt;test&lt;/code&gt; directory. A &lt;code&gt;src&lt;/code&gt; directory may also exist for Erlang sources.</source>
          <target state="translated">모든 프로젝트에는 &lt;code&gt;mix.exs&lt;/code&gt; 파일 이 있으며 빌드, 컴파일, 테스트 실행 방법에 대한 지침이 있습니다. 라이브러리에는 일반적으로 Elixir 소스 코드 및 &lt;code&gt;test&lt;/code&gt; 디렉토리 가 포함 된 &lt;code&gt;lib&lt;/code&gt; 디렉토리가 있습니다 . Erlang 소스 의 경우 &lt;code&gt;src&lt;/code&gt; 디렉토리가 존재할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a22b2e5fd456a7ae0a76d486db20f724d54096" translate="yes" xml:space="preserve">
          <source>Every release contains an environment file, named &lt;code&gt;env.sh&lt;/code&gt; on Unix-like systems and &lt;code&gt;env.bat&lt;/code&gt; on Windows machines, that executes before the Elixir system starts. In this file, you can execute any OS-level code, such as invoke other applications, set environment variables and so on. Some of those environment variables can even configure how the release itself runs.</source>
          <target state="translated">모든 릴리스에는 Unix 계열 시스템에서 &lt;code&gt;env.sh&lt;/code&gt; 라는 환경 파일 과 Windows 시스템에서 &lt;code&gt;env.bat&lt;/code&gt; 라는 환경 파일이 포함되어 있으며 이는 Elixir 시스템이 시작되기 전에 실행됩니다. 이 파일에서 다른 응용 프로그램 호출, 환경 변수 설정 등과 같은 OS 레벨 코드를 실행할 수 있습니다. 이러한 환경 변수 중 일부는 릴리스 자체의 실행 방식을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ec0c5ca215e236f63402da7cfee38e03a48ba1" translate="yes" xml:space="preserve">
          <source>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</source>
          <target state="translated">파일을 열 때마다 Elixir는 새로운 프로세스를 생성합니다. 파일에 쓰는 것은 파일 디스크립터에 쓰는 프로세스에 메시지를 보내는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d10c5b0b93979a90184cbb51fe0a0e036d577833" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful as storage during module compilation.</source>
          <target state="translated">함수 내에서 속성을 읽을 때마다 현재 값의 스냅 샷이 작성됩니다. 즉, 값은 런타임이 아닌 컴파일 시간에 읽 힙니다. 앞으로 보 겠지만, 이것은 또한 모듈 컴파일 중에 저장으로 유용한 속성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8195a151075d5ab9fbd9a600b260682c39388d0f" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful to be used as storage during module compilation.</source>
          <target state="translated">함수 내에서 속성을 읽을 때마다 현재 값의 스냅 샷이 작성됩니다. 즉, 값은 런타임이 아닌 컴파일 타임에 읽습니다. 앞으로 살펴 보 겠지만, 이는 모듈 컴파일 과정에서 속성을 스토리지로 사용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="78b99dda1ab8cad5aa5dc088e4709cd8ffa9a689" translate="yes" xml:space="preserve">
          <source>Every time we need to look up a bucket, we need to send a message to the registry. In case our registry is being accessed concurrently by multiple processes, the registry may become a bottleneck!</source>
          <target state="translated">버킷을 찾아야 할 때마다 레지스트리에 메시지를 보내야합니다. 여러 프로세스에서 동시에 레지스트리에 액세스하는 경우 레지스트리에 병목 현상이 발생할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="62cee6babe5c5a8fa4e03c567fac109731766e5f" translate="yes" xml:space="preserve">
          <source>Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes. In this case, we are using &lt;code&gt;:one_for_one&lt;/code&gt; and the &lt;code&gt;KV.Registry&lt;/code&gt; is started before &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;.</source>
          <target state="translated">감독자에 새 자식을 추가 할 때마다 자식 전략의 순서와 감독자 전략이 올바른지 평가하는 것이 중요합니다. 이 경우 &lt;code&gt;:one_for_one&lt;/code&gt; 을 사용하고 &lt;code&gt;KV.Registry&lt;/code&gt; 가 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 보다 먼저 시작 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b446cdb18e309af06e8229f9b0fda9244ac6da3e" translate="yes" xml:space="preserve">
          <source>Every time you concatenate binaries or use interpolation (&lt;code&gt;#{}&lt;/code&gt;) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data:</source>
          <target state="translated">이진을 연결하거나 보간 ( &lt;code&gt;#{}&lt;/code&gt; )을 사용할 때마다 해당 이진의 복사본을 만듭니다. 그러나 대부분의 경우 바이너리를 만드는 동안 완전한 바이너리가 필요하지 않지만 인쇄 또는 어딘가에 보낼 때만 끝납니다. 이러한 경우 IO 데이터를 만들어 바이너리를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed798ff113b14474967cd268a8bbd91a2314f668" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;GenServer.call/3&lt;/code&gt; &lt;/a&gt; 을 수행 할 때마다 클라이언트는 GenServer 에서 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 콜백에 의해 처리되어야하는 메시지를 보냅니다. &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; 메시지를 처리해야 &lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 사용할 때 7 가지 가능한 콜백을 구현할 수 있습니다 . 유일한 필수 콜백은 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="962675beca29d3a850376db901731b3eb3593d3c" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;genserver#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;genserver#call/3&quot;&gt; &lt;code&gt;GenServer.call/3&lt;/code&gt; &lt;/a&gt; 을 수행 할 때마다 클라이언트는 GenServer 의 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 콜백에서 처리해야하는 메시지를 보냅니다. &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; 메시지를 처리해야 &lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 사용할 때 7 가지 콜백이 구현 될 수 있습니다 . 필요한 콜백은 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3205df423b3d81a662d949f234ea958bc947b117" translate="yes" xml:space="preserve">
          <source>Every value in the map is a string, and these are:</source>
          <target state="translated">지도의 모든 값은 문자열이며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd021f13376bc32f27e40804859460a61c19bc80" translate="yes" xml:space="preserve">
          <source>Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.</source>
          <target state="translated">에이전트에 전달한 함수 내부의 모든 것은 에이전트 프로세스에서 발생합니다. 이 경우 에이전트 프로세스는 메시지를 수신하고 응답하는 프로세스이므로 에이전트 프로세스는 서버입니다. 함수 외부의 모든 것은 클라이언트에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1cf46969c22298bcd54d98e6e2c526dc85b4471b" translate="yes" xml:space="preserve">
          <source>Everything we have done so far could have been implemented with an &lt;code&gt;Agent&lt;/code&gt;. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.</source>
          <target state="translated">우리가 지금까지 한 모든 일은 &lt;code&gt;Agent&lt;/code&gt; 로 구현되었을 수 있습니다 . 이 섹션에서는 에이전트로는 불가능한 GenServer로 달성 할 수있는 많은 것들 중 하나를 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="76820f41cc3743792e89eb2f8f24b62c9538f00b" translate="yes" xml:space="preserve">
          <source>ExUnit</source>
          <target state="translated">ExUnit</target>
        </trans-unit>
        <trans-unit id="5c93a2b236252a89748bc06f469e33d5dc2f6a4b" translate="yes" xml:space="preserve">
          <source>ExUnit automatically creates a temporary directory for tests tagged with &lt;code&gt;:tmp_dir&lt;/code&gt; and puts the path to that directory into the test context. The directory is removed before being created to ensure we start with a blank slate.</source>
          <target state="translated">ExUnit은 &lt;code&gt;:tmp_dir&lt;/code&gt; 태그가 붙은 테스트를위한 임시 디렉터리를 자동으로 만들고 해당 디렉터리의 경로를 테스트 컨텍스트에 넣습니다. 빈 슬레이트로 시작하도록 만들기 전에 디렉토리가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0bdc79e9fc2af1de5a45467b3f1630138afbfe1" translate="yes" xml:space="preserve">
          <source>ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging.</source>
          <target state="translated">ExUnit은 테스트 중에 생성 된 로그 메시지의 인쇄를 선택적으로 억제 할 수 있습니다. 테스트를 실행하는 동안 생성 된 로그 메시지는 캡처되며 테스트에 실패한 경우에만 디버깅을 돕기 위해 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c48c9be568f6b4c0f2e197839d3d8f36c2515f00" translate="yes" xml:space="preserve">
          <source>ExUnit provides tags and filtering functionality that allow developers to select which tests to run. The most common functionality is to exclude some particular tests from running by default in your test helper file:</source>
          <target state="translated">ExUnit은 개발자가 실행할 테스트를 선택할 수있는 태그 및 필터링 기능을 제공합니다. 가장 일반적인 기능은 테스트 도우미 파일에서 일부 특정 테스트가 기본적으로 실행되지 않도록 제외하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="745dfe2a60f037338c2fefadc9162188f364f731" translate="yes" xml:space="preserve">
          <source>ExUnit supports the following options:</source>
          <target state="translated">ExUnit은 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2a6345907bef5ae0698454dc9d06ee0ed677f2c2" translate="yes" xml:space="preserve">
          <source>ExUnit.AssertionError</source>
          <target state="translated">ExUnit.AssertionError</target>
        </trans-unit>
        <trans-unit id="7bca0a1e09b5a1e6a12113e9ce6109c131e65f8d" translate="yes" xml:space="preserve">
          <source>ExUnit.AssertionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.AssertionError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f25c6298726d908d1e5e794bcc788478aa5fad10" translate="yes" xml:space="preserve">
          <source>ExUnit.Assertions</source>
          <target state="translated">ExUnit.Assertions</target>
        </trans-unit>
        <trans-unit id="57cef9f68db32989085431b21b29a52b82750643" translate="yes" xml:space="preserve">
          <source>ExUnit.Callbacks</source>
          <target state="translated">ExUnit.Callbacks</target>
        </trans-unit>
        <trans-unit id="b3d66fa6516f4ac426d6095179546b33f36c0614" translate="yes" xml:space="preserve">
          <source>ExUnit.CaptureIO</source>
          <target state="translated">ExUnit.CaptureIO</target>
        </trans-unit>
        <trans-unit id="2ad208584040b9fe065269a5120b26089443ba8f" translate="yes" xml:space="preserve">
          <source>ExUnit.CaptureLog</source>
          <target state="translated">ExUnit.CaptureLog</target>
        </trans-unit>
        <trans-unit id="b2783ae3bb7e24c853deac54a917d583149053c2" translate="yes" xml:space="preserve">
          <source>ExUnit.Case</source>
          <target state="translated">ExUnit.Case</target>
        </trans-unit>
        <trans-unit id="987b4f38599b32760dd676508e3a70f39b41abee" translate="yes" xml:space="preserve">
          <source>ExUnit.CaseTemplate</source>
          <target state="translated">ExUnit.CaseTemplate</target>
        </trans-unit>
        <trans-unit id="53d1f918a06cc534372a86260796a2d4c309360f" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest</source>
          <target state="translated">ExUnit.DocTest</target>
        </trans-unit>
        <trans-unit id="d9999b4f8af1e866e1f0ea61762d5c1cc8ad2341" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest.Error</source>
          <target state="translated">ExUnit.DocTest.Error</target>
        </trans-unit>
        <trans-unit id="67f2a3042727823ccf7dbd9817c09cbbb8efa9a4" translate="yes" xml:space="preserve">
          <source>ExUnit.DocTest.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DocTest.Error &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="704ab5cbebf8d2029c97c7f45718c1bb4afd3696" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateDescribeError</source>
          <target state="translated">ExUnit.DuplicateDescribeError</target>
        </trans-unit>
        <trans-unit id="aa1d2c3323c831aec609875e9f0efa265c871e03" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateDescribeError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DuplicateDescribeError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1405ead3862a5cfca420a49f538bc241594f997e" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateTestError</source>
          <target state="translated">ExUnit.DuplicateTestError</target>
        </trans-unit>
        <trans-unit id="2a268d99fb56998619707be3b9214a541f86d7ab" translate="yes" xml:space="preserve">
          <source>ExUnit.DuplicateTestError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.DuplicateTestError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d7bd9d677f0a9c6dc45310d081af8fcc4ca6e2ec" translate="yes" xml:space="preserve">
          <source>ExUnit.Filters</source>
          <target state="translated">ExUnit.Filters</target>
        </trans-unit>
        <trans-unit id="f8206f0d81a07fa8af2ac0840c2bae2ed2f08165" translate="yes" xml:space="preserve">
          <source>ExUnit.Formatter</source>
          <target state="translated">ExUnit.Formatter</target>
        </trans-unit>
        <trans-unit id="229fc09a3b8e6efa5ac9d2ca8a11a9f502333ec1" translate="yes" xml:space="preserve">
          <source>ExUnit.MultiError</source>
          <target state="translated">ExUnit.MultiError</target>
        </trans-unit>
        <trans-unit id="735227bd3ecbb542e7953b335de901a172e5d02e" translate="yes" xml:space="preserve">
          <source>ExUnit.MultiError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.MultiError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c5c72bd93dc7e3f0a7d2fffbd54cf9bb0f675038" translate="yes" xml:space="preserve">
          <source>ExUnit.Test</source>
          <target state="translated">ExUnit.Test</target>
        </trans-unit>
        <trans-unit id="97bb13a74b9a963a04a1d616ace7b7ad0af2e626" translate="yes" xml:space="preserve">
          <source>ExUnit.TestModule</source>
          <target state="translated">ExUnit.TestModule</target>
        </trans-unit>
        <trans-unit id="f755d37b9e89df3ed4f26779dc2f46df095cbb0b" translate="yes" xml:space="preserve">
          <source>ExUnit.TimeoutError</source>
          <target state="translated">ExUnit.TimeoutError</target>
        </trans-unit>
        <trans-unit id="0eb19ea70731acc4546a8736af6c56cc94e70fc3" translate="yes" xml:space="preserve">
          <source>ExUnit.TimeoutError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ExUnit.TimeoutError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">출력 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="d26b3d4470724ac05d7c9da540813fd9a38a03b8" translate="yes" xml:space="preserve">
          <source>Example: aggregating coverage reports from all umbrella children</source>
          <target state="translated">예 : 모든 우산 어린이의 커버리지 보고서 집계</target>
        </trans-unit>
        <trans-unit id="c74c91815529047b04fef7063d238333584897a5" translate="yes" xml:space="preserve">
          <source>Example: aggregating partitioned runs</source>
          <target state="translated">예 : 분할 된 실행 집계</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="25122b962e79de0ee8a27ce3b5647bd4c01ca409" translate="yes" xml:space="preserve">
          <source>Examples (in ISO)</source>
          <target state="translated">예 (ISO)</target>
        </trans-unit>
        <trans-unit id="0d3f1fb4ead37a9ebada8ba4792a85c60fc239e8" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_list/1&quot;&gt; &lt;code&gt;Kernel.is_list/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36164a25cdcc73cd1cf8d728f5b2f50878a4ec40" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c5fda773f78bb26a8e1303d5c85d69d871488af" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#map_size/1&quot;&gt; &lt;code&gt;Kernel.map_size/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad9928fd1db4bd5dbdaaf41bf03f0e344ec8d2e7" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt; &lt;code&gt;Mix.debug?/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#contains?/2&quot;&gt; &lt;code&gt;String.contains?/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b67cde3e2893f45e1d2342cc89a6c494050168c1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#is_list/1&quot;&gt; &lt;code&gt;Kernel.is_list/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fba0066e54914f2c201f52bafe91a91ee882db71" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59e48be0f15bfe533102ec4eff7ccf70153ea050" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;kernel#map_size/1&quot;&gt; &lt;code&gt;Kernel.map_size/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8894d30453776d313609dc175c436a396fe228a1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt; &lt;code&gt;Mix.debug?/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;string#contains?/2&quot;&gt; &lt;code&gt;String.contains?/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80519cae3a2fe4f658e3d881595a3f1c8312fcf3" translate="yes" xml:space="preserve">
          <source>Excellent!</source>
          <target state="translated">Excellent!</target>
        </trans-unit>
        <trans-unit id="60ec7b5f4ed1c9f91fe92c8f85e12cb5b5d0e653" translate="yes" xml:space="preserve">
          <source>Excellent! A release was assembled in &lt;code&gt;_build/prod/rel/foo&lt;/code&gt;. Inside the release, there will be a &lt;code&gt;bin/foo&lt;/code&gt; file which is the entry point to your system. It supports multiple commands, such as:</source>
          <target state="translated">우수한! 릴리즈는 &lt;code&gt;_build/prod/rel/foo&lt;/code&gt; 에 어셈블되었습니다 . 릴리스 안에는 시스템의 진입 점 인 &lt;code&gt;bin/foo&lt;/code&gt; 파일이 있습니다. 다음과 같은 여러 명령을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="44e97cbdae038c2c5424f2954134819fe68f1b89" translate="yes" xml:space="preserve">
          <source>Exception &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">예외 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="3d517d7c8883cc469bb6f0690fb53e26f6870d0a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="translated">예외는 &lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 모듈이 지원하는 구조체 입니다. &lt;a href=&quot;exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 동작을 구현하는 두 가지 기능이 필요합니다</target>
        </trans-unit>
        <trans-unit id="8e51b2994e896de8ce300f36d4a22aa73a3be30a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="translated">예외는 &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 모듈에 의해 지원되는 구조체 입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 동작을 구현하는 두 가지 기능이 필요합니다</target>
        </trans-unit>
        <trans-unit id="f5f7c811b0be5635dd0fe494c23bb6038a54a491" translate="yes" xml:space="preserve">
          <source>Exceptions in the &lt;code&gt;else&lt;/code&gt; block are not caught. If no pattern inside the &lt;code&gt;else&lt;/code&gt; block matches, an exception will be raised; this exception is not caught by the current &lt;code&gt;try/catch/rescue/after&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 블록의 예외는 포착되지 않습니다. &lt;code&gt;else&lt;/code&gt; 블록 내의 패턴이 일치 하지 않으면 예외가 발생합니다. 이 예외는 현재 &lt;code&gt;try/catch/rescue/after&lt;/code&gt; 블록에 의해 포착되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ea74b62ed292a57db053839d4dd2cfb1e0f29152" translate="yes" xml:space="preserve">
          <source>Excluded (via :exclude filters)</source>
          <target state="translated">제외됨 : 필터 제외</target>
        </trans-unit>
        <trans-unit id="3341b34959d98dd397fee5b24380ce422a7f718a" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; as a shell command and invokes the &lt;code&gt;callback&lt;/code&gt; for the streamed response.</source>
          <target state="translated">주어진 &lt;code&gt;command&lt;/code&gt; 을 쉘 명령 으로 실행하고 스트리밍 된 응답에 대한 &lt;code&gt;callback&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="70a317365d7713ea507b0cb5d939c290a69f7da8" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;command&lt;/code&gt; 을 &lt;code&gt;args&lt;/code&gt; 로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="8de8bb94364b91423f5a970361d0ca351b0ec3d4" translate="yes" xml:space="preserve">
          <source>Executes the given command and forwards its messages to the current process.</source>
          <target state="translated">주어진 명령을 실행하고 해당 메시지를 현재 프로세스로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c1372af04a9efd8163a10572859082b925f8dafa" translate="yes" xml:space="preserve">
          <source>Executes the given command and prints its output to stdout as it comes.</source>
          <target state="translated">주어진 명령을 실행하고 출력을 stdout에 출력합니다.</target>
        </trans-unit>
        <trans-unit id="a75d5012d51d09974229d69b19fd7d7622bdc109" translate="yes" xml:space="preserve">
          <source>Executes the given command and returns its exit status.</source>
          <target state="translated">주어진 명령을 실행하고 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c07c6d426de3d265c77a3c160b7a3bafe862b2c" translate="yes" xml:space="preserve">
          <source>Executes the given command quietly without outputting anything.</source>
          <target state="translated">아무것도 출력하지 않고 주어진 명령을 조용히 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4004d7a200a9edc8cf038043abae23d5809c733f" translate="yes" xml:space="preserve">
          <source>Executes the given command.</source>
          <target state="translated">주어진 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="55f164b4c64455051e302faf23d4842520137933" translate="yes" xml:space="preserve">
          <source>Executes the given function for each element.</source>
          <target state="translated">각 요소에 대해 주어진 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b5ce416e76da997843fde479e97ac42967b3d692" translate="yes" xml:space="preserve">
          <source>Executes the tasks separated by comma.</source>
          <target state="translated">작업을 쉼표로 구분하여 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7ac90140fbd596d3f7878d936c650ac9466a6ee5" translate="yes" xml:space="preserve">
          <source>Exit reasons and restarts</source>
          <target state="translated">종료 이유 및 재시작</target>
        </trans-unit>
        <trans-unit id="53b33039635fa494645e1b43b50ac67531129d6a" translate="yes" xml:space="preserve">
          <source>Exiting the shell</source>
          <target state="translated">쉘 종료</target>
        </trans-unit>
        <trans-unit id="f45e71feb97fe698bfbbe5199dddf26ea61ae573" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, and so forth.</source>
          <target state="translated">다른 이유로 종료하는 것은 비정상적인 것으로 간주되며 충돌로 처리됩니다. 즉, 기본 감독자 동작이 시작되고 오류 보고서가 생성되는 등의 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="31a12820b55617ff15b68585a3da10bfbeb53dca" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</source>
          <target state="translated">다른 이유로 종료하면 비정상으로 간주되어 충돌로 처리됩니다. 이는 기본 수퍼바이저 동작이 시작되고 오류 보고서가 생성되는 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="7977d0a8642620960ce842afec7459a90da93ce6" translate="yes" xml:space="preserve">
          <source>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;:</source>
          <target state="translated">프로세스가 비정상적으로 종료되었는지 여부를 판별하기 위해 OTP에서 엑시트를 사용합니다. 다음 출구는 &quot;정상&quot;으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d2a34bd07d0e86299a6bc287e4921ca1aef50681" translate="yes" xml:space="preserve">
          <source>Expands the path relative to the path given as the second argument expanding any &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; characters.</source>
          <target state="translated">any를 확장하는 두 번째 인수로 제공된 경로를 기준으로 경로를 확장합니다 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;..&lt;/code&gt; 문자.</target>
        </trans-unit>
        <trans-unit id="56faca74d01072fe618cfc8860e3704b0f548536" translate="yes" xml:space="preserve">
          <source>Expands the struct given by &lt;code&gt;module&lt;/code&gt; in the given &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;env&lt;/code&gt; 에서 &lt;code&gt;module&lt;/code&gt; 이 제공 한 구조체를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="a58d845ac21beded647c9679bfd179b6ae8af84c" translate="yes" xml:space="preserve">
          <source>Expands to something akin to:</source>
          <target state="translated">다음과 유사한 것으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae47f3ad3318c24412abe41c786c7c08970f0f5" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;date&lt;/code&gt; if each entry fits its appropriate range, raises if the date is invalid.</source>
          <target state="translated">모든 값이 정수 여야합니다. 각 항목이 해당 범위에 맞으면 &lt;code&gt;date&lt;/code&gt; 반환 하고 날짜가 유효하지 않으면 올립니다.</target>
        </trans-unit>
        <trans-unit id="13b37db6b572edb898a47a3bd0fb0e8a7a11988b" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;naive_datetime&lt;/code&gt; if each entry fits its appropriate range, raises if time or date is invalid.</source>
          <target state="translated">모든 값이 정수 여야합니다. &lt;code&gt;naive_datetime&lt;/code&gt; 을 반환 합니다.각 항목이 적절한 범위에 맞으면 하고 시간 또는 날짜가 유효하지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bcd459526f4b99811c8fbb63304ea87ace873e34" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;time&lt;/code&gt; if each entry fits its appropriate range, raises if the time is invalid.</source>
          <target state="translated">모든 값이 정수 여야합니다. 각 항목이 적절한 범위에 맞으면 &lt;code&gt;time&lt;/code&gt; 반환 하고 시간이 유효하지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91a8dae3c7e0a7461d109ccac314fd3b05583329" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">모든 값이 정수가 될 것으로 예상합니다. 반환 &lt;code&gt;{:ok, date}&lt;/code&gt; 각 항목이 적절한 범위, 반환 맞는 경우 &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="36147c4004a324e8f3e4b2ea0f84715a379f133f" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">모든 값이 정수가 될 것으로 예상합니다. 반환 &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; 각 항목이 적절한 범위, 반환 맞는 경우 &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="b1f148de03b18e5985298d31921d5f1111620987" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">모든 값이 정수가 될 것으로 예상합니다. 반환 &lt;code&gt;{:ok, time}&lt;/code&gt; 각 항목이 적절한 범위, 반환 맞는 경우 &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="1387b27163a391ef8f7a170807b6e12dfd7c742a" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 과 동일한 명령 줄 옵션이 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="6d58782f27892aec9906a2b37b517051b421e83e" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 과 동일한 명령 행 옵션이 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="8185e179a98e4c14d7d2dc6601e54859946ed332" translate="yes" xml:space="preserve">
          <source>Explicit derivations can now be called via &lt;code&gt;__deriving__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__deriving__&lt;/code&gt; 을 통해 명시 적 파생을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1af430d5daa7566a82be8754e90eab91a53418f6" translate="yes" xml:space="preserve">
          <source>Explicitly convert to string with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; (v1.0)을 사용 하여 명시 적으로 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="a311e0f546569e17c6cb9a033783cc3c973c3f50" translate="yes" xml:space="preserve">
          <source>Exploring</source>
          <target state="translated">Exploring</target>
        </trans-unit>
        <trans-unit id="17144cbaf80b5556f57bcc08120468f882fb7da0" translate="yes" xml:space="preserve">
          <source>Exports dependencies are compile time dependencies on the module API, namely structs and its public definitions. For example, if you import a module but only use its functions, it is an export dependency. If you use a struct, it is an export dependency too. Export dependencies are only recompiled if the module API changes. Note, however, that compile time dependencies have higher precedence than exports. Therefore if you import a module and use its macros, it is a compile time dependency.</source>
          <target state="translated">내보내기 종속성은 모듈 API, 즉 구조체 및 공개 정의에 대한 컴파일 시간 종속성입니다. 예를 들어 모듈을 가져 오지만 해당 기능 만 사용하는 경우 내보내기 종속성입니다. 구조체를 사용하는 경우 내보내기 종속성이기도합니다. 내보내기 종속성은 모듈 API가 변경된 경우에만 다시 컴파일됩니다. 그러나 컴파일 시간 종속성은 내보내기보다 우선 순위가 높습니다. 따라서 모듈을 가져 와서 해당 매크로를 사용하는 경우 컴파일 시간에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd636ca0127e991954457d5520bc826a5790bde1" translate="yes" xml:space="preserve">
          <source>Expressions in IEx</source>
          <target state="translated">IEx의 표현</target>
        </trans-unit>
        <trans-unit id="ee1891c8d113531de2d0f468e0034dd1a97f49a7" translate="yes" xml:space="preserve">
          <source>Expressions on multiple lines are also supported:</source>
          <target state="translated">여러 줄의 표현식도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="96e930ee8659a5428bf86a0d55155d9541ab8120" translate="yes" xml:space="preserve">
          <source>Extension point for precompiling dependencies.</source>
          <target state="translated">종속성을 사전 컴파일하기위한 확장 점입니다.</target>
        </trans-unit>
        <trans-unit id="8fdb5d77c0ea69e962db331c0331d4ccd1f6e481" translate="yes" xml:space="preserve">
          <source>External dependencies</source>
          <target state="translated">외부 의존성</target>
        </trans-unit>
        <trans-unit id="ecfbef1298f91628d1f080163cdf6946c9def817" translate="yes" xml:space="preserve">
          <source>External dependencies are the ones not tied to your business domain. For example, if you need an HTTP API for your distributed KV application, you can use the &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; project as an external dependency.</source>
          <target state="translated">외부 종속성은 비즈니스 도메인과 무관합니다. 예를 들어, 분산 KV 애플리케이션에 HTTP API가 필요한 경우 &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; 프로젝트를 외부 종속성으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c150e0ee17017b4793bcf0b0cc69d4046c404195" translate="yes" xml:space="preserve">
          <source>Extract test cases from the documentation.</source>
          <target state="translated">문서에서 테스트 케이스를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="95e8ae6e88b22e27a03f7d64d058e8d835494561" translate="yes" xml:space="preserve">
          <source>Extracts all protocols from the given paths.</source>
          <target state="translated">주어진 경로에서 모든 프로토콜을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="6672f515f4795b7a00946cd73a72fe3b0d731698" translate="yes" xml:space="preserve">
          <source>Extracts all records information from an Erlang file.</source>
          <target state="translated">Erlang 파일에서 모든 레코드 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0aa4ae6318b818f36730be7bf017b931ef4ea73b" translate="yes" xml:space="preserve">
          <source>Extracts all types implemented for the given protocol from the given paths.</source>
          <target state="translated">주어진 경로에서 주어진 프로토콜에 대해 구현 된 모든 유형을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="fe0c75ba33dd78a4066417d5f149fc1b26fb8202" translate="yes" xml:space="preserve">
          <source>Extracts record information from an Erlang file.</source>
          <target state="translated">Erlang 파일에서 레코드 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="574d59827e0eb28bc33410c7d28d8d1801cae6ee" translate="yes" xml:space="preserve">
          <source>Extracts the part of the binary starting at &lt;code&gt;start&lt;/code&gt; with length &lt;code&gt;length&lt;/code&gt;. Binaries are zero-indexed.</source>
          <target state="translated">에서 바이너리 시작 부분 추출 &lt;code&gt;start&lt;/code&gt; 길이와 &lt;code&gt;length&lt;/code&gt; . 이진은 인덱스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="09fef5d8d9a3c86b2523fef60d512606e7fe0003" translate="yes" xml:space="preserve">
          <source>Failed</source>
          <target state="translated">Failed</target>
        </trans-unit>
        <trans-unit id="96fff357d65451f89027b22467cd65b418ae720a" translate="yes" xml:space="preserve">
          <source>Failing guards</source>
          <target state="translated">실패 경비</target>
        </trans-unit>
        <trans-unit id="1652d7e1326512444d5398f784563f91db27adf9" translate="yes" xml:space="preserve">
          <source>Failing to specify the size for the non-last causes compilation to fail:</source>
          <target state="translated">마지막이 아닌 크기를 지정하지 않으면 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a8f785f9330c1e75e28a2a7140d3aec99d182b95" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="translated">이름이 PID 또는 포트에 등록되어 있지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="0ccdf9c4d16331f9f9a7885177207e85c8dc38a3" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="translated">이름이 PID 또는 포트에 등록되지 않은 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="a6d0b09e283994372eb19fd9e9acdd66b7d8a5ff" translate="yes" xml:space="preserve">
          <source>Fails with a message.</source>
          <target state="translated">메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d98c0b711b96d90c648aa1ba79214b16cf3c847f" translate="yes" xml:space="preserve">
          <source>Faint (decreased intensity). Not widely supported.</source>
          <target state="translated">희미 함 (강도 감소). 널리 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80eafe8c844b802892eae9dec9a932d3aae704a2" translate="yes" xml:space="preserve">
          <source>Fallback to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">에 폴백 &lt;code&gt;Any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e83224357f427a57043b90f12511c5e7c2761fe6" translate="yes" xml:space="preserve">
          <source>Falsy values (of which there are exactly two):</source>
          <target state="translated">거짓 값 (정확히 두 개가 있음) :</target>
        </trans-unit>
        <trans-unit id="84961cf65129825950c4fb505dbebfa0af3c33d5" translate="yes" xml:space="preserve">
          <source>Feel free to go ahead and do the changes above and write some unit tests. The idea is that your tests will start an instance of the &lt;code&gt;KV.Registry&lt;/code&gt; and pass it as an argument to &lt;code&gt;run/2&lt;/code&gt; instead of relying on the global &lt;code&gt;KV.Registry&lt;/code&gt;. This has the advantage of keeping our tests asynchronous as there is no shared state.</source>
          <target state="translated">계속해서 위의 변경 사항을 수행하고 단위 테스트를 작성하십시오. 아이디어는 테스트가 &lt;code&gt;KV.Registry&lt;/code&gt; 의 인스턴스를 시작 하여 글로벌 &lt;code&gt;KV.Registry&lt;/code&gt; 에 의존하는 대신 &lt;code&gt;run/2&lt;/code&gt; 의 인수로 전달한다는 것입니다 . 공유 상태가 없기 때문에 테스트를 비동기 적으로 유지할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9eab4f18f16e5a9faaa07931254d91146148ac" translate="yes" xml:space="preserve">
          <source>Fetches a copy of &lt;code&gt;rebar&lt;/code&gt; or &lt;code&gt;rebar3&lt;/code&gt; from the given path or URL.</source>
          <target state="translated">주어진 경로 또는 URL에서 &lt;code&gt;rebar&lt;/code&gt; 또는 &lt;code&gt;rebar3&lt;/code&gt; 의 사본을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="6ce2d20bef71f0063b999c8745340e3f56b5a4aa" translate="yes" xml:space="preserve">
          <source>Fetches the test supervisor for the current test.</source>
          <target state="translated">현재 테스트에 대한 테스트 감독자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c0e97bf839fe5fe85207b4a9d492c885c7fec652" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; and returns it in a tuple.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 의 값을 가져 와서 튜플로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e51d5ee9800fb6a00e8f93feaec0009d2b77b447" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;, erroring out if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;map&lt;/code&gt; 에서 특정 &lt;code&gt;key&lt;/code&gt; 의 값을 가져 오고 &lt;code&gt;map&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 가 없으면 오류가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="a43e0afb7d744e48d3c341e4b08f1f780c55b575" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;map&lt;/code&gt; 에서 특정 &lt;code&gt;key&lt;/code&gt; 의 값을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e32be0757ce9c975d2425bacc76ae29c90d94cf3" translate="yes" xml:space="preserve">
          <source>Fetches the value for specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="f5f8f513b41db299570bc23df8a5cd56d7a7348b" translate="yes" xml:space="preserve">
          <source>Fetches the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">컨테이너 (지도, 키워드 목록 또는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 구조체)에서 지정된 키의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="31798ce3f2f936a238f0a2c5ab7cdb503c7ea839" translate="yes" xml:space="preserve">
          <source>File permissions are specified by adding together the following octal modes:</source>
          <target state="translated">파일 사용 권한은 다음 8 진 모드를 함께 추가하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e9762f0351951cf7ed47c0893d9de2c36796a05d" translate="yes" xml:space="preserve">
          <source>File.CopyError</source>
          <target state="translated">File.CopyError</target>
        </trans-unit>
        <trans-unit id="7b57f930765dd268a9cde88eaefc8e395b0beb29" translate="yes" xml:space="preserve">
          <source>File.CopyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.CopyError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="27e1fc83e1258e80dfd4127d0a4ce93324162992" translate="yes" xml:space="preserve">
          <source>File.Error</source>
          <target state="translated">File.Error</target>
        </trans-unit>
        <trans-unit id="8354290eb6b6ea2cbcbaa3bd4c48c21f5649591a" translate="yes" xml:space="preserve">
          <source>File.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.Error &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5561cc6859be7830bb0219495771f2109757df2e" translate="yes" xml:space="preserve">
          <source>File.LinkError</source>
          <target state="translated">File.LinkError</target>
        </trans-unit>
        <trans-unit id="ff963e9e333fceee8593af446c12736218860d8a" translate="yes" xml:space="preserve">
          <source>File.LinkError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.LinkError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="34595af71c483f8de72a2abf0c30fcef3475a04a" translate="yes" xml:space="preserve">
          <source>File.RenameError</source>
          <target state="translated">File.RenameError</target>
        </trans-unit>
        <trans-unit id="918afebd70d1938336f0bcc22b61603501a5ef93" translate="yes" xml:space="preserve">
          <source>File.RenameError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">File.RenameError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="26a6590f983813e802ea4c694400ea32fe379883" translate="yes" xml:space="preserve">
          <source>File.Stat</source>
          <target state="translated">File.Stat</target>
        </trans-unit>
        <trans-unit id="665c1dadb9609c9481c5f8ebc57dca4f06031e23" translate="yes" xml:space="preserve">
          <source>File.Stream</source>
          <target state="translated">File.Stream</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="e4b01a2510691aed09a9f3e1dbbc4fcd455e3aee" translate="yes" xml:space="preserve">
          <source>Filters can also be given:</source>
          <target state="translated">필터도 제공 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2503811e18a88c94424e3c46d73925ff58ba8899" translate="yes" xml:space="preserve">
          <source>Filters can either be a regular expression or any data structure that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol, which is invoked before comparing the filter with the &lt;code&gt;:tag&lt;/code&gt; value.</source>
          <target state="translated">필터는 정규식 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 데이터 구조 일 수 있으며, 필터를 &lt;code&gt;:tag&lt;/code&gt; 값 과 비교하기 전에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e53af0e96b0cc30e1acdc06f0e1e173375388aa" translate="yes" xml:space="preserve">
          <source>Filters the &lt;code&gt;enumerable&lt;/code&gt;, i.e. returns only those elements for which &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">필터 &lt;code&gt;enumerable&lt;/code&gt; , 즉 반환을 요소 만있는 &lt;code&gt;fun&lt;/code&gt; 리턴한다 truthy 값을.</target>
        </trans-unit>
        <trans-unit id="38e91ba97986e6ce700c58bdd7ad300d67734ab8" translate="yes" xml:space="preserve">
          <source>Final note</source>
          <target state="translated">최종 메모</target>
        </trans-unit>
        <trans-unit id="35edd1c925c63232dc7f42b120954fad87230406" translate="yes" xml:space="preserve">
          <source>Finally note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it may be removed after consolidation.</source>
          <target state="translated">마지막으로 &lt;code&gt;elixirc&lt;/code&gt; 컴파일러가 설정 한 옵션에 관계없이 모든 프로토콜은 &lt;code&gt;debug_info&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 상태로 컴파일됩니다 . 디버그 정보는 통합에 사용되며 통합 후에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04fdf1c25fdd5f8a57c6967c66cfb3a7de5f847e" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;setup_all&lt;/code&gt; callbacks run in a separate process per module, while all &lt;code&gt;setup&lt;/code&gt; callbacks run in the same process as the test itself. &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt; callbacks always run in a separate process, as implied by their name. The test process always exits with reason &lt;code&gt;:shutdown&lt;/code&gt;, which means any process linked to the test process will also exit, although asynchronously. Therefore it is preferred to use &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; to guarantee synchronous termination.</source>
          <target state="translated">마지막으로 &lt;code&gt;setup_all&lt;/code&gt; 콜백은 모듈마다 별도의 프로세스에서 실행되는 반면 모든 &lt;code&gt;setup&lt;/code&gt; 콜백은 테스트 자체와 동일한 프로세스에서 실행됩니다. &lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt; 콜백은 항상 이름에서 알 수 있듯이 별도의 프로세스에서 실행됩니다. 테스트 프로세스는 항상 reason &lt;code&gt;:shutdown&lt;/code&gt; 과 함께 종료됩니다 . 즉, 비동기 적으로도 테스트 프로세스에 연결된 프로세스도 종료됩니다. 따라서 동기식 종료를 보장 하기 위해 &lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4a48b23e11b49db2f57e13074e7a2452579f61b9" translate="yes" xml:space="preserve">
          <source>Finally, Elixir has a construct called aliases which we will explore later. Aliases start in upper case and are also atoms:</source>
          <target state="translated">마지막으로, Elixir에는 나중에 살펴볼 별칭이라는 구성이 있습니다. 별명은 대문자로 시작하며 원자이기도합니다.</target>
        </trans-unit>
        <trans-unit id="f1f7036035e55443b9fb00eab5b0f156761b7796" translate="yes" xml:space="preserve">
          <source>Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix help archive.build&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix help escript.build&lt;/code&gt;&lt;/a&gt; for more detail.</source>
          <target state="translated">마지막으로, Elixir는 escript 및 아카이브와 같은 도구를 제공합니다.이 도구는 응용 프로그램을 패키징하기위한 다른 메커니즘입니다. 일반적으로 배포 옵션이 아닌 개발자간에 도구를 공유해야 할 때 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix help archive.build&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix help escript.build&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51f5f67bdc287fa28acb4c9223c262389c58e3ea" translate="yes" xml:space="preserve">
          <source>Finally, aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;mix.tasks.clean&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="translated">마지막으로 별칭을 사용하여 기존 작업을 보강 할 수도 있습니다. 다른 디렉토리를 정리 하기 위해 &lt;a href=&quot;mix.tasks.clean&quot;&gt; &lt;code&gt;mix clean&lt;/code&gt; &lt;/a&gt; 를 강화하고 싶다고 가정합시다 .</target>
        </trans-unit>
        <trans-unit id="191e1198a5b11d86c8e069a1379cf393ac7fbbc2" translate="yes" xml:space="preserve">
          <source>Finally, anonymous functions are also closures and as such they can access variables that are in scope when the function is defined. Let&amp;rsquo;s define a new anonymous function that uses the &lt;code&gt;add&lt;/code&gt; anonymous function we have previously defined:</source>
          <target state="translated">마지막으로 익명 함수도 클로저이므로 함수가 정의 될 때 범위 내에있는 변수에 액세스 할 수 있습니다. 이전에 정의한 익명 &lt;code&gt;add&lt;/code&gt; 기능을 사용하는 새로운 익명 함수를 정의 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1877a861abfea57d3175dd4ec2545e64bd06b283" translate="yes" xml:space="preserve">
          <source>Finally, as discussed in the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; documentation, remember that the initial context metadata can also be set via &lt;code&gt;@tag&lt;/code&gt;s, which can then be accessed in the &lt;code&gt;setup&lt;/code&gt; block:</source>
          <target state="translated">에서 논의 된 바와 같이 마지막 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; 된&lt;/a&gt; 문서의 초기 콘텍스트 메타 또한 통해 설정 될 수 있음을 유의 &lt;code&gt;@tag&lt;/code&gt; S, 다음에 액세스 될 수있는 &lt;code&gt;setup&lt;/code&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="4f8f9ee80a4128eebbd8b8d0785f0bf4b51354e3" translate="yes" xml:space="preserve">
          <source>Finally, attributes can also be read inside functions:</source>
          <target state="translated">마지막으로, 함수 내에서 속성을 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="668fb656f73feadaab2b70bd66310c5a6a4ae07c" translate="yes" xml:space="preserve">
          <source>Finally, beware of redundant code comments, such as the ones describing the exact same that the code does:</source>
          <target state="translated">마지막으로 코드와 동일한 내용을 설명하는 주석과 같은 중복 코드 주석에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="7b06c2901c51b502cac134085935b1c4ea9f9da4" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 에서 지원되는 다른 작업을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1083a91a64ef83410037ffb35fd49e9fb40c270f" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 에서 다른 지원되는 작업을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f726a5d73225d60359e8c4f7a62c08247c5e3152" translate="yes" xml:space="preserve">
          <source>Finally, copy the &lt;code&gt;kv&lt;/code&gt; application we have built so far to the &lt;code&gt;apps&lt;/code&gt; directory in our new umbrella project. The final directory structure should match the structure we mentioned earlier:</source>
          <target state="translated">마지막으로 지금까지 빌드 한 &lt;code&gt;kv&lt;/code&gt; 애플리케이션을 새 우산 프로젝트 의 &lt;code&gt;apps&lt;/code&gt; 디렉토리에 복사하십시오 . 최종 디렉토리 구조는 앞에서 언급 한 구조와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="fab90ae3564b828d174f4a1339c23b2f23ef10c1" translate="yes" xml:space="preserve">
          <source>Finally, developers should also avoid defining functions inside the &lt;code&gt;__using__/1&lt;/code&gt; callback, unless those functions are the default implementation of a previously defined &lt;code&gt;@callback&lt;/code&gt; or are functions meant to be overridden (see &lt;a href=&quot;#defoverridable/1&quot;&gt;&lt;code&gt;defoverridable/1&lt;/code&gt;&lt;/a&gt;). Even in these cases, defining functions should be seen as a &quot;last resort&quot;.</source>
          <target state="translated">마지막으로 개발자는 &lt;code&gt;__using__/1&lt;/code&gt; 콜백 내에서 함수를 정의 하지 않아야합니다. 이러한 함수는 이전에 정의 된 &lt;code&gt;@callback&lt;/code&gt; 의 기본 구현 이거나 재정의하려는 함수가 &lt;a href=&quot;#defoverridable/1&quot;&gt; &lt;code&gt;defoverridable/1&lt;/code&gt; &lt;/a&gt; ( defoverridable / 1 참조 ). 이러한 경우에도 기능 정의는 &quot;마지막 수단&quot;으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a5904f73dbbcd0930c32f8ef2421f6ebf86cef4" translate="yes" xml:space="preserve">
          <source>Finally, different from the other callbacks, we have defined a &amp;ldquo;catch-all&amp;rdquo; clause for &lt;code&gt;handle_info/2&lt;/code&gt; that discards any unknown message. To understand why, let&amp;rsquo;s move on to the next section.</source>
          <target state="translated">마지막으로 다른 콜백과 달리 알 수없는 메시지를 버리는 &lt;code&gt;handle_info/2&lt;/code&gt; 에 대한 &quot;catch-all&quot;절을 정의했습니다 . 이유를 이해하려면 다음 섹션으로 넘어가겠습니다.</target>
        </trans-unit>
        <trans-unit id="2dca70c0e3d6a9acaabab7bc96177fe2d9c44844" translate="yes" xml:space="preserve">
          <source>Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">마지막으로, 유니 코드 모드의 IO 디바이스에서는이 기능을 사용하지 마십시오. 잘못된 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1ed29b60633fb5430adba7b8757ea6539225e2" translate="yes" xml:space="preserve">
          <source>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</source>
          <target state="translated">마지막으로 빈 열거 형에 대해 발생하지 않으려면 빈 폴백을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e8ca83f100555992c56e00e0551b89ee834e2cb" translate="yes" xml:space="preserve">
          <source>Finally, in order for runtime configuration to work properly (as well as any other &quot;Config provider&quot; as defined next), it needs to be able to persist the newly computed configuration to disk. The computed config file will be written to &quot;tmp&quot; directory inside the release every time the system boots. You can configure the &quot;tmp&quot; directory by setting the &lt;code&gt;RELEASE_TMP&lt;/code&gt; environment variable, either explicitly or inside your &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (or &lt;code&gt;env.bat&lt;/code&gt; on Windows).</source>
          <target state="translated">마지막으로 런타임 구성이 제대로 작동하려면 (다음에 정의 된 다른 &quot;구성 공급자&quot;도 마찬가지 임) 새로 계산 된 구성을 디스크에 유지할 수 있어야합니다. 계산 된 구성 파일은 시스템이 부팅 될 때마다 릴리스 내의 &quot;tmp&quot;디렉토리에 기록됩니다. &lt;code&gt;RELEASE_TMP&lt;/code&gt; 환경 변수를 명시 적으로 또는 &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; (또는 Windows의 &lt;code&gt;env.bat&lt;/code&gt; )내 에서 설정하여 &quot;tmp&quot;디렉토리를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a0fcc78d43cdb2d5efe08a2aa140520d91d3bf" translate="yes" xml:space="preserve">
          <source>Finally, it also documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="translated">마지막으로, &lt;a href=&quot;#__block__/1&quot;&gt; &lt;code&gt;__block__/1&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt; 두 가지 특수 형식을 설명합니다.이 양식 은 개발자가 직접 호출하지 않지만 Elixir의 구성에 필수적이므로 인용 된 내용으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f74f8991d0d3c9a479fe59d35b99b4abf4e6cf52" translate="yes" xml:space="preserve">
          <source>Finally, it's advised to profile your program with the &lt;code&gt;prod&lt;/code&gt; environment, since this should provide more realistic insights into bottlenecks.</source>
          <target state="translated">마지막으로, 당신의 프로그램을 프로파일 링하는 것이 좋습니다 것 &lt;code&gt;prod&lt;/code&gt; 이 병목 현상에보다 현실적인 통찰력을 제공해야하기 때문에, 환경.</target>
        </trans-unit>
        <trans-unit id="e7d511ddfbac4fd8a034329e957061520ac4e991" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind it is not required for you to assemble the release from the umbrella root. You can also assemble the release from each child application individually. Doing it from the root, however, allows you to include two applications that do not depend on each other as part of the same release.</source>
          <target state="translated">마지막으로 우산 뿌리에서 릴리스를 조립할 필요가 없습니다. 또한 각 하위 애플리케이션의 릴리스를 개별적으로 어셈블 할 수도 있습니다. 그러나 루트에서 수행하면 동일한 릴리스의 일부로 서로 의존하지 않는 두 개의 응용 프로그램을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04258f441df3a0685acf7dc84f54350179d26c35" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that applications in an umbrella project all share the same configurations and dependencies. If two applications in your umbrella need to configure the same dependency in drastically different ways or even use different versions, you have probably outgrown the benefits brought by umbrellas. Remember you can break the umbrella and still leverage the benefits behind &amp;ldquo;mono-repos&amp;rdquo;.</source>
          <target state="translated">마지막으로, 우산 프로젝트의 응용 프로그램은 모두 동일한 구성 및 종속성을 공유합니다. 우산에있는 두 응용 프로그램이 서로 다른 방식으로 동일한 종속성을 구성하거나 다른 버전을 사용해야하는 경우에는 우산으로 인한 이점을 능가했을 것입니다. 우산을 깰 수는 있지만 &quot;단일 저장소&quot;의 이점을 여전히 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17d2e9b41800db01905629d7c64202ebf54e9fc" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="translated">마지막으로 생성기, 필터 또는 블록 내부에있는 이해 내부의 변수 할당은 이해 외부에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b0dc026cfea9e2e7b1becee88cabf1eed936967" translate="yes" xml:space="preserve">
          <source>Finally, note &lt;code&gt;cond&lt;/code&gt; considers any value besides &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to be true:</source>
          <target state="translated">마지막으로, &lt;code&gt;cond&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 이외의 값은 true 로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1e8a25344ef8715d7cecfc3690b780ce1c60f07c" translate="yes" xml:space="preserve">
          <source>Finally, note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by the &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it is removed after consolidation unless globally set.</source>
          <target state="translated">마지막으로 모든 프로토콜은 &lt;code&gt;elixirc&lt;/code&gt; 컴파일러가 설정 한 옵션에 관계없이 &lt;code&gt;debug_info&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 컴파일됩니다 . 디버그 정보는 통합에 사용되며 전역 적으로 설정되지 않는 한 통합 후 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7a86bfddfc1fd1f3cd3bcab92a5988d59aa4d019" translate="yes" xml:space="preserve">
          <source>Finally, note it is also possible to simply pass the &lt;code&gt;Stack&lt;/code&gt; module as a child:</source>
          <target state="translated">마지막으로 &lt;code&gt;Stack&lt;/code&gt; 모듈을 자식으로 간단히 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5e8ec2ca3602b6bc2810511f915ff11214b601b" translate="yes" xml:space="preserve">
          <source>Finally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator.</source>
          <target state="translated">마지막으로 패턴의 노트 맵 키는 항상 리터럴이거나 pin 연산자와 일치하는 이전에 바인딩 된 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ddefd09be238de8fef0e43712279c903c785e333" translate="yes" xml:space="preserve">
          <source>Finally, note strings themselves are valid algebra documents that keep their formatting when pretty printed. This means your &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; implementation may simply return a string, although that will devoid it of any pretty-printing.</source>
          <target state="translated">마지막으로, 메모 문자열 자체는 예쁘게 인쇄 될 때 형식을 유지하는 유효한 대수 문서입니다. 이것은 당신의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 구현이 단순히 문자열을 반환 할 수 있다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7e168ab8bcfeb48be21d768c678e77ae94e3845d" translate="yes" xml:space="preserve">
          <source>Finally, note that attributes can also be read inside functions:</source>
          <target state="translated">마지막으로, 속성은 함수 내에서도 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525d826b02e67b29a0d7a1fb2bd96144f8ca9ed8" translate="yes" xml:space="preserve">
          <source>Finally, note the coverage itself is not measured across the projects themselves. For example, if project B depends on A, and if there is code in A that is only executed from project B, those lines will not be marked as covered, which is important, as those projects should be developed and tested in isolation.</source>
          <target state="translated">마지막으로 커버리지 자체는 프로젝트 자체에서 측정되지 않습니다. 예를 들어 프로젝트 B가 A에 의존하고 A에 프로젝트 B에서만 실행되는 코드가있는 경우 해당 행은 포함 된 것으로 표시되지 않습니다. 이는 해당 프로젝트를 별도로 개발하고 테스트해야하므로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d4f7dd24a40c84b2db68e974eaff07a24dba709d" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="translated">마지막으로, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 함수 는 열망합니다. 호출되는 즉시 열거 형을 순회합니다. 무한 열거 형으로 작업 할 때 특히 위험합니다. 이러한 경우에는 컬렉션을 순회하지 않고 계산을 느리게 표현하고 무한한 컬렉션으로 작업 할 수 있는 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야합니다 . 예제 및 문서 는 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60bc3c90be2296af6dc74f8ac6ed31dee639afd7" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 함수 는 열망합니다. 즉 , 열거 된 함수 는 호출하자마자 통과합니다. 무한 열거 형으로 작업 할 때 특히 위험합니다. 이 경우 컬렉션을 순회하지 않고 계산을 느리게 표현하고 무한한 컬렉션으로 작업 할 수 있는 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야합니다 . 예제 및 설명서 는 &lt;a href=&quot;stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12f0160206d216529166c8634dc691e626760b5b" translate="yes" xml:space="preserve">
          <source>Finally, notice that attributes can also be read inside functions:</source>
          <target state="translated">마지막으로, 함수 내에서도 속성을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="989e69e0609a31b9b4fe9f32b562a703b9696c7b" translate="yes" xml:space="preserve">
          <source>Finally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">마지막으로 Elixir의 문자열은 UTF-8로 인코딩 된 바이너리라는 점을 기억하세요. 즉, 문자 목록과 유사하게 이진 연결 연산자 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;/a&gt; )를 사용하여 문자열에 대한 접두사 일치도 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="232829bb783ca862d2a7fbdd06c1982a8e6d4a55" translate="yes" xml:space="preserve">
          <source>Finally, remember you can also get a mini-overview of the runtime info by calling &lt;code&gt;runtime_info/0&lt;/code&gt; directly in IEx.</source>
          <target state="translated">마지막으로, IEx에서 &lt;code&gt;runtime_info/0&lt;/code&gt; 을 직접 호출하여 런타임 정보의 미니 개요를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4e093b24b7868fdbb88889dcf9d11e7ebbe5c8" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; will import other config files, based on the current Mix environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; 은 &lt;code&gt;config/dev.exs&lt;/code&gt; 및 &lt;code&gt;config/test.exs&lt;/code&gt; 와 같은 현재 믹스 환경에 따라 다른 구성 파일을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b6807f6f10cbe61d66aff585c4548460bfb9b94d" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{config_env()}.exs&quot;&lt;/code&gt; will import other config files based on the current configuration environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;import_config &quot;#{config_env()}.exs&quot;&lt;/code&gt; 은 &lt;code&gt;config/dev.exs&lt;/code&gt; 및 &lt;code&gt;config/test.exs&lt;/code&gt; 와 같은 현재 구성 환경을 기반으로 다른 구성 파일을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="321ba25e566c212d784496c47ffc76a0ad896628" translate="yes" xml:space="preserve">
          <source>Finally, the stacktrace relates to the failure itself, giving information about the test and often the place the failure was generated from within the source files.</source>
          <target state="translated">마지막으로 스택 추적은 실패 자체와 관련되어 테스트에 대한 정보와 종종 소스 파일 내에서 실패가 발생한 위치에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="924ac30e08d7b545eac852afc656f22c82661634" translate="yes" xml:space="preserve">
          <source>Finally, these operators appear in the precedence table above but are only meaningful within certain constructs:</source>
          <target state="translated">마지막으로 이러한 연산자는 위의 우선 순위 표에 나타나지만 특정 구조 내에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f56c580dd08d36a6b47e54333acfe9e1d8d30e4" translate="yes" xml:space="preserve">
          <source>Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as &lt;a href=&quot;#to_doc/2&quot;&gt;&lt;code&gt;to_doc/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마지막으로,이 모듈에는 Elixir 관련 기능이 포함되어 있으며, 이는 &lt;a href=&quot;#to_doc/2&quot;&gt; &lt;code&gt;to_doc/2&lt;/code&gt; &lt;/a&gt; 와 같은 Elixir 형식과 관련된 비트 입니다.</target>
        </trans-unit>
        <trans-unit id="9005decc18b830a894ffeaad85db25d6cd8463cf" translate="yes" xml:space="preserve">
          <source>Finally, to convert a String into a list of integer code points, known as &quot;charlists&quot; in Elixir, you can call &lt;code&gt;String.to_charlist&lt;/code&gt;:</source>
          <target state="translated">마지막으로, 문자열을 Elixir에서 &quot;charlists&quot;라고하는 정수 코드 포인트 목록으로 변환하려면 &lt;code&gt;String.to_charlist&lt;/code&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c7d0203ff19b759dff9a8dcf709329c059ef93" translate="yes" xml:space="preserve">
          <source>Finally, you may have observed that each doctest corresponds to a different test in our suite, which now reports a total of 7 doctests. That is because ExUnit considers the following to define two different doctests:</source>
          <target state="translated">마지막으로, 각 doctest는 제품군의 다른 테스트에 해당하며, 총 7 개의 doctest가보고됩니다. ExUnit은 다음 두 가지 doctest를 정의하기 위해 다음을 고려하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="82318fe7e7a021f4fa35e9409276a28582c98da1" translate="yes" xml:space="preserve">
          <source>Find more about the pipe operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;by reading its documentation&lt;/a&gt;.</source>
          <target state="translated">파이프 운영자 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;에&lt;/a&gt; 대한 자세한 내용은 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d473a61a8edc12c54afe46832414dc97879d0388" translate="yes" xml:space="preserve">
          <source>Finds a template path for the release.</source>
          <target state="translated">릴리스의 템플릿 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e44a6c20b46b4eb7ebeba1748cd0e7795b1fd20f" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;{pid, value}&lt;/code&gt; pair for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; in no particular order.</source>
          <target state="translated">&lt;code&gt;registry&lt;/code&gt; 에서 주어진 &lt;code&gt;key&lt;/code&gt; 에 대한 &lt;code&gt;{pid, value}&lt;/code&gt; 쌍을 특별한 순서없이 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d980122971e9d4fe80a33e7b799338a83929abd3" translate="yes" xml:space="preserve">
          <source>Finds the element at the given &lt;code&gt;index&lt;/code&gt; (zero-based).</source>
          <target state="translated">주어진 &lt;code&gt;index&lt;/code&gt; 에서 요소를 찾습니다 (0부터 시작).</target>
        </trans-unit>
        <trans-unit id="fdbbbf2a367be4fcd9eca718811c5a61aea8c66b" translate="yes" xml:space="preserve">
          <source>First of all, since we generated this project inside &lt;code&gt;kv_umbrella/apps&lt;/code&gt;, Mix automatically detected the umbrella structure and added four lines to the project definition:</source>
          <target state="translated">우선, &lt;code&gt;kv_umbrella/apps&lt;/code&gt; 내에서이 프로젝트를 생성 했으므로 Mix는 자동으로 우산 구조를 감지하고 프로젝트 정의에 4 개의 라인을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="21e0a6d768daca714108b3a36ec6e2151c3c1139" translate="yes" xml:space="preserve">
          <source>First this task guarantees that all dependencies are in place and that the current project has been compiled. Then the current application is started as a temporary application, unless &lt;code&gt;:start_permanent&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; in your project configuration or the &lt;code&gt;--permanent&lt;/code&gt; option is given, then it's started as permanent, which guarantees the node will shut down if the application crashes permanently.</source>
          <target state="translated">먼저이 작업은 모든 종속성이 제자리에 있고 현재 프로젝트가 컴파일되었는지 확인합니다. 그런 다음 프로젝트 구성에서 &lt;code&gt;:start_permanent&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정되거나 &lt;code&gt;--permanent&lt;/code&gt; 옵션이 제공 되지 않는 한 현재 애플리케이션이 임시 애플리케이션으로 시작됩니다 . 그러면 영구적으로 시작되어 애플리케이션이 영구적으로 충돌하는 경우 노드가 종료되도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="0b225f4fd1da05fdbc3ee99a9f166606b1d95c47" translate="yes" xml:space="preserve">
          <source>First, if the routing tables are the opposite of each other, such as &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; in one node and &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; in the other, you can have a routing request that will run recursively in the cluster infinitely. This can be tackled at the application level by making sure you pass a list of seen nodes when we route, such as &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt;. Then by checking if the node being dispatched to was already visited, we can avoid the cycle. Implementing and testing this functionality will be left as an exercise.</source>
          <target state="translated">먼저 라우팅 테이블이 서로 반대 인 경우 (예 : &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; 한 노드에서 &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; , 다른 노드 에서는 클러스터에서 재귀 적으로 실행되는 라우팅 요청 &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt; 와 같이 라우팅 할 때 본 노드 목록을 전달함으로써 응용 프로그램 수준에서이를 해결할 수 있습니다 . 그런 다음 발송중인 노드가 이미 방문했는지 확인하여주기를 피할 수 있습니다. 이 기능을 구현하고 테스트하는 것은 연습으로 남을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe6a7fa579eecc0b0104d2aa94bc63bd9d9aa9d6" translate="yes" xml:space="preserve">
          <source>First, the &lt;code&gt;request&lt;/code&gt; is sent to every node in &lt;code&gt;nodes&lt;/code&gt;; then, the caller waits for the replies. This function returns a two-element tuple &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; where:</source>
          <target state="translated">먼저 &lt;code&gt;request&lt;/code&gt; 이 노드의 모든 노드로 전송 &lt;code&gt;nodes&lt;/code&gt; . 그런 다음 발신자가 회신을 기다립니다. 이 함수는 다음 두 요소로 구성된 튜플 &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="60398b803dd263be0dc63a6c96308aea282994d5" translate="yes" xml:space="preserve">
          <source>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. Optional behaviour, such as &lt;code&gt;:rename_deprecated_at&lt;/code&gt;, is allowed to break this guarantee.</source>
          <target state="translated">첫째, 포맷터는 기본적으로 코드의 의미를 변경하지 않습니다. 이는 입력 AST와 출력 AST가 동일 함을 의미합니다. &lt;code&gt;:rename_deprecated_at&lt;/code&gt; 와 같은 선택적 동작 은이 보증을 위반할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761d6955efc7722bb7c5e17c7ad9ae6eee0e3a82" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists.</source>
          <target state="translated">주어진 중첩 &lt;code&gt;list&lt;/code&gt; 의 목록 을 병합 합니다.</target>
        </trans-unit>
        <trans-unit id="384278e07033851614565e0c9f8e0ea314279560" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists. The list &lt;code&gt;tail&lt;/code&gt; will be added at the end of the flattened list.</source>
          <target state="translated">주어진 중첩 &lt;code&gt;list&lt;/code&gt; 의 목록 을 병합 합니다. 평평한 목록의 끝에 목록 &lt;code&gt;tail&lt;/code&gt; 가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="e0ed30f7614c69e32cbce2c9fd0bd8fcaa7586e6" translate="yes" xml:space="preserve">
          <source>Float numbers require a dot followed by at least one digit and also support &lt;code&gt;e&lt;/code&gt; for scientific notation:</source>
          <target state="translated">부동 소수점은 점 다음에 적어도 하나의 숫자가 필요하며 과학적 표기법을 위해 &lt;code&gt;e&lt;/code&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a4495969af61f575a24ee4711fa76dfaafb26d0e" translate="yes" xml:space="preserve">
          <source>Floats in Elixir are 64-bit double precision.</source>
          <target state="translated">Elixir의 플로트는 64 비트 배정도입니다.</target>
        </trans-unit>
        <trans-unit id="9ee393efb1b19d0c371e21c8a5d6360e13a111b0" translate="yes" xml:space="preserve">
          <source>Flushes all &lt;code&gt;:mix_shell&lt;/code&gt; and &lt;code&gt;:mix_shell_input&lt;/code&gt; messages from the current process.</source>
          <target state="translated">현재 프로세스에서 모든 &lt;code&gt;:mix_shell&lt;/code&gt; 및 &lt;code&gt;:mix_shell_input&lt;/code&gt; 메시지를 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="1f37e32316ff57285093c07bcc6fa68a47a4a700" translate="yes" xml:space="preserve">
          <source>Flushes the logger.</source>
          <target state="translated">로거를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="d44af71a2582a2b67261bbce0307838133bc552a" translate="yes" xml:space="preserve">
          <source>Flushes the output buffer and returns its current contents.</source>
          <target state="translated">출력 버퍼를 플러시하고 현재 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fd9c42d3180adcefdbd370b8adb9856f5a36877" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the left with a function. Requires an accumulator.</source>
          <target state="translated">주어진 목록을 함수로 왼쪽에서 접습니다 (감소시킵니다). 누산기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="569c663a35f673e18e4fd8649f95dd98dfc6e9c3" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the right with a function. Requires an accumulator.</source>
          <target state="translated">함수로 주어진 목록을 오른쪽에서 접습니다 (감소시킵니다). 누산기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2fa0635488dcee65136d608f773cf5f9ef5e7acf" translate="yes" xml:space="preserve">
          <source>Folds a list of documents into a document using the given folder function.</source>
          <target state="translated">주어진 폴더 기능을 사용하여 문서 목록을 문서에 접습니다.</target>
        </trans-unit>
        <trans-unit id="708d44cdbbf26cc5087abdc9244c378da50e27f8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;call/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_call/3&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt;, the process from which we received the request (&lt;code&gt;_from&lt;/code&gt;), and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_call/3&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt;. The first element of the tuple, &lt;code&gt;:reply&lt;/code&gt;, indicates that the server should send a reply back to the client. The second element, &lt;code&gt;reply&lt;/code&gt;, is what will be sent to the client while the third, &lt;code&gt;new_state&lt;/code&gt; is the new server state.</source>
          <target state="translated">들면 &lt;code&gt;call/2&lt;/code&gt; 요청, 우리는 구현 &lt;code&gt;handle_call/3&lt;/code&gt; 수신 콜백 &lt;code&gt;request&lt;/code&gt; 우리는 요구 (수신되는 프로세스 &lt;code&gt;_from&lt;/code&gt; 을 ), 현재 서버의 상태 ( &lt;code&gt;names&lt;/code&gt; ). &lt;code&gt;handle_call/3&lt;/code&gt; 콜백은 형식 튜플 반환 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; . 튜플의 첫 번째 요소 인 &lt;code&gt;:reply&lt;/code&gt; 는 서버가 클라이언트에게 응답을 다시 보내야 함을 나타냅니다. 두 번째 요소 인 &lt;code&gt;reply&lt;/code&gt; 는 클라이언트로 전송되는 것이고, 세 번째 인 &lt;code&gt;new_state&lt;/code&gt; 는 새로운 서버 상태입니다.</target>
        </trans-unit>
        <trans-unit id="85fe9a9b5eab6f7837fd7ce17f20db0e36c96d5e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cast/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_cast/2&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt; and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_cast/2&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:noreply, new_state}&lt;/code&gt;. Note that in a real application we would have probably implemented the callback for &lt;code&gt;:create&lt;/code&gt; with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.</source>
          <target state="translated">들어 &lt;code&gt;cast/2&lt;/code&gt; 요청, 우리는 구현 &lt;code&gt;handle_cast/2&lt;/code&gt; 수신 콜백 &lt;code&gt;request&lt;/code&gt; 및 현재 서버 상태 ( &lt;code&gt;names&lt;/code&gt; ). &lt;code&gt;handle_cast/2&lt;/code&gt; 콜백 형식으로 튜플을 반환 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; . 실제 응용 프로그램에서는 아마도 비동기 캐스트 대신 동기 호출로 &lt;code&gt;:create&lt;/code&gt; 에 대한 콜백을 구현했을 것입니다 . 캐스트 콜백을 구현하는 방법을 설명하기 위해이 방법을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c507ce5e858adfd9920b90e4c749fbfaa148e35" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt; &lt;code&gt;:compile.file/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b0f265cab36385ed743f3055c68d076ae6c612a" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;. The option &lt;code&gt;:debug_info&lt;/code&gt; is always added to the end of it. You can disable that using:</source>
          <target state="translated">전체 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt; &lt;code&gt;:compile.file/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . &lt;code&gt;:debug_info&lt;/code&gt; 옵션 은 항상 끝에 추가됩니다. 다음을 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b1a5cb3bd304af286350dbfa2dd4e5a7bde159" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/leex.html#file-2&quot;&gt;&lt;code&gt;:leex.file/2&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="translated">전체 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/leex.html#file-2&quot;&gt; &lt;code&gt;:leex.file/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 참고 그 &lt;code&gt;:report&lt;/code&gt; , &lt;code&gt;:return_errors&lt;/code&gt; 및 &lt;code&gt;:return_warnings&lt;/code&gt; 의 옵션을 따라서 그 효과가 없습니다 설정,이 컴파일러에 의해 무시된다.</target>
        </trans-unit>
        <trans-unit id="3e1748b035236f7578aca77841e51909dcda09f3" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt;&lt;code&gt;:yecc.file/1&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="translated">전체 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt; &lt;code&gt;:yecc.file/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 참고 그 &lt;code&gt;:report&lt;/code&gt; , &lt;code&gt;:return_errors&lt;/code&gt; 및 &lt;code&gt;:return_warnings&lt;/code&gt; 의 옵션을 따라서 그 효과가 없습니다 설정,이 컴파일러에 의해 무시된다.</target>
        </trans-unit>
        <trans-unit id="cbadcbaa533f681fcd43632a6b2da738e09b45d0" translate="yes" xml:space="preserve">
          <source>For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 옵션에 대한 설명은 &lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5de5c09f365a342ca1f4adef5fcae8f98c944b89" translate="yes" xml:space="preserve">
          <source>For a detailed explanation it's worth reading the analysis in &lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;Erlang/OTP documentation for fprof&lt;/a&gt;.</source>
          <target state="translated">자세한 설명 &lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;은 fprof에 대한 Erlang / OTP 문서&lt;/a&gt; 의 분석을 읽어 볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b520e99e07d5ece73b44be8ccfff4f1b35fe3ab3" translate="yes" xml:space="preserve">
          <source>For a machine with 8 cores, the above will process 16 items instead of 10. The reason is that &lt;a href=&quot;#async_stream/5&quot;&gt;&lt;code&gt;async_stream/5&lt;/code&gt;&lt;/a&gt; always have 8 elements processing at once. So by the time &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; says it got all elements it needed, there are still 6 elements left to be processed.</source>
          <target state="translated">코어가 8 개인 머신의 경우 위의 항목은 10 개가 아닌 16 개 항목을 처리합니다. 그 이유는 &lt;a href=&quot;#async_stream/5&quot;&gt; &lt;code&gt;async_stream/5&lt;/code&gt; 는&lt;/a&gt; 항상 한 번에 8 개의 요소를 처리하기 때문입니다. 따라서 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 이 필요한 모든 요소를 ​​얻었다 고 말할 때까지 처리 할 요소는 6 개가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="455bca35994e1d4d5c63a42b082bcc28685c8fab" translate="yes" xml:space="preserve">
          <source>For a more complete rundown on the VM support for different times, see the &lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;chapter on time and time correction&lt;/a&gt; in the Erlang docs.</source>
          <target state="translated">다른 시간에 대한 VM 지원에 대한 자세한 설명 은 Erlang 문서의 &lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;시간 및 시간 수정 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ad3bd05a62d0ba912c71da5b141b89b54b65bc7" translate="yes" xml:space="preserve">
          <source>For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section.</source>
          <target state="translated">종료 이유 및 그 영향에 대한 자세한 내용은 &quot;종료 이유 및 재시작&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28d7d5e1dc06aba969a0b236e650a8f1ae4054d6" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">더 자세한 설명은 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 의 &quot;Shutdown values ​​(: shutdown)&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="282328027889720b4154eca4c4806b544bc3a754" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">보다 자세한 설명은 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 의 &quot;종료 값 (: 종료)&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37b344bcdc0c7b8779f65785a14e8c7aa3e5ded0" translate="yes" xml:space="preserve">
          <source>For accessing atom keys, one may also &lt;code&gt;map.key&lt;/code&gt;. Note that while &lt;code&gt;map[key]&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;map.key&lt;/code&gt; will raise if &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;.</source>
          <target state="translated">원자 키에 액세스하기 위해 &lt;code&gt;map.key&lt;/code&gt; 도 있습니다 . 반면 있습니다 &lt;code&gt;map[key]&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;code&gt;map&lt;/code&gt; 포함되지 않은 &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;map.key&lt;/code&gt; 이 경우에 올릴 &lt;code&gt;map&lt;/code&gt; 키가 포함되어 있지 않습니다 &lt;code&gt;:key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57b9d70004f10cc3b53d8d1fb3e515752a611d21" translate="yes" xml:space="preserve">
          <source>For all other time zones, it returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt;.</source>
          <target state="translated">다른 모든 시간대의 경우 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f912dfac4d0836d413b5ac057a2a5efa533103ff" translate="yes" xml:space="preserve">
          <source>For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration.</source>
          <target state="translated">나머지 모든 시나리오에서 라이브러리는 사용자가 응용 프로그램 환경을 구성에 사용하도록 강요해서는 안됩니다. 라이브러리 사용자가 특정 매개 변수를 전체적으로 구성해야한다고 생각하면 라이브러리 기능을 자체 애플리케이션 환경 구성으로 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0878fd6cedf49cadfbc1ce37dc2efcc64e9280" translate="yes" xml:space="preserve">
          <source>For anonymous functions, there is also information about any of the atoms &lt;code&gt;:index&lt;/code&gt;, &lt;code&gt;:new_index&lt;/code&gt;, &lt;code&gt;:new_uniq&lt;/code&gt;, &lt;code&gt;:uniq&lt;/code&gt;, and &lt;code&gt;:pid&lt;/code&gt;. For a named function, the value of any of these items is always the atom &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">익명 함수의 경우 atom &lt;code&gt;:index&lt;/code&gt; , &lt;code&gt;:new_index&lt;/code&gt; , &lt;code&gt;:new_uniq&lt;/code&gt; , &lt;code&gt;:uniq&lt;/code&gt; 및 &lt;code&gt;:pid&lt;/code&gt; 에 대한 정보도 있습니다. 명명 된 함수의 경우 이러한 항목의 값은 항상 atom &lt;code&gt;:undefined&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b4ad9d30cceadfeb05cba1ddc74ec23c371587e" translate="yes" xml:space="preserve">
          <source>For any function, the information asked for can be any of the atoms &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:name&lt;/code&gt;, &lt;code&gt;:arity&lt;/code&gt;, &lt;code&gt;:env&lt;/code&gt;, or &lt;code&gt;:type&lt;/code&gt;.</source>
          <target state="translated">모든 기능에 대해 요청 된 정보는 atoms &lt;code&gt;:module&lt;/code&gt; , &lt;code&gt;:name&lt;/code&gt; , &lt;code&gt;:arity&lt;/code&gt; , &lt;code&gt;:env&lt;/code&gt; 또는 &lt;code&gt;:type&lt;/code&gt; 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19051a75616b4ec98796f8226da734aa9dd4e72d" translate="yes" xml:space="preserve">
          <source>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</source>
          <target state="translated">이진의 경우 기본값은 이진의 크기입니다. 일치하는 마지막 바이너리 만 기본 크기를 사용할 수 있습니다. 일치하는 내용이 모호하지 않더라도 다른 모든 크기는 명시 적으로 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b53d094e78539531bab25286f248fcbe76cc3712" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="translated">위와 같은 경우에는 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="bee446e092800012625413c21226bed4c6f88b01" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="translated">위와 같은 경우 &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcf46e59d6f52359a868d6e88a0b7c5725001a1" translate="yes" xml:space="preserve">
          <source>For companies and teams, we recommend developers to run &lt;code&gt;mix format --check-formatted&lt;/code&gt; on their continuous integration servers, ensuring all current and future code follows the standard.</source>
          <target state="translated">회사와 팀의 경우 개발자 는 지속적인 통합 서버에서 &lt;code&gt;mix format --check-formatted&lt;/code&gt; 을 실행 하여 현재 및 미래의 모든 코드가 표준을 준수하도록하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="57326dd8df98d78d81aebf773cf3bf48a345cefe" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여러 파일을 동시에 컴파일하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.ParallelCompiler.html#compile/2&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b735130a48640def7fafe41aafe71355bd32d99" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">많은 파일을 동시에 컴파일하려면 &lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt; &lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22400dc268fe8a7d24bf1a85c2d093a54cf84f6d" translate="yes" xml:space="preserve">
          <source>For convenience, consider adding &lt;code&gt;~/.mix/escripts&lt;/code&gt; directory to your &lt;code&gt;PATH&lt;/code&gt; environment variable. For more information, check the wikipedia article on PATH: &lt;a href=&quot;https://en.wikipedia.org/wiki/PATH_(variable)&quot;&gt;https://en.wikipedia.org/wiki/PATH_(variable)&lt;/a&gt;</source>
          <target state="translated">편의를 위해 &lt;code&gt;~/.mix/escripts&lt;/code&gt; 디렉토리를 &lt;code&gt;PATH&lt;/code&gt; 환경 변수에 추가하는 것이 좋습니다. 자세한 내용은 PATH의 wikipedia 문서를 확인하십시오. &lt;a href=&quot;https://en.wikipedia.org/wiki/PATH_(variable)&quot;&gt;https://en.wikipedia.org/wiki/PATH_(variable)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfd371e570b65e572a1bfac8fa45fb1789e4dcde" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="translated">편의를 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;opts&lt;/code&gt; 인수 로 전달할 수 있으며 현재 환경에서 정의 된 모든 가져 오기, 요구 및 별칭이 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d23e5be0a4ca18d043f1de42dd2f9c986db30d" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="translated">편의를 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;opts&lt;/code&gt; 인수 로 전달할 수 있으며 모든 옵션은 현재 환경에서 자동으로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1c26fa0cb08e8439005305225bde72db303603" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="translated">편의상 &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;opts&lt;/code&gt; 인수로 전달하면 현재 환경에 정의 된 모든 가져 오기, 요구 및 별명이 자동으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="98082b67d38ae575b213c7f51ae3f6f67492121c" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="translated">편의상 &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;opts&lt;/code&gt; 인수 로 전달하면 모든 옵션이 현재 환경에서 자동으로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="44989465a60239ad9d5198d147baa434ebc38464" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="translated">편의를 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 과 같은 모든 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 구조체를 첫 번째 인수 또는 옵션으로 전달할 수 있습니다. 모듈과 모든 옵션이 환경에서 자동으로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="54af569b6a029610c5091d98fd6f8fdc1073fe13" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="translated">편의상 &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 구조체를 첫 번째 인수 또는 옵션으로 전달할 수 있습니다. 모듈과 모든 옵션은 모두 환경에서 자동으로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="74cba56f60db3c6914d9e9b93e9bb138f70a33f1" translate="yes" xml:space="preserve">
          <source>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's &lt;code&gt;:unicode&lt;/code&gt; module.</source>
          <target state="translated">바이너리를 다른 인코딩으로 변환하고 유니 코드 정규화 메커니즘에 대해서는 Erlang의 &lt;code&gt;:unicode&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6add89b99abcbf70ca9badb7516b8595c553f524" translate="yes" xml:space="preserve">
          <source>For debugging complex systems, jumping at the code is not enough. It is necessary to have an understanding of the whole virtual machine, processes, applications, as well as set up tracing mechanisms. Luckily this can be achieved in Erlang with &lt;code&gt;:observer&lt;/code&gt;. In your application:</source>
          <target state="translated">복잡한 시스템을 디버깅하려면 코드를 뛰어 넘는 것으로 충분하지 않습니다. 추적 메커니즘을 설정하고 전체 가상 머신, 프로세스, 애플리케이션을 이해해야합니다. 운 좋게도 이것은 Erlang에서 &lt;code&gt;:observer&lt;/code&gt; 로 달성 할 수 있습니다 . 응용 프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="5a06afd6a1e3c7ee6cdc0611f593f11b1bb1243b" translate="yes" xml:space="preserve">
          <source>For defining your own guards, Elixir even provides conveniences in &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt;. Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical.</source>
          <target state="translated">자신의 가드를 정의하기 위해 Elixir는 &lt;code&gt;defguard&lt;/code&gt; 및 &lt;code&gt;defguardp&lt;/code&gt; 의 편의성을 제공합니다 . 간단한 사례 연구를 살펴 보겠습니다. 인수가 짝수인지 홀수인지 확인하려고합니다. 패턴 매칭을 사용하면 정수의 수가 무한하기 때문에 불가능합니다. 따라서 모든 정수에 대해 패턴 매칭을 할 수 없습니다. 그러므로 우리는 경비원을 사용해야합니다. 홀수를 확인하는 것은 거의 동일하므로 짝수 확인에만 초점을 맞출 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb347f81732d219e27a511b076553d17de737f2a" translate="yes" xml:space="preserve">
          <source>For detailed documentation, see the &lt;a href=&quot;typespecs&quot;&gt;typespec documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 문서는 &lt;a href=&quot;typespecs&quot;&gt;typespec 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3a098e863f08842ff154a18684a91f2e51c3a25" translate="yes" xml:space="preserve">
          <source>For detailed documentation, see the &lt;a href=&quot;typespecs#behaviours&quot;&gt;behaviour typespec documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 문서는 &lt;a href=&quot;typespecs#behaviours&quot;&gt;동작 typespec 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="312205920e8b42c10300fdc1c0d355fb769ce4d0" translate="yes" xml:space="preserve">
          <source>For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">코드 포인트 및 그래프에 대한 자세한 내용은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f4a8cd91cf5db5cd126fba13df45a267644abde" translate="yes" xml:space="preserve">
          <source>For duplicate registries:</source>
          <target state="translated">중복 레지스트리의 경우 :</target>
        </trans-unit>
        <trans-unit id="72d0f0434fbcec9eb207f396a9fc529d7587b375" translate="yes" xml:space="preserve">
          <source>For dynamically logging messages, see &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt;. But note that &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; always evaluates its arguments (unless the argument is an anonymous function).</source>
          <target state="translated">메시지를 동적으로 로깅하려면 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 그러나 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt; 는 인수가 익명 함수가 아닌 한 항상 인수를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1a7f7d68ad358e0a245cd7d3ae221748af013919" translate="yes" xml:space="preserve">
          <source>For each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (rhs) of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">각 실패에 대해 ExUnit은 테스트 케이스와 함께 테스트 이름, 실패한 코드 및 &lt;code&gt;==&lt;/code&gt; 연산자 의 왼쪽 및 오른쪽 (rhs) 값이 포함 된 자세한 보고서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="9e3caa2dc1d9000c1cebb47a719b8e0066b5bd2d" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 목록의 각 프로토콜에 대해 Elixir는 프로토콜이 &lt;code&gt;Any&lt;/code&gt; 에 대해 구현되었다고 주장합니다 . 만약 &lt;code&gt;Any&lt;/code&gt; 구현 정의하는 &lt;code&gt;__deriving__/3&lt;/code&gt; 콜백 콜백이 호출되고이 구현 모듈을 정의해야합니다. 그렇지 않으면 단순히 &lt;code&gt;Any&lt;/code&gt; 구현을 가리키는 구현이 자동으로 파생됩니다. &lt;code&gt;__deriving__/3&lt;/code&gt; 콜백 에 대한 자세한 내용 은&lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#derive/3&quot;&gt; &lt;code&gt;Protocol.derive/3&lt;/code&gt; 를&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e0fb1546f77232688d241d37ca1d325018f6f776" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;protocol#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 목록의 각 프로토콜에 대해 Elixir는 프로토콜이 &lt;code&gt;Any&lt;/code&gt; 에 대해 구현되었다고 주장합니다 . 만약 &lt;code&gt;Any&lt;/code&gt; 구현 정의하는 &lt;code&gt;__deriving__/3&lt;/code&gt; 콜백 콜백이 호출되고이 구현 모듈을 정의해야합니다. 그렇지 않으면 단순히 &lt;code&gt;Any&lt;/code&gt; 구현을 가리키는 구현이 자동으로 파생됩니다. &lt;code&gt;__deriving__/3&lt;/code&gt; 콜백 에 대한 자세한 내용 은 &lt;a href=&quot;protocol#derive/3&quot;&gt; &lt;code&gt;Protocol.derive/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25c946451972c973e2251bc9392dd413447e547a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt; 은 입력이 증가함에 따라 더 오래 걸립니다. 반면에&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; 은&lt;/a&gt; 항상 일정한 시간 (즉 입력 크기에 관계없이)으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce575e007b24aad8c7c6a66939213cc21ace30a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;the Ecto library&lt;/a&gt; makes use of these features to provide an elegant DSL for writing database queries:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;Ecto 라이브러리&lt;/a&gt; 는 이러한 기능을 사용하여 데이터베이스 쿼리 작성을위한 우아한 DSL을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72de0d4d0cc3d700aee14fc5035d60936c6b125d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;keyword#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keyword#delete/3&quot;&gt;&lt;code&gt;Keyword.delete/3&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note that operations that require keys to be found in the keyword list (like &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt;) need to traverse the list in order to find keys, so these operations may be slower than their map counterparts.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt; 는 중복 된 항목이 존재하는지 여부에 관계없이 주어진 키와 일치하는 첫 번째 항목을 가져옵니다. 마찬가지로 &lt;a href=&quot;keyword#put/3&quot;&gt; &lt;code&gt;Keyword.put/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;keyword#delete/3&quot;&gt; &lt;code&gt;Keyword.delete/3&lt;/code&gt; &lt;/a&gt; 는 지정된 키에 대해 중복 된 모든 항목이 호출 될 때 제거되도록합니다. 키워드를 키워드 목록에서 찾아야하는 작업 (예 : &lt;a href=&quot;keyword#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt; )은 키를 찾기 위해 목록을 순회해야하므로지도 작업보다 속도가 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6838c5c681ffb29b6c7310ee5d238a1c820319" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="translated">예를 들어, 입력이 증가함에 따라 &lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt; 이 더 오래 걸립니다. 반면 &lt;a href=&quot;kernel#byte_size/1&quot;&gt; &lt;code&gt;Kernel.byte_size/1&lt;/code&gt; 은&lt;/a&gt; 항상 일정한 시간에 실행됩니다 (즉, 입력 크기에 관계없이).</target>
        </trans-unit>
        <trans-unit id="26266e605a5c6ee91c1509624141ef8292746ecc" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt; then all &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:notice&lt;/code&gt; and above will be passed to backends. If your log level is set to &lt;code&gt;:alert&lt;/code&gt;, only &lt;code&gt;:alert&lt;/code&gt; and &lt;code&gt;:emergency&lt;/code&gt; will be printed.</source>
          <target state="translated">예를 들어 &lt;code&gt;:info&lt;/code&gt; 는 &lt;code&gt;:debug&lt;/code&gt; 보다 우선 합니다. 로그 수준이 &lt;code&gt;:info&lt;/code&gt; 로 설정되어 있으면 모든 &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:notice&lt;/code&gt; 이상이 백엔드로 전달됩니다. 로그 수준이 &lt;code&gt;:alert&lt;/code&gt; 로 설정되어 있으면 &lt;code&gt;:alert&lt;/code&gt; 및 &lt;code&gt;:emergency&lt;/code&gt; 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c117e3a1a342b1f8160acdddadbc25ed7792af" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, and &lt;code&gt;:error&lt;/code&gt; will be printed to the console. If your log level is set to &lt;code&gt;:warn&lt;/code&gt;, only &lt;code&gt;:warn&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt; will be printed.</source>
          <target state="translated">예를 들어, &lt;code&gt;:info&lt;/code&gt; 가 &lt;code&gt;:debug&lt;/code&gt; 보다 우선 합니다. 로그 레벨이 &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; 및 &lt;code&gt;:error&lt;/code&gt; 로 설정되면 콘솔에 인쇄됩니다. 로그 레벨이 &lt;code&gt;:warn&lt;/code&gt; 으로 설정되면 &lt;code&gt;:warn&lt;/code&gt; 및 &lt;code&gt;:error&lt;/code&gt; 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="852751a1fe78b13274da6029c51675b7e90dcb56" translate="yes" xml:space="preserve">
          <source>For example, Nerves uses this function to force all dependencies to be reloaded after it updates the system environment. It goes roughly like this:</source>
          <target state="translated">예를 들어 Nerves는이 함수를 사용하여 시스템 환경을 업데이트 한 후 모든 종속성을 강제로 다시로드합니다. 대략 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4af1c4caff42157f9481064fecc0d437c1cbd415" translate="yes" xml:space="preserve">
          <source>For example, a bitstring generator can be used with the &lt;code&gt;:into&lt;/code&gt; option in order to easily remove all spaces in a string:</source>
          <target state="translated">예를 들어, 문자열에서 모든 공백을 쉽게 제거하기 위해 비트 문자열 생성기를 &lt;code&gt;:into&lt;/code&gt; 옵션 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e07fb9806a4d8ebf20cacc02e52f4a77448a86cc" translate="yes" xml:space="preserve">
          <source>For example, a value that is not meant to be used must be assigned to &lt;code&gt;_&lt;/code&gt; or to a variable starting with underscore:</source>
          <target state="translated">예를 들어, 사용되지 않는 값은 &lt;code&gt;_&lt;/code&gt; 또는 밑줄로 시작하는 변수에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d8801f0d497391a5a53cac45037cd40a678af92" translate="yes" xml:space="preserve">
          <source>For example, although the code point &quot;&amp;eacute;&quot; is a single character, its underlying representation uses two bytes:</source>
          <target state="translated">예를 들어, 코드 포인트 &quot;&amp;eacute;&quot;는 단일 문자이지만 기본 표현은 2 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc12bb8ea1c91096d68d9eef9815101e3f31bcef" translate="yes" xml:space="preserve">
          <source>For example, consider you have a project called &lt;code&gt;my_app&lt;/code&gt; that depends on another one called &lt;code&gt;my_dep&lt;/code&gt;. &lt;code&gt;my_dep&lt;/code&gt; wants to export some configuration, so &lt;code&gt;my_dep/.formatter.exs&lt;/code&gt; would look like this:</source>
          <target state="translated">예를 들어 &lt;code&gt;my_dep&lt;/code&gt; 라는 다른 프로젝트 에 의존하는 &lt;code&gt;my_app&lt;/code&gt; 이라는 프로젝트가 있다고 가정 해보십시오 . &lt;code&gt;my_dep&lt;/code&gt; 는 일부 구성을 내보내 &lt;code&gt;my_dep/.formatter.exs&lt;/code&gt; 하므로 my_dep / .formatter.exs 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bafc7c87cc4324b3f378e1b55b1f860c335be286" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜에는 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a61e8f663dab72d666aa99d7d8392df6e2866f" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜의 경우 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10d10d9aafa7b7150f21f408c108aefffcb399e3" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;code&gt;MyBehaviour&lt;/code&gt; module defined in &quot;Optional callbacks&quot; above:</source>
          <target state="translated">예를 들어 위의 &quot;선택적 콜백&quot;에 정의 된 &lt;code&gt;MyBehaviour&lt;/code&gt; 모듈의 경우 :</target>
        </trans-unit>
        <trans-unit id="8cdbd82ecc31ecfa904887629dd77138df5f318e" translate="yes" xml:space="preserve">
          <source>For example, if the &lt;code&gt;args&lt;/code&gt; in the above &lt;code&gt;echo&lt;/code&gt; task were inspected, you might see something like this:</source>
          <target state="translated">예를 들어, 위의 &lt;code&gt;echo&lt;/code&gt; 작업 의 &lt;code&gt;args&lt;/code&gt; 가 검사 된 경우 다음과 같은 내용이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8306be9b21cc2aa72f1fd185081e1e544776e5ce" translate="yes" xml:space="preserve">
          <source>For example, if we want to use the &lt;code&gt;duplicate/2&lt;/code&gt; function from the &lt;code&gt;List&lt;/code&gt; module several times, we can import it:</source>
          <target state="translated">예를 들어, &lt;code&gt;List&lt;/code&gt; 모듈 에서 &lt;code&gt;duplicate/2&lt;/code&gt; 함수를 여러 번 사용하려면 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f456eb16f2bcd93d7684bd1cc3f45a1a1b9a12d" translate="yes" xml:space="preserve">
          <source>For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages.</source>
          <target state="translated">예를 들어 프로세스가 일부 작업을 수행하기를 기다리는 경우 해당 작업의 진행 상황을 메시지와 통신하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dcc71fade44be2f0b07fe15278a544d60b766461" translate="yes" xml:space="preserve">
          <source>For example, if you expect the target system to have a config file in an absolute path, you can configure your &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">예를 들어, 대상 시스템이 절대 경로에 구성 파일을 가질 것으로 예상하는 경우 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 구성 할 수 있습니다. 를 다음과 같이 .</target>
        </trans-unit>
        <trans-unit id="d7c6d734ff451f6956c6aacbeccd9d4fdd938f74" translate="yes" xml:space="preserve">
          <source>For example, if you have a release named &lt;code&gt;demo&lt;/code&gt;, you can install the service and then start it from the release root as follows:</source>
          <target state="translated">예를 들어 &lt;code&gt;demo&lt;/code&gt; 라는 릴리스가있는 경우 서비스를 설치 한 다음 다음과 같이 릴리스 루트에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcebcea9fb6c7cf3c366b1c527f43067e4ff086" translate="yes" xml:space="preserve">
          <source>For example, if you push the &lt;code&gt;kv&lt;/code&gt; project to a Git repository, you&amp;rsquo;ll need to list it in your deps code in order to use it:</source>
          <target state="translated">예를 들어 &lt;code&gt;kv&lt;/code&gt; 프로젝트를 Git 리포지토리로 푸시하는 경우 이를 사용하려면 deps 코드에 프로젝트를 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3f65aca3ddc3c99d917b0c1b11f664e45fbabf4" translate="yes" xml:space="preserve">
          <source>For example, imagine a function that checks that the head of a list is not &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 목록의 헤드가 &lt;code&gt;nil&lt;/code&gt; 이 아닌지 확인하는 함수를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="aa3f335cc98a4af2b77268595737e5b7b1ed0489" translate="yes" xml:space="preserve">
          <source>For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt;, we want to return the map &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 모든 대문자를 무시하고 각 소문자가 몇 번 발생하는지 계산하려는 문자가있는 바이너리가 있다고 가정하십시오. 예를 들어, 문자열 &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt; 의 경우 맵 &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt; 을 반환하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f71ae8328569a71678b0be29a48fd915491141" translate="yes" xml:space="preserve">
          <source>For example, imagine the following configuration:</source>
          <target state="translated">예를 들어 다음 구성을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="92738f48db6bf8520616d3f910c86cb70b6a91a2" translate="yes" xml:space="preserve">
          <source>For example, imagine we want to implement a Validator module which provides a data validation domain-specific language. We could implement it using data structures, functions or macros. Let&amp;rsquo;s see what those different DSLs would look like:</source>
          <target state="translated">예를 들어 데이터 유효성 검사 도메인 별 언어를 제공하는 유효성 검사기 모듈을 구현한다고 가정합니다. 데이터 구조, 함수 또는 매크로를 사용하여 구현할 수 있습니다. 서로 다른 DSL이 어떻게 보이는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="2ea959d5faa9cf257e82d7007ec084b4f335c593" translate="yes" xml:space="preserve">
          <source>For example, imagine you have a variable &lt;code&gt;number&lt;/code&gt; which contains the number you want to inject inside a quoted expression.</source>
          <target state="translated">예를 들어 따옴표로 묶은 표현식에 삽입하려는 &lt;code&gt;number&lt;/code&gt; 가 포함 된 변수 번호 가 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a2be4f8e8e8f8a802e09e5114bdae52f10f3c768" translate="yes" xml:space="preserve">
          <source>For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this:</source>
          <target state="translated">예를 들어 파일 이름을 이진 파일로받는 API가 있다고 가정합니다. 어느 시점에서이 파일에 쓰려고합니다. 다음과 같은 기능을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f70d74391e0cf5d436981e9565a03fd1f683a6" translate="yes" xml:space="preserve">
          <source>For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like:</source>
          <target state="translated">예를 들어 JSON 파일에서 일부 구성을로드하여 시스템에로드해야한다고 가정하십시오. 해당 구성 제공자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e595982d4d16b2fed73877c7eb51c758ba09c9f8" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How do you often fix it? By restarting it. Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="translated">예를 들어, 컴퓨터, 라우터, 프린터 또는 제대로 작동하지 않는 장치가 있다고 가정하십시오. 얼마나 자주 고치나요? 다시 시작하여. 장치를 다시 시작하면 장치를 초기 상태로 다시 설정하여 테스트를 거쳤으며 제대로 작동합니다. Elixir에서는 동일한 방식을 소프트웨어에 적용합니다. 프로세스가 충돌 할 때마다 충돌 된 프로세스와 동일한 작업을 수행하기 위해 새 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="700e114b8e70a0f80ebb6154d773287b9067f337" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How often do you fix it by restarting it? Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="translated">예를 들어 컴퓨터, 라우터, 프린터 또는 모든 장치가 제대로 작동하지 않는다고 상상해보십시오. 다시 시작하여 얼마나 자주 수정합니까? 장치를 다시 시작하면 장치를 초기 상태로 재설정하여 잘 테스트되고 작동이 보장됩니다. Elixir에서는 이와 동일한 접근 방식을 소프트웨어에 적용합니다. 프로세스가 충돌 할 때마다 충돌 한 프로세스와 동일한 작업을 수행하기 위해 새로운 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f3cd6f9b58acaa3e0524e83ef7217c631726de0e" translate="yes" xml:space="preserve">
          <source>For example, in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;case&lt;/code&gt; 와 &lt;code&gt;cond&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5132419edebfb5538ebf32de072ef747449be00a" translate="yes" xml:space="preserve">
          <source>For example, in order to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">예를 들어, Elixir와 함께 제공되는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 프레임 워크를 사용하여 테스트 케이스를 작성하려면 개발자는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 모듈을 &lt;code&gt;use&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="d7d72e926d93f3ca1c487388374604ee39ad35ad" translate="yes" xml:space="preserve">
          <source>For example, in order to write tests using the ExUnit framework, a developer should use the &lt;code&gt;ExUnit.Case&lt;/code&gt; module:</source>
          <target state="translated">예를 들어 ExUnit 프레임 워크를 사용하여 테스트를 작성하려면 개발자가 &lt;code&gt;ExUnit.Case&lt;/code&gt; 모듈을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3a8a1f3ca0f4f6e6f52cd5c38c70ee3321a7257d" translate="yes" xml:space="preserve">
          <source>For example, setting the mode &lt;code&gt;0o755&lt;/code&gt; gives it write, read and execute permission to the owner and both read and execute permission to group and others.</source>
          <target state="translated">예를 들어, &lt;code&gt;0o755&lt;/code&gt; 모드를 설정하면 소유자 에게 쓰기, 읽기 및 실행 권한이 부여되고 그룹 및 다른 사람에게는 읽기 및 실행 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="aa476bb5aa4307e87b6892c3eef680e2a1027574" translate="yes" xml:space="preserve">
          <source>For example, someone using your application can override its &lt;code&gt;:redis_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">예를 들어, 애플리케이션을 사용하는 사람 은 다음과 같이 : &lt;code&gt;:redis_host&lt;/code&gt; 환경 변수를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f9245784df422bc589c02556ded2ebe4df04fc" translate="yes" xml:space="preserve">
          <source>For example, take a group document represented as &lt;code&gt;[1, 2, 3]&lt;/code&gt; where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as:</source>
          <target state="translated">예를 들어, 모든 쉼표 뒤의 공백이 구분 인 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 으로 표시되는 그룹 문서를 사용 하십시오. 위의 문서가 한 줄에 맞지 않으면 모든 나누기가 활성화되어 문서가 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="5d84b09dd24eed2b37c8292a1e28d040806e59c5" translate="yes" xml:space="preserve">
          <source>For example, take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">예를 들어 다음 &lt;code&gt;.iex.exs&lt;/code&gt; 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d2ade3e7c04be9a767d2179941a1c0d02c356f6" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt; function only works with tuples. If we use it with anything else, an argument error is raised:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt; 함수는 튜플에서만 작동합니다. 다른 것과 함께 사용하면 인수 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f77c979642e1a9533effb1fde71896e71b2b1b38" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/Record.html&quot;&gt;&lt;code&gt;Record&lt;/code&gt;&lt;/a&gt; module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation.</source>
          <target state="translated">예를 들어 Elixir 의 &lt;a href=&quot;https://hexdocs.pm/elixir/Record.html&quot;&gt; &lt;code&gt;Record&lt;/code&gt; &lt;/a&gt; 모듈은 컴파일 중에 튜플이 명명 된 필드를 가질 수 있도록하는 패턴 및 가드에서 사용할 일련의 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dabd9937e48a29e73846df5608de823548c08b1e" translate="yes" xml:space="preserve">
          <source>For example, the code point &quot;&amp;eacute;&quot; is two bytes:</source>
          <target state="translated">예를 들어, 코드 포인트 &quot;&amp;eacute;&quot;는 2 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d6d855b74f3622b261e79dba8a4c6c84fa6807d2" translate="yes" xml:space="preserve">
          <source>For example, the decimal number &lt;code&gt;3&lt;/code&gt; when represented with 4 bits in base 2 would be &lt;code&gt;0011&lt;/code&gt;, which is equivalent to the values &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, each stored using 1 bit:</source>
          <target state="translated">예를 들어, 2 진법 에서 4 비트로 표현 될 때 10 진수 &lt;code&gt;3&lt;/code&gt; 은 &lt;code&gt;0011&lt;/code&gt; 이 되며, 이는 각각 1 비트를 사용하여 저장된 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 값과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d5c30e8005c0c98d6e53ce8dd367db66742e7504" translate="yes" xml:space="preserve">
          <source>For example, the following agent implements a counter:</source>
          <target state="translated">예를 들어 다음 에이전트는 카운터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f261112170af791387e9b66db2c2a75a6ec23785" translate="yes" xml:space="preserve">
          <source>For example, the following is a keyword list:</source>
          <target state="translated">예를 들어 다음은 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3df9b543906bfd5595a0cacf49aeb1e63c393e38" translate="yes" xml:space="preserve">
          <source>For example, the module implementing the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol for lists is &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.List.html&quot;&gt;&lt;code&gt;Enumerable.List&lt;/code&gt;&lt;/a&gt;. Therefore, we can invoke &lt;code&gt;__impl__/1&lt;/code&gt; on this module:</source>
          <target state="translated">예를 들어 목록에 대한 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현하는 모듈 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.List.html&quot;&gt; &lt;code&gt;Enumerable.List&lt;/code&gt; &lt;/a&gt; 입니다. 따라서이 모듈에서 &lt;code&gt;__impl__/1&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b821bcc62d19a98d61faaca345d43a31156e0565" translate="yes" xml:space="preserve">
          <source>For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:</source>
          <target state="translated">예를 들어, 숫자 0.1과 0.01은 그중 두 가지이며, 0.1을 제곱 한 결과 0.01을 가장 가깝게 나타내지 않습니다. 이 경우에 다음과 같은 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3780e894751fdee43da26866cc6af18a271859a8" translate="yes" xml:space="preserve">
          <source>For example, to add multiple backends to your application, modify your configuration:</source>
          <target state="translated">예를 들어 애플리케이션에 여러 백엔드를 추가하려면 구성을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="4009f5a45e54514dcb5423e242c0ca43c71a40ed" translate="yes" xml:space="preserve">
          <source>For example, to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; to redirect all Erlang messages using a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">예를 들어 &lt;code&gt;config/config.exs&lt;/code&gt; 파일을 사용하여 모든 Erlang 메시지를 리디렉션 하도록 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 를 구성 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="97810dcc8560ef61b772f3bdcad87ca93ff037d4" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:backends&lt;/code&gt; and purge all calls that happen at compile time with level lower than &lt;code&gt;:info&lt;/code&gt; in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">예를 들어, &lt;code&gt;:backends&lt;/code&gt; 를 구성하고 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 &lt;code&gt;:info&lt;/code&gt; 보다 낮은 수준으로 컴파일 타임에 발생하는 모든 호출을 제거 하려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="21a8e2abf86d2318a5a86e1829eeef5e5857c798" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:level&lt;/code&gt; and &lt;code&gt;:truncate&lt;/code&gt; options in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">예를 들어, &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 &lt;code&gt;:level&lt;/code&gt; 및 &lt;code&gt;:truncate&lt;/code&gt; 옵션 을 구성하려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b9557028bd4e04dc9baddf4fcbc9b36f7fb55a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;erlc_options&lt;/code&gt; for your Erlang project you may run:</source>
          <target state="translated">예를 들어, Erlang 프로젝트에 대해 &lt;code&gt;erlc_options&lt;/code&gt; 를 구성하려면 다음 을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76a5d4e647864137abb48e20144e766fb0c89015" translate="yes" xml:space="preserve">
          <source>For example, to disable color, one may use the configuration:</source>
          <target state="translated">예를 들어, 색상을 비활성화하려면 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a765ecc41513328acb3598f8f52b46ee7deada9a" translate="yes" xml:space="preserve">
          <source>For example, to lookup a server process, monitor it and send a cast to it:</source>
          <target state="translated">예를 들어, 서버 프로세스를 조회하려면 해당 프로세스를 모니터하고 캐스트를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="cabc9384ea2bf9af1b99579a392dfd97e82162f8" translate="yes" xml:space="preserve">
          <source>For example, to split a test suite into 4 partitions and run them, you would use the following commands:</source>
          <target state="translated">예를 들어 테스트 스위트를 4 개의 파티션으로 분할하고 실행하려면 다음 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="49838731982f45b819651e28face607e270a0d83" translate="yes" xml:space="preserve">
          <source>For example, to update a map inside another map:</source>
          <target state="translated">예를 들어 다른지도 내에서지도를 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="f8d6f1962522c5a74c0c716a39923ef1c094d4d7" translate="yes" xml:space="preserve">
          <source>For example, to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">예를 들어 Elixir에서 제공 하는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 프레임 워크를 사용하여 테스트 케이스를 작성 &lt;code&gt;use&lt;/code&gt; 개발자가 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다 . 모듈을 .</target>
        </trans-unit>
        <trans-unit id="16fe3a971c511fed7157a7e0a03e09bb51dcfcf2" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Just open &lt;code&gt;config/config.exs&lt;/code&gt; and add the following to the end:</source>
          <target state="translated">예를 들어 IEx 기본 프롬프트를 다른 값으로 구성 할 수 있습니다. &lt;code&gt;config/config.exs&lt;/code&gt; 를 열고 끝에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3ad4f120b95aba025295d32b32cd84c67c8c60d6" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Let&amp;rsquo;s create the &lt;code&gt;config/config.exs&lt;/code&gt; file with the following content:</source>
          <target state="translated">예를 들어 IEx 기본 프롬프트를 다른 값으로 구성 할 수 있습니다. 다음 내용으로 &lt;code&gt;config/config.exs&lt;/code&gt; 파일을 생성 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="65ea0a674f1ce41ff4c22e2d07ee72ff95421ac9" translate="yes" xml:space="preserve">
          <source>For example, we can map a list of integers into their squared values:</source>
          <target state="translated">예를 들어 정수 목록을 제곱 된 값으로 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecebd23ebfe4f1d1acd8ff8a2d9a8722555dc40b" translate="yes" xml:space="preserve">
          <source>For example, we can use bitstring generators with the &lt;code&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:</source>
          <target state="translated">예를 들어, &lt;code&gt;:into&lt;/code&gt; 옵션 과 함께 비트 스트링 생성기를 사용 하여 문자열의 모든 공백을 쉽게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="825bc9fd2268ad4ced535baaab0a761647bf3261" translate="yes" xml:space="preserve">
          <source>For example, we could implement &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">예를 들어 다음과 같이 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 와 관련하여 &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; 를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="678b43ac2ccf82f31c5e6153c0e2834d16a5b6ca" translate="yes" xml:space="preserve">
          <source>For example, we could start and register our &lt;code&gt;Stack&lt;/code&gt; server locally as follows:</source>
          <target state="translated">예를 들어 다음과 같이 &lt;code&gt;Stack&lt;/code&gt; 서버를 로컬로 시작하고 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4ed3f8957553e26e0d94986089ddb6888e33a8" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode characters, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="translated">예를 들어 지금까지 4 개의 카운팅 함수를 사용했습니다 : &lt;code&gt;byte_size/1&lt;/code&gt; (문자열의 바이트 수), &lt;code&gt;tuple_size/1&lt;/code&gt; (튜플 크기), &lt;code&gt;length/1&lt;/code&gt; (목록 길이) 및 &lt;code&gt;String.length/1&lt;/code&gt; ( 문자열의 그래프 수에 대한 정보). 우리는 &lt;code&gt;byte_size&lt;/code&gt; 를 사용 하여 문자열의 바이트 수를 얻습니다. 저렴한 작업입니다. 반면에 유니 코드 문자 수를 검색하면 &lt;code&gt;String.length&lt;/code&gt; 가 사용 되며 전체 문자열 순회에 의존하므로 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a856e5ee06c9349ef31043c8ece70cd8e13f1483" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode graphemes, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="translated">예를 들어, 지금까지 4 개의 계수 함수를 사용했습니다 : &lt;code&gt;byte_size/1&lt;/code&gt; (문자열의 바이트 수), &lt;code&gt;tuple_size/1&lt;/code&gt; (튜플 크기), &lt;code&gt;length/1&lt;/code&gt; (목록 길이) 및 &lt;code&gt;String.length/1&lt;/code&gt; ( 문자열의 자소 수). 문자열의 바이트 수를 얻기 위해 &lt;code&gt;byte_size&lt;/code&gt; 를 사용 합니다. 저렴한 작업입니다. 반면에 유니 코드 문자 소의 수를 검색하는 것은 &lt;code&gt;String.length&lt;/code&gt; 를 사용 하며 전체 문자열의 순회에 의존하므로 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e82002b46a7bc98e04a53b8f0787d96d507b69d" translate="yes" xml:space="preserve">
          <source>For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt;. This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it.</source>
          <target state="translated">예를 들어, 개발자는 항상 감독자 하에서 작업을 시작하는 것이 좋습니다. 이를 통해 가시성이 향상되고 노드가 종료 될 때 해당 작업이 종료되는 방법을 제어 할 수 있습니다. &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt; 과 같이 보일 수 있습니다 . 즉, 코드가 작업을 호출하는 코드 임에도 불구하고 작업의 실제 조상은 수퍼바이저입니다. 수퍼바이저는 효과적으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0dcb9a644dbae1acdb996808b23645d55e2f6941" translate="yes" xml:space="preserve">
          <source>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; is not validated against a time zone, such errors would go unnoticed.</source>
          <target state="translated">예를 들어, 일광 절약 시간제 변경 사항이 지역별로 적용되면 시계는 일반적으로 1 시간 씩 앞뒤로 이동합니다. 이는 특정 날짜 시간이 발생하지 않거나 두 번 이상 발생할 수 있음을 의미합니다. 이후 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 이&lt;/a&gt; 시간대에 대해 검증되지 않으며, 이러한 오류는 들키지 것이다.</target>
        </trans-unit>
        <trans-unit id="0134d97aaa5f44efc896482193ec373596c0207e" translate="yes" xml:space="preserve">
          <source>For example, you could specify a &lt;code&gt;URI.Parser&lt;/code&gt; behaviour as follows:</source>
          <target state="translated">예를 들어 다음과 같이 &lt;code&gt;URI.Parser&lt;/code&gt; 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c725586e4c191211220e82dbb160afa5b6efb9" translate="yes" xml:space="preserve">
          <source>For example, you might wish to include a custom &lt;code&gt;:error_code&lt;/code&gt; metadata in your logs:</source>
          <target state="translated">예를 들어 로그에 사용자 지정 &lt;code&gt;:error_code&lt;/code&gt; 메타 데이터 를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e3a66cb565ce65f19a6ff578510f5919a4c4a12" translate="yes" xml:space="preserve">
          <source>For examples on how to use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol and &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;into/1&lt;/code&gt;&lt;/a&gt; see the module documentation.</source>
          <target state="translated">사용하는 방법에 대한 예는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜 및 &lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;into/1&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4c21cf1cac5889764a4444020c6074013f406cd" translate="yes" xml:space="preserve">
          <source>For floats, it is 64. For floats, &lt;code&gt;size * unit&lt;/code&gt; must result in 32 or 64, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32 and binary64, respectively.</source>
          <target state="translated">float의 경우 64입니다. float의 경우 &lt;code&gt;size * unit&lt;/code&gt; 는 각각 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32 및 binary64에 해당하는 32 또는 64 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="e0863812afa8bda24138da4ec3b1ecff0d4ecc46" translate="yes" xml:space="preserve">
          <source>For fun, let's define a simple module in this shell too:</source>
          <target state="translated">이 쉘에서 간단한 모듈을 정의 해보자.</target>
        </trans-unit>
        <trans-unit id="979ac34509c51f5dab54e261eec8b56be64ab620" translate="yes" xml:space="preserve">
          <source>For further details on applications please check the documentation of the &lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt;&lt;code&gt;application&lt;/code&gt;&lt;/a&gt; Erlang module, and the &lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;Applications&lt;/a&gt; section of the &lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP Design Principles User's Guide&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램에 대한 자세한 내용은 응용 &lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt; &lt;code&gt;application&lt;/code&gt; &lt;/a&gt; Erlang 모듈 &lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;의 설명서&lt;/a&gt; 와 OTP 디자인 원칙 사용자 안내서 의 &lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;응용 프로그램&lt;/a&gt; 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91858e05de05b595ba22a40c6d98a7a27a8e926" translate="yes" xml:space="preserve">
          <source>For grouping tests together, see &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; in this module.</source>
          <target state="translated">테스트를 그룹화하려면 이 모듈의 &lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ab7e6ee8d58a006653e5dfc1bb9f58088937ba" translate="yes" xml:space="preserve">
          <source>For instance one period could be the summer of 2018 in &quot;Europe/London&quot; where summer time / daylight saving time is in effect and lasts from spring to autumn. At autumn the &lt;code&gt;std_offset&lt;/code&gt; changes along with the &lt;code&gt;zone_abbr&lt;/code&gt; so a different period is needed during winter.</source>
          <target state="translated">예를 들어 여름 시간 / 일광 절약 시간이 적용되고 봄에서 가을까지 지속되는 &quot;유럽 / 런던&quot;에서 2018 년 여름이 한 기간이 될 수 있습니다. 가을에 &lt;code&gt;std_offset&lt;/code&gt; 는 과 함께 변화 &lt;code&gt;zone_abbr&lt;/code&gt; 다른 기간이 겨울 동안 필요하므로.</target>
        </trans-unit>
        <trans-unit id="e51496febe42a068541cd5f1776cfef4dbdc9e31" translate="yes" xml:space="preserve">
          <source>For instance, given a user map with the &lt;code&gt;:name&lt;/code&gt; and &lt;code&gt;:languages&lt;/code&gt; keys, here is how to deeply traverse the map and convert all language names to uppercase:</source>
          <target state="translated">예를 들어, &lt;code&gt;:name&lt;/code&gt; 및 &lt;code&gt;:languages&lt;/code&gt; 키가 있는 사용자 맵에서 맵 을 깊이 탐색하고 모든 언어 이름을 대문자로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fa8784dfc2e01f4f7777294a47b6dd71b0ca392" translate="yes" xml:space="preserve">
          <source>For instance, releases run using short-names (&lt;code&gt;--sname&lt;/code&gt;). However, if you want to actually run a distributed key-value store in production, you will need multiple nodes and start the release with the &lt;code&gt;--name&lt;/code&gt; option. We can achieve this by setting the &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; environment variable inside the &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; files. Mix already has a template for said files which we can customize, so let&amp;rsquo;s ask Mix to copy them to our application:</source>
          <target state="translated">예를 들어 릴리스는 짧은 이름 ( &lt;code&gt;--sname&lt;/code&gt; )을 사용하여 실행됩니다 . 그러나 실제로 프로덕션에서 분산 키-값 저장소를 실행하려면 여러 노드가 필요하며 &lt;code&gt;--name&lt;/code&gt; 옵션으로 릴리스를 시작해야합니다 . &lt;code&gt;env.sh&lt;/code&gt; 및 &lt;code&gt;env.bat&lt;/code&gt; 파일 내에 &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; 환경 변수 를 설정하여이를 달성 할 수 있습니다. 믹스에는 이미 사용자 정의 할 수있는 파일에 대한 템플릿이 있으므로 믹스에 요청하여 애플리케이션에 복사하도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="098abe87bcf54674f294a660fdeca753e3973228" translate="yes" xml:space="preserve">
          <source>For instance, we can create a file called &lt;code&gt;math.exs&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;math.exs&lt;/code&gt; 라는 파일을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="915841eb2ae9437182185facdb407e9c03dade23" translate="yes" xml:space="preserve">
          <source>For intensive workloads, the registry may also be partitioned (by specifying the &lt;code&gt;:partitions&lt;/code&gt; option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available:</source>
          <target state="translated">집중적 인 워크로드의 경우 &lt;code&gt;:partitions&lt;/code&gt; 옵션 을 지정하여 레지스트리를 분할 할 수도 있습니다 . 파티션이 필요한 경우 파티션 수를 사용 가능한 스케줄러 수로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0be2313f13029f16466fa64d8d779bb84d194911" translate="yes" xml:space="preserve">
          <source>For maps, the first tuple element must be a &lt;code&gt;{key, value}&lt;/code&gt; tuple.</source>
          <target state="translated">맵의 경우 첫 번째 튜플 요소는 &lt;code&gt;{key, value}&lt;/code&gt; 튜플 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ef87b3ee1067750a0799faa766ca960ddec15e8" translate="yes" xml:space="preserve">
          <source>For maps, the function expects a key-value tuple.</source>
          <target state="translated">맵의 경우 함수는 키-값 튜플을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="2006fc3ed297a859555ea878c9cf50cc043d6a81" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-2&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 노드의 상태 변경을 모니터링하려면 &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-2&quot;&gt; &lt;code&gt;:net_kernel.monitor_nodes/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f65055eecdf00696b65a9b430fcafe6f22952a12" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 노드의 상태 변경을 모니터링하려면 &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt; &lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a50d8c364812d16e018ab6d0f72a5d0030e8481" translate="yes" xml:space="preserve">
          <source>For more advanced options available when defining custom attributes, see &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 속성을 정의 할 때 사용 가능한 고급 옵션에 대해서는 &lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;register_attribute/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="095613a0c71daec41f22ebf762f9ec5144c17212" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt;&lt;code&gt;:file.read_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt; &lt;code&gt;:file.read_link/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c85e5081a17eac440f3c5a413306106ced5d9c19" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt;&lt;code&gt;:file.read_link_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt; &lt;code&gt;:file.read_link_info/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40801b427f30e76ede611926a90606441dd86a7c" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; module.</target>
        </trans-unit>
        <trans-unit id="c734b39d3add7d597fc3e2a0a8f87e008c1a861a" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 모듈 의 &quot;Charlists&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95147adb3177256a490cdad3827bcc51779e68e4" translate="yes" xml:space="preserve">
          <source>For more information about IO data, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">IO 데이터에 대한 자세한 내용은 모듈 설명서 의 &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO 데이터&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c3a9dad7c543d1c63c29b6ca8ca500c85b4a2b7" translate="yes" xml:space="preserve">
          <source>For more information about chardata, see the &lt;a href=&quot;#module-chardata&quot;&gt;&quot;Chardata&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">chardata에 대한 자세한 내용은 모듈 설명서 의 &lt;a href=&quot;#module-chardata&quot;&gt;&quot;Chardata&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0541321f88f511fe94f622a2cb19777c006436cc" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">For more information about structs, please check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%25/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="edd1a5e1d2ce7f216383d5f43648eb3d76f38089" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조체에 대한 자세한 내용은 &lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="59d3cf884555506ee92cff193a1929009e874d1e" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &quot;Aliasing&quot; section in the docs for &lt;a href=&quot;mix&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업 앨리어싱에 대한 자세한 내용은 &lt;a href=&quot;mix&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt; 문서에서 &quot;앨리어싱&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78f8e40c63b458c9fad682e6d3b6666a0f62cf7b" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;&quot;Aliases&quot;&lt;/a&gt; section in the docs for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">For more information about task aliasing, take a look at the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;&quot;Aliases&quot;&lt;/a&gt; section in the docs for &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt; &lt;code&gt;Mix&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="da00729bbfd1619462b29a7b8fa0dab41f7868c6" translate="yes" xml:space="preserve">
          <source>For more information and the list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 및 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt; &lt;code&gt;:erlang.open_port/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc7ee954ed549f3663bd8fb004277a09d86223c0" translate="yes" xml:space="preserve">
          <source>For more information and to open any module or function, see &lt;a href=&quot;#open/1&quot;&gt;&lt;code&gt;open/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 및 모듈 또는 기능을 &lt;a href=&quot;#open/1&quot;&gt; &lt;code&gt;open/1&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0b21c46bc07a705dfc9fb743eebf812b0cdc892" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;code&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">코드 경로에 대한 자세한 내용 은 Elixir 의 &lt;a href=&quot;code&quot;&gt; &lt;code&gt;Code&lt;/code&gt; &lt;/a&gt; 모듈과 Erlang의 &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 모듈을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bd54480aa692a8df8b981b72aa444502ecc46ce" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">For more information on code paths, check the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html&quot;&gt; &lt;code&gt;Code&lt;/code&gt; &lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6bd6c86df060a9a0da50c17d815720a12995dd04" translate="yes" xml:space="preserve">
          <source>For more information on each of the possible returned values, see &lt;a href=&quot;#info/1&quot;&gt;&lt;code&gt;info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 각 리턴 값에 대한 자세한 정보는 &lt;a href=&quot;#info/1&quot;&gt; &lt;code&gt;info/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a372c9bd101c94685e235eb649743902f58f48c" translate="yes" xml:space="preserve">
          <source>For more information on how the break is inserted, see &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나누기 삽입 방법에 대한 자세한 내용은 &lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65a28bc1907c5e0ff21b3bd1d4bbcdfcc5c5acaf" translate="yes" xml:space="preserve">
          <source>For more information on running your project, see the official &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix documentation&lt;/a&gt;.</source>
          <target state="translated">프로젝트 실행에 대한 자세한 내용은 공식 &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix &amp;amp; OTP 안내서&lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix &lt;/a&gt;설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eff11d18fedd9846c96b5c225d02a932e7b86b50" translate="yes" xml:space="preserve">
          <source>For more information read the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt; section in the Wikipedia article of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; standard.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; 표준 의 Wikipedia 기사에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;문자 그룹&lt;/a&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5b003e6f0d5f3ad23f1b90e810d0b8f11ff3028f" translate="yes" xml:space="preserve">
          <source>For more information, check &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SmartEngine.html&quot;&gt;&lt;code&gt;EEx.SmartEngine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">For more information, check &lt;a href=&quot;https://hexdocs.pm/eex/EEx.SmartEngine.html&quot;&gt; &lt;code&gt;EEx.SmartEngine&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c1311002c3a957f544a2fb2f22b854fa11815412" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt;&lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt; &lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cd3be4a21a8ffdb5484f382332800faea93a58f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt;&lt;code&gt;:erlang.halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt; &lt;code&gt;:erlang.halt/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48be8c3bec9fc07a6ce3cee60d8a8e670e70ad06" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt;&lt;code&gt;:erlang.monitor_node/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt; &lt;code&gt;:erlang.monitor_node/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb3eefbbccd2c205683a61d85dab5af738a1f1d7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt;&lt;code&gt;:erlang.monitor_node/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt; &lt;code&gt;:erlang.monitor_node/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c9d37564a53538860067ee2ce72a5278d51bbde" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt;&lt;code&gt;:erlang.nodes/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt; &lt;code&gt;:erlang.nodes/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2eb045622e309576ede0093587a78e27c6a80e60" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt;&lt;code&gt;:erlang.port_close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt; &lt;code&gt;:erlang.port_close/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74569ddc9dafdb010b29df91efd894806768f74c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt;&lt;code&gt;:erlang.port_command/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt; &lt;code&gt;:erlang.port_command/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db0e4c8249cd1b3c3788a38e7bf3c3b9d4b6ceab" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt;&lt;code&gt;:erlang.port_connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt; &lt;code&gt;:erlang.port_connect/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ce86a1871484a9008f73d0c702d7521b667af6c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt;&lt;code&gt;:erlang.port_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt; &lt;code&gt;:erlang.port_info/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80edbd442183f322a586734d8b1f7c8a23af48b7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt;&lt;code&gt;:erlang.port_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt; &lt;code&gt;:erlang.port_info/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82424b64f3a822c3b698f3418f074d1a59050668" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt;&lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt; &lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef58581a2fb238d3165babba36ae1b31c20add22" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt;&lt;code&gt;:os.getpid/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt; &lt;code&gt;:os.getpid/0&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed8b5928b9cd599d88e9ffccabb9856023defc53" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">For more information, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; module, the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; function and the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#t:child_spec/0&quot;&gt; &lt;code&gt;Supervisor.child_spec/0&lt;/code&gt; &lt;/a&gt; type.</target>
        </trans-unit>
        <trans-unit id="9ba2f8e0812ba8129e28893614e39bd76a33546b" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈, &lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; 기능 및 &lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt; &lt;code&gt;Supervisor.child_spec/0&lt;/code&gt; &lt;/a&gt; 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c2459bba39c2a32218e800abed73a1b40251809" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: &lt;a href=&quot;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&quot;&gt;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&lt;/a&gt;</source>
          <target state="translated">For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: &lt;a href=&quot;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&quot;&gt;https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d95ccf97994d2d052649c07b5320d1f38bf9f6a" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</source>
          <target state="translated">자세한 내용은 &lt;code&gt;git config&lt;/code&gt; 설명서를 참조하십시오 : https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</target>
        </trans-unit>
        <trans-unit id="72d636c495936af4b6f2d13c4ec5f6492712b56a" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1db1a5e08950211f4efaa987901db5f4cb9b8017" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">더 많은 옵션을 원하면 단일 믹스 작업에 대한 문서를 주시하십시오. 좋은 예는 &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt; 작업 및 모든 특정 컴파일러 작업 (예 : &lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="ab9291211cba201b17b9f64f55072345afbd7fc8" translate="yes" xml:space="preserve">
          <source>For most cases, use &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#now/2&quot;&gt;&lt;code&gt;DateTime.now/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/1&quot;&gt;&lt;code&gt;DateTime.utc_now/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">For most cases, use &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#now/2&quot;&gt; &lt;code&gt;DateTime.now/2&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/1&quot;&gt; &lt;code&gt;DateTime.utc_now/1&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="df72e64eacb9e3850dc8419637a02be86b270033" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s move on and explore the world of I/O in Elixir.</source>
          <target state="translated">지금은 엘릭서에서 I / O 세계를 탐험 해 보자.</target>
        </trans-unit>
        <trans-unit id="9d92d262d1937649c7dcc6aa1826ed7218a816df" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows PowerShell, where &lt;code&gt;iex&lt;/code&gt; is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="translated">For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows PowerShell, where &lt;code&gt;iex&lt;/code&gt; is a PowerShell command) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</target>
        </trans-unit>
        <trans-unit id="f53fcbcb4286cbc82f5367680ea1d01a64e91602" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="translated">지금 들어, 실행하여 시작하자 &lt;code&gt;iex&lt;/code&gt; (또는 &lt;code&gt;iex.bat&lt;/code&gt; 는 Windows에있는 경우) 대화 비약을 의미한다. 대화식 모드에서는 모든 Elixir 표현식을 입력하고 결과를 얻을 수 있습니다. 몇 가지 기본 표현으로 예열합시다.</target>
        </trans-unit>
        <trans-unit id="8f7af079e462a2a151d8084f9a25584ba5fdb2e5" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s write some tests to guarantee our GenServer works as expected.</source>
          <target state="translated">지금은 GenServer가 예상대로 작동하는지 확인하기위한 테스트를 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="148e18f793d17b1f034ccd4f65b51bd7c72b46fe" translate="yes" xml:space="preserve">
          <source>For now, there is a more important bug we need to fix: what happens if our TCP acceptor crashes? Since there is no supervision, the server dies and we won&amp;rsquo;t be able to serve more requests, because it won&amp;rsquo;t be restarted. That&amp;rsquo;s why we must move our server to a supervision tree.</source>
          <target state="translated">현재 우리가 해결해야 할 더 중요한 버그가 있습니다 : TCP 수락자가 충돌하면 어떻게됩니까? 감독이 없기 때문에 서버가 종료되고 다시 시작되지 않기 때문에 더 많은 요청을 처리 할 수 ​​없습니다. 그래서 서버를 감독 트리로 옮겨야합니다.</target>
        </trans-unit>
        <trans-unit id="87f6316211bcc19e1a9eaf598a9dc404f5c35c3f" translate="yes" xml:space="preserve">
          <source>For now, we don&amp;rsquo;t have a mechanism to run tests, but we know that a function named &amp;ldquo;test hello&amp;rdquo; was defined behind the scenes. When we invoke it, it should fail:</source>
          <target state="translated">현재로서는 테스트를 실행하는 메커니즘이 없지만&amp;ldquo;test hello&amp;rdquo;라는 함수가 배후에서 정의되었다는 것을 알고 있습니다. 호출하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c1b2f8891476cbc97734acacb2637f18c16dc0b0" translate="yes" xml:space="preserve">
          <source>For now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.</source>
          <target state="translated">지금은 적절한 API를 제공하지 않고 버킷 등록 논리에 대한 서버 콜백 만 작성합니다.</target>
        </trans-unit>
        <trans-unit id="dc972a5ae988c88cbdf8abf55ced2fc62781c361" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;Node.start/3&lt;/code&gt; &lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt; . Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</target>
        </trans-unit>
        <trans-unit id="cdf1e2badff2fb623eee0d15afc921e9e14a706d" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;node#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">네트워크의 다른 노드의 경우 이는 노드가 다운되는 것과 같습니다. &lt;a href=&quot;node#start/3&quot;&gt; &lt;code&gt;Node.start/3&lt;/code&gt; 으로&lt;/a&gt; 노드를 시작한 경우에만 가능하며 , 그렇지 않으면 &lt;code&gt;{:error, :not_allowed}&lt;/code&gt; 리턴합니다 . 반환 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 로컬 노드가 살아 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="6dc55533805b090f117cb41ae2a4faf8a8f47746" translate="yes" xml:space="preserve">
          <source>For our routing layer, we are going to use tasks, but feel free to explore the other alternatives too.</source>
          <target state="translated">라우팅 계층의 경우 작업을 사용하지만 다른 대안도 자유롭게 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="40e9bcfd5323b3ba76bb77edb0dbd378b076a7c8" translate="yes" xml:space="preserve">
          <source>For qualified calls, Elixir also allows the function name to be written between double- or single-quotes, allowing calls such as &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt;. Operators can be used as qualified calls without a need for quote, such as &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt;.</source>
          <target state="translated">정규화 된 호출의 경우 Elixir에서는 큰 따옴표 나 작은 따옴표 사이에 함수 이름을 쓸 수 있으므로 &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt; 와 같은 호출을 허용합니다 . &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt; 와 같이 따옴표없이 운영자를 규정 된 호출로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42f87f4978894da77ca58ac8711d1cc43114d9dc" translate="yes" xml:space="preserve">
          <source>For reference information about operators (and ordering), check the &lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;reference page on operators&lt;/a&gt;.</source>
          <target state="translated">연산자 (및 주문)에 대한 참조 정보는 연산자의 &lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;참조 페이지를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="45c16b662757456a064165b8b1b3ab76da91cf9d" translate="yes" xml:space="preserve">
          <source>For runtime configuration, you can use the &lt;code&gt;config/runtime.exs&lt;/code&gt; file. It is executed right before applications start in both Mix and releases (assembled with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">For runtime configuration, you can use the &lt;code&gt;config/runtime.exs&lt;/code&gt; file. It is executed right before applications start in both Mix and releases (assembled with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cf040e76c44787262309528d14284c46bf630986" translate="yes" xml:space="preserve">
          <source>For selecting a maximum value out of two consider using &lt;a href=&quot;kernel#max/2&quot;&gt;&lt;code&gt;Kernel.max/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 가지 중 최대 값을 선택하려면 &lt;a href=&quot;kernel#max/2&quot;&gt; &lt;code&gt;Kernel.max/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1562be9dbea9e9ca6fb9c201080d343b056ee54f" translate="yes" xml:space="preserve">
          <source>For selecting a minimal value out of two consider using &lt;a href=&quot;kernel#min/2&quot;&gt;&lt;code&gt;Kernel.min/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">둘 중 최소값을 선택하려면 &lt;a href=&quot;kernel#min/2&quot;&gt; &lt;code&gt;Kernel.min/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4f8060b8066310c46625a879a6c7a04a6546c32" translate="yes" xml:space="preserve">
          <source>For simplicity, we will define a routing table that always points to the current node. That&amp;rsquo;s the table we will use for development and most of our tests. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="translated">For simplicity, we will define a routing table that always points to the current node. That&amp;rsquo;s the table we will use for development and most of our tests. Back in &lt;code&gt;config/config.exs&lt;/code&gt; , add this line:</target>
        </trans-unit>
        <trans-unit id="57260814a626a0bc7ec7efb7558c4019fed8ea33" translate="yes" xml:space="preserve">
          <source>For such cases, there is a special break-trigger (&lt;code&gt;#iex:break&lt;/code&gt;) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</source>
          <target state="translated">이러한 경우, 줄 자체에서 발견 될 때 쉘이 보류중인 표현식에서 빠져 나와 정상 상태로 돌아가도록 하는 특별한 중단 트리거 ( &lt;code&gt;#iex:break&lt;/code&gt; )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2bcf831b712f7880bfa8b2d774584d0dac9e8fa" translate="yes" xml:space="preserve">
          <source>For such, you can explicitly pass the current module scope as argument:</source>
          <target state="translated">이를 위해 현재 모듈 범위를 인수로 명시 적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5574a61794819cd12b11f08763b8c0faad5bbf7" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실제 날짜, 시간 및 날짜 / 시간 구조는 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b01361fded820f92aa3d34dea84f82e83756a312" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">For the actual date, time and datetime structures, see &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dd4507d56d8ae26835032192a96f8f942cf347e1" translate="yes" xml:space="preserve">
          <source>For the cases where you do expect a file to exist (and the lack of that file is truly an &lt;em&gt;error&lt;/em&gt;) you may use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="translated">파일이 존재할 것으로 예상되는 경우 (그리고 해당 파일이없는 것이 실제로 &lt;em&gt;오류 인 경우&lt;/em&gt; ) &lt;code&gt;File.read!/1&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="feff331a64ed11f441e7848a674afa89ee8071f6" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt;&lt;code&gt;:erlang.spawn/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt; &lt;code&gt;:erlang.spawn/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6639a98f71e3255b9d9416659477b36d9f9e63f9" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt;&lt;code&gt;:erlang.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt; &lt;code&gt;:erlang.spawn/4&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d102dfda15fab2a12aecfca86ecdab6b9328f4c7" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt;&lt;code&gt;:erlang.spawn/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt; &lt;code&gt;:erlang.spawn/5&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="147c5308097c95403b6c3b710471092817aba390" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt;&lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt; &lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad4e9a7fc7900bbb60654000287c4ad75fc0eadd" translate="yes" xml:space="preserve">
          <source>For the list of supported warnings, see &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;&lt;code&gt;:dialyzer&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">지원되는 경고 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt; &lt;code&gt;:dialyzer&lt;/code&gt; 모듈을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a293fce2f70fe18d9d7bb3411509a1883ca74c72" translate="yes" xml:space="preserve">
          <source>For this chapter, we will be using files instead of running code samples in IEx. That&amp;rsquo;s because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a &lt;code&gt;macros.exs&lt;/code&gt; file and running it with &lt;code&gt;elixir macros.exs&lt;/code&gt; or &lt;code&gt;iex macros.exs&lt;/code&gt;.</source>
          <target state="translated">이 장에서는 IEx에서 코드 샘플을 실행하는 대신 파일을 사용합니다. 코드 샘플이 여러 줄의 코드로 확장되어 IEx에 모두 입력하면 역효과를 낼 수 있기 때문입니다. 코드 샘플을 &lt;code&gt;macros.exs&lt;/code&gt; 파일 에 저장하고 &lt;code&gt;elixir macros.exs&lt;/code&gt; 또는 &lt;code&gt;iex macros.exs&lt;/code&gt; 로 실행하여 코드 샘플을 실행할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="467f37cafc343b5dd34e43c5cc0cac653196e6ee" translate="yes" xml:space="preserve">
          <source>For this reason, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; supports partitioning the test files across different Elixir instances. This is done by setting the &lt;code&gt;--partitions&lt;/code&gt; option to an integer, with the number of partitions, and setting the &lt;code&gt;MIX_TEST_PARTITION&lt;/code&gt; environment variable to control which test partition that particular instance is running. This can also be useful if you want to distribute testing across multiple machines.</source>
          <target state="translated">For this reason, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; supports partitioning the test files across different Elixir instances. This is done by setting the &lt;code&gt;--partitions&lt;/code&gt; option to an integer, with the number of partitions, and setting the &lt;code&gt;MIX_TEST_PARTITION&lt;/code&gt; environment variable to control which test partition that particular instance is running. This can also be useful if you want to distribute testing across multiple machines.</target>
        </trans-unit>
        <trans-unit id="945a8597b683042909912d13ab0af0f05f4a1912" translate="yes" xml:space="preserve">
          <source>For this reason, Mix also provides an &lt;code&gt;--only&lt;/code&gt; option that excludes all tests and includes only the given ones:</source>
          <target state="translated">이러한 이유로 Mix는 모든 테스트를 제외하고 지정된 테스트 만 포함 하는 &lt;code&gt;--only&lt;/code&gt; 옵션 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="5942291bf8303552448ccf23f92c1cc85a264e74" translate="yes" xml:space="preserve">
          <source>For this reason, Mix supports &amp;ldquo;umbrella projects&amp;rdquo;. Umbrella projects are used to build applications that run together in a single repository. That is exactly the style we are going to explore in the next sections.</source>
          <target state="translated">이러한 이유로 Mix는 &quot;우산 프로젝트&quot;를 지원합니다. 우산 프로젝트는 단일 저장소에서 함께 실행되는 애플리케이션을 빌드하는 데 사용됩니다. 이것이 바로 다음 섹션에서 살펴볼 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="c1c939e13c6bbd8a4d4a1a8b54e616c8009ed164" translate="yes" xml:space="preserve">
          <source>For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">For this reason, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</target>
        </trans-unit>
        <trans-unit id="db439eca1a575baf9e479914a743abe4e55ae0ad" translate="yes" xml:space="preserve">
          <source>For this reason, the task touches your &lt;code&gt;:compile_path&lt;/code&gt; directory and sets the modification time to the current time and date at the end of each compilation. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="translated">이러한 이유로 작업은 &lt;code&gt;:compile_path&lt;/code&gt; 디렉토리를 건드리고 각 컴파일이 끝날 때 수정 시간을 현재 시간과 날짜로 설정합니다. &lt;code&gt;--force&lt;/code&gt; 옵션 을 전달하면 수정 시간에 관계없이 강제로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32446efaffd01773633a5c5b128367d85e1cc28b" translate="yes" xml:space="preserve">
          <source>For those reasons, reading the application environment at runtime should be the first choice. However, if you really have to read the application environment during compilation, we recommend you to use &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; instead:</source>
          <target state="translated">For those reasons, reading the application environment at runtime should be the first choice. However, if you really have to read the application environment during compilation, we recommend you to use &lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt; instead:</target>
        </trans-unit>
        <trans-unit id="c4c8e038c25d83bf6d852a971892fb340f9e2eff" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module in a file named &lt;code&gt;example.ex&lt;/code&gt;:</source>
          <target state="translated">For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt; . Let&amp;rsquo;s define a module in a file named &lt;code&gt;example.ex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cfae34045d5d895009311d2a2a010463848d8c45" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module:</source>
          <target state="translated">중단 점을 즐기지 만 시각적 디버거에 관심이있는 사용자를 위해 Erlang / OTP에는 편리한 이름이 &lt;code&gt;:debugger&lt;/code&gt; 인 그래픽 디버거가 제공 됩니다. 모듈을 정의 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="bc2d3f32f1c4138eee3831b35b324f9d5504e4b5" translate="yes" xml:space="preserve">
          <source>For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value.</source>
          <target state="translated">고유 한 레지스트리의 경우 특정 값과 일치하는지 여부에 따라 조건부로 키를 등록 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14cd0b7637eff1b0c6bd870cfbdfa9301754b7b7" translate="yes" xml:space="preserve">
          <source>For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up.</source>
          <target state="translated">고유 한 레지스트리의 경우 단일 파티션 조회가 필요합니다. 중복 레지스트리의 경우 모든 파티션을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="a33570d2441921e7831b3c41af0473896917c621" translate="yes" xml:space="preserve">
          <source>For unique registries:</source>
          <target state="translated">고유 한 레지스트리의 경우 :</target>
        </trans-unit>
        <trans-unit id="a494479b1595316138e63803f01b27c1d049ecb0" translate="yes" xml:space="preserve">
          <source>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</source>
          <target state="translated">변수의 경우 밑줄로 시작하는 식별자는 사용되지 않은 변수를 나타내야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c93842334df0e58537ff9e4564650c5a06d71f1b" translate="yes" xml:space="preserve">
          <source>Forces the current group to be unfit.</source>
          <target state="translated">현재 그룹을 부적합하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c5bf5789dde7373724874c65a12c156bc9c3ab1f" translate="yes" xml:space="preserve">
          <source>Forces the disconnection of a node.</source>
          <target state="translated">노드 연결을 강제로 끊습니다.</target>
        </trans-unit>
        <trans-unit id="815a28d19a43ab21cf99300b9b2fd43fa459fe43" translate="yes" xml:space="preserve">
          <source>Forces the path to be a relative path.</source>
          <target state="translated">경로를 상대 경로로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="5c35ec0ad733522cc571cfec85232066d155794d" translate="yes" xml:space="preserve">
          <source>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</source>
          <target state="translated">명명 된 ANSI 시퀀스를 실제 ANSI 코드로 변환하여 chardata와 같은 인수를 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="2207193e5d684c4dc9f415ae14757dea81eca345" translate="yes" xml:space="preserve">
          <source>Formats a file.</source>
          <target state="translated">파일을 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="cafa245a564712637537f38b69c740ea4dde1a5f" translate="yes" xml:space="preserve">
          <source>Formats a given document for a given width.</source>
          <target state="translated">주어진 너비에 대해 주어진 문서를 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="8dfa3afe7b66a75ca4db90cdffb1c56ec5f2cef4" translate="yes" xml:space="preserve">
          <source>Formats an exit. It returns a string.</source>
          <target state="translated">엑시트를 형식화합니다. 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6efb90c18f18ca530ad6f75b186ea9a0dab0abb7" translate="yes" xml:space="preserve">
          <source>Formats and truncates messages on the client to avoid clogging &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; backends.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 백엔드가 막히지 않도록 클라이언트에서 메시지를 형식화하고 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="56622496774bb19434d2ebee47141c996a87f22d" translate="yes" xml:space="preserve">
          <source>Formats date as chardata.</source>
          <target state="translated">날짜를 chardata로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="027d7a70820717a59658836a98131d6522ec7975" translate="yes" xml:space="preserve">
          <source>Formats filters used to constrain cases to be run.</source>
          <target state="translated">Formats filters used to constrain cases to be run.</target>
        </trans-unit>
        <trans-unit id="8c5df1d8fe3d3f335538a7bdda896042d42452a8" translate="yes" xml:space="preserve">
          <source>Formats received datetime into a string.</source>
          <target state="translated">Formats received datetime into a string.</target>
        </trans-unit>
        <trans-unit id="aa53a753f568d1640d41923f79bf478cc8554997" translate="yes" xml:space="preserve">
          <source>Formats the error reason returned by &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;ensure_started/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unload/1&quot;&gt;&lt;code&gt;unload/1&lt;/code&gt;&lt;/a&gt;, returns a string.</source>
          <target state="translated">&lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ensure_started/2&quot;&gt; &lt;code&gt;ensure_started/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unload/1&quot;&gt; &lt;code&gt;unload/1&lt;/code&gt; &lt;/a&gt; 에서 리턴 한 오류 이유를 형식화 하면 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e18bb89882580c7f86301b123f406d45a0f80a81" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces.</source>
          <target state="translated">Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces.</target>
        </trans-unit>
        <trans-unit id="7f7ec50c392208c557864813c0cfdc9b2645d9c5" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces. If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">stacktrace에 표시된대로 지정된 &lt;code&gt;file&lt;/code&gt; 과 &lt;code&gt;line&lt;/code&gt; 을 형식화합니다. 값이 &lt;code&gt;nil&lt;/code&gt; 인 경우 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="aa90b5e3e8aaedcbfa1f49413d30ef681c6976ab" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, and &lt;code&gt;column&lt;/code&gt; as shown in stacktraces.</source>
          <target state="translated">Formats the given &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; , and &lt;code&gt;column&lt;/code&gt; as shown in stacktraces.</target>
        </trans-unit>
        <trans-unit id="43daea1857449413e5d2961950390283bfbd89a9" translate="yes" xml:space="preserve">
          <source>Formats the given code &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">주어진 코드 &lt;code&gt;string&lt;/code&gt; 포맷합니다 .</target>
        </trans-unit>
        <trans-unit id="4e9ff0af2c46ca0408f0eb37c63e3365599d3452" translate="yes" xml:space="preserve">
          <source>Formats the given files and patterns.</source>
          <target state="translated">Formats the given files and patterns.</target>
        </trans-unit>
        <trans-unit id="60cbeba6574b12f984495c88bbbacdd53f31a94a" translate="yes" xml:space="preserve">
          <source>Formats the location for &lt;a href=&quot;#whereami/3&quot;&gt;&lt;code&gt;whereami/3&lt;/code&gt;&lt;/a&gt; prying.</source>
          <target state="translated">Formats the location for &lt;a href=&quot;#whereami/3&quot;&gt; &lt;code&gt;whereami/3&lt;/code&gt; &lt;/a&gt; prying.</target>
        </trans-unit>
        <trans-unit id="095114a79701908ee2dfdcd7beb556b92bb7fa82" translate="yes" xml:space="preserve">
          <source>Formats the stacktrace.</source>
          <target state="translated">스택 추적을 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="bc17a3e28e6db9da82c06d3e64dd8f9133ab1362" translate="yes" xml:space="preserve">
          <source>Formats time as chardata.</source>
          <target state="translated">시간을 chardata로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="5fe0bd39dac4ab949c5775de27530dde1ae6b8b7" translate="yes" xml:space="preserve">
          <source>Formats time taken running the test suite.</source>
          <target state="translated">Formats time taken running the test suite.</target>
        </trans-unit>
        <trans-unit id="15bac6318ac5108c02b6ce4ab557e2ea1f9cdf7e" translate="yes" xml:space="preserve">
          <source>Formatted text output</source>
          <target state="translated">형식화 된 텍스트 출력</target>
        </trans-unit>
        <trans-unit id="c66bee8a4119b5327ef887f4d0279de0d7aa74f7" translate="yes" xml:space="preserve">
          <source>Formatters are &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s specified during ExUnit configuration that receive a series of events as casts.</source>
          <target state="translated">Formatters are &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;s specified during ExUnit configuration that receive a series of events as casts.</target>
        </trans-unit>
        <trans-unit id="c4eab01558e7f8dfc62c9bd7e738281bda6c0c43" translate="yes" xml:space="preserve">
          <source>Formatting options</source>
          <target state="translated">Formatting options</target>
        </trans-unit>
        <trans-unit id="d313dfa968201dd94ad67d87fc3344bb38c0890c" translate="yes" xml:space="preserve">
          <source>Formatting syntax</source>
          <target state="translated">Formatting syntax</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="8b2cd2532672c31ff20ceae8b0d526cd937086f0" translate="yes" xml:space="preserve">
          <source>Forwards the error to the current process.</source>
          <target state="translated">현재 프로세스로 오류를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9fdf06a3445d03e7647fe9c67a18a17eb8735986" translate="yes" xml:space="preserve">
          <source>Forwards the message to the current process.</source>
          <target state="translated">메시지를 현재 프로세스로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="39a119adde6f197e8aa3e8c2dbd49285e486f01b" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Fractional second precision stays the same in a similar way to &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html#add/2&quot;&gt; &lt;code&gt;NaiveDateTime.add/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="addaa186164be6af6cfe3af8285a06cb4198e95d" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;naivedatetime#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">분수 초정밀도는 &lt;a href=&quot;naivedatetime#add/2&quot;&gt; &lt;code&gt;NaiveDateTime.add/2&lt;/code&gt; &lt;/a&gt; 와 비슷한 방식으로 동일하게 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4802179f7c5db9ab1d4360e530bc8c507bf436cc" translate="yes" xml:space="preserve">
          <source>Framed.</source>
          <target state="translated">Framed.</target>
        </trans-unit>
        <trans-unit id="61df51b01c40ba0a9247aa6363331261830b3b95" translate="yes" xml:space="preserve">
          <source>From Elixir v1.10, Elixir's Logger is fully integrated with Erlang's logger. They share the same &lt;a href=&quot;#level/0&quot;&gt;&lt;code&gt;Logger.level/0&lt;/code&gt;&lt;/a&gt;, any metadata set with &lt;a href=&quot;#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; applies to both, and so on.</source>
          <target state="translated">From Elixir v1.10, Elixir's Logger is fully integrated with Erlang's logger. They share the same &lt;a href=&quot;#level/0&quot;&gt; &lt;code&gt;Logger.level/0&lt;/code&gt; &lt;/a&gt;, any metadata set with &lt;a href=&quot;#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; applies to both, and so on.</target>
        </trans-unit>
        <trans-unit id="37cd4097eb3a24362095532952b9b30616bd33e9" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under &lt;code&gt;MyApp&lt;/code&gt;, you can alias the modules &lt;code&gt;MyApp.Foo&lt;/code&gt;, &lt;code&gt;MyApp.Bar&lt;/code&gt; and &lt;code&gt;MyApp.Baz&lt;/code&gt; at once as follows:</source>
          <target state="translated">Elixir v1.2부터는 한 번에 여러 모듈을 별칭으로 가져 오거나 가져올 수 있습니다. 이것은 중첩 모듈을 시작한 후에 특히 유용하며, 이는 Elixir 응용 프로그램을 구축 할 때 매우 일반적입니다. 예를 들어 모든 모듈이 &lt;code&gt;MyApp&lt;/code&gt; 아래에 중첩 된 응용 프로그램이 있다고 가정하면 다음과 같이 &lt;code&gt;MyApp.Foo&lt;/code&gt; , &lt;code&gt;MyApp.Bar&lt;/code&gt; 및 &lt;code&gt;MyApp.Baz&lt;/code&gt; 모듈의 별칭 을 한 번에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f129d8dac3eb2b485d35cfaa8fcb065c8677f2f" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, protocol consolidation happens automatically for all projects. We will build our own project in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Elixir v1.2부터 모든 프로젝트에 대해 프로토콜 통합이 자동으로 수행됩니다. 우리는 &lt;strong&gt;&lt;em&gt;Mix and OTP 가이드&lt;/em&gt;&lt;/strong&gt; 에서 우리 자신의 프로젝트를 만들 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a9cab3793941ece60ffc8a0b775c34f6a348677a" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 21, &lt;code&gt;:handle_sasl_reports&lt;/code&gt; only has an effect if &lt;code&gt;:handle_otp_reports&lt;/code&gt; is true.</source>
          <target state="translated">Erlang / OTP 21에서 &lt;code&gt;:handle_sasl_reports&lt;/code&gt; 는 &lt;code&gt;:handle_otp_reports&lt;/code&gt; 가 true 인 경우에만 효과 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b5ac9d2f1ffaa0f16939a6691b3606f6f5495e8" translate="yes" xml:space="preserve">
          <source>From inside &lt;code&gt;bar@computer-name&lt;/code&gt;, we can now spawn a task directly on the other node via the supervisor:</source>
          <target state="translated">&lt;code&gt;bar@computer-name&lt;/code&gt; 내부 에서 감독자를 통해 다른 노드에 직접 작업을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee07fcd21c8e4081421ab00fc5d8c03d08b554f" translate="yes" xml:space="preserve">
          <source>From now on, ExUnit will not run any test that has the &lt;code&gt;:external&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;. This behaviour can be reversed with the &lt;code&gt;:include&lt;/code&gt; option which is usually passed through the command line:</source>
          <target state="translated">이제부터 ExUnit은 &lt;code&gt;:external&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 테스트를 실행하지 않습니다 . 이 동작 은 일반적으로 명령 행을 통해 전달되는 &lt;code&gt;:include&lt;/code&gt; 옵션 으로 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c26276a10f65beef569c18570dfcc2f42f56636" translate="yes" xml:space="preserve">
          <source>From now on, we will be using the term &quot;event handler&quot; to refer to your custom backend, as we head into implementation details.</source>
          <target state="translated">이제부터는 구현 세부 정보로 향할 때 &quot;이벤트 핸들러&quot;라는 용어를 사용하여 사용자 지정 백엔드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="938617f06857d43f6a085cfd6bce09c1655cac4a" translate="yes" xml:space="preserve">
          <source>From our quick exploration, we could conclude that we should use &lt;code&gt;Node.spawn_link/2&lt;/code&gt; to spawn processes on a remote node every time we need to do a distributed computation. However, we have learned throughout this guide that spawning processes outside of supervision trees should be avoided if possible, so we need to look for other options.</source>
          <target state="translated">빠른 탐색 을 통해 분산 계산이 필요할 때마다 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 를 사용 하여 원격 노드에서 프로세스를 생성 해야한다는 결론을 내릴 수 있습니다. 그러나이 안내서 전체에서 가능한 경우 감독 트리 외부에서 생성되는 프로세스를 피해야하므로 다른 옵션을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="4db16168eb1bd7c62518bc09890c1b7ba6baa6ce" translate="yes" xml:space="preserve">
          <source>From the printed information, we can see far fewer files are generated. The generated &lt;code&gt;mix.exs&lt;/code&gt; file is different too. Let&amp;rsquo;s take a look (comments have been removed):</source>
          <target state="translated">인쇄 된 정보에서 훨씬 적은 파일이 생성되는 것을 볼 수 있습니다. 생성 된 &lt;code&gt;mix.exs&lt;/code&gt; 파일도 다릅니다. 살펴 보자 (의견 제거) :</target>
        </trans-unit>
        <trans-unit id="d86c7074fa10260d3d9ae0cadb6b7bff099b2b69" translate="yes" xml:space="preserve">
          <source>Full month name</source>
          <target state="translated">월 이름</target>
        </trans-unit>
        <trans-unit id="2298064d1fda3e808dc04798e3aef0bd717a3cbf" translate="yes" xml:space="preserve">
          <source>Full name of day</source>
          <target state="translated">Full name of day</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="8e40024a6b83dbe7056d1e4a40db12942b440d4e" translate="yes" xml:space="preserve">
          <source>Function Arguments</source>
          <target state="translated">함수 인수</target>
        </trans-unit>
        <trans-unit id="bc1254dc5150511a2a061bfd2a8e778f130ed9a6" translate="yes" xml:space="preserve">
          <source>Function and variable names</source>
          <target state="translated">함수와 변수 이름</target>
        </trans-unit>
        <trans-unit id="83ade9ad4e94b4c5006286b88e8447b8a91c444a" translate="yes" xml:space="preserve">
          <source>Function and variable names have the following syntax: A &lt;em&gt;lowercase ASCII letter&lt;/em&gt; or an &lt;em&gt;underscore&lt;/em&gt;, followed by any number of &lt;em&gt;lowercase or uppercase ASCII letters&lt;/em&gt;, &lt;em&gt;numbers&lt;/em&gt;, or &lt;em&gt;underscores&lt;/em&gt;. Optionally they can end in either an &lt;em&gt;exclamation mark&lt;/em&gt; or a &lt;em&gt;question mark&lt;/em&gt;.</source>
          <target state="translated">함수 및 변수 이름은 다음과 같은 구문을 갖습니다. &lt;em&gt;소문자 ASCII 문자&lt;/em&gt; 또는 &lt;em&gt;밑줄&lt;/em&gt; , 그 뒤에 여러 &lt;em&gt;소문자 또는 대문자 ASCII 문자&lt;/em&gt; , &lt;em&gt;숫자&lt;/em&gt; 또는 &lt;em&gt;밑줄&lt;/em&gt; . 선택적들이는 중 하나로 끝낼 수 &lt;em&gt;느낌표&lt;/em&gt; 나 &lt;em&gt;물음표&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="317d75f3496ca96594673f20ba1da34b938abdcd" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does (known as &quot;implicit try&quot;). For example, the following two functions are equivalent:</source>
          <target state="translated">Function bodies support &lt;code&gt;rescue&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; , and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt; does (known as &quot;implicit try&quot;). For example, the following two functions are equivalent:</target>
        </trans-unit>
        <trans-unit id="23cced316c3006e2ae03dfcedc7e3c98513a344d" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does. For example, the following two functions are equivalent:</source>
          <target state="translated">기능 기관 지원 &lt;code&gt;rescue&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; , 그리고 &lt;code&gt;else&lt;/code&gt; 으로 &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt; 않습니다. 예를 들어 다음 두 기능은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a06abcd236c2b1c30e0ad208ebb8f15fa6b429ec" translate="yes" xml:space="preserve">
          <source>Function capturing</source>
          <target state="translated">기능 캡처</target>
        </trans-unit>
        <trans-unit id="f1329761aa64d73b0a0135229f12fe0d0ace1793" translate="yes" xml:space="preserve">
          <source>Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:</source>
          <target state="translated">함수 선언은 또한 가드 및 다중 절을 지원합니다. 함수에 여러 절이있는 경우 Elixir는 일치하는 것을 찾을 때까지 각 절을 시도합니다. 주어진 숫자가 0인지 아닌지를 검사하는 함수의 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a8ac45592076c6753dc5eab45709c494a73fe32" translate="yes" xml:space="preserve">
          <source>Function names may also start with an underscore. Such functions are never imported by default:</source>
          <target state="translated">함수 이름은 밑줄로 시작할 수도 있습니다. 이러한 기능은 기본적으로 가져 오지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
