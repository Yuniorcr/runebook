<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="814c5f11fc85ecacb301d5d1ff7a5207b63cc546" translate="yes" xml:space="preserve">
          <source>Starts monitoring the given &lt;code&gt;port&lt;/code&gt; from the calling process.</source>
          <target state="translated">호출 프로세스에서 지정된 &lt;code&gt;port&lt;/code&gt; 모니터링을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="32f7fdf8c34390c9e691d76ef8c0ec7bd0d81af7" translate="yes" xml:space="preserve">
          <source>Starts the current application and runs code.</source>
          <target state="translated">현재 응용 프로그램을 시작하고 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="465701ca429a2dfabc3bc5f01a8bd60e3b9231c7" translate="yes" xml:space="preserve">
          <source>Starts the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;app&lt;/code&gt; 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="e2271caeb4b7d5b3c207dd94c7b7c318ed2188f2" translate="yes" xml:space="preserve">
          <source>Starts the registry as a supervisor process.</source>
          <target state="translated">감독자 프로세스로 레지스트리를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="a04227ba1319a1fad4347603729d051498bac906" translate="yes" xml:space="preserve">
          <source>Static code analysis</source>
          <target state="translated">정적 코드 분석</target>
        </trans-unit>
        <trans-unit id="cdde4f20ba31a24db2cc7ae71135c8353631907b" translate="yes" xml:space="preserve">
          <source>Steps</source>
          <target state="translated">Steps</target>
        </trans-unit>
        <trans-unit id="a62a6d902db47855d8f77112868e3787eabbca53" translate="yes" xml:space="preserve">
          <source>Stopping an application with a callback module has three steps:</source>
          <target state="translated">콜백 모듈을 사용하여 응용 프로그램을 중지하려면 다음 세 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3753ad0cdb9c49b6498a88fe4f4514a2b9b36ece" translate="yes" xml:space="preserve">
          <source>Stopping an application without a callback module is defined, but except for some system tracing, it is in practice a no-op.</source>
          <target state="translated">콜백 모듈없이 응용 프로그램을 중지하는 것이 정의되어 있지만 일부 시스템 추적을 제외하고 실제로는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5b2d506e52eb47a1075dbad242127c01e521df7" translate="yes" xml:space="preserve">
          <source>Stopping applications</source>
          <target state="translated">응용 프로그램 중지</target>
        </trans-unit>
        <trans-unit id="16d9ee2c7e28df63e19079e90e7824e30d92fc9f" translate="yes" xml:space="preserve">
          <source>Stops a child process started via &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt; 를 통해 시작된 하위 프로세스를 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="1d836dc29fd66efd06619857a7f3fbdbb2570615" translate="yes" xml:space="preserve">
          <source>Stops the IO device and returns the remaining input/output buffers.</source>
          <target state="translated">IO 장치를 중지하고 나머지 입력 / 출력 버퍼를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="420cba62897b963528b14026eceb60569ceedeae" translate="yes" xml:space="preserve">
          <source>Stops the execution of the calling process with the given reason.</source>
          <target state="translated">주어진 이유로 호출 프로세스의 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="1b87ddfd2f0a1efe1c63c07d6457515d241e5a11" translate="yes" xml:space="preserve">
          <source>Stops the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="9e5206ef2f4946342c59fa2df527c82ea74eb890" translate="yes" xml:space="preserve">
          <source>Stores a compilation option.</source>
          <target state="translated">컴파일 옵션을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5e57817ff2a6b8e48e8d562b55890d766e0aa874" translate="yes" xml:space="preserve">
          <source>Stores all given compilation options.</source>
          <target state="translated">주어진 모든 컴파일 옵션을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7a8ca646fdc158d3d531a0223dadbec6991917ca" translate="yes" xml:space="preserve">
          <source>Stores registry metadata.</source>
          <target state="translated">레지스트리 메타 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="486a63f10cb978abccfbd8ecf134b1efae0f41f9" translate="yes" xml:space="preserve">
          <source>Stores the given &lt;code&gt;key&lt;/code&gt;-&lt;code&gt;value&lt;/code&gt; pair in the process dictionary.</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; - &lt;code&gt;value&lt;/code&gt; 쌍을 프로세스 사전에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="3a40588dab874cb0f15e4d524b5977f1cc44faf9" translate="yes" xml:space="preserve">
          <source>Storing information with attributes</source>
          <target state="translated">속성을 사용하여 정보 저장</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="32937312f1205a985f371273166b0a08620a94b4" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">스트림은 컴포저 블하고 게으른 열거 형입니다 (열거 형에 대한 소개는 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 참조 ). 열거하는 동안 요소를 하나씩 생성하는 열거 가능 항목을 스트림이라고합니다. 예를 들어, 엘릭서의 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 는 스트림입니다 :</target>
        </trans-unit>
        <trans-unit id="9c5426850f84369e2b7dbe33f323ee50c006981f" translate="yes" xml:space="preserve">
          <source>Streams are composable, lazy enumerables (for an introduction on enumerables, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module). Any enumerable that generates elements one by one during enumeration is called a stream. For example, Elixir's &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a stream:</source>
          <target state="translated">스트림은 구성 가능하고 지연된 열거 형입니다 (열거 형에 대한 소개는 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 참조 ). 열거하는 동안 요소를 하나씩 생성하는 열거 가능 항목을 스트림이라고합니다. 예를 들어, Elixir의 &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 는 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="4d05b9a39a36694d426084ba23a5f9e69c3f3e62" translate="yes" xml:space="preserve">
          <source>Streams are lazy, composable enumerables.</source>
          <target state="translated">스트림은 게으르고 구성 가능한 열거 형입니다.</target>
        </trans-unit>
        <trans-unit id="712809970aa25b88c8417d13c741aaaed8cdc5c7" translate="yes" xml:space="preserve">
          <source>Streams the enumerable in chunks, containing &lt;code&gt;count&lt;/code&gt; elements each, where each new chunk starts &lt;code&gt;step&lt;/code&gt; elements into the enumerable.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 요소를 포함하는 열거 가능한 청크를 스트림으로 스트리밍합니다 . 여기서 각 새 청크는 &lt;code&gt;step&lt;/code&gt; 요소를 열거 가능으로 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="c3766632b158ff372c632bd5e459fa938b757447" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;and&quot; operator.</source>
          <target state="translated">엄격한 부울 &quot;and&quot;연산자.</target>
        </trans-unit>
        <trans-unit id="a5a9a0e0f16ce8cccca691f5a88a387331ed3a60" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;not&quot; operator.</source>
          <target state="translated">엄격하게 부울 &quot;not&quot;연산자입니다.</target>
        </trans-unit>
        <trans-unit id="307c1d3f27f897db66810f52b5d24b80983a2d95" translate="yes" xml:space="preserve">
          <source>Strictly boolean &quot;or&quot; operator.</source>
          <target state="translated">엄격한 부울 &quot;or&quot;연산자.</target>
        </trans-unit>
        <trans-unit id="1134f2ebe54abc3c1e5e36f6931e4a7294126534" translate="yes" xml:space="preserve">
          <source>Strictly equal to operator.</source>
          <target state="translated">연산자와 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="30cf2e475f38e7c13632c86b9147ef4d7d19d6a3" translate="yes" xml:space="preserve">
          <source>Strictly not equal to operator.</source>
          <target state="translated">연산자와 완전히 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="642ccf43dc1d6fbbbae9dcb9d0b32837c15cd30f" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists use the lists concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">문자열 (이진) 연결은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자를 사용하지만 문자 목록은 목록 연결 연산자 &lt;code&gt;++&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7b412c0d58e5e7ad2aecfd7b3150626c2d9ea814" translate="yes" xml:space="preserve">
          <source>String (binary) concatenation uses the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator but charlists, being lists, use the list concatenation operator &lt;code&gt;++&lt;/code&gt;:</source>
          <target state="translated">문자열 (이진) 연결은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 연산자를 사용하지만 목록 인 문자 목록은 목록 연결 연산자를 사용합니다. &lt;code&gt;++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83229f3ff8f7ea7a043154af3b38efd4909e3589" translate="yes" xml:space="preserve">
          <source>String and binary operations</source>
          <target state="translated">문자열 및 이진 연산</target>
        </trans-unit>
        <trans-unit id="bd850015d8baaaed30b4f3d5a9c9529f30dc8015" translate="yes" xml:space="preserve">
          <source>String concatenation is done with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">문자열 연결은 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d89992e6bf13c0c402335f758d9be996e2e01c23" translate="yes" xml:space="preserve">
          <source>String.Chars</source>
          <target state="translated">String.Chars</target>
        </trans-unit>
        <trans-unit id="34301512f5868a1de9803c4f3410c31c2c126816" translate="yes" xml:space="preserve">
          <source>String.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">String.Chars &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1c5c736c504b053727fd9efef0379fa8c75be99f" translate="yes" xml:space="preserve">
          <source>String.Chars.t (0)</source>
          <target state="translated">String.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="53d34343625f2871cea1abc24cdb3f39da79c324" translate="yes" xml:space="preserve">
          <source>String.Chars.to_string (1)</source>
          <target state="translated">String.Chars.to_string (1)</target>
        </trans-unit>
        <trans-unit id="71b9f81312a912f581ac74b4c41e1dabf6deb89c" translate="yes" xml:space="preserve">
          <source>StringIO</source>
          <target state="translated">StringIO</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="4e070c4fd19657d532bad6b50d3c0bc3ada85afa" translate="yes" xml:space="preserve">
          <source>Strings are always represented as themselves in the AST.</source>
          <target state="translated">문자열은 항상 AST에서 자체로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9189545cce6b22534b68d2a8c78d66e2e097a67a" translate="yes" xml:space="preserve">
          <source>Strings can have line breaks in them. You can introduce them using escape sequences:</source>
          <target state="translated">문자열에는 줄 바꿈이있을 수 있습니다. 이스케이프 시퀀스를 사용하여 소개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d0eb9bbaa9223ef9b42ad1496081c266e99b1dd" translate="yes" xml:space="preserve">
          <source>Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the &lt;code&gt;#{}&lt;/code&gt; syntax:</source>
          <target state="translated">Elixir의 문자열은 보간도 지원합니다. 이렇게하면 &lt;code&gt;#{}&lt;/code&gt; 를 사용하여 문자열 중간에 값을 배치 할 수 있습니다. 구문 .</target>
        </trans-unit>
        <trans-unit id="ca18cb73f9036b31075a45d8b8797d8a39e4a864" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are UTF-8 encoded binaries.</source>
          <target state="translated">Elixir의 문자열은 UTF-8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="04815a1192ce7e3ea77d99b96198de07fc1d57e2" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as &lt;code&gt;&quot;hello&quot;&lt;/code&gt; and &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt;.</source>
          <target state="translated">Elixir의 문자열은 유니 코드 문자의 시퀀스이며 일반적으로 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;h&amp;eacute;ll&amp;ograve;&quot;&lt;/code&gt; 와 같이 큰 따옴표로 묶인 문자열 사이에 작성됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="ca38f6c1fbddaf28313e82e08e3bdd20ed71adb5" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are delimited by double quotes, and they are encoded in UTF-8:</source>
          <target state="translated">Elixir의 문자열은 큰 따옴표로 구분되며 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="956ce6bc8b8fc3893f30f39eeac47f3c2031a779" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by binaries which are sequences of bytes:</source>
          <target state="translated">Elixir의 문자열은 바이트 시퀀스 인 이진으로 내부적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="06c215a72c89446e5cfff5f5e5552a7f7dfcebc0" translate="yes" xml:space="preserve">
          <source>Strings in Elixir are represented internally by contiguous sequences of bytes known as binaries:</source>
          <target state="translated">Elixir의 문자열은 내부적으로 바이너리로 알려진 연속적인 바이트 시퀀스로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="949492a01a0acbead6a5b64c79b3a5208d1fa196" translate="yes" xml:space="preserve">
          <source>Strings, char lists, and word lists sigils</source>
          <target state="translated">문자열, 문자 목록 및 단어 목록시길</target>
        </trans-unit>
        <trans-unit id="b1b0c17e89281d54da848221c3d7d64fce387af1" translate="yes" xml:space="preserve">
          <source>Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input</source>
          <target state="translated">현, 캐릭터리스트, 원자 및시길은 그대로 유지됩니다. 어떤 문자도 자동으로 이스케이프되거나 이스케이프되지 않습니다. 구분 기호의 선택은 입력에서 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="5f59a80be2040336e52379484730e3abaf9c3bdf" translate="yes" xml:space="preserve">
          <source>Strips a beam file for a release.</source>
          <target state="translated">릴리즈를 위해 빔 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a4ab848fe5c4b2e5f638f279c7f13cc481bac6da" translate="yes" xml:space="preserve">
          <source>Struct</source>
          <target state="translated">Struct</target>
        </trans-unit>
        <trans-unit id="21e310386df8cb3491068257a8769c52dadb5d7d" translate="yes" xml:space="preserve">
          <source>Struct fields are evaluated at compile-time, which allows them to be dynamic. In the example below, &lt;code&gt;10 + 11&lt;/code&gt; is evaluated at compile-time and the age field is stored with value &lt;code&gt;21&lt;/code&gt;:</source>
          <target state="translated">구조 필드는 컴파일 타임에 평가되므로 동적 일 수 있습니다. 아래 예제에서 &lt;code&gt;10 + 11&lt;/code&gt; 은 컴파일 타임에 평가되고 age 필드는 &lt;code&gt;21&lt;/code&gt; 값으로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="66b9bcf6fa135918752a0ac296373b9fc45c7435" translate="yes" xml:space="preserve">
          <source>Structs</source>
          <target state="translated">Structs</target>
        </trans-unit>
        <trans-unit id="e48092358ab469205143fa60ac35c7155aef2e05" translate="yes" xml:space="preserve">
          <source>Structs (see below)</source>
          <target state="translated">구조 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="1fa66ef16d007913d84111c1caa8d36201a759a2" translate="yes" xml:space="preserve">
          <source>Structs alongside protocols provide one of the most important features for Elixir developers: data polymorphism. That&amp;rsquo;s what we will explore in the next chapter.</source>
          <target state="translated">프로토콜과 함께 Structs는 Elixir 개발자에게 가장 중요한 기능 중 하나 인 데이터 다형성입니다. 이것이 다음 장에서 살펴볼 내용입니다.</target>
        </trans-unit>
        <trans-unit id="906ed9113d865df8c36d98027adb8b4c438462a1" translate="yes" xml:space="preserve">
          <source>Structs also allow pattern matching on the struct name:</source>
          <target state="translated">구조체는 구조체 이름에서 패턴 일치를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="403a81b60bd1b9d08b2aba9ce6f1c1e83a0ae9bd" translate="yes" xml:space="preserve">
          <source>Structs are bare maps underneath</source>
          <target state="translated">Structs는 맨 아래에있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ef8a5b2279bd1fda0dd17b3e4b37d53f5cabffc3" translate="yes" xml:space="preserve">
          <source>Structs are extensions built on top of maps that provide compile-time checks and default values.</source>
          <target state="translated">Structs는 컴파일 타임 확인 및 기본값을 제공하는 맵 위에 빌드 된 확장입니다.</target>
        </trans-unit>
        <trans-unit id="b2f574270028afc6da451166304e7163b0e325d1" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">구조체는 일반적으로 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; 로&lt;/a&gt; 정의됩니다. 매크로로 .</target>
        </trans-unit>
        <trans-unit id="57a5690039bdfaa887691c076af282fbfcd1e385" translate="yes" xml:space="preserve">
          <source>Structs are usually defined with the &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;Kernel.defstruct/1&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Structs는 일반적으로 &lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;Kernel.defstruct/1&lt;/code&gt; &lt;/a&gt; 매크로로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="abdab30b78e5e45d65ba3227273c7089180b1f6f" translate="yes" xml:space="preserve">
          <source>Structs built on the map syntax by passing the struct name between &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;{&lt;/code&gt;. For example, &lt;code&gt;%User{...}&lt;/code&gt;.</source>
          <target state="translated">구조체 이름을 &lt;code&gt;%&lt;/code&gt; 와 &lt;code&gt;{&lt;/code&gt; 사이에 전달하여 맵 구문을 기반으로하는 구조 입니다. 예를 들어 &lt;code&gt;%User{...}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ce56958d9176de03025283b3099e3721e59a8eb" translate="yes" xml:space="preserve">
          <source>Structs can also be used in pattern matching, both for matching on the value of specific keys as well as for ensuring that the matching value is a struct of the same type as the matched value.</source>
          <target state="translated">Structs는 특정 키의 값에 대한 일치와 일치하는 값이 일치하는 값과 동일한 유형의 구조 체인지 확인하기 위해 패턴 일치에 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="627a64dfd0ce65d3cdca0e3adc12f995862ee10f" translate="yes" xml:space="preserve">
          <source>Structs provide &lt;em&gt;compile-time&lt;/em&gt; guarantees that only the fields (and &lt;em&gt;all&lt;/em&gt; of them) defined through &lt;code&gt;defstruct&lt;/code&gt; will be allowed to exist in a struct:</source>
          <target state="translated">Structs는 &lt;code&gt;defstruct&lt;/code&gt; 를 통해 정의 된 필드와 &lt;em&gt;모든&lt;/em&gt; 필드 만 구조체 에 존재할 수 있도록 &lt;em&gt;컴파일 타임을&lt;/em&gt; 보장합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9a421e5ee413973974fb1a4739a9e94164f81b8a" translate="yes" xml:space="preserve">
          <source>Structs take the name of the module they&amp;rsquo;re defined in. In the example above, we defined a struct named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Structs는 자신이 정의한 모듈의 이름을 사용합니다. 위의 예에서는 &lt;code&gt;User&lt;/code&gt; 라는 구조체를 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="4bcfdb993ad07d9903f21c6cf1477e9cf60ca26b" translate="yes" xml:space="preserve">
          <source>Structs whose internal structure is private to the local module (pattern matching them or directly accessing their fields should not be allowed) should use the &lt;code&gt;@opaque&lt;/code&gt; attribute. Structs whose internal structure is public should use &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">내부 구조가 로컬 모듈 전용 인 구조 ( &lt;code&gt;@opaque&lt;/code&gt; 일치하거나 필드에 직접 액세스하는 패턴은 허용되지 않아야 함)는 @opaque 속성을 사용해야 합니다. 내부 구조가 public 인 구조체는 &lt;code&gt;@type&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3fdac6921d89e2c5b2bed6c0d9d18041f744d060" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;datetime2&lt;/code&gt; from &lt;code&gt;datetime1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;datetime2&lt;/code&gt; 에서 &lt;code&gt;datetime1&lt;/code&gt; 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="01f386a46810771df7fb30922411804e63bbb211" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;naive_datetime2&lt;/code&gt; from &lt;code&gt;naive_datetime1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;naive_datetime2&lt;/code&gt; 에서 &lt;code&gt;naive_datetime1&lt;/code&gt; 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="14da215035d163f8d2e9ac00ee5de927b8ce5918" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator (the initial value being the result returned by &lt;code&gt;start_fun&lt;/code&gt;) and it must return a tuple containing a list of elements to be emitted and the next accumulator. The enumeration finishes if it returns &lt;code&gt;{:halt, acc}&lt;/code&gt;.</source>
          <target state="translated">연속적인 값은 이전 누적 기 ( &lt;code&gt;start_fun&lt;/code&gt; 에 의해 리턴 된 결과 인 초기 값)로 &lt;code&gt;next_fun&lt;/code&gt; 을 호출하여 생성되며 방출 될 요소 목록과 다음 누적 기를 포함하는 튜플을 리턴해야합니다. &lt;code&gt;{:halt, acc}&lt;/code&gt; 리턴하면 열거가 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="522311cdcaf7b3267814d3b09a19e47dea3c8a0f" translate="yes" xml:space="preserve">
          <source>Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; with the previous accumulator and it must return a tuple with the current value and next accumulator. The enumeration finishes if it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">연속적인 값은 이전 누산기로 &lt;code&gt;next_fun&lt;/code&gt; 을 호출하여 생성되며 현재 값과 다음 누산기가있는 튜플을 반환해야합니다. &lt;code&gt;nil&lt;/code&gt; 을 반환하면 열거가 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec0597f1e250ca1cd4f549ebe479656572bafdd1" translate="yes" xml:space="preserve">
          <source>Such a guard would look like this:</source>
          <target state="translated">이러한 경비원은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53658e37fb70788364f35c3ef3e5d3ef21ca3b29" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">이러한 함수 호출은 범위의 크기에 관계없이 메모리 방식으로 효율적입니다. &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜 의 구현은 엔드 포인트만을 기반으로하는 논리를 사용하며 전체 정수 목록을 구체화하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="966ec8ae3fe9132ccbf00f8e3b57331123098390" translate="yes" xml:space="preserve">
          <source>Such function calls are efficient memory-wise no matter the size of the range. The implementation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol uses logic based solely on the endpoints and does not materialize the whole list of integers.</source>
          <target state="translated">이러한 함수 호출은 범위의 크기에 관계없이 메모리 측면에서 효율적입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜 의 구현은 끝점만을 기반으로하는 논리를 사용하며 전체 정수 목록을 구체화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="413448cc1d1e59d4180a2c1df46d6b20fc8b2386" translate="yes" xml:space="preserve">
          <source>Such is also useful when using update functions, allowing us to introduce values as we traverse the data structure for updates:</source>
          <target state="translated">업데이트 기능을 사용할 때도 유용하며 업데이트를 위해 데이터 구조를 탐색 할 때 값을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c8c931aa883a1710a5641257d627e0b793426c" translate="yes" xml:space="preserve">
          <source>Such is possible for duplicate registries though:</source>
          <target state="translated">다음과 같은 경우에는 중복 레지스트리에서 가능합니다.</target>
        </trans-unit>
        <trans-unit id="af0451134f60a76766f000f3339e06b3c7fb942b" translate="yes" xml:space="preserve">
          <source>Suffix matches (&lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt;) are not valid patterns.</source>
          <target state="translated">접미사 일치 ( &lt;code&gt;hello &amp;lt;&amp;gt; &quot; world&quot;&lt;/code&gt; )는 유효한 패턴이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9413f829dc8a9eeac79634a8fecd1c1711b00407" translate="yes" xml:space="preserve">
          <source>Summing up</source>
          <target state="translated">합산</target>
        </trans-unit>
        <trans-unit id="008681d0cf389abc8327426047cec2a8b18317d8" translate="yes" xml:space="preserve">
          <source>Supervised tasks</source>
          <target state="translated">감독 업무</target>
        </trans-unit>
        <trans-unit id="908fa8f422bcf3bb9ccc6611b5129caf568648d9" translate="yes" xml:space="preserve">
          <source>Supervision trees</source>
          <target state="translated">감독 나무</target>
        </trans-unit>
        <trans-unit id="2cd4fa195ed5b220930149c31cc72fbb131921db" translate="yes" xml:space="preserve">
          <source>Supervisor</source>
          <target state="translated">Supervisor</target>
        </trans-unit>
        <trans-unit id="e1ea02d7a77e7dff85d3adb88e64fc729ba83f91" translate="yes" xml:space="preserve">
          <source>Supervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">감독자 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d69abd18d455510b99f3ff0e898ca02a3c32b696" translate="yes" xml:space="preserve">
          <source>Supervisor and Application</source>
          <target state="translated">감독자와 신청</target>
        </trans-unit>
        <trans-unit id="def06f454fe2aafd60e9bf9113ffca345eac503e" translate="yes" xml:space="preserve">
          <source>Supervisor and GenServers</source>
          <target state="translated">감독자와 GenServer</target>
        </trans-unit>
        <trans-unit id="12010eabcaf19b4380edc62ef8ef7afae10e6caa" translate="yes" xml:space="preserve">
          <source>Supervisor and worker options</source>
          <target state="translated">감독자 및 근로자 옵션</target>
        </trans-unit>
        <trans-unit id="ef948fc60b8d6995f73a05206917fcdf6cd81c08" translate="yes" xml:space="preserve">
          <source>Supervisor.Spec</source>
          <target state="translated">Supervisor.Spec</target>
        </trans-unit>
        <trans-unit id="fb7cc714ff3123e658f82813b47d9835dd16af4d" translate="yes" xml:space="preserve">
          <source>Supervisors support different strategies; in the example above, we have chosen &lt;code&gt;:one_for_one&lt;/code&gt;. Furthermore, each supervisor can have many workers and/or supervisors as children, with each one having its own configuration (as outlined in the &quot;Child specification&quot; section).</source>
          <target state="translated">감독자는 다양한 전략을 지원합니다. 위의 예에서는 &lt;code&gt;:one_for_one&lt;/code&gt; 을 선택 했습니다 . 더욱이, 각 감독 당국은 다수의 근로자 및 / 또는 감독 당국을 자녀로 가질 수 있으며, 각각의 구성 요소는 자체 구성을 갖습니다 ( &quot;자식 지정&quot;섹션에 설명 된대로).</target>
        </trans-unit>
        <trans-unit id="0578994f188280cb99013a5c58ec4c81802bfe88" translate="yes" xml:space="preserve">
          <source>Supervisors support different supervision strategies (through the &lt;code&gt;:strategy&lt;/code&gt; option, as seen above):</source>
          <target state="translated">감독자는 다양한 감독 전략을 지원합니다 ( 위 의 &lt;code&gt;:strategy&lt;/code&gt; 옵션을 통해 ).</target>
        </trans-unit>
        <trans-unit id="f32d5a3b17e614297417cc279a7ec1cd02274d65" translate="yes" xml:space="preserve">
          <source>Support</source>
          <target state="translated">Support</target>
        </trans-unit>
        <trans-unit id="e6e1e0cd205858fc9432c841e89bbd6483ce3fe6" translate="yes" xml:space="preserve">
          <source>Support for making &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;private functions&lt;/a&gt; overridable</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defp/2&quot;&gt;개인 기능을&lt;/a&gt; 재정의 할 수 있도록 지원</target>
        </trans-unit>
        <trans-unit id="a4eab47f32a482fa6a57e7d78931eebd65984bbe" translate="yes" xml:space="preserve">
          <source>Support for making private functions overridable</source>
          <target state="translated">개인 기능을 재정의 할 수 있도록 지원</target>
        </trans-unit>
        <trans-unit id="6afec07b7fa976af6cf8797ee913469e9babea8a" translate="yes" xml:space="preserve">
          <source>Supported Erlang/OTP versions</source>
          <target state="translated">지원되는 Erlang / OTP 버전</target>
        </trans-unit>
        <trans-unit id="cc98180ca761a9afbf85fc26a48b02b6e25dbae6" translate="yes" xml:space="preserve">
          <source>Supported ID values</source>
          <target state="translated">지원되는 ID 값</target>
        </trans-unit>
        <trans-unit id="59b7fd869e912d97d97078bf118935bf508cd7dc" translate="yes" xml:space="preserve">
          <source>Supported module values</source>
          <target state="translated">지원되는 모듈 값</target>
        </trans-unit>
        <trans-unit id="4ce9ab2c76a64f3bead6b697086605679c05ba0b" translate="yes" xml:space="preserve">
          <source>Supported restart values</source>
          <target state="translated">지원되는 재시작 값</target>
        </trans-unit>
        <trans-unit id="4754143afdbe77546c223d10dd545bf29beec5ec" translate="yes" xml:space="preserve">
          <source>Supported shutdown values</source>
          <target state="translated">지원되는 종료 값</target>
        </trans-unit>
        <trans-unit id="556737ead8feb164936eb5c9d04fdbaa68615120" translate="yes" xml:space="preserve">
          <source>Supported strategies</source>
          <target state="translated">지원되는 전략</target>
        </trans-unit>
        <trans-unit id="011f076c3d846af2a7296431ecd45f9d0d9ceba4" translate="yes" xml:space="preserve">
          <source>Supported worker values</source>
          <target state="translated">지원되는 근로자 가치</target>
        </trans-unit>
        <trans-unit id="b1ffd261b167462587f7afeaf76db355c7359f62" translate="yes" xml:space="preserve">
          <source>Supporting documents</source>
          <target state="translated">증빙 서류</target>
        </trans-unit>
        <trans-unit id="5074c54fe3d2dada9edf83c0782274a9de618a17" translate="yes" xml:space="preserve">
          <source>Supports multiple backends which are automatically supervised when plugged into &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 에&lt;/a&gt; 연결하면 자동으로 감독되는 여러 백엔드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="63b71cb9682231a38f6cb8bfe3190bb22abb9ee8" translate="yes" xml:space="preserve">
          <source>Switch definitions</source>
          <target state="translated">스위치 정의</target>
        </trans-unit>
        <trans-unit id="3b07b3e7fad246aad851785b8640c09bc790a0c6" translate="yes" xml:space="preserve">
          <source>Switches can be specified via one of two options:</source>
          <target state="translated">스위치는 다음 두 옵션 중 하나를 통해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10f820ab2456db02149e31f2047f0b2fc4844076" translate="yes" xml:space="preserve">
          <source>Switches can be specified with modifiers, which change how they behave. The following modifiers are supported:</source>
          <target state="translated">스위치는 작동 방식을 변경하는 수정자를 사용하여 지정할 수 있습니다. 다음 수정자가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="76095f9f5c83633412d257a75ee9b301147d2861" translate="yes" xml:space="preserve">
          <source>Switches followed by a value will be assigned the value, as a string. Switches without an argument will be set automatically to &lt;code&gt;true&lt;/code&gt;. Since we cannot assert the type of the switch value, it is preferred to use the &lt;code&gt;:strict&lt;/code&gt; option that accepts only known switches and always verify their types.</source>
          <target state="translated">스위치 뒤에 값이 오는 경우 값이 문자열로 할당됩니다. 인수가없는 스위치는 자동으로 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 . 스위치 값의 유형을 지정할 수 없으므로 알려진 스위치 만 허용하고 항상 유형을 확인 하는 &lt;code&gt;:strict&lt;/code&gt; 옵션 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5845d5880bc5d8b451e5a4dd803aa622305d25f1" translate="yes" xml:space="preserve">
          <source>Switches parsed by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt; may take zero or one arguments.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; 로&lt;/a&gt; 구문 분석 된 스위치 는 0 개 또는 1 개의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3687a859d3cbb75ed3b6669b03cb32119eb5e843" translate="yes" xml:space="preserve">
          <source>Synchronously stops the agent with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;reason&lt;/code&gt; 에이전트를 동 기적으로 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="83e327b0ee0a0791c10736b6ce6e0977e644efa8" translate="yes" xml:space="preserve">
          <source>Synchronously stops the given supervisor with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;reason&lt;/code&gt; 지정된 감독자를 동 기적으로 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="20daca0170b9cf17db723aa618e07ac24ddb1612" translate="yes" xml:space="preserve">
          <source>Synchronously stops the server with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;reason&lt;/code&gt; 서버를 동기식으로 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="f6ceae4e1810d086bda09a8ac74e9e1fae98d4f4" translate="yes" xml:space="preserve">
          <source>Syntactic sugar</source>
          <target state="translated">구문 설탕</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="8c15a6de8bd57bfcd07b3aef8fb9a4bc8f26c05e" translate="yes" xml:space="preserve">
          <source>Syntax reference</source>
          <target state="translated">구문 참조</target>
        </trans-unit>
        <trans-unit id="de4af2ff6c0bd31526ce7f5f8ca08783d0cc5ed7" translate="yes" xml:space="preserve">
          <source>SyntaxError</source>
          <target state="translated">SyntaxError</target>
        </trans-unit>
        <trans-unit id="62e61480537cef04396517bf21f00631d5916b00" translate="yes" xml:space="preserve">
          <source>SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SyntaxError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="15a3c2ea878a67e7f83b1e5350d3a1c397e6870e" translate="yes" xml:space="preserve">
          <source>System messages such as timer messages and monitoring events</source>
          <target state="translated">타이머 메시지 및 모니터링 이벤트와 같은 시스템 메시지</target>
        </trans-unit>
        <trans-unit id="629539f2b0b3c31f1b5b674c293fc529369d30a0" translate="yes" xml:space="preserve">
          <source>System modules</source>
          <target state="translated">시스템 모듈</target>
        </trans-unit>
        <trans-unit id="e1f03c30c4ad532e4c164e6bd797580a623de00e" translate="yes" xml:space="preserve">
          <source>SystemLimitError</source>
          <target state="translated">SystemLimitError</target>
        </trans-unit>
        <trans-unit id="87d2f1faf999bf62e28a61deae6996346ba925b4" translate="yes" xml:space="preserve">
          <source>SystemLimitError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">SystemLimitError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="34fe46e18f0db15e3602c13218d0d43606ec62eb" translate="yes" xml:space="preserve">
          <source>Table of deprecations</source>
          <target state="translated">지원 중단 표</target>
        </trans-unit>
        <trans-unit id="848eed0fbd5429f556b2982dec3ea87136e33e44" translate="yes" xml:space="preserve">
          <source>Tags</source>
          <target state="translated">Tags</target>
        </trans-unit>
        <trans-unit id="b6178fb349e0b28eda375aea2c569cd350dc4da1" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;exunit.casetemplate&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">태그는 사례 템플릿 ( &lt;a href=&quot;exunit.casetemplate&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt; ) 과 함께 사용하면 사례 템플릿의 콜백을 통해 테스트 동작을 사용자 정의 할 수있어 매우 효과적 입니다.</target>
        </trans-unit>
        <trans-unit id="1e98eca58b343bf9eef58db2b4d0749342e87444" translate="yes" xml:space="preserve">
          <source>Tags are also very effective when used with case templates (&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt;&lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt;&lt;/a&gt;) allowing callbacks in the case template to customize the test behaviour.</source>
          <target state="translated">태그는 케이스 템플릿 ( &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html&quot;&gt; &lt;code&gt;ExUnit.CaseTemplate&lt;/code&gt; &lt;/a&gt; ) 과 함께 사용할 때도 매우 효과적 이므로 케이스 템플릿의 콜백을 통해 테스트 동작을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc249ccb61119dc450a78be8a81ac2c8c0e49629" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;exunit#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">태그를 사용하여 특정 테스트를 식별 할 수도 있습니다. 그런 다음 필터를 사용하여 포함하거나 제외 할 수 있습니다. 가장 일반적인 기능은 &lt;a href=&quot;exunit#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; 을&lt;/a&gt; 통해 수행 할 수있는 특정 테스트를 제외하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="fbe21cac3f1b836469722d6aaccceafc7c70d983" translate="yes" xml:space="preserve">
          <source>Tags can also be used to identify specific tests, which can then be included or excluded using filters. The most common functionality is to exclude some particular tests from running, which can be done via &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">태그를 사용하여 특정 테스트를 식별 한 다음 필터를 사용하여 포함하거나 제외 할 수도 있습니다. 가장 일반적인 기능은 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; 을&lt;/a&gt; 통해 수행 할 수있는 일부 특정 테스트를 실행에서 제외하는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="8b6e5fd9a74ed5f0c910db816652873cf2d30599" translate="yes" xml:space="preserve">
          <source>Tags in ExUnit are used to annotate tests. Tags can be later used to filter tests. For example, you can avoid running external tests on your machine because they are slow and dependent on other services, while they can still be enabled in your build system.</source>
          <target state="translated">ExUnit의 태그는 테스트에 주석을 달기 위해 사용됩니다. 태그는 나중에 테스트를 필터링하는 데 사용될 수 있습니다. 예를 들어, 시스템에서 외부 테스트가 느리고 다른 서비스에 의존하기 때문에 빌드 시스템에서 계속 활성화 할 수 있으므로 외부 테스트를 실행하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="001aa408e4c6ef94853eea6d535dd0cd3f2d9ecb" translate="yes" xml:space="preserve">
          <source>Take note of the second argument to &lt;code&gt;Macro.var/2&lt;/code&gt;. This is the context being used and will determine hygiene as described in the next section.</source>
          <target state="translated">&lt;code&gt;Macro.var/2&lt;/code&gt; 의 두 번째 인수를 기록해 두십시오 . 이것이 사용되는 상황이며 다음 섹션에 설명 된대로 위생을 결정할 것입니다.</target>
        </trans-unit>
        <trans-unit id="396cb525a863762a0153f155bab5fa14c60b4b53" translate="yes" xml:space="preserve">
          <source>Take such cases as a suggestion that your code should be refactored:</source>
          <target state="translated">코드를 리팩터링해야한다고 제안하는 경우를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0ec41530414c8186f413ef6553a9627c2edc74fd" translate="yes" xml:space="preserve">
          <source>Take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="translated">다음 &lt;code&gt;.iex.exs&lt;/code&gt; 파일을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3272b9a706ed0ca47f559e862d6dc2150998b033" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;count&lt;/code&gt; random elements from &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">걸립니다 &lt;code&gt;count&lt;/code&gt; 에서 임의 요소 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff00a34c033bd6b414639eb45fc22dcd00b26ff3" translate="yes" xml:space="preserve">
          <source>Takes a compiled format and injects the level, timestamp, message, and metadata keyword list and returns a properly formatted string.</source>
          <target state="translated">컴파일 된 형식을 취해 레벨, 타임 스탬프, 메시지 및 메타 데이터 키워드 목록을 삽입하고 올바른 형식의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc0be3a7f7029dd2d434cb9dc499906bd7070ad7" translate="yes" xml:space="preserve">
          <source>Takes a time zone name and a point in time for UTC and returns a &lt;code&gt;time_zone_period&lt;/code&gt; for that point in time.</source>
          <target state="translated">UTC의 시간대 이름과 특정 시점을 가져 &lt;code&gt;time_zone_period&lt;/code&gt; 해당 시점 의 time_zone_period 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="108613966b46cb41abd8d09ea8bc76b57d639cc0" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given &lt;code&gt;keys&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and extracts them into a separate map.</source>
          <target state="translated">주어진 &lt;code&gt;keys&lt;/code&gt; 에 해당하는 모든 항목 을 &lt;code&gt;map&lt;/code&gt; 에서 가져 와서 별도의 맵으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a057f41d143426d964dc91f467aeae07be4b8c88" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and extracts them into a separate keyword list.</source>
          <target state="translated">주어진 키에 해당하는 모든 항목을 가져 와서 별도의 키워드 목록으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="22f2fcc0cd4b387311cd745e5116cafb06152b07" translate="yes" xml:space="preserve">
          <source>Takes all entries corresponding to the given keys and returns them in a new keyword list.</source>
          <target state="translated">주어진 키에 해당하는 모든 항목을 가져 와서 새 키워드 목록으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f01e74291caa1b3fb31a76131a0358dad5dd2b3a" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;amount&lt;/code&gt; of elements from the beginning or the end of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">걸린다 &lt;code&gt;amount&lt;/code&gt; 시작 또는 끝에서 요소들의 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1f6557000f60347445111652f8c88ca3309153" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (e.g., a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 요소로 된 튜플 목록 (예 :지도 또는 키워드 목록)으로 열거하고 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 형식의 문자열을 반환하는 열거 형을 가져옵니다 . 여기서 키와 값은 &lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa8eb6bc5f76dd6add111a9e6f96763d7be8a60" translate="yes" xml:space="preserve">
          <source>Takes an enumerable that enumerates as a list of two-element tuples (for instance, a map or a keyword list) and returns a string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; where keys and values are URL encoded as per &lt;a href=&quot;#encode_www_form/1&quot;&gt;&lt;code&gt;encode_www_form/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소가 두 개인 튜플 (예 : 맵 또는 키워드 목록) 목록으로 열거되는 열거 형을 취하고 &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 형식의 문자열을 반환합니다 . 여기서 키와 값은 &lt;a href=&quot;#encode_www_form/1&quot;&gt; &lt;code&gt;encode_www_form/1&lt;/code&gt; &lt;/a&gt; 따라 URL 인코딩됩니다. / 1 .</target>
        </trans-unit>
        <trans-unit id="e45acfd4331b2440feb53de6fbc1560baa366e61" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;character_limit&lt;/code&gt; as a second argument. If &lt;code&gt;character_limit&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, this function will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;character_limit&lt;/code&gt; 를 두 번째 인수로 사용합니다. 경우 &lt;code&gt;character_limit&lt;/code&gt; 있다 &lt;code&gt;0&lt;/code&gt; ,이 함수는 반환됩니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feadb0c8e9163376cb17aaa5d080783ed49a3087" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;code&gt;limit&lt;/code&gt; as a second argument. &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt; only checks the printability of the list up to the &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">선택적인 &lt;code&gt;limit&lt;/code&gt; 을 두 번째 인수로 사용합니다. &lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; &lt;/a&gt; 는 목록의 인쇄 가능성을 &lt;code&gt;limit&lt;/code&gt; 까지만 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b31890ea4f4df85c9832a1da5e1e6d04b9bbfbd0" translate="yes" xml:space="preserve">
          <source>Takes changes such as summer time/DST into account. This means that adding time can cause the wall time to &quot;go backwards&quot; during &quot;fall back&quot; during autumn. Adding just a few seconds to a datetime just before &quot;spring forward&quot; can cause wall time to increase by more than an hour.</source>
          <target state="translated">서머 타임 / DST와 같은 변경 사항을 고려합니다. 즉, 시간을 추가하면 가을에 &quot;뒤로&quot;동안 벽 시간이 &quot;뒤로 이동&quot;할 수 있습니다. &quot;스프링 포워드&quot;직전에 날짜 시간에 몇 초를 추가하면 벽 시간이 1 시간 이상 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae8e01301c7e0feb68a23236a2c9b3567e8ae34" translate="yes" xml:space="preserve">
          <source>Takes the elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 는 진실한 가치를 반환 하면서 &lt;code&gt;enumerable&lt;/code&gt; 요소의 시작 부분부터 요소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c5464b7fb8fc4c108c9bf24e8c373a4e9e4044e0" translate="yes" xml:space="preserve">
          <source>Takes the maximum width and a document to print as its arguments and returns an IO data representation of the best layout for the document to fit in the given width.</source>
          <target state="translated">최대 너비와 문서를 인수로 사용하여 주어진 너비에 맞게 문서에 가장 적합한 레이아웃의 IO 데이터 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8282e151892442f9f2cf52b76a916f132d30c0f4" translate="yes" xml:space="preserve">
          <source>Target ABI (for example, musl or gnu)</source>
          <target state="translated">대상 ABI (예 : musl 또는 gnu)</target>
        </trans-unit>
        <trans-unit id="9af45fd9ac96ee8998b351868ee1becb19e802d4" translate="yes" xml:space="preserve">
          <source>Target architecture (for example, x86_64 or ARM)</source>
          <target state="translated">대상 아키텍처 (예 : x86_64 또는 ARM)</target>
        </trans-unit>
        <trans-unit id="8e253f67079c51fc720f2bde4e13e5c23c03b6de" translate="yes" xml:space="preserve">
          <source>Target vendor + operating system (for example, Windows, Linux, or Darwin/macOS)</source>
          <target state="translated">대상 공급 업체 + 운영 체제 (예 : Windows, Linux 또는 Darwin / macOS)</target>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="56913f440f346fedff0613f1a58aff47c8c81efb" translate="yes" xml:space="preserve">
          <source>Task and gen_tcp</source>
          <target state="translated">작업 및 gen_tcp</target>
        </trans-unit>
        <trans-unit id="42d489b854c5dff6b39f3ae727392332235bf30a" translate="yes" xml:space="preserve">
          <source>Task supervisor</source>
          <target state="translated">작업 감독자</target>
        </trans-unit>
        <trans-unit id="0590ada27ec6762e406a036264c8d3a5f2c7e027" translate="yes" xml:space="preserve">
          <source>Task-specific options</source>
          <target state="translated">작업 별 옵션</target>
        </trans-unit>
        <trans-unit id="35a08efc9d440da7708c69812b0507ba330ba97d" translate="yes" xml:space="preserve">
          <source>Task.Supervisor</source>
          <target state="translated">Task.Supervisor</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="ba00cfab602d1779b811d576baf5eafe077e7cab" translate="yes" xml:space="preserve">
          <source>Tasks are processes meant to execute one particular action throughout their lifetime, often with little or no communication with other processes. The most common use case for tasks is to convert sequential code into concurrent code by computing a value asynchronously:</source>
          <target state="translated">작업은 일생 동안 하나의 특정 작업을 실행하기위한 프로세스로, 종종 다른 프로세스와의 통신이 거의 또는 전혀 없습니다. 가장 일반적인 작업 사용 사례는 값을 비동기 적으로 계산하여 순차 코드를 동시 코드로 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a0db3194d6f9d766302e10355f2237684a84453" translate="yes" xml:space="preserve">
          <source>Tasks are what make Mix extensible.</source>
          <target state="translated">작업은 믹스를 확장 가능하게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a520f228dee983c80456da705995e99d0baf055b" translate="yes" xml:space="preserve">
          <source>Tasks build on top of the spawn functions to provide better error reports and introspection:</source>
          <target state="translated">더 나은 오류 보고서 및 내부 검사를 제공하기 위해 작업이 스폰 기능 위에 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="0d54343e18426db24d51d0ad44751f910be12ca3" translate="yes" xml:space="preserve">
          <source>Tasks spawned with &lt;code&gt;async&lt;/code&gt; can be awaited on by their caller process (and only their caller) as shown in the example above. They are implemented by spawning a process that sends a message to the caller once the given computation is performed.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 생성 된 작업은 위의 예와 같이 호출자 프로세스 (및 호출자 만)에 의해 대기 될 수 있습니다. 주어진 계산이 수행되면 호출자에게 메시지를 보내는 프로세스를 생성하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f19715ca7223bd4e0d3fbc34df5b7dcc7380e790" translate="yes" xml:space="preserve">
          <source>Tasks typically depend on the &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; task, when they need to access code from the current project with all apps already configured, or the &quot;app.start&quot; task, when they also need those apps to be already started:</source>
          <target state="translated">작업은 일반적으로 &lt;code&gt;&quot;app.config&quot;&lt;/code&gt; 에 따라 다릅니다. 모든 앱이 이미 구성된 현재 프로젝트의 코드에 액세스해야하는 경우 작업 해당 앱을 이미 시작해야하는 경우에는 &quot;app.start&quot;작업에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b4b058a048fc58f7cc9589f239b42e939508324" translate="yes" xml:space="preserve">
          <source>Techniques</source>
          <target state="translated">Techniques</target>
        </trans-unit>
        <trans-unit id="f36d34a8fff232dc61a718546ef8daf864665507" translate="yes" xml:space="preserve">
          <source>Tells whether the given process is alive on the local node.</source>
          <target state="translated">주어진 프로세스가 로컬 노드에 존재하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3c899cc5439be26f0cd7b582a42447cf769aca66" translate="yes" xml:space="preserve">
          <source>Temporarily blocks the current process waiting for a task reply.</source>
          <target state="translated">작업 응답을 기다리는 현재 프로세스를 일시적으로 차단합니다.</target>
        </trans-unit>
        <trans-unit id="d33ebb237e98c8b9d937b2d694b2c125b79ca66f" translate="yes" xml:space="preserve">
          <source>Term ordering</source>
          <target state="translated">학기 주문</target>
        </trans-unit>
        <trans-unit id="696845220c6e0a0d1e64cd82d61908625e60074a" translate="yes" xml:space="preserve">
          <source>Terminate the top-level supervisor.</source>
          <target state="translated">최상위 관리자를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="37c2abf54c623c6250b581aced135fc94e351e86" translate="yes" xml:space="preserve">
          <source>Terminates the Erlang runtime system without properly shutting down applications and ports. Please see &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; for a careful shutdown of the system.</source>
          <target state="translated">응용 프로그램 및 포트를 올바르게 종료하지 않고 Erlang 런타임 시스템을 종료합니다. 시스템을 신중하게 종료 하려면 &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cd2179f3f59774aca5baa2c47c7a727d23960ae" translate="yes" xml:space="preserve">
          <source>Terminates the child with the given &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;pid&lt;/code&gt; 로 아이를 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="c4bb07a1089485a5deadcff889ffd042bd8e458f" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; 로 식별 된 지정된 자식을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="a50fe58f5df366a9be1362e929ebd0084a28443a" translate="yes" xml:space="preserve">
          <source>Terminates the given child identified by &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 로 식별 된 지정된 자식을 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="a202094d471c445107dcaeee3f888512868cbcd8" translate="yes" xml:space="preserve">
          <source>Test filters and tags</source>
          <target state="translated">테스트 필터 및 태그</target>
        </trans-unit>
        <trans-unit id="6259e4e6f0c5acd8366ddcebaae6c7f8a418bd4b" translate="yes" xml:space="preserve">
          <source>Test setup with ExUnit callbacks</source>
          <target state="translated">ExUnit 콜백을 사용한 테스트 설정</target>
        </trans-unit>
        <trans-unit id="56c4fd8cce0fae76b0fc19e67eda41b7a30e0a0f" translate="yes" xml:space="preserve">
          <source>Testing a GenServer</source>
          <target state="translated">GenServer 테스트</target>
        </trans-unit>
        <trans-unit id="788b3affdeae419dc740b3f8cbcd405e20e4cc4b" translate="yes" xml:space="preserve">
          <source>Testing a GenServer is not much different from testing an agent. We will spawn the server on a setup callback and use it throughout our tests. Create a file at &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; with the following:</source>
          <target state="translated">GenServer 테스트는 에이전트 테스트와 크게 다르지 않습니다. 설정 콜백에서 서버를 스폰하고 테스트 전체에서 사용합니다. &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; 에서 다음을 사용하여 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="187e41969f8b9137e679aa44737b6ab5557c6441" translate="yes" xml:space="preserve">
          <source>Tests are first excluded, then included, and then skipped (if any left).</source>
          <target state="translated">테스트는 먼저 제외 된 다음 포함 된 다음 건너 뜁니다 (남은 경우).</target>
        </trans-unit>
        <trans-unit id="85b9fcfc0f6fc72610f7a98efec365df258038e3" translate="yes" xml:space="preserve">
          <source>Tests in umbrella projects can be run from the root by specifying the full suite path, including &lt;code&gt;apps/my_app/test&lt;/code&gt;, in which case recursive tests for other child apps will be skipped completely:</source>
          <target state="translated">&lt;code&gt;apps/my_app/test&lt;/code&gt; 를 포함한 전체 제품군 경로를 지정하여 우산 프로젝트의 테스트를 루트에서 실행할 수 있습니다 .이 경우 다른 하위 앱에 대한 재귀 테스트는 완전히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="c876e9844d9fdc72e6da9216815faacf651f395c" translate="yes" xml:space="preserve">
          <source>Text-based match operator. Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">텍스트 기반 일치 연산자. 상의 용어 일치 &lt;code&gt;left&lt;/code&gt; 상의 정규 표현식 또는 문자열에 대한 &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="062dbf72aa69df4b2bf2e11e396bf97a679fa018" translate="yes" xml:space="preserve">
          <source>Thankfully, Elixir v1.2 introduced the &lt;code&gt;with&lt;/code&gt; construct, which allows you to simplify code like the above, replacing nested &lt;code&gt;case&lt;/code&gt; calls with a chain of matching clauses. Let&amp;rsquo;s rewrite the &lt;code&gt;serve/1&lt;/code&gt; function to use &lt;code&gt;with&lt;/code&gt;:</source>
          <target state="translated">고맙게도 Elixir v1.2에는 &lt;code&gt;with&lt;/code&gt; 구문이 도입되어 위와 같은 코드를 단순화하여 중첩 된 &lt;code&gt;case&lt;/code&gt; 호출을 일치하는 절로 대체 할 수 있습니다 . &lt;code&gt;serve/1&lt;/code&gt; 함수를 다음 &lt;code&gt;with&lt;/code&gt; 같이 다시 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="01e9b39e30c1a0e15112939ef1fff61fe4a3aa75" translate="yes" xml:space="preserve">
          <source>Thanks to the agent server process, the counter can be safely incremented concurrently.</source>
          <target state="translated">에이전트 서버 프로세스 덕분에 카운터를 동시에 안전하게 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb4fefaf1d73585354762c2031b68d75737ffd24" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system.</source>
          <target state="translated">이는 &lt;code&gt;kv_server&lt;/code&gt; 및 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램 과 함께 &lt;code&gt;foo&lt;/code&gt; 라는 릴리스를 정의합니다 . 모드는 &lt;code&gt;:permanent&lt;/code&gt; 로 설정되어 있습니다 . 즉, 해당 애플리케이션이 충돌하면 전체 노드가 종료됩니다. 이러한 응용 프로그램은 우리 시스템에 필수적이기 때문에 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="cdbd4eae22bceef6692b374955bde22d9b7d01d6" translate="yes" xml:space="preserve">
          <source>That defines a release named &lt;code&gt;foo&lt;/code&gt; with both &lt;code&gt;kv_server&lt;/code&gt; and &lt;code&gt;kv&lt;/code&gt; applications. Their mode is set to &lt;code&gt;:permanent&lt;/code&gt;, which means that, if those applications crash, the whole node terminates. That&amp;rsquo;s reasonable since those applications are essential to our system. With the configuration in place, let&amp;rsquo;s give another try at assembling the release:</source>
          <target state="translated">&lt;code&gt;kv_server&lt;/code&gt; 및 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램 을 모두 사용하여 &lt;code&gt;foo&lt;/code&gt; 라는 릴리스를 정의합니다 . 해당 모드는 &lt;code&gt;:permanent&lt;/code&gt; 로 설정되어 있습니다 . 즉, 해당 응용 프로그램이 충돌하면 전체 노드가 종료됩니다. 이러한 응용 프로그램은 시스템에 필수적이므로 합리적입니다. 구성이 완료되면 릴리스를 조립할 때 다시 시도해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c0b2e0d9fe52f84cc809886b734e22953d615efa" translate="yes" xml:space="preserve">
          <source>That ensures that if the task completes after the &lt;code&gt;timeout&lt;/code&gt; but before &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; has been called, you will still get the result, since &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt; is designed to handle this case and return the result.</source>
          <target state="translated">그러면 &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; &lt;code&gt;timeout&lt;/code&gt; 이 종료 되었지만 shutdown / 1 이 호출 되기 전에 작업이 완료된 경우 &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; 이이 경우를 처리하고 결과를 반환하도록 설계되었으므로 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1fc0fd9268067ed50e8dff689947fe93beb5673" translate="yes" xml:space="preserve">
          <source>That happens because the &lt;code&gt;IO&lt;/code&gt; module actually works with processes (see &lt;a href=&quot;processes&quot;&gt;chapter 11&lt;/a&gt;). Given a file is a process, when you write to a file that has been closed, you are actually sending a message to a process which has been terminated:</source>
          <target state="translated">이는 &lt;code&gt;IO&lt;/code&gt; 모듈이 실제로 프로세스와 함께 작동 하기 때문에 발생 합니다 ( &lt;a href=&quot;processes&quot;&gt;11 장&lt;/a&gt; 참조 ). 파일이 프로세스 인 경우 닫은 파일에 쓸 때 실제로 종료 된 프로세스에 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="897c7bf39cdf3d75952cff1b5ff6f99e7827d8f9" translate="yes" xml:space="preserve">
          <source>That is, if the node can be part of a distributed system.</source>
          <target state="translated">즉, 노드가 분산 시스템의 일부일 수있는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="8e363ec1e2d5f0647070623c22f89c8707555da9" translate="yes" xml:space="preserve">
          <source>That is, if the number of bits in &lt;code&gt;bitstring&lt;/code&gt; is not divisible by 8, the resulting number of bytes will be rounded up (by excess). This operation happens in constant time.</source>
          <target state="translated">즉, 비트 &lt;code&gt;bitstring&lt;/code&gt; 비트 수가 8로 나눌 수없는 경우 결과 바이트 수는 반올림됩니다 (초과). 이 작업은 일정한 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="21fbb88b6f851991624fb5b17096150fe0715845" translate="yes" xml:space="preserve">
          <source>That said, there are still cases where using macros and modules to build domain-specific languages is useful. Since we have explored data structures and function definitions in the Getting Started guide, this chapter will explore how to use macros and module attributes to tackle more complex DSLs.</source>
          <target state="translated">그러나 매크로와 모듈을 사용하여 도메인 별 언어를 만드는 것이 여전히 유용한 경우가 있습니다. 시작 안내서에서 데이터 구조 및 기능 정의를 살펴 보았으므로이 장에서는 매크로 및 모듈 속성을 사용하여보다 복잡한 DSL을 처리하는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="814b47f77dfc5a37096b4b03955d625f97a0e859" translate="yes" xml:space="preserve">
          <source>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example:</source>
          <target state="translated">즉, 별칭 노드를 원자로 확장하여 길이를 검색 할 수 있어야합니다. 발신자 별칭도 확장해야하므로 노드 확장은 간단하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d3f07f40965deb2a6bdc254e2fe7db4fac694fb" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because an umbrella project gives us plenty of options when deploying the software. We can:</source>
          <target state="translated">이는 우산 프로젝트가 소프트웨어를 배포 할 때 많은 옵션을 제공하기 때문입니다. 우리는 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="11e8efbea29607bc7f881559616858502e41b031" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because we were expecting data from &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; but the client closed the connection. We need to handle such cases better in future revisions of our server.</source>
          <target state="translated">우리가 &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 에서 데이터를 기대하고 있었지만 클라이언트가 연결을 닫았 기 때문입니다. 향후 서버 개정에서 이러한 경우를 더 잘 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c56715445461f557ef98a6e96f4646be8d6243e" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s enough for our tests to pass but there is a resource leakage in our application. When a bucket terminates, the supervisor will start a new bucket in its place. After all, that&amp;rsquo;s the role of the supervisor!</source>
          <target state="translated">테스트를 통과하기에는 충분하지만 애플리케이션에 리소스가 누출됩니다. 버킷이 종료되면 수퍼바이저가 대신 새 버킷을 시작합니다. 결국, 그것은 감독자의 역할입니다!</target>
        </trans-unit>
        <trans-unit id="b7a0f3e3c150c923165c6e2a99dd197a0a28b7af" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s happening because the release &lt;code&gt;foo&lt;/code&gt; is already listening on port &lt;code&gt;4040&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; is trying to do the same! One option could be to move the &lt;code&gt;:port&lt;/code&gt; configuration to the application environment, like we did for the routing table. But let&amp;rsquo;s try something else. Let&amp;rsquo;s make it so the &lt;code&gt;bar&lt;/code&gt; release contains only the &lt;code&gt;:kv&lt;/code&gt; application. So it works as a storage but it won&amp;rsquo;t have a front-end. Change the &lt;code&gt;:bar&lt;/code&gt; information to this:</source>
          <target state="translated">릴리스 때문에 무슨 일이 일어나고 그 &lt;code&gt;foo&lt;/code&gt; 이미 포트에서 수신 대기 &lt;code&gt;4040&lt;/code&gt; 과 &lt;code&gt;bar&lt;/code&gt; 동일한 작업을 수행하려고! 라우팅 테이블에서와 같이 &lt;code&gt;:port&lt;/code&gt; 구성을 응용 프로그램 환경 으로 이동하는 옵션이 있습니다 . 그러나 다른 것을 시도해 봅시다. &lt;code&gt;bar&lt;/code&gt; 릴리스에 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션 만 포함 되도록하십시오 . 따라서 스토리지로 작동하지만 프런트 엔드는 없습니다. &lt;code&gt;:bar&lt;/code&gt; 정보를 다음 과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="728db93af19ad8ae8e28827f7df6fa0ee95b6c1b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it for the client API. On the server side, we can implement a variety of callbacks to guarantee the server initialization, termination, and handling of requests. Those callbacks are optional and for now, we have only implemented the ones we care about. Let&amp;rsquo;s recap.</source>
          <target state="translated">바로 클라이언트 API입니다. 서버 측에서는 서버 초기화, 종료 및 요청 처리를 보장하기 위해 다양한 콜백을 구현할 수 있습니다. 이러한 콜백은 선택 사항이며 현재로서는 관심있는 콜백 만 구현했습니다. 요약하자.</target>
        </trans-unit>
        <trans-unit id="a3de339a8a8126c8176ac9eab07a22576517e36b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not what we wanted, since the value of the &lt;code&gt;number&lt;/code&gt; variable has not been injected and &lt;code&gt;number&lt;/code&gt; has been quoted in the expression. In order to inject the &lt;em&gt;value&lt;/em&gt; of the &lt;code&gt;number&lt;/code&gt; variable, &lt;code&gt;unquote&lt;/code&gt; has to be used inside the quoted representation:</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 변수 의 값 이 주입되지 않았고 표현식에서 &lt;code&gt;number&lt;/code&gt; 가 인용되었으므로 우리가 원하는 것이 아닙니다 . 분사하기 위해 &lt;em&gt;값&lt;/em&gt; 의 &lt;code&gt;number&lt;/code&gt; 변수를 &lt;code&gt;unquote&lt;/code&gt; 인용 표현 내에서 사용되어야한다 :</target>
        </trans-unit>
        <trans-unit id="dcf68842185af09e3a0f9fe32163648242f47543" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what macros are all about. They are about receiving quoted expressions and transforming them into something else. In fact, &lt;code&gt;unless/2&lt;/code&gt; in Elixir is implemented as a macro:</source>
          <target state="translated">그것이 매크로에 관한 것입니다. 인용 된 표현을 받고 다른 것으로 변환하는 것에 관한 것입니다. 실제로 Elixir의 &lt;code&gt;unless/2&lt;/code&gt; 는 매크로로 구현 되지 않는 한 :</target>
        </trans-unit>
        <trans-unit id="23bd0d6f40de4627ff508337339ea27a545beab3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s when &lt;code&gt;unquote_splicing&lt;/code&gt; becomes handy:</source>
          <target state="translated">&lt;code&gt;unquote_splicing&lt;/code&gt; 이 편리해 졌을 때입니다 .</target>
        </trans-unit>
        <trans-unit id="21e361b399ff70e0ade5d247fbe5325383f22c2c" translate="yes" xml:space="preserve">
          <source>That's because by reading the application in the module body and storing it in a module attribute, we are effectively reading the configuration at compile-time, which may become an issue when configuring the system later.</source>
          <target state="translated">이는 모듈 본문에서 애플리케이션을 읽고 모듈 속성에 저장함으로써 컴파일 타임에 효과적으로 구성을 읽고 있기 때문이며, 이는 나중에 시스템을 구성 할 때 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525c877e46b0705b116260fb28719a829fe1a18e" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Note that we could call &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이전에 스트림이 구성 가능하고 게으른 열거 형이라고 말했을 때 이것이 의미하는 바입니다. &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; 를&lt;/a&gt; 여러 번 호출 하여 효과적으로 스트림을 구성하고 지연을 유지할 수 있습니다. 계산은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 에서 함수를 호출 할 때만 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd53bd72aff61e4af823bbda7c24cb88da5c37ab" translate="yes" xml:space="preserve">
          <source>That's what we meant when we said earlier that streams are composable, lazy enumerables. Notice we could call &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt; multiple times, effectively composing the streams and keeping them lazy. The computations are only performed when you call a function from the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이것이 스트림이 컴포저 블, 게으른 열거 형이라고 말했을 때의 의미입니다. &lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; 를&lt;/a&gt; 여러 번 호출 하여 스트림을 효과적으로 구성하고 게으르게 유지할 수 있습니다. &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 에서 함수를 호출 할 때만 계산이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="09a6d160f8b301e17d705ee43757bf265bccdb38" translate="yes" xml:space="preserve">
          <source>The &quot;Current Era&quot; or the &quot;Common Era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&quot;현재 시대&quot;또는 년에 시작 &quot;일반적인 시대&quot;(CE) &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a59d1e1634f57e0cf851ffcf7499aa4351a17212" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to a deprecated &quot;module.function/arity&quot; is made. This operation does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">&quot;file : line&quot;은 파일을 나타내며 더 이상 사용되지 않는 &quot;module.function / arity&quot;를 호출합니다. 이 작업은 더 이상 사용되지 않는 로컬 호출 (같은 모듈에서 더 이상 사용되지 않는 함수 또는 매크로에 대한 호출) 또는 Elixir 자체에서 더 이상 사용되지 않는 기능에 대한 호출을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="826934dab44a7a099fc8b2a86a3c62e533cc4b2e" translate="yes" xml:space="preserve">
          <source>The &quot;file:line&quot; represents the file and line a call to an unknown &quot;module.function/arity&quot; is made.</source>
          <target state="translated">&quot;file : line&quot;은 파일을 나타내며 알 수없는 &quot;module.function / arity&quot;를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f23646193825ac71d9878bc225694b7560e701b8" translate="yes" xml:space="preserve">
          <source>The --stale option</source>
          <target state="translated">--stale 옵션</target>
        </trans-unit>
        <trans-unit id="0c20b0f5fe22af74b9f5bd9023dad3c12944c0fd" translate="yes" xml:space="preserve">
          <source>The .iex.exs file</source>
          <target state="translated">.iex.exs 파일</target>
        </trans-unit>
        <trans-unit id="f8308d6c331d75737fe1ed60777039be95e5626b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">&lt;a href=&quot;#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; 연산자는 긴 왼쪽 인자 리터럴 진만큼 패턴 매칭 (가드 절)에 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="2522f291657c90a8970a25fc0f5c55b3b111e28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator can also be used in pattern matching (and guard clauses) as long as the left argument is a literal binary:</source>
          <target state="translated">&lt;a href=&quot;#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; 연산자는 긴 왼쪽 인자 리터럴 진만큼 패턴 매칭 (가드 절)에 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="3ea0da9cdd3dfdfb8c5593853f9e341b5464f742" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#--/2&quot;&gt;&lt;code&gt;--/2&lt;/code&gt;&lt;/a&gt; operator is right associative, meaning:</source>
          <target state="translated">&lt;a href=&quot;#--/2&quot;&gt; &lt;code&gt;--/2&lt;/code&gt; &lt;/a&gt; 연산자는 의미를 잘 결합이다 :</target>
        </trans-unit>
        <trans-unit id="ae4a9ae0930f3e9d2c507d033d48dd4bf27477e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/2&quot;&gt;&lt;code&gt;add/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/2&quot;&gt;&lt;code&gt;diff/2&lt;/code&gt;&lt;/a&gt; functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):</source>
          <target state="translated">&lt;a href=&quot;#add/2&quot;&gt; &lt;code&gt;add/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#diff/2&quot;&gt; &lt;code&gt;diff/2&lt;/code&gt; &lt;/a&gt; 기능은 날짜를 계산하거나 순간 사이의 일 수를 검색하는 데 사용할 수 있습니다. 예를 들어, 유닉스 시대 (1970-01-01)에서 일 수를 계산하는 데 관심이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="9ee4b27e73fcd2815c54fe669288c51019f1a3b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#add/3&quot;&gt;&lt;code&gt;add/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#diff/3&quot;&gt;&lt;code&gt;diff/3&lt;/code&gt;&lt;/a&gt; functions can be used for computing with date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00):</source>
          <target state="translated">&lt;a href=&quot;#add/3&quot;&gt; &lt;code&gt;add/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#diff/3&quot;&gt; &lt;code&gt;diff/3&lt;/code&gt; &lt;/a&gt; 기능 날짜 시간으로 계산 또는 순간 사이의 시간 (초)을 검색하기 위해 사용될 수있다. 예를 들어, 유닉스 시대 (1970-01-01 00:00:00)에서 초 수를 계산하는 데 관심이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="a3dad105e7857da173ae25be4e7158181735facf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function returns an atom indicating the status of the compilation, and optionally can also return a list of &quot;diagnostics&quot; such as warnings or compilation errors. Doing this enables code editors to display issues inline without having to analyze the command-line output.</source>
          <target state="translated">&lt;a href=&quot;#c:run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 기능은 또한 경고 또는 컴파일 에러로 &quot;진단&quot;의 목록을 반환 할 수 있습니다 선택적으로 컴파일의 상태를 나타내는 원자를 반환합니다. 이렇게하면 코드 편집기에서 명령 줄 출력을 분석하지 않고도 문제를 인라인으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43daa6aefdc5d7ab59c882f8c756868ab5825ba5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback has to spawn and link a supervisor and return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor, and &lt;code&gt;state&lt;/code&gt; is an optional application state. &lt;code&gt;args&lt;/code&gt; is the second element of the tuple given to the &lt;code&gt;:mod&lt;/code&gt; option.</source>
          <target state="translated">&lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백은 산란을 가지고 있으며, 감독자 및 반환을 연결 &lt;code&gt;{:ok, pid}&lt;/code&gt; 또는 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; , &lt;code&gt;pid&lt;/code&gt; 는 감독자의 PID이며, &lt;code&gt;state&lt;/code&gt; 옵션으로 애플리케이션 상태입니다. &lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 옵션에 지정된 튜플의 두 번째 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="ed55773b14c9f49b1e67866369426e97f1e28202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; callback of the given &lt;code&gt;server&lt;/code&gt; will be invoked before exiting. This function returns &lt;code&gt;:ok&lt;/code&gt; if the server terminates with the given reason; if it terminates with another reason, the call exits.</source>
          <target state="translated">주어진 &lt;code&gt;server&lt;/code&gt; 의 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 콜백 이 종료 되기 전에 호출됩니다. 주어진 이유로 서버가 종료되면 이 함수는 &lt;code&gt;:ok&lt;/code&gt; 를 리턴합니다 . 다른 이유로 종료되면 통화가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e5479aff7c9902d4559e5268eb0059ef6a88b9eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module defines a behaviour for dynamically accessing keys of any type in a data structure via the &lt;code&gt;data[key]&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 통해 동적으로 데이터 구조의 임의의 타입의 키에 액세스하기위한 동작을 정의 &lt;code&gt;data[key]&lt;/code&gt; 구.</target>
        </trans-unit>
        <trans-unit id="22076bf07a81ed27164e331c5cdde4703e5883c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module provides a basic server implementation that allows state to be retrieved and updated via a simple API.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈은 상태가 간단한 API를 통해 검색 및 업데이트 할 수있는 기본 서버 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab7d336fe7d0f927a59616b237afeff91face2e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;collectable#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 모듈은 왼쪽으로 간격 채우기 위해 설계되었다 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜을. &lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 와 반대되는 것으로 볼 수 있습니다 . &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 의 함수 가 값을 가져 오는 것이라면 &lt;a href=&quot;collectable#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; 은 해당 값을 구조에 수집하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b8288b2458a158037407e3018394c02df95a408e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; module was designed to fill the gap left by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; can be seen as the opposite of &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt;. If the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; are about taking values out, then &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;Collectable.into/1&lt;/code&gt;&lt;/a&gt; is about collecting those values into a structure.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 모듈은 왼쪽으로 간격 채우기 위해 설계되었다 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜을. &lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 의 반대라고 볼 수 있습니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 의 함수 가 값을 꺼내는 것에 관한 것이라면 &lt;a href=&quot;#into/1&quot;&gt; &lt;code&gt;Collectable.into/1&lt;/code&gt; &lt;/a&gt; 은 그 값을 구조로 수집하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba60445997acad418c74ca5920c2ffa31f99771e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">Elixir 의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 모듈은 Mix에 한정되어 더 이상 사용되지 않는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; 를&lt;/a&gt; 대체하기 위해 v1.9 에서 도입 되었습니다.</target>
        </trans-unit>
        <trans-unit id="abf8114bea9b602a6fa5cde26a4f28f20fe6f936" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is disabled by configuration but might be enabled later.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 는&lt;/a&gt; 구성으로 비활성화되어 나중에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bff3abe60e151fca7d023800c126e733ac84e99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. This is especially useful for fields containing private information.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 가 로그, 검사 및 이와 유사한에 표시되지 않도록 프로토콜은, 구조체에서 특정 필드를 숨기도록 유도 할 수있다. 개인 정보가 포함 된 필드에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8080f21d315b84058f54169b0d0e5acda5fedb17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol converts an Elixir data structure into an algebra document.</source>
          <target state="translated">는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 대수 문서로 프로토콜 변환 엘릭서 데이터 구조를.</target>
        </trans-unit>
        <trans-unit id="9574ae7fd608f87be01cc34283e1b30a27e28472" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt; module consists solely of macros that can be invoked anywhere in Elixir code without the use of the &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel.SpecialForms&lt;/code&gt; 의&lt;/a&gt; 모듈은 단독으로 사용하지 않고 비약 코드 어디서나 호출 할 수있는 매크로로 구성 &lt;code&gt;Kernel.SpecialForms.&lt;/code&gt; 접두사. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈의 함수 및 매크로와 동일한 방식으로 모두 자동으로 가져 오기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9b2d0f65323751f2d634dcefd3c1350838c93ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;List.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a charlist (only if applicable).</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;List.Chars&lt;/code&gt; 의&lt;/a&gt; 프로토콜은 charlist (해당되는 경우)에 구조를 변환 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d20b80dced22a569e8ce8dd2e2cb76ca007f43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level can be changed via &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 수준을 통해 변경할 수 있습니다 &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b1a8808d4938037f08f4bb6036b797cb46526f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol is responsible for converting a structure to a binary (only if applicable).</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; 의&lt;/a&gt; 프로토콜은 바이너리 (해당되는 경우)에 구조를 변환 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a7cc4ed1dd3a53a3c1622be5d60a8754eb496ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module also provides functions that work with time, returning different times kept by the system with support for different time units.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; 모듈은 시간 작업, 반환 서로 다른 시간에 서로 다른 시간 단위를 지원하는 시스템에 의해 유지한다는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cb4a8417128c99dd0f8e923027d6accff8aed84b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module provides functions that interact directly with the VM or the host system.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; 모듈은 기능을 제공합니다 상호 작용 직접 VM 또는 호스트 시스템과 그.</target>
        </trans-unit>
        <trans-unit id="12062fd16ee7106907717a179dc3f0336ff014a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt; 기능은 때때로 혼동된다&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; , 모두 동일의 행동 상기 예 때문이다. 주요 차이점은 이스케이프 할 값이 변수에 저장 될 때 가장 잘 나타납니다.</target>
        </trans-unit>
        <trans-unit id="809a6d9b2839f1f30bd03fe2ee9a26d931f04222" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#escape/2&quot;&gt;&lt;code&gt;escape/2&lt;/code&gt;&lt;/a&gt; function is sometimes confused with &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</source>
          <target state="translated">&lt;a href=&quot;#escape/2&quot;&gt; &lt;code&gt;escape/2&lt;/code&gt; &lt;/a&gt; 기능은 때때로 혼동된다 &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; , 모두 동일의 행동 상기 예 때문이다. 주요 차이점은 이스케이프 할 값이 변수에 저장 될 때 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="9c2c3fda2409ed0d9077f83013708c3d236d2331" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#in/2&quot;&gt;&lt;code&gt;in/2&lt;/code&gt;&lt;/a&gt; operator (as well as &lt;code&gt;not in&lt;/code&gt;) can be used in guard clauses as long as the right-hand side is a range or a list. In such cases, Elixir will expand the operator to a valid guard expression. For example:</source>
          <target state="translated">&lt;a href=&quot;#in/2&quot;&gt; &lt;code&gt;in/2&lt;/code&gt; &lt;/a&gt; (뿐만 아니라 운영자 &lt;code&gt;not in&lt;/code&gt; ) 긴 우측이 범위 또는리스트만큼 가드 절에서 사용될 수있다. 이 경우 Elixir는 연산자를 유효한 보호 표현식으로 확장합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12e9561355b5b7e730bdce33c0452a589a9f44d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warning&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; 의&lt;/a&gt; 매크로에서 제공된 메시지 방출 &lt;code&gt;:info&lt;/code&gt; 수준. 주어진 인수에 유의하십시오.&lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; 에&lt;/a&gt;는 메시지가 기록 된 경우에만 평가됩니다. 로거의 레벨로 설정되어있는 경우 예를 들어, &lt;code&gt;:warning&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; 메시지가 기록되지 않습니다 따라서 위의 인수도 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64530a6b669b9204e5a94bb0898670f111e23370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; 함수는 구조체로 표시되는 검사 옵션에 따라 검사 될 엔티티를 수신&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt; . 대수 문서 작성은&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; 를 사용&lt;/a&gt; 하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1987eac8908bd887fd45fd0aa17e5d5cf4eae6f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; function receives the entity to be inspected followed by the inspecting options, represented by the struct &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Building of the algebra document is done with &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; 기능은 엔티티 구조체로 표시되는 검사 옵션 이어 피검 수신 &lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt; . 대수 문서 작성은 &lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; 로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="134dffce704618fe41bc1a6ff89c996a1a5a5795" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; function is an alternative to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; which stops parsing as soon as it finds a value that is not a switch nor a value for a previous switch.</source>
          <target state="translated">&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 기능의 대안 &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 가 스위치 나 이전 스위치의 값이 아닌 값을 발견하자마자 파싱하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="697f7c6714240908cebb2f84042a4676fb351582" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#receive/1&quot;&gt;&lt;code&gt;receive/1&lt;/code&gt;&lt;/a&gt; special form handles variables exactly as the &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt; special macro. For more information, check the docs for &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">은 &lt;a href=&quot;#receive/1&quot;&gt; &lt;code&gt;receive/1&lt;/code&gt; &lt;/a&gt; 정확하게 같은 특수 형태의 핸들 변수 &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt; 특별한 매크로. 자세한 정보는 &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; 에&lt;/a&gt; 대한 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0a73aff6dd1644a4fec2f0cc2e5b4cbf67e226d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all arguments passed to the command line.</source>
          <target state="translated">&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 기능은 명령 줄에 전달 된 모든 인수 목록을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="d0035717d441177cdcf48958cde9b6d4cb1dceef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function will receive a list of all command line arguments passed, according to the user's terminal.</source>
          <target state="translated">&lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 기능은 사용자의 단말기에 따라, 전달 된 모든 명령 행 인수의 목록을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="659e7f5a2f80c4b590db43cd2313e4b28833eba7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt; 에 의해 자동으로 가져 오기 기능을 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 이 프로토콜을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1acbbf7700e430d5e8a317ed727437d8f72605c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol.</source>
          <target state="translated">&lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt; 에 의해 자동으로 가져 오기 기능을 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 이 프로토콜을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e73d8ea623f499f0cd55a3dd0c9f7d97f06db4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 에 의해 자동으로 가져 오기 기능을 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 이 프로토콜을 호출합니다. 문자열 보간은 또한 인수에서 &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 을 호출합니다 . 예 : &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c9a742b2d1a9b66bf0c1dce63c60e9a1472deab1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; function automatically imported by &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; invokes this protocol. String interpolation also invokes &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt; in its arguments. For example, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; is the same as &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 에 의해 자동으로 가져 오기 기능을 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 이 프로토콜을 호출합니다. 문자열 보간은 또한 인수에서 &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 을 호출합니다 . 예를 들어, &lt;code&gt;&quot;foo#{bar}&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;foo&quot; &amp;lt;&amp;gt; to_string(bar)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="99cfcb046ece84f36691d25008fe9a0f03a6c335" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;access#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">&lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 등 많은 편의 접근 기능을 가진 모듈 제공되는 &lt;code&gt;all&lt;/code&gt; 위에서 정의 된 익명 함수. 예를 들어 &lt;a href=&quot;access#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt; 및 기타를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf10aa8724a5861c9b7609f06466ac0092733d78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">&lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; 기능 집합을 열거 내로 삽입이 프로토콜을 사용</target>
        </trans-unit>
        <trans-unit id="fa114b12b62761d046798dab8cfd3d0e25686da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜 모음에서 값을 가질 때 유용합니다. 광범위한 값을 지원하기 위해 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜이 제공하는 기능은 형태를 유지하지 않습니다. 예를 들어 &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; 에&lt;/a&gt; 맵을 전달하면 항상 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c6e919949e1cc4c7055aecf80d424e6c7c8e1be6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;exunit.assertions&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">&lt;a href=&quot;exunit.assertions&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; 의&lt;/a&gt; 모듈은 적절한 오류 메시지와 주장을 생성하는 매크로 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06ff54ee1b695829bf1293f395bfa9eaf00995b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt;&lt;code&gt;queue&lt;/code&gt; is a data structure&lt;/a&gt; that implements (double-ended) FIFO (first-in first-out) queues efficiently:</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/man/queue.html&quot;&gt; &lt;code&gt;queue&lt;/code&gt; 데이터 구조&lt;/a&gt; 가 구현 (양두) 것을 효율적 큐 (선입 선출 처음에) FIFO :</target>
        </trans-unit>
        <trans-unit id="07ed121626ed7e8f632f13e54f94021e4c3eade3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module ships with many convenience accessor functions, like the &lt;code&gt;all&lt;/code&gt; anonymous function defined above. See &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt;&lt;code&gt;Access.all/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt;&lt;code&gt;Access.key/2&lt;/code&gt;&lt;/a&gt;, and others as examples.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 등 많은 편의 접근 기능을 가진 모듈 제공되는 &lt;code&gt;all&lt;/code&gt; 위에서 정의 된 익명 함수. 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#all/0&quot;&gt; &lt;code&gt;Access.all/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#key/2&quot;&gt; &lt;code&gt;Access.key/2&lt;/code&gt; &lt;/a&gt; 및 예제 등 다른 사람.</target>
        </trans-unit>
        <trans-unit id="bdd1437c3341d1c07273b3f627a96d773e38e418" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt;, which we&amp;rsquo;re going to see in the next chapter, already provides many conveniences for working with lists. For instance, the examples above could be written as:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 모듈&lt;/a&gt; 우리는 다음 장에서 보게 될, 이미 목록 작업을위한 많은 편의를 제공합니다. 예를 들어 위의 예는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a11f1e7c47a4cc245aed3807805f29443ecca4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; function uses this protocol to insert an enumerable into a collection:</source>
          <target state="translated">그만큼 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; 기능 집합을 열거 내로 삽입이 프로토콜을 사용</target>
        </trans-unit>
        <trans-unit id="2f7b5a0e03b34766993d4d199617c0cbd0ae5332" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol is useful to take values out of a collection. In order to support a wide range of values, the functions provided by the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol do not keep shape. For example, passing a map to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; always returns a list.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜 모음에서 값을 가질 때 유용합니다. 광범위한 값을 지원하기 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜에서 제공하는 함수 는 모양을 유지하지 않습니다. 예를 들어,지도를&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; 에&lt;/a&gt;항상 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c7834fd0c261cc1b5f7ce8f49f4c14a50c74c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; module contains functions that allow us to open files as IO devices. By default, files are opened in binary mode, which requires developers to use the specific &lt;code&gt;IO.binread/2&lt;/code&gt; and &lt;code&gt;IO.binwrite/2&lt;/code&gt; functions from the &lt;code&gt;IO&lt;/code&gt; module:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 모듈은 우리가 IO 장치로 파일을 열 수있는 기능이 포함되어 있습니다. 기본적으로 파일은 이진 모드로 열리 &lt;code&gt;IO.binread/2&lt;/code&gt; 개발자 는 &lt;code&gt;IO&lt;/code&gt; 모듈 에서 특정 IO.binread / 2 및 &lt;code&gt;IO.binwrite/2&lt;/code&gt; 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f10e5258e9f652f477ba9a6f2a826f10009c524a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module is the main mechanism in Elixir for reading and writing to standard input/output (&lt;code&gt;:stdio&lt;/code&gt;), standard error (&lt;code&gt;:stderr&lt;/code&gt;), files, and other IO devices. Usage of the module is pretty straightforward:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 의&lt;/a&gt; (모듈 읽고 표준 입 / 출력을 기록하기위한 엘릭서의 주요 메커니즘이다 &lt;code&gt;:stdio&lt;/code&gt; ), 표준 에러 ( &lt;code&gt;:stderr&lt;/code&gt; ), 파일 및 다른 IO 장치. 모듈 사용법은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="cedaefb5f61468b8c215642cc99c539ddbc0a94c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈은 모두 스트림을 제공 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 와&lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 여기를 이용한 지능형 upcase 에코 서버는 :</target>
        </trans-unit>
        <trans-unit id="e868f828529603da9f63a81284af34a853bef03f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above it is concatenating the string &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt;, the document returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt;, and the final string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;. We prefix the module name &lt;code&gt;#&lt;/code&gt; to denote the inspect presentation is not actually valid Elixir syntax.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt; 기능에서 온다 &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; 과 함께 대수 문서를 연결합니다. 위의 예에서는 문자열 &lt;code&gt;&quot;#MapSet&amp;lt;&quot;&lt;/code&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt; 에서 반환 된 문서 및 최종 문자열 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 을 연결 합니다. 검사 프리젠 테이션이 실제로 유효한 Elixir 구문이 아님을 나타 내기 위해 모듈 이름 &lt;code&gt;#&lt;/code&gt; 접두사를 붙 입니다.</target>
        </trans-unit>
        <trans-unit id="ae641337e01b9f93059a36e1a3ba275b039ee2b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 가 로그, 검사 및 이와 유사한에 표시되지 않도록 프로토콜은, 구조체에서 특정 필드를 숨기도록 유도 할 수있다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜 설명서의 &quot;Deriving&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1a28216d6e4672680d6eab32ae15b9eaaeac9554" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;%NaiveDateTime{}&lt;/a&gt; struct contains fields from both &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt;. You can create one using the &lt;code&gt;~N&lt;/code&gt; sigil:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;%의 NaiveDateTime {}&lt;/a&gt; 구조체는 모두의 필드가 포함되어 &lt;code&gt;Date&lt;/code&gt; 와 &lt;code&gt;Time&lt;/code&gt; . &lt;code&gt;~N&lt;/code&gt; 시길을 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0707ff13aefb15f3954d547b10f3f7c1336b24c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;String module&lt;/a&gt; contains a bunch of functions that operate on strings as defined in the Unicode standard:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;문자열 모듈은&lt;/a&gt; 유니 코드 표준에 정의 된 문자열에서 작동 기능의 무리가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="d8cf6fffff5672b5280f7c52df7e56e3e88d0bc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈은 관리자가 시작되면 주어진 순서로 시작됩니다 주로 정적 자녀를 처리 할 수 있도록 설계되었다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; 이&lt;/a&gt; 없는 아이들과 함께 시작됩니다. 대신, 하위는 &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; 를 통해 요청시 시작됩니다 . 동적 감독자가 종료되면 주문 보장없이 모든 하위 항목이 동시에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3698c4ae0d236660076a5f1da19f774b16936015" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 의&lt;/a&gt; 모듈은 개발자가 동적으로 여러 감독 작업을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc49e09c4c997793290301e758bea0470f3d8f68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;%Time{}&lt;/a&gt; struct contains the fields &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;microsecond&lt;/code&gt;, and &lt;code&gt;calendar&lt;/code&gt;. You can create one using the &lt;code&gt;~T&lt;/code&gt; sigil:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;{} %의 시간&lt;/a&gt; 구조체 필드의 포함 &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;microsecond&lt;/code&gt; 및 &lt;code&gt;calendar&lt;/code&gt; . &lt;code&gt;~T&lt;/code&gt; 시길을 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e2e3efd9b70a9c902779bfbca4902214d293def" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt;&lt;code&gt;ExUnit.Assertions&lt;/code&gt;&lt;/a&gt; module contains a set of macros to generate assertions with appropriate error messages.</source>
          <target state="translated">그만큼 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Assertions.html&quot;&gt; &lt;code&gt;ExUnit.Assertions&lt;/code&gt; 의&lt;/a&gt; 모듈은 적절한 오류 메시지와 주장을 생성하는 매크로 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="67af9d3d80d8598be47bff2ebf254dbbb32a0636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt;&lt;code&gt;mix new&lt;/code&gt;&lt;/a&gt; command also allows the &lt;code&gt;--sup&lt;/code&gt; option to scaffold an application with a supervision tree out of the box. We talk about supervision trees later on when discussing one of the common anti-patterns when writing libraries.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.New.html&quot;&gt; &lt;code&gt;mix new&lt;/code&gt; &lt;/a&gt; 명령은 또한 수 있습니다 &lt;code&gt;--sup&lt;/code&gt; 상자 밖으로 감독 트리를 사용하여 응용 프로그램을 스캐 폴딩하는 옵션을 선택합니다. 나중에 라이브러리를 작성할 때 일반적인 안티 패턴 중 하나를 논의 할 때 감독 트리에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="08414f62e4bbf9fd4d3ea08bc5b82b4c8e08abc1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol can be derived to hide certain fields from structs, so they don't show up in logs, inspects and similar. See the &quot;Deriving&quot; section of the documentation of the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for more information.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 가 로그, 검사 및 이와 유사한에 표시되지 않도록 프로토콜은, 구조체에서 특정 필드를 숨기도록 유도 할 수있다. 자세한 내용은 &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜 설명서의 &quot;파생&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40361add3dfacd3a82f9de048a333c39b479ae30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;inspect.algebra#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt; function comes from &lt;a href=&quot;inspect.algebra&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; and it concatenates algebra documents together. In the example above, it is concatenating the string &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; (all strings are valid algebra documents that keep their formatting when pretty printed), the document returned by &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; and the other string &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;inspect.algebra#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt; 기능에서 온다 &lt;a href=&quot;inspect.algebra&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; &lt;/a&gt; 과 함께 대수 문서를 연결합니다. 위의 예에서 문자열 &lt;code&gt;&quot;MapSet&amp;lt;&quot;&lt;/code&gt; (모든 문자열은 유효한 인쇄시 형식을 유지하는 유효한 대수 문서), &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 문서 및 다른 문자열 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 을 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="3e499fed5d9e082220ab4665ee83930202fbc216" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides streams, that are both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, here is an upcase echo server using comprehensions:</source>
          <target state="translated">&lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈은 모두 스트림 제공 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 와 &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 여기를 이용한 지능형 upcase 에코 서버는 :</target>
        </trans-unit>
        <trans-unit id="ef991dbc6590a70e7dc7792c1502faa5b82544ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;logger#info/2&quot;&gt;&lt;code&gt;Logger.info/2&lt;/code&gt;&lt;/a&gt; macro emits the provided message at the &lt;code&gt;:info&lt;/code&gt; level. Note the arguments given to &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt; will only be evaluated if a message is logged. For instance, if the Logger level is set to &lt;code&gt;:warn&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt; messages are never logged and therefore the arguments given above won't even be executed.</source>
          <target state="translated">&lt;a href=&quot;logger#info/2&quot;&gt; &lt;code&gt;Logger.info/2&lt;/code&gt; 의&lt;/a&gt; 매크로에서 제공된 메시지 방출 &lt;code&gt;:info&lt;/code&gt; 수준. &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; 에&lt;/a&gt; 제공된 인수 는 메시지가 기록 된 경우에만 평가됩니다. 예를 들어, 로거 레벨이 &lt;code&gt;:warn&lt;/code&gt; 으로 설정 되면 &lt;code&gt;:info&lt;/code&gt; 메시지가 기록되지 않으므로 위에 제공된 인수도 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fb892be769329b47a3a72fea685384027a625eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module was designed to handle mostly static children that are started in the given order when the supervisor starts. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; starts with no children. Instead, children are started on demand via &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;. When a dynamic supervisor terminates, all children are shut down at the same time, with no guarantee of ordering.</source>
          <target state="translated">&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈은 관리자가 시작되면 주어진 순서로 시작됩니다 주로 정적 자녀를 처리 할 수 있도록 설계되었다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; 이&lt;/a&gt; 없는 아이들과 함께 시작됩니다. 대신, 아이들은 &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; 를 통해 요청에 따라 시작됩니다 . 동적 관리자가 종료되면 주문을 보장하지 않고 모든 어린이가 동시에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="26a12a273dc85b3ddb0a7cf7190ec7cccb61c0d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; module allows developers to dynamically create multiple supervised tasks.</source>
          <target state="translated">&lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 의&lt;/a&gt; 모듈은 개발자가 동적으로 여러 감독 작업을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3bcdc6b0dacd5812de01049f85ba71ec9d986e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;1&lt;/code&gt; represents the first argument passed into the function. &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; above is exactly the same as &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt;. The syntax above is useful for short function definitions.</source>
          <target state="translated">&lt;code&gt;&amp;amp;1&lt;/code&gt; 함수로 전달되는 첫번째 인수를 나타낸다. &lt;code&gt;&amp;amp;(&amp;amp;1 + 1)&lt;/code&gt; 은 &lt;code&gt;fn x -&amp;gt; x + 1 end&lt;/code&gt; 와 정확히 동일 합니다. 위의 구문은 짧은 함수 정의에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="462dea57799a704e8bdaa1d60d5f41548cf0ff70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator can be used with more complex expressions:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 연산자는 더 복잡한 식을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8324a31beed435619f352d82babacf78e2ffed56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--source&lt;/code&gt; and &lt;code&gt;--sink&lt;/code&gt; options are particularly useful when trying to understand how the modules in a particular file interact with the whole system. You can combine those options with &lt;code&gt;--label&lt;/code&gt; and &lt;code&gt;--only-nodes&lt;/code&gt; to get all files that exhibit a certain property, for example:</source>
          <target state="translated">&lt;code&gt;--source&lt;/code&gt; 및 &lt;code&gt;--sink&lt;/code&gt; 전체 시스템에 특정 파일의 상호 작용에 어떻게 모듈을 이해하려고 할 때 옵션은 특히 유용합니다. 이러한 옵션을 &lt;code&gt;--label&lt;/code&gt; 및 &lt;code&gt;--only-nodes&lt;/code&gt; 와 결합 하여 특정 속성을 나타내는 모든 파일을 가져올 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da8c5a69e634407470f64de131f93cd85b1c1054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only the test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--stale&lt;/code&gt; 명령 줄 옵션을 시도 참조 모듈은 당신이이 작업을 마지막으로 실행 된 이후에 변경된 경우에만 테스트 파일을 실행합니다 &lt;code&gt;--stale&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="27914fb6ca74f78b539d08d503dae1d70d9876c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; command line option attempts to run only those test files which reference modules that have changed since the last time you ran this task with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--stale&lt;/code&gt; 명령 행 옵션 시도 만 테스트 파일 당신이이 작업을 마지막으로 실행 한 이후에 변경된 참조 모듈 실행 &lt;code&gt;--stale&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="df6e7ebae80eb329ea0918689120d554cb37f2c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stale&lt;/code&gt; option is extremely useful for software iteration, allowing you to run only the relevant tests as you perform changes to the codebase.</source>
          <target state="translated">그만큼 &lt;code&gt;--stale&lt;/code&gt; 옵션을 사용하면 코드베이스에 변경 사항을 수행 할 때 당신은 단지 관련 테스트를 실행할 수 있도록 소프트웨어 반복에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="08ab3c233377a6ec13838eb8f093fb564ec02061" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. If you run the tests multiple times you may see this intermittent failure:</source>
          <target state="translated">&lt;code&gt;--trace&lt;/code&gt; 옵션은 테스트가 교착 할 때 유용하거나 동 기적으로 모든 테스트를 실행으로 경쟁 조건이있다 ( &lt;code&gt;async: true&lt;/code&gt; 와 쇼는 각 테스트에 대한 자세한 정보를 아무런 효과가 없습니다). 테스트를 여러 번 실행하면 다음과 같은 간헐적 인 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c59bbd77397d77a76b99b62c09d5b35df96a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trace&lt;/code&gt; option is useful when your tests are deadlocking or there are race conditions, as it runs all tests synchronously (&lt;code&gt;async: true&lt;/code&gt; has no effect) and shows detailed information about each test. You may see one or two intermittent failures:</source>
          <target state="translated">&lt;code&gt;--trace&lt;/code&gt; 동 기적 (모든 테스트를 실행되는 옵션은, 당신의 검사 결과가 교착하거나 경쟁 조건이있을 때 유용하다 &lt;code&gt;async: true&lt;/code&gt; 와 쇼는 각 테스트에 대한 자세한 정보를 아무런 효과가 없습니다). 간헐적으로 하나 또는 두 개의 장애가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac163fa8c2566f186b54fd07de5c6d65f93af5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ascii&lt;/code&gt; mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</source>
          <target state="translated">&lt;code&gt;:ascii&lt;/code&gt; 모드는 유니 코드 문자를 무시하고 문자열이 ASCII 문자 만 포함 알고있을 때 더 성능이 좋은 구현을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="05564ea628704e49dd4cc09651f569d44c1a82ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:crypto&lt;/code&gt; module is not part of the Erlang standard library, but is included with the Erlang distribution. This means you must list &lt;code&gt;:crypto&lt;/code&gt; in your project&amp;rsquo;s applications list whenever you use it. To do this, edit your &lt;code&gt;mix.exs&lt;/code&gt; file to include:</source>
          <target state="translated">&lt;code&gt;:crypto&lt;/code&gt; 모듈은 얼랑 표준 라이브러리의 일부가 아니라 얼랑 배포판에 포함되어있다. 즉, 사용할 때마다 프로젝트 응용 프로그램 목록에 &lt;code&gt;:crypto&lt;/code&gt; 를 나열해야 합니다. 이렇게하려면 &lt;code&gt;mix.exs&lt;/code&gt; 파일을 편집하여 다음 을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="add3cf115e3a7915716bd93a5b79e1744ef2d173" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:fd&lt;/code&gt; name option allows developers to access &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; file descriptors used by the Erlang VM. You would use those only if you are reimplementing core part of the Runtime System, such as the &lt;code&gt;:user&lt;/code&gt; and &lt;code&gt;:shell&lt;/code&gt; processes.</source>
          <target state="translated">&lt;code&gt;:fd&lt;/code&gt; 이름 옵션은 액세스 개발자 수 &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;out&lt;/code&gt; 얼랑 VM에서 사용하는 파일 기술자. &lt;code&gt;:user&lt;/code&gt; 및 &lt;code&gt;:shell&lt;/code&gt; 프로세스 와 같이 런타임 시스템의 핵심 부분을 다시 구현하는 경우에만이를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="3f6ac7a8b41e26b0d52e88d330fed22cf2cc2f20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; and &lt;code&gt;:uniq&lt;/code&gt; options</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 와 &lt;code&gt;:uniq&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="0211bc3942dfba08cb46ef94332394518116ea6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:into&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="a3988e2dcd8f368dd88c8ea1b7ec2bcd3100e56a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:label&lt;/code&gt; option is especially useful with pipelines:</source>
          <target state="translated">&lt;code&gt;:label&lt;/code&gt; 옵션은 파이프 라인에 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="d03df649244dc7c63287f31c15a54de9bf6e2182" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mod&lt;/code&gt; option specifies the &amp;ldquo;application callback module&amp;rdquo;, followed by the arguments to be passed on application start. The application callback module can be any module that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;Application&lt;/a&gt; behaviour.</source>
          <target state="translated">&lt;code&gt;:mod&lt;/code&gt; 옵션은 인수 다음에 &quot;응용 프로그램 콜백 모듈&quot;, 응용 프로그램 시작에 전달되도록 지정합니다. 응용 프로그램 콜백 모듈은 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;응용 프로그램&lt;/a&gt; 동작 을 구현하는 모든 모듈 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc92fad8b6ff75a2a9c584dbe63fcee1353d021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 또한 관리자 이름을 등록하기 위해 제공 될 수 있으며, 지원되는 값은에서 &quot;이름 등록&quot;절에서 설명하는 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 의&lt;/a&gt; 모듈 문서.</target>
        </trans-unit>
        <trans-unit id="869c20a77b331e475dc6550865b679c81c154f2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be given in order to register a supervisor name, the supported values are described in the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 또한 관리자 이름을 등록하기 위해 제공 될 수 있으며, 지원되는 값은에서 &quot;이름 등록&quot;절에서 설명하는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 의&lt;/a&gt; 모듈 문서.</target>
        </trans-unit>
        <trans-unit id="9dd616361d3877df539a2d092f8aadb9d1c83008" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 감독자의 이름을 등록 할 수 있습니다. 지원되는 값은 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 모듈 문서 의 &quot;이름 등록&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccfdad6d1a6ed0b138742630a980b7e627021ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 감독자의 이름을 등록 할 수 있습니다. 지원되는 값은 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 모듈 문서 의 &quot;이름 등록&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be059e0f52bc117f0d9ac535f0ebaba535ffdbc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:name&lt;/code&gt; option is used for registration as described in the module documentation.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 모듈 문서에 설명 된대로 옵션을 등록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae6a790ebfb15d6c60e22c6003dc079f27e1350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:persistent&lt;/code&gt; option can be set to &lt;code&gt;true&lt;/code&gt; when there is a need to guarantee parameters set with this function will not be overridden by the ones defined in the application resource file on load. This means persistent values will stick after the application is loaded and also on application reload.</source>
          <target state="translated">&lt;code&gt;:persistent&lt;/code&gt; 옵션을 설정할 수 있습니다 &lt;code&gt;true&lt;/code&gt; 부하에 응용 프로그램 자원 파일에 정의 된 것들에 의해 오버라이드 (override)되지 않습니다이 기능으로 설정된 보증 매개 변수에 대한 필요가있을 때. 이는 애플리케이션이로드 된 후 및 애플리케이션을 다시로드 할 때 지속적 값이 유지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f0d1fdc494208ae6f6f718ee89ecd443e0ecaf7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:reduce&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;:reduce&lt;/code&gt; 옵션을</target>
        </trans-unit>
        <trans-unit id="fb3b286cd086eae72642832fb5a362f5110c1af4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:restart&lt;/code&gt; option controls what the supervisor should consider to be a successful termination or not. If the termination is successful, the supervisor won't restart the child. If the child process crashed, the supervisor will start a new one.</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; 감독자가 고려해야 할 옵션 컨트롤이 성공적으로 종료 여부를합니다. 종료에 성공하면 감독자는 자식을 다시 시작하지 않습니다. 하위 프로세스가 중단되면 감독자가 새 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="21c211e6097ddfd5bc4a9bb4945fe2497ef06a6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, &lt;code&gt;:microsecond&lt;/code&gt; and &lt;code&gt;:nanosecond&lt;/code&gt; time units controls the return value of the functions that accept a time unit.</source>
          <target state="translated">&lt;code&gt;:second&lt;/code&gt; , &lt;code&gt;:millisecond&lt;/code&gt; , &lt;code&gt;:microsecond&lt;/code&gt; 과 &lt;code&gt;:nanosecond&lt;/code&gt; 시간 단위의 시간 제어 유닛을 수용 함수의 리턴 값.</target>
        </trans-unit>
        <trans-unit id="2027010005a9400e00a3f5e7626e15299c8de0f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:secret_key&lt;/code&gt; key under &lt;code&gt;:my_app&lt;/code&gt; will be computed on the host machine, whenever the release is built. Setting the &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; right before starting your release will have no effect.</source>
          <target state="translated">&lt;code&gt;:my_app&lt;/code&gt; 아래 의 &lt;code&gt;:secret_key&lt;/code&gt; 키 는 릴리스가 빌드 될 때마다 호스트 시스템에서 계산됩니다. 설정 &lt;code&gt;MY_APP_SECRET_KEY&lt;/code&gt; 의 당신의 방출을 시작하기 전에 잘하는 것은 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fc77c6e40a992f998c561f03446c6642ec346ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:spawn&lt;/code&gt; tuple receives a binary that is going to be executed as a full invocation. For example, we can use it to invoke &quot;echo hello&quot; directly:</source>
          <target state="translated">&lt;code&gt;:spawn&lt;/code&gt; 튜플 전체 호출로 실행하는 것입니다 바이너리를받습니다. 예를 들어, &quot;echo hello&quot;를 직접 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b93bb4d3ff18560e52b37ae6c18a308889c8bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atom_encoder&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;:static_atom_encoder&lt;/code&gt; 의 기능</target>
        </trans-unit>
        <trans-unit id="1e63d1877fcfa7f1cccde5219f1c0beb12c1d581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:static_atoms_encoder&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;:static_atoms_encoder&lt;/code&gt; 기능</target>
        </trans-unit>
        <trans-unit id="a4c229bf7cb4e00904018bc0adfca73eff22ebc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:steps&lt;/code&gt; option must be a list and it must always include the atom &lt;code&gt;:assemble&lt;/code&gt;, which does most of the release assembling. You can pass anonymous functions before and after the &lt;code&gt;:assemble&lt;/code&gt; to customize your release assembling pipeline. Those anonymous functions will receive a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct and must return the same or an updated &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct. It is also possible to build a tarball of the release by passing the &lt;code&gt;:tar&lt;/code&gt; step anywhere after &lt;code&gt;:assemble&lt;/code&gt;. If the release &lt;code&gt;:path&lt;/code&gt; is not configured, the tarball is created in &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; Otherwise it is created inside the configured &lt;code&gt;:path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:steps&lt;/code&gt; 옵션은 목록에 있어야하며 항상 원자 포함해야한다 &lt;code&gt;:assemble&lt;/code&gt; , 릴리스 조립의 대부분을 수행합니다. &lt;code&gt;:assemble&lt;/code&gt; 전후에 익명 함수를 전달 하여 릴리스 어셈블 링 파이프 라인을 사용자 지정할 수 있습니다. 이러한 익명 함수는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; 구조체 를 수신 하고 동일하거나 업데이트 된 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; 구조체를 반환해야합니다 . 또한 &lt;code&gt;:assemble&lt;/code&gt; 다음에 : &lt;code&gt;:tar&lt;/code&gt; 단계 를 전달하여 릴리스의 tarball을 빌드 할 수도 있습니다 . 릴리스 &lt;code&gt;:path&lt;/code&gt; 가 구성되지 않은 경우 tarball이 생성되고 &lt;code&gt;_build/MIX_ENV/RELEASE_NAME-RELEASE_VSN.tar.gz&lt;/code&gt; 그렇지 않으면 구성된 &lt;code&gt;:path&lt;/code&gt; 내부에 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7852e9b0f6e5ea07cd2dd1ac64030694b4b9d2d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; is a required option and the currently supported value is &lt;code&gt;:one_for_one&lt;/code&gt;. The remaining options can be found in the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; 필수 옵션이며 현재 지원되는 값입니다 &lt;code&gt;:one_for_one&lt;/code&gt; . 나머지 옵션은 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 문서 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ecf2c76d0e93dbfb5af69dd0e723a8fce1f3ba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; 옵션이 필요하며 기본적으로 3 다시 시작의 최대 5 초 이내에 허용됩니다. 사용 가능한 전략에 대한 자세한 설명은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="39fdbe497bf489a09ea386b4627370ef6bf6b5e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; 옵션이 필요하며 기본적으로 3 다시 시작의 최대 5 초 이내에 허용됩니다. 사용 가능한 전략에 대한 자세한 설명은 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4318a8c81e458ee0b9cf77340dadbaf79a290499" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:strategy&lt;/code&gt; option is required and by default a maximum of 3 restarts is allowed within 5 seconds. Check the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module for a detailed description of the available strategies.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; 옵션이 필요하며 기본적으로 3 다시 시작의 최대 5 초 이내에 허용됩니다. 사용 가능한 전략에 대한 자세한 설명은 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fd3d939dbec7e219780c6a3622d4fe572215853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_coverage&lt;/code&gt; configuration accepts the following options:</source>
          <target state="translated">&lt;code&gt;:test_coverage&lt;/code&gt; 의 구성은 다음과 같은 옵션을 적용합니다</target>
        </trans-unit>
        <trans-unit id="ad9818925ace018f87e1927334e33ca1a365e0b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;em&gt;not&lt;/em&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">&lt;code&gt;:test_type&lt;/code&gt; 태그가 자동으로 ExUnit으로 설정되어 있지만 &lt;em&gt;없는&lt;/em&gt; 소유. 이 태그는 사용자가 원하는 경우 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f5e1a838ff9cda2c11258cd3b2a863cbdf176f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:test_type&lt;/code&gt; tag is automatically set by ExUnit, but is &lt;strong&gt;not&lt;/strong&gt; reserved. This tag is available for users to customize if they desire.</source>
          <target state="translated">&lt;code&gt;:test_type&lt;/code&gt; 태그가 자동으로 ExUnit으로 설정되어 있지만 &lt;strong&gt;없는&lt;/strong&gt; 소유. 이 태그는 사용자가 원하는 경우 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea129091dfbd99c2a530d95ef2783ebbf81e5ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:tracers&lt;/code&gt; compiler option can be combined with the &lt;code&gt;:parser_options&lt;/code&gt; compiler option to enrich the metadata of the traced events above.</source>
          <target state="translated">&lt;code&gt;:tracers&lt;/code&gt; 컴파일러 옵션은과 결합 될 수 &lt;code&gt;:parser_options&lt;/code&gt; 위의 추적 이벤트의 메타 데이터를 풍부하게 컴파일러 옵션.</target>
        </trans-unit>
        <trans-unit id="0bb936c2d2f36ac2f8066e21c586a6fb2a08b1b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@&lt;/code&gt; macro compiles to a call to this function. For example, the following code:</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 이 함수를 호출하는 매크로를 컴파일합니다. 예를 들어, 다음 코드는</target>
        </trans-unit>
        <trans-unit id="4db7ff3247782ab9520366b88d96d14d1712fe6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@optional_callbacks&lt;/code&gt; attributes are used to create a &lt;code&gt;behaviour_info/1&lt;/code&gt; function available on the defining module. This function can be used to retrieve the callbacks and optional callbacks defined by that module.</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; 및 &lt;code&gt;@optional_callbacks&lt;/code&gt; 특성은 생성하는 데 사용된다 &lt;code&gt;behaviour_info/1&lt;/code&gt; 정의하는 모듈 가능한 기능. 이 함수는 해당 모듈에서 정의한 콜백 및 선택적 콜백을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5131f63d4a847e5310d4b0da9f690cbf2653c391" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@compile&lt;/code&gt; attribute accepts different options that are used by both Elixir and Erlang compilers. Some of the common use cases are documented below:</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; 속성은 모두 비약과 얼랑 컴파일러에 의해 사용되는 다른 옵션을 받아들입니다. 일반적인 사용 사례 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c96b72a2b5229c84ff37173dda7b65a784fe244" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; annotation immediately preceding &lt;code&gt;use Supervisor&lt;/code&gt; will be attached to the generated &lt;code&gt;child_spec/1&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 바로 앞에 있는 &lt;code&gt;@doc&lt;/code&gt; 주석 이 생성 된 &lt;code&gt;child_spec/1&lt;/code&gt; 함수에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2548a73a793d075044328d72e23f487f2153196" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@moduledoc&lt;/code&gt; attribute is used to add documentation to the module. &lt;code&gt;@doc&lt;/code&gt; is used before a function to provide documentation for it. Besides the attributes above, &lt;code&gt;@typedoc&lt;/code&gt; can also be used to attach documentation to types defined as part of typespecs. Elixir also allows metadata to be attached to documentation, by passing a keyword list to &lt;code&gt;@doc&lt;/code&gt; and friends.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; 의 속성은 모듈에 문서를 추가하는 데 사용됩니다. &lt;code&gt;@doc&lt;/code&gt; 은 문서화 기능을 제공하기 전에 사용됩니다. 위의 속성 외에도 &lt;code&gt;@typedoc&lt;/code&gt; 을 사용하여 문서를 typespec의 일부로 정의 된 형식에 첨부 할 수 있습니다. Elixir는 또한 키워드 목록을 &lt;code&gt;@doc&lt;/code&gt; 및 friends 에 전달하여 메타 데이터를 문서에 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c4c9561309d3048192c645c1b53867cd58046c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@spec&lt;/code&gt; above expresses that all types allowed to implement the given protocol are valid argument types for the given function.</source>
          <target state="translated">위 의 &lt;code&gt;@spec&lt;/code&gt; 은 주어진 프로토콜을 구현할 수있는 모든 유형이 주어진 함수에 유효한 인수 유형임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ecf8bb424c804cabf2a64179dad99d91c08aa50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@type&lt;/code&gt;, &lt;code&gt;@typep&lt;/code&gt;, and &lt;code&gt;@opaque&lt;/code&gt; module attributes can be used to define new types:</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; , &lt;code&gt;@typep&lt;/code&gt; 및 &lt;code&gt;@opaque&lt;/code&gt; 모듈 속성은 새로운 유형을 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="525e602ced98f13bd5ecaf2f8ae5f13ce9d11d61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; attribute, similar to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; attributes, is used to document custom types.</source>
          <target state="translated">&lt;code&gt;@typedoc&lt;/code&gt; 을 받는 유사한 속성 &lt;code&gt;@doc&lt;/code&gt; 및 &lt;code&gt;@moduledoc&lt;/code&gt; 속성은 문서의 사용자 정의 유형에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="923172e1b194c31095f6b50cc3fcf7cd6864f7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@typedoc&lt;/code&gt; directive, similarly to the &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@moduledoc&lt;/code&gt; directives, is used to document custom types.</source>
          <target state="translated">&lt;code&gt;@typedoc&lt;/code&gt; 의 지시는 유사에 &lt;code&gt;@doc&lt;/code&gt; 및 &lt;code&gt;@moduledoc&lt;/code&gt; 지침, 문서 정의 유형에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a562fb60ef30731bd3203cf4bbff217d46bc1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as a second argument any function that receives one argument and returns a value:</source>
          <target state="translated">&lt;code&gt;Agent.update/3&lt;/code&gt; 함수는 제 인수로 하나 개의 인자를 수신하고 값을 리턴하는 함수를 받아 :</target>
        </trans-unit>
        <trans-unit id="a63341783e3511427fe146f8a19ffd92af29382f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Agent.update/3&lt;/code&gt; function accepts as second argument any function that receives one argument and returns a value:</source>
          <target state="translated">&lt;code&gt;Agent.update/3&lt;/code&gt; 함수는 두번째 인수로 하나 개의 인자를 수신하고 값을 리턴하는 함수를 받아 :</target>
        </trans-unit>
        <trans-unit id="7a655503d2990c75edcb4c8b8a481ab364d1c5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Config&lt;/code&gt; module in Elixir was introduced in v1.9 as a replacement to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt;, which was specific to Mix and has been deprecated.</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; 비약의 모듈로 대체 V1.9에 도입 된 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Config.html&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; 믹스 특이하고 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e27fe58053aba859d0bb7d011fc28980f6e9c181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Enum&lt;/code&gt; module provides a huge range of functions to transform, sort, group, filter and retrieve items from enumerables. It is one of the modules developers use frequently in their Elixir code.</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 모듈은 변환 정렬 기, 필터 enumerables에서 항목을 검색하는 함수의 큰 범위를 제공한다. 개발자가 Elixir 코드에서 자주 사용하는 모듈 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1d4fbc9808f8e26c00c234d6fa1459002dc186de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;File&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="e840334dc33e37be12e55cfa6bc3b7e8c169342a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="ef38704061a34457ddb379b41a2b80be49207a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Inspect&lt;/code&gt; protocol is the protocol used to transform any data structure into a readable textual representation. This is what tools like IEx use to print results:</source>
          <target state="translated">&lt;code&gt;Inspect&lt;/code&gt; 프로토콜은 판독의 텍스트 표현에 어떤 데이터 구조를 변환하는 데 사용되는 프로토콜이다. 이것은 IEx와 같은 도구가 결과를 인쇄하는 데 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="867c539e4d21456c5aa36b2d220867f9a7212a1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;KV.RouterTest&lt;/code&gt; truly has to be distributed, as its purpose is to test the distribution. However, the test in &lt;code&gt;KVServerTest&lt;/code&gt; was only made distributed because we had a hardcoded distributed routing table, which we couldn&amp;rsquo;t configure, but now we can!</source>
          <target state="translated">&lt;code&gt;KV.RouterTest&lt;/code&gt; 은 진정으로 그 목적은 배포를 테스트하는 것입니다으로 분산되어야한다. 그러나 &lt;code&gt;KVServerTest&lt;/code&gt; 의 테스트는 구성 할 수없는 하드 코딩 된 분산 라우팅 테이블이 있었기 때문에 배포 만되었지만 이제는 가능합니다!</target>
        </trans-unit>
        <trans-unit id="98cbbae17162ecee1b3987ff4642880f4c337dca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MyApp&lt;/code&gt; module given to &lt;code&gt;:mod&lt;/code&gt; needs to implement the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; behaviour. This can be done by putting &lt;code&gt;use Application&lt;/code&gt; in that module and implementing the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback, for example:</source>
          <target state="translated">&lt;code&gt;MyApp&lt;/code&gt; 를의 에게 주어진 모듈 &lt;code&gt;:mod&lt;/code&gt; 필요가 구현하는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 동작을. 이를 &lt;code&gt;use Application&lt;/code&gt; 해당 모듈에 Application 을 사용 하고 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백을 구현하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb345c09eb20de824e9541a17d7bf17e012b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="c334edecfba6073bd7010af2e40dba91546f5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol can now be implemented for &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 &lt;code&gt;Any&lt;/code&gt; 에 대해 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e306d6fedad75e62089879bf19da4f3ec37aa79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Size&lt;/code&gt; protocol expects a function called &lt;code&gt;size&lt;/code&gt; that receives one argument (the data structure we want to know the size of) to be implemented. We can now implement this protocol for the data structures that would have a compliant implementation:</source>
          <target state="translated">&lt;code&gt;Size&lt;/code&gt; 프로토콜은 기능이라고 예상 &lt;code&gt;size&lt;/code&gt; 하나 개의 인수 구현 될 (우리는의 크기를 알고 싶은 데이터 구조)를 받는다. 이제 우리는 호환 구현을 갖는 데이터 구조에 대해이 프로토콜을 구현할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="db5fefc34081f3a8d848c3114be6230d0555c05c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression:</source>
          <target state="translated">&lt;code&gt;User switch command&lt;/code&gt; 또한 평가자가 무한 루프에 걸리면 또는 예를 들어, 기존 세션을 종료하는 데 사용할 수있는 문제가 발생할 입력하는 식 때 :</target>
        </trans-unit>
        <trans-unit id="7f41e81f3757a1435933e38bc5bfe28881ade0a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User switch command&lt;/code&gt; menu also allows developers to connect to remote shells using the &lt;code&gt;r&lt;/code&gt; command. A topic which we will discuss next.</source>
          <target state="translated">&lt;code&gt;User switch command&lt;/code&gt; 메뉴는 개발자가 사용하여 원격 쉘에 연결할 수 있습니다 &lt;code&gt;r&lt;/code&gt; 에 명령을. 다음에 논의 할 주제입니다.</target>
        </trans-unit>
        <trans-unit id="57c1d154dd951f8282bee6bdc6065d02cb12023d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[head | tail]&lt;/code&gt; format is not only used on pattern matching but also for prepending items to a list:</source>
          <target state="translated">&lt;code&gt;[head | tail]&lt;/code&gt; 형식은 패턴 일치뿐만 아니라 항목을 목록에 추가 할 때도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1f98818191e0504c9112dc757cd520cf41584f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause can be specified even if there are no match clauses. The timeout value given to &lt;code&gt;after&lt;/code&gt; can be any expression evaluating to one of the allowed values:</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절은 일치하는 조항이없는 경우에도 지정할 수 있습니다. &lt;code&gt;after&lt;/code&gt; 제공된 시간 종료 값 은 허용되는 값 중 하나로 평가되는 표현식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4dc8c4ed1d9e88f4741236f5ec92ee315c9d28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;after&lt;/code&gt; clause will be executed regardless of whether or not the tried block succeeds. Note, however, that if a linked process exits, this process will exit and the &lt;code&gt;after&lt;/code&gt; clause will not get run. Thus &lt;code&gt;after&lt;/code&gt; provides only a soft guarantee. Luckily, files in Elixir are also linked to the current processes and therefore they will always get closed if the current process crashes, independent of the &lt;code&gt;after&lt;/code&gt; clause. You will find the same to be true for other resources like ETS tables, sockets, ports and more.</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절에 관계없이 시도 블록이 성공 여부에 실행됩니다. 그러나 연결된 프로세스가 종료되면이 프로세스가 종료되고 &lt;code&gt;after&lt;/code&gt; 절이 실행되지 않습니다. 따라서 &lt;code&gt;after&lt;/code&gt; 는 부드러운 보증 만 제공합니다. 운 좋게도 Elixir의 파일은 현재 프로세스에 연결되어 있으므로 &lt;code&gt;after&lt;/code&gt; 절 과 상관없이 현재 프로세스가 충돌하면 항상 닫힙니다 . ETS 테이블, 소켓, 포트 등과 같은 다른 리소스에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="522546706684271ab3f2efbb350890fbe1239f1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assigns&lt;/code&gt; extension is useful when the number of variables required by the template is not specified at compilation time.</source>
          <target state="translated">&lt;code&gt;assigns&lt;/code&gt; 템플릿에 필요한 변수의 수는 컴파일시에 지정되지 않은 경우 확장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="20b542c507c9f404606e6129f6dd5795d8b21d4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a keyword list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 인수는 변수 바인딩의 키워드 목록입니다. &lt;code&gt;opts&lt;/code&gt; 인수는 환경 옵션의 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f9ca71e42e6855918a8f26e42f0cc7edcc80187e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binding&lt;/code&gt; argument is a list of variable bindings. The &lt;code&gt;opts&lt;/code&gt; argument is a keyword list of environment options.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 인수는 변수 바인딩의 목록입니다. &lt;code&gt;opts&lt;/code&gt; 인수는 환경 옵션의 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="43af9d9f02afe40e3a624713286d4df36015f946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports &lt;code&gt;:error&lt;/code&gt; alongside &lt;code&gt;:exit&lt;/code&gt; and &lt;code&gt;:throw&lt;/code&gt; as in Erlang, although this is commonly avoided in favor of &lt;code&gt;raise&lt;/code&gt;/&lt;code&gt;rescue&lt;/code&gt; control mechanisms. One reason for this is that when catching &lt;code&gt;:error&lt;/code&gt;, the error is not automatically transformed into an Elixir error:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 절은 또한 지원 &lt;code&gt;:error&lt;/code&gt; 와 함께 &lt;code&gt;:exit&lt;/code&gt; 과 &lt;code&gt;:throw&lt;/code&gt; 얼랑에서,이 일반적으로 찬성 피할 수 있지만, &lt;code&gt;raise&lt;/code&gt; / &lt;code&gt;rescue&lt;/code&gt; 제어 메커니즘. 이에 대한 한 가지 이유는 &lt;code&gt;:error&lt;/code&gt; 를 잡을 때 오류가 자동으로 Elixir 오류로 변환되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="efeea9a7b42fc8c994bd1aa663c47cac8fa65f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause also supports catching exits and errors. To do that, it allows matching on both the &lt;em&gt;kind&lt;/em&gt; of the caught value as well as the value itself:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 절은 종료되고 오류를 잡기 지원합니다. 이를 위해 catch 된 값 의 &lt;em&gt;종류&lt;/em&gt; 와 값 자체를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24330da6829bfcedd43d719e9d8c6b8cc77a9453" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values, exits, and errors.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 절은 던져 값, 종료 및 오류를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2397a8238f753aef5def5de423d0f7288e2079" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;child_spec/1&lt;/code&gt; function returns the child specification which describes how to start the process, if the process is a worker or a supervisor, if the process is temporary, transient or permanent and so on. The &lt;code&gt;child_spec/1&lt;/code&gt; function is automatically defined when we &lt;code&gt;use Agent&lt;/code&gt;, &lt;code&gt;use GenServer&lt;/code&gt;, &lt;code&gt;use Supervisor&lt;/code&gt;, etc. Let&amp;rsquo;s give it a try in the terminal with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;child_spec/1&lt;/code&gt; 기능은 프로세스가 일시적으로 일시적 또는 영구적 등의 경우 프로세스가 작업자 또는 감독자 인 경우, 프로세스를 시작하는 방법에 대해 설명 자식 사양을 반환합니다. &lt;code&gt;child_spec/1&lt;/code&gt; 우리는 때 기능이 자동으로 정의됩니다 &lt;code&gt;use Agent&lt;/code&gt; , &lt;code&gt;use GenServer&lt;/code&gt; , &lt;code&gt;use Supervisor&lt;/code&gt; 등하자주고 그것으로 터미널에서 시도 &lt;code&gt;iex -S mix&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5076e4aa7f98418aab62c50ce92daa399ad148af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;datetime&lt;/code&gt; is expected to be using the ISO calendar with a year greater than or equal to 0.</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; 일년 0 이상의와 ISO 캘린더를 사용하는 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="a7470ce899e96bb2d28a9c1301a9927e4e0d7efa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 있는 경우 광고가 바이트 라인의 소정 수로 반복되는 &lt;code&gt;:line&lt;/code&gt; 주어진다. 또는 &lt;code&gt;:all&lt;/code&gt; 을 지정하면 전체 &lt;code&gt;device&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18926bc10cd79bf34225eb9fdce31365b1c6d418" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of bytes or line by line if &lt;code&gt;:line&lt;/code&gt; is given. This reads from the IO device as a raw binary.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 있는 경우 광고가 바이트 라인의 소정 수로 반복되는 &lt;code&gt;:line&lt;/code&gt; 주어진다. 이것은 IO 디바이스에서 원시 바이너리로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d123d0b725ad2bf46d13d4f89ecd59664f74da3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 경우 선으로 문자 나 라인의 지정된 수에 의해 반복되는 &lt;code&gt;:line&lt;/code&gt; 주어진다.</target>
        </trans-unit>
        <trans-unit id="8d73a8d9622fd3342e8e37363bb8e4678e91ee6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device&lt;/code&gt; is iterated by the given number of characters or line by line if &lt;code&gt;:line&lt;/code&gt; is given. Alternatively, if &lt;code&gt;:all&lt;/code&gt; is given, then whole &lt;code&gt;device&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 경우 선으로 문자 나 라인의 지정된 수에 의해 반복되는 &lt;code&gt;:line&lt;/code&gt; 주어진다. 또는 &lt;code&gt;:all&lt;/code&gt; 을 지정하면 전체 &lt;code&gt;device&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd6d16ba352ae3e2cd0c595b6f985cf5e9830dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do:&lt;/code&gt; and &lt;code&gt;else:&lt;/code&gt; pairs form a keyword list! In fact, the call above is equivalent to:</source>
          <target state="translated">는 &lt;code&gt;do:&lt;/code&gt; 과 &lt;code&gt;else:&lt;/code&gt; 쌍은 키워드 목록을 형성! 실제로 위의 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="814c3b44f539cbabd4a18b1a20149ed63266fd5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doctest&lt;/code&gt; macro loops through all functions and macros defined in &lt;code&gt;MyModule&lt;/code&gt;, parsing their documentation in search of code examples.</source>
          <target state="translated">&lt;code&gt;doctest&lt;/code&gt; 가 모든 함수 및 매크로를 통해 매크로 루프에 정의 &lt;code&gt;MyModule&lt;/code&gt; 코드 예제의 검색에 자신의 문서를 구문 분석.</target>
        </trans-unit>
        <trans-unit id="c8fc7f9dce0c33872417dd46af42c25ac3d59fce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; is used to set environment variables. In there, you can set vars such as &lt;code&gt;RELEASE_NODE&lt;/code&gt;, &lt;code&gt;RELEASE_COOKIE&lt;/code&gt;, and &lt;code&gt;RELEASE_TMP&lt;/code&gt; to customize your node name, cookie and tmp directory respectively. Whenever &lt;code&gt;env.sh&lt;/code&gt; or &lt;code&gt;env.bat&lt;/code&gt; is invoked, the variables &lt;code&gt;RELEASE_ROOT&lt;/code&gt;, &lt;code&gt;RELEASE_NAME&lt;/code&gt;, &lt;code&gt;RELEASE_VSN&lt;/code&gt;, and &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; have already been set, so you can rely on them. See the section on environment variables for more information.</source>
          <target state="translated">&lt;code&gt;env.sh&lt;/code&gt; 및 &lt;code&gt;env.bat&lt;/code&gt; 는 세트 환경 변수로 사용된다. 여기에서 &lt;code&gt;RELEASE_NODE&lt;/code&gt; , &lt;code&gt;RELEASE_COOKIE&lt;/code&gt; 및 &lt;code&gt;RELEASE_TMP&lt;/code&gt; 와 같은 변수 를 설정하여 노드 이름, 쿠키 및 tmp 디렉토리를 각각 사용자 지정할 수 있습니다. &lt;code&gt;env.sh&lt;/code&gt; 또는 &lt;code&gt;env.bat&lt;/code&gt; 가 호출 될 때마다 &lt;code&gt;RELEASE_ROOT&lt;/code&gt; , &lt;code&gt;RELEASE_NAME&lt;/code&gt; , &lt;code&gt;RELEASE_VSN&lt;/code&gt; 및 &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; 변수 가 이미 설정되어 있으므로 신뢰할 수 있습니다. 자세한 내용은 환경 변수 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d34a58294096caa28e71e9a15e38240b2916397f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; command starts its own instance of the VM but without starting any of the applications in the release and without starting distribution. For example, if you need to do some prep work before running the actual system, like migrating your database, &lt;code&gt;eval&lt;/code&gt; can be a good fit. Just keep in mind any application you may use during eval has to be explicitly loaded and/or started.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 명령은 VM의하지만 릴리스의 모든 응용 프로그램을 시작하지 않고 및 유통을 시작하지 않고 자신의 인스턴스를 시작합니다. 예를 들어 데이터베이스 마이그레이션과 같은 실제 시스템을 실행하기 전에 몇 가지 준비 작업을 수행해야하는 경우 &lt;code&gt;eval&lt;/code&gt; 이 적합 할 수 있습니다. 평가하는 동안 사용할 수있는 모든 응용 프로그램은 명시 적으로로드 및 / 또는 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7d3bd404eb61a5ace38bb205d91cc9fe9dacd66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; argument is usually a keyword list with field names as atom keys and default values as corresponding values. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; also supports a list of atoms as its argument: in that case, the atoms in the list will be used as the struct's field names and they will all default to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fields&lt;/code&gt; 인수는 일반적으로 원자의 키와 해당 값으로 기본 값으로 필드 이름과 키워드 목록입니다. &lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; 은 또한 인수로 원자 목록을 지원합니다.이 경우 목록의 원자는 구조체의 필드 이름으로 사용되며 모두 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f8139dc2ac79685ca13901ec7c7e0bf0f70fcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;container&lt;/code&gt;) and must return a two-element tuple &lt;code&gt;{get_value, update_value}&lt;/code&gt;: the &quot;get&quot; value &lt;code&gt;get_value&lt;/code&gt; (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; (&lt;code&gt;update_value&lt;/code&gt;). &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value should be removed from the container and returned.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 인수의 값 수신 &lt;code&gt;key&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 하면 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;container&lt;/code&gt; )와, 2 요소 튜플 반환해야합니다 &lt;code&gt;{get_value, update_value}&lt;/code&gt; : 값 &quot;GET&quot; &lt;code&gt;get_value&lt;/code&gt; 이전에 작동 할 수 있습니다 (검색된 값을, 반환되고) &lt;code&gt;key&lt;/code&gt; ( &lt;code&gt;update_value&lt;/code&gt; )에 저장 될 새 값 입니다. &lt;code&gt;fun&lt;/code&gt; 은 &lt;code&gt;:pop&lt;/code&gt; 을 반환 할 수도 있습니다 . 즉, 현재 값을 컨테이너에서 제거하여 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab82e984fadbbf0154d9f589974323854d91ddd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return one of the following values:</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 인수의 값 수신 &lt;code&gt;key&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 하면 &lt;code&gt;key&lt;/code&gt; 존재하지 않는)과 다음 값 중 하나를 반환해야합니다 :</target>
        </trans-unit>
        <trans-unit id="15ae90181c3399df6f57363e86986a58cdd69c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inspect/1&lt;/code&gt; function is used to convert a data structure&amp;rsquo;s internal representation into a string, typically for printing. Notice that when the &lt;code&gt;receive&lt;/code&gt; block gets executed the sender process we have spawned may already be dead, as its only instruction was to send a message.</source>
          <target state="translated">는 &lt;code&gt;inspect/1&lt;/code&gt; 기능은 일반적으로 인쇄 문자열에 데이터 구조의 내부 표현으로 변환하기 위해 사용된다. (가) 때 통지 &lt;code&gt;receive&lt;/code&gt; 블록은 우리가 유일한 명령은 메시지를 보낼 수 있었다으로 이미 죽었을 수도 산란 한 발송 프로세스를 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="409be34f87b611c8cf8263c5eb6c08385aeb1ddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;install&lt;/code&gt; command must be executed as an administrator.</source>
          <target state="translated">&lt;code&gt;install&lt;/code&gt; 명령은 관리자 권한으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4ef8eb0a2e7ca9a57a606a0bc63171348ce16a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated and &lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;all protocols were consolidated as described in the Getting Started guide&lt;/a&gt;. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;lib/kv.ex&lt;/code&gt; 파일은 컴파일 된 응용 프로그램 매니페스트라는 이름의 &lt;code&gt;kv.app&lt;/code&gt; 가 생성 및 &lt;a href=&quot;../protocols#protocol-consolidation&quot;&gt;시작하기 안내서에 설명 된대로 모든 프로토콜을 통합했다&lt;/a&gt; . 모든 컴파일 아티팩트는 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 옵션을 사용하여 &lt;code&gt;_build&lt;/code&gt; 디렉토리에 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="afab5577848b6315338da48841f3a29c305f64dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lib/kv.ex&lt;/code&gt; file was compiled, an application manifest named &lt;code&gt;kv.app&lt;/code&gt; was generated. All compilation artifacts are placed inside the &lt;code&gt;_build&lt;/code&gt; directory using the options defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;lib/kv.ex&lt;/code&gt; 파일은 매니페스트라는 응용 프로그램 컴파일 &lt;code&gt;kv.app&lt;/code&gt; 가 발생했습니다. 모든 컴파일 아티팩트는 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 옵션을 사용하여 &lt;code&gt;_build&lt;/code&gt; 디렉토리에 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="fb93b5ae3cb838786493785c00bd4b6f99477ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line_or_bytes&lt;/code&gt; argument configures how the file is read when streaming, by &lt;code&gt;:line&lt;/code&gt; (default) or by a given number of bytes.</source>
          <target state="translated">은 &lt;code&gt;line_or_bytes&lt;/code&gt; 하여 스트리밍 할 때 파일을 읽는 방법 인수를 구성을 &lt;code&gt;:line&lt;/code&gt; (기본값) 또는 지정된 바이트 수에 의해.</target>
        </trans-unit>
        <trans-unit id="fe606eea5a853797263dc491beb562e8cbcc73c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logger&lt;/code&gt; application ships as part of Elixir. We stated that our application needs it by specifying it in the &lt;code&gt;:extra_applications&lt;/code&gt; list in &lt;code&gt;mix.exs&lt;/code&gt;. See the &lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;official docs&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;logger&lt;/code&gt; 비약의 일부로 응용 프로그램 제공됩니다. 우리는 우리의 응용 프로그램에 지정하여 필요하다고 언급 &lt;code&gt;:extra_applications&lt;/code&gt; 의 목록 &lt;code&gt;mix.exs&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/logger&quot;&gt;공식 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54af23949bca7ed78e1b2333920d90c038af7ad6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mix test&lt;/code&gt; command also allows us to dynamically include and exclude tags. For example, we can run &lt;code&gt;$ mix test --include distributed&lt;/code&gt; to run distributed tests regardless of the value set in &lt;code&gt;test/test_helper.exs&lt;/code&gt;. We could also pass &lt;code&gt;--exclude&lt;/code&gt; to exclude a particular tag from the command line. Finally, &lt;code&gt;--only&lt;/code&gt; can be used to run only tests with a particular tag:</source>
          <target state="translated">또한 &lt;code&gt;mix test&lt;/code&gt; 명령을 사용하면 태그를 동적으로 포함 및 제외 할 수 있습니다. 예를 들어, &lt;code&gt;test/test_helper.exs&lt;/code&gt; 에 설정된 값에 관계없이 &lt;code&gt;$ mix test --include distributed&lt;/code&gt; 를 실행하여 분산 테스트를 실행할 수 있습니다 . 명령 줄에서 특정 태그를 제외하기 위해 &lt;code&gt;--exclude&lt;/code&gt; 를 전달할 수도 있습니다 . 마지막으로 &lt;code&gt;--only&lt;/code&gt; 는 특정 태그로 테스트 만 실행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75c3e7f0c2115829278fc15321400f8791e52369" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mod&lt;/code&gt; key of an application resource file configures an application callback module and start argument:</source>
          <target state="translated">응용 프로그램 자원 파일 의 &lt;code&gt;mod&lt;/code&gt; 키는 응용 프로그램 콜백 모듈 및 시작 인수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="9164f612584725a4293d48491d9ba4d200ea917a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 이 수신 기능도 지원하는 &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cefbaf0f99d8706ada7dd49301877753ff097956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; received by this function are also supported by &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 이 기능에 의해 수신도 지원하는 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64284a2724bf8bf1be42ef3f1c05bbea72ce9fee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is not received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 인수는 일치하는 패턴해야합니다. 메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신되지 않으면 failure_message와 함께 &lt;code&gt;failure_message&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="306d8664f10996ce7979609652732704d345ac55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 인수는 일치하는 패턴해야합니다. 메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신 되면 failure_message와 &lt;code&gt;failure_message&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0b8cb821a5d5214e8e6bc4e51c9c7ff6f736aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was not received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 인수는 일치하는 패턴해야합니다. 메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신되지 않은 경우 failure_message와 &lt;code&gt;failure_message&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05af0549cba6832bb035eed4973d7149b45f6ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument must be a match pattern. Flunks with &lt;code&gt;failure_message&lt;/code&gt; if a message matching &lt;code&gt;pattern&lt;/code&gt; was received.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 인수는 일치하는 패턴해야합니다. 메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신 된 경우 failure_message와 &lt;code&gt;failure_message&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df3b9d4931bcfe8e3dcb9ad739101300cbf08327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a list of strings, a regular expression, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 문자열, 문자열 목록, 정규 표현식, 또는 컴파일 된 패턴이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9712132d8ecb090f4be0f4f06a8c889cede54cae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; may be a string, a regular expression, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 문자열, 정규 표현식, 또는 컴파일 된 패턴이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e822b0c23d86ef4a2e7320c3e2f68f5b6a5886" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_line/1&lt;/code&gt; implementation receives data from the socket using &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; and &lt;code&gt;write_line/2&lt;/code&gt; writes to the socket using &lt;code&gt;:gen_tcp.send/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read_line/1&lt;/code&gt; 구현하여 소켓으로부터 데이터를 수신한다 &lt;code&gt;:gen_tcp.recv/2&lt;/code&gt; 및 &lt;code&gt;write_line/2&lt;/code&gt; 기입하여 소켓 &lt;code&gt;:gen_tcp.send/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4738ad60c532661639b80291c79bbfd95de51f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replacement&lt;/code&gt; may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; 문자열 또는 유사한 패턴을 수신하고, 문자열 또는 iodata로 여분을 반환해야 함수일 수있다.</target>
        </trans-unit>
        <trans-unit id="9c0458fa683a21c30d6bb8dd696e33377e0fc149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rescue&lt;/code&gt; clause is used to handle exceptions while the &lt;code&gt;catch&lt;/code&gt; clause can be used to catch thrown values and exits. The &lt;code&gt;else&lt;/code&gt; clause can be used to control flow based on the result of the expression. &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; clauses work based on pattern matching (similar to the &lt;code&gt;case&lt;/code&gt; special form).</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt; 절은 동안 예외를 처리하는 데 사용됩니다 &lt;code&gt;catch&lt;/code&gt; 절을 캐치 던져 값과 종료에 사용할 수 있습니다. &lt;code&gt;else&lt;/code&gt; 절 식의 결과에 기초하여 흐름 제어하는데 사용될 수있다. &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;rescue&lt;/code&gt; 및 &lt;code&gt;else&lt;/code&gt; 절은 패턴 일치 ( &lt;code&gt;case&lt;/code&gt; 특수 양식 과 유사)를 기반으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="8d1df58d3bea703fd1bbf8c012df285de49b968d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup_all&lt;/code&gt; callbacks are invoked only once per module, before any test is run. All &lt;code&gt;setup&lt;/code&gt; callbacks are run before each test. No callback is run if the test case has no tests or all tests have been filtered out.</source>
          <target state="translated">&lt;code&gt;setup_all&lt;/code&gt; 의 모든 테스트를 실행하기 전에 콜백은 오직 모듈 당 한 번만 호출됩니다. 모든 &lt;code&gt;setup&lt;/code&gt; 콜백은 각 테스트 전에 실행됩니다. 테스트 케이스에 테스트가 없거나 모든 테스트가 필터링 된 경우 콜백이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd0f9431cca0c37985b6fe072752b25bee336f01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns &lt;code&gt;:ok&lt;/code&gt; if retrieving the &lt;code&gt;size&lt;/code&gt; of the &lt;code&gt;enumerable&lt;/code&gt; is cheap, fast and takes constant time. Otherwise the simplest of operations, such as &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt;, will become too expensive.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 이 함수에 의해 반환되는 값은 따라서 매우 중요하다, 경계 확인을 위해 사용되는이 기능에만 반환 &lt;code&gt;:ok&lt;/code&gt; 검색하는 경우 &lt;code&gt;size&lt;/code&gt; 의 &lt;code&gt;enumerable&lt;/code&gt; 빠르고 저렴하고 일정 시간이 걸립니다. 그렇지 않으면 &lt;code&gt;Enum.at(enumerable, 0)&lt;/code&gt; 과 같은 가장 간단한 작업 이 너무 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="c3101c570b674a9ec75b76ebada532649060afec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spec&lt;/code&gt; consists of a list of three part tuples, in the shape of &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 형상으로 세 부분 튜플들의 목록으로 구성 &lt;code&gt;[{match_pattern, guards, body}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135f720ae9d7a6885e26e8bce732a1ea91412353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; position is a number &lt;code&gt;&amp;gt;= 0&lt;/code&gt; and guaranteed to exist in the &lt;code&gt;enumerable&lt;/code&gt;. The length is a number &lt;code&gt;&amp;gt;= 1&lt;/code&gt; in a way that &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt;, where &lt;code&gt;count&lt;/code&gt; is the maximum amount of elements in the enumerable.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 위치가 번호 &lt;code&gt;&amp;gt;= 0&lt;/code&gt; 및 존재 보장 &lt;code&gt;enumerable&lt;/code&gt; . 길이는 &lt;code&gt;start + length &amp;lt;= count&lt;/code&gt; 와 같은 방식으로 숫자 &lt;code&gt;&amp;gt;= 1&lt;/code&gt; 이며 , 여기서 &lt;code&gt;count&lt;/code&gt; 는 열거 가능한 최대 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="e168d9178d44f7f46283a9cdf56615be6a7637ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_link/1&lt;/code&gt; (or a custom) is then called for each child process. The &lt;code&gt;start_link/1&lt;/code&gt; function must return &lt;code&gt;{:ok, pid}&lt;/code&gt; where &lt;code&gt;pid&lt;/code&gt; is the process identifier of a new process that is linked to the supervisor. The child process usually starts its work by executing the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback. Generally speaking, the &lt;code&gt;init&lt;/code&gt; callback is where we initialize and configure the child process.</source>
          <target state="translated">&lt;code&gt;start_link/1&lt;/code&gt; (또는 사용자 정의)은 다음 각 자식 프로세스라고합니다. &lt;code&gt;start_link/1&lt;/code&gt; 함수를 반환해야합니다 &lt;code&gt;{:ok, pid}&lt;/code&gt; 여기서 &lt;code&gt;pid&lt;/code&gt; 는 감독자에 연결된 새로운 프로세스의 프로세스 ID입니다. 자식 프로세스는 보통 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 을 실행하여 작업을 시작합니다 . 일반적으로 &lt;code&gt;init&lt;/code&gt; 콜백은 자식 프로세스를 초기화하고 구성하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="a8a0cec068e183c964ba134c5b70d885df25681c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start_supervised!&lt;/code&gt; function was injected into our test module by &lt;code&gt;use ExUnit.Case&lt;/code&gt;. It does the job of starting the &lt;code&gt;KV.Registry&lt;/code&gt; process, by calling its &lt;code&gt;start_link/1&lt;/code&gt; function. The advantage of using &lt;code&gt;start_supervised!&lt;/code&gt; is that ExUnit will guarantee that the registry process will be shutdown &lt;strong&gt;before&lt;/strong&gt; the next test starts. In other words, it helps guarantee that the state of one test is not going to interfere with the next one in case they depend on shared resources.</source>
          <target state="translated">&lt;code&gt;start_supervised!&lt;/code&gt; 함수는 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 를 사용하여 테스트 모듈에 주입되었습니다 . &lt;code&gt;KV.Registry&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 함수를 호출 하여 KV.Registry 프로세스 를 시작하는 작업을 수행합니다. &lt;code&gt;start_supervised!&lt;/code&gt; 사용의 장점 ! ExUnit은 다음 테스트가 시작 &lt;strong&gt;되기 전에&lt;/strong&gt; 레지스트리 프로세스가 종료되도록 보장 합니다. 다시 말해, 한 테스트 상태가 공유 리소스에 의존하는 경우 다음 테스트를 방해하지 않도록 보장하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b4592fb7e0957a1fc52071c848d5e17c99c69385" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;starting_on&lt;/code&gt; represents the starting day of the week. All calendars must support at least the &lt;code&gt;:default&lt;/code&gt; value. They may also support other values representing their days of the week.</source>
          <target state="translated">&lt;code&gt;starting_on&lt;/code&gt; 은 한주 의 시작일을 나타냅니다. 모든 달력은 최소한 &lt;code&gt;:default&lt;/code&gt; 값을 지원해야합니다 . 또한 요일을 나타내는 다른 값을 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c3b0210439efc565cc631c8fa0e308643197cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;string()&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;string()&lt;/code&gt; 타입</target>
        </trans-unit>
        <trans-unit id="61ebcef3a8537f672d50ed7bff3d6db73d860578" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 인수 (정의 원자 수있다 &lt;code&gt;defstruct&lt;/code&gt; ) 또는 &lt;code&gt;struct&lt;/code&gt; 자체. 두 번째 인수는 열거하는 동안 두 요소 튜플 (키-값 쌍)을 방출 하는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38386201665d1e0b386055fc8c5fb1dd196e0581" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; argument may be an atom (which defines &lt;code&gt;defstruct&lt;/code&gt;) or a &lt;code&gt;struct&lt;/code&gt; itself. The second argument is any &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that emits two-element tuples (key-value pairs) during enumeration.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 인수 (정의 원자 수있다 &lt;code&gt;defstruct&lt;/code&gt; ) 또는 &lt;code&gt;struct&lt;/code&gt; 자체. 두 번째 인수는 열거 중에 요소가 두 개인 튜플 (키-값 쌍)을 내보내는 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3ca4af46f233ac35dc3b79485d62ec51b88145af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subject&lt;/code&gt; is always a string.</source>
          <target state="translated">&lt;code&gt;subject&lt;/code&gt; 항상 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="bae6804f43f42b63c5528bcc2381471d0d39bad4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에 정의 된 참조 여야 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . 작업은 여전히 ​​호출자에게 연결됩니다. 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; 를 참조하고 연결되지 않은 변형의 경우 &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; 를 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="08337e923feb72c49328d32727f3434709f1f848" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에 정의 된 참조 여야 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . 작업은 호출자에게 연결되지 않습니다 . 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="fa2ecf30353c15851b99330eab13deee5216e86a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task will still be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information and &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt; for a non-linked variant.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에 정의 된 참조 여야 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . 작업은 여전히 ​​호출자에게 연결됩니다. 자세한 내용 은 &lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; 및 연결되지 않은 변형의 경우 &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="549a87864f7a5407aab555d12f030b23c5278a92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supervisor&lt;/code&gt; must be a reference as defined in &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The task won't be linked to the caller, see &lt;a href=&quot;task#async/3&quot;&gt;&lt;code&gt;Task.async/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에 정의 된 참조 여야 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; . 작업은 호출자와 연결되지 않습니다 . 자세한 내용 은 &lt;a href=&quot;task#async/3&quot;&gt; &lt;code&gt;Task.async/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc1957bc0923712dab3fe287b0e8df3bec3ec39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; macro</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 매크로</target>
        </trans-unit>
        <trans-unit id="6bf883ffd229719baaf3e026049bc07e3e3fdc26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument passed to &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; is usually &lt;code&gt;:normal&lt;/code&gt; unless in a distributed setup where application takeovers and failovers are configured. Distributed applications are beyond the scope of this documentation.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인수는 전달 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 일반적으로 &lt;code&gt;:normal&lt;/code&gt; 응용 프로그램의 인수 및 장애 조치가 구성되는 경우 분산 설치에서 제외하고. 분산 응용 프로그램은이 설명서에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69149411f0751c47ab43a2cb8ee2352867ce8c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument specifies the type of the application:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인수는 응용 프로그램의 유형을 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="f6663df984e95662866d3ab67e965809a6b673af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update_in/2&lt;/code&gt; macro is similar but allows us to pass a function that controls how the value changes. For example, let&amp;rsquo;s remove &amp;ldquo;Clojure&amp;rdquo; from Mary&amp;rsquo;s list of languages:</source>
          <target state="translated">&lt;code&gt;update_in/2&lt;/code&gt; 매크로는 비슷하지만 컨트롤 값을 변경하는 방법을하는 기능을 전달할 수있게 해준다. 예를 들어 Mary의 언어 목록에서 &quot;Clojure&quot;를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="8f6feff517dde91abd98ddcc94fc5f8ee947ce68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; macro is frequently used as an extension point. This means that, when you &lt;code&gt;use&lt;/code&gt; a module &lt;code&gt;FooBar&lt;/code&gt;, you allow that module to inject &lt;em&gt;any&lt;/em&gt; code in the current module, such as importing itself or other modules, defining new functions, setting a module state, etc.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 매크로는 자주 확장 지점으로 사용됩니다. 즉, &lt;code&gt;FooBar&lt;/code&gt; 모듈 을 &lt;code&gt;use&lt;/code&gt; 하면 해당 모듈이 자체 또는 다른 모듈 가져 오기, 새 함수 정의, 모듈 상태 설정 등과 같은 현재 모듈에 코드 를 삽입 &lt;em&gt;할 수&lt;/em&gt; 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="443668287cbb8f84b2664ce3f01400a9552185b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, and &lt;code&gt;utf32&lt;/code&gt; types are for Unicode code points. They can also be applied to literal strings and charlists:</source>
          <target state="translated">&lt;code&gt;utf8&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; 및 &lt;code&gt;utf32&lt;/code&gt; 유형은 유니 코드 코드 포인트를위한 것입니다. 리터럴 문자열과 문자 목록에도 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d593cc256ac243970966e445b59ce382b3d1c4ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vm.args&lt;/code&gt; file may contain any of the VM flags accepted by the &lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt;&lt;code&gt;erl&lt;/code&gt; command&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vm.args&lt;/code&gt; 의 파일에서 허용하는 VM 플래그의 포함 할 수 &lt;a href=&quot;http://erlang.org/doc/man/erl.html&quot;&gt; &lt;code&gt;erl&lt;/code&gt; 명령을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="766b25b711b24bf14734bf86264816b50201e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;xref&lt;/code&gt; task expects a mode as first argument:</source>
          <target state="translated">&lt;code&gt;xref&lt;/code&gt; 작업은 첫 번째 인수로 모드를 기대한다 :</target>
        </trans-unit>
        <trans-unit id="848f828061a57fea28024ac6791811ddcc578da8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{module, function}&lt;/code&gt; will be invoked with four arguments:</source>
          <target state="translated">&lt;code&gt;{module, function}&lt;/code&gt; 사 개 인수와 함께 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="6bb6f7b835bb4273bfb73268cdb830e1eaa1b0c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; operator is mostly useful when there is a desire to execute a series of operations resembling a pipeline:</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt; 파이프 라인을 닮은 일련의 작업을 실행하는 욕구가있을 때 운전자는 대부분 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="e7c15f5a444d0eb501f58185ab4ff6cc148686d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&amp;gt;&lt;/code&gt; symbol used in the snippet above is the &lt;strong&gt;pipe operator&lt;/strong&gt;: it takes the output from the expression on its left side and passes it as the first argument to the function call on its right side. It&amp;rsquo;s similar to the Unix &lt;code&gt;|&lt;/code&gt; operator. Its purpose is to highlight the data being transformed by a series of functions. To see how it can make the code cleaner, have a look at the example above rewritten without using the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt; 상기 코드에서 사용되는 기호가있다 &lt;strong&gt;파이프 연산자&lt;/strong&gt; : 그것의 왼쪽 표현식의 출력을 취하고, 우측 함수 호출에 첫 번째 인수로서 전달한다. 유닉스와 비슷합니다. &lt;code&gt;|&lt;/code&gt; 운영자. 그 목적은 일련의 기능에 의해 변환되는 데이터를 강조하는 것입니다. 코드를 더 깔끔하게 만드는 방법을 보려면 &lt;code&gt;|&amp;gt;&lt;/code&gt; 연산자를 사용하지 않고 다시 작성된 위의 예를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="de83fadff1ba2a72273182089ea2a050990085bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~c&lt;/code&gt; sigil is useful for generating char lists that contain single quotes:</source>
          <target state="translated">&lt;code&gt;~c&lt;/code&gt; 시길는 작은 따옴표를 포함하는 문자 목록을 생성하는 데 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="281b4a2fc5fd64a2cedf95577018a34d44729cd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~s&lt;/code&gt; sigil is used to generate strings, like double quotes are. The &lt;code&gt;~s&lt;/code&gt; sigil is useful when a string contains double quotes:</source>
          <target state="translated">&lt;code&gt;~s&lt;/code&gt; 따옴표가있는 것처럼시길는 문자열을 생성하는 데 사용됩니다. &lt;code&gt;~s&lt;/code&gt; 문자열을 큰 따옴표가 포함되어있는 경우시길 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="1b5ce296d52d56b387e6952a8ac2c01f7f747b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil also accepts the &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; modifiers (for char lists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:</source>
          <target state="translated">&lt;code&gt;~w&lt;/code&gt; 인장 또한 허용 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 및 결과리스트의 요소의 데이터 유형을 지정 (각각 문자 목록, 문자열 및 원자에 대한) 개질제 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9578a70bcff0146fc766139c2fb2691deada995b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~w&lt;/code&gt; sigil is used to generate lists of words (&lt;em&gt;words&lt;/em&gt; are just regular strings). Inside the &lt;code&gt;~w&lt;/code&gt; sigil, words are separated by whitespace.</source>
          <target state="translated">&lt;code&gt;~w&lt;/code&gt; 시길는 단어의 목록을 (생성하는 데 사용되는 &lt;em&gt;단어는&lt;/em&gt; 그냥 평범한 문자열). 내부 &lt;code&gt;~w&lt;/code&gt; 시길, 단어는 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="57c0bcba93565ebcb726bbcf9fe5e3a854d68664" translate="yes" xml:space="preserve">
          <source>The AST for a pipeline (a sequence of applications of &lt;code&gt;|&amp;gt;&lt;/code&gt;) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most &lt;code&gt;:|&amp;gt;&lt;/code&gt; (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</source>
          <target state="translated">파이프 라인에 대한 AST (의 응용 프로그램의 순서는 &lt;code&gt;|&amp;gt;&lt;/code&gt; ) 이항 연산자 또는 함수의 응용 프로그램의 시퀀스의 AST와 유사하다 : 최상위 표현이 가장 오른쪽 &lt;code&gt;:|&amp;gt;&lt;/code&gt; (될 수있는 마지막 하나입니다 실행) 및 왼쪽과 오른쪽이 인수입니다.</target>
        </trans-unit>
        <trans-unit id="22673f1e15930ac4a2bce8fc889928e4bf1f922d" translate="yes" xml:space="preserve">
          <source>The BREAK menu</source>
          <target state="translated">BREAK 메뉴</target>
        </trans-unit>
        <trans-unit id="98504b06eb756100aa8d0fe1b8a5bed8131e1638" translate="yes" xml:space="preserve">
          <source>The Client API</source>
          <target state="translated">클라이언트 API</target>
        </trans-unit>
        <trans-unit id="de89441db4562cab93bdfbf9ab1875a33c2df7e4" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Date 구조체에는 년, 월, 일 및 달력 필드가 포함됩니다. &lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~D&lt;/code&gt; ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 새 날짜를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="087349ac5d28e5bd9b6d72d6f50436cef7a3d724" translate="yes" xml:space="preserve">
          <source>The Date struct contains the fields year, month, day and calendar. New dates can be built with the &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~D&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_D/2&quot;&gt;&lt;code&gt;Kernel.sigil_D/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Date 구조체에는 연도, 월, 일 및 달력 필드가 포함됩니다. &lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~D&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_D/2&quot;&gt; &lt;code&gt;Kernel.sigil_D/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 새 날짜를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60739ce280ae99907b36b37adf6ef92a05aaedd6" translate="yes" xml:space="preserve">
          <source>The Elixir AST</source>
          <target state="translated">엘릭서 AST</target>
        </trans-unit>
        <trans-unit id="b354da44a5ccc03b14d8e9e9f977406245074d69" translate="yes" xml:space="preserve">
          <source>The Elixir guides are also available in EPUB format:</source>
          <target state="translated">엘릭서 가이드는 EPUB 형식으로도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3b88c39f2093f79b409f882370622044ce70ae" translate="yes" xml:space="preserve">
          <source>The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the &lt;code&gt;bin_opt_info&lt;/code&gt; compiler option:</source>
          <target state="translated">Erlang 컴파일러는 이진 생성 및 일치에 대한 여러 가지 최적화를 제공 할 수 있습니다. 최적화 출력을 보려면 &lt;code&gt;bin_opt_info&lt;/code&gt; 컴파일러 옵션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7953816f5ef9843a5ed4589ec36cf1a54fdf799d" translate="yes" xml:space="preserve">
          <source>The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.</source>
          <target state="translated">GenServer 동작은 일반적인 클라이언트-서버 상호 작용을 추상화합니다. 개발자는 원하는 콜백 및 기능 만 구현하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3d66e19aeb4f8b03c43c83bf06d0a7f010db09c4" translate="yes" xml:space="preserve">
          <source>The GenServer name</source>
          <target state="translated">GenServer 이름</target>
        </trans-unit>
        <trans-unit id="4c83968c19110a694ab1613224a8a36aaf6e3f41" translate="yes" xml:space="preserve">
          <source>The IEx.Server.</source>
          <target state="translated">IEx.Server.</target>
        </trans-unit>
        <trans-unit id="06223706895cabbf123c8e779883d2c10704e930" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras:</source>
          <target state="translated">ISO 달력에는 두 가지 시대가 있습니다.</target>
        </trans-unit>
        <trans-unit id="abfb693f46640a1c9464403f477ffc2622e7b611" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the &quot;current era&quot; (CE) which starts in year &lt;code&gt;1&lt;/code&gt; and is defined as era &lt;code&gt;1&lt;/code&gt;. And &quot;before the current era&quot; (BCE) for those years less than &lt;code&gt;1&lt;/code&gt;, defined as era &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">ISO 달력에는 두 개의 시대가 있습니다. &quot;현재 시대&quot;(CE) 는 &lt;code&gt;1&lt;/code&gt; 년에 시작하여 시대 &lt;code&gt;1&lt;/code&gt; 로 정의됩니다 . 그리고 시대 &lt;code&gt;0&lt;/code&gt; 으로 정의되는 &lt;code&gt;1&lt;/code&gt; 미만의 연도에 대한 &quot;현재 시대 이전&quot;(BCE) .</target>
        </trans-unit>
        <trans-unit id="25aef49825211907484d43e756114a0b1fa27f36" translate="yes" xml:space="preserve">
          <source>The ISO calendar has two eras: the current era which starts in year 1 and is defined as era &quot;1&quot;. And a second era for those years less than 1 defined as era &quot;0&quot;.</source>
          <target state="translated">ISO 캘린더에는 두 가지 기간이 있습니다. 현재 연도는 1 년차에 시작하여 &quot;1&quot;로 정의됩니다. 그리고 1 미만의 기간 동안 &quot;0&quot;으로 정의 된 두 번째 시대.</target>
        </trans-unit>
        <trans-unit id="1a856fcbbb476ea67477f19a707dbe002ca4c6dc" translate="yes" xml:space="preserve">
          <source>The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the &quot;did you mean?&quot; functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the &lt;a href=&quot;#jaro_distance/2&quot;&gt;&lt;code&gt;jaro_distance/2&lt;/code&gt;&lt;/a&gt; score.</source>
          <target state="translated">Jaro 거리 측정법은 사람 이름과 같은 짧은 문자열에 가장 적합합니다. 엘릭서 자체는이 기능을 사용하여 &quot;의미 있습니까?&quot; 기능. 예를 들어, 모듈에서 함수를 호출 할 때 함수 이름에 오타가있는 경우 &lt;a href=&quot;#jaro_distance/2&quot;&gt; &lt;code&gt;jaro_distance/2&lt;/code&gt; &lt;/a&gt; 점수를 기반으로 사용 가능한 가장 유사한 함수 이름을 제안하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2243840442a8f32a34eed8592db54cfe259c03b6" translate="yes" xml:space="preserve">
          <source>The Mix build tool automates most of the application management tasks. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mix 빌드 도구는 대부분의 애플리케이션 관리 작업을 자동화합니다. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 는 테스트가 실행되기 전에 애플리케이션 종속성과 애플리케이션 자체를 자동으로 시작합니다. &lt;code&gt;mix run --no-halt&lt;/code&gt; 는 현재 프로젝트를 부팅하며 장기 실행 시스템을 시작하는 데 사용할 수 있습니다. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37173c596301d8be8275b8b1f500a183f87ab7fa" translate="yes" xml:space="preserve">
          <source>The Mix build tool can also be used to start your applications. For example, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; automatically starts your application dependencies and your application itself before your test runs. &lt;code&gt;mix run --no-halt&lt;/code&gt; boots your current project and can be used to start a long running system. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix help run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">믹스 빌드 도구를 사용하여 응용 프로그램을 시작할 수도 있습니다. 예를 들어, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 는 테스트가 실행되기 전에 애플리케이션 종속성 및 애플리케이션 자체를 자동으로 시작합니다. &lt;code&gt;mix run --no-halt&lt;/code&gt; 는 현재 프로젝트를 부팅하며 장기 실행 시스템을 시작하는 데 사용할 수 있습니다. &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix help run&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed1904da080bbb46fb65f0901cdd39a58e1d853d" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation, computed via &lt;code&gt;mix xref warnings&lt;/code&gt;.</source>
          <target state="translated">믹스 컴파일러는 자동으로 더 이상 사용되지 않는 모듈에 대한 호출을 찾고 컴파일 중에 &lt;code&gt;mix xref warnings&lt;/code&gt; 를 통해 계산 된 경고를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="3d196736edd538da5aa685ff060f4fbf30705946" translate="yes" xml:space="preserve">
          <source>The Mix compiler automatically looks for calls to deprecated modules and emit warnings during compilation.</source>
          <target state="translated">Mix 컴파일러는 더 이상 사용되지 않는 모듈에 대한 호출을 자동으로 찾고 컴파일 중에 경고를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="34452d9cfe86755e31b4602a825598bf680a2294" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields</source>
          <target state="translated">Mix.Release 구조체에는 다음과 같은 읽기 전용 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b03d254e8865b80217130278011a49c00a226d" translate="yes" xml:space="preserve">
          <source>The Mix.Release struct has the following read-only fields:</source>
          <target state="translated">Mix.Release 구조체에는 다음과 같은 읽기 전용 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dfe2774b7ab63b2ea9316075f485e26e6770c05" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">NaiveDateTime 구조체에는 년, 월, 일,시, 분, 초, 마이크로 초 및 달력 필드가 포함됩니다. &lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~N&lt;/code&gt; ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 새 순진한 날짜 시간을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be1eb0ffc63d3de62778534778d3195fa7ba19b5" translate="yes" xml:space="preserve">
          <source>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the &lt;a href=&quot;#new/2&quot;&gt;&lt;code&gt;new/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#new/8&quot;&gt;&lt;code&gt;new/8&lt;/code&gt;&lt;/a&gt; functions or using the &lt;code&gt;~N&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_N/2&quot;&gt;&lt;code&gt;Kernel.sigil_N/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">NaiveDateTime 구조체는 연도, 월, 일,시, 분, 초, 마이크로 초 및 달력 필드를 포함합니다. 새로운 순진 날짜 시간은 &lt;a href=&quot;#new/2&quot;&gt; &lt;code&gt;new/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#new/8&quot;&gt; &lt;code&gt;new/8&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~N&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_N/2&quot;&gt; &lt;code&gt;Kernel.sigil_N/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68ea22c150e9e8bf3b5e486f34ccdf3da6885051" translate="yes" xml:space="preserve">
          <source>The Plug library also allows developers to define their own plugs which can be run in a web server:</source>
          <target state="translated">또한 플러그 라이브러리를 통해 개발자는 웹 서버에서 실행할 수있는 자체 플러그를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a12ef86cf46c7d5f545c70ee0f3e00bac2b5a15b" translate="yes" xml:space="preserve">
          <source>The Supervisor name</source>
          <target state="translated">감독자 이름</target>
        </trans-unit>
        <trans-unit id="ec4b01d7b2161ab93486a9f17a632dd403411fb3" translate="yes" xml:space="preserve">
          <source>The Task struct.</source>
          <target state="translated">작업 구조.</target>
        </trans-unit>
        <trans-unit id="5c4c62b39d79d7cb27a5185a0a6601bdd97a3708" translate="yes" xml:space="preserve">
          <source>The Task type.</source>
          <target state="translated">작업 유형</target>
        </trans-unit>
        <trans-unit id="9e011d9f109b1de717a6e789ef4d48fa0c5bf500" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">Time 구조체에는 시간, 분, 초 및 마이크로 초 필드가 포함됩니다. &lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~T&lt;/code&gt; ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 새 시간을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b4c615274399f80e52f24988cf891d5bac9928c" translate="yes" xml:space="preserve">
          <source>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; function or using the &lt;code&gt;~T&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_T/2&quot;&gt;&lt;code&gt;Kernel.sigil_T/2&lt;/code&gt;&lt;/a&gt;) sigil:</source>
          <target state="translated">시간 구조체에는 필드시, 분, 초 및 마이크로 초가 포함됩니다. &lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 &lt;code&gt;~T&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_T/2&quot;&gt; &lt;code&gt;Kernel.sigil_T/2&lt;/code&gt; &lt;/a&gt; 참조 )시길을 사용하여 새로운 시간을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8474ee41c99d01d2c859c45e3ba20cf759140dae" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected.</source>
          <target state="translated">UTF-8 인코딩은 자체 동기화됩니다. 즉, 잘못된 데이터 (즉, 인코딩 정의에 따라 불가능한 데이터)가 발생하면 하나의 코드 포인트 만 거부하면됩니다.</target>
        </trans-unit>
        <trans-unit id="af4cd337ec1852f0dfb035c5a67522bde05e43a9" translate="yes" xml:space="preserve">
          <source>The Unicode standard assigns code points to many of the characters we know. For example, the letter &lt;code&gt;a&lt;/code&gt; has code point &lt;code&gt;97&lt;/code&gt; while the letter &lt;code&gt;ł&lt;/code&gt; has code point &lt;code&gt;322&lt;/code&gt;. When writing the string &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; to disk, we need to convert this sequence of characters to bytes. If we adopted a rule that said one byte represents one code point, we wouldn&amp;rsquo;t be able to write &lt;code&gt;&quot;hełło&quot;&lt;/code&gt;, because it uses the code point &lt;code&gt;322&lt;/code&gt; for &lt;code&gt;ł&lt;/code&gt;, and one byte can only represent a number from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt;. But of course, given you can actually read &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; on your screen, it must be represented &lt;em&gt;somehow&lt;/em&gt;. That&amp;rsquo;s where encodings come in.</source>
          <target state="translated">유니 코드 표준은 우리가 알고있는 많은 문자에 코드 포인트를 할당합니다. 예를 들어, 문자 &lt;code&gt;a&lt;/code&gt; 에는 코드 포인트 &lt;code&gt;97&lt;/code&gt; 이 있고 문자 &lt;code&gt;ł&lt;/code&gt; 에는 코드 포인트 &lt;code&gt;322&lt;/code&gt; 가 있습니다. 문자열 &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; 를 디스크에 쓸 때이 문자 시퀀스를 바이트로 변환해야합니다. 만약 우리가 1 바이트가 하나의 코드 포인트를 나타내는 규칙을 채택했다면, &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; 는 &lt;code&gt;ł&lt;/code&gt; 에 대한 코드 포인트 &lt;code&gt;322&lt;/code&gt; 를 사용 하고 1 바이트는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;255&lt;/code&gt; 까지의 숫자 만 나타낼 수 있기 때문에 &quot;hełło&quot; 를 쓸 수 없습니다 . 물론, 실제로 화면에서 &lt;code&gt;&quot;hełło&quot;&lt;/code&gt; 를 읽을 수 있다면 반드시 표시해야합니다&lt;em&gt;어떻게 든&lt;/em&gt; . 그것이 인코딩이 들어오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="2f4916c41c92d9991c4b1a3b6471eb39a20e54f2" translate="yes" xml:space="preserve">
          <source>The User switch command</source>
          <target state="translated">사용자 전환 명령</target>
        </trans-unit>
        <trans-unit id="1a567b978fcdc4da963f5cc140173eaaff0ae789" translate="yes" xml:space="preserve">
          <source>The above example shows the difference; the &lt;code&gt;String&lt;/code&gt; module returns Unicode codepoints, while &lt;code&gt;:binary&lt;/code&gt; deals with raw data bytes.</source>
          <target state="translated">위의 예는 차이점을 보여줍니다. &lt;code&gt;String&lt;/code&gt; 모듈 반면, 유니 코드 코드 포인트를 반환 &lt;code&gt;:binary&lt;/code&gt; 원시 데이터 바이트를 다룬다.</target>
        </trans-unit>
        <trans-unit id="3a294edc39ba298dd2fbf7c3e29c2a6c5831e0fe" translate="yes" xml:space="preserve">
          <source>The above is treated the same as &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; by the parser.</source>
          <target state="translated">위 의 구문 분석기 는 &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; 과 동일하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="06bc5ff1abf3cc124d1fca8a735f66352777e819" translate="yes" xml:space="preserve">
          <source>The above will open another Graphical User Interface that provides many panes to fully understand and navigate the runtime and your project:</source>
          <target state="translated">위는 런타임과 프로젝트를 완전히 이해하고 탐색 할 수있는 여러 창을 제공하는 또 다른 그래픽 사용자 인터페이스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d9d727dddfefcfe94e321842e4a52a5241d4e51c" translate="yes" xml:space="preserve">
          <source>The accepted formats are:</source>
          <target state="translated">허용되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4124955158531615905cdb11c74372fed2efecdc" translate="yes" xml:space="preserve">
          <source>The accepted options are:</source>
          <target state="translated">허용되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7021d5fb676b9152eef63709fd1b96c4dc35ca14" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">액세스 구문은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; &lt;/a&gt; 매크로와 함께 사용하여 값이 중첩 된 데이터 구조에 설정되도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aca7adeb72bb259b777f4c2b15cd9a4f9b4ff5ce" translate="yes" xml:space="preserve">
          <source>The access syntax can also be used with the &lt;a href=&quot;kernel#put_in/2&quot;&gt;&lt;code&gt;Kernel.put_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#update_in/2&quot;&gt;&lt;code&gt;Kernel.update_in/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt;&lt;/a&gt; macros to allow values to be set in nested data structures:</source>
          <target state="translated">액세스 구문을 &lt;a href=&quot;kernel#put_in/2&quot;&gt; &lt;code&gt;Kernel.put_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#update_in/2&quot;&gt; &lt;code&gt;Kernel.update_in/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#get_and_update_in/2&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/2&lt;/code&gt; &lt;/a&gt; 매크로 와 함께 사용하여 중첩 된 데이터 구조에서 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243c0eadcb33ec262a94b0246c4ece1f117a3666" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;access#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">액세스 구문은 &lt;a href=&quot;access#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; 에&lt;/a&gt; 대한 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c19d0ebf16010f6efd63fa157dd829c700b0b58" translate="yes" xml:space="preserve">
          <source>The access syntax is represented as a call to &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt;&lt;code&gt;Access.get/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">액세스 구문은 &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html#get/2&quot;&gt; &lt;code&gt;Access.get/2&lt;/code&gt; 에&lt;/a&gt; 대한 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b8d2c8f5f09f671794f31f1f907968a5ca06aff" translate="yes" xml:space="preserve">
          <source>The accumulator is only calculated when transformation starts. It also allows an after function to be given which is invoked when the stream halts or completes.</source>
          <target state="translated">누산기는 변환이 시작될 때만 계산됩니다. 또한 스트림이 정지하거나 완료 될 때 호출되는 after 함수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="231cb19852aaf99a578b488de350325c3dbaf7df" translate="yes" xml:space="preserve">
          <source>The accumulator value for each step.</source>
          <target state="translated">각 단계의 누산기 값입니다.</target>
        </trans-unit>
        <trans-unit id="e04f1a61804f76a146e2c529d3dfa319227959a4" translate="yes" xml:space="preserve">
          <source>The actual line is especially formatted in bold.</source>
          <target state="translated">실제 줄은 특히 굵게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1f1fb598d7730a9ff70812d543d26b95408bb0" translate="yes" xml:space="preserve">
          <source>The advantage of starting a process under the test supervisor is that it is guaranteed to exit before the next test starts. Therefore, you don't need to remove the process at the end of your tests via &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt;. You only need to use &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; if you want to remove a process from the supervision tree in the middle of a test, as simply shutting down the process would cause it to be restarted according to its &lt;code&gt;:restart&lt;/code&gt; value.</source>
          <target state="translated">테스트 감독자에서 프로세스를 시작하면 다음 테스트가 시작되기 전에 프로세스가 종료된다는 장점이 있습니다. 따라서 테스트 &lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt; 통해 프로세스를 제거 할 필요가 없습니다 . 테스트 도중에 감독 트리에서 프로세스를 제거하려는 경우 &lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt; 만 사용해야합니다 . 프로세스를 종료하면 &lt;code&gt;:restart&lt;/code&gt; 값 에 따라 프로세스가 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="f25d9730409ef1dfe6f5e984f31be4fd99cffcf1" translate="yes" xml:space="preserve">
          <source>The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key &lt;code&gt;:full_name&lt;/code&gt; in the &lt;code&gt;User&lt;/code&gt; struct:</source>
          <target state="translated">구조체의 장점은 주어진 키가 정의 된 구조체의 일부인지 확인한다는 것입니다. 더 키가 없기 때문에 아래의 예는 실패합니다 &lt;code&gt;:full_name&lt;/code&gt; 에서 &lt;code&gt;User&lt;/code&gt; 구조체 :</target>
        </trans-unit>
        <trans-unit id="83ac1b567e220f667e9d9d2c2f19a5c7705de064" translate="yes" xml:space="preserve">
          <source>The agent name</source>
          <target state="translated">에이전트 이름</target>
        </trans-unit>
        <trans-unit id="850cde34796934da35ab95f25d166c013161b0f7" translate="yes" xml:space="preserve">
          <source>The agent reference</source>
          <target state="translated">에이전트 참조</target>
        </trans-unit>
        <trans-unit id="79d99d2d3b7f3ac280b26b43a51cc435cf66db5f" translate="yes" xml:space="preserve">
          <source>The agent state</source>
          <target state="translated">에이전트 상태</target>
        </trans-unit>
        <trans-unit id="04287ba52642f4b2e9805d3cbb6242221ac4131b" translate="yes" xml:space="preserve">
          <source>The agent's state will be added to the given list of arguments (&lt;code&gt;[%{}]&lt;/code&gt;) as the first argument.</source>
          <target state="translated">에이전트의 상태는 주어진 인수 목록 ( &lt;code&gt;[%{}]&lt;/code&gt; )에 첫 번째 인수로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8beb83ba7f5ecd3254d30e564e0d6fb8a2d460e5" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;An O(ND) Difference Algorithm and Its Variations&quot; paper by E. Myers.</source>
          <target state="translated">알고리즘은 E. Myers의 &quot;O (ND) 차이 알고리즘 및 그 변형&quot;논문에 요약되어있다.</target>
        </trans-unit>
        <trans-unit id="3e134324067f32fab468c28c29405fca71811700" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &quot;String Matching with Metric Trees Using an Approximate Distance&quot; paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella.</source>
          <target state="translated">이 알고리즘은 Ilaria Bartolini, Paolo Ciaccia 및 Marco Patella의 &quot;대략 거리를 사용한 메트릭 트리와 문자열 일치&quot;백서에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b130944005218b61f70b8dda4acb83f5f8b422" translate="yes" xml:space="preserve">
          <source>The algorithm is outlined in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29, Unicode Text Segmentation&lt;/a&gt;.</source>
          <target state="translated">이 알고리즘은 &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex # 29, Unicode Text Segmentation에&lt;/a&gt; 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9558fd66aceb0ac12811fbd079f3478d2d6d0b6" translate="yes" xml:space="preserve">
          <source>The allowed modes:</source>
          <target state="translated">허용되는 모드 :</target>
        </trans-unit>
        <trans-unit id="22b1bedb9b0e24d713b2164c5c95fdaf0f81ef84" translate="yes" xml:space="preserve">
          <source>The allowed values for &lt;code&gt;flag&lt;/code&gt; are only a subset of those allowed in &lt;a href=&quot;#flag/2&quot;&gt;&lt;code&gt;flag/2&lt;/code&gt;&lt;/a&gt;, namely &lt;code&gt;:save_calls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flag&lt;/code&gt; 허용되는 값 은 &lt;a href=&quot;#flag/2&quot;&gt; &lt;code&gt;flag/2&lt;/code&gt; &lt;/a&gt; 허용 된 값 중 &lt;code&gt;:save_calls&lt;/code&gt; . 즉 : save_calls 입니다.</target>
        </trans-unit>
        <trans-unit id="a1284e6a8b509aaab6853404ad966b4c6d0d9c11" translate="yes" xml:space="preserve">
          <source>The amount of functionality in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules can be daunting at first, but you will get familiar with them case by case. In particular, focus on the &lt;code&gt;Enum&lt;/code&gt; module first and only move to &lt;code&gt;Stream&lt;/code&gt; for the particular scenarios where laziness is required, to either deal with slow resources or large, possibly infinite, collections.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈 의 기능은 처음에는 어려울 수 있지만 경우에 따라 익숙해 질 것입니다. 특히 &lt;code&gt;Enum&lt;/code&gt; 모듈 에 중점을두고 느리게 처리해야하는 특정 시나리오에 대해서만 &lt;code&gt;Stream&lt;/code&gt; 이동하여 느린 리소스 또는 무한대의 대규모 컬렉션을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8600e30f0a326a12149028f15ee8e6ad16cef8" translate="yes" xml:space="preserve">
          <source>The anonymous function receives 0 arguments, and may return any value.</source>
          <target state="translated">익명 함수는 0 개의 인수를 받고 모든 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3860a6ee964a29eb95c7ca816e5e5490427978d6" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대답은 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 반환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35961a2d2bc407917b83fe316a44657eb3d70dde" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first time value is earlier than the second, a negative number is returned.</source>
          <target state="translated">대답은 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 반환 될 수 있습니다 . 첫 번째 시간 값이 두 번째 값보다 이전이면 음수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="273c2352c55239386071c9f97857464d5b54d531" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">답변은 &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 반환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c851ccba3a0c5e2913af28fbba1bc5059650f30" translate="yes" xml:space="preserve">
          <source>The answer can be returned in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. If the first unit is smaller than the second, a negative number is returned.</source>
          <target state="translated">답변은 &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 반환 될 수 있습니다 . 첫 번째 단위가 두 번째 단위보다 작 으면 음수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="11872c1546ad5d8d77e3dd6dcf24fe80bdc32569" translate="yes" xml:space="preserve">
          <source>The application callback</source>
          <target state="translated">응용 프로그램 콜백</target>
        </trans-unit>
        <trans-unit id="498cebd5386c08940274d180a46313b584299218" translate="yes" xml:space="preserve">
          <source>The application callback module</source>
          <target state="translated">애플리케이션 콜백 모듈</target>
        </trans-unit>
        <trans-unit id="ce357182db7e39e7d54f85ac0fa8ea1bfe43cdcd" translate="yes" xml:space="preserve">
          <source>The application environment</source>
          <target state="translated">응용 환경</target>
        </trans-unit>
        <trans-unit id="40917bb5c729fef80a4c140a2928d1f7a14bf4d7" translate="yes" xml:space="preserve">
          <source>The application environment can be overridden via the &lt;code&gt;-config&lt;/code&gt; option of &lt;code&gt;erl&lt;/code&gt;, as well as command-line options, as we are going to see below.</source>
          <target state="translated">응용 프로그램 환경 은 아래에서 볼 수 있듯이 명령 줄 옵션뿐만 아니라 &lt;code&gt;erl&lt;/code&gt; 의 &lt;code&gt;-config&lt;/code&gt; 옵션을 통해 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37789b75dd5f623e649e47a61f598fab65dfa7b6" translate="yes" xml:space="preserve">
          <source>The application environment should be reserved only for configurations that are truly global, for example, to control your application boot process and its supervision tree.</source>
          <target state="translated">응용 프로그램 환경은 응용 프로그램 부팅 프로세스 및 관리 트리를 제어하기 위해 실제로 전역적인 구성에 대해서만 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="280a9a5faaec5ff9e8215df748115db28ebee1a0" translate="yes" xml:space="preserve">
          <source>The application is located by analyzing the spec of all loaded applications. Returns &lt;code&gt;nil&lt;/code&gt; if the module is not listed in any application spec.</source>
          <target state="translated">응용 프로그램은로드 된 모든 응용 프로그램의 사양을 분석하여 찾습니다. 모듈이 애플리케이션 사양에 나열되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bc8d61b7265354046282efa86c0154278c621f25" translate="yes" xml:space="preserve">
          <source>The application life cycle</source>
          <target state="translated">애플리케이션 수명주기</target>
        </trans-unit>
        <trans-unit id="cc4a58ee1265d5c1fe9173d32bf0ac223249dd85" translate="yes" xml:space="preserve">
          <source>The application lifecycle</source>
          <target state="translated">응용 프로그램 수명주기</target>
        </trans-unit>
        <trans-unit id="143141b825e19c759eb1a18e855e24abed92b957" translate="yes" xml:space="preserve">
          <source>The application resource file</source>
          <target state="translated">응용 프로그램 리소스 파일</target>
        </trans-unit>
        <trans-unit id="e3563cd3d1dfc3ea0fa27f37030c6816eb2657f5" translate="yes" xml:space="preserve">
          <source>The application works as a distributed key-value store. We are going to organize key-value pairs into buckets and distribute those buckets across multiple nodes. We will also build a simple client that allows us to connect to any of those nodes and send requests such as:</source>
          <target state="translated">응용 프로그램은 분산 키-값 저장소로 작동합니다. 키-값 쌍을 버킷으로 구성하고 해당 버킷을 여러 노드에 분산시킬 것입니다. 또한 이러한 노드 중 하나에 연결하고 다음과 같은 요청을 보낼 수있는 간단한 클라이언트를 구축 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="27642ed423e2fa876dc5149e7e9fb4418a0af850" translate="yes" xml:space="preserve">
          <source>The archive will be created in the current directory (which is expected to be the project root), unless an argument &lt;code&gt;-o&lt;/code&gt; is provided with the file name.</source>
          <target state="translated">&lt;code&gt;-o&lt;/code&gt; 인수 가 파일 이름과 함께 제공 되지 않는 한 아카이브는 현재 디렉토리 (프로젝트 루트가 될 것으로 예상 됨)에 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0f3ead845310ee387fe5a545e6953c55ffb1629" translate="yes" xml:space="preserve">
          <source>The argument can also be a compiled pattern:</source>
          <target state="translated">인수는 컴파일 된 패턴 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="591637cab81491d8824a1f871aa68b8d413473f1" translate="yes" xml:space="preserve">
          <source>The argument can be either a variable unquoted or in standard tuple form &lt;code&gt;{name, meta, context}&lt;/code&gt;.</source>
          <target state="translated">인수는 인용되지 않은 변수이거나 표준 튜플 형식 &lt;code&gt;{name, meta, context}&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="001d538e8d0cdf963d20a8cda73ecd32223786da" translate="yes" xml:space="preserve">
          <source>The arguments passed to the callbacks are related to the state optionally returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, and are documented in the section about the callback module above.</source>
          <target state="translated">콜백에 전달 된 인수는 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 에서 선택적으로 반환 된 상태와 관련이 있으며 위의 콜백 모듈에 대한 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a881ae7cb35da41cfdaee7b5069205d1b09ab08" translate="yes" xml:space="preserve">
          <source>The atom encoder is not called for &lt;em&gt;all&lt;/em&gt; atoms that are present in the AST. It won't be invoked for the following atoms:</source>
          <target state="translated">원자 엔코더는 AST에 존재하는 &lt;em&gt;모든&lt;/em&gt; 원자에 대해 요구되는 것은 아닙니다 . 다음 원자에 대해서는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca8797b60e8c99dfe84eeca54f5b5a5a65568918" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;.</source>
          <target state="translated">속성 값은 &lt;code&gt;context.registered&lt;/code&gt; 를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1aacd6450630dafa0ac3016ebf55acec692c62f" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@describetag&lt;/code&gt;.</source>
          <target state="translated">속성 값은 &lt;code&gt;context.registered&lt;/code&gt; 를 통해 사용할 수 있습니다 . 등록 된 값은 &lt;code&gt;@describetag&lt;/code&gt; 와 유사한 각 &lt;a href=&quot;#describe/2&quot;&gt; &lt;code&gt;describe/2&lt;/code&gt; &lt;/a&gt; 후에 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="f388a223145d9f2cd324e6f166a8ccfc6a8b5209" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">속성 값은 &lt;code&gt;context.registered&lt;/code&gt; 를 통해 사용할 수 있습니다 . 등록 된 값은 &lt;code&gt;@tag&lt;/code&gt; 와 유사하게 각 &lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt; 후에 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="b41ad89c98d422fd2e978f100782ecfe3f1da362" translate="yes" xml:space="preserve">
          <source>The attribute values will be available through &lt;code&gt;context.registered&lt;/code&gt;. Registered values are cleared after each &lt;a href=&quot;exunit.case#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; similar to &lt;code&gt;@tag&lt;/code&gt;.</source>
          <target state="translated">속성 값은 &lt;code&gt;context.registered&lt;/code&gt; 를 통해 사용 가능합니다 . 등록 된 값은 각 후 삭제됩니다 &lt;a href=&quot;exunit.case#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; &lt;/a&gt; 유사 &lt;code&gt;@tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fadbc924b0cd6b0ad53d9ab7f75eafe50d08633" translate="yes" xml:space="preserve">
          <source>The available backends by default are:</source>
          <target state="translated">기본적으로 사용 가능한 백엔드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cce71e8c20ef741ad606617e045711680af943f" translate="yes" xml:space="preserve">
          <source>The available color options are:</source>
          <target state="translated">사용 가능한 색상 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6310c4c55c85283101be1a934d0a00206b4f631d" translate="yes" xml:space="preserve">
          <source>The backend needs to be started and running in order to be configured at runtime.</source>
          <target state="translated">런타임에 구성하려면 백엔드를 시작하고 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="96a787facf19135fb4b200f8b487060672819be8" translate="yes" xml:space="preserve">
          <source>The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different.</source>
          <target state="translated">백 거리는 크게 다른 스트링을 신속하게 배제하기 위해 두 스트링 사이의 거리를 효율적으로 근사하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0aa33c6e6c19292365b6836f590a40f470ae9e8" translate="yes" xml:space="preserve">
          <source>The base needs to be between &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;36&lt;/code&gt;.</source>
          <target state="translated">기준은 &lt;code&gt;2&lt;/code&gt; 에서 &lt;code&gt;36&lt;/code&gt; 사이 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="338ca5e9a146228c6591ce27e258c309b41537d7" translate="yes" xml:space="preserve">
          <source>The basic mechanism for spawning new processes is the auto-imported &lt;code&gt;spawn/1&lt;/code&gt; function:</source>
          <target state="translated">새로운 프로세스를 생성하는 기본 메커니즘은 자동 가져 &lt;code&gt;spawn/1&lt;/code&gt; 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4e7559ee61af701da957bbebc32b89de3be4e12f" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#ceil/2&quot;&gt;&lt;code&gt;ceil/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">수레에 대한 &lt;a href=&quot;#ceil/2&quot;&gt; &lt;code&gt;ceil/2&lt;/code&gt; &lt;/a&gt; 의 동작은 놀랍습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d56bb8e1dfaa2c0603350dcc324ff5c454da55f1" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">수레에 대한 &lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt; 의 동작은 놀랍습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="038842fad2e4b3a86e4d5b65bf16dcbffaa55807" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; for floats can be surprising. For example:</source>
          <target state="translated">float에 대한 &lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt; 의 동작은 놀랍습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c79b8f7e64e352a09f016328372f8c34533b468e" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">절에있는 모든 표현식의 동작은 외부와 동일합니다. 예를 들어 &lt;code&gt;=&lt;/code&gt; 는 일치하지 않는 값을 반환하는 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="850b8800d7a40702a94f4c6f350b76c00c714c91" translate="yes" xml:space="preserve">
          <source>The behaviour of any expression in a clause is the same as outside. For example, &lt;code&gt;=&lt;/code&gt; will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; instead of returning the non-matched value:</source>
          <target state="translated">절에서 식의 동작은 외부와 동일합니다. 예를 들어 &lt;code&gt;=&lt;/code&gt; 는 일치하지 않는 값을 반환하는 대신 &lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2c2089b4c70310731d109bdd4cb28eac8386c5ba" translate="yes" xml:space="preserve">
          <source>The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter.</source>
          <target state="translated">위의 동작은 보장되지 않습니다. 향후 새로운 규칙을 제거하거나 추가 할 수 있습니다. 그것들을 문서화하는 목적은 포맷터로부터 무엇을 기대해야하는지에 대한 이해를 높이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b5532ea236231522d81c8ef60d96c8157a31b23" translate="yes" xml:space="preserve">
          <source>The best solution is to simply use the explicit module, function, and arguments APIs when working with distributed agents.</source>
          <target state="translated">가장 좋은 솔루션은 분산 에이전트로 작업 할 때 명시 적 모듈, 함수 및 인수 API를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="230a7e78c26b7490aaeba0ccd0ad9d4d649d4144" translate="yes" xml:space="preserve">
          <source>The best way to get started with your first project is by calling &lt;code&gt;mix new my_project&lt;/code&gt; from the command line.</source>
          <target state="translated">첫 번째 프로젝트를 시작하는 가장 좋은 방법 은 명령 줄에서 &lt;code&gt;mix new my_project&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d0bbf418b1f38a55ccb7dde48f0990ed9ed4760a" translate="yes" xml:space="preserve">
          <source>The binary module</source>
          <target state="translated">이진 모듈</target>
        </trans-unit>
        <trans-unit id="95ca58a2bc8511627f8365c4bfe2246bdcfdaed5" translate="yes" xml:space="preserve">
          <source>The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</source>
          <target state="translated">바인딩 키는 일반적으로 원자이지만 다른 컨텍스트에서 정의 된 변수에 대한 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b507e4caeeefa4e12188b817548237116e75e51" translate="yes" xml:space="preserve">
          <source>The booleans &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; are also atoms:</source>
          <target state="translated">부울 값 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 도 원자입니다.</target>
        </trans-unit>
        <trans-unit id="922dc50f7cf9b7578080aaeb54c1d2a1b40ac190" translate="yes" xml:space="preserve">
          <source>The boot script uses the RELEASE_LIB environment variable, which must be accordingly set with &lt;code&gt;--boot-var&lt;/code&gt; and point to the release lib dir.</source>
          <target state="translated">부트 스크립트는 RELEASE_LIB 환경 변수를 사용합니다.이 변수는 그에 따라 &lt;code&gt;--boot-var&lt;/code&gt; 로 설정 하고 릴리스 lib dir을 가리켜 야합니다.</target>
        </trans-unit>
        <trans-unit id="173c29727301f1e8ee220ab1adbc4da76be15175" translate="yes" xml:space="preserve">
          <source>The bucket supervisor</source>
          <target state="translated">버킷 관리자</target>
        </trans-unit>
        <trans-unit id="28ca52bc03d0c7c44e235ef531de8f5ba2e83b87" translate="yes" xml:space="preserve">
          <source>The building block of Elixir's AST is a call, such as:</source>
          <target state="translated">Elixir AST의 빌딩 블록은 다음과 같은 호출입니다.</target>
        </trans-unit>
        <trans-unit id="461328f5549d78a8b5fdedc116f07cd5036d784a" translate="yes" xml:space="preserve">
          <source>The building block of an Elixir program is a tuple with three elements. For example, the function call &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; is represented internally as:</source>
          <target state="translated">Elixir 프로그램의 빌딩 블록은 세 가지 요소가있는 튜플입니다. 예를 들어 함수 호출 &lt;code&gt;sum(1, 2, 3)&lt;/code&gt; 은 내부적으로 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="75d9d0a9c9a355ba2103db23084500c77872bd8e" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">내장 &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt; 유형은 &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt; 측면에서 정의됩니다 . IO 목록은 IO 데이터와 동일하지만 최상위 수준에서 바이너리를 허용하지 않습니다 (그러나 바이너리는 목록 자체에서 여전히 허용됨).</target>
        </trans-unit>
        <trans-unit id="bb521e80a89a4c39c427f904962402bd53b9f9e8" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iodata/0&lt;/code&gt;&lt;/a&gt; type is defined in terms of &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;iolist/0&lt;/code&gt;&lt;/a&gt;. An IO list is the same as IO data but it doesn't allow for a binary at the top level (but binaries are still allowed in the list itself).</source>
          <target state="translated">는 내장 &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iodata/0&lt;/code&gt; &lt;/a&gt; 유형의 관점에서 정의 &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;iolist/0&lt;/code&gt; &lt;/a&gt; . IO 목록은 IO 데이터와 동일하지만 최상위 수준에서는 이진을 허용하지 않지만 이진은 여전히 ​​목록 자체에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa702ce8bbd071f4798263a3cd547b0d108c54b2" translate="yes" xml:space="preserve">
          <source>The built-in Elixir String module handles binaries that are UTF-8 encoded. &lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;The binary module&lt;/a&gt; is useful when you are dealing with binary data that is not necessarily UTF-8 encoded.</source>
          <target state="translated">내장 Elixir String 모듈은 UTF-8로 인코딩 된 바이너리를 처리합니다. &lt;a href=&quot;http://erlang.org/doc/man/binary.html&quot;&gt;이진 모듈&lt;/a&gt; 은 반드시 UTF-8로 인코딩되지 않은 이진 데이터를 처리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9912c6244d1c63cb84c34b3a68b26e804aecd085" translate="yes" xml:space="preserve">
          <source>The built-in calendar does not support leap seconds.</source>
          <target state="translated">내장 캘린더는 윤초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eac291bdda8b39cdd07415652c800893620c2cab" translate="yes" xml:space="preserve">
          <source>The calendar era.</source>
          <target state="translated">달력 시대.</target>
        </trans-unit>
        <trans-unit id="c53205e7065bb3ce87323206c4d4e303fc4d8e79" translate="yes" xml:space="preserve">
          <source>The callback is invoked after the compiler runs and it receives a tuple with current status and the list of diagnostic. It must return the updated status and diagnostics.</source>
          <target state="translated">콜백은 컴파일러가 실행 된 후 호출되며 현재 상태와 진단 목록이있는 튜플을 수신합니다. 업데이트 된 상태 및 진단을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5d5a7fc225ff3dc99ea235a243bb670a176a9d8" translate="yes" xml:space="preserve">
          <source>The calling process is put into a waiting state where its memory allocation has been reduced as much as possible, which is useful if the process does not expect to receive any messages in the near future.</source>
          <target state="translated">호출 프로세스는 메모리 할당이 가능한 한 감소 된 대기 상태가되며, 가까운 시일 내에 프로세스가 메시지를 수신하지 않을 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2b5b064f8261c2b03a774df6e6ae6dcd0d5c8140" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">속성에 대한 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 예는 모듈이 GenServer 와 같은 OTP 동작을 구현한다는 주석입니다 .</target>
        </trans-unit>
        <trans-unit id="f0b8dfb4a5a810c9b8c195f76200b64770caff21" translate="yes" xml:space="preserve">
          <source>The canonical example for attributes is annotating that a module implements an OTP behaviour, such as &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">속성에 대한 표준 예는 모듈이 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 같은 OTP 동작을 구현한다는 주석입니다 .</target>
        </trans-unit>
        <trans-unit id="88868f6d5562a67e7ddaf9b29fc243c12f68bba4" translate="yes" xml:space="preserve">
          <source>The capture operator</source>
          <target state="translated">캡처 연산자</target>
        </trans-unit>
        <trans-unit id="1347b7b88b5541d0e12b97a6af43a979bc085407" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:</source>
          <target state="translated">캡처 연산자를 사용하여 개인 기능을 포함한 로컬 기능 및 모듈 이름을 생략하여 가져온 기능을 캡처 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="75226e8489147d2da09b1c8fddde984e1d062fca" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to create anonymous functions that expect at least one argument:</source>
          <target state="translated">캡처 연산자를 사용하여 최소한 하나의 인수를 예상하는 익명 함수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef5fce1b72abda5249ca40d94c6bba5adc71084" translate="yes" xml:space="preserve">
          <source>The capture operator can also be used to partially apply functions, where &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt; and so on can be used as value placeholders. For example:</source>
          <target state="translated">캡처 연산자를 사용하여 &lt;code&gt;&amp;amp;1&lt;/code&gt; , &lt;code&gt;&amp;amp;2&lt;/code&gt; 등을 값 플레이스 홀더로 사용할 수있는 기능을 부분적으로 적용 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed78fb3f56be122fa668d8b4473c09f744fcc1e2" translate="yes" xml:space="preserve">
          <source>The capture operator is most commonly used to capture a function with given name and arity from a module:</source>
          <target state="translated">캡처 연산자는 모듈에서 주어진 이름과 특성을 가진 함수를 캡처하는 데 가장 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="daa5b67ac4266d64104c7c678fbebf39b612b043" translate="yes" xml:space="preserve">
          <source>The changes we have performed above have broken our tests because the registry requires the &lt;code&gt;:name&lt;/code&gt; option when starting up. Furthermore, some registry operations such as &lt;code&gt;lookup/2&lt;/code&gt; require the name to be given as an argument, instead of a PID, so we can do the ETS table lookup. Let&amp;rsquo;s change the setup function in &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; to fix both issues:</source>
          <target state="translated">레지스트리 를 시작할 때 레지스트리에 &lt;code&gt;:name&lt;/code&gt; 옵션이 필요하기 때문에 위에서 수행 한 변경 사항으로 인해 테스트가 중단 되었습니다. 또한 &lt;code&gt;lookup/2&lt;/code&gt; 와 같은 일부 레지스트리 작업 에서는 이름 대신 PID 대신 인수로 이름을 지정해야하므로 ETS 테이블 조회를 수행 할 수 있습니다. &lt;code&gt;test/kv/registry_test.exs&lt;/code&gt; 의 설정 기능을 변경하여 두 가지 문제를 모두 해결해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a0d4f7e1122a8b55f665626ee09ac09a98518fc5" translate="yes" xml:space="preserve">
          <source>The child specification contains 6 keys. The first two are required, and the remaining ones are optional:</source>
          <target state="translated">하위 스펙에는 6 개의 키가 있습니다. 처음 두 개가 필요하고 나머지 두 개는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7160687e53597f9f0ad549c50eef17c501e4af5e" translate="yes" xml:space="preserve">
          <source>The child specification describes how the supervisor starts, shuts down, and restarts child processes.</source>
          <target state="translated">자식 사양은 감독자가 자식 프로세스를 시작, 종료 및 다시 시작하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="950e3568a25b27f2811958eb0aa95e081e11f40c" translate="yes" xml:space="preserve">
          <source>The child specification is a map containing up to 6 elements. The first two keys in the following list are required, and the remaining ones are optional:</source>
          <target state="translated">하위 사양은 최대 6 개의 요소를 포함하는 맵입니다. 다음 목록의 처음 두 키는 필수이며 나머지 키는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="42da62bf1cce6040df7eca9209cf8b54396ada67" translate="yes" xml:space="preserve">
          <source>The child specification must exist and the corresponding child process must not be running.</source>
          <target state="translated">하위 스펙이 존재해야하며 해당 하위 프로세스가 실행되고 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="313526f010da8f629d585c9d88474ee1e8f4898f" translate="yes" xml:space="preserve">
          <source>The children is a list of modules, two-element tuples with module and arguments or a map with the child specification. A strategy is required to be provided through the &lt;code&gt;:strategy&lt;/code&gt; option. See &quot;start_link/2, init/2, and strategies&quot; for examples and other options.</source>
          <target state="translated">자식은 모듈 목록, 모듈이 포함 된 2 요소 튜플 및 인수 또는 자식 사양이 포함 된 맵입니다. &lt;code&gt;:strategy&lt;/code&gt; 옵션을 통해 전략을 제공해야합니다 . 예제 및 기타 옵션은 &quot;start_link / 2, init / 2 및 전략&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53b9ca94898155cae15db3cc7ef654f0bd4da634" translate="yes" xml:space="preserve">
          <source>The choice between &lt;code&gt;:do&lt;/code&gt; keyword and &lt;code&gt;do/end&lt;/code&gt; blocks is left to the user</source>
          <target state="translated">&lt;code&gt;:do&lt;/code&gt; 키워드와 &lt;code&gt;do/end&lt;/code&gt; 블록 사이의 선택 은 사용자에게 맡겨집니다</target>
        </trans-unit>
        <trans-unit id="7b1b61c1ee1c04db8df86f79837449227f41eae5" translate="yes" xml:space="preserve">
          <source>The choice between parens and no parens is a matter of preference.</source>
          <target state="translated">Parens와 No Parens 중 하나를 선택하는 것이 선호의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="a3a0a29c159eb1228d94714c1b6b06e0b32d7a74" translate="yes" xml:space="preserve">
          <source>The choice of parens and no parens also affects indentation. When a function call with parens doesn't fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces:</source>
          <target state="translated">Parens의 선택과 parens가없는 것도 들여 쓰기에 영향을줍니다. parens를 사용한 함수 호출이 같은 행에 맞지 않으면 포맷터는 parens 주위에 줄 바꿈을 도입하고 인수를 두 개의 공백으로 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="23594e68f8f770603c0ad519dc9b20dde3e76ac3" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. A more complete introduction to guards is available &lt;a href=&quot;guards&quot;&gt;in the Guards page&lt;/a&gt;.</source>
          <target state="translated">위의 조항은 사용자의 연령이 16 세 이상인 경우에만 호출됩니다. 가드에 대한보다 완전한 소개 &lt;a href=&quot;guards&quot;&gt;는 가드 페이지에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba6a994f50b6302be9c679389659a12c3a4b68fd" translate="yes" xml:space="preserve">
          <source>The clause above will only be invoked if the user's age is more than or equal to 16. Guards also support joining multiple conditions with &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. The whole guard is true if all guard expressions will evaluate to &lt;code&gt;true&lt;/code&gt;. A more complete introduction to guards is available &lt;a href=&quot;patterns-and-guards&quot;&gt;in the &quot;Patterns and Guards&quot; page&lt;/a&gt;.</source>
          <target state="translated">사용자의 나이는 여러 조건에 입사 지원 (16) 가드와 같거나보다 더 경우 절은 위의 경우에만 호출됩니다 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; . 모든 가드 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가되면 전체 가드가 참 입니다 . 가드에 대한보다 완전한 소개 &lt;a href=&quot;patterns-and-guards&quot;&gt;는 &quot;패턴 및 가드&quot;페이지에서&lt;/a&gt; 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c255b3390bdbf75961fab635ba6b005f6d757746" translate="yes" xml:space="preserve">
          <source>The client sends the given &lt;code&gt;request&lt;/code&gt; to the server and waits until a reply arrives or a timeout occurs. &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; will be called on the server to handle the request.</source>
          <target state="translated">클라이언트는 주어진 &lt;code&gt;request&lt;/code&gt; 을 서버로 보내고 응답이 도착하거나 시간 초과가 발생할 때까지 기다립니다. 요청을 처리하기 위해 서버에서 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d9950721b47bf760ca7644941dac9e25516ba4de" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.01 is 0.0099999997</source>
          <target state="translated">0.01에 가장 가까운 표현 가능한 숫자는 0.0099999997입니다.</target>
        </trans-unit>
        <trans-unit id="94f439e6735d38fbe26e845fc67b04161ed13286" translate="yes" xml:space="preserve">
          <source>The closest representable number to 0.1 is 0.1000000014</source>
          <target state="translated">0.1에 가장 가까운 표현 가능한 수는 0.1000000014입니다.</target>
        </trans-unit>
        <trans-unit id="a2e208db8b2d737003cfa026657e7817cb56f94b" translate="yes" xml:space="preserve">
          <source>The code above has very long lines and running the formatter is not going to address this issue. In fact, the formatter may make it more obvious that you have complex expressions:</source>
          <target state="translated">위의 코드는 매우 긴 행을 가지며 포맷터를 실행하면이 문제를 해결하지 못합니다. 실제로, 포매터는 복잡한 표현을 가지고 있음을보다 분명하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8971296bf8b5fe352cb67c40d256dea059794cfe" translate="yes" xml:space="preserve">
          <source>The code above says we are only bringing in the functions from &lt;code&gt;MyLib&lt;/code&gt; so we can invoke &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; directly without the &lt;code&gt;MyLib.&lt;/code&gt; prefix. Even more important, &lt;code&gt;import MyLib&lt;/code&gt; says that we have an option to not &lt;code&gt;import MyLib&lt;/code&gt; at all as we can simply invoke the function as &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt;.</source>
          <target state="translated">위의 코드는 &lt;code&gt;MyLib&lt;/code&gt; 에서 함수를 가져 와서 MyLib 없이 &lt;code&gt;some_fun(arg1, arg2)&lt;/code&gt; 직접 호출 할 수 &lt;code&gt;MyLib.&lt;/code&gt; 접두사. 더 중요한 것은 &lt;code&gt;import MyLib&lt;/code&gt; 은 &lt;code&gt;MyLib.some_fun(arg1, arg2)&lt;/code&gt; 함수를 호출 할 수 있기 때문에 &lt;code&gt;import MyLib&lt;/code&gt; 을 전혀 가져 오지 않는 옵션이 있다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="09481c86dbd26d18c6fe8e729156a7702b288946" translate="yes" xml:space="preserve">
          <source>The code above will be kept with one keyword entry per line by the formatter. To avoid that, just squash everything into a single line.</source>
          <target state="translated">위 코드는 포맷터에 의해 한 줄에 하나의 키워드 항목으로 유지됩니다. 이를 피하기 위해 모든 것을 한 줄로 스쿼시하십시오.</target>
        </trans-unit>
        <trans-unit id="5a5a8b1aa48591121657910360da4599001ef7e7" translate="yes" xml:space="preserve">
          <source>The code above will fail because the &lt;code&gt;=&lt;/code&gt; operator always fails when the sides do not match and &lt;a href=&quot;#refute/2&quot;&gt;&lt;code&gt;refute/2&lt;/code&gt;&lt;/a&gt; does not change it.</source>
          <target state="translated">측면이 일치하지 않고 &lt;a href=&quot;#refute/2&quot;&gt; &lt;code&gt;refute/2&lt;/code&gt; &lt;/a&gt; 가 변경하지 않으면 &lt;code&gt;=&lt;/code&gt; 연산자가 항상 실패하기 때문에 위의 코드는 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="d1a28899a290431210335f780f9a3a344e1bdaa4" translate="yes" xml:space="preserve">
          <source>The code above will work but issue a warning: &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt;. The macro is overriding the original value and the original value is never used.</source>
          <target state="translated">위의 코드는 작동하지만 경고 : &lt;code&gt;variable &quot;a&quot; is unused&lt;/code&gt; . 매크로가 원래 값을 재정의하고 원래 값이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="269d3d7086c8d03fa3a689c409e633046b40f522" translate="yes" xml:space="preserve">
          <source>The code above would have the same flaw: if we link the &lt;code&gt;serve(client)&lt;/code&gt; task to the acceptor, a crash when serving a request would bring the acceptor, and consequently all other connections, down.</source>
          <target state="translated">위의 코드는 같은 결함이 있습니다. &lt;code&gt;serve(client)&lt;/code&gt; 작업을 수락 자에 연결하면 요청을 처리 할 때 충돌이 발생하여 수락 자 및 결과적으로 다른 모든 연결이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="382718e17e13c129c8263cdafc53473338fb082d" translate="yes" xml:space="preserve">
          <source>The code in the loaded &lt;code&gt;.iex.exs&lt;/code&gt; file is evaluated in the shell's context. For instance, any modules that are loaded or variables that are bound in the &lt;code&gt;.iex.exs&lt;/code&gt; file will be available in the shell after it has booted.</source>
          <target state="translated">로드 된 &lt;code&gt;.iex.exs&lt;/code&gt; 파일 의 코드 는 셸의 컨텍스트에서 평가됩니다. 예를 들어,로드 된 모든 모듈 또는 &lt;code&gt;.iex.exs&lt;/code&gt; 파일에 바인딩 된 변수 는 부팅 된 후 셸에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89723bc3e0f1ff8256d889a81362651a037ba774" translate="yes" xml:space="preserve">
          <source>The code is now more readable, as it is now clear which functions are part of your API and which ones are callback implementations. To reinforce this idea, &lt;code&gt;@impl true&lt;/code&gt; automatically marks the function as &lt;code&gt;@doc false&lt;/code&gt;, disabling documentation unless &lt;code&gt;@doc&lt;/code&gt; is explicitly set.</source>
          <target state="translated">어떤 함수가 API의 일부이고 어떤 함수가 콜백 구현인지가 명확 해짐에 따라 코드는 이제 더 읽기 쉽습니다. 이 아이디어를 강화하기 위해 &lt;code&gt;@impl true&lt;/code&gt; 는 함수를 &lt;code&gt;@doc false&lt;/code&gt; 로 자동 표시하여 &lt;code&gt;@doc&lt;/code&gt; 가 명시 적으로 설정되어 있지 않으면 문서를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="27bd571c88e679120d69355a8855de7b06b30a1a" translate="yes" xml:space="preserve">
          <source>The collection types are compared using the following rules:</source>
          <target state="translated">컬렉션 유형은 다음 규칙을 사용하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5b2a728faaf0d704086c8a732474d34b64c7d1" translate="yes" xml:space="preserve">
          <source>The comma should be followed by a space.</source>
          <target state="translated">쉼표 뒤에 공백이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="139636692335607d6eb4460b93391d027f1c3267" translate="yes" xml:space="preserve">
          <source>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</source>
          <target state="translated">쉘을 전환했기 때문에 위의 명령이 실패합니다. 쉘은 서로 분리되어 있기 때문에 한 쉘에 정의 된 변수를 다른 쉘에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="000af91ba82011c87383cf8f5a08713fe7fef900" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;:error&lt;/code&gt;</source>
          <target state="translated">위의 명령은 &lt;code&gt;:error&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="93e8c4e8d6a9562251088181806121ea8983b620" translate="yes" xml:space="preserve">
          <source>The command above returns &lt;code&gt;{:ok, bucket}&lt;/code&gt;</source>
          <target state="translated">위 명령은 &lt;code&gt;{:ok, bucket}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="919db13977d98a781eec05aba6aea3150c8048e9" translate="yes" xml:space="preserve">
          <source>The command above will start a new shell and connect to it. Create a new variable called &lt;code&gt;hello&lt;/code&gt; and assign some value to it:</source>
          <target state="translated">위의 명령은 새로운 쉘을 시작하고 연결합니다. &lt;code&gt;hello&lt;/code&gt; 라는 새 변수를 작성하고 값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="604e09637e094315eab98b85fbd210082725e389" translate="yes" xml:space="preserve">
          <source>The command name will correspond to the portion of the module name following &lt;code&gt;Mix.Tasks.&lt;/code&gt;. For example, a module name of &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt;&lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt;&lt;/a&gt; corresponds to a task name of &lt;code&gt;deps.clean&lt;/code&gt;.</source>
          <target state="translated">명령 이름은 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 다음의 모듈 이름 부분에 해당합니다 . . 예를 들어 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Clean.html&quot;&gt; &lt;code&gt;Mix.Tasks.Deps.Clean&lt;/code&gt; &lt;/a&gt; 의 모듈 이름은 deps.clean 의 작업 이름에 &lt;code&gt;deps.clean&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8ecae1fb9875a4247d5f5ea9609a8cfd1c1df1d2" translate="yes" xml:space="preserve">
          <source>The community has also created its own tools, often to aid in production, other times in development:</source>
          <target state="translated">커뮤니티는 또한 종종 개발을 위해 생산을 돕기 위해 자체 도구를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="efb56379060db8ad190cf0cb0689ca498a14c785" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 간의 비교는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f587be913201bd350f5a6a58f7e5d2545a34fce" translate="yes" xml:space="preserve">
          <source>The comparison between elements must be done using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요소 간의 비교는 &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86fab95de2a0427fca68934f781f6fe06670a789" translate="yes" xml:space="preserve">
          <source>The compilation can be customized by passing a &lt;code&gt;compile&lt;/code&gt; option in the dependency:</source>
          <target state="translated">종속성에 &lt;code&gt;compile&lt;/code&gt; 옵션 을 전달하여 컴파일을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72ead9d1380c933dae651b694aba918748f04d3" translate="yes" xml:space="preserve">
          <source>The compilation will fail because &lt;code&gt;My.Module&lt;/code&gt; when quoted is not an atom, but a syntax tree as follows:</source>
          <target state="translated">인용 할 때 &lt;code&gt;My.Module&lt;/code&gt; 이 원자가 아니라 다음과 같은 구문 트리 이므로 컴파일이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="cd0d32bee722121f8e488a947a395b8badae67cf" translate="yes" xml:space="preserve">
          <source>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</source>
          <target state="translated">컴파일 된 패턴은 동일한 일치가 계속 반복 될 때 유용합니다. 패턴은 런타임에 생성되고 컴파일 시간 동안 유지되지 않으므로 컴파일 된 패턴은 모듈 속성에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c261a06d80c478e0111d6983a7ae911378fd70b" translate="yes" xml:space="preserve">
          <source>The compiler is telling us that invoking the &lt;code&gt;join&lt;/code&gt; function with two arguments will always choose the first definition of &lt;code&gt;join&lt;/code&gt; whereas the second one will only be invoked when three arguments are passed:</source>
          <target state="translated">컴파일러는 두 개의 인수로 &lt;code&gt;join&lt;/code&gt; 함수 를 호출 하면 항상 첫 번째 &lt;code&gt;join&lt;/code&gt; 정의를 선택 하고 두 번째 인수는 세 개의 인수가 전달 될 때만 호출된다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4a5b9456e8b2526749824cf107036fdea5219003" translate="yes" xml:space="preserve">
          <source>The compiler translates this into multiple functions with different arities, here &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; and &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt;, that represent cases when arguments for parameters with default values are passed or not passed.</source>
          <target state="translated">컴파일러는이 값을 다른 &lt;code&gt;MyMath.multiply_by/1&lt;/code&gt; 여기서는 MyMath.multiply_by / 1 및 &lt;code&gt;MyMath.multiply_by/2&lt;/code&gt; ) 과 함께 여러 함수로 변환 하여 기본값을 가진 매개 변수의 인수가 전달되거나 전달되지 않는 경우를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fbf77ba7c519d57f697a772e3efbb085cc5c852a" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, and so on. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 임시 모듈을 사용하여 코드를 컴파일합니다. 예를 들어 &lt;code&gt;elixir_compiler_1&lt;/code&gt; , &lt;code&gt;elixir_compiler_2&lt;/code&gt; 등입니다. 컴파일 된 코드가 익명 함수 또는 유사 함수에 대한 참조를 저장하는 경우 Elixir 컴파일러는 해당 모듈을 회수하지 &lt;code&gt;elixir_compiler_12345&lt;/code&gt; 불필요한 양의 코드를 메모리에 유지하고 결국 elixir_compiler_12345 와 같은 모듈로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ad36289d9fc32f9ce285a83c0db949e85318f5" translate="yes" xml:space="preserve">
          <source>The compiler utilizes temporary modules to compile code. For example, &lt;code&gt;elixir_compiler_1&lt;/code&gt;, &lt;code&gt;elixir_compiler_2&lt;/code&gt;, etc. In case the compiled code stores references to anonymous functions or similar, the Elixir compiler may be unable to reclaim those modules, keeping an unnecessary amount of code in memory and eventually leading to modules such as &lt;code&gt;elixir_compiler_12345&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 임시 모듈을 사용하여 코드를 컴파일합니다. 예를 들어, &lt;code&gt;elixir_compiler_1&lt;/code&gt; , &lt;code&gt;elixir_compiler_2&lt;/code&gt; 등입니다. 컴파일 된 코드가 익명 함수 또는 유사한 것에 대한 참조를 저장하는 경우, Elixir 컴파일러는 해당 모듈을 회수 할 수 없어 메모리에 불필요한 코드를 유지하고 결국 &lt;code&gt;elixir_compiler_12345&lt;/code&gt; 와 같은 모듈로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e326f0b1277ff195521c682d15083f035944526" translate="yes" xml:space="preserve">
          <source>The compiler will infer this argument as &lt;code&gt;map&lt;/code&gt;. Sometimes the inference will be suboptimal, especially if the function contains multiple clauses with the argument matching on different values each time. You can specify the proper names for documentation by declaring only the function head at any moment before the implementation:</source>
          <target state="translated">컴파일러는이 인수를 &lt;code&gt;map&lt;/code&gt; 으로 유추합니다 . 때로는 함수가 매번 다른 값에 일치하는 인수를 가진 여러 절을 포함하는 경우 추론이 차선책이 될 수 있습니다. 구현하기 전에 언제든지 함수 헤드 만 선언하여 문서의 올바른 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68165d5af4e0c7518ce750565d2875d5f1b99f6f" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, e.g. &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">&lt;code&gt;a ++ b&lt;/code&gt; 의 복잡성은 &lt;code&gt;length(a)&lt;/code&gt; 비례 하므로 임의의 길이의 &lt;code&gt;list ++ [element]&lt;/code&gt; 예 : list ++ [element])에 반복적으로 추가하지 마십시오 . 대신 &lt;code&gt;[element | rest]&lt;/code&gt; 그리고 반전.</target>
        </trans-unit>
        <trans-unit id="51b97324d416e9860c0329e32ca5a0050e8a20b3" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a ++ b&lt;/code&gt; is proportional to &lt;code&gt;length(a)&lt;/code&gt;, so avoid repeatedly appending to lists of arbitrary length, for example, &lt;code&gt;list ++ [element]&lt;/code&gt;. Instead, consider prepending via &lt;code&gt;[element | rest]&lt;/code&gt; and then reversing.</source>
          <target state="translated">&lt;code&gt;a ++ b&lt;/code&gt; 의 복잡성은 &lt;code&gt;length(a)&lt;/code&gt; 비례 하므로 임의 길이의 목록에 반복적으로 추가하지 마십시오 (예 : &lt;code&gt;list ++ [element]&lt;/code&gt; . 대신 &lt;code&gt;[element | rest]&lt;/code&gt; 그리고 후진.</target>
        </trans-unit>
        <trans-unit id="ce5190846b0b9ce88bde5e1fb9838155c0302562" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;a -- b&lt;/code&gt; is proportional to &lt;code&gt;length(a) * length(b)&lt;/code&gt;, meaning that it will be very slow if both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are long lists. In such cases, consider converting each list to a &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; and using &lt;a href=&quot;mapset#difference/2&quot;&gt;&lt;code&gt;MapSet.difference/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a -- b&lt;/code&gt; 의 복잡도는 &lt;code&gt;length(a) * length(b)&lt;/code&gt; 비례 하므로 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 긴 목록 인 경우 속도가 느려집니다 . 이러한 경우 각 목록을 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 으로&lt;/a&gt; 변환 하고 &lt;a href=&quot;mapset#difference/2&quot;&gt; &lt;code&gt;MapSet.difference/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="84ce76ba55c26126100351cef4100465580a3f63" translate="yes" xml:space="preserve">
          <source>The compressed option must be combined with either read or write, but not both. Note that the file size obtained with &lt;a href=&quot;#stat/1&quot;&gt;&lt;code&gt;stat/1&lt;/code&gt;&lt;/a&gt; will most probably not match the number of bytes that can be read from a compressed file.</source>
          <target state="translated">압축 옵션은 읽기 또는 쓰기와 결합되어야하지만 둘 다와 결합해서는 안됩니다. &lt;a href=&quot;#stat/1&quot;&gt; &lt;code&gt;stat/1&lt;/code&gt; 로&lt;/a&gt; 얻은 파일 크기 는 압축 파일에서 읽을 수있는 바이트 수와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2bc42beb1d07a11bffabca4e75ecee65b8f3cc" translate="yes" xml:space="preserve">
          <source>The concurrency can be increased or decreased using the &lt;code&gt;:max_concurrency&lt;/code&gt; option. For example, if the tasks are IO heavy, the value can be increased:</source>
          <target state="translated">&lt;code&gt;:max_concurrency&lt;/code&gt; 옵션을 사용하여 동시성을 늘리거나 줄일 수 있습니다 . 예를 들어, 작업이 IO가 많은 경우 값을 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dcb06049bb00d9d82db3a23393505f88e85183b" translate="yes" xml:space="preserve">
          <source>The configurations are merged together with the values in the second one having higher preference than the first in case of conflicts. In case both values are set to keyword lists, it deep merges them.</source>
          <target state="translated">구성은 충돌시 첫 번째보다 선호도가 높은 두 번째 값과 병합됩니다. 두 값이 모두 키워드 목록으로 설정되어 있으면 깊이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="8bfd0598c3186c98ed3b75f81d353f661a54c9d0" translate="yes" xml:space="preserve">
          <source>The console backend allows you to customize the format of your log messages with the &lt;code&gt;:format&lt;/code&gt; option.</source>
          <target state="translated">콘솔 백엔드에서는 &lt;code&gt;:format&lt;/code&gt; 옵션 을 사용하여 로그 메시지의 형식을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7235027880d78a2aea2ca7dc4debaca1a57f60b0" translate="yes" xml:space="preserve">
          <source>The console backend logs messages by printing them to the console. It supports the following options:</source>
          <target state="translated">콘솔 백엔드는 콘솔에 메시지를 인쇄하여 메시지를 기록합니다. 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b55d6ec1cda71844493902f9fd51af5232de80cd" translate="yes" xml:space="preserve">
          <source>The contents are compared to avoid asking the user to override if the contents did not change. Returns false if the file exists and the content is the same or the user forbade to override it. Returns true otherwise.</source>
          <target state="translated">내용이 변경되지 않은 경우 사용자에게 재정의하도록 요청하지 않도록 내용을 비교합니다. 파일이 존재하고 내용이 동일하거나 사용자가 덮어 쓰기를 금지 한 경우 false를 반환합니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de6b43b33ab75286e101ec804e217bdf4636eeb" translate="yes" xml:space="preserve">
          <source>The context is used to pass information from the callbacks to the test. In order to pass information from the test to the callback, ExUnit provides tags.</source>
          <target state="translated">컨텍스트는 콜백에서 테스트로 정보를 전달하는 데 사용됩니다. 테스트에서 콜백으로 정보를 전달하기 위해 ExUnit은 태그를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0ac124f60dd5f0bf6457e5116fc9264ff455388d" translate="yes" xml:space="preserve">
          <source>The context returned by &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt; will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself. For instance, the &lt;code&gt;conn&lt;/code&gt; from the previous example can be accessed as:</source>
          <target state="translated">&lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; &lt;/a&gt; 에서 반환 된 컨텍스트는 모든 후속 &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;test&lt;/code&gt; 자체 에서 사용할 수 있습니다. 예를 들어, 이전 예제 의 &lt;code&gt;conn&lt;/code&gt; 은 다음과 같이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df9b547258c058ce1d60f5a04eb16b39a7714b90" translate="yes" xml:space="preserve">
          <source>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</source>
          <target state="translated">연속은 열거가 일시 중단 될 때 결과로 반환되는 클로저입니다. 호출되면 새로운 누산기를 기대하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95e2451a8bd06ec3ff7404ffc596006e9814e181" translate="yes" xml:space="preserve">
          <source>The correct way to write the refutation above is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위의 반박을 쓰는 올바른 방법은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt; &lt;code&gt;Kernel.match?/2&lt;/code&gt; &lt;/a&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="471e051b1dfc7605a0864374979ff909fdd918ff" translate="yes" xml:space="preserve">
          <source>The corresponding child process must not be running; use &lt;a href=&quot;#terminate_child/2&quot;&gt;&lt;code&gt;terminate_child/2&lt;/code&gt;&lt;/a&gt; to terminate it if it's running.</source>
          <target state="translated">해당 하위 프로세스가 실행되고 있으면 안됩니다. 실행중인 경우 &lt;a href=&quot;#terminate_child/2&quot;&gt; &lt;code&gt;terminate_child/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="25f2832dc850f5e3ce868623e448ed6173ae8a76" translate="yes" xml:space="preserve">
          <source>The crypto module</source>
          <target state="translated">암호화 모듈</target>
        </trans-unit>
        <trans-unit id="6c25b4183ffb2089e8226e185f14e599e79dc998" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 환경은 언제든지 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 으로 액세스 할 수 있습니다 . 매크로 내에서 호출자 환경은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ecd090fb1dcdddfdde8d184412bdb4ef34572bf" translate="yes" xml:space="preserve">
          <source>The current environment can be accessed at any time as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;. Inside macros, the caller environment can be accessed as &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 환경은 언제라도 &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 으로 액세스 할 수 있습니다 . 매크로 내에서 호출자 환경은 &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; 으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3e60a2c1efd523ca96fe66ffa2af8ecfa3ad2af" translate="yes" xml:space="preserve">
          <source>The current working directory is set for the BEAM globally. This can lead to race conditions if multiple processes are changing the current working directory concurrently. To run an external command in a given directory without changing the global current working directory, use the &lt;code&gt;:cd&lt;/code&gt; option of &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 작업 디렉토리는 BEAM에 대해 전역 적으로 설정됩니다. 여러 프로세스가 현재 작업 디렉토리를 동시에 변경하는 경우 경쟁 조건이 발생할 수 있습니다. 전역 현재 작업 디렉토리를 변경하지 않고 주어진 디렉토리에서 외부 명령을 실행하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;:cd&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="11ca9436cf4382b007a36385f24017c6fe9ea438" translate="yes" xml:space="preserve">
          <source>The daemon will write all of its standard output to the &quot;tmp/log/&quot; directory in the release root. You can watch the log file by doing &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; or similar. Once files get too large, the index suffix will be incremented. A developer can also attach to the standard input of the daemon by invoking &quot;to_erl tmp/pipe/&quot; from the release root. However, note that attaching to the system should be done with extreme care, since the usual commands for exiting an Elixir system, such as hitting Ctrl+C twice or Ctrl+\, will actually shut down the daemon. Therefore, using &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; should be preferred, even in daemon mode.</source>
          <target state="translated">데몬은 모든 표준 출력을 릴리스 루트의 &quot;tmp / log /&quot;디렉토리에 기록합니다. &lt;code&gt;tail -f tmp/log/erlang.log.1&lt;/code&gt; 또는 이와 유사한 작업을 수행하여 로그 파일을 볼 수 있습니다 . 파일이 너무 커지면 색인 접미사가 증가합니다. 개발자는 릴리스 루트에서 &quot;to_erl tmp / pipe /&quot;를 호출하여 데몬의 표준 입력에 연결할 수도 있습니다. 그러나 시스템에 연결하는 것은 매우주의해서 수행해야합니다. Ctrl + C를 두 번 누르거나 Ctrl + \를 두 번 누르는 것과 같은 Elixir 시스템을 종료하는 일반적인 명령은 실제로 데몬을 종료하기 때문입니다. 따라서 데몬 모드에서도 &lt;code&gt;bin/RELEASE_NAME remote&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d8cd8e8b468d03cac9b2aec5728511f109cbd6ae" translate="yes" xml:space="preserve">
          <source>The data structure you are implementing the protocol for must be the first argument to all functions defined in the protocol.</source>
          <target state="translated">프로토콜을 구현하는 데이터 구조는 프로토콜에 정의 된 모든 함수에 대한 첫 번째 인수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b2d538224a6564739f222b37335408e88b676276" translate="yes" xml:space="preserve">
          <source>The date and time fields in the struct can be accessed directly:</source>
          <target state="translated">구조체의 날짜 및 시간 필드에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa23e38a0ca17fbedb614ea88023f4b1e8f6b6f" translate="yes" xml:space="preserve">
          <source>The datetime can be any of the Calendar types (&lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;) or any map, as long as they contain all of the relevant fields necessary for formatting. For example, if you use &lt;code&gt;%Y&lt;/code&gt; to format the year, the datetime must have the &lt;code&gt;:year&lt;/code&gt; field. Therefore, if you pass a &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, or a map without the &lt;code&gt;:year&lt;/code&gt; field to a format that expects &lt;code&gt;%Y&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">datetime은 형식 지정에 필요한 모든 관련 필드가 포함되어있는 경우 달력 유형 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; ) 또는지도 일 수 있습니다. 예를 들어, &lt;code&gt;%Y&lt;/code&gt; 를 사용하여 연도를 형식화하는 경우 datetime에는 &lt;code&gt;:year&lt;/code&gt; 필드 가 있어야 합니다. 따라서 &lt;a href=&quot;https://hexdocs.pm/elixir/Time.html&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;:year&lt;/code&gt; 필드가 없는 맵을 &lt;code&gt;%Y&lt;/code&gt; 예상하는 형식으로 전달 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="104ca7733bdc0fce19ec1a42bd6f6c3a9728b295" translate="yes" xml:space="preserve">
          <source>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</source>
          <target state="translated">일은 그레고리력 일로 계산됩니다. 날짜는 주어진 날짜와 동일한 달력으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="81de1658f9b930a338fa7d15b3cd46a31f6ce081" translate="yes" xml:space="preserve">
          <source>The default engine used by EEx.</source>
          <target state="translated">EEx에서 사용하는 기본 엔진.</target>
        </trans-unit>
        <trans-unit id="5c2506b585933bcf9d63b9d589d2095db52d7f38" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">기본 노드는 로컬 노드 인 &lt;a href=&quot;#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt; 입니다. 경우 &lt;code&gt;node&lt;/code&gt; 로컬 노드가,이 함수는 또한 다른 모든 알 수없는 노드의 쿠키 설정 &lt;code&gt;cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1841b4dcd409156ad003b434d7d06485770c7448" translate="yes" xml:space="preserve">
          <source>The default node is &lt;a href=&quot;node#self/0&quot;&gt;&lt;code&gt;Node.self/0&lt;/code&gt;&lt;/a&gt;, the local node. If &lt;code&gt;node&lt;/code&gt; is the local node, the function also sets the cookie of all other unknown nodes to &lt;code&gt;cookie&lt;/code&gt;.</source>
          <target state="translated">기본 노드는 로컬 노드 인 &lt;a href=&quot;node#self/0&quot;&gt; &lt;code&gt;Node.self/0&lt;/code&gt; &lt;/a&gt; 입니다. 경우 &lt;code&gt;node&lt;/code&gt; 로컬 노드가,이 함수는 또한 다른 모든 알 수없는 노드의 쿠키 설정 &lt;code&gt;cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee7448078e00a12f44bc6d6a512061a6e8e76068" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The first row after the header contains the sums of the partial results and the average time for all the function calls listed. The following rows contain the function call, followed by the number of times that the function was called, then by the percentage of time that the call uses, then the total time for that function in microseconds, and, finally, the average time per call in microseconds.</source>
          <target state="translated">기본 출력에는 모든 일치하는 기능에서 수집 된 데이터가 포함됩니다. 헤더 다음의 첫 번째 행에는 부분 결과의 합계와 나열된 모든 함수 호출의 평균 시간이 포함됩니다. 다음 행에는 함수 호출, 함수 호출 횟수, 호출 사용 시간 백분율, 해당 함수의 총 시간 (마이크로 초) 및 마지막으로 호출 당 평균 시간이 포함됩니다. 마이크로 초</target>
        </trans-unit>
        <trans-unit id="ea39ed70f4785b6c480b790dacca9bfe36cb2b1f" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all matching functions. The left column structures each module and its total call count trace is presented on the right. Each module has its count discriminated by function below. The &lt;code&gt;&amp;lt;--&lt;/code&gt; symbol is meant to help visualize where a new module call count begins.</source>
          <target state="translated">기본 출력에는 모든 일치하는 기능에서 수집 된 데이터가 포함됩니다. 왼쪽 열은 각 모듈을 구성하고 총 호출 수 추적은 오른쪽에 표시됩니다. 각 모듈의 개수는 아래 기능별로 구분됩니다. &lt;code&gt;&amp;lt;--&lt;/code&gt; 새 모듈 호출 횟수가 시작되는 기호는 도움말 시각화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="819e6f3391fb45f7ce5241a6dd1d1431dc481702" translate="yes" xml:space="preserve">
          <source>The default output contains data gathered from all profiled processes. All times are wall clock milliseconds. The columns have the following meaning:</source>
          <target state="translated">기본 출력에는 모든 프로파일 링 된 프로세스에서 수집 된 데이터가 포함됩니다. 모든 시간은 벽시계 밀리 초입니다. 열의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27a16bfaa2e09572a48e318dc8d0f73e02fd7ff6" translate="yes" xml:space="preserve">
          <source>The default value will not be passed through the update function.</source>
          <target state="translated">기본값은 업데이트 기능을 통해 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="380321e8388d234e55ec92513260d8b22df6e305" translate="yes" xml:space="preserve">
          <source>The definition above wouldn't work for this particular example, as it would attempt to start the counter with an initial value of an empty list. However, this may be a viable option in your own agents. A common approach is to use a keyword list, as that would allow setting the initial value and giving a name to the counter process, for example:</source>
          <target state="translated">위의 정의는 빈 목록의 초기 값으로 카운터를 시작하려고 시도 하므로이 특정 예제에서는 작동하지 않습니다. 그러나 이것은 자신의 에이전트에서 실행 가능한 옵션 일 수 있습니다. 일반적인 방법은 키워드 목록을 사용하는 것입니다. 키워드 목록을 사용하면 초기 값을 설정하고 카운터 프로세스에 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14e3a7f1b4ff430ef2347af078514bfcd6aac53f" translate="yes" xml:space="preserve">
          <source>The dependencies' versions are expected to be formatted according to Semantic Versioning and the requirements must be specified as defined in the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">종속성 버전은 시맨틱 버전 관리에 따라 형식화 될 것으로 예상되며 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된대로 요구 사항을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0199850bb5adebc71f4018576818506ad556f1cc" translate="yes" xml:space="preserve">
          <source>The device will be created and sent to the function given. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">장치가 생성되어 주어진 기능으로 전송됩니다. 함수가 반환되면 장치가 닫힙니다. 최종 결과는 &lt;code&gt;:ok&lt;/code&gt; 와 함수 결과가 포함 된 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="92c1c70614d3e16189eb567106d0cd377288e598" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;===&lt;/code&gt; is that the latter is more strict when comparing integers and floats:</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;===&lt;/code&gt; 의 차이점은 정수와 부동 소수점을 비교할 때 후자가 더 엄격하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bce9ae6a81650ed69afbfa89ac267aa5dbf3c9da" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">두 접근 방식의 차이점은 모듈 기반 감독자가 감독자가 초기화되는 방식을보다 직접적으로 제어 할 수 있다는 것입니다. 자동으로 초기화되는 자식 목록과 함께 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt; 를 호출하는 대신 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 내에서 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; 를 호출하여 자식을 수동으로 초기화했습니다 .</target>
        </trans-unit>
        <trans-unit id="7b165d79002d46e097dd675e283b2c25db64a858" translate="yes" xml:space="preserve">
          <source>The difference between the two approaches is that a module-based supervisor gives you more direct control over how the supervisor is initialized. Instead of calling &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt; with a list of children that are automatically initialized, we manually initialized the children by calling &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; inside its &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">두 방법의 차이점은 모듈 기반 감독자가 감독자가 초기화되는 방식을보다 직접적으로 제어 할 수 있다는 것입니다. 자동으로 초기화되는 자식 목록으로 &lt;a href=&quot;supervisor#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; &lt;/a&gt; 를 호출하는 대신 , &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 안에서 &lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; 를 호출하여 자식을 수동으로 초기화했습니다 .</target>
        </trans-unit>
        <trans-unit id="3b5eb7b6faff508891acf9d2eb056d03565a244c" translate="yes" xml:space="preserve">
          <source>The difference is that anonymous functions require the target node to have exactly the same code version as the caller. Using module, function, and arguments is more robust because you only need to find a function with matching arity in the given module.</source>
          <target state="translated">차이점은 익명 함수는 대상 노드가 호출자와 정확히 동일한 코드 버전을 가져야한다는 것입니다. 주어진 모듈에서 일치하는 arity를 ​​가진 함수를 찾기 만하면되기 때문에 모듈, 함수 및 인수를 사용하는 것이 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="42de26ff16cbc728a59ab8e0d11febc5d9712289" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차이점은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; 가&lt;/a&gt;&lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; 가 호출 되는 순간 하위 사양을 예상 하고 더 이상 init 콜백에 있지 않다는 것입니다. &lt;code&gt;[initial_arg]&lt;/code&gt; 와 같이 초기화시 지정된 초기 인수가있는 경우 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;:extra_arguments&lt;/code&gt; 플래그에 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5358501133f2ba56bf1b306cdd649fc8fee2e62a" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; expects the child specification at the moment &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt; is called, and no longer on the init callback. If there are any initial arguments given on initialization, such as &lt;code&gt;[initial_arg]&lt;/code&gt;, it can be given in the &lt;code&gt;:extra_arguments&lt;/code&gt; flag on &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차이점은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; &lt;/a&gt; 가 호출 되는 순간의 자식 사양을 예상 하고 더 이상 init 콜백을 기대하지 않는다는 것입니다. 초기화에 주어진 초기 인수 (예 : &lt;code&gt;[initial_arg]&lt;/code&gt; )가 있으면 &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;:extra_arguments&lt;/code&gt; 플래그에 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53c4296a8b739f59bee25619f4e6585ba6646d78" translate="yes" xml:space="preserve">
          <source>The digraph module</source>
          <target state="translated">디 그래프 모듈</target>
        </trans-unit>
        <trans-unit id="d3687778e68f2e38fa3eb29706a7417475b459a2" translate="yes" xml:space="preserve">
          <source>The document starts flat (without breaks) until a group is found.</source>
          <target state="translated">그룹이 발견 될 때까지 문서는 중단없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad969954076e16dcc1ff7f0c2aba06e5e46ee7f" translate="yes" xml:space="preserve">
          <source>The dot (&lt;code&gt;.&lt;/code&gt;) in Elixir can be used for remote calls:</source>
          <target state="translated">Elixir 의 점 ( &lt;code&gt;.&lt;/code&gt; )은 원격 통화에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555f5e20b9d1a7a0564cfc99c5aa3c497147b302" translate="yes" xml:space="preserve">
          <source>The dot may be used to invoke anonymous functions too:</source>
          <target state="translated">이 점은 익명 함수를 호출하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bfa76913b9787750a0bfa227b60b3c7658a646a" translate="yes" xml:space="preserve">
          <source>The downside of this approach is that the doctest result is not really what users would see in the terminal.</source>
          <target state="translated">이 접근 방식의 단점은 doctest 결과가 실제로 사용자가 터미널에서 볼 수있는 것과 다르다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b457ad21100bb14e953ebf6025ecbe3add69796" translate="yes" xml:space="preserve">
          <source>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</source>
          <target state="translated">리턴 된 두 목록의 요소는 원래 열거 가능한 것과 동일한 상대 순서입니다 (목록과 같은 열거 가능한 순서가 지정된 경우). 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46fd29816806a299fb407c730c9ba36ba20c158f" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. It is required to return either &lt;code&gt;{:ok, term}&lt;/code&gt;, where term is an atom. It is possible to return something else than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">엔코더 함수는 주어진 문자열에서 아톰을 생성해야합니다. &lt;code&gt;{:ok, term}&lt;/code&gt; 을 리턴해야합니다 . 여기서 term은 원자입니다. 원자 이외의 것을 반환하는 것이 가능하지만,이 경우 AST는 더 이상 &quot;유효하지 않음&quot;으로 엘릭서 코드를 컴파일하거나 평가하는 데 사용할 수 없습니다. 유스 케이스는 사용자가 직면 한 상황에서 Elixir 파서를 사용하고 싶지만 원자 테이블을 소진하고 싶지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="865f48d17fe14cd4996952b1bd0f45d973a938ce" translate="yes" xml:space="preserve">
          <source>The encoder function is supposed to create an atom from the given string. To produce a valid AST, it is required to return &lt;code&gt;{:ok, term}&lt;/code&gt;, where &lt;code&gt;term&lt;/code&gt; is an atom. It is possible to return something other than an atom, however, in that case the AST is no longer &quot;valid&quot; in that it cannot be used to compile or evaluate Elixir code. A use case for this is if you want to use the Elixir parser in a user-facing situation, but you don't want to exhaust the atom table.</source>
          <target state="translated">인코더 함수는 주어진 문자열에서 원자를 생성하도록되어 있습니다. 유효한 AST를 생성하려면 &lt;code&gt;{:ok, term}&lt;/code&gt; 을 반환해야합니다 . 여기서 &lt;code&gt;term&lt;/code&gt; 은 원자입니다. 원자가 아닌 다른 것을 반환 할 수도 있지만,이 경우 AST는 Elixir 코드를 컴파일하거나 평가하는 데 사용할 수 없다는 점에서 더 이상 &quot;유효&quot;하지 않습니다. 이에 대한 사용 사례는 사용자가 직면하는 상황에서 Elixir 파서를 사용하고 싶지만 atom 테이블을 소모하고 싶지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="7abcd054d6c0c3b0676a107d280986f037e15ba1" translate="yes" xml:space="preserve">
          <source>The encoder function will receive the atom name (as a binary) and a keyword list with the current file, line and column. It must return &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt;.</source>
          <target state="translated">인코더 함수는 원자 이름 (2 진)과 현재 파일, 행 및 열이있는 키워드 목록을받습니다. &lt;code&gt;{:ok, token :: term} | {:error, reason :: binary}&lt;/code&gt; 리턴해야합니다 . | {: 오류, 이유 :: 이진} .</target>
        </trans-unit>
        <trans-unit id="d93739e1f908805f248fbd3ca05efb8a31a93ffb" translate="yes" xml:space="preserve">
          <source>The environment</source>
          <target state="translated">환경</target>
        </trans-unit>
        <trans-unit id="b1059c7023600cf66d37436e09b5b8c7e27f7d77" translate="yes" xml:space="preserve">
          <source>The environment applies only to the current project. As we will see in future chapters, any dependency you add to your project will by default run in the &lt;code&gt;:prod&lt;/code&gt; environment.</source>
          <target state="translated">환경은 현재 프로젝트에만 적용됩니다. 다음 장에서 살펴 보 겠지만 프로젝트에 추가 한 모든 종속성은 기본적으로 &lt;code&gt;:prod&lt;/code&gt; 환경 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="569fc959f1dad768558df72d1e65bcb68e016b15" translate="yes" xml:space="preserve">
          <source>The environment can be changed via the command line by setting the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable, for example:</source>
          <target state="translated">다음과 같이 &lt;code&gt;MIX_ENV&lt;/code&gt; 환경 변수 를 설정하여 명령 행을 통해 환경을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="514025daae02cae2313ca1d48fbcc882bf070826" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경은 &lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; 을&lt;/a&gt; 통해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfd48ae86d7fb6e0cc9118fb73487346d9610f87" translate="yes" xml:space="preserve">
          <source>The environment can be read via &lt;a href=&quot;mix#env/0&quot;&gt;&lt;code&gt;Mix.env/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경은 &lt;a href=&quot;mix#env/0&quot;&gt; &lt;code&gt;Mix.env/0&lt;/code&gt; 을&lt;/a&gt; 통해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79b786be3813b81bda2dd7613367e75b678039b6" translate="yes" xml:space="preserve">
          <source>The environment is available after loading the application, which is a process explained later:</source>
          <target state="translated">애플리케이션을로드 한 후 환경을 사용할 수 있습니다.이 프로세스는 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="97a5f35bc8e443b15b7816310584c96da8ae8afe" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;exunit.test&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exunit.testmodule&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exunit.test&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exunit.testmodule&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; 이&lt;/a&gt; 반환 한 오류 상태</target>
        </trans-unit>
        <trans-unit id="1dd062c870a86dc73f9a75e2843a53a9fc3ffd4b" translate="yes" xml:space="preserve">
          <source>The error state returned by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; 에서&lt;/a&gt; 반환하는 오류 상태</target>
        </trans-unit>
        <trans-unit id="67a7d2b9fd9ee22fe670aa85c88c37eecda3144b" translate="yes" xml:space="preserve">
          <source>The exact chunks that are kept are not documented and may change in future versions.</source>
          <target state="translated">유지되는 정확한 청크는 문서화되지 않았으며 향후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd79581f4945ce7000f24bd77d80edb09d58223a" translate="yes" xml:space="preserve">
          <source>The example above broadcasted the message &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; to all processes registered under the &quot;topic&quot; (or &quot;key&quot; as we called it until now) &lt;code&gt;&quot;hello&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 예제는 &lt;code&gt;{:broadcast, &quot;world&quot;}&lt;/code&gt; 메시지를 &quot;topic&quot;(또는 지금까지 호출 한 &quot;key&quot;) &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 아래에 등록 된 모든 프로세스에 브로드 캐스트 했습니다 .</target>
        </trans-unit>
        <trans-unit id="85cebbc730e74ea1586122c70e3648ace6b606a3" translate="yes" xml:space="preserve">
          <source>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with &lt;code&gt;100_000&lt;/code&gt; items. Then we keep all odd elements from the list, generating a new list, now with &lt;code&gt;50_000&lt;/code&gt; items, and then we sum all entries.</source>
          <target state="translated">위의 예제에는 작업 파이프 라인이 있습니다. 범위로 시작한 다음 범위의 각 요소에 3을 곱합니다.이 첫 번째 조작은 이제 &lt;code&gt;100_000&lt;/code&gt; 개의 항목 으로 목록을 작성하고 리턴 합니다. 그런 다음 모든 홀수 요소를 목록에서 유지하고 이제 &lt;code&gt;50_000&lt;/code&gt; 개의 항목 으로 새 목록을 생성 한 다음 모든 항목을 합산합니다.</target>
        </trans-unit>
        <trans-unit id="d7a86a0bce3d2d4979cfe2b252cb1ba44bf3ffc0" translate="yes" xml:space="preserve">
          <source>The example above is the same as calling &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt;.</source>
          <target state="translated">위의 예제는 &lt;code&gt;List.flatten([1, [2], 3])&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="34a98e7e58a5ad26483cead8675329ffdc04e919" translate="yes" xml:space="preserve">
          <source>The example above rescues the runtime error and returns the error itself which is then printed in the &lt;code&gt;iex&lt;/code&gt; session.</source>
          <target state="translated">위의 예제는 런타임 오류를 해결하고 오류 자체를 반환 한 다음 &lt;code&gt;iex&lt;/code&gt; 세션 에서 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a1acf2309aa592e7d6d6148eb2c43c7439baf836" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred strategy for customizing exception messages.</source>
          <target state="translated">위의 예는 예외 메시지를 사용자 정의하기위한 기본 전략을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c4ee977260f8fcae5e39eaa8c9f47beb473c79e" translate="yes" xml:space="preserve">
          <source>The example above will define two modules: &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt;. The second can be accessed as &lt;code&gt;Bar&lt;/code&gt; inside &lt;code&gt;Foo&lt;/code&gt; as long as they are in the same lexical scope. The code above is exactly the same as:</source>
          <target state="translated">위의 예제는 &lt;code&gt;Foo&lt;/code&gt; 및 &lt;code&gt;Foo.Bar&lt;/code&gt; 의 두 모듈을 정의 합니다. 두 번째는 동일한 어휘 범위에있는 한 &lt;code&gt;Foo&lt;/code&gt; 내 에서 &lt;code&gt;Bar&lt;/code&gt; 로 액세스 할 수 있습니다 . 위의 코드는 다음과 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8af5b80536d2c072fd5d6366536aa5700dca7b65" translate="yes" xml:space="preserve">
          <source>The example above will fetch the first 10 lines of the file you have selected. This means streams can be very useful for handling large files or even slow resources like network resources.</source>
          <target state="translated">위의 예는 선택한 파일의 처음 10 줄을 가져옵니다. 즉, 스트림은 대용량 파일이나 네트워크 리소스와 같은 느린 리소스를 처리하는 데 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="696bcc0172521f253466c2cb561bc8d6cc698268" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">위의 예는 &lt;code&gt;x&lt;/code&gt; 가 오른쪽 목록의 첫 번째 값과 일치하는 경우에만 작동 합니다. 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/MatchError.html&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; 가 발생합니다&lt;/a&gt; ( &lt;code&gt;=&lt;/code&gt; 연산자 처럼 ).</target>
        </trans-unit>
        <trans-unit id="b5335acb8d877ec62b7cb06ce91a567ae1709575" translate="yes" xml:space="preserve">
          <source>The example above will only work if &lt;code&gt;x&lt;/code&gt; matches the first value in the right list. Otherwise, it will raise a &lt;a href=&quot;matcherror&quot;&gt;&lt;code&gt;MatchError&lt;/code&gt;&lt;/a&gt; (like the &lt;code&gt;=&lt;/code&gt; operator would do).</source>
          <target state="translated">위의 예는 &lt;code&gt;x&lt;/code&gt; 가 오른쪽 목록의 첫 번째 값과 일치하는 경우에만 작동 합니다. 그렇지 않으면 &lt;code&gt;=&lt;/code&gt; 연산자 처럼 &lt;a href=&quot;matcherror&quot;&gt; &lt;code&gt;MatchError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b460f75ed7a246aed0999b0840cd9a86244be18" translate="yes" xml:space="preserve">
          <source>The example above will print:</source>
          <target state="translated">위의 예는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="fb87f61c9de07aa0c29854b1fe6c1165c0f17fed" translate="yes" xml:space="preserve">
          <source>The example above will run all tests that have the external option set to &lt;code&gt;true&lt;/code&gt;. It is also possible to include all examples that have a given tag, regardless of its value:</source>
          <target state="translated">위의 예제는 외부 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 모든 테스트를 실행 합니다 . 값에 관계없이 주어진 태그가있는 모든 예제를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a35cc3928c93cd1525534e5aae37a525e3a1f63a" translate="yes" xml:space="preserve">
          <source>The example below prints the available compilers and then the list of dependencies.</source>
          <target state="translated">아래 예제는 사용 가능한 컴파일러와 종속성 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="fd542bcb5f7a7bfb0b02572bb9041c4454ce88bf" translate="yes" xml:space="preserve">
          <source>The examples below use the &lt;code&gt;:exrop&lt;/code&gt; pseudorandom algorithm since it's the default from Erlang/OTP 20, however if you are using Erlang/OTP 22 or above then &lt;code&gt;:exsss&lt;/code&gt; is the default algorithm. If you are using &lt;code&gt;:exsplus&lt;/code&gt;, then please update, as this algorithm is deprecated since Erlang/OTP 20.</source>
          <target state="translated">아래 예제 는 Erlang / OTP 20의 기본값이므로 &lt;code&gt;:exrop&lt;/code&gt; 의사 난수 알고리즘을 사용하지만 Erlang / OTP 22 이상을 사용하는 경우 &lt;code&gt;:exsss&lt;/code&gt; 가 기본 알고리즘입니다. &lt;code&gt;:exsplus&lt;/code&gt; 를 사용 하는 경우이 알고리즘은 Erlang / OTP 20 이후로 더 이상 사용되지 않으므로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="977b62dac31ac2298799e3e82efadb76ace792aa" translate="yes" xml:space="preserve">
          <source>The examples below will use &lt;code&gt;break!&lt;/code&gt;, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name &lt;code&gt;IEx.break!&lt;/code&gt;.</source>
          <target state="translated">아래 예제는 &lt;code&gt;break!&lt;/code&gt; 를 사용합니다 ! IEx 셸에서 직접 중단 점을 설정한다고 가정합니다. 그러나 정규화 된 이름 &lt;code&gt;IEx.break!&lt;/code&gt; 사용하여 어디서나 휴식을 설정할 수 있습니다 ! .</target>
        </trans-unit>
        <trans-unit id="598b6c321009ab41147aeda0cc432613c93bc6ff" translate="yes" xml:space="preserve">
          <source>The exception type</source>
          <target state="translated">예외 유형</target>
        </trans-unit>
        <trans-unit id="96d166dd9433a91274c33b5c64faa14557b71d73" translate="yes" xml:space="preserve">
          <source>The expected result should start at the next line after the &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and it is terminated either by a newline.</source>
          <target state="translated">예상되는 결과는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;...&amp;gt;&lt;/code&gt; 행 뒤의 다음 행에서 시작해야 하며 개행으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ef1dcbe751c0f9e41d4eb9dc12ae9aa4ff81e740" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</source>
          <target state="translated">이 함수가 Erlang의 용어 순서를 사용한다는 것은 비교가 의미가 아니라 구조적이라는 것을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d619b509d29dcc70d09a1c1eedfade7f7d69f11" translate="yes" xml:space="preserve">
          <source>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a &quot;compare&quot; function, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt;, which receives two structs and returns &lt;code&gt;:lt&lt;/code&gt; (less-than), &lt;code&gt;:eq&lt;/code&gt; (equal to), and &lt;code&gt;:gt&lt;/code&gt; (greater-than). If you pass a module as the sorting function, Elixir will automatically use the &lt;code&gt;compare/2&lt;/code&gt; function of said module:</source>
          <target state="translated">이 함수가 Erlang의 용어 순서를 사용한다는 사실은 비교가 의미가 아니라 구조적이라는 것을 의미합니다. 따라서 구조체를 비교하려는 경우 대부분의 구조체 는 두 개의 구조체를 수신하고 &lt;code&gt;:lt&lt;/code&gt; (보다 작음), &lt;code&gt;:eq&lt;/code&gt; (같음) 및 &lt;code&gt;:gt&lt;/code&gt; 를 반환하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; 와 같은 &quot;비교&quot;함수를 제공 합니다 . (보다 큰). 모듈을 정렬 함수로 전달하면 Elixir는 자동으로 해당 모듈 의 &lt;code&gt;compare/2&lt;/code&gt; 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a8e9535a979f24690a83f0d69ec866c95c5b87d9" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;enum#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">이 기능은 사용에 대한 경고를 표시하여 효과적으로 사용되지 않습니다. 이것은 사용 중단이라고도합니다. 기능을 더 이상 사용하지 않으려면 최소 3 개의 마이너 버전에 대해 제안 된 대안이 있어야합니다. 예를 들어, &lt;code&gt;Enum.uniq/2&lt;/code&gt; 는 Elixir v1.1에서 &lt;a href=&quot;enum#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt; 에 유리하게 사용되지 않습니다 . 이는 지원 중단 경고가 Elixir v1.4 이상에서만 발생할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="767e9fa4f6cbd49737c9ee934e26b4707f937c6f" translate="yes" xml:space="preserve">
          <source>The feature is effectively deprecated by emitting warnings on usage. This is also known as hard-deprecation. In order to deprecate a feature, the proposed alternative MUST exist for AT LEAST THREE minor versions. For example, &lt;code&gt;Enum.uniq/2&lt;/code&gt; was soft-deprecated in favor of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt;&lt;code&gt;Enum.uniq_by/2&lt;/code&gt;&lt;/a&gt; in Elixir v1.1. This means a deprecation warning may only be emitted by Elixir v1.4 or later.</source>
          <target state="translated">이 기능은 사용시 경고를 표시하여 효과적으로 사용되지 않습니다. 이를 영구 지원 중단이라고도합니다. 기능을 폐기하려면 제안 된 대안이 최소 3 개의 부 버전에 대해 존재해야합니다. 예를 들어, &lt;code&gt;Enum.uniq/2&lt;/code&gt; 는 Elixir v1.1에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#uniq_by/2&quot;&gt; &lt;code&gt;Enum.uniq_by/2&lt;/code&gt; &lt;/a&gt; 를 위해 소프트 사용되지 않습니다 . 즉, 지원 중단 경고는 Elixir v1.4 이상에서만 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77826c76ea0072ad69d2f391c353d094902019fd" translate="yes" xml:space="preserve">
          <source>The feature is removed. This can only happen on major releases. This means deprecated features in Elixir v1.x shall only be removed by Elixir v2.x.</source>
          <target state="translated">기능이 제거되었습니다. 이것은 주요 릴리스에서만 발생할 수 있습니다. 이는 Elixir v1.x에서 사용되지 않는 기능은 Elixir v2.x에 의해서만 제거되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="64f27bcc28943bbd06806f078df1fb5cd0c4fa41" translate="yes" xml:space="preserve">
          <source>The feature is soft-deprecated. It means both CHANGELOG and documentation must list the feature as deprecated but no warning is effectively emitted by running the code. There is no requirement to soft-deprecate a feature.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 이는 CHANGELOG와 문서 모두 기능을 더 이상 사용되지 않는 것으로 표시해야하지만 코드를 실행해도 효과적으로 경고가 표시되지 않습니다. 기능을 소프트 더 이상 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf695dceb54489cced53f84555aabadc2f0e697" translate="yes" xml:space="preserve">
          <source>The file is created if it does not exist. If it exists, the previous contents are overwritten. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">파일이 없으면 작성됩니다. 존재하는 경우 이전 내용을 덮어 씁니다. 성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="d594748254e0bf9d6de08774efbf46885ccdc846" translate="yes" xml:space="preserve">
          <source>The file is created if it doesn't exist. Requires datetime in UTC (as returned by &lt;code&gt;:erlang.universaltime()&lt;/code&gt;) or an integer representing the POSIX timestamp (as returned by &lt;code&gt;System.os_time(:second)&lt;/code&gt;).</source>
          <target state="translated">파일이 없으면 작성됩니다. 날짜 시간 (UTC) ( &lt;code&gt;:erlang.universaltime()&lt;/code&gt; 반환 ) 또는 POSIX 타임 스탬프를 나타내는 정수 ( &lt;code&gt;System.os_time(:second)&lt;/code&gt; 반환 )가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16e6a8d0dd5fc8fad11975b4cd8380cee1d272d3" translate="yes" xml:space="preserve">
          <source>The file is opened, given to the function as an argument and automatically closed after the function returns, regardless if there was an error when executing the function.</source>
          <target state="translated">함수에 인수로 제공된 파일이 열리고 함수를 실행할 때 오류가 있는지 여부에 관계없이 함수가 리턴 된 후 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7da78c24b03af92a331655b22affad9970828441" translate="yes" xml:space="preserve">
          <source>The file will be compiled in memory and executed, printing &amp;ldquo;3&amp;rdquo; as the result. No bytecode file will be created. In the following examples, we recommend you write your code into script files and execute them as shown above.</source>
          <target state="translated">파일이 메모리에 컴파일되고 실행되어 결과적으로&amp;ldquo;3&amp;rdquo;이 인쇄됩니다. 바이트 코드 파일이 생성되지 않습니다. 다음 예제에서는 코드를 스크립트 파일에 작성하여 위에 표시된대로 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="163b392b3771b3d68e4cabd76e12f649d752ed1d" translate="yes" xml:space="preserve">
          <source>The final code for the application built in this guide is in &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;this repository&lt;/a&gt; and can be used as a reference.</source>
          <target state="translated">이 안내서에 빌드 된 애플리케이션의 최종 코드는 &lt;a href=&quot;https://github.com/josevalim/kv_umbrella&quot;&gt;이 저장소에&lt;/a&gt; 있으며 참조로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="849e4d016851d364ddd912997469160b512c2434" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">최종 모듈 이름은 &lt;code&gt;MyHelpers.Module&lt;/code&gt; 아니라 &lt;code&gt;My.Module&lt;/code&gt; 입니다. 함께 &lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; &lt;/a&gt; 와 같은 별칭이 고려됩니다. 로컬 및 원격 매크로도 확장됩니다. 위의 매크로를 다시 작성하여이 함수를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeed0a9446d454784748ae3c92f5f970ae5e8749" translate="yes" xml:space="preserve">
          <source>The final module name will be &lt;code&gt;MyHelpers.Module&lt;/code&gt; and not &lt;code&gt;My.Module&lt;/code&gt;. With &lt;a href=&quot;macro#expand/2&quot;&gt;&lt;code&gt;Macro.expand/2&lt;/code&gt;&lt;/a&gt;, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</source>
          <target state="translated">최종 모듈 이름은 &lt;code&gt;MyHelpers.Module&lt;/code&gt; 아니라 &lt;code&gt;My.Module&lt;/code&gt; 입니다. 함께 &lt;a href=&quot;macro#expand/2&quot;&gt; &lt;code&gt;Macro.expand/2&lt;/code&gt; &lt;/a&gt; 와 같은 별칭이 고려됩니다. 로컬 및 원격 매크로도 확장됩니다. 이 함수를 다음과 같이 사용하기 위해 위의 매크로를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94b7aa6c8d6098097b882564487315e75f42062" translate="yes" xml:space="preserve">
          <source>The first argument given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; is a list of child specifications as defined in the &quot;child_spec/1&quot; section above.</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; 에&lt;/a&gt; 제공된 첫 번째 인수 는 위의 &quot;child_spec / 1&quot;섹션에 정의 된 하위 스펙 목록입니다.</target>
        </trans-unit>
        <trans-unit id="13a0df9187b50523011cbb4505688a72e2b67377" translate="yes" xml:space="preserve">
          <source>The first argument is the application name. The second argument &lt;code&gt;key_or_path&lt;/code&gt; is either an atom key or a path to traverse in search of the configuration, starting with an atom key.</source>
          <target state="translated">첫 번째 인수는 애플리케이션 이름입니다. 두 번째 인수 &lt;code&gt;key_or_path&lt;/code&gt; 는 원자 키 또는 구성을 검색 할 때 탐색 할 경로이며 원자 키로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3bd0d4cfc55b69d9253066edc78349e5a5f0a43e" translate="yes" xml:space="preserve">
          <source>The first clause above will only match when &lt;code&gt;x&lt;/code&gt; is positive.</source>
          <target state="translated">위의 첫 번째 절은 &lt;code&gt;x&lt;/code&gt; 가 양수일 때만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="eb035f0f30f88032dbb2e6101c25284087903853" translate="yes" xml:space="preserve">
          <source>The first clause has a guard which says &amp;ldquo;use this definition if and only if &lt;code&gt;n&lt;/code&gt; is less than or equal to &lt;code&gt;1&lt;/code&gt;&amp;rdquo;. Since this is not the case, Elixir proceeds to the next clause&amp;rsquo;s definition.</source>
          <target state="translated">첫 번째 절에는&amp;ldquo; &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 보다 작거나 같은 경우에만이 정의를 사용하십시오&amp;rdquo;라는 가드가 있습니다 . 이는 사실이 아니므로 Elixir는 다음 절의 정의로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="89e50c2ad64d1cb084a88caace5a204ed21c004f" translate="yes" xml:space="preserve">
          <source>The first column is the version the feature was hard deprecated. The second column shortly describes the deprecated feature and the third column explains the replacement and from which the version the replacement is available from.</source>
          <target state="translated">첫 번째 열은 기능이 더 이상 사용되지 않는 버전입니다. 두 번째 열은 더 이상 사용되지 않는 기능을 설명하고 세 번째 열은 교체와 교체가 가능한 버전을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="090b48aa7b27ba7aabd1d7a17461511059a79e62" translate="yes" xml:space="preserve">
          <source>The first element is always dropped, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 이 0이 아니면 첫 번째 요소는 항상 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="f10968f84672fced5f1e4ec8ec8d8d3398ac17ef" translate="yes" xml:space="preserve">
          <source>The first element is always included, unless &lt;code&gt;nth&lt;/code&gt; is 0.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 가 0이 아닌 한 첫 번째 요소는 항상 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d62944a019ad040d05e692b397bd4389633cb416" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function, unless &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이 아닌 경우 첫 번째 요소는 항상 주어진 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d3d07fd30dfdee5089f7add816955448e8a7e62" translate="yes" xml:space="preserve">
          <source>The first element is always passed to the given function.</source>
          <target state="translated">첫 번째 요소는 항상 주어진 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="a20362c2ee76acf3525cfe072360096fe727a0f9" translate="yes" xml:space="preserve">
          <source>The first element is an atom or another tuple in the same representation;</source>
          <target state="translated">첫 번째 요소는 동일한 표현에서 원자 또는 다른 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="de5cd0ed2836b580d20a53b60b89fdbc3744b2af" translate="yes" xml:space="preserve">
          <source>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list.</source>
          <target state="translated">첫 번째 요소는 함수 이름이고 두 번째 요소는 메타 데이터를 포함하는 키워드 목록이고 세 번째 요소는 인수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8b93358d99cbfe2c9b65df07674bef6d363d42e0" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;enumerable&lt;/code&gt; is used as the initial value of the accumulator. Then the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the &lt;code&gt;enumerable&lt;/code&gt; is done, the last accumulator is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 첫 번째 요소 는 누산기의 초기 값으로 사용됩니다. 그런 다음 함수는 다음 요소와 누산기로 호출됩니다. 함수에 의해 반환 된 결과는 다음 반복의 누산기로 재귀 적으로 사용됩니다. 때 &lt;code&gt;enumerable&lt;/code&gt; 완료, 마지막 축적이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ff5ed72f8d68d33e831fb03d181cb08f9312e39a" translate="yes" xml:space="preserve">
          <source>The first element of the tuple is always an atom or another tuple in the same representation.</source>
          <target state="translated">튜플의 첫 번째 요소는 항상 동일한 표현에서 원자 또는 다른 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="3622c3705870af3b02b55f90fe91c49c65360502" translate="yes" xml:space="preserve">
          <source>The first element of these tuples is known as the &lt;em&gt;key&lt;/em&gt;, and it must be an atom. The second element, known as the &lt;em&gt;value&lt;/em&gt;, can be any term.</source>
          <target state="translated">이러한 튜플의 첫 번째 요소는 &lt;em&gt;key&lt;/em&gt; 로 알려져 있으며 원자 여야합니다. &lt;em&gt;값으로&lt;/em&gt; 알려진 두 번째 요소 는 모든 용어가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="753965fc9c8c958c1adc18030905ea9a9fce1c71" translate="yes" xml:space="preserve">
          <source>The first function blocks the agent. The second function copies all the state to the client and then executes the operation in the client. One aspect to consider is whether the data is large enough to require processing in the server, at least initially, or small enough to be sent to the client cheaply. Another factor is whether the data needs to be processed atomically: getting the state and calling &lt;code&gt;do_something_expensive(state)&lt;/code&gt; outside of the agent means that the agent's state can be updated in the meantime. This is specially important in case of updates as computing the new state in the client rather than in the server can lead to race conditions if multiple clients are trying to update the same state to different values.</source>
          <target state="translated">첫 번째 기능은 에이전트를 차단합니다. 두 번째 함수는 모든 상태를 클라이언트에 복사 한 다음 클라이언트에서 작업을 실행합니다. 고려해야 할 한 가지 측면은 데이터가 서버에서 처리해야 할만큼 충분히 큰지, 적어도 초기에 또는 클라이언트에게 싸게 보낼 수있을 정도로 작은 지 여부입니다. 또 다른 요인은 데이터를 원자 적으로 처리해야하는지 여부입니다. 상태를 가져 와서 에이전트 외부에서 &lt;code&gt;do_something_expensive(state)&lt;/code&gt; 호출 하면 그 동안 에이전트 상태를 업데이트 할 수 있습니다. 여러 클라이언트가 동일한 상태를 다른 값으로 업데이트하려고 할 경우 서버가 아닌 클라이언트에서 새 상태를 계산하면 경쟁 조건이 발생할 수 있으므로 업데이트시 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3a8bdc0ad5ea0cf6a739758090fdb5a2d0573fc4" translate="yes" xml:space="preserve">
          <source>The first function is &lt;code&gt;start_link/1&lt;/code&gt;, which starts a new GenServer passing a list of options. &lt;code&gt;start_link/1&lt;/code&gt; calls out to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;, which takes three arguments:</source>
          <target state="translated">첫 번째 기능은 &lt;code&gt;start_link/1&lt;/code&gt; 이며, 옵션 목록을 전달하는 새 GenServer를 시작합니다. &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 은 GenServer.start_link / 3 를 호출합니다 . 여기에는 세 가지 인수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6da90265feaa08cdbd5c291c792941296efaf6fb" translate="yes" xml:space="preserve">
          <source>The first is the &lt;code&gt;init/1&lt;/code&gt; callback, that receives the second argument given to &lt;code&gt;GenServer.start_link/3&lt;/code&gt; and returns &lt;code&gt;{:ok, state}&lt;/code&gt;, where state is a new map. We can already notice how the &lt;code&gt;GenServer&lt;/code&gt; API makes the client/server segregation more apparent. &lt;code&gt;start_link/3&lt;/code&gt; happens in the client, while &lt;code&gt;init/1&lt;/code&gt; is the respective callback that runs on the server.</source>
          <target state="translated">첫 번째는 &lt;code&gt;init/1&lt;/code&gt; 콜백으로 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; 에 주어진 두 번째 인수를 받고 &lt;code&gt;{:ok, state}&lt;/code&gt; 반환합니다 . 여기서 state는 새로운 맵입니다. 우리는 이미 &lt;code&gt;GenServer&lt;/code&gt; API가 어떻게 클라이언트 / 서버 분리를보다 명백하게 하는지 알 수 있습니다 . &lt;code&gt;start_link/3&lt;/code&gt; 는 클라이언트에서 발생하지만 &lt;code&gt;init/1&lt;/code&gt; 은 서버에서 실행되는 각각의 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="6abd6bfc1ce31ae2f7f3cf73ef51afa902c3df53" translate="yes" xml:space="preserve">
          <source>The first is to rely on the fact that doctest can compare internal structures as long as they are at the root. So one could write:</source>
          <target state="translated">첫 번째는 doctest가 루트에있는 한 내부 구조를 비교할 수 있다는 사실에 의존하는 것입니다. 따라서 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56525212a2d836e7b2e6c9fc3d438debd74b1ce4" translate="yes" xml:space="preserve">
          <source>The first occurrence of each element is kept.</source>
          <target state="translated">각 요소의 첫 번째 항목이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6fdbbd4ad4f56c5f2d4b83c9b51836d3c3baff1c" translate="yes" xml:space="preserve">
          <source>The first one is related to operator precedence. For example, the following expression:</source>
          <target state="translated">첫 번째는 연산자 우선 순위와 관련이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb6432ba2d593bb02b187beac0081aecf4153a10" translate="yes" xml:space="preserve">
          <source>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</source>
          <target state="translated">첫 번째는 코드가 실제로 평가되고 컴파일되지 않는다는 것입니다. 이는 셸에서 수행 된 모든 벤치마킹 결과가 왜곡 될 수 있음을 의미합니다. 따라서 쉘에서 프로파일 링이나 벤치 마크를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9aa7af0b736df8170b447c11a0b1486409c8447e" translate="yes" xml:space="preserve">
          <source>The first one is with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; which we can use instead of &lt;code&gt;IO.inspect binding()&lt;/code&gt;:</source>
          <target state="translated">첫 번째는 &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; 이며 &lt;code&gt;IO.inspect binding()&lt;/code&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cece2699937857700a6e57ae7a8e2fdab1620e09" translate="yes" xml:space="preserve">
          <source>The first part, the match pattern, must be a tuple that will match the structure of the the data stored in the registry, which is &lt;code&gt;{key, pid, value}&lt;/code&gt;. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison. This can be combined like &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt;.</source>
          <target state="translated">첫 번째 부분 인 일치 패턴은 레지스트리에 저장된 데이터의 구조 ( &lt;code&gt;{key, pid, value}&lt;/code&gt; 와 일치하는 튜플이어야합니다 . atom &lt;code&gt;:_&lt;/code&gt; 은 주어진 값이나 튜플 요소를 무시하는 데 사용될 수 있지만 atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 은 후속 비교를 위해 변수에 패턴의 일부를 임시로 할당하는 데 사용될 수 있습니다. 이것은 &lt;code&gt;{:&quot;$1&quot;, :_, :_}&lt;/code&gt; 과 같이 결합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33bf9cc2d09af8093ef73164f4425101ddcff356" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all function calls. In the last row the number of matching functions that were considered for profiling is presented.</source>
          <target state="translated">첫 번째 행 (전체)은 모든 함수 호출의 합계입니다. 마지막 행에는 프로파일 링을 위해 고려 된 일치 함수 수가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c85192b0b88529b2ffa5c7dc5ed794fb80bfa927" translate="yes" xml:space="preserve">
          <source>The first row (Total) is the sum of all functions executed in all profiled processes. For the given output, we had a total of 200279 function calls and spent about 2 seconds running the code.</source>
          <target state="translated">첫 번째 행 (총계)은 모든 프로파일 링 된 프로세스에서 실행 된 모든 기능의 합계입니다. 주어진 출력에 대해 총 200279 개의 함수 호출이 있었고 코드를 실행하는 데 약 2 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="7cd60f6007c291382d0b163734079218de4d7d65" translate="yes" xml:space="preserve">
          <source>The first step in our implementation is to call &lt;code&gt;use Agent&lt;/code&gt;.</source>
          <target state="translated">구현의 첫 단계는 &lt;code&gt;use Agent&lt;/code&gt; 를 호출 하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="868cc4dcae35b14912938b182f9884b2f9e36c22" translate="yes" xml:space="preserve">
          <source>The first step is to tell our application definition (i.e. our &lt;code&gt;.app&lt;/code&gt; file) which module is going to implement the application callback. Let&amp;rsquo;s do so by opening &lt;code&gt;mix.exs&lt;/code&gt; and changing &lt;code&gt;def application&lt;/code&gt; to the following:</source>
          <target state="translated">첫 번째 단계는 애플리케이션 콜백을 구현할 모듈을 애플리케이션 정의 (예 : &lt;code&gt;.app&lt;/code&gt; 파일) 에 알리는 것 입니다. &lt;code&gt;mix.exs&lt;/code&gt; 를 열고 &lt;code&gt;def application&lt;/code&gt; 을 다음과 같이 변경 하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="b1db7f18a01e941b219c679437813ff0c63b86ff" translate="yes" xml:space="preserve">
          <source>The first step to do so is to add a &lt;code&gt;:mod&lt;/code&gt; key to the &lt;code&gt;application/0&lt;/code&gt; definition in your &lt;code&gt;mix.exs&lt;/code&gt; file. It expects a tuple, with the application callback module and start argument (commonly an empty list):</source>
          <target state="translated">이를위한 첫 번째 단계는 &lt;code&gt;mix.exs&lt;/code&gt; 파일 의 &lt;code&gt;application/0&lt;/code&gt; 정의에 &lt;code&gt;:mod&lt;/code&gt; 키를 추가하는 것 입니다. 애플리케이션 콜백 모듈과 시작 인수 (일반적으로 빈 목록)가있는 튜플이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="08b35c8002543aef4eef62b9715905dd1c3e096e" translate="yes" xml:space="preserve">
          <source>The first test invokes &lt;code&gt;Kernel.node/0&lt;/code&gt;, which returns the name of the current node, based on the bucket names &amp;ldquo;hello&amp;rdquo; and &amp;ldquo;world&amp;rdquo;. According to our routing table so far, we should get &lt;code&gt;foo@computer-name&lt;/code&gt; and &lt;code&gt;bar@computer-name&lt;/code&gt; as responses, respectively.</source>
          <target state="translated">첫 번째 테스트는 &lt;code&gt;Kernel.node/0&lt;/code&gt; 을 호출 하여 버킷 이름&amp;ldquo;hello&amp;rdquo;및&amp;ldquo;world&amp;rdquo;를 기반으로 현재 노드의 이름을 반환합니다. 지금까지 라우팅 테이블에 따르면 &lt;code&gt;foo@computer-name&lt;/code&gt; 및 &lt;code&gt;bar@computer-name&lt;/code&gt; 을 각각 응답으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="aac5f450f7a22287bfbd1ca580bfb413b84283d5" translate="yes" xml:space="preserve">
          <source>The first time this task is run with &lt;code&gt;--stale&lt;/code&gt;, all tests are run and a manifest is generated. On subsequent runs, a test file is marked &quot;stale&quot; if any modules it references (and any modules those modules reference, recursively) were modified since the last run with &lt;code&gt;--stale&lt;/code&gt;. A test file is also marked &quot;stale&quot; if it has been changed since the last run with &lt;code&gt;--stale&lt;/code&gt;.</source>
          <target state="translated">이 작업이 &lt;code&gt;--stale&lt;/code&gt; 로 처음 실행될 때 모든 테스트가 실행되고 매니페스트가 생성됩니다. 이후 실행시 &lt;code&gt;--stale&lt;/code&gt; 을 사용 하여 마지막 실행 이후 참조한 모듈 (및 해당 모듈이 참조하는 모든 모듈)이 수정 된 경우 테스트 파일은 &quot;stale&quot;로 표시 됩니다. &lt;code&gt;--stale&lt;/code&gt; 로 마지막 실행 이후에 변경된 테스트 파일도 &quot;stale&quot;로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="295fb12141f4c89eb596a5dac17f4949547acbec" translate="yes" xml:space="preserve">
          <source>The following attributes are part of typespecs and are also built-in in Elixir:</source>
          <target state="translated">다음 속성은 typespecs의 일부이며 Elixir에도 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ddb17433dfdb141914290560e8f56274113cff7" translate="yes" xml:space="preserve">
          <source>The following behaviour applies if &lt;code&gt;reason&lt;/code&gt; is any term except &lt;code&gt;:normal&lt;/code&gt; or &lt;code&gt;:kill&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 이 &lt;code&gt;:normal&lt;/code&gt; 또는 &lt;code&gt;:kill&lt;/code&gt; 이외의 용어 인 경우 다음 동작이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cc6a385de289ddbe867800f5a4d45eaf506d87a" translate="yes" xml:space="preserve">
          <source>The following code is clearer:</source>
          <target state="translated">다음 코드가 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="bd520f433c3d9627651ec8f3c46e49f2f0b40321" translate="yes" xml:space="preserve">
          <source>The following commands are supported by &lt;code&gt;bin/RELEASE_NAME&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; 은 다음 명령을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6fa07c7c4a4b08ed5ab5840982521232d9dc60" translate="yes" xml:space="preserve">
          <source>The following configuration applies to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;'s wrapper around Erlang's logging functionalities. All the configurations below must be set before the &lt;code&gt;:logger&lt;/code&gt; application starts.</source>
          <target state="translated">다음 구성 은 Erlang의 로깅 기능을 둘러싼 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 래퍼에 적용됩니다 . &lt;code&gt;:logger&lt;/code&gt; 애플리케이션을 시작 하기 전에 아래의 모든 구성을 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2b59ddac9c85343e9c0315f555148e29de15b834" translate="yes" xml:space="preserve">
          <source>The following configuration must be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">&lt;code&gt;:logger&lt;/code&gt; 애플리케이션을 시작 하기 전에 구성 파일 (예 : &lt;code&gt;config/config.exs&lt;/code&gt; )을 통해 다음 구성을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7468ef5075d9f1bb00ad4478b84201c0051a39d2" translate="yes" xml:space="preserve">
          <source>The following configurations apply only for Erlang/OTP 20 and earlier:</source>
          <target state="translated">다음 구성은 Erlang / OTP 20 및 이전 버전에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5bee2fb68242ae2a980fb37c51c72ff07363e60a" translate="yes" xml:space="preserve">
          <source>The following contents are expanded:</source>
          <target state="translated">다음 내용이 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="184db633c0e9a1d1d50d51efc796a68bbb36b312" translate="yes" xml:space="preserve">
          <source>The following document has 10 bytes and therefore it does not format to width 9 without breaks:</source>
          <target state="translated">다음 문서에는 10 바이트가 있으므로 나누지 않고 너비 9로 형식을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de1fd9b941b49b602c0ebc3107ff23bc87d50045" translate="yes" xml:space="preserve">
          <source>The following escape codes can be used in strings and char lists:</source>
          <target state="translated">문자열 및 문자 목록에 다음 이스케이프 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c26c5de3e4e7cd245868d8c611a09003ff421aa" translate="yes" xml:space="preserve">
          <source>The following events are possible:</source>
          <target state="translated">다음 이벤트가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d46d9ba3da9322ecdf037e20b892895d0db04656" translate="yes" xml:space="preserve">
          <source>The following fields are available:</source>
          <target state="translated">사용 가능한 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7293829d505cc3a0054aa1a59ac73bad4f509dae" translate="yes" xml:space="preserve">
          <source>The following fields are deprecated and must not be accessed or relied on:</source>
          <target state="translated">다음 필드는 더 이상 사용되지 않으며 액세스하거나 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9526796f05e114fb24325e062cf85e1db31da0" translate="yes" xml:space="preserve">
          <source>The following fields are private to Elixir's macro expansion mechanism and must not be accessed directly:</source>
          <target state="translated">다음 필드는 Elixir의 매크로 확장 메커니즘에 대한 비공개이며 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30c2e9695ce3105ad651330d3b52e46b3a324658" translate="yes" xml:space="preserve">
          <source>The following fields are public:</source>
          <target state="translated">다음 필드는 공개입니다 :</target>
        </trans-unit>
        <trans-unit id="4144d492a1a8552ba49119bd2fcd0fd26179f7b6" translate="yes" xml:space="preserve">
          <source>The following fields may be modified as long as they keep their defined types:</source>
          <target state="translated">다음 필드는 정의 된 유형을 유지하는 한 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecaaab8e8eae9b4df4d22551bafa8feaa1ec9420" translate="yes" xml:space="preserve">
          <source>The following fields pertain to variable handling and must not be accessed or relied on. To get a list of all variables, see &lt;a href=&quot;#vars/1&quot;&gt;&lt;code&gt;vars/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 필드는 변수 처리와 관련이 있으며 액세스하거나 의존해서는 안됩니다. 모든 변수의 목록을 얻으려면 &lt;a href=&quot;#vars/1&quot;&gt; &lt;code&gt;vars/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8fcb5815c5a0952c38de454edd61e7d1f142d6d" translate="yes" xml:space="preserve">
          <source>The following is a list of all operators that Elixir is capable of parsing, ordered from higher to lower precedence, alongside their associativity:</source>
          <target state="translated">다음은 Elixir가 연관성과 함께 우선 순위가 높은 순서대로 구문 분석 할 수있는 모든 연산자의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9104e819567333a6da0e8ce2dab5b947458c30fd" translate="yes" xml:space="preserve">
          <source>The following is a table of all the operators that Elixir is capable of parsing, but that are not used by default:</source>
          <target state="translated">다음은 Elixir가 구문 분석 할 수 있지만 기본적으로 사용되지 않는 모든 연산자의 표입니다.</target>
        </trans-unit>
        <trans-unit id="0ba751c3adfd8a7fc2856a1dbf3e62fbc4ec76f2" translate="yes" xml:space="preserve">
          <source>The following keys are optional:</source>
          <target state="translated">다음 키는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7b884b576e7fc0feccc202abb8a4a3d2fbce2d97" translate="yes" xml:space="preserve">
          <source>The following keys are returned:</source>
          <target state="translated">다음 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf2cdc4ebfa3f4a0590ef2625ba82e196ae8c2a8" translate="yes" xml:space="preserve">
          <source>The following literals are also supported in typespecs:</source>
          <target state="translated">다음 리터럴은 typespec에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b914b4fb7bd70067053e9e95983328f16ab1fd00" translate="yes" xml:space="preserve">
          <source>The following macros are generated:</source>
          <target state="translated">다음과 같은 매크로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8b11c8558e4b5ede506774a8ccaf530f1714eee7" translate="yes" xml:space="preserve">
          <source>The following metadata keys are enabled by &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt;&lt;code&gt;Code.string_to_quoted/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 메타 데이터 키는 &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#string_to_quoted/2&quot;&gt; &lt;code&gt;Code.string_to_quoted/2&lt;/code&gt; 에서&lt;/a&gt; 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="73eaa1cbb3b18d9fd1ab6f109e8770b921b255f4" translate="yes" xml:space="preserve">
          <source>The following metadata keys are private:</source>
          <target state="translated">다음 메타 데이터 키는 비공개입니다.</target>
        </trans-unit>
        <trans-unit id="a19a723fcc38df91c7efce744ef29817327ec398" translate="yes" xml:space="preserve">
          <source>The following metadata keys are public:</source>
          <target state="translated">다음 메타 데이터 키는 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a2d7253e70d0b7ab68844ea930f5d415637299" translate="yes" xml:space="preserve">
          <source>The following modules build on top of processes to provide concurrency, fault-tolerance, and more.</source>
          <target state="translated">다음 모듈은 프로세스 위에 구축되어 동시성, 내결함성 등을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4f887b33e0c44ae6b51e81b5ab7bc56ab3d3fc4" translate="yes" xml:space="preserve">
          <source>The following modules handle Elixir built-in data types:</source>
          <target state="translated">다음 모듈은 Elixir 내장 데이터 유형을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="16b7215fb9d992fc605683d883c23ca3932275a5" translate="yes" xml:space="preserve">
          <source>The following names are reserved and cannot be assigned to processes nor ports:</source>
          <target state="translated">다음 이름은 예약되어 있으며 프로세스 나 포트에 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b3878c8ab3dccd7e89f167b65de39bd2f92844f" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">가져올 때 &lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 모듈 에서 다음 연산자를 사용합니다 . &lt;a href=&quot;bitwise#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%255E%255E%255E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%253C%253C%253C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%253E%253E%253E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bitwise#%257C%257C%257C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;bitwise#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="178f615607801ccb48b704fc1947669dd0349eaf" translate="yes" xml:space="preserve">
          <source>The following operators are used by the &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; module when imported: &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt;&lt;code&gt;^^^&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt;&lt;code&gt;|||&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt;&lt;code&gt;~~~&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">다음 연산자는 가져올 때 &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 모듈에서 사용됩니다 : &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#&amp;amp;&amp;amp;&amp;amp;/2&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%5E%5E%5E/2&quot;&gt; &lt;code&gt;^^^&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3C%3C%3C/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%3E%3E%3E/2&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#%7C%7C%7C/2&quot;&gt; &lt;code&gt;|||&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html#~~~/1&quot;&gt; &lt;code&gt;~~~&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="77f3895c41618839ee5e26a20028be3be4ec2b1d" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">&lt;code&gt;:escript&lt;/code&gt; 키 아래 &lt;code&gt;mix.exs&lt;/code&gt; 에 다음 옵션을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf3f75fb4a0fa1361326143ff900caf814328a06" translate="yes" xml:space="preserve">
          <source>The following option must be specified in your &lt;code&gt;mix.exs&lt;/code&gt; under the &lt;code&gt;:escript&lt;/code&gt; key:</source>
          <target state="translated">다음 옵션은 &lt;code&gt;:escript&lt;/code&gt; 키 아래의 &lt;code&gt;mix.exs&lt;/code&gt; 에 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">다음과 같은 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab6a9f1a0bbaef19cacfbc5c31136467bf2e22d" translate="yes" xml:space="preserve">
          <source>The following options are supported:</source>
          <target state="translated">다음과 같은 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5d2ba16817e078ffdf67dfcad431c49900869b20" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your &lt;code&gt;mix.exs&lt;/code&gt; on each release definition:</source>
          <target state="translated">다음 옵션은 각 릴리스 정의 의 &lt;code&gt;mix.exs&lt;/code&gt; 내에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e0b1eaa4142d08cf206798562baf46888ee1a50" translate="yes" xml:space="preserve">
          <source>The following options can be set inside your releases key in your &lt;code&gt;mix.exs&lt;/code&gt; to control how config providers work:</source>
          <target state="translated">구성 공급자의 작동 방식을 제어 하기 위해 &lt;code&gt;mix.exs&lt;/code&gt; 의 릴리스 키 내에 다음 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a63388a7d9c69cb081c0bd25c0b348227ea8b98e" translate="yes" xml:space="preserve">
          <source>The following restart values are supported in the &lt;code&gt;:restart&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; 옵션 에서 다음 재시작 값이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3bfac8b769dcde18c31230db7c8155e1610b73f" translate="yes" xml:space="preserve">
          <source>The following sets up a breakpoint on &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt; 에 중단 점을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="af7f88d381759e98fbd8a59a2974fdc1427bfa5a" translate="yes" xml:space="preserve">
          <source>The following shutdown values are supported in the &lt;code&gt;:shutdown&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 옵션 에서는 다음과 같은 종료 값이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="62c95490240e6721731c2a4166fbf474d701eaa5" translate="yes" xml:space="preserve">
          <source>The following switches take one argument:</source>
          <target state="translated">다음 스위치는 하나의 인수를 취합니다.</target>
        </trans-unit>
        <trans-unit id="09182b59468032ac91eb3e19cfac73cd63919777" translate="yes" xml:space="preserve">
          <source>The following switches types take no arguments:</source>
          <target state="translated">다음 스위치 유형에는 인수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="656560aa5a4b69ea097162499366d646d82b57a2" translate="yes" xml:space="preserve">
          <source>The following tags are set automatically by ExUnit and are therefore reserved:</source>
          <target state="translated">다음 태그는 ExUnit에 의해 자동으로 설정되므로 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="5fc9716a622a264a8eff71eefa013048286d3378" translate="yes" xml:space="preserve">
          <source>The following tags customize how tests behave:</source>
          <target state="translated">다음 태그는 테스트 작동 방식을 사용자 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f3f1a1a3a62e3160fd586f6ee95d4fab3af95423" translate="yes" xml:space="preserve">
          <source>The following tasks are automatically reenabled: &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.do&quot;&gt;&lt;code&gt;mix do&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt;&lt;code&gt;mix loadconfig&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt;&lt;code&gt;mix profile.cprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt;&lt;code&gt;mix profile.eprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt;&lt;code&gt;mix profile.fprof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.do&quot;&gt; &lt;code&gt;mix do&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.loadconfig&quot;&gt; &lt;code&gt;mix loadconfig&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.profile.cprof&quot;&gt; &lt;code&gt;mix profile.cprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.profile.eprof&quot;&gt; &lt;code&gt;mix profile.eprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.profile.fprof&quot;&gt; &lt;code&gt;mix profile.fprof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt; 작업이 자동으로 다시 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="94b02fa4807601cf95b13d7bfacf63de52daec08" translate="yes" xml:space="preserve">
          <source>The following types are also provided by Elixir as shortcuts on top of the basic and literal types described above.</source>
          <target state="translated">Elixir는 위에서 설명한 기본 및 리터럴 유형의 바로 가기로 다음 유형도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23128f3afb79fe9776e7ccf884ae9b5f280de2c5" translate="yes" xml:space="preserve">
          <source>The following values in the prompt string will be replaced appropriately:</source>
          <target state="translated">프롬프트 문자열의 다음 값이 적절하게 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="55cd405f97f23c4fe92ae34e5fe7acfcdc9373f0" translate="yes" xml:space="preserve">
          <source>The following variables can be set before you invoke the release or inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt;:</source>
          <target state="translated">릴리스를 호출하기 전에 또는 &lt;code&gt;env.sh&lt;/code&gt; 및 &lt;code&gt;env.bat&lt;/code&gt; 내부에서 다음 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd9e27e386ddec7a2956d45d1104ee9dcf8cf427" translate="yes" xml:space="preserve">
          <source>The following will answer with &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; to the prompt &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;&quot;What's your name?&quot;&lt;/code&gt; 프롬프트에 &quot; &lt;code&gt;&quot;Meg&quot;&lt;/code&gt; 됩니다. :</target>
        </trans-unit>
        <trans-unit id="d10907c83024affa6f13fdf8900f10947fef49e4" translate="yes" xml:space="preserve">
          <source>The format, metadata and colors can be configured with &lt;code&gt;:format&lt;/code&gt;, &lt;code&gt;:metadata&lt;/code&gt; and &lt;code&gt;:colors&lt;/code&gt; respectively. These three options defaults to the &lt;code&gt;:console&lt;/code&gt; backend configuration parameters.</source>
          <target state="translated">형식, 메타 데이터 및 색상은 각각 &lt;code&gt;:format&lt;/code&gt; , &lt;code&gt;:metadata&lt;/code&gt; 및 &lt;code&gt;:colors&lt;/code&gt; 로 구성 할 수 있습니다 . 이 세 가지 옵션의 기본값은 &lt;code&gt;:console&lt;/code&gt; 백엔드 구성 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="dc2e84198cf648d67efe0dc56f0a0d3f7a6c41f5" translate="yes" xml:space="preserve">
          <source>The formatter also extracts all trailing comments to their previous line. For example, the code below</source>
          <target state="translated">포맷터는 또한 모든 후행 주석을 이전 행으로 추출합니다. 예를 들어 아래 코드</target>
        </trans-unit>
        <trans-unit id="f2dbb773aae103d1ac648bef9a245406adea93a6" translate="yes" xml:space="preserve">
          <source>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</source>
          <target state="translated">또한 포맷터는 주석 시작 (#)과 다음 문자 사이에 공백이 항상 추가되도록 코드 주석을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="174a1bba642104242141e782016509d0a3307dd9" translate="yes" xml:space="preserve">
          <source>The formatter attempts to fit the most it can on a single line and introduces line breaks wherever possible when it cannot.</source>
          <target state="translated">포맷터는 한 줄에 최대한 잘 맞추려고 할 수 있으며 가능한 한 줄 바꿈을합니다.</target>
        </trans-unit>
        <trans-unit id="db2d1c69ac2af0675a9fbaa3dbf3bb62be0f48e5" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, etc. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">포맷터는 이름을 하드 코딩하지 않습니다. 함수 이름이 &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; 등 이기 때문에 포맷터는 특수하게 작동하지 않습니다 .이 원칙은 개발자가 마치 언어의 일부인 것처럼 새로운 구문으로 언어를 확장 할 수있는 확장 가능한 언어라는 Elixir의 목표를 반영합니다. 이름을 기준으로 동작을 변경해야하는 경우, &lt;code&gt;:locals_without_parens&lt;/code&gt; 옵션 과 같이이 동작을 구성 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4b2df21441dc79dd9bd7c2eac32664e6ea35e2a4" translate="yes" xml:space="preserve">
          <source>The formatter does not hard code names. The formatter will not behave specially because a function is named &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or the like. This principle mirrors Elixir's goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the &lt;code&gt;:locals_without_parens&lt;/code&gt; option.</source>
          <target state="translated">포맷터는 이름을 하드 코딩하지 않습니다. 함수의 이름이 &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; 등 이기 때문에 포맷터가 특별히 작동하지 않습니다 . 이 원칙은 개발자가 마치 언어의 일부인 것처럼 새로운 구조로 언어를 확장 할 수있는 확장 가능한 언어라는 Elixir의 목표를 반영합니다. 이름에 따라 동작을 변경해야하는 경우이 동작을 구성 할 수 있어야합니다 (예 &lt;code&gt;:locals_without_parens&lt;/code&gt; 옵션).</target>
        </trans-unit>
        <trans-unit id="03003fdc11feaf71c728ace4a4e8175ee7b4844f" translate="yes" xml:space="preserve">
          <source>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</source>
          <target state="translated">포맷터는 Elixir 코드를 나타내는 문자열을 수신하고 미리 정의 된 규칙에 따라 형식화 된 코드를 나타내는 iodata를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72e5baea79c2662552fd592f7668202474a199d4" translate="yes" xml:space="preserve">
          <source>The formatter respects the input format in some cases. Those are listed below:</source>
          <target state="translated">경우에 따라 포매터는 입력 형식을 존중합니다. 그것들은 아래와 같습니다 :</target>
        </trans-unit>
        <trans-unit id="73147abbfb07a1782272353b129dfe6ae2759140" translate="yes" xml:space="preserve">
          <source>The formatter was designed under three principles.</source>
          <target state="translated">포맷터는 세 가지 원칙에 따라 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d253cdad860fbe489673fba372b661892f2a2b1a" translate="yes" xml:space="preserve">
          <source>The formatter will also receive the following events but they are deprecated and should be ignored:</source>
          <target state="translated">포맷터는 다음 이벤트도 수신하지만 더 이상 사용되지 않으므로 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="16faacc4637c873b1a6d5ef2df7c790ea5ae523a" translate="yes" xml:space="preserve">
          <source>The formatter will read a &lt;code&gt;.formatter.exs&lt;/code&gt; file in the current directory for formatter configuration. Evaluating this file should return a keyword list.</source>
          <target state="translated">포맷터는 포맷터 구성을 위해 현재 디렉토리에서 &lt;code&gt;.formatter.exs&lt;/code&gt; 파일을 읽습니다 . 이 파일을 평가하면 키워드 목록이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="54861fc5081e64334a71df9d50b523e9ef441995" translate="yes" xml:space="preserve">
          <source>The formatter wraps the algebra document representing the map in &lt;a href=&quot;#next_break_fits/1&quot;&gt;&lt;code&gt;next_break_fits/1&lt;/code&gt;&lt;/a&gt; so the code is formatted as:</source>
          <target state="translated">포맷터는 &lt;a href=&quot;#next_break_fits/1&quot;&gt; &lt;code&gt;next_break_fits/1&lt;/code&gt; &lt;/a&gt; 에서 맵을 나타내는 대수 문서를 랩핑하여 코드 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b530c8de3f53b8e27706291f76c2c2287eac72b" translate="yes" xml:space="preserve">
          <source>The formatting syntax for strftime is a sequence of characters in the following format:</source>
          <target state="translated">strftime의 형식화 구문은 다음 형식의 문자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="95bd7646a64eb0576fcb230b316aeb1624812ca3" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">Mix의 기초는 프로젝트입니다. 프로젝트는 일반적으로 &lt;code&gt;mix.exs&lt;/code&gt; 파일에있는 모듈에서 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 를 사용하여 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="619bfcd8852612a615d36e293bdf93e9442a2fd9" translate="yes" xml:space="preserve">
          <source>The foundation of Mix is a project. A project can be defined by using &lt;a href=&quot;mix.project&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; in a module, usually placed in a file named &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">믹스의 기초는 프로젝트입니다. 프로젝트는 모듈에서 &lt;a href=&quot;mix.project&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 를 사용하여 정의 할 수 있으며 일반적으로 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b28558869b4d11a344cb1f239f09303f041a1a0" translate="yes" xml:space="preserve">
          <source>The full ExUnit configuration is passed as the argument to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback when the formatters are started. If you need to do runtime configuration of a formatter, you can add any configuration needed by using &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt;&lt;code&gt;ExUnit.configure/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt;&lt;code&gt;ExUnit.start/1&lt;/code&gt;&lt;/a&gt;, and this will then be included in the options passed to the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt;&lt;code&gt;GenServer.init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">포맷터가 시작되면 전체 ExUnit 구성이 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt; 콜백에 인수로 전달됩니다 . 포맷터의 런타임 구성을 수행해야하는 경우 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#configure/1&quot;&gt; &lt;code&gt;ExUnit.configure/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#start/1&quot;&gt; &lt;code&gt;ExUnit.start/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 필요한 구성을 추가 할 수 있습니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:init/1&quot;&gt; &lt;code&gt;GenServer.init/1&lt;/code&gt; &lt;/a&gt; 콜백에 전달되는 옵션에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="27f8279b8cd5628c38c64722e539ac026a11da8b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#put_env/3&quot;&gt;&lt;code&gt;put_env/3&lt;/code&gt;&lt;/a&gt; allows dynamic configuration of the application environment, but as a rule of thumb each application is responsible for its own environment. Please do not use the functions in this module for directly accessing or modifying the environment of other applications.</source>
          <target state="translated">&lt;a href=&quot;#put_env/3&quot;&gt; &lt;code&gt;put_env/3&lt;/code&gt; &lt;/a&gt; 기능 을 사용하면 응용 프로그램 환경을 동적으로 구성 할 수 있지만 일반적으로 각 응용 프로그램은 자체 환경을 담당합니다. 다른 응용 프로그램의 환경에 직접 액세스하거나 수정하기 위해이 모듈의 기능을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="44dd7e8c0883ba7364643058445d069f16c2e43c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#struct!/2&quot;&gt;&lt;code&gt;struct!/2&lt;/code&gt;&lt;/a&gt; emulates the compile time behaviour of structs. This means that:</source>
          <target state="translated">&lt;a href=&quot;#struct!/2&quot;&gt; &lt;code&gt;struct!/2&lt;/code&gt; &lt;/a&gt; 함수는 구조체 의 컴파일 시간 동작을 에뮬레이트합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e0639c36ddd40dd4d3c1545de8b7ff6af66a1a8" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The function must return a tuple with two elements, the first being the value to return (that is, the &quot;get&quot; value) and the second one being the new state of the agent.</source>
          <target state="translated">함수 &lt;code&gt;fun&lt;/code&gt; 받는 전송 &lt;code&gt;agent&lt;/code&gt; 에이전트 상태를 통과하는 함수를 호출합니다. 함수는 두 개의 요소가있는 튜플을 리턴해야합니다. 첫 번째는 리턴 할 값 (즉, &quot;get&quot;값)이고 두 번째는 에이전트의 새 상태입니다.</target>
        </trans-unit>
        <trans-unit id="216982854731717320607d5aa3e2c69ffa39cfa0" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The result of the function invocation is returned from this function.</source>
          <target state="translated">함수 &lt;code&gt;fun&lt;/code&gt; 받는 전송 &lt;code&gt;agent&lt;/code&gt; 에이전트 상태를 통과하는 함수를 호출합니다. 함수 호출 결과는이 함수에서 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="fc7b0ec15b4d375100169c807030b178d76cb224" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; is sent to the &lt;code&gt;agent&lt;/code&gt; which invokes the function passing the agent state. The return value of &lt;code&gt;fun&lt;/code&gt; becomes the new state of the agent.</source>
          <target state="translated">함수 &lt;code&gt;fun&lt;/code&gt; 받는 전송 &lt;code&gt;agent&lt;/code&gt; 에이전트 상태를 통과하는 함수를 호출합니다. &lt;code&gt;fun&lt;/code&gt; 의 반환 값은 에이전트의 새로운 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="cad7f93891da662dbbaf24dfbad6e47a904e9038" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term which is used to determine if two elements are duplicates.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수 는 두 요소가 중복되는지 확인하는 데 사용되는 용어에 모든 요소를 ​​매핑합니다.</target>
        </trans-unit>
        <trans-unit id="2063958f17451467d712f93ea552d845434a5f7b" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;fun&lt;/code&gt; maps every element to a term. Two elements are considered duplicates if the return value of &lt;code&gt;fun&lt;/code&gt; is equal for both of them.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수 는 모든 요소를 ​​용어에 매핑합니다. &lt;code&gt;fun&lt;/code&gt; 의 반환 값이 두 요소에 대해 동일 하면 두 요소가 중복으로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="786bdba792da55f0fb2aae425ae917dfa7672afd" translate="yes" xml:space="preserve">
          <source>The function must receive the exit status code as an argument.</source>
          <target state="translated">함수는 종료 상태 코드를 인수로 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="a56026b8a6cb0f0aeff01c85c9ee7342a99db076" translate="yes" xml:space="preserve">
          <source>The function must return:</source>
          <target state="translated">함수는 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="78c45238f9f6bc55b2be81844c73ef2dab477691" translate="yes" xml:space="preserve">
          <source>The function receives the arguments and passes them to &lt;code&gt;if&lt;/code&gt;. However, as we learned in the &lt;a href=&quot;quote-and-unquote&quot;&gt;previous chapter&lt;/a&gt;, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</source>
          <target state="translated">이 함수는 인수를 받아서 &lt;code&gt;if&lt;/code&gt; 로 전달합니다 . 그러나 &lt;a href=&quot;quote-and-unquote&quot;&gt;이전 장&lt;/a&gt; 에서 배운대로 매크로는 따옴표로 묶인 표현식을 받아 따옴표에 삽입 한 다음 마지막으로 따옴표로 묶은 표현식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="970e1abe8c2a97edfeb1747215a9aaebefbaf05f" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;:ok&lt;/code&gt; in case of success. Otherwise, it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">성공하면 이 함수는 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="42211e9c17fc840b6d18e986bbdd31d79b28999c" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; in case of success, &lt;code&gt;files_and_directories&lt;/code&gt; lists all files and directories copied in no specific order. It returns &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">성공하면 이 함수는 &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; 를 반환 하고 &lt;code&gt;files_and_directories&lt;/code&gt; 는 특정 순서없이 복사 된 모든 파일과 디렉토리를 나열합니다. 그것은 반환 &lt;code&gt;{:error, reason, file}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="b12965a38c8943a04c360761ab1a75653a316455" translate="yes" xml:space="preserve">
          <source>The function should return a non empty list where the amount of elements is equal to &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">이 함수는 요소의 양이 &lt;code&gt;length&lt;/code&gt; 와 같은 비어 있지 않은 목록을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="370959ce1313e0ee1574bb7b4f639ad8e764cdd3" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;fun&lt;/code&gt;, receives two arguments: the first one is the element, and the second one is the accumulator. &lt;code&gt;fun&lt;/code&gt; must return a tuple with two elements in the form of &lt;code&gt;{result, accumulator}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수 는 두 개의 인수를받습니다. 첫 번째는 요소이고 두 번째는 누산기입니다. &lt;code&gt;fun&lt;/code&gt; 은 &lt;code&gt;{result, accumulator}&lt;/code&gt; 형식의 두 요소가 포함 된 튜플을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5956f11dd1602a7d0b839eecd3ea612fa5aace7" translate="yes" xml:space="preserve">
          <source>The functions &lt;a href=&quot;#nest/2&quot;&gt;&lt;code&gt;nest/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#space/2&quot;&gt;&lt;code&gt;space/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#line/2&quot;&gt;&lt;code&gt;line/2&lt;/code&gt;&lt;/a&gt; help you put the document together into a rigid structure. However, the document algebra gets interesting when using functions like &lt;a href=&quot;#glue/3&quot;&gt;&lt;code&gt;glue/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#group/1&quot;&gt;&lt;code&gt;group/1&lt;/code&gt;&lt;/a&gt;. A glue inserts a break between two documents. A group indicates a document that must fit the current line, otherwise breaks are rendered as new lines. Let's glue two docs together with a break, group it and then render it:</source>
          <target state="translated">&lt;a href=&quot;#nest/2&quot;&gt; &lt;code&gt;nest/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#space/2&quot;&gt; &lt;code&gt;space/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#line/2&quot;&gt; &lt;code&gt;line/2&lt;/code&gt; &lt;/a&gt; 함수 는 문서를 견고한 구조로 만드는 데 도움이됩니다. 그러나 &lt;a href=&quot;#glue/3&quot;&gt; &lt;code&gt;glue/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#group/1&quot;&gt; &lt;code&gt;group/1&lt;/code&gt; &lt;/a&gt; 과 같은 함수를 사용할 때 문서 대수는 흥미로워집니다 . 접착제는 두 문서 사이에 끊김을 삽입합니다. 그룹은 현재 줄에 맞는 문서를 나타내며, 그렇지 않으면 줄 바꿈이 새 줄로 렌더링됩니다. 두 개의 문서를 나누기와 함께 붙이고 그룹화 한 다음 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c253790d407e18b7d5f0c9bb8af92800693543dd" translate="yes" xml:space="preserve">
          <source>The functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; do not guarantee any property when it comes to ordering. However, since a keyword list is simply a list, all the operations defined in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; can be applied too, especially when ordering is required.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 의 기능은 주문시 어떠한 속성도 보장하지 않습니다. 그러나 키워드 목록은 단순한 목록 이므로 특히 주문이 필요한 경우 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 정의 된 모든 작업을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc395b4f1565e86a3f414d5f43f358ea3ab4b968" translate="yes" xml:space="preserve">
          <source>The functions in &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;File&lt;/code&gt; also allow lists to be given as arguments. Not only that, they also allow a mixed list of lists, integers, and binaries to be given:</source>
          <target state="translated">&lt;code&gt;IO&lt;/code&gt; 및 &lt;code&gt;File&lt;/code&gt; 의 함수를 사용하면 목록을 인수로 제공 할 수도 있습니다. 뿐만 아니라 목록, 정수 및 이진의 혼합 목록을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24702aeda4cc39358f5c9073ad6385b684128ba" translate="yes" xml:space="preserve">
          <source>The functions in the &lt;code&gt;ets&lt;/code&gt; module will modify the state of the table as a side-effect.</source>
          <target state="translated">&lt;code&gt;ets&lt;/code&gt; 모듈 의 기능 은 테이블 상태를 부작용으로 수정합니다.</target>
        </trans-unit>
        <trans-unit id="645c924b3f04d5643fc9c0295858b7ef02f4fe7d" translate="yes" xml:space="preserve">
          <source>The functions in the Enum module are limited to, as the name says, enumerating values in data structures. For specific operations, like inserting and updating particular elements, you may need to reach for modules specific to the data type. For example, if you want to insert an element at a given position in a list, you should use the &lt;code&gt;List.insert_at/3&lt;/code&gt; function from &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;the &lt;code&gt;List&lt;/code&gt; module&lt;/a&gt;, as it would make little sense to insert a value into, for example, a range.</source>
          <target state="translated">Enum 모듈의 기능은 이름에서 알 수 있듯이 데이터 구조의 값을 열거하는 것으로 제한됩니다. 특정 요소 삽입 및 업데이트와 같은 특정 작업의 경우 데이터 유형별 모듈에 도달해야 할 수 있습니다. 당신이 목록에서 지정된 위치에 요소를 삽입 할 경우 예를 들어, 사용한다 &lt;code&gt;List.insert_at/3&lt;/code&gt; 에서 기능을 &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 모듈 이 조금 나을으로, 예를 들어, 범위에 값을 삽입, .</target>
        </trans-unit>
        <trans-unit id="77cce334a46132ba295a248960c6d018c960a8aa" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 11.0.0.</source>
          <target state="translated">이 모듈의 기능은 Unicode Standard 버전 11.0.0에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2539a9cd4324f66b525de87feede6af27bf5479d" translate="yes" xml:space="preserve">
          <source>The functions in this module act according to the Unicode Standard, version 12.1.0.</source>
          <target state="translated">이 모듈의 기능은 유니 코드 표준 버전 12.1.0에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="435e788eab1bd17ae90e69f5f7810182e093e4b6" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">이 모듈의 함수는 더 이상 사용되지 않으며 Elixir v1.5에 도입 된 모듈 기반 하위 사양에서 작동하지 않습니다. 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="173416c87fd5ec34f77cd8d34322b0332ac7cfcb" translate="yes" xml:space="preserve">
          <source>The functions in this module are deprecated and they do not work with the module-based child specs introduced in Elixir v1.5. Please see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; documentation instead.</source>
          <target state="translated">이 모듈의 기능은 더 이상 사용되지 않으며 Elixir v1.5에 도입 된 모듈 기반 하위 스펙에서는 작동하지 않습니다. 대신 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55c1606f7340829fac4bdeef11ed0e160ebd64a6" translate="yes" xml:space="preserve">
          <source>The functions in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">이 모듈의 함수는 명명 된 또는 연산자라는 두 가지 유형으로 제공됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="96e74349f320a8c58dc1c59108496ee930024bf1" translate="yes" xml:space="preserve">
          <source>The functions in this module may receive a chardata as argument (i.e. a string or a list of characters / string) and will always return a string (encoded in UTF-8).</source>
          <target state="translated">이 모듈의 함수는 chardata를 인수 (문자열 또는 문자 / 문자열 목록)로 수신 할 수 있으며 항상 UTF-8로 인코딩 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b429b5ce2f9a2392aff46c5515cf68d49d6d6adf" translate="yes" xml:space="preserve">
          <source>The functions in this module support chardata, so giving a list will treat it as a single entity:</source>
          <target state="translated">이 모듈의 함수는 chardata를 지원하므로 목록을 제공하면 단일 엔티티로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="255d1a73d20d6ce6127802c33ec8ce540df5e39c" translate="yes" xml:space="preserve">
          <source>The functions in this module that add and remove elements from tuples are rarely used in practice, as they typically imply tuples are being used as collections. To append to a tuple, it is preferable to extract the elements from the old tuple with pattern matching, and then create a new tuple:</source>
          <target state="translated">튜플에서 요소를 추가 및 제거하는이 모듈의 기능은 일반적으로 튜플이 컬렉션으로 사용되고 있음을 의미하므로 실제로는 거의 사용되지 않습니다. 튜플에 추가하려면 패턴 일치로 이전 튜플에서 요소를 추출한 다음 새 튜플을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="33b30755a342f20f218b83071cf71f52c8757557" translate="yes" xml:space="preserve">
          <source>The functions in this module that need to find a specific key work in logarithmic time. This means that the time it takes to find keys grows as the map grows, but it's not directly proportional to the map size. In comparison to finding an element in a list, it performs better because lists have a linear time complexity. Some functions, such as &lt;a href=&quot;#keys/1&quot;&gt;&lt;code&gt;keys/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values/1&quot;&gt;&lt;code&gt;values/1&lt;/code&gt;&lt;/a&gt;, run in linear time because they need to get to every element in the map.</source>
          <target state="translated">이 모듈에서 로그 키로 특정 키 작업을 찾아야하는 기능. 즉, 키를 찾는 데 걸리는 시간은 맵이 커질수록 커지지 만 맵 크기에 정비례하지는 않습니다. 목록에서 요소를 찾는 것과 비교하여 목록의 시간이 선형 적으로 복잡하기 때문에 성능이 향상됩니다. &lt;a href=&quot;#keys/1&quot;&gt; &lt;code&gt;keys/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#values/1&quot;&gt; &lt;code&gt;values/1&lt;/code&gt; &lt;/a&gt;/ 1 과 같은 일부 함수 는 맵의 모든 요소에 도달해야하기 때문에 선형 시간으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="74f82d17a516dfeabf8954e130f2901c86439fbe" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">이 모듈의 기능은 선형 시간으로 작동합니다. 즉, 작업을 수행하는 데 걸리는 시간이 열거 형 길이와 동일한 속도로 늘어납니다. 이는 &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 와 같은 작업에서 예상됩니다 . 결국 목록의 모든 요소를 ​​순회하려면 목록이 길수록 순회해야하는 요소가 많고 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9f0853ffd0b6dd95f29653e4a1c1ad06e52385c2" translate="yes" xml:space="preserve">
          <source>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">이 모듈의 기능은 선형 시간으로 작동합니다. 즉, 작업을 수행하는 데 걸리는 시간은 열거 가능 길이와 동일한 비율로 증가합니다. 이것은 &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 와 같은 작업에서 예상됩니다 . 결국, 목록의 모든 요소를 ​​순회하려면 목록이 길수록 순회해야하는 요소가 많아지고 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="3463cc17b842a1d5960bd8ec694214b314a84bdc" translate="yes" xml:space="preserve">
          <source>The functions listed under &lt;code&gt;:locals_without_parens&lt;/code&gt; in the &lt;code&gt;:export&lt;/code&gt; option of a dependency can be imported in a project by listing that dependency in the &lt;code&gt;:import_deps&lt;/code&gt; option of the formatter configuration file of the project.</source>
          <target state="translated">종속성 의 &lt;code&gt;:export&lt;/code&gt; 옵션 에서 &lt;code&gt;:locals_without_parens&lt;/code&gt; 아래에 나열된 함수 는 프로젝트 의 포맷터 구성 파일의 &lt;code&gt;:import_deps&lt;/code&gt; 옵션에 해당 종속성을 나열하여 프로젝트에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b5e518a4ce1d29fa0de0a02c9ab38609211f7bc" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈의 함수는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체뿐만 아니라 &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 과 같이 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체 와 동일한 필드를 포함하는 모든 구조체 와 함께 작동합니다 . 이러한 함수 는 유형 사양에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt; 을 예상합니다 ( &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; 대신 ).</target>
        </trans-unit>
        <trans-unit id="709dd48512a8ffdaa9639efcdf5626b90390736d" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:date/0&quot;&gt;&lt;code&gt;Calendar.date/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈 작업의 기능 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체뿐만 아니라 같은 필드가 포함 된 모든 구조체 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 와 같은 구조체, &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . 이러한 함수 는 &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; 대신 typespecs에서 &lt;a href=&quot;calendar#t:date/0&quot;&gt; &lt;code&gt;Calendar.date/0&lt;/code&gt; &lt;/a&gt; 을 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="2ff0d30d9202c4c6b14208fdf831e03638322939" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈의 함수는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조체뿐만 아니라 &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 과 같이 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조체 와 동일한 필드를 포함하는 모든 구조체 와 함께 작동합니다 . 이러한 함수 는 유형 사양에서 ( &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; 대신) &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt; 을 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="dd7fe8f3288c5b63dba38948e86e695e4e2b2557" translate="yes" xml:space="preserve">
          <source>The functions on this module work with the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct as well as any struct that contains the same fields as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. Such functions expect &lt;a href=&quot;calendar#t:time/0&quot;&gt;&lt;code&gt;Calendar.time/0&lt;/code&gt;&lt;/a&gt; in their typespecs (instead of &lt;a href=&quot;#t:t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈 작업에 대한 기능 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조체뿐만 아니라 같은 필드가 포함 된 모든 구조체 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 과 같은 구조체, &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; . 이러한 함수 는 &lt;a href=&quot;#t:t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; 대신 typespecs에서 &lt;a href=&quot;calendar#t:time/0&quot;&gt; &lt;code&gt;Calendar.time/0&lt;/code&gt; &lt;/a&gt; 을 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="003b5d0dd560d869b45725f5251941da4e2978b9" translate="yes" xml:space="preserve">
          <source>The general Elixir identifier rule is specified as:</source>
          <target state="translated">일반 엘릭서 식별자 규칙은 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="279b2d1d6d51ad298e11acb6402db1bbf4467c85" translate="yes" xml:space="preserve">
          <source>The generated files are similar to the ones we first generated for &lt;code&gt;kv&lt;/code&gt;, with a few differences. Let&amp;rsquo;s open up &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">생성 된 파일은 &lt;code&gt;kv&lt;/code&gt; 에 대해 처음 생성 한 파일과 유사하지만 몇 가지 차이점이 있습니다. &lt;code&gt;mix.exs&lt;/code&gt; 를 열어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="fe11b786cb48918f9b05dccc30b89f3c9d182f54" translate="yes" xml:space="preserve">
          <source>The generated macros can also be used in order to pattern match on records and to bind variables during the match:</source>
          <target state="translated">생성 된 매크로는 레코드에서 일치를 패턴 화하고 일치하는 동안 변수를 바인딩하기 위해 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="50f5c0fcf4c39bd1e0e3ce49d94a449eccf8a5ee" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;datetime_string&lt;/code&gt; must include &quot;Z&quot; or &quot;00:00&quot; offset which marks it as UTC, otherwise an error is raised.</source>
          <target state="translated">주어진 &lt;code&gt;datetime_string&lt;/code&gt; 에는 &quot;Z&quot;또는 &quot;00:00&quot;오프셋이 포함되어야하며이를 UTC로 표시합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5945d8ce9d0ed7b935712680470e46feacdd1644" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;fun&lt;/code&gt; is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</source>
          <target state="translated">주어진 &lt;code&gt;fun&lt;/code&gt; 는 AST의 모든 노드에 대해 두 개의 인수, 즉 인쇄되는 노드의 AST와 동일한 노드의 문자열 표현과 함께 호출됩니다. 이 함수의 반환 값은 해당 AST 노드의 최종 문자열 표현으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a83da51956cb3348840e43e856af798fc100e9ea" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing configuration for the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">주어진 &lt;code&gt;opts&lt;/code&gt; 는 주어진 &lt;code&gt;root_key&lt;/code&gt; 에 대한 기존 구성으로 병합됩니다 . 충돌하는 키는 &lt;code&gt;opts&lt;/code&gt; 에 지정된 키로 대체됩니다 . 예를 들어 아래 애플리케이션 구성</target>
        </trans-unit>
        <trans-unit id="b05f234517d759a8cb3f7b2d59dc801482a98965" translate="yes" xml:space="preserve">
          <source>The given &lt;code&gt;opts&lt;/code&gt; are merged into the existing values for &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;root_key&lt;/code&gt;. Conflicting keys are overridden by the ones specified in &lt;code&gt;opts&lt;/code&gt;. For example, the application configuration below</source>
          <target state="translated">주어진 &lt;code&gt;opts&lt;/code&gt; 는 주어진 &lt;code&gt;root_key&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 에 대한 기존 값으로 병합됩니다 . 충돌하는 키는 &lt;code&gt;opts&lt;/code&gt; 에 지정된 키로 대체됩니다 . 예를 들어 아래 애플리케이션 구성</target>
        </trans-unit>
        <trans-unit id="02ef5a607d49adbb7866b57f819df6b77fdbb345" translate="yes" xml:space="preserve">
          <source>The given config should not:</source>
          <target state="translated">주어진 설정은해서는 안됩니다 :</target>
        </trans-unit>
        <trans-unit id="44e635edac5e4e08e828b82a2eaab3164491a4b7" translate="yes" xml:space="preserve">
          <source>The given datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">주어진 날짜 시간이 이미 주어진 정밀도보다 정밀도가 낮 으면 변경되지 않은 상태로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="77d42dd0c470aae641d549b4c74c46ab9659c1be" translate="yes" xml:space="preserve">
          <source>The given dependencies and the projects they depend on will be unlocked and updated to the latest version according to their version requirements.</source>
          <target state="translated">주어진 종속성과 이들이 의존하는 프로젝트는 버전 요구 사항에 따라 잠금 해제되고 최신 버전으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6d2a43a0c7f321f6321fd1b9eb5b43b059a8e70b" translate="yes" xml:space="preserve">
          <source>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">주어진 순진 날짜 시간이 이미 주어진 정밀도보다 정밀도가 낮은 경우 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ee23443246e5491d80625e07cdf87fe6cfe649c9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">주어진 옵션은 &lt;code&gt;~r&lt;/code&gt; ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; 참조 )시길에 주어진 것과 동일한 정규식 옵션을 나타내는 문자가있는 바이너리 이거나 Erlang의 &lt;code&gt;:re&lt;/code&gt; 모듈 에서 예상하는 옵션 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8ff7c40025099fed2b47a6ca6bd7d1bee58abb9" translate="yes" xml:space="preserve">
          <source>The given options can either be a binary with the characters representing the same regex options given to the &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) sigil, or a list of options, as expected by the Erlang's &lt;code&gt;:re&lt;/code&gt; module.</source>
          <target state="translated">주어진 옵션은 &lt;code&gt;~r&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; 참조 )시길에 주어진 것과 같은 정규식 옵션을 나타내는 문자를 가진 바이너리 이거나 Erlang의 &lt;code&gt;:re&lt;/code&gt; 모듈에 의해 예상되는 옵션 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a877d88a9ed060a658c7f85f772f951264b25f7d" translate="yes" xml:space="preserve">
          <source>The given string may contain a timezone offset but it is ignored.</source>
          <target state="translated">주어진 문자열은 시간대 오프셋을 포함 할 수 있지만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8ee391432291b1d23474c64748cd369ce3de6c17" translate="yes" xml:space="preserve">
          <source>The given time is returned unchanged if it already has lower precision than the given precision.</source>
          <target state="translated">주어진 시간이 이미 주어진 정밀도보다 정밀도가 낮 으면 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="595ea9127c2b29264915dada8a0a74f247f402db" translate="yes" xml:space="preserve">
          <source>The goal in this chapter is to build a module named &lt;code&gt;TestCase&lt;/code&gt; that allows us to write the following:</source>
          <target state="translated">이 장의 목표 는 다음과 같이 작성할 수있는 &lt;code&gt;TestCase&lt;/code&gt; 라는 모듈 을 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="005035c0ac9ba5b2d03b96ccf393ae5ff11ffe11" translate="yes" xml:space="preserve">
          <source>The goal of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is to abstract the &quot;receive&quot; loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own &quot;receive&quot; inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 목표는 개발자를위한 &quot;수신&quot;루프를 추상화하여 시스템 메시지를 자동으로 처리하고 코드 변경, 동기 호출 등을 지원하는 것입니다. 따라서 GenServer 콜백 내부에서 자신의 &quot;수신&quot;을 호출해서는 안됩니다. 그렇게하면 GenServer가 오작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6d568374392c51e27178f8aac8e2da82bbf64d" translate="yes" xml:space="preserve">
          <source>The good news is that breaking an umbrella apart is quite straightforward, as you simply need to move applications outside of the umbrella project&amp;rsquo;s &lt;code&gt;apps/&lt;/code&gt; directory. In the worst case scenario, you can discard the umbrella project and all related configuration (&lt;code&gt;build_path&lt;/code&gt;, &lt;code&gt;config_path&lt;/code&gt;, &lt;code&gt;deps_path&lt;/code&gt; and &lt;code&gt;lockfile&lt;/code&gt;) and still leverage the &amp;ldquo;mono-repo&amp;rdquo; pattern by keeping all applications together in the same repository. Each application will have its own dependencies and configuration. Dependencies between those applications can still be explicitly listed by using the &lt;code&gt;:path&lt;/code&gt; option (in contrast to &lt;code&gt;:git&lt;/code&gt;).</source>
          <target state="translated">좋은 소식은 단순히 우산 프로젝트를 분리하는 것이 매우 간단하다는 것입니다. 단순히 우산 프로젝트의 &lt;code&gt;apps/&lt;/code&gt; 디렉토리 외부로 응용 프로그램을 이동하면되기 때문 입니다. 최악의 시나리오에서는 우산 프로젝트와 모든 관련 구성 ( &lt;code&gt;build_path&lt;/code&gt; , &lt;code&gt;config_path&lt;/code&gt; , &lt;code&gt;deps_path&lt;/code&gt; 및 &lt;code&gt;lockfile&lt;/code&gt; )을 버리고 모든 애플리케이션을 동일한 저장소에 함께 유지하여 &quot;모노 레포&quot;패턴을 계속 활용할 수 있습니다. 각 응용 프로그램에는 고유 한 종속성과 구성이 있습니다. 이러한 응용 프로그램 간의 종속성은 여전히 명시 적으로 사용하여 나열 할 수 있습니다 &lt;code&gt;:path&lt;/code&gt; 옵션 (달리 &lt;code&gt;:git&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="78ffff4bce308419c28073fad905a3416ef9e300" translate="yes" xml:space="preserve">
          <source>The good news is that developers can use third-party implementations of both Elixir backends and Erlang handlers.</source>
          <target state="translated">좋은 소식은 개발자가 Elixir 백엔드와 Erlang 핸들러의 타사 구현을 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18abb99c49c0cd9f625ee8db0e020cadbbd4d636" translate="yes" xml:space="preserve">
          <source>The greatest common divisor (GCD) of &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; is the largest positive integer that divides both &lt;code&gt;integer1&lt;/code&gt; and &lt;code&gt;integer2&lt;/code&gt; without leaving a remainder.</source>
          <target state="translated">&lt;code&gt;integer1&lt;/code&gt; 과 &lt;code&gt;integer2&lt;/code&gt; 의 최대 공약수 (GCD) 는 나머지를 남기지 않고 &lt;code&gt;integer1&lt;/code&gt; 과 &lt;code&gt;integer2&lt;/code&gt; 를 모두 나누는 가장 큰 양의 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="04a15f34a10083efdd1b4c7fb23d6409a2799f7b" translate="yes" xml:space="preserve">
          <source>The group mode can also be set to &lt;code&gt;:inherit&lt;/code&gt;, which means it automatically breaks if the parent group has broken too.</source>
          <target state="translated">그룹 모드를 &lt;code&gt;:inherit&lt;/code&gt; 로 설정할 수도 있습니다 . 즉, 상위 그룹도 끊어지면 자동으로 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="a353728570ac2d4d82e8f0ff930144d1e562cb6a" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, and others) won't be available by the time the handler function is invoked.</source>
          <target state="translated">핸들러는 항상 등록 된 프로세스와 다른 프로세스에서 실행됩니다. 결과적으로 호출 프로세스 (ETS 테이블, 열린 파일 등)에서 관리하는 모든 리소스는 핸들러 함수가 호출 될 때 사용할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="abae706b2e9875a2d4fe24ac37232c3285b58047" translate="yes" xml:space="preserve">
          <source>The handler always executes in a different process from the one it was registered in. As a consequence, any resources managed by the calling process (ETS tables, open files, etc.) won't be available by the time the handler function is invoked.</source>
          <target state="translated">핸들러는 항상 등록 된 프로세스와 다른 프로세스에서 실행됩니다. 결과적으로, 호출 프로세스가 관리하는 자원 (ETS 테이블, 열린 파일 등)은 핸들러 함수가 호출 될 때까지 사용할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="91dc0be92537f81da316aa8d3834b6a0c2b63c02" translate="yes" xml:space="preserve">
          <source>The head element of aliases can be any term that must expand to an atom at compilation time.</source>
          <target state="translated">별칭의 헤드 요소는 컴파일 타임에 원자로 확장되어야하는 모든 용어 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d895e647576b7caa588974823adee16cc261b47d" translate="yes" xml:space="preserve">
          <source>The hex representation will also help you look up information about a code point, e.g. &lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt; has a data sheet all about the lower case &lt;code&gt;a&lt;/code&gt;, a.k.a. code point 97.</source>
          <target state="translated">16 진수 표현은 코드 포인트에 대한 정보를 찾는데도 도움이됩니다. 예를 들어 &lt;a href=&quot;https://codepoints.net/U+0061&quot;&gt;https://codepoints.net/U+0061&lt;/a&gt; 에는 소문자 &lt;code&gt;a&lt;/code&gt; , 즉 코드 포인트 97에 대한 데이터 시트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f5e37ee6e6bb7829dd572b3c957edcc2f9784b" translate="yes" xml:space="preserve">
          <source>The implementation above is arguably not a reasonable one. For example, it makes no sense to say that the size of a &lt;code&gt;PID&lt;/code&gt; or an &lt;code&gt;Integer&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">위의 구현은 아마도 합리적인 것이 아닙니다. 예를 들어 &lt;code&gt;PID&lt;/code&gt; 또는 &lt;code&gt;Integer&lt;/code&gt; 의 크기 가 &lt;code&gt;0&lt;/code&gt; 이라고 말하는 것은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a82e7d1f4f1afb4f634e8bc16b67baab165570d" translate="yes" xml:space="preserve">
          <source>The implementation is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;reservoir sampling&lt;/a&gt; algorithm. It assumes that the sample being returned can fit into memory; the input &lt;code&gt;enumerable&lt;/code&gt; doesn't have to, as it is traversed just once.</source>
          <target state="translated">구현은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle&quot;&gt;저수지 샘플링&lt;/a&gt; 알고리즘을 기반으로합니다 . 반환되는 샘플이 메모리에 맞을 수 있다고 가정합니다. &lt;code&gt;enumerable&lt;/code&gt; 입력 은 한 번만 통과하므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b8d2b9e0c9b1879d05717152c53da40bcc3437b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect.Algebra&lt;/code&gt;&lt;/a&gt; is based on the Strictly Pretty paper by &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; which builds on top of previous pretty printing algorithms but is tailored to strict languages, such as Elixir. The core idea in the paper is the use of explicit document groups which are rendered as flat (breaks as spaces) or as break (breaks as newlines).</source>
          <target state="translated">의 구현 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect.Algebra&lt;/code&gt; 는&lt;/a&gt; 에 의해 엄격하게 예쁜 종이에 기반 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;Lindig&lt;/a&gt; 이전 꽤 인쇄 알고리즘의 상단을 기반으로하지만, 같은 비약 엄격한 언어에 맞게 조정된다. 이 문서의 핵심 아이디어는 평평하게 (공백으로 나누기) 또는 나누기 (줄 바꿈으로 나누기)로 표현되는 명시 적 문서 그룹을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a573a08337f6f0cf025ec9ae17d9092603c49c35" translate="yes" xml:space="preserve">
          <source>The implementation of this callback should invoke &lt;code&gt;fun&lt;/code&gt; with the value under &lt;code&gt;key&lt;/code&gt; in the passed structure &lt;code&gt;data&lt;/code&gt;, or with &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in it. This function must return either &lt;code&gt;{get_value, update_value}&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt;.</source>
          <target state="translated">이 콜백의 구현은 전달 된 구조 &lt;code&gt;data&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 아래 값을 사용 하거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 사용하여 &lt;code&gt;fun&lt;/code&gt; 을 호출해야 합니다. 이 함수는 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 또는 &lt;code&gt;:pop&lt;/code&gt; 을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="791ef5c45db6655a2b8e0d52e101cc594625c78d" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started.</source>
          <target state="translated">초기 백엔드는 &lt;code&gt;:backends&lt;/code&gt; 구성을 통해로드되며 , 이는 &lt;code&gt;:logger&lt;/code&gt; 애플리케이션이 시작 되기 전에 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="26abb8f8f9a767e820200e7bf8e998799e79b893" translate="yes" xml:space="preserve">
          <source>The initial backends are loaded via the &lt;code&gt;:backends&lt;/code&gt; configuration, which must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started. Backends can also be added dynamically through &lt;a href=&quot;#add_backend/2&quot;&gt;&lt;code&gt;add_backend/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">초기 백엔드는 &lt;code&gt;:backends&lt;/code&gt; 구성을 통해로드되며 &lt;code&gt;:logger&lt;/code&gt; 애플리케이션을 시작 하기 전에 설정해야합니다 . 백엔드는 &lt;a href=&quot;#add_backend/2&quot;&gt; &lt;code&gt;add_backend/2&lt;/code&gt; 를&lt;/a&gt; 통해 동적으로 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5d99b4bc070e331607e6d5df8659a98abe40c48" translate="yes" xml:space="preserve">
          <source>The initial value of the accumulator is &lt;code&gt;acc&lt;/code&gt;. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</source>
          <target state="translated">누산기의 초기 값은 &lt;code&gt;acc&lt;/code&gt; 입니다. 이 함수는 누산기를 사용하여 열거 가능한 각 요소에 대해 호출됩니다. 함수가 반환 한 결과는 다음 반복의 누산기로 사용됩니다. 이 함수는 마지막 누산기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3d8510abacaf7b1519659fdcdb00b6e366da892" translate="yes" xml:space="preserve">
          <source>The initialization arguments, in this case the atom &lt;code&gt;:ok&lt;/code&gt;</source>
          <target state="translated">초기화 인수,이 경우 atom &lt;code&gt;:ok&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3041c0950b326f4d917de04b2c7baea534d3ad6" translate="yes" xml:space="preserve">
          <source>The inputs of a macro</source>
          <target state="translated">매크로 입력</target>
        </trans-unit>
        <trans-unit id="90073db7fde62d3d91fecce3e1a99c3827dbc4cc" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">정수는 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 에 따라 다른 단위로 주어질 수 있으며 내부적으로 마이크로 초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="36e6d864c0e22df1c9a628ca13539c3c770887d4" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally. Up to 253402300799 seconds is supported.</source>
          <target state="translated">정수는 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 에 따라 다른 단위로 주어질 수 있으며 내부적으로 마이크로 초로 변환됩니다. 최대 253402300799 초가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c1ddbc45c619f8049cea4c440a4edb65fecbed96" translate="yes" xml:space="preserve">
          <source>The integer can be given in different unit according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt; and it will be converted to microseconds internally.</source>
          <target state="translated">정수는 &lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 에 따라 다른 단위로 제공 될 수 있으며 내부적으로 마이크로 초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f1e2568ac6af5c9527d828828602700a4893a4" translate="yes" xml:space="preserve">
          <source>The interesting thing about this approach is that Mix has many conveniences for working with such projects, such as the ability to compile and test all applications inside &lt;code&gt;apps&lt;/code&gt; with a single command. However, even though they are all listed together inside &lt;code&gt;apps&lt;/code&gt;, they are still decoupled from each other, so you can build, test and deploy each application in isolation if you want to.</source>
          <target state="translated">이 접근 방식의 흥미로운 점은 Mix는 단일 명령으로 &lt;code&gt;apps&lt;/code&gt; 내의 모든 응용 프로그램을 컴파일하고 테스트하는 기능과 같은 프로젝트 작업에 많은 편의가 있다는 것 입니다. 그러나 &lt;code&gt;apps&lt;/code&gt; 안에 모두 함께 나열되어 있어도 서로 분리되어 있으므로 원하는 경우 각 애플리케이션을 개별적으로 빌드, 테스트 및 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccef43e698ff7f77a039db9e5b5b3d002b852b8a" translate="yes" xml:space="preserve">
          <source>The internal date format that is used when converting between calendars.</source>
          <target state="translated">캘린더간에 변환 할 때 사용되는 내부 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5490fd4bbe326611a1d9b742e7e1f91649638437" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque and cannot be converted to external term format and then back again without losing its properties (meaning it can not be sent to a process on another node and still remain a valid compiled match_spec, nor can it be stored on disk).</source>
          <target state="translated">내부 표현은 불투명하며 외부 용어 형식으로 변환 한 다음 속성을 잃지 않고 다시 되돌릴 수 없습니다 (다른 노드의 프로세스로 보낼 수없고 유효한 컴파일 된 match_spec으로 남아 있거나 디스크에 저장 될 수 없음) .</target>
        </trans-unit>
        <trans-unit id="6c115b27adcc796af14ec5adb8e1c50e34b4b2ef" translate="yes" xml:space="preserve">
          <source>The internal representation is opaque.</source>
          <target state="translated">내부 표현은 불투명합니다.</target>
        </trans-unit>
        <trans-unit id="7334ee5b04d77d686d637a0f70cc9375ca49af7d" translate="yes" xml:space="preserve">
          <source>The internal time format is used when converting between calendars.</source>
          <target state="translated">내부 시간 형식은 달력간에 변환 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c746eb548e21139e2d2543ac649c03aeac54f5a" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;env&lt;/code&gt; of an application resource file has a list of tuples that map atoms to terms, and its contents are known as the application &lt;em&gt;environment&lt;/em&gt;. Note that this environment is unrelated to the operating system environment.</source>
          <target state="translated">응용 프로그램 리소스 파일 의 주요 &lt;code&gt;env&lt;/code&gt; 에는 원자를 용어에 매핑하는 튜플 목록이 있으며 그 내용을 응용 프로그램 &lt;em&gt;환경&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 이 환경은 운영 체제 환경과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3409677dd18b558166751c16ef637b64275c9b00" translate="yes" xml:space="preserve">
          <source>The key types in maps are allowed to overlap, and if they do, the leftmost key takes precedence. A map value does not belong to this type if it contains a key that is not in the allowed map keys.</source>
          <target state="translated">맵의 키 유형은 겹칠 수 있으며, 그렇게하면 가장 왼쪽의 키가 우선합니다. 허용 된 맵 키에없는 키가 포함 된 맵 값은이 유형에 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32d41944ca5b336f1b48c86344355078fd3da940" translate="yes" xml:space="preserve">
          <source>The keyword list used with &lt;code&gt;defstruct&lt;/code&gt; defines what fields the struct will have along with their default values.</source>
          <target state="translated">&lt;code&gt;defstruct&lt;/code&gt; 와 함께 사용되는 키워드 목록 은 struct가 기본값으로 사용할 필드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e67b4b10fb8bead468c4a33dc123a05fee573455" translate="yes" xml:space="preserve">
          <source>The kind (&lt;code&gt;:def&lt;/code&gt; or &lt;code&gt;:defp&lt;/code&gt;) must be given, the function name, its arguments and the compilation options.</source>
          <target state="translated">종류 ( &lt;code&gt;:def&lt;/code&gt; 또는 &lt;code&gt;:defp&lt;/code&gt; ), 함수 이름, 인수 및 컴파일 옵션이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4db3abef2e6392ab0276950699e4f4e0f758b4c0" translate="yes" xml:space="preserve">
          <source>The kind handled by formatting functions</source>
          <target state="translated">형식 지정 기능으로 처리되는 종류</target>
        </trans-unit>
        <trans-unit id="35b01fa192b09fbd575c96a38ea9c12c69135b18" translate="yes" xml:space="preserve">
          <source>The last step is to change the registry to use the dynamic supervisor:</source>
          <target state="translated">마지막 단계는 동적 관리자를 사용하도록 레지스트리를 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec09c363bc1673984c9ef7c8fd26b487f2e86ec0" translate="yes" xml:space="preserve">
          <source>The last step is to implement &lt;code&gt;KVServer.Command.run/1&lt;/code&gt;, to run the parsed commands against the &lt;code&gt;:kv&lt;/code&gt; application. Its implementation is shown below:</source>
          <target state="translated">마지막 단계는 &lt;code&gt;KVServer.Command.run/1&lt;/code&gt; 을 구현 하여 구문 분석 된 명령을 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션 에 대해 실행하는 것 입니다. 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7d6dc59f16f27e400e615ab808e1ed8fe0b3a57" translate="yes" xml:space="preserve">
          <source>The last step is to replace all &lt;code&gt;Mix.env()&lt;/code&gt; calls by &lt;code&gt;config_env()&lt;/code&gt;.</source>
          <target state="translated">마지막 단계는 모든 &lt;code&gt;Mix.env()&lt;/code&gt; 호출을 &lt;code&gt;config_env()&lt;/code&gt; 로 대체하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1505f07b9a5dea491d06c3282407488da838a326" translate="yes" xml:space="preserve">
          <source>The last syntax convenience are &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks. &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks are equivalent to keywords as the last argument of a function call where the block contents are wrapped in parentheses. For example:</source>
          <target state="translated">마지막 구문 편의는 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록입니다. &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록은 블록 내용이 괄호로 묶인 함수 호출의 마지막 인수와 같이 키워드와 같습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc0ec7829a3c5fbbae5ba7d71fb20b1484d4bd86" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is represented similar to operators except that they are always part of a list, its left side represents a list of arguments and the right side is an expression.</source>
          <target state="translated">왼쪽에서 오른쪽으로 화살표 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )는 연산자가 목록의 일부이고 왼쪽은 인수 목록을 나타내고 오른쪽은 표현식이라는 점을 제외하고 연산자와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a6289423275f2a3ff2ff61d789c2121d3f39f1f8" translate="yes" xml:space="preserve">
          <source>The left to right arrow (&lt;code&gt;-&amp;gt;&lt;/code&gt;) is used to establish a relationship between left and right, commonly referred as clauses. The left side may have zero, one, or more arguments; the right side is zero, one, or more expressions separated by new line. The &lt;code&gt;-&amp;gt;&lt;/code&gt; may appear one or more times between one of the following terminators: &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; or &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;. When &lt;code&gt;-&amp;gt;&lt;/code&gt; is used, only other clauses are allowed between those terminators. Mixing clauses and regular expressions is invalid syntax.</source>
          <target state="translated">왼쪽에서 오른쪽 화살표 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; )는 일반적으로 절이라고하는 왼쪽과 오른쪽의 관계를 설정하는 데 사용됩니다. 왼쪽에는 0 개 또는 하나 이상의 인수가있을 수 있습니다. 오른쪽은 개행으로 구분 된 0 개 또는 하나 이상의 표현식입니다. (가) &lt;code&gt;-&amp;gt;&lt;/code&gt; 다음 터미네이터 중 하나 사이에 한 번 이상 나타날 수 있습니다 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 또는을 &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; . &lt;code&gt;-&amp;gt;&lt;/code&gt; 를 사용 하면 해당 터미네이터 사이에 다른 절만 허용됩니다. 절과 정규식을 혼합하는 것은 유효하지 않은 구문입니다.</target>
        </trans-unit>
        <trans-unit id="62dfa2cc28c3ba61b288f1d13e4cdc1ed0d38af0" translate="yes" xml:space="preserve">
          <source>The left-hand side supports any expression you would use on the left-hand side of a match:</source>
          <target state="translated">왼쪽은 일치하는 왼쪽에서 사용할 식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="452a67adaa49211fbae18840ab0e8f40710191cd" translate="yes" xml:space="preserve">
          <source>The length of the match is equal to the &lt;code&gt;unit&lt;/code&gt; (a number of bits) times the &lt;code&gt;size&lt;/code&gt; (the number of repeated segments of length &lt;code&gt;unit&lt;/code&gt;).</source>
          <target state="translated">매치의 길이는 &lt;code&gt;unit&lt;/code&gt; (비트 수)에 &lt;code&gt;size&lt;/code&gt; (길이 &lt;code&gt;unit&lt;/code&gt; 의 반복 세그먼트 수 )를 곱한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9b58150e587a8ab776f8c034fd8c13d895af6209" translate="yes" xml:space="preserve">
          <source>The level of concurrency and the time tasks are allowed to run can be controlled via options (see the &quot;Options&quot; section below).</source>
          <target state="translated">동시성 수준과 작업 실행 시간은 옵션을 통해 제어 할 수 있습니다 (아래 &quot;옵션&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="0f521fe02fee98ba137b8a2f629c9607b50efc70" translate="yes" xml:space="preserve">
          <source>The limit in the given &lt;code&gt;inspect_opts&lt;/code&gt; is respected and when reached this function stops processing and outputs &lt;code&gt;&quot;...&quot;&lt;/code&gt; instead.</source>
          <target state="translated">지정된 &lt;code&gt;inspect_opts&lt;/code&gt; 의 한계 가 존중 되며이 함수에 도달하면 처리가 중지되고 대신 &lt;code&gt;&quot;...&quot;&lt;/code&gt; 이 출력 됩니다.</target>
        </trans-unit>
        <trans-unit id="c1945f9bf3a795845e8993a19f7a9dfe86f17eea" translate="yes" xml:space="preserve">
          <source>The line above makes &lt;code&gt;:kv&lt;/code&gt; available as a dependency inside &lt;code&gt;:kv_server&lt;/code&gt; and automatically starts the &lt;code&gt;:kv&lt;/code&gt; application before the server starts.</source>
          <target state="translated">위의 줄은 &lt;code&gt;:kv&lt;/code&gt; 를 &lt;code&gt;:kv_server&lt;/code&gt; 내부의 종속성으로 사용할 수 있게 하고 서버가 시작되기 전에 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램을 자동으로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="6f3150330fa7863de05e8e4f528741a7ca7bb476" translate="yes" xml:space="preserve">
          <source>The line where the module is defined and its file &lt;strong&gt;must&lt;/strong&gt; be passed as options.</source>
          <target state="translated">모듈이 정의 된 행과 파일 &lt;strong&gt;은&lt;/strong&gt; 옵션으로 전달 &lt;strong&gt;되어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="65e5d401ccb2b8279fcac802ea4250628d92a6f3" translate="yes" xml:space="preserve">
          <source>The list of &lt;code&gt;entries&lt;/code&gt; is a non-empty list of two-element tuples where the first element is the PID and the second element is the value associated to the PID. If there are no entries for the given key, the callback is never invoked.</source>
          <target state="translated">&lt;code&gt;entries&lt;/code&gt; 목록은 비어 있지 않은 두 요소 튜플의 목록이며 첫 번째 요소는 PID이고 두 번째 요소는 PID와 연관된 값입니다. 주어진 키에 대한 항목이 없으면 콜백이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8d60e505b52f11e3ed1a46b8da9d55ffe759f2d" translate="yes" xml:space="preserve">
          <source>The list of callers of the current process can be retrieved from the Process dictionary with &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt;. This will return either &lt;code&gt;nil&lt;/code&gt; or a list &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; with at least one entry Where &lt;code&gt;pid_n&lt;/code&gt; is the PID that called the current process, &lt;code&gt;pid2&lt;/code&gt; called &lt;code&gt;pid_n&lt;/code&gt;, and &lt;code&gt;pid2&lt;/code&gt; was called by &lt;code&gt;pid1&lt;/code&gt;.</source>
          <target state="translated">현재 프로세스의 호출자 목록은 &lt;code&gt;Process.get(:&quot;$callers&quot;)&lt;/code&gt; 를 사용하여 프로세스 사전에서 검색 할 수 있습니다 . 이 중 하나를 반환합니다 &lt;code&gt;nil&lt;/code&gt; 하거나 목록 &lt;code&gt;[pid_n, ..., pid2, pid1]&lt;/code&gt; 어디 하나 이상의 항목과를 &lt;code&gt;pid_n&lt;/code&gt; 는 , 현재의 프로세스라는 PID입니다 &lt;code&gt;pid2&lt;/code&gt; 라고 &lt;code&gt;pid_n&lt;/code&gt; 및 &lt;code&gt;pid2&lt;/code&gt; 호출 된 &lt;code&gt;pid1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2470ea39e6ace181c558514355d2df667d90f1fa" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">문서 목록은 &quot;오른쪽에서&quot;접혀 있습니다. 이 함수는 초기 누산기를 기대하지 않고 &lt;code&gt;docs&lt;/code&gt; 의 마지막 요소를 초기 누산기로 사용한다는 점을 제외하면 &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="6ed6bd036ce9220742f24381556f3269068288d9" translate="yes" xml:space="preserve">
          <source>The list of documents is folded &quot;from the right&quot;; in that, this function is similar to &lt;a href=&quot;list#foldr/3&quot;&gt;&lt;code&gt;List.foldr/3&lt;/code&gt;&lt;/a&gt;, except that it doesn't expect an initial accumulator and uses the last element of &lt;code&gt;docs&lt;/code&gt; as the initial accumulator.</source>
          <target state="translated">문서 목록은 &quot;오른쪽에서&quot;접 힙니다. 이 함수는 초기 누적 &lt;a href=&quot;list#foldr/3&quot;&gt; &lt;code&gt;List.foldr/3&lt;/code&gt; &lt;/a&gt; 기대하지 않고 &lt;code&gt;docs&lt;/code&gt; 의 마지막 요소를 초기 누적 기로 사용 한다는 점을 제외하면 List.foldr / 3 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="55a959d98d885f3a529aa834328d65182098caeb" translate="yes" xml:space="preserve">
          <source>The local copy is stored in your &lt;code&gt;MIX_HOME&lt;/code&gt; (defaults to &lt;code&gt;~/.mix&lt;/code&gt;). This version of Rebar will be used as required by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt;&lt;code&gt;mix deps.compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로컬 사본은 &lt;code&gt;MIX_HOME&lt;/code&gt; 에 저장됩니다 (기본값은 &lt;code&gt;~/.mix&lt;/code&gt; ). 이 버전의 Rebar는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Compile.html&quot;&gt; &lt;code&gt;mix deps.compile&lt;/code&gt; 에서&lt;/a&gt; 필요에 따라 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c160860031d2eb83a58036161c7480f1f6e09fc" translate="yes" xml:space="preserve">
          <source>The lock is sent via &lt;code&gt;opts[:lock]&lt;/code&gt; but it may not always be available. In such cases, if the SCM requires a lock, it must return &lt;code&gt;:mismatch&lt;/code&gt;, otherwise simply &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">잠금은 &lt;code&gt;opts[:lock]&lt;/code&gt; 통해 전송 되지만 항상 사용 가능한 것은 아닙니다. 이러한 경우 SCM에 잠금이 필요하면 &lt;code&gt;:mismatch&lt;/code&gt; 를 반환해야 하고 그렇지 않으면 간단히 &lt;code&gt;:ok&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bae6744658312a20896e781b3c9940470c438e50" translate="yes" xml:space="preserve">
          <source>The low-level API for prying sessions and setting up breakpoints.</source>
          <target state="translated">세션을 검색하고 중단 점을 설정하기위한 저수준 API입니다.</target>
        </trans-unit>
        <trans-unit id="b1a2ec347d3bbd914ac71de3130a3ca5d8e9ba73" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~d&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date sigils.</source>
          <target state="translated">보간 및 이스케이프 문자는 날짜시길에는 유용하지 않으므로 소문자 &lt;code&gt;~d&lt;/code&gt; 변형이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243770f815841be461d24f785d91a84dc8f25160" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~n&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">보간 및 이스케이프 문자는 날짜 시간시길에는 유용하지 않으므로 소문자 &lt;code&gt;~n&lt;/code&gt; 변형이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61c4050f1d545dfb95cf8194b35027ab14a85e08" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~t&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for time sigils.</source>
          <target state="translated">보간 및 이스케이프 문자는 시간 표시에 유용하지 않으므로 소문자 &lt;code&gt;~t&lt;/code&gt; 변형이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32388371298b5aa74ba2be98958ecd5080c981d1" translate="yes" xml:space="preserve">
          <source>The lower case &lt;code&gt;~u&lt;/code&gt; variant does not exist as interpolation and escape characters are not useful for date time sigils.</source>
          <target state="translated">보간 및 이스케이프 문자는 날짜 시간시길에는 유용하지 않으므로 소문자 &lt;code&gt;~u&lt;/code&gt; 변형이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94a5c210052abe863a1fe8f7104b55665bd29e19" translate="yes" xml:space="preserve">
          <source>The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See &lt;a href=&quot;#t:input/0&quot;&gt;&lt;code&gt;input/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#t:output/0&quot;&gt;&lt;code&gt;output/0&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">매크로는 인자로 주어진 코드의 표현을 받고 함수는 인자로 주어진 코드의 결과를받습니다. 매크로는 코드 표현의 상위 집합을 반환해야합니다. 자세한 내용은 &lt;a href=&quot;#t:input/0&quot;&gt; &lt;code&gt;input/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#t:output/0&quot;&gt; &lt;code&gt;output/0&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7ef1cd736ece10b4c740827fd1cda368fe6a8305" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#notice/2&quot;&gt;&lt;code&gt;notice/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warning/2&quot;&gt;&lt;code&gt;warning/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#critical/2&quot;&gt;&lt;code&gt;critical/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#alert/2&quot;&gt;&lt;code&gt;alert/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#emergency/2&quot;&gt;&lt;code&gt;emergency/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">매크로 &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#notice/2&quot;&gt; &lt;code&gt;notice/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#warning/2&quot;&gt; &lt;code&gt;warning/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#critical/2&quot;&gt; &lt;code&gt;critical/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#alert/2&quot;&gt; &lt;code&gt;alert/2&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#emergency/2&quot;&gt; &lt;code&gt;emergency/2&lt;/code&gt; &lt;/a&gt; 가 자동으로 호출 제거 할 수있는이 매크로 선호하는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 모두에서 원하는 경우 컴파일 시간 ( &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 모듈에 대한 문서 참조 ).</target>
        </trans-unit>
        <trans-unit id="8467f6194459766a9d70ef8dad6012fd6200c681" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn/2&quot;&gt;&lt;code&gt;warn/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#error/2&quot;&gt;&lt;code&gt;error/2&lt;/code&gt;&lt;/a&gt; are preferred over this macro as they can automatically eliminate the call to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; altogether at compile time if desired (see the documentation for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">매크로 &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#warn/2&quot;&gt; &lt;code&gt;warn/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#error/2&quot;&gt; &lt;code&gt;error/2&lt;/code&gt; &lt;/a&gt; 는이 매크로보다 선호 됩니다 (원하는 경우 컴파일 타임 에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 대한 호출을 자동으로 제거 할 수 있음) ( &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 모듈 설명서 참조 ).</target>
        </trans-unit>
        <trans-unit id="824174ce5b570e4d9805c05f1124ce5c26a319b1" translate="yes" xml:space="preserve">
          <source>The macros &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defrecordp/3&quot;&gt;&lt;code&gt;defrecordp/3&lt;/code&gt;&lt;/a&gt; can be used to create records while &lt;a href=&quot;#extract/2&quot;&gt;&lt;code&gt;extract/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extract_all/1&quot;&gt;&lt;code&gt;extract_all/1&lt;/code&gt;&lt;/a&gt; can be used to extract records from Erlang files.</source>
          <target state="translated">매크로 &lt;a href=&quot;#defrecord/3&quot;&gt; &lt;code&gt;defrecord/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#defrecordp/3&quot;&gt; &lt;code&gt;defrecordp/3&lt;/code&gt; &lt;/a&gt; 는 레코드를 작성하는 데 사용될 수 있으며 &lt;a href=&quot;#extract/2&quot;&gt; &lt;code&gt;extract/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#extract_all/1&quot;&gt; &lt;code&gt;extract_all/1&lt;/code&gt; &lt;/a&gt; 은 Erlang 파일에서 레코드를 추출하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1487033e0043998b4a55854f41e5aff164999a" translate="yes" xml:space="preserve">
          <source>The macros in this module come in two flavors: named or operators. For example:</source>
          <target state="translated">이 모듈의 매크로는 이름 또는 연산자라는 두 가지 종류로 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f2bf18c746e61e235b955af779aaf9aaea45f54" translate="yes" xml:space="preserve">
          <source>The main entry point to compile source files.</source>
          <target state="translated">소스 파일을 컴파일하기위한 기본 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="38f9dca5177d03726cc73b1076b1d78de398e382" translate="yes" xml:space="preserve">
          <source>The main function in this module is &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;, which parses a list of command line options and arguments into a keyword list:</source>
          <target state="translated">이 모듈의 주요 기능은 &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 이며 명령 행 옵션 및 인수 목록을 키워드 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a06fbfa6c4b60070753ff93ddfbef19aade6baec" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">대부분의 함수는 chardata를 기대합니다. 다른 유형이 제공되는 경우 함수는 &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜을 통해 해당 유형을 문자열로 변환합니다 (유형 사양에 표시됨). chardata에 대한 자세한 내용은 아래 &quot;IO 데이터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="852a05b0450dc656348efc6729f9e523cd593860" translate="yes" xml:space="preserve">
          <source>The majority of the functions expect chardata. In case another type is given, functions will convert those types to string via the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol (as shown in typespecs). For more information on chardata, see the &quot;IO data&quot; section below.</source>
          <target state="translated">함수의 대부분은 chardata를 기대합니다. 다른 유형이 주어지면 함수는 &lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜을 통해 해당 유형을 문자열로 변환 합니다 (typespecs에 표시됨). chardata에 대한 자세한 내용은 아래 &quot;IO 데이터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99c734179f1102a008e516a50860fb644aef0bb8" translate="yes" xml:space="preserve">
          <source>The majority of the functions in the &lt;code&gt;File&lt;/code&gt; module expect paths as arguments. Most commonly, those paths will be regular binaries. The &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; module provides facilities for working with such paths:</source>
          <target state="translated">&lt;code&gt;File&lt;/code&gt; 모듈 의 대부분의 함수는 경로를 인수로 예상합니다. 가장 일반적으로 이러한 경로는 일반 바이너리입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 모듈은 경로 작업을위한 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="14d50e0537a311e097eac9e5b800ff509846d646" translate="yes" xml:space="preserve">
          <source>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like &lt;a href=&quot;#wildcard/2&quot;&gt;&lt;code&gt;wildcard/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈의 대부분의 기능은 파일 시스템과 상호 작용하지 않습니다 ( &lt;a href=&quot;#wildcard/2&quot;&gt; &lt;code&gt;wildcard/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;expand/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="53cb17dd3de6e34ca6338dd415345dba7ba819e3" translate="yes" xml:space="preserve">
          <source>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with &lt;code&gt;spawn_link/1&lt;/code&gt;, let&amp;rsquo;s see what happens when a process started with &lt;code&gt;spawn/1&lt;/code&gt; fails:</source>
          <target state="translated">Elixir에서 프로세스를 생성하는 대부분의 시간은 프로세스를 연결된 프로세스로 생성합니다. &lt;code&gt;spawn_link/1&lt;/code&gt; 예제를 보여주기 전에 &lt;code&gt;spawn/1&lt;/code&gt; 로 시작한 프로세스 가 실패 했을 때 어떤 일이 발생하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="dffb7c1527c61bbb5104fbd6ca60eac0e55a8d98" translate="yes" xml:space="preserve">
          <source>The map above defines a child with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">위의 맵 은 &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; 를 호출하여 시작되는 &lt;code&gt;Stack&lt;/code&gt; 의 &lt;code&gt;:id&lt;/code&gt; 가 있는 자식을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="10d66e531d4200425ddeb9a59e3170249b7e1aed" translate="yes" xml:space="preserve">
          <source>The map above defines a supervisor with &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; that is started by calling &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt;.</source>
          <target state="translated">위의지도는 &lt;code&gt;Stack.start_link([:hello])&lt;/code&gt; 를 호출하여 시작되는 &lt;code&gt;:id&lt;/code&gt; of &lt;code&gt;Stack&lt;/code&gt; 을 사용하여 감독자를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="8bb3eb4a71679f85fc1f23e76313b0ee7d67d6ad" translate="yes" xml:space="preserve">
          <source>The map contains the following keys:</source>
          <target state="translated">맵에는 다음 키가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c1e1079a87250a9082cabf85f0e2b686337098" translate="yes" xml:space="preserve">
          <source>The map must be a function. The function receives an integer representing the code point of the character it wants to unescape. Here is the default mapping function implemented by Elixir:</source>
          <target state="translated">맵은 기능이어야합니다. 이 함수는 이스케이프 해제하려는 문자의 코드 포인트를 나타내는 정수를받습니다. Elixir가 구현 한 기본 매핑 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23154a42b58e45ef674deb33492b4a7b042bd7a7" translate="yes" xml:space="preserve">
          <source>The mapping between code and data (the underlying AST) is what allows Elixir to implement &lt;code&gt;defmodule&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and others in Elixir itself. Elixir makes the constructs available for building the language accessible to developers who want to extend the language to new domains.</source>
          <target state="translated">코드와 데이터 (기본 AST) 간의 매핑은 Elixir가 &lt;code&gt;defmodule&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; 등을 Elixir 자체에서 구현할 수있게 합니다. Elixir는 언어를 새로운 도메인으로 확장하려는 개발자가 언어를 빌드 할 수 있도록 구성물을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a6991efb82e0a459b03a5b7c2a6877fbcec33018" translate="yes" xml:space="preserve">
          <source>The marker is what follows exactly after &lt;code&gt;&amp;lt;%&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; has an empty marker, but &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; has &lt;code&gt;&quot;=&quot;&lt;/code&gt; as marker. The allowed markers so far are:</source>
          <target state="translated">마커는 &lt;code&gt;&amp;lt;%&lt;/code&gt; 바로 뒤에 오는 것 입니다. 예를 들어 &lt;code&gt;&amp;lt;% foo %&amp;gt;&lt;/code&gt; 에는 빈 마커가 있지만 &lt;code&gt;&amp;lt;%= foo %&amp;gt;&lt;/code&gt; 에는 &lt;code&gt;&quot;=&quot;&lt;/code&gt; 가 마커로 있습니다. 지금까지 허용 된 마커는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb00df7fd3fe762840c451309786ffe89ed55ff" translate="yes" xml:space="preserve">
          <source>The match operator</source>
          <target state="translated">일치 연산자</target>
        </trans-unit>
        <trans-unit id="f8693773fd6ff53ba9de6646d15390dd067bbab4" translate="yes" xml:space="preserve">
          <source>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</source>
          <target state="translated">일치 연산자는 단순한 값을 비교하는 데 사용될뿐만 아니라보다 복잡한 데이터 형식을 파괴하는 데에도 유용합니다. 예를 들어 튜플에서 패턴 일치를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ee80ea2fa936cf7002a1188db1c8b023133c11" translate="yes" xml:space="preserve">
          <source>The math module</source>
          <target state="translated">수학 모듈</target>
        </trans-unit>
        <trans-unit id="a810ba47e0afb01caa643d3b27868322a40ed5d7" translate="yes" xml:space="preserve">
          <source>The maximum atom size is of 255 Unicode code points.</source>
          <target state="translated">최대 아톰 크기는 255 개의 유니 코드 코드 포인트입니다.</target>
        </trans-unit>
        <trans-unit id="da10e2a3fe264c784b7e0fdd60cc0177cfc3d0fb" translate="yes" xml:space="preserve">
          <source>The message is formatted and displayed in the same format as used by Elixir's CLI.</source>
          <target state="translated">메시지는 Elixir의 CLI에서 사용 된 것과 같은 형식으로 형식화되고 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae60ef8d035658452d72bdc4024fef29dc953c1c" translate="yes" xml:space="preserve">
          <source>The message is not sent immediately. Therefore, &lt;code&gt;dest&lt;/code&gt; can receive other messages in-between even when &lt;code&gt;time&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">메시지가 즉시 전송되지 않습니다. 따라서 &lt;code&gt;dest&lt;/code&gt; 는 &lt;code&gt;time&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 일 때도 중간에 다른 메시지를 수신 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1852e95a6b1b63c415d7d9c305bc3d2ad89962d3" translate="yes" xml:space="preserve">
          <source>The messages supported by ports and their counterpart function APIs are listed below:</source>
          <target state="translated">포트가 지원하는 메시지 및 해당 기능 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01f467e93a20e666a1a71239d36e1b21c0c18df1" translate="yes" xml:space="preserve">
          <source>The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the &lt;code&gt;:line&lt;/code&gt; annotation, while the AST emitted by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt; will only have the &lt;code&gt;:line&lt;/code&gt; annotation if the &lt;code&gt;:line&lt;/code&gt; option is provided.</source>
          <target state="translated">Elixir AST의 메타 데이터는 키워드 값 목록입니다. 모든 키를 사용할 수 있으며 컴파일러의 다른 부분에서 다른 키를 사용할 수 있습니다. 예를 들어, 매크로에 의해 수신 된 AST는 항상 &lt;code&gt;:line&lt;/code&gt; 주석을 포함하지만 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; 에&lt;/a&gt; 의해 방출 된 AST 는 &lt;code&gt;:line&lt;/code&gt; 옵션이 제공된 경우 에만 &lt;code&gt;:line&lt;/code&gt; 주석을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d94502ad54e0168b2a0dd7bb477e4117c14a5e51" translate="yes" xml:space="preserve">
          <source>The minimum example of a &lt;code&gt;test_helper.exs&lt;/code&gt; file would be:</source>
          <target state="translated">&lt;code&gt;test_helper.exs&lt;/code&gt; 파일 의 최소 ​​예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36e330d350d67652867a9b1fa816fde5c72c65e0" translate="yes" xml:space="preserve">
          <source>The modifiers available when creating a Regex are:</source>
          <target state="translated">정규식을 만들 때 사용할 수있는 수정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="554bd8892a2a2f959aaf3286fab34f7cb4eab543" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;bitwise&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bitwise&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 모듈 에는 &lt;a href=&quot;bitwise#guards&quot;&gt;가드로서&lt;/a&gt; 소수의 Erlang 비트 단위 연산 도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6202288899e34ec4c71c794b46b5bcdf21e2a59" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt;&lt;code&gt;Bitwise&lt;/code&gt;&lt;/a&gt; also includes a handful of &lt;a href=&quot;bitwise#guards&quot;&gt;Erlang bitwise operations as guards&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Bitwise.html&quot;&gt; &lt;code&gt;Bitwise&lt;/code&gt; &lt;/a&gt; 모듈 은 또한 &lt;a href=&quot;bitwise#guards&quot;&gt;가드로&lt;/a&gt; 몇 가지 Erlang 비트 연산을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="b6173752a29eeb047f2dfafc51f6c1560f53e16b" translate="yes" xml:space="preserve">
          <source>The module containing the custom sigil must be imported before the sigil syntax can be used.</source>
          <target state="translated">시길 구문을 사용하려면 먼저 맞춤시길이 포함 된 모듈을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="11a697026fe35980b1003f6f8535e1c516332e63" translate="yes" xml:space="preserve">
          <source>The module documentation above contains documentation and examples for the supported &lt;code&gt;name&lt;/code&gt; values, summarized below:</source>
          <target state="translated">위의 모듈 설명서에는 지원되는 &lt;code&gt;name&lt;/code&gt; 값에 대한 설명서와 예제가 아래에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6052f32cd5500caeb9f54ee4b03cfe6002f80902" translate="yes" xml:space="preserve">
          <source>The module where the server callbacks are implemented, in this case &lt;code&gt;__MODULE__&lt;/code&gt; (meaning the current module)</source>
          <target state="translated">서버 콜백이 구현되는 모듈 ( 이 경우 &lt;code&gt;__MODULE__&lt;/code&gt; (현재 모듈을 의미))</target>
        </trans-unit>
        <trans-unit id="5d69468bc82e2cdb38bbc6e03284931c1987f717" translate="yes" xml:space="preserve">
          <source>The modules &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt;&lt;code&gt;ets&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt;&lt;code&gt;dets&lt;/code&gt;&lt;/a&gt; handle storage of large data structures in memory or on disk respectively.</source>
          <target state="translated">모듈 &lt;a href=&quot;http://erlang.org/doc/man/ets.html&quot;&gt; &lt;code&gt;ets&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://erlang.org/doc/man/dets.html&quot;&gt; &lt;code&gt;dets&lt;/code&gt; &lt;/a&gt; 는 메모리 나 디스크에 각각 큰 데이터 구조의 저장을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="aad5655a8df039c1d174539db815749409e4e0c7" translate="yes" xml:space="preserve">
          <source>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</source>
          <target state="translated">파일에 정의 된 모듈은 제거되지 않습니다. 이 함수를 호출하면 목록에서 제거되어 다시 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2b347a7bc6a5535356bac28ba3f2b363ebc47b" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">가장 일반적인 Erlang 오류는 Elixir 대응으로 변환됩니다. 그렇지 않은 것은 더 일반적인 &lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0e8b772b81f68e7e9d79ec05dc5213643ac8a48" translate="yes" xml:space="preserve">
          <source>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">가장 일반적인 Erlang 오류는 Elixir에 해당하는 오류로 변환됩니다. 그렇지 않은 것은 더 일반적인 &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdce2f67135b244ca8a17c4bfd6e3995d0cb745a" translate="yes" xml:space="preserve">
          <source>The most common sigil in Elixir is &lt;code&gt;~r&lt;/code&gt;, which is used to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;regular expressions&lt;/a&gt;:</source>
          <target state="translated">Elixir에서 가장 일반적인 sigil은 &lt;code&gt;~r&lt;/code&gt; 이며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_Expressions&quot;&gt;정규 표현식&lt;/a&gt; 을 만드는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a6e4e1aba3cc5896f4b550cdd6a497deff0ddb9" translate="yes" xml:space="preserve">
          <source>The most common tasks are &lt;code&gt;mix deps.get&lt;/code&gt; and &lt;code&gt;mix deps.update&lt;/code&gt;. Once fetched, dependencies are automatically compiled for you. You can read more about deps by typing &lt;code&gt;mix help deps&lt;/code&gt;, and in the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;documentation for the Mix.Tasks.Deps module&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 작업은 &lt;code&gt;mix deps.get&lt;/code&gt; 과 &lt;code&gt;mix deps.update&lt;/code&gt; 입니다. 가져 오면 종속성이 자동으로 컴파일됩니다. 당신은 타이핑에 의해 deps에 대한 자세한 읽을 수있는 &lt;code&gt;mix help deps&lt;/code&gt; 과의 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.html&quot;&gt;Mix.Tasks.Deps 모듈에 대한 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9cc7f30985b20ae7924700825d31d820820e24" translate="yes" xml:space="preserve">
          <source>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</source>
          <target state="translated">heredoc sigils의 가장 일반적인 사용 사례는 문서를 작성할 때입니다. 예를 들어, 설명서에 이스케이프 문자를 쓰면 일부 문자를 두 번 이스케이프해야하기 때문에 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9a837abf2f926d7bd68d291aea16431f4ec63587" translate="yes" xml:space="preserve">
          <source>The most common use of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Config&lt;/code&gt;&lt;/a&gt; is to define application configuration so that &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt; and other &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; functions can be used to retrieve or further change them.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Config&lt;/code&gt; &lt;/a&gt; 의 가장 일반적인 용도는 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; &lt;/a&gt; 및 기타 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 검색하거나 추가로 변경할 수 있도록 애플리케이션 구성을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3b38c4c7bf2ec83c1026ecdaac1402a38fdf641" translate="yes" xml:space="preserve">
          <source>The most common way to raise an exception is via &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예외를 발생시키는 가장 일반적인 방법은 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; 를 이용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="db6ae63cdeae86d32f305032ae11a7867f19ace7" translate="yes" xml:space="preserve">
          <source>The most commonly used keys are:</source>
          <target state="translated">가장 일반적으로 사용되는 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec63aea88c70e103879cfde37537cf2e076faa36" translate="yes" xml:space="preserve">
          <source>The name of the generated macros will be &lt;code&gt;name&lt;/code&gt; (which has to be an atom). &lt;code&gt;tag&lt;/code&gt; is also an atom and is used as the &quot;tag&quot; for the record (i.e., the first element of the record tuple); by default (if &lt;code&gt;nil&lt;/code&gt;), it's the same as &lt;code&gt;name&lt;/code&gt;. &lt;code&gt;kv&lt;/code&gt; is a keyword list of &lt;code&gt;name: default_value&lt;/code&gt; fields for the new record.</source>
          <target state="translated">생성 된 매크로의 이름은 &lt;code&gt;name&lt;/code&gt; (아톰이어야 함)이됩니다. &lt;code&gt;tag&lt;/code&gt; 는 또한 원자이며 레코드의 &quot;태그&quot;(즉, 레코드 튜플의 첫 번째 요소)로 사용됩니다. 기본적으로 ( &lt;code&gt;nil&lt;/code&gt; 인 경우 ) &lt;code&gt;name&lt;/code&gt; 과 동일합니다 . &lt;code&gt;kv&lt;/code&gt; 는 새 레코드 의 &lt;code&gt;name: default_value&lt;/code&gt; 필드 로 구성된 키워드 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="c90ebcf1b0655ac03fd3dd0d53f96acb011b2609" translate="yes" xml:space="preserve">
          <source>The name of the service is &lt;code&gt;demo_demo&lt;/code&gt; because the name is built by concatenating the node name with the release name. Since Elixir automatically uses the same name for both, the service will be referenced as &lt;code&gt;demo_demo&lt;/code&gt;.</source>
          <target state="translated">서비스 이름은 &lt;code&gt;demo_demo&lt;/code&gt; 입니다. 이름은 노드 이름과 릴리스 이름을 연결하여 빌드되기 때문입니다. Elixir는 자동으로 두 가지 모두에 동일한 이름을 사용하므로 서비스는 &lt;code&gt;demo_demo&lt;/code&gt; 로 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="090750250669854ad5f2a1b18b4694400b5de691" translate="yes" xml:space="preserve">
          <source>The named sequences are represented by atoms.</source>
          <target state="translated">명명 된 서열은 원자로 표시된다.</target>
        </trans-unit>
        <trans-unit id="84dca7c82c4adab78e96e4275650ccd595bf63f7" translate="yes" xml:space="preserve">
          <source>The need for monitoring</source>
          <target state="translated">모니터링 필요성</target>
        </trans-unit>
        <trans-unit id="11f3fb45a34842b8d6e2b1b6e9657cdd42649db8" translate="yes" xml:space="preserve">
          <source>The new child specs outlined in &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; (v1.5)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; (v1.5)에 설명 된 새로운 하위 사양</target>
        </trans-unit>
        <trans-unit id="5d5693a336fde96fc9f4a9263d265529c9d65820" translate="yes" xml:space="preserve">
          <source>The next two functions, &lt;code&gt;lookup/2&lt;/code&gt; and &lt;code&gt;create/2&lt;/code&gt;, are responsible for sending these requests to the server. In this case, we have used &lt;code&gt;{:lookup, name}&lt;/code&gt; and &lt;code&gt;{:create, name}&lt;/code&gt; respectively. Requests are often specified as tuples, like this, in order to provide more than one &amp;ldquo;argument&amp;rdquo; in that first argument slot. It&amp;rsquo;s common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to &lt;code&gt;handle_call/3&lt;/code&gt; or &lt;code&gt;handle_cast/2&lt;/code&gt;.</source>
          <target state="translated">다음 두 함수 인 &lt;code&gt;lookup/2&lt;/code&gt; 및 &lt;code&gt;create/2&lt;/code&gt; 는 이러한 요청을 서버로 전송합니다. 이 경우에는 각각 &lt;code&gt;{:lookup, name}&lt;/code&gt; 및 &lt;code&gt;{:create, name}&lt;/code&gt; 했습니다. 첫 번째 인수 슬롯에서 둘 이상의 &quot;인수&quot;를 제공하기 위해 요청은 종종 이와 같이 튜플로 지정됩니다. 요청되는 조치를 튜플의 첫 번째 요소로 지정하고 나머지 요소에서 해당 조치에 대한 인수를 지정하는 것이 일반적입니다. 요청은 &lt;code&gt;handle_call/3&lt;/code&gt; 또는 &lt;code&gt;handle_cast/2&lt;/code&gt; 의 첫 번째 인수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="987bf5fe1a29a589006df7a1c4246dedd1188aa8" translate="yes" xml:space="preserve">
          <source>The node list defaults to a list of all connected nodes.</source>
          <target state="translated">노드 목록의 기본값은 연결된 모든 노드의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1e4f23ef668efde946b979656f1273bb8fc04978" translate="yes" xml:space="preserve">
          <source>The notation to represent the union of types is the pipe &lt;code&gt;|&lt;/code&gt;. For example, the typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; creates a type &lt;code&gt;type&lt;/code&gt; that can be either an &lt;code&gt;atom&lt;/code&gt;, a &lt;code&gt;pid&lt;/code&gt;, or a &lt;code&gt;tuple&lt;/code&gt;. This is usually called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;sum type&lt;/a&gt; in other languages</source>
          <target state="translated">유형의 합집합을 나타내는 표기법은 파이프 &lt;code&gt;|&lt;/code&gt; . 예를 들어, typespec &lt;code&gt;type :: atom() | pid() | tuple()&lt;/code&gt; 은 &lt;code&gt;atom&lt;/code&gt; , &lt;code&gt;pid&lt;/code&gt; 또는 &lt;code&gt;tuple&lt;/code&gt; 일 수 있는 유형 &lt;code&gt;type&lt;/code&gt; 을 만듭니다 . 일반적으로 다른 언어 에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;합계 유형&lt;/a&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3ab75e9fdd50914ae4096566ba3ee4815b968a2a" translate="yes" xml:space="preserve">
          <source>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</source>
          <target state="translated">각 익명 함수 절의 인수 수는 같아야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58646d5d2a31b22e08348e0987be6fb1b1552f1b" translate="yes" xml:space="preserve">
          <source>The offset is capped to the length of the string. Returns a tuple with two elements.</source>
          <target state="translated">오프셋은 문자열 길이에 제한됩니다. 두 요소를 가진 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc47b2c77b07a194ec3fbe01564888859692ecf9" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">유일한 차이점 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 이다 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; 이&lt;/a&gt; 는 정수와 수레를 비교에 관해서 엄격합니다 :</target>
        </trans-unit>
        <trans-unit id="7ac751725399e216969e58864613bb897ae9753a" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; is strict when it comes to comparing integers and floats:</source>
          <target state="translated">유일한 차이점 &lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; 이다 &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===&lt;/code&gt; 이&lt;/a&gt; 는 정수와 수레를 비교에 관해서 엄격합니다 :</target>
        </trans-unit>
        <trans-unit id="42fcb26dc86b08d995f11bae71b9989f2f7b728a" translate="yes" xml:space="preserve">
          <source>The only exception to the compatibility guarantees above are experimental features, which will be explicitly marked as such, and do not provide any compatibility guarantee until they are stabilized.</source>
          <target state="translated">위의 호환성 보증에 대한 유일한 예외는 실험적인 기능으로, 명시 적으로 표시되며 안정화 될 때까지 호환성 보증을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f057536218de2bcb4eee9345b4ec9df6b4b0d58" translate="yes" xml:space="preserve">
          <source>The only exception to this rule is that &lt;code&gt;:skip&lt;/code&gt; is found in the &lt;code&gt;include&lt;/code&gt; filter, &lt;code&gt;:ok&lt;/code&gt; is returned regardless of whether the test was excluded or not.</source>
          <target state="translated">이 규칙의 유일한 예외 는 &lt;code&gt;include&lt;/code&gt; 필터 에서 &lt;code&gt;:skip&lt;/code&gt; 이 발견되고 테스트가 제외되었는지 여부에 관계없이 &lt;code&gt;:ok&lt;/code&gt; 가 리턴 된다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5b80c752c5e1cd83678df53e132bab989245bf95" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">구현해야하는 유일한 기능 은 변환을 수행하는 &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3738a03df0b0292cd0fc541a62dccb969b8d4008" translate="yes" xml:space="preserve">
          <source>The only function required to be implemented is &lt;a href=&quot;#to_string/1&quot;&gt;&lt;code&gt;to_string/1&lt;/code&gt;&lt;/a&gt;, which does the conversion.</source>
          <target state="translated">구현하는 데 필요한 유일한 함수는 &lt;a href=&quot;#to_string/1&quot;&gt; &lt;code&gt;to_string/1&lt;/code&gt; &lt;/a&gt; 이며 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9818a90770672e6306fec6ad6c84e3f7b8114355" translate="yes" xml:space="preserve">
          <source>The only function that must be implemented is &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt; which does the conversion.</source>
          <target state="translated">구현해야하는 유일한 함수 는 변환을 수행하는 &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ade81e07849e4708797e256e50ea8daa5d7c1c81" translate="yes" xml:space="preserve">
          <source>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least &lt;code&gt;&amp;amp;1&lt;/code&gt;, and that block expressions are not supported:</source>
          <target state="translated">익명 함수를 만들 때 유일한 제한 사항은 하나 이상의 자리 표시자가 있어야한다는 것입니다. 즉 , &lt;code&gt;&amp;amp;1&lt;/code&gt; 이상을 포함해야 하며 블록 표현식이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bde5d825d53af6907621f0cb4672e1213049a4a" translate="yes" xml:space="preserve">
          <source>The operation is Unicode unsafe.</source>
          <target state="translated">작업이 유니 코드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="820323122693cc928f8711400bb7374b1eb73417" translate="yes" xml:space="preserve">
          <source>The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">이진수 부동 소수점에서 10 진수로 변환하지 않고 연산이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="215bce352413475dfa0bf14c5c4c4836769feeb5" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Elixir에서 사용하는 연산자 (예 : &lt;code&gt;+&lt;/code&gt; )는 모든 모듈에서 정의 할 수 있으며 특히 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (기본적으로 모든 곳 에서 가져 오기)에서 가져 오지 않는 한 Elixir에서 정의한 것 대신 사용할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="54a4338b50a933ea4de60119e3d7bc1ba6605f93" translate="yes" xml:space="preserve">
          <source>The operators that Elixir uses (for example, &lt;code&gt;+&lt;/code&gt;) can be defined by any module and used in place of the ones defined by Elixir, provided they're specifically not imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (which is imported everywhere by default). For example:</source>
          <target state="translated">Elixir가 사용하는 연산자 (예 : &lt;code&gt;+&lt;/code&gt; )는 모든 모듈에서 정의 할 수 있으며 Elixir에서 정의한 연산자 대신 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 가져 오지 않는 경우 기본적으로 모든 위치 에서 가져옵니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d083ec82ad103a49d0f2c21f621e7d904b855c2f" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">문자열을 인용 된 형식으로 변환하는 것과 반대 되는 것은 인용 된 형식을 문자열 / 이진 표현으로 변환하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35424357ca8ff1662dd08fa3f02518cdf95e9618" translate="yes" xml:space="preserve">
          <source>The opposite of converting a string to its quoted form is &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt;, which converts a quoted form to a string/binary representation.</source>
          <target state="translated">문자열을 따옴표로 묶은 형식으로 변환하는 것과 반대로 &lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; 는 따옴표로 묶은 형식을 문자열 / 이진 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="648996e2b78ff86fed25658983c86c1ca75fe83d" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if deprecated calls exist.</source>
          <target state="translated">더 이상 사용되지 않는 호출이있는 &lt;code&gt;--abort-if-any&lt;/code&gt; 옵션을 사용하여 명령이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719eb9d884931feb59017fec9c07b6c8395fab97" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--abort-if-any&lt;/code&gt; can be used for the command to fail if unreachable calls exist.</source>
          <target state="translated">연결할 수없는 호출이있는 &lt;code&gt;--abort-if-any&lt;/code&gt; 옵션을 사용하여 명령이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="098132f317e5ef6b4049ca986c6beb4394ebb00e" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; can be used with &lt;code&gt;@derive&lt;/code&gt; to specify which fields should and should not appear in the algebra document:</source>
          <target state="translated">&lt;code&gt;:only&lt;/code&gt; 및 &lt;code&gt;:except&lt;/code&gt; 옵션 을 &lt;code&gt;@derive&lt;/code&gt; 와 함께 사용 하여 대수 문서에 표시하거나 표시하지 않아야하는 필드를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ca038b4953a725a1168758bdb05bf6957d97558" translate="yes" xml:space="preserve">
          <source>The options above have different properties. Both &lt;code&gt;:rpc&lt;/code&gt; and using a GenServer would serialize your requests on a single server, while tasks are effectively running asynchronously on the remote node, with the only serialization point being the spawning done by the supervisor.</source>
          <target state="translated">위의 옵션은 다른 속성을 가지고 있습니다. 모두 &lt;code&gt;:rpc&lt;/code&gt; 및 작업을 효과적으로 원격 노드에서 비동기 적으로 실행하는 동안 GenServer은 관리자에 의해 수행 산란되는 유일한 직렬화 포인트, 단일 서버에서 사용자의 요청을 직렬화 것 사용.</target>
        </trans-unit>
        <trans-unit id="ec569bf070d46fd1797683900e4e0d1b42dd476e" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">이 옵션을 사용하여 감독자 이름을 등록 할 수도 있습니다. 지원되는 값은 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 모듈 문서 의 &quot;이름 등록&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbff1ba0f3f44314e39e2577a433b4751e9e390" translate="yes" xml:space="preserve">
          <source>The options can also be used to register a supervisor name. The supported values are described under the &quot;Name registration&quot; section in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">옵션을 사용하여 감독자 이름을 등록 할 수도 있습니다. 지원되는 값은 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 모듈 문서 의 &quot;이름 등록&quot;섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29b1695f7e1a72d94e875780fae402a43a9edf2" translate="yes" xml:space="preserve">
          <source>The options given in the child specification are documented in &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하위 스펙에 제공된 옵션은 &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; 에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="29149d2185c124051b475d7edf03c7125bd21d1c" translate="yes" xml:space="preserve">
          <source>The options not available are:</source>
          <target state="translated">사용할 수없는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4550dfac2891c5670508cc8032dc4a8ebcd0b681" translate="yes" xml:space="preserve">
          <source>The order they are returned is guaranteed to be sorted for proper dependency resolution. For example, if A depends on B, then B will listed before A.</source>
          <target state="translated">반환되는 순서는 적절한 종속성 해결을 위해 정렬됩니다. 예를 들어 A가 B에 의존하는 경우 B는 A 앞에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="df79e73939e2f96120d0bd91e6ec1e8015418fd3" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;List&lt;/code&gt; can still be accessed within &lt;code&gt;Stats&lt;/code&gt; by the fully-qualified name &lt;code&gt;Elixir.List&lt;/code&gt;.</source>
          <target state="translated">정식 이름 &lt;code&gt;Elixir.List&lt;/code&gt; 로 &lt;code&gt;Stats&lt;/code&gt; 내에서 원래 &lt;code&gt;List&lt;/code&gt; 에 계속 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce9ed5ea2ea656edc685034fbbcbc4be784892bd" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">출력은 다른 &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; 호출 과 쉽게 구별 할 수 있도록 &lt;code&gt;:label&lt;/code&gt; 옵션을 제공하여 레이블로 장식 할 수 있습니다 . 라벨은 검사 된 &lt;code&gt;item&lt;/code&gt; 보다 먼저 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1668a9a07e94faf6e48dc573decf8c9122af382" translate="yes" xml:space="preserve">
          <source>The output can be decorated with a label, by providing the &lt;code&gt;:label&lt;/code&gt; option to easily distinguish it from other &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; calls. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:label&lt;/code&gt; 옵션을 제공하여 다른 &lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; 호출 과 쉽게 구별하여 출력을 레이블로 장식 할 수 있습니다 . 검사 된 &lt;code&gt;item&lt;/code&gt; 전에 라벨이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="f95d4e3d274d4d273eca22868ba00ceeec8b577f" translate="yes" xml:space="preserve">
          <source>The output of a macro</source>
          <target state="translated">매크로의 출력</target>
        </trans-unit>
        <trans-unit id="a8fcd6a77b8cc147c47e87ab2b38b5ca8be3e761" translate="yes" xml:space="preserve">
          <source>The path for local archives or escripts.</source>
          <target state="translated">로컬 아카이브 또는 escript의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="abd015aedaea96a1467039e45829bb4bd7fad58c" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">경로는 추가되기 전에 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 로&lt;/a&gt; 확장 됩니다. 이 경로가 없으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e20a72d38a5ba46e84750b746640ae5729db0fc4" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경로는 삭제되기 전에 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 로&lt;/a&gt; 확장 됩니다. 경로가 존재하지 않으면이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e11342758ba07f1f86c835e6c8736ad536d0d920" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">경로는 앞에 추가되기 전에 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 로&lt;/a&gt; 확장 됩니다. 이 경로가 없으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="313b3334ac8a23ead5e2d1a7fbc216efaabeea04" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being appended. If this path does not exist, an error is returned.</source>
          <target state="translated">경로는 추가되기 전에 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 로&lt;/a&gt; 확장 됩니다. 이 경로가 존재하지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6d4310f7386df1164fbd8636a1690c05bd665337" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being deleted. If the path does not exist, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경로는 삭제되기 전에 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 로&lt;/a&gt; 확장 됩니다. 경로가 존재하지 않으면이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="838b6d73e0a2709d4a72a878f5b42de538ac3faf" translate="yes" xml:space="preserve">
          <source>The path is expanded with &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; before being prepended. If this path does not exist, an error is returned.</source>
          <target state="translated">경로는 앞에 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 전에 Path.expand / 1로 확장 됩니다. 이 경로가 존재하지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e091aa0884c675c72ffb53e03abf27a7e2087b1e" translate="yes" xml:space="preserve">
          <source>The paths can be either a charlist or a string. Internally they are worked on as charlists, so passing them as lists avoid extra conversion.</source>
          <target state="translated">경로는 charlist 또는 string 일 수 있습니다. 내부적으로 그들은 charlists로 작업하므로 목록으로 전달하면 추가 변환을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="668bfdcbbc88064352f1db03b861c85f89d02114" translate="yes" xml:space="preserve">
          <source>The pattern can be a module name, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; to count all calls to that module, a call without arity, such as &lt;code&gt;String.split&lt;/code&gt;, to count all calls to that function regardless of arity, or a call with arity, such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt;, to count all calls to that exact module, function and arity.</source>
          <target state="translated">패턴은 해당 모듈에 대한 모든 호출을 계산하는 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 과 같은 모듈 이름, &lt;code&gt;String.split&lt;/code&gt; 과 같은 arity가없는 호출은 arity에 관계없이 해당 함수에 대한 모든 호출을 계산하거나 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt; 과 같은 arity가있는 호출 일 수 있습니다. .split / 2 , 해당 정확한 모듈, 기능 및 특성에 대한 모든 호출을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e6382a5f5628ad82e683e23e1297c423e36e37f3" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matched patterns:</source>
          <target state="translated">패턴은 문자열 목록 일 수도 있고 대체는 일치하는 패턴을 수신하는 함수일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3b17b28d01efecd387f4a558aef5d36e3e123e9" translate="yes" xml:space="preserve">
          <source>The pattern may also be a list of strings and the replacement may also be a function that receives the matches:</source>
          <target state="translated">패턴은 문자열 목록 일 수도 있고 교체는 일치 항목을받는 함수일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2c0506c6452af899d4d254cc14a3c00d8d753c" translate="yes" xml:space="preserve">
          <source>The pattern of keeping multiple applications in the same repository is known as &amp;ldquo;mono-repo&amp;rdquo;. Umbrella projects maximize this pattern by providing conveniences to compile, test and run multiple applications at once.</source>
          <target state="translated">여러 응용 프로그램을 동일한 리포지토리에 유지하는 패턴을 &quot;모노 레포&quot;라고합니다. 우산 프로젝트는 여러 애플리케이션을 한 번에 컴파일, 테스트 및 실행할 수있는 편의성을 제공하여이 패턴을 최대화합니다.</target>
        </trans-unit>
        <trans-unit id="b5336f2e10af99a0ddce0df1dbcc6953c1b3edca" translate="yes" xml:space="preserve">
          <source>The pin operator</source>
          <target state="translated">핀 연산자</target>
        </trans-unit>
        <trans-unit id="8a16097e3345670b784d58d96c0daf29bd6b6363" translate="yes" xml:space="preserve">
          <source>The pipe operator</source>
          <target state="translated">파이프 운영자</target>
        </trans-unit>
        <trans-unit id="38ac69a732c3ec695582cbd0d48d9b6cb576dd15" translate="yes" xml:space="preserve">
          <source>The port can be opened through four main mechanisms.</source>
          <target state="translated">포트는 4 가지 주요 메커니즘을 통해 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f2f4882ba1e010d9493752e86925be5a3100f2" translate="yes" xml:space="preserve">
          <source>The power of Elixir&amp;rsquo;s extensibility comes when protocols and structs are used together.</source>
          <target state="translated">프로토콜과 구조체를 함께 사용하면 Elixir의 확장 성의 힘이옵니다.</target>
        </trans-unit>
        <trans-unit id="4539c5e2ab058d8719dac59fa3bb2dc3b38cff89" translate="yes" xml:space="preserve">
          <source>The precision represents the number of digits that must be used when representing the microseconds to external format. If the precision is 0, it means microseconds must be skipped.</source>
          <target state="translated">정밀도는 마이크로 초를 외부 형식으로 표시 할 때 사용해야하는 자릿수를 나타냅니다. 정밀도가 0이면 마이크로 초를 건너 뛰어야한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="7b62847898ead6d12d866064984b0e4967caa7b6" translate="yes" xml:space="preserve">
          <source>The previous implementation used pipelines which made the logic straightforward to follow. However, now that we need to handle different error codes along the way, our server logic is nested inside many &lt;code&gt;case&lt;/code&gt; calls.</source>
          <target state="translated">이전 구현에서는 논리를 따라 가기 쉬운 파이프 라인을 사용했습니다. 그러나 이제는 다양한 오류 코드를 처리해야하므로 서버 논리는 여러 &lt;code&gt;case&lt;/code&gt; 호출 안에 중첩됩니다 .</target>
        </trans-unit>
        <trans-unit id="199cc5f932aae17375561fec949a9c5a51d6d815" translate="yes" xml:space="preserve">
          <source>The problem with the code above is that, if the user supplies an invalid input, the error will be raised deep inside the library, which makes it confusing for users. Furthermore, when you don't validate the values at the boundary, the internals of your library are never quite sure which kind of values they are working with.</source>
          <target state="translated">위 코드의 문제점은 사용자가 유효하지 않은 입력을 제공하면 라이브러리 내부에서 오류가 발생하여 사용자에게 혼란을 줄 수 있다는 것입니다. 또한 경계에서 값의 유효성을 검사하지 않으면 라이브러리의 내부가 어떤 종류의 값으로 작업하는지 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="523d730771dc4a286c57cbc053f5c708e3c1f6ea" translate="yes" xml:space="preserve">
          <source>The process is terminated, if there's one. The child specification is kept unless the child is temporary.</source>
          <target state="translated">프로세스가 있으면 종료됩니다. 아이가 일시적이 아닌 한 아이 사양이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b431d95d4131709473d087764c74e5d0bd63926d" translate="yes" xml:space="preserve">
          <source>The process of taking a list and &lt;em&gt;reducing&lt;/em&gt; it down to one value is known as a &lt;em&gt;reduce algorithm&lt;/em&gt; and is central to functional programming.</source>
          <target state="translated">목록을 가져 와서 하나의 값으로 &lt;em&gt;줄이는&lt;/em&gt; 프로세스를 &lt;em&gt;축소 알고리즘&lt;/em&gt; 이라고하며 함수형 프로그래밍의 핵심입니다.</target>
        </trans-unit>
        <trans-unit id="2fe675ae074650fc0dd2cca82261ebbd5e4a0afa" translate="yes" xml:space="preserve">
          <source>The process that sends the message does not block on &lt;code&gt;send/2&lt;/code&gt;, it puts the message in the recipient&amp;rsquo;s mailbox and continues. In particular, a process can send messages to itself.</source>
          <target state="translated">메시지를 보내는 프로세스는 &lt;code&gt;send/2&lt;/code&gt; 에서 차단되지 않고 메시지를 수신자의 편지함에 넣고 계속합니다. 특히 프로세스는 메시지를 자신에게 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f279aa503c0e9c1a8851aaff4d4667435775ccbe" translate="yes" xml:space="preserve">
          <source>The project name is given in the &lt;code&gt;snake_case&lt;/code&gt; convention where all letters are lowercase and words are separate with underscores. This is the same convention used by variables, function names and atoms in Elixir. See the &lt;a href=&quot;naming-conventions&quot;&gt;Naming Conventions&lt;/a&gt; document for more information.</source>
          <target state="translated">프로젝트 이름은 모든 문자가 소문자이고 단어가 밑줄로 분리되는 &lt;code&gt;snake_case&lt;/code&gt; 규칙에 제공됩니다 . 이것은 엘릭서의 변수, 함수 이름 및 원자에서 사용하는 것과 동일한 규칙입니다. 자세한 내용은 &lt;a href=&quot;naming-conventions&quot;&gt;명명 규칙&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee55aee8e2dfe77fe02c53dba2352810a3c64b0a" translate="yes" xml:space="preserve">
          <source>The protocol definition would look like this:</source>
          <target state="translated">프로토콜 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc915ce7d8df69961e91346b51ae1b4406aeabbb" translate="yes" xml:space="preserve">
          <source>The queue module</source>
          <target state="translated">큐 모듈</target>
        </trans-unit>
        <trans-unit id="0af8f5620b697ca5fb92373212c500e4cb31990a" translate="yes" xml:space="preserve">
          <source>The rand module</source>
          <target state="translated">랜드 모듈</target>
        </trans-unit>
        <trans-unit id="ff54517df928691d964fdb5317bf18da5a260890" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. In Erlang, charlists are the default way of handling strings, while in Elixir it's binaries. One example of such functions is &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 동작의 근거는 Elixir 문자열 대신 문자 목록으로 텍스트를 반환 할 수있는 Erlang 라이브러리를 더 잘 지원하는 것입니다. Erlang에서 charlist는 문자열을 처리하는 기본 방법이고 Elixir에서는 바이너리입니다. 이러한 함수의 한 가지 예는 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="231da92c7cb81a49b248aa20d7528608e5de9c35" translate="yes" xml:space="preserve">
          <source>The rationale behind this behaviour is to better support Erlang libraries which may return text as charlists instead of Elixir strings. One example of such functions is &lt;a href=&quot;application#loaded_applications/0&quot;&gt;&lt;code&gt;Application.loaded_applications/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 동작의 근거는 텍스트를 Elixir 문자열 대신 charlists로 반환 할 수있는 Erlang 라이브러리를보다 잘 지원하는 것입니다. 이러한 함수의 한 예는 &lt;a href=&quot;application#loaded_applications/0&quot;&gt; &lt;code&gt;Application.loaded_applications/0&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22c7e6cba80de4bce6770359917648b6c44cab9b" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">프로토콜의 진정한 이점은 구조체와 혼합 될 때 발생합니다. 예를 들어 Elixir에는 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 과 같이 구조체로 구현 된 많은 데이터 유형이 함께 제공됩니다 . 이러한 유형에 대해서도 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd093bcc0572d7db8f0249b943686c7ab44cd28f" translate="yes" xml:space="preserve">
          <source>The real benefit of protocols comes when mixed with structs. For instance, Elixir ships with many data types implemented as structs, like &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. We can implement the &lt;code&gt;Size&lt;/code&gt; protocol for those types as well:</source>
          <target state="translated">프로토콜의 실제 이점은 구조체와 혼합 될 때 발생합니다. 예를 들어, Elixir는 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 과 같은 구조체로 구현 된 많은 데이터 유형과 함께 제공됩니다 . 이러한 유형에 대해서도 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd7d714c1aa6b48b1d5593fcc16114d85e6a86ca" translate="yes" xml:space="preserve">
          <source>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like &lt;code&gt;~r(^https?://)&lt;/code&gt; reads arguably better than &lt;code&gt;~r/^https?:\/\//&lt;/code&gt;. Similarly, if the regular expression has forward slashes and capturing groups (that use &lt;code&gt;()&lt;/code&gt;), you may then choose double quotes instead of parentheses.</source>
          <target state="translated">다른 분리 문자를 지원하는 이유는 이스케이프 된 분리 문자없이 리터럴을 작성하는 방법을 제공하기위한 것입니다. 예를 들어, &lt;code&gt;~r(^https?://)&lt;/code&gt; 와 같이 슬래시가있는 정규식 은 &lt;code&gt;~r/^https?:\/\//&lt;/code&gt; 보다 확실히 읽습니다 . 마찬가지로 정규식에 슬래시와 캡처 그룹 ( &lt;code&gt;()&lt;/code&gt; 사용 )이 있으면 괄호 대신 큰 따옴표를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ebf61cf3ca7649d4a079542dcbdefccc549e8d6" translate="yes" xml:space="preserve">
          <source>The reason those failures are happening is because, for didactic purposes, we have made two mistakes:</source>
          <target state="translated">이러한 실패가 발생하는 이유는 교훈적인 목적으로 두 가지 실수를했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c08560839cd14ff160f58cb4ece9a90b113b6018" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don&amp;rsquo;t need to worry about different data types in order to sort. The overall sorting order is defined below:</source>
          <target state="translated">다른 데이터 형식을 비교할 수있는 이유는 실용성입니다. 정렬 알고리즘은 정렬하기 위해 다른 데이터 유형에 대해 걱정할 필요가 없습니다. 전체 정렬 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96b6eb1d3d1c2f52c89893113a0264a48486f7f0" translate="yes" xml:space="preserve">
          <source>The reason we can compare different data types is pragmatism. Sorting algorithms don't need to worry about different data types in order to sort. For reference, the overall sorting order is defined below:</source>
          <target state="translated">다른 데이터 형식을 비교할 수있는 이유는 실용성입니다. 정렬 알고리즘은 정렬하기 위해 다른 데이터 유형에 대해 걱정할 필요가 없습니다. 참고로 전체 정렬 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bf8002bbf671d6262f86dd4db1f940a5c99c6ee" translate="yes" xml:space="preserve">
          <source>The reason we don't provide hot code upgrades is because they are very complicated to perform in practice, as they require careful coding of your processes and applications as well as extensive testing. Given most teams can use other techniques that are language agnostic to upgrade their systems, such as Blue/Green deployments, Canary deployments, Rolling deployments, and others, hot upgrades are rarely a viable option. Let's understand why.</source>
          <target state="translated">핫 코드 업그레이드를 제공하지 않는 이유는 프로세스와 애플리케이션에 대한 세심한 코딩과 광범위한 테스트가 필요하기 때문에 실제로 수행하기가 매우 복잡하기 때문입니다. 대부분의 팀이 블루 / 그린 배포, 카나리아 배포, 롤링 배포 등과 같이 언어에 구애받지 않는 다른 기술을 사용하여 시스템을 업그레이드 할 수 있다는 점을 감안할 때 핫 업그레이드는 거의 실행 가능한 옵션이 아닙니다. 이유를 이해합시다.</target>
        </trans-unit>
        <trans-unit id="9745fde52cc90f68fc3769f51bdd3839a79e7909" translate="yes" xml:space="preserve">
          <source>The reason why defining the &lt;code&gt;__using__&lt;/code&gt; macro above should be avoided is because when a developer writes:</source>
          <target state="translated">위 의 &lt;code&gt;__using__&lt;/code&gt; 매크로를 정의 하지 않는 이유는 개발자가 다음을 쓸 때 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6ec6b8d401a0e57e5eec7caca955764b74ee728d" translate="yes" xml:space="preserve">
          <source>The reducer function.</source>
          <target state="translated">감속기 기능.</target>
        </trans-unit>
        <trans-unit id="fe9b615b4b2367b7daee50e253cbdf23dba26c40" translate="yes" xml:space="preserve">
          <source>The registry can be used for different purposes, such as name lookups (using the &lt;code&gt;:via&lt;/code&gt; option), storing properties, custom dispatching rules, or a pubsub implementation. We explore some of those use cases below.</source>
          <target state="translated">레지스트리는 이름 조회 ( &lt;code&gt;:via&lt;/code&gt; 옵션 사용), 속성 저장, 사용자 지정 디스패치 규칙 또는 pubsub 구현 과 같은 다양한 목적으로 사용될 수 있습니다 . 아래에서 이러한 사용 사례 중 일부를 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="830561c69ec1b44d20b1476b8ca91dcfe652b847" translate="yes" xml:space="preserve">
          <source>The registry creates the bucket and updates the cache table</source>
          <target state="translated">레지스트리가 버킷을 생성하고 캐시 테이블을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1e02149d4dfcef116ac8ae8bc7c958f58a3e9c0d" translate="yes" xml:space="preserve">
          <source>The registry identifier</source>
          <target state="translated">레지스트리 식별자</target>
        </trans-unit>
        <trans-unit id="6c262eba9d17501af95e8d89e43d93764b4ff9c4" translate="yes" xml:space="preserve">
          <source>The registry may also be transparently partitioned, which provides more scalable behaviour for running registries on highly concurrent environments with thousands or millions of entries.</source>
          <target state="translated">레지스트리는 투명하게 분할되어 수천 또는 수백만 개의 항목이있는 동시 환경에서 레지스트리를 실행하기위한 확장 가능한 동작을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dcaa3fc50cf9fd5531a012d77c058d5085b7bd8" translate="yes" xml:space="preserve">
          <source>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to &lt;em&gt;monitor&lt;/em&gt; each bucket. Because our &lt;em&gt;registry&lt;/em&gt; needs to be able to receive and handle ad-hoc messages from the system, the &lt;code&gt;Agent&lt;/code&gt; API is not enough.</source>
          <target state="translated">레지스트리는 항상 최신 상태를 유지해야합니다. 예를 들어, 버그로 인해 버킷 프로세스 중 하나가 충돌하는 경우 레지스트리는이 변경 사항을 확인하고 오래된 항목을 제공하지 않아야합니다. Elixir에서는 레지스트리가 각 버킷 을 &lt;em&gt;모니터링&lt;/em&gt; 해야한다고 말합니다 . 우리 때문에 &lt;em&gt;레지스트리&lt;/em&gt; 필요가 시스템에서 임시 메시지를 수신하고 처리 할 수의 &lt;code&gt;Agent&lt;/code&gt; API는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a058f690e57a3aca65e5ad6c344df9d0e9611d7" translate="yes" xml:space="preserve">
          <source>The registry requires the following keys:</source>
          <target state="translated">레지스트리에는 다음 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="66187ff2a57d2c76b021b6e86b887377c3911cc5" translate="yes" xml:space="preserve">
          <source>The remaining fields are private and should not be accessed.</source>
          <target state="translated">나머지 필드는 개인용이므로 액세스하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0abbf815761f3e816424020ca8e718d8880a26" translate="yes" xml:space="preserve">
          <source>The remaining options can be specified to further customize the escript:</source>
          <target state="translated">나머지 옵션은 escript를 추가로 사용자 정의하기 위해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b880036afa4f762da2230a6fa814b25c0b9e585" translate="yes" xml:space="preserve">
          <source>The replacement can be either a string or a function. The string is used as a replacement for every match and it allows specific captures to be accessed via &lt;code&gt;\N&lt;/code&gt; or &lt;code&gt;\g{N}&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the capture. In case &lt;code&gt;\0&lt;/code&gt; is used, the whole match is inserted. Note that in regexes the backslash needs to be escaped, hence in practice you'll need to use &lt;code&gt;\\N&lt;/code&gt; and &lt;code&gt;\\g{N}&lt;/code&gt;.</source>
          <target state="translated">대체는 문자열 또는 함수일 수 있습니다. 이 문자열은 모든 일치 항목의 대체로 사용되며 &lt;code&gt;\N&lt;/code&gt; 또는 &lt;code&gt;\g{N}&lt;/code&gt; 통해 특정 캡처에 액세스 할 수 있습니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 캡처입니다. 경우 &lt;code&gt;\0&lt;/code&gt; 전체 경기가 삽입되어 사용된다. 정규 표현식에서 백 슬래시를 이스케이프해야하므로 실제로 &lt;code&gt;\\N&lt;/code&gt; 및 &lt;code&gt;\\g{N}&lt;/code&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d12dcacc64e49f2ca797e3a42d48c6b95c4c021d" translate="yes" xml:space="preserve">
          <source>The reply sent by the task will be in the format &lt;code&gt;{ref, result}&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the monitor reference held by the task struct and &lt;code&gt;result&lt;/code&gt; is the return value of the task function.</source>
          <target state="translated">태스크가 보낸 응답은 &lt;code&gt;{ref, result}&lt;/code&gt; 형식 이며, 여기서 &lt;code&gt;ref&lt;/code&gt; 는 태스크 구조체가 보유한 모니터 참조이고 &lt;code&gt;result&lt;/code&gt; 는 태스크 함수의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="fbae3095fe06d4c7dbe53db6c416f757e85aa9e2" translate="yes" xml:space="preserve">
          <source>The requirement operand after the &lt;code&gt;~&amp;gt;&lt;/code&gt; is allowed to omit the patch version, allowing us to express &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; or &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt;, something that wouldn't be allowed when using the common comparison operators.</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; 이후의 요구 사항 피연산자 는 패치 버전을 생략 할 수 있으므로 공통 비교 연산자를 사용할 때 허용되지 않는 &lt;code&gt;~&amp;gt; 2.1&lt;/code&gt; 또는 &lt;code&gt;~&amp;gt; 2.1-dev&lt;/code&gt; 를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c107c58db2b694200d1ee8f97e6cacd70556ad" translate="yes" xml:space="preserve">
          <source>The requirements for this guide are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">이 안내서의 요구 사항은 다음과 같습니다 ( &lt;code&gt;elixir -v&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="510fb68883c75cfa0f5726ad2958e2b2d1f8df13" translate="yes" xml:space="preserve">
          <source>The rest of this document will cover how child processes are specified, how they can be started and stopped, different supervision strategies and more.</source>
          <target state="translated">이 문서의 나머지 부분에서는 하위 프로세스 지정 방법, 시작 및 중지 방법, 다양한 감독 전략 등을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="34f71128fc5223e069e44135ef71e787278b7b2a" translate="yes" xml:space="preserve">
          <source>The result depends on the given options. In particular, if &lt;code&gt;:monitor&lt;/code&gt; is given as an option, it will return a tuple containing the PID and the monitoring reference, otherwise just the spawned process PID.</source>
          <target state="translated">결과는 주어진 옵션에 따라 다릅니다. 특히, &lt;code&gt;:monitor&lt;/code&gt; 가 옵션으로 제공되면 PID 및 모니터링 참조가 포함 된 튜플을 반환하고 그렇지 않은 경우 스폰 된 프로세스 PID 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8c0864a3fd323ad326bf0ff0a4ae750f6f28b62b" translate="yes" xml:space="preserve">
          <source>The result is a map where each key is given by &lt;code&gt;key_fun&lt;/code&gt; and each value is a list of elements given by &lt;code&gt;value_fun&lt;/code&gt;. The order of elements within each list is preserved from the &lt;code&gt;enumerable&lt;/code&gt;. However, like all maps, the resulting map is unordered.</source>
          <target state="translated">결과는 각 키가 &lt;code&gt;key_fun&lt;/code&gt; 에 의해 제공되는 맵 이고 각 값은 &lt;code&gt;value_fun&lt;/code&gt; 에 의해 제공된 요소의 목록입니다 . 각 목록 내 요소의 순서는 &lt;code&gt;enumerable&lt;/code&gt; 합니다. 그러나 모든지도와 마찬가지로 결과지도는 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c937afc93e905039ed962f46e31ce761b0b7910" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the code point and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">결과는 코드 포인트와 문자열의 나머지 부분 또는 문자열이 끝에 도달하면 &lt;code&gt;nil&lt;/code&gt; 이있는 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="b054d17c2daa0de49da800a95e641450c215bba5" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the grapheme and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the String reached its end.</source>
          <target state="translated">결과는 그래프와 튜플이며 나머지는 문자열이거나 문자열이 끝에 도달하면 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf56030549a526b9bf11fca22b129025175f9e01" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">결과는 다음 grapheme 크기를 가진 튜플이며 문자열의 끝에 도달 한 경우 나머지 문자열 또는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49e5bd89a099593fc1d84560689945a8bdf9718a" translate="yes" xml:space="preserve">
          <source>The result is a tuple with the next grapheme size in bytes and the remainder of the string or &lt;code&gt;nil&lt;/code&gt; in case the string reached its end.</source>
          <target state="translated">결과는 다음 문자 소 크기 (바이트)와 나머지 문자열 또는 문자열이 끝에 도달 한 경우 &lt;code&gt;nil&lt;/code&gt; 을 갖는 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="69c824c2f4dd9e92c63e7c43b613daec936f10e9" translate="yes" xml:space="preserve">
          <source>The result is always a float. Use &lt;a href=&quot;#div/2&quot;&gt;&lt;code&gt;div/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#rem/2&quot;&gt;&lt;code&gt;rem/2&lt;/code&gt;&lt;/a&gt; if you want an integer division or the remainder.</source>
          <target state="translated">결과는 항상 부동입니다. 정수 나누기 또는 나머지를 원하는 경우 &lt;a href=&quot;#div/2&quot;&gt; &lt;code&gt;div/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#rem/2&quot;&gt; &lt;code&gt;rem/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e60b28a7c2d9f237889da5d63ad55cd56db26e5f" translate="yes" xml:space="preserve">
          <source>The result is returned in the &lt;code&gt;:native&lt;/code&gt; time unit.</source>
          <target state="translated">결과는 &lt;code&gt;:native&lt;/code&gt; 시간 단위 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e378125d134cee06b90778b774e2ca53b3a689f" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (e.g., obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">주어진 시간 단위 &lt;code&gt;unit&lt;/code&gt; 로 결과가 반환됩니다 . Erlang 단조 시간에 추가 된 반환 오프셋 (예 : &lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; 으로&lt;/a&gt; 획득 )은 해당 단조 시간에 해당하는 Erlang 시스템 시간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd31606d8c7fb963c24880e97f324e4acb8d8f68" translate="yes" xml:space="preserve">
          <source>The result is returned in the given time unit &lt;code&gt;unit&lt;/code&gt;. The returned offset, added to an Erlang monotonic time (for instance, one obtained with &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt;), gives the Erlang system time that corresponds to that monotonic time.</source>
          <target state="translated">결과는 주어진 시간 단위 &lt;code&gt;unit&lt;/code&gt; 로 반환됩니다 . Erlang 단조 시간 (예 : &lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; 으로&lt;/a&gt; 얻은 시간)에 추가 된 반환 된 오프셋 은 해당 단조 시간에 해당하는 Erlang 시스템 시간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ad2bb7bf504a7a31fc692bc22a46a7f6c26558df" translate="yes" xml:space="preserve">
          <source>The result is rounded via the floor function.</source>
          <target state="translated">결과는 바닥 함수를 통해 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="7c9d24e7e55d00cf51e7d7ac4365534956cf6af0" translate="yes" xml:space="preserve">
          <source>The result of the reduce operation.</source>
          <target state="translated">감소 작업의 결과.</target>
        </trans-unit>
        <trans-unit id="5c33a08ba308a53a6a04ff3b3a415b2906539c81" translate="yes" xml:space="preserve">
          <source>The result of this function is used to check if two calendars rollover at the same time of day. If they do not, we can only convert datetimes and times between them. If they do, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">이 기능의 결과는 두 개의 캘린더가 같은 시간에 롤오버되는지 확인하는 데 사용됩니다. 그렇지 않은 경우 날짜 시간과 시간 만 변환 할 수 있습니다. 그렇다면 날짜와 날짜 사이의 순진한 날짜 시간도 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deee6a8e2cf3a1dc01e05f85abd7a333a49b9743" translate="yes" xml:space="preserve">
          <source>The result returned when the argument is a list, is the list of nodes satisfying the disjunction(s) of the list elements.</source>
          <target state="translated">인수가리스트 일 때 리턴되는 결과는리스트 요소의 분리를 만족시키는 노드리스트입니다.</target>
        </trans-unit>
        <trans-unit id="de9d80b1ab304736a1d1cf097b00ab6920ddf496" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;fun&lt;/code&gt; is expected to be</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 위한 귀환 가치 는</target>
        </trans-unit>
        <trans-unit id="ac8a9c64fdd4a29692e13a9877d1bb2d850a96ef" translate="yes" xml:space="preserve">
          <source>The return value is considered to be found when the result is truthy (neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">반환 값은 결과가 진실 일 때 발견 된 것으로 간주됩니다 ( &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 가 아님).</target>
        </trans-unit>
        <trans-unit id="c789d5090be5fd4830e5650f8cf224329bb3d092" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; or any of the &lt;code&gt;handle_*&lt;/code&gt; callbacks may include a timeout value in milliseconds; if not, &lt;code&gt;:infinity&lt;/code&gt; is assumed. The timeout can be used to detect a lull in incoming messages.</source>
          <target state="translated">&lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 의 반환 값 또는 &lt;code&gt;handle_*&lt;/code&gt; 콜백 중 하나는 밀리 초 단위의 시간 초과 값을 포함 할 수 있습니다. 그렇지 않은 경우 &lt;code&gt;:infinity&lt;/code&gt; 가 가정됩니다. 시간 초과는 들어오는 메시지의 중단을 감지하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="637f2543c6c71a469bb5665295bb80f1c21c7816" translate="yes" xml:space="preserve">
          <source>The return value of this function is always &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 함수의 반환 값은 항상 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aee9968a076604f4bf8eb65e4e57dfeed366595f" translate="yes" xml:space="preserve">
          <source>The return value of this function is the value that was previously stored under &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; in case no value was stored under it.</source>
          <target state="translated">이 함수의 리턴 값은 이전에 &lt;code&gt;key&lt;/code&gt; 로 저장된 값 이거나, 값이 저장되지 않은 경우에는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8981b39a20d60bae9e3cc6f4a790fa30d54a0258" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; will have &lt;code&gt;UTC&lt;/code&gt; timezone, if you want other timezone, please use &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;UTC&lt;/code&gt; 시간대 가 있으며 다른 시간대를 원하면 &lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="30cb91bc5640b8dc4f60b9f7ca0aa50c81c4fc01" translate="yes" xml:space="preserve">
          <source>The returned datetime must be in UTC. The original &lt;code&gt;utc_offset&lt;/code&gt; it was written in must be returned in the result.</source>
          <target state="translated">반환 된 날짜 시간은 UTC 여야합니다. 기록 된 원래 &lt;code&gt;utc_offset&lt;/code&gt; 이 결과에 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="68256b5cc686943a73a48ce0ec84d14bdbd6db53" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">반환 된 함수는 일반적으로 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt; 및 친구에 대한 접근 자로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f600704ad2a1d265216e1874920599247dcd864b" translate="yes" xml:space="preserve">
          <source>The returned function is typically passed as an accessor to &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">반환 된 함수는 일반적으로 &lt;a href=&quot;kernel#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt; 및 friends에 대한 접근 자로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="feb14c2276580a5fb93fd8afe56dfe5ef725b402" translate="yes" xml:space="preserve">
          <source>The returned function raises if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 가 범위를 벗어나 면 반환 된 함수가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f18363f66f41ea776d213b7a358943fee2fbf810" translate="yes" xml:space="preserve">
          <source>The returned function receives a term and a command and injects the term into the collectable on every &lt;code&gt;{:cont, term}&lt;/code&gt; command.</source>
          <target state="translated">리턴 된 함수는 용어와 명령을 수신하고 모든 &lt;code&gt;{:cont, term}&lt;/code&gt; 명령 에서 수집 가능한 용어를 주입합니다 .</target>
        </trans-unit>
        <trans-unit id="03b6bd0a789c54c65fa616d4c3d05a787c9fac95" translate="yes" xml:space="preserve">
          <source>The returned function uses the default value if the key does not exist. This can be used to specify defaults and safely traverse missing keys:</source>
          <target state="translated">키가 존재하지 않으면 리턴 된 함수는 기본값을 사용합니다. 기본값을 지정하고 누락 된 키를 안전하게 트래버스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17eadcc2531c98be75b3d36e9d02f1db40badbf9" translate="yes" xml:space="preserve">
          <source>The returned information is a two-element tuple in the shape of &lt;code&gt;{info, value}&lt;/code&gt;.</source>
          <target state="translated">리턴 된 정보는 &lt;code&gt;{info, value}&lt;/code&gt; 모양의 두 요소 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="40619e10ae25c330063c65535cf867c78a0305e7" translate="yes" xml:space="preserve">
          <source>The returned keys (with the corresponding possible values) for all types of functions (local and external) are the following:</source>
          <target state="translated">모든 유형의 기능 (로컬 및 외부)에 대해 리턴되는 키 (해당 가능한 값이 있음)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ee75b4eeb81fcc96ebfd98173bc87ddff369546" translate="yes" xml:space="preserve">
          <source>The returned path will be expanded.</source>
          <target state="translated">반환 된 경로가 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="4d71c99a8e09f63bf55427e1e561d5818b8e3777" translate="yes" xml:space="preserve">
          <source>The returned reference will re-occur after approximately 2^82 calls; therefore it is unique enough for practical purposes.</source>
          <target state="translated">약 2 ^ 82 번의 호출 후 반환 된 참조가 다시 발생합니다. 따라서 실용적 목적으로 충분히 독특합니다.</target>
        </trans-unit>
        <trans-unit id="6710b3a068da95fe2b8593d7add9ec761b0835bc" translate="yes" xml:space="preserve">
          <source>The returned value is a map containing name-value pairs. Variable names and their values are strings.</source>
          <target state="translated">리턴 된 값은 이름-값 쌍을 포함하는 맵입니다. 변수 이름과 해당 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b373635bb9902337ad9e10b973bd7b4caeea100c" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;fun&lt;/code&gt; 에 의해 반환 된 &quot;get&quot;값이있는 튜플 이고 &lt;code&gt;key&lt;/code&gt; 아래에 업데이트 된 값이있는 새 키워드 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="b42137d3006c00e4b619eab71021a2f058571bc2" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;fun&lt;/code&gt; 에 의해 반환 된 &quot;get&quot;값이있는 튜플 이고 &lt;code&gt;key&lt;/code&gt; 아래에 업데이트 된 값이있는 새 맵입니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
