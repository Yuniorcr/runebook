<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="22c577ef1c31238772ee8831a83e168e224b3891" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO.inspect/2&lt;/code&gt; also provides the ability to decorate the output with a &lt;code&gt;label&lt;/code&gt; option. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IO.inspect/2&lt;/code&gt; 는 &lt;code&gt;label&lt;/code&gt; 옵션으로 출력을 꾸미는 기능도 제공합니다 . 검사 된 &lt;code&gt;item&lt;/code&gt; 전에 라벨이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab245843059173dbf82eb4fe6e1efb8953b384a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KVServer.Command.run/1&lt;/code&gt;&amp;rsquo;s implementation is sending commands directly to the server named &lt;code&gt;KV.Registry&lt;/code&gt;, which is registered by the &lt;code&gt;:kv&lt;/code&gt; application. This means this server is global and if we have two tests sending messages to it at the same time, our tests will conflict with each other (and likely fail). We need to decide between having unit tests that are isolated and can run asynchronously, or writing integration tests that work on top of the global state, but exercise our application&amp;rsquo;s full stack as it is meant to be exercised in production.</source>
          <target state="translated">&lt;code&gt;KVServer.Command.run/1&lt;/code&gt; 의 구현은 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션에 의해 등록 된 &lt;code&gt;KV.Registry&lt;/code&gt; 라는 서버로 직접 명령을 전송합니다 . 이는이 서버가 글로벌 서버임을 의미하며 동시에 두 개의 테스트 메시지를 보내는 테스트가 있으면 테스트가 서로 충돌하여 실패 할 수 있습니다. 격리되고 비동기 적으로 실행될 수있는 단위 테스트를 수행하거나 전역 상태에서 작동하는 통합 테스트를 작성해야할지 결정해야하지만 프로덕션 환경에서 응용 프로그램의 전체 스택을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="da6d4153744f3433ed1a5402789f34e812c03af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - 아카이브를 설치할 디렉토리를 지정합니다</target>
        </trans-unit>
        <trans-unit id="8c717830b04d23844afea6b838122a9bdf423ef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed (default: &lt;code&gt;~/.mix/archives&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed (default: &lt;code&gt;~/.mix/archives&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f2e7a10def5ff72cf9b8c6ec1feafc70b7396700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#build_path/0&quot;&gt;&lt;code&gt;Mix.Project.build_path/0&lt;/code&gt;&lt;/a&gt; config. This option must always point to a subdirectory inside a temporary directory. For instance, never &quot;/tmp&quot; or &quot;_build&quot; but &quot;_build/PROD&quot; or &quot;/tmp/PROD&quot;, as required by Mix</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#build_path/0&quot;&gt; &lt;code&gt;Mix.Project.build_path/0&lt;/code&gt; &lt;/a&gt; config. This option must always point to a subdirectory inside a temporary directory. For instance, never &quot;/tmp&quot; or &quot;_build&quot; but &quot;_build/PROD&quot; or &quot;/tmp/PROD&quot;, as required by Mix</target>
        </trans-unit>
        <trans-unit id="9e3878570d540f1dc8a3f3f892fd2b11f01cccaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project build_path config</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - 프로젝트 build_path 설정을 설정</target>
        </trans-unit>
        <trans-unit id="9a08f060f5be9937a437a588bee8fc6346fcb193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_ROOT&lt;/code&gt; - sets the root directory where build artifacts should be written to. For example, &quot;_build&quot;. If &lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; is set, this option is ignored.</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_ROOT&lt;/code&gt; - sets the root directory where build artifacts should be written to. For example, &quot;_build&quot;. If &lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; is set, this option is ignored.</target>
        </trans-unit>
        <trans-unit id="0140498ebd7646b788b6566801c7befbab061cb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEBUG&lt;/code&gt; - outputs debug information about each task before running it</source>
          <target state="translated">&lt;code&gt;MIX_DEBUG&lt;/code&gt; - 각 작업을 실행하기 전에 디버그 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="11512a24233fbaca58260cd8b783ef9bc74e70b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEPS_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#deps_path/0&quot;&gt;&lt;code&gt;Mix.Project.deps_path/0&lt;/code&gt;&lt;/a&gt; config (default: &lt;code&gt;deps&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_DEPS_PATH&lt;/code&gt; - sets the project &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Project.html#deps_path/0&quot;&gt; &lt;code&gt;Mix.Project.deps_path/0&lt;/code&gt; &lt;/a&gt; config (default: &lt;code&gt;deps&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="329ed8db0c467fa57966c2408385f46d68602c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ENV&lt;/code&gt; - specifies which environment should be used. See &lt;a href=&quot;#module-environments&quot;&gt;Environments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_ENV&lt;/code&gt; - 사용해야하는 환경을 지정합니다. &lt;a href=&quot;#module-environments&quot;&gt;환경&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="2d50621b63f1f2c2227991dd4eff2fd82684592f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_EXS&lt;/code&gt; - changes the full path to the &lt;code&gt;mix.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;MIX_EXS&lt;/code&gt; - &lt;code&gt;mix.exs&lt;/code&gt; 파일 의 전체 경로를 변경 합니다</target>
        </trans-unit>
        <trans-unit id="0c7e96e7109921de42973a61dead2b979ac90fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; -Mix의 홈 디렉토리 경로, Mix가 사용하는 구성 파일 및 스크립트 저장</target>
        </trans-unit>
        <trans-unit id="03ef2cea06987a0a92a52a0d0f29167ab7220a8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix (default: &lt;code&gt;~/.mix&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix (default: &lt;code&gt;~/.mix&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="553587fa68acdae7dd360d62677c233b8de4b6a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_PATH&lt;/code&gt; - appends extra code paths</source>
          <target state="translated">&lt;code&gt;MIX_PATH&lt;/code&gt; - 추가 코드 경로 추가</target>
        </trans-unit>
        <trans-unit id="e5e1141c719d2a85373ac124af8fe76e6cceea81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_QUIET&lt;/code&gt; - does not print information messages to the terminal</source>
          <target state="translated">&lt;code&gt;MIX_QUIET&lt;/code&gt; - 터미널에 정보 메시지를 인쇄하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7254592f8891c8c6dd40bd7299fc6ec41c04871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; - 믹스 설치를 재정의하는 rebar3 명령의 경로</target>
        </trans-unit>
        <trans-unit id="e09832a96f2b1d018a61ea57e9189d15094a9f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar3&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar3&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="06ea93f78b26d8cfb7ce48134404d1f745e0f50b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; - 믹스 설치를 재정의하는 철근 명령 경로</target>
        </trans-unit>
        <trans-unit id="b266a14c80d9857d2f0f79371c5122b2ebde45ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs (default: &lt;code&gt;~/.mix/rebar&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9971767c5036a2608426896f053fa0cf39812d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_TARGET&lt;/code&gt; - specifies which target should be used. See &lt;a href=&quot;#module-targets&quot;&gt;Targets&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_TARGET&lt;/code&gt; - 사용해야하는 대상을 지정합니다. &lt;a href=&quot;#module-targets&quot;&gt;대상&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="73dafaead44cb117058f87e670829a36ef8f794b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_XDG&lt;/code&gt; - asks Mix to follow the &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Directory Specification&lt;/a&gt; for its home directory and configuration files. This behaviour needs to be opt-in due to backwards compatibility. &lt;code&gt;MIX_HOME&lt;/code&gt; has higher preference than &lt;code&gt;MIX_XDG&lt;/code&gt;. If none of the variables are set, the default directory &lt;code&gt;~/.mix&lt;/code&gt; will be used</source>
          <target state="translated">&lt;code&gt;MIX_XDG&lt;/code&gt; - asks Mix to follow the &lt;a href=&quot;https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html&quot;&gt;XDG Directory Specification&lt;/a&gt; for its home directory and configuration files. This behaviour needs to be opt-in due to backwards compatibility. &lt;code&gt;MIX_HOME&lt;/code&gt; has higher preference than &lt;code&gt;MIX_XDG&lt;/code&gt; . If none of the variables are set, the default directory &lt;code&gt;~/.mix&lt;/code&gt; will be used</target>
        </trans-unit>
        <trans-unit id="3d25413013d7642f8cf841919f8270de1f43ed5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Macro.expand_once/2&lt;/code&gt; receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about &lt;code&gt;__ENV__&lt;/code&gt; later in this chapter).</source>
          <target state="translated">&lt;code&gt;Macro.expand_once/2&lt;/code&gt; 는 인용 된 표현식을 수신하여 현재 환경에 따라 확장합니다. 이 경우 &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; 매크로를 확장 / 호출 하고 결과를 반환했습니다. 그런 다음 반환 된 인용 식을 문자열로 변환하고 인쇄합니다 ( 이 장의 뒷부분 에 &lt;code&gt;__ENV__&lt;/code&gt; 에 대해 이야기하겠습니다 ).</target>
        </trans-unit>
        <trans-unit id="f7cf5a4a08fc0443742331ca9c19953329372043" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Makefile.win&lt;/code&gt;- invokes &lt;code&gt;nmake /F Makefile.win&lt;/code&gt; (only on Windows)</source>
          <target state="translated">&lt;code&gt;Makefile.win&lt;/code&gt; - invokes &lt;code&gt;nmake /F Makefile.win&lt;/code&gt; (only on Windows)</target>
        </trans-unit>
        <trans-unit id="5089530935a333b39d0f09b9dc40db65ec63d8f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Makefile&lt;/code&gt; - invokes &lt;code&gt;gmake&lt;/code&gt; on DragonFlyBSD, FreeBSD, NetBSD, and OpenBSD, invokes &lt;code&gt;make&lt;/code&gt; on any other operating system (except on Windows)</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; - invokes &lt;code&gt;gmake&lt;/code&gt; on DragonFlyBSD, FreeBSD, NetBSD, and OpenBSD, invokes &lt;code&gt;make&lt;/code&gt; on any other operating system (except on Windows)</target>
        </trans-unit>
        <trans-unit id="00b1d41a5db3e2d02233a9ec6cf644eff865bef1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mix.Task.run(&quot;compile&quot;, args)&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;Mix.Task.run(&quot;compile&quot;, args)&lt;/code&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="0f0e096f8f78d8ae18f78e22ad67df03c1d9cd33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_BOOT_SCRIPT&lt;/code&gt; - the name of the boot script to use when starting the release. This script is used when running commands such as &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;daemon&lt;/code&gt;. The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot&lt;/code&gt;. Defaults to &lt;code&gt;start&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_BOOT_SCRIPT&lt;/code&gt; - the name of the boot script to use when starting the release. This script is used when running commands such as &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;daemon&lt;/code&gt; . The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT.boot&lt;/code&gt; . Defaults to &lt;code&gt;start&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8d200a48258e76cb9c3dfbc4c5509d26e83cf9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_BOOT_SCRIPT_CLEAN&lt;/code&gt; - the name of the boot script used when starting the release clean, without your application or its dependencies. This script is used by commands such as &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;rpc&lt;/code&gt;, and &lt;code&gt;remote&lt;/code&gt;. The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot&lt;/code&gt;. Defaults to &lt;code&gt;start_clean&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_BOOT_SCRIPT_CLEAN&lt;/code&gt; - the name of the boot script used when starting the release clean, without your application or its dependencies. This script is used by commands such as &lt;code&gt;eval&lt;/code&gt; , &lt;code&gt;rpc&lt;/code&gt; , and &lt;code&gt;remote&lt;/code&gt; . The boot script is expected to be located at the path &lt;code&gt;releases/RELEASE_VSN/RELEASE_BOOT_SCRIPT_CLEAN.boot&lt;/code&gt; . Defaults to &lt;code&gt;start_clean&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b347c1865aeb917d5f8064ddb6bb310c8775c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_COMMAND&lt;/code&gt; - the command given to the release, such as &lt;code&gt;&quot;start&quot;&lt;/code&gt;, &lt;code&gt;&quot;remote&quot;&lt;/code&gt;, &lt;code&gt;&quot;eval&quot;&lt;/code&gt;, and so on. This is typically accessed inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to set different environment variables under different conditions. Note, however, that &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; has not been validated by the time &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; are called, so it may be empty or contain invalid values. This variable is always computed and it cannot be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_COMMAND&lt;/code&gt; - the command given to the release, such as &lt;code&gt;&quot;start&quot;&lt;/code&gt; , &lt;code&gt;&quot;remote&quot;&lt;/code&gt; , &lt;code&gt;&quot;eval&quot;&lt;/code&gt; , and so on. This is typically accessed inside &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to set different environment variables under different conditions. Note, however, that &lt;code&gt;RELEASE_COMMAND&lt;/code&gt; has not been validated by the time &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; are called, so it may be empty or contain invalid values. This variable is always computed and it cannot be set to a custom value</target>
        </trans-unit>
        <trans-unit id="5db5d9d226dd57b61c3de56bafcb76a6e683a137" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_COOKIE&lt;/code&gt; - the release cookie. By default uses the value in &lt;code&gt;releases/COOKIE&lt;/code&gt;. It can be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_COOKIE&lt;/code&gt; - the release cookie. By default uses the value in &lt;code&gt;releases/COOKIE&lt;/code&gt; . It can be set to a custom value</target>
        </trans-unit>
        <trans-unit id="11092c988bfb9b026d3556a8be28d644e61b02b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; - how do we want to run the distribution. May be &lt;code&gt;name&lt;/code&gt; (long names), &lt;code&gt;sname&lt;/code&gt; (short names) or &lt;code&gt;none&lt;/code&gt; (distribution is not started automatically). Defaults to &lt;code&gt;sname&lt;/code&gt; which allows access only within the current system. &lt;code&gt;name&lt;/code&gt; allows external connections. If &lt;code&gt;name&lt;/code&gt; is used and you are not running on Erlang/OTP 22 or later, you must set &lt;code&gt;RELEASE_NODE&lt;/code&gt; to &lt;code&gt;RELEASE_NAME@127.0.0.1&lt;/code&gt; with an IP or a known host</source>
          <target state="translated">&lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; - how do we want to run the distribution. May be &lt;code&gt;name&lt;/code&gt; (long names), &lt;code&gt;sname&lt;/code&gt; (short names) or &lt;code&gt;none&lt;/code&gt; (distribution is not started automatically). Defaults to &lt;code&gt;sname&lt;/code&gt; which allows access only within the current system. &lt;code&gt;name&lt;/code&gt; allows external connections. If &lt;code&gt;name&lt;/code&gt; is used and you are not running on Erlang/OTP 22 or later, you must set &lt;code&gt;RELEASE_NODE&lt;/code&gt; to &lt;code&gt;RELEASE_NAME@127.0.0.1&lt;/code&gt; with an IP or a known host</target>
        </trans-unit>
        <trans-unit id="1c0fdca101ddcd4c15181c8e5aef8f9de51f1808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_MODE&lt;/code&gt; - if the release should start in embedded or interactive mode. Defaults to &quot;embedded&quot;. It applies only to start/daemon/install commands</source>
          <target state="translated">&lt;code&gt;RELEASE_MODE&lt;/code&gt; - if the release should start in embedded or interactive mode. Defaults to &quot;embedded&quot;. It applies only to start/daemon/install commands</target>
        </trans-unit>
        <trans-unit id="f7ccd36485374c0118fd8558abe9f6a5ba88f205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_NAME&lt;/code&gt; - the name of the release. It can be set to a custom value when invoking the release</source>
          <target state="translated">&lt;code&gt;RELEASE_NAME&lt;/code&gt; - the name of the release. It can be set to a custom value when invoking the release</target>
        </trans-unit>
        <trans-unit id="2f70cb906cf189a8668c80a9a5ba13a29c35617f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_NODE&lt;/code&gt; - the release node name, in the format &lt;code&gt;name@host&lt;/code&gt;. It can be set to a custom value. The name part must be made only of letters, digits, underscores, and hyphens</source>
          <target state="translated">&lt;code&gt;RELEASE_NODE&lt;/code&gt; - the release node name, in the format &lt;code&gt;name@host&lt;/code&gt; . It can be set to a custom value. The name part must be made only of letters, digits, underscores, and hyphens</target>
        </trans-unit>
        <trans-unit id="f06d11834d6cb4ca20dd2e4206b76cc64d991608" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_ROOT&lt;/code&gt; - points to the root of the release. If the system includes ERTS, then it is the same as &lt;a href=&quot;http://www.erlang.org/doc/man/code.html#root_dir-0&quot;&gt;&lt;code&gt;:code.root_dir/0&lt;/code&gt;&lt;/a&gt;. This variable is always computed and it cannot be set to a custom value</source>
          <target state="translated">&lt;code&gt;RELEASE_ROOT&lt;/code&gt; - points to the root of the release. If the system includes ERTS, then it is the same as &lt;a href=&quot;http://www.erlang.org/doc/man/code.html#root_dir-0&quot;&gt; &lt;code&gt;:code.root_dir/0&lt;/code&gt; &lt;/a&gt;. This variable is always computed and it cannot be set to a custom value</target>
        </trans-unit>
        <trans-unit id="1388a58ae031e8df945df5b3a7bfe0e70c9fd9a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_SYS_CONFIG&lt;/code&gt; - the location of the sys.config file. It can be set to a custom path and it must not include the &lt;code&gt;.config&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;RELEASE_SYS_CONFIG&lt;/code&gt; - the location of the sys.config file. It can be set to a custom path and it must not include the &lt;code&gt;.config&lt;/code&gt; extension</target>
        </trans-unit>
        <trans-unit id="4abf1af7d08e33f076797e5d00e9b7760c2e2b5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_TMP&lt;/code&gt; - the directory in the release to write temporary files to. It can be set to a custom directory. It defaults to &lt;code&gt;$RELEASE_ROOT/tmp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;RELEASE_TMP&lt;/code&gt; - the directory in the release to write temporary files to. It can be set to a custom directory. It defaults to &lt;code&gt;$RELEASE_ROOT/tmp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57a28a1108df7bec7cd0a4fb296132129fff4ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_VM_ARGS&lt;/code&gt; - the location of the vm.args file. It can be set to a custom path</source>
          <target state="translated">&lt;code&gt;RELEASE_VM_ARGS&lt;/code&gt; - the location of the vm.args file. It can be set to a custom path</target>
        </trans-unit>
        <trans-unit id="a11c1bc1765c0750c7c0007612319bfe2c0845eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RELEASE_VSN&lt;/code&gt; - the version of the release, otherwise the latest version is used. It can be set to a custom value when invoking the release. The custom value must be an existing release version in the &lt;code&gt;releases/&lt;/code&gt; directory</source>
          <target state="translated">&lt;code&gt;RELEASE_VSN&lt;/code&gt; - the version of the release, otherwise the latest version is used. It can be set to a custom value when invoking the release. The custom value must be an existing release version in the &lt;code&gt;releases/&lt;/code&gt; directory</target>
        </trans-unit>
        <trans-unit id="3fc6929a951f92925b08e51e26456aa3d1b43853" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="025d0341292dc3a3ec173d8548f02f17ffdfc36c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.length/1&lt;/code&gt; counts graphemes, but &lt;code&gt;byte_size/1&lt;/code&gt; reveals the number of underlying raw bytes needed to store the string when using UTF-8 encoding. UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, and &lt;code&gt;o&lt;/code&gt;, but two bytes to represent &lt;code&gt;ł&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String.length/1&lt;/code&gt; counts graphemes, but &lt;code&gt;byte_size/1&lt;/code&gt; reveals the number of underlying raw bytes needed to store the string when using UTF-8 encoding. UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , and &lt;code&gt;o&lt;/code&gt; , but two bytes to represent &lt;code&gt;ł&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c79ae2e0183612283b4bdd763f31738afe6b32e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.ljust/3&lt;/code&gt; and &lt;code&gt;String.rjust/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.ljust/3&lt;/code&gt; 및 &lt;code&gt;String.rjust/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6971e188b1f5ca6887f36a1aabb3d9f4803817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/1&lt;/code&gt; and &lt;code&gt;String.rstrip/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/1&lt;/code&gt; 및 &lt;code&gt;String.rstrip/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4f8fac69d745e565219ca9c212f205a839b4d94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/2&lt;/code&gt; and &lt;code&gt;String.rstrip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/2&lt;/code&gt; 및 &lt;code&gt;String.rstrip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dba6d3f4606546ef740ff6427a2da28113bd080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.strip/1&lt;/code&gt; and &lt;code&gt;String.strip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.strip/1&lt;/code&gt; 및 &lt;code&gt;String.strip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd32067781123d89c1ac8e4f997b876beb9c3863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; is capable of building a child specification from a given module and/or tuple, and it also accepts values that override the underlying child specification. Now we have an always running acceptor that starts temporary task processes under an always running task supervisor.</source>
          <target state="translated">&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 는 주어진 모듈 및 / 또는 튜플에서 하위 사양을 작성할 수 있으며 기본 하위 사양을 재정의하는 값도 허용합니다. 이제 항상 실행중인 작업 관리자에서 임시 작업 프로세스를 시작하는 항상 실행중인 수락자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad77d229f6cbfcafcb4f7741c0dc27b0f4b740b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="088aa7cd9bf1e6a8427fd52deb0693f6c10b18ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[char1,char2,...]&lt;/code&gt; - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;[char1,char2,...]&lt;/code&gt; -나열된 문자와 일치합니다. 하이픈으로 구분 된 두 문자는 문자 범위와 일치합니다. 공백 문자 자체를 포함하는 경로와 일치하므로 쉼표 앞뒤에 공백을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="716d641385133215b3dad8b4209c815a375959a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[xref: [exclude: ...]]&lt;/code&gt; - a list of &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;{module, function, arity}&lt;/code&gt; that should not be warned on in case on undefined modules or undefined application warnings.</source>
          <target state="translated">&lt;code&gt;[xref: [exclude: ...]]&lt;/code&gt; - a list of &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;{module, function, arity}&lt;/code&gt; that should not be warned on in case on undefined modules or undefined application warnings.</target>
        </trans-unit>
        <trans-unit id="7678d3e63037186910d7f0ae81525b64485520eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\#&lt;/code&gt; - Returns the &lt;code&gt;#&lt;/code&gt; character itself, skipping interpolation</source>
          <target state="translated">&lt;code&gt;\#&lt;/code&gt; - Returns the &lt;code&gt;#&lt;/code&gt; character itself, skipping interpolation</target>
        </trans-unit>
        <trans-unit id="39c640871ce2526ab4fa5310ef6480273c950ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\0&lt;/code&gt; - null byte</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 널 바이트</target>
        </trans-unit>
        <trans-unit id="65ed13dac56222bcbf8e3e216b956a7a2244b177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; &amp;ndash; single backslash</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; &amp;ndash; 단일 백 슬래시</target>
        </trans-unit>
        <trans-unit id="47357c3d9a815c299db4cc36a5a19e15cd4a88d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; - see &lt;a href=&quot;kernel#def/2-default-arguments&quot;&gt;Default arguments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; - see &lt;a href=&quot;kernel#def/2-default-arguments&quot;&gt;Default arguments&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b174b497cb3a1cc6880a9950599e3a0b77cab5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; is used to specify a default value for a parameter of a function. For example:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 는 함수의 매개 변수에 대한 기본값을 지정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f9d9ffe5a9bac743656529800fff03c95336241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; &amp;ndash; bell/alert</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; &amp;ndash; 종 / 경고</target>
        </trans-unit>
        <trans-unit id="45753357243d44add04b0d403bcb727bf01ac640" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; - Bell</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; - Bell</target>
        </trans-unit>
        <trans-unit id="14886ebc85cca038dec60a61c0e91b8b4ead61c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; &amp;ndash; backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; &amp;ndash; 백 스페이스</target>
        </trans-unit>
        <trans-unit id="e2b21a168427d47ef491a0b46394abff13b4ace1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; - Backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; - Backspace</target>
        </trans-unit>
        <trans-unit id="0bb4d977ed1327929c1a92021eb0613308fd0ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; - delete</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 삭제</target>
        </trans-unit>
        <trans-unit id="f1fa4a2a5b80412cbf38d35040e73ca767510a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - Command Escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; - Command Escape</target>
        </trans-unit>
        <trans-unit id="ccb79b2d6e647a0cac1fd9c56eabf463190b35ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 탈출</target>
        </trans-unit>
        <trans-unit id="55299eb9827bdc0cdce7357d89c2a61fb6cf5a99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - Form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; - Form feed</target>
        </trans-unit>
        <trans-unit id="7df87f44b5903cdd4ae86383ef920d5afcb83fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; 양식 피드</target>
        </trans-unit>
        <trans-unit id="74c29c02b88f493e0b8a40781b5dd5c63d7f01bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; &amp;ndash; newline</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; &amp;ndash; 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="035d222408ecfdbe03e1c6f467bf7b85f3d09276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; - Line feed (New lines)</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; - Line feed (New lines)</target>
        </trans-unit>
        <trans-unit id="f63d66cab57190093b88defb77e6fab011870475" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; &amp;ndash; carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; &amp;ndash; 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="16a3f8f6e455b31b406751d768b8997d3b0141f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; - Carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; - Carriage return</target>
        </trans-unit>
        <trans-unit id="0a1c5bdfb07d4e036fe4810e5550d502e2f30408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; &amp;ndash; space</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; &amp;ndash; 공간</target>
        </trans-unit>
        <trans-unit id="547d5d52bd4fa577be6f348f6604137b954496a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; &amp;ndash; tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; &amp;ndash; 탭</target>
        </trans-unit>
        <trans-unit id="ac9f3e83b566f79b509b507babdbaf1e3039b623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; - Horizontal tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; - Horizontal tab</target>
        </trans-unit>
        <trans-unit id="736c96e8078aabb67ae94f12f2958e5765eb382c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uDDDD&lt;/code&gt; and &lt;code&gt;\u{D...}&lt;/code&gt; - represents a Unicode codepoint in hexadecimal (such as &lt;code&gt;\u{1F600}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\uDDDD&lt;/code&gt; 및 &lt;code&gt;\u{D...}&lt;/code&gt; -16 진수로 된 유니 코드 코드 포인트를 나타냅니다 (예 : &lt;code&gt;\u{1F600}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f59792bb819b89eb12383151ec5c270c793db45e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uNNNN&lt;/code&gt; - A Unicode code point represented by &lt;code&gt;NNNN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\uNNNN&lt;/code&gt; - A Unicode code point represented by &lt;code&gt;NNNN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46eb12f311d0fe7aa10c40fac2213a97f6692013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uXXXX&lt;/code&gt; or &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</source>
          <target state="translated">&lt;code&gt;\uXXXX&lt;/code&gt; 또는 &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</target>
        </trans-unit>
        <trans-unit id="c0b1167bef21cda9a624d04841f631aeb54af646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; &amp;ndash; vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; &amp;ndash; 세로 탭</target>
        </trans-unit>
        <trans-unit id="baae21e52c1a4d911ab0b0815dbbb669da87f8c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; - Vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; - Vertical tab</target>
        </trans-unit>
        <trans-unit id="38a8f23f2eb09ba8af053d2c20b167de36d6466a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xDD&lt;/code&gt; - represents a single byte in hexadecimal (such as &lt;code&gt;\x13&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\xDD&lt;/code&gt; -16 진수로 단일 바이트를 나타냅니다 (예 : &lt;code&gt;\x13&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0119ce503ea17ff365f93ebcad5ab105e0246f64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xNN&lt;/code&gt; - A byte represented by the hexadecimal &lt;code&gt;NN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;\xNN&lt;/code&gt; - A byte represented by the hexadecimal &lt;code&gt;NN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3210dc14496231e2d2fc4514864f15323c30fdbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{X*}&lt;/code&gt; inside strings/sigils/charlists</source>
          <target state="translated">&lt;code&gt;\x{X*}&lt;/code&gt; 문자열 / sigils / charlists 내부의 \ x {X *}</target>
        </trans-unit>
        <trans-unit id="12de2ac6c25aa71b2904637230b82ed326e8ae16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_&lt;/code&gt;: pad with spaces</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; : pad with spaces</target>
        </trans-unit>
        <trans-unit id="3cde9d9e85c4c0b53108719f116e97eb679ac877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ENV__&lt;/code&gt; returns an instance of the &lt;code&gt;Macro.Env&lt;/code&gt; struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires and so on:</source>
          <target state="translated">&lt;code&gt;__ENV__&lt;/code&gt; 는 현재 모듈, 파일 및 줄, 현재 범위에 정의 된 모든 변수 및 가져 오기 등의 컴파일 환경에 대한 유용한 정보가 포함 된 &lt;code&gt;Macro.Env&lt;/code&gt; 구조체 의 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd76053a130e15c6a7e3c3653c524a8cead2f8f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__STACKTRACE__&lt;/code&gt; in &lt;code&gt;try/catch/rescue&lt;/code&gt; (v1.7)</source>
          <target state="translated">&lt;code&gt;__STACKTRACE__&lt;/code&gt; in &lt;code&gt;try/catch/rescue&lt;/code&gt; (v1.7)</target>
        </trans-unit>
        <trans-unit id="e61733caa542452527b202971f1b67c6052df9a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__protocol__/1&lt;/code&gt; - returns the protocol information. The function takes one of the following atoms:</source>
          <target state="translated">&lt;code&gt;__protocol__/1&lt;/code&gt; 프로토콜 정보를 반환합니다. 이 함수는 다음 원자 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f30c6faee12c1a5a12b4701c1489caf0490de93e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt; , see the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; for more information) into the caller.</target>
        </trans-unit>
        <trans-unit id="ead78218949f957d38127d6c0b9181cecc79bdc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 은 일반적으로 호출자 에게 상태 (모듈 속성을 통해) 또는 콜백 ( &lt;code&gt;@before_compile&lt;/code&gt; 과 같은 자세한 내용 은 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; 설명서 참조 )을 설정해야 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="18fec841d33b1eed5707722ba145fa8e46469457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; may also be used to alias, require, or import functionality from different modules:</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 사용하여 다른 모듈에서 기능을 별칭으로 지정하거나 요구하거나 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5888cfe9b0257d8c48e3413d54a04e07ef4f2f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;: words in the list are atoms</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; : 목록의 단어는 원자입니다</target>
        </trans-unit>
        <trans-unit id="5dd0df57ca13d192483ae4afa8ee7dcd66ac716e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt;; the current system access to the file.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt; ; 파일에 대한 현재 시스템 액세스</target>
        </trans-unit>
        <trans-unit id="5bf576af207250aae2f10f4b1a3367c771a70828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="561d785f096648699e854e9a94018cf81a312387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3d214af6b3554314446ba0e18e374c3577cbda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; 은 반복이 수행 될 때 호출되며 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 또는 &lt;code&gt;{:cont, acc}&lt;/code&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b02de91b9af39aa2a7c9496b9788f7c36c0544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias&lt;/code&gt; allows you to set up aliases for any given module name.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 를 사용하면 지정된 모듈 이름에 대한 별칭을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c880b6a07ca827b5812f7f974a1fcacab19aaf4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aliases&lt;/code&gt; - a list of two-element tuples, where the first element is the aliased name and the second one the actual name</source>
          <target state="translated">&lt;code&gt;aliases&lt;/code&gt; - 두 요소 튜플의 목록. 첫 번째 요소는 별명 이며 두 번째 요소는 실제 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d4e8eef689e82c072f90c3d43dbd352d218bf09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anchored&lt;/code&gt; - not available, use &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;\A&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;anchored&lt;/code&gt; -사용할 수 없음, 대신 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;\A&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="69d2286a504a92480fa7093d21b1d829c664c953" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</target>
        </trans-unit>
        <trans-unit id="4458fc9a4b25b25b5a15d3aebebe9b878cfddf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 는 사양 의 &lt;code&gt;:start&lt;/code&gt; 필드 에서 &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; 에 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d15eca1e275872ac68dbab33a4fcdc7d4900f368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 는 부울이어야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c766db9327568eebb91c2c7ede208193b9693614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; is a list of the remaining arguments in &lt;code&gt;argv&lt;/code&gt; as strings</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;argv&lt;/code&gt; 의 나머지 인수 목록을 문자열로 나타낸 것입니다</target>
        </trans-unit>
        <trans-unit id="67b55e613b38ca10448abedd47d027b2fda5747b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must be a list of binaries which the executable will receive as its arguments as is. This means that:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 실행 파일이 그대로 인수로받을 바이너리 목록이어야합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="783fe4760ba15ae07c09e338cd73681f91718b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6116c0e3ccd4227ebffa3336ec78198214587e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 에서 false 이고 / 2 가 &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="822629b7db721ef2933cb934e45149d4a945780c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;enum#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; 주어진 부울 값으로 취급된다는 것을 사용자에게 알리기 위해 존재 &lt;code&gt;nil&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; 로 평가 될 것이다 &lt;code&gt;false&lt;/code&gt; 그 밖의 모든 것이 &lt;code&gt;true&lt;/code&gt; . 예를 들어 &lt;a href=&quot;enum#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt; 는 다음 사양을 갖습니다. &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ca5e1feb985abd11ae694ad71b883d67b520062" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt; . For example, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d720388f308d192f8429307f6fcab52f0e1f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 는 기본 표현을 검사하고 실패가있을 때마다 좋은보고 기능을 제공합니다. 예를 들어, 표현식이 비교 연산자를 사용하는 경우 메시지에 양면 값이 표시됩니다. 주장</target>
        </trans-unit>
        <trans-unit id="b8c959da5563d8804e6c5ab088f8ce78ed2be376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; provides a very simple mechanism to compute values concurrently. Not only that, &lt;code&gt;async/await&lt;/code&gt; can also be used with the same &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; we have used in previous chapters. We just need to call &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; instead of &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; and use &lt;code&gt;Task.await/2&lt;/code&gt; to read the result later on.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 는 값을 동시에 계산하는 매우 간단한 메커니즘을 제공합니다. 뿐만 아니라 &lt;code&gt;async/await&lt;/code&gt; 는 이전 장에서 사용한 것과 동일한 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수도 있습니다 . 우리는 호출 할 필요가 &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 대신 &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; 및 사용 &lt;code&gt;Task.await/2&lt;/code&gt; 를 나중에 결과를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbc2fd902dcfa9a0d5b3b03629aa9a39e8105cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atime&lt;/code&gt; - the last time the file was read.</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; - 파일을 마지막으로 읽은 시간</target>
        </trans-unit>
        <trans-unit id="a1bc563adc7ed0327db5ff505175d84400d984ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_nodes&lt;/code&gt; - is a list of nodes that either did not exist or where a server with the given &lt;code&gt;name&lt;/code&gt; did not exist or did not reply</source>
          <target state="translated">&lt;code&gt;bad_nodes&lt;/code&gt; - 존재하지 않거나 주어진 &lt;code&gt;name&lt;/code&gt; 의 서버가 존재하지 않거나 응답하지 않은 노드의 목록입니다</target>
        </trans-unit>
        <trans-unit id="b0f9d352deff5e6bef483d40252e8c579ec823db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; can be an integer between 2 and 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 는 2와 36 사이의 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fd140ab9c10a0cfc1c2df9c9a53282f52de13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;big&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="24aeeb91a66e25c695a35aa48b22c0e94d817f06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; commands</source>
          <target state="translated">&lt;code&gt;bin/RELEASE_NAME&lt;/code&gt; commands</target>
        </trans-unit>
        <trans-unit id="683140005c82637887b9603468709538ca7e8c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo daemon&lt;/code&gt; and &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; - to start the system as a daemon on Unix-like systems</source>
          <target state="translated">&lt;code&gt;bin/foo daemon&lt;/code&gt; 및 &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; -Unix 계열 시스템에서 시스템을 데몬으로 시작</target>
        </trans-unit>
        <trans-unit id="decd6a4e6f8eff7dd632caccc3c36fce1d0d44bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - to start a fresh system that runs a single command and then shuts down</source>
          <target state="translated">&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - 단일 명령을 실행 한 다음 종료되는 새로운 시스템을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="432eeca34ed295a1f1ff0e49167671eefec3e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo install&lt;/code&gt; - to install the system as a service on Windows machines</source>
          <target state="translated">&lt;code&gt;bin/foo install&lt;/code&gt; -Windows 시스템에서 시스템을 서비스로 설치</target>
        </trans-unit>
        <trans-unit id="8eb1dbc6df6a7ebd68488f9c558335906ced9632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; and &lt;code&gt;bin/foo remote&lt;/code&gt; - for running commands on the running system or to connect to the running system</source>
          <target state="translated">&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; 및 &lt;code&gt;bin/foo remote&lt;/code&gt; - 또는 실행중인 시스템에서 명령을 실행은 실행중인 시스템에 연결</target>
        </trans-unit>
        <trans-unit id="61afcc7c9d27662591ec64aeb53fbe50494c9c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo start&lt;/code&gt;, &lt;code&gt;bin/foo start_iex&lt;/code&gt;, &lt;code&gt;bin/foo restart&lt;/code&gt;, and &lt;code&gt;bin/foo stop&lt;/code&gt; - for general management of the release</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; , &lt;code&gt;bin/foo start_iex&lt;/code&gt; , &lt;code&gt;bin/foo restart&lt;/code&gt; 및 &lt;code&gt;bin/foo stop&lt;/code&gt; stop- 릴리스의 일반 관리</target>
        </trans-unit>
        <trans-unit id="0ca6cada709e43a4d29a38bd7db90e5e5fdce17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/my_app start&lt;/code&gt; will start the system connected to the current standard input/output, where logs are also written to by default. This is the preferred way to run the system. Many tools, such as &lt;code&gt;systemd&lt;/code&gt;, platforms as a service, such as Heroku, and many containers platforms, such as Docker, are capable of processing the standard input/output and redirecting the log contents elsewhere. Those tools and platforms also take care of restarting the system in case it crashes.</source>
          <target state="translated">&lt;code&gt;bin/my_app start&lt;/code&gt; will start the system connected to the current standard input/output, where logs are also written to by default. This is the preferred way to run the system. Many tools, such as &lt;code&gt;systemd&lt;/code&gt; , platforms as a service, such as Heroku, and many containers platforms, such as Docker, are capable of processing the standard input/output and redirecting the log contents elsewhere. Those tools and platforms also take care of restarting the system in case it crashes.</target>
        </trans-unit>
        <trans-unit id="1d72332764c11e123f7347708663156c1233e11a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a keyword list with the value of all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 을 평가 한 후 모든 변수 바인딩 값이있는 키워드 목록입니다 . 바인딩 키는 일반적으로 원자이지만 다른 컨텍스트에서 정의 된 변수의 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e7fbcaa11b87d5daded74fc37531decf595f1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a list with all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; is a list with all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt; . The binding keys are usually atoms, but they may be a tuple for variables defined in a different context.</target>
        </trans-unit>
        <trans-unit id="1c823d3a888334fa369393bafb696100163d27f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bits&lt;/code&gt; (alias for &lt;code&gt;bitstring&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bits&lt;/code&gt; (별칭 &lt;code&gt;bitstring&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="15d4a43121fe32de8967a969e91d058bcf17a84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes&lt;/code&gt; (alias for &lt;code&gt;binary&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; ( &lt;code&gt;binary&lt;/code&gt; 별명 )</target>
        </trans-unit>
        <trans-unit id="834919dffb47cc92a7a48cd0b0701a70f30f53b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: words in the list are charlists</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; : 목록의 단어는 문자 목록입니다</target>
        </trans-unit>
        <trans-unit id="b2ccd200c0a8ea5eab26b2092f3c2628e13ebdda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f8c3b2d3da64ab6cc3b0a518b860cadf593c568e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; is a function that receives no arguments and runs in a separate process than the caller.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 은 인수를받지 않고 호출자와 다른 프로세스에서 실행되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="95b68f4cda4012cbd6bf09e1c90d22f081c35df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; allows us to compare a value against many patterns until we find a matching one:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 를 사용하면 일치하는 패턴을 찾을 때까지 여러 패턴과 값을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e836bef50ccfd75e73db047504ecafbbd45966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; is useful when you need to match against different values. However, in many circumstances, we want to check different conditions and find the first one that does not evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. In such cases, one may use &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 는 다른 값과 일치해야 할 때 유용합니다. 그러나 많은 상황에서 우리는 다른 조건을 확인하고 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 평가되지 않는 첫 번째 조건을 찾고 싶습니다 . 이러한 경우 &lt;code&gt;cond&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93db9ef7d76055eccf64ca125a1bd08e2afa0ce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caseless&lt;/code&gt; (i) - adds case insensitivity</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; (i)-대소 문자를 구분하지 않습니다</target>
        </trans-unit>
        <trans-unit id="111682203e5e59ead60bf73cdbc6a0fd477ad42b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="81988c264165854eebe013b354206a9d80761cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;kernel#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 는 &lt;a href=&quot;kernel#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; 에&lt;/a&gt; 의해 던져진 값을 잡는데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cb7c5d439fab5f4770d5cbbe8aa9adfa7fda6776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="db91933fecb8b9776531516395537a60984fe8c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changed&lt;/code&gt; is a keyword list of keys and their changed values in the application environment. &lt;code&gt;new&lt;/code&gt; is a keyword list with all new keys and their values. &lt;code&gt;removed&lt;/code&gt; is a list with all removed keys.</source>
          <target state="translated">&lt;code&gt;changed&lt;/code&gt; 는 응용 프로그램 환경에서 키워드의 키 목록 및 변경된 값입니다. &lt;code&gt;new&lt;/code&gt; 는 모든 새 키와 해당 값이 포함 된 키워드 목록입니다. &lt;code&gt;removed&lt;/code&gt; 는 모든 제거 된 키가있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="60538f44591b66b504b274f4df6fe77688be99e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_list/0&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;char_list/0&lt;/code&gt; 타입</target>
        </trans-unit>
        <trans-unit id="343cfd2a019aa43de8f9ab53908dba3ccb94d728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process or the atom &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; - 해당 자식 프로세스 또는 원자의 PID &lt;code&gt;:restarting&lt;/code&gt; 프로세스가 다시 시작하는 것입니다 경우</target>
        </trans-unit>
        <trans-unit id="8b19e01788ee36713a234b5a35b8998444e68a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process, &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted, or &lt;code&gt;:undefined&lt;/code&gt; if there is no such process</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; - 해당하는 자식 프로세스의 PID, &lt;code&gt;:restarting&lt;/code&gt; 프로세스를 다시 시작 하려고하면 다시 시작, 또는 프로세스가없는 경우 &lt;code&gt;:undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6476916acd48544b426c8480acd642ec86103d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;Child specification&quot; section of the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;Child specification&quot; section of the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt;. The child process will be started as defined in the child specification.</target>
        </trans-unit>
        <trans-unit id="4b785aaae874a7f7ac89b390425e4e181327565b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;child_spec/1&quot; section of the documentation for &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 은 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 문서의 &quot;child_spec / 1&quot;섹션에 설명 된 유효한 자식 사양이어야합니다 . 하위 프로세스는 하위 스펙에 정의 된대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d9984de2b8855daeaef81ef2dcc1396c0705a01d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 은 유효한 자식 사양이어야합니다. 하위 프로세스는 하위 스펙에 정의 된대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="631a468d011ccda2d4a412a6dc19a7a03449ce32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, chunk, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</target>
        </trans-unit>
        <trans-unit id="9f93140b69bea94d444900d436d05d80b21439d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; 은 현재 요소와 누산기를 수신하고 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 를 리턴 하여 주어진 청크를 방출하고 어큐뮬레이터 또는 &lt;code&gt;{:cont, acc}&lt;/code&gt; 를 계속 수행하여 청크를 방출하지 않고 리턴 누산기를 계속해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a4d8126ef5b5ce5f93f354fe8074bc265f819b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client&lt;/code&gt; must be the &lt;code&gt;from&lt;/code&gt; argument (the second argument) accepted by &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callbacks. &lt;code&gt;reply&lt;/code&gt; is an arbitrary term which will be given back to the client as the return value of the call.</source>
          <target state="translated">&lt;code&gt;client&lt;/code&gt; 는 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 콜백에서 허용 하는 &lt;code&gt;from&lt;/code&gt; 인수 (두 번째 인수) 여야합니다 . &lt;code&gt;reply&lt;/code&gt; 은 호출의 반환 값으로 클라이언트에 다시 제공되는 임의의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="74ea1ebde7d25d8d5b3afc102cd5079c21ac3674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; is expected to be an executable available in PATH unless an absolute path is given.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 절대 경로가 지정되지 않은 경우 명령 은 PATH에서 사용 가능한 실행 파일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5be94dc7b7015ea04aea4b9a09952702a0f94d63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which are executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt; ) - provides build-time application configuration, which are executed when the release is assembled</target>
        </trans-unit>
        <trans-unit id="dcd9856e60a10b0680192123ebbb0d9096956b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which is executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; (및 &lt;code&gt;config/prod.exs&lt;/code&gt; )-빌드 타임 애플리케이션 구성을 제공합니다.이 구성은 릴리즈가 어셈블 될 때 실행됩니다</target>
        </trans-unit>
        <trans-unit id="d4b61ac40c23e500c794d4e5338038bb7d000bbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; - provides build-time application configuration, which is executed when the release is assembled. This file often imports configuration files based on the environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/prod.exs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; - provides build-time application configuration, which is executed when the release is assembled. This file often imports configuration files based on the environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/prod.exs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="238fad20b64f6752094e989e81c47221593a4dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time the release boots and is further extensible via config providers</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; - 런타임 응용 프로그램 구성을 제공합니다. 릴리스가 부팅 될 때마다 실행되며 구성 제공자를 통해 추가로 확장 가능</target>
        </trans-unit>
        <trans-unit id="a8ff7a040c02a1351d6dbd358d27db3517eb600c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to a regular &lt;code&gt;config/config.exs&lt;/code&gt; but it may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; 파일은 일반 &lt;code&gt;config/config.exs&lt;/code&gt; 와 매우 유사 하지만 약간의 제한이있을 수 있습니다. 당신은 할 수 있습니다 &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;설명서를 참조&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="d115832a93226d7668d444d20891799549c49ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to regular &lt;code&gt;config/config.exs&lt;/code&gt; files, but they may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to regular &lt;code&gt;config/config.exs&lt;/code&gt; files, but they may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="c9a7117d3f47e4aa0c4a534c57f688556ec90f1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/runtime.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time your Mix project or your release boots and is further extensible via config providers. If you want to detect you are inside a release, you can check for release specific environment variables, such as &lt;code&gt;RELEASE_NODE&lt;/code&gt; or &lt;code&gt;RELEASE_MODE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;config/runtime.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time your Mix project or your release boots and is further extensible via config providers. If you want to detect you are inside a release, you can check for release specific environment variables, such as &lt;code&gt;RELEASE_NODE&lt;/code&gt; or &lt;code&gt;RELEASE_MODE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11f7fbb073392ce31a1574f9793451f7610f3ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt; should be a list of &lt;code&gt;{app, app_config}&lt;/code&gt; tuples or a &lt;code&gt;%{app =&amp;gt; app_config}&lt;/code&gt; map where &lt;code&gt;app&lt;/code&gt; are the applications to be configured and &lt;code&gt;app_config&lt;/code&gt; are the configuration (as key-value pairs) for each of those applications.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; should be a list of &lt;code&gt;{app, app_config}&lt;/code&gt; tuples or a &lt;code&gt;%{app =&amp;gt; app_config}&lt;/code&gt; map where &lt;code&gt;app&lt;/code&gt; are the applications to be configured and &lt;code&gt;app_config&lt;/code&gt; are the configuration (as key-value pairs) for each of those applications.</target>
        </trans-unit>
        <trans-unit id="8f3eb732cc99e5e8d0e7d53c8f3927e2f14fdbcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; must be &lt;code&gt;iodata&lt;/code&gt; (a list of bytes or a binary). Setting the encoding for this function has no effect.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 는 &lt;code&gt;iodata&lt;/code&gt; (바이트 목록 또는 이진) 여야합니다 . 이 기능의 인코딩 설정은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3deab4bf4d8695b2db46398f128ebe3680400d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contents&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 은 문자열, 문자열 목록 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4068af36af3815a173cb8e9bbb5840dd4f7966e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context&lt;/code&gt; - the context of the environment; it can be &lt;code&gt;nil&lt;/code&gt; (default context), &lt;code&gt;:guard&lt;/code&gt; (inside a guard) or &lt;code&gt;:match&lt;/code&gt; (inside a match)</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; -환경의 맥락; 그것은 할 수있다 &lt;code&gt;nil&lt;/code&gt; (기본 컨텍스트), &lt;code&gt;:guard&lt;/code&gt; (가드 내부) 또는 &lt;code&gt;:match&lt;/code&gt; (일치하는 내부)</target>
        </trans-unit>
        <trans-unit id="e65d01ac3d70dd939e249ff006400606c24ca6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context_modules&lt;/code&gt; - a list of modules defined in the current context</source>
          <target state="translated">&lt;code&gt;context_modules&lt;/code&gt; - 현재 컨텍스트에 정의 된 모듈 목록</target>
        </trans-unit>
        <trans-unit id="5d9edb2d993802ba4716d7849368f4f8e74a86f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cprof&lt;/code&gt; can be useful when you want to discover the bottlenecks related to function calls.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 는 함수 호출과 관련된 병목 현상을 발견 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a38cdb98964403a68aee6e3174c867d51569e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; - 이 시간 필드의 해석은 운영 체제에 따라 다릅니다. Unix에서는 파일 또는 inode가 마지막으로 변경된 시간입니다. Windows에서는 지금이 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="e58b9649a044a1cbcb6e4a1e77207d650bc8622b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix-like operating systems, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix-like operating systems, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</target>
        </trans-unit>
        <trans-unit id="cf11efa8a9ba50fdad146c0ab1f8c6bab17d9d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cycles&lt;/code&gt; - prints all cycles in the graph;</source>
          <target state="translated">&lt;code&gt;cycles&lt;/code&gt; - prints all cycles in the graph;</target>
        </trans-unit>
        <trans-unit id="f1205b070fab0c83d6c993c3f3960abb127d2ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the characters in the line terminated by a line-feed (LF) or end of file (EOF)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 라인 피드 (LF) 또는 파일의 끝으로 종료 라인의 문자 (EOF)</target>
        </trans-unit>
        <trans-unit id="65ebe7dc5a6cbe47bb0f679ee7ef6cf59418d356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the input characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 입력 문자</target>
        </trans-unit>
        <trans-unit id="3d4410c596b384477fdcae0b3c0d2b1de73cede5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output bytes</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 출력 바이트</target>
        </trans-unit>
        <trans-unit id="d66ff6e276982cb027d53bd1f1e405fd861fcfe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 출력 문자</target>
        </trans-unit>
        <trans-unit id="f1e314b3d0f6ce196df7c11d73e42319ca204a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 는 중첩 구조 (즉, &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 맵, 키워드 목록 또는 구조체 )입니다.</target>
        </trans-unit>
        <trans-unit id="7c1c6811edebd033596c7ac3e0aad23e4479ee80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; behaviour).</target>
        </trans-unit>
        <trans-unit id="29e5249cd2895fafdb31d5931c2c7169b30ae35c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour). The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and the result replaces the value in the structure.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; behaviour). The &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and the result replaces the value in the structure.</target>
        </trans-unit>
        <trans-unit id="7a5af7db322cfde7e4e292358150d98466d7d4fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dep1 dep2&lt;/code&gt; - the name of dependencies to be unlocked</source>
          <target state="translated">&lt;code&gt;dep1 dep2&lt;/code&gt; - the name of dependencies to be unlocked</target>
        </trans-unit>
        <trans-unit id="d5594dd739a777b9fbe6eced0fe4ddf09a7ab2b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dep1 dep2&lt;/code&gt; - the names of dependencies to be deleted separated by a space</source>
          <target state="translated">&lt;code&gt;dep1 dep2&lt;/code&gt; - the names of dependencies to be deleted separated by a space</target>
        </trans-unit>
        <trans-unit id="e5cb8b51e466bd529414676deb5702007605833f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt; may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 는 원격 또는 로컬 PID, 로컬 포트, 로컬로 등록 된 이름 또는 다른 노드에서 등록 된 이름에 대한 &lt;code&gt;{registered_name, node}&lt;/code&gt; 형식의 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cb04154e21b24c69f9c8bad5656b7a39545bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device&lt;/code&gt; - the IO device</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; -IO 장치</target>
        </trans-unit>
        <trans-unit id="48cd3cb1cdaa44a2d6bca7edd5d1a1fc56abbc4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록</target>
        </trans-unit>
        <trans-unit id="325351821945a7973f1da881d3d9c9177ab84e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks are a syntactic convenience built on top of the keywords one. That&amp;rsquo;s why &lt;code&gt;do/end&lt;/code&gt; blocks do not require a comma between the previous argument and the block. They are useful exactly because they remove the verbosity when writing blocks of code. These are equivalent:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록은 키워드 하나 위에 구축 된 구문상의 편의성입니다. 따라서 &lt;code&gt;do/end&lt;/code&gt; 블록은 이전 인수와 블록 사이에 쉼표가 필요하지 않습니다. 코드 블록을 작성할 때 자세한 정보를 제거하기 때문에 정확하게 유용합니다. 이들은 동등합니다 :</target>
        </trans-unit>
        <trans-unit id="ade8e208e831b5d198ac3add386fe1dab9834807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; - used in do/end blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;rescue&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; / end 블록에 사용</target>
        </trans-unit>
        <trans-unit id="3985298d4759592d757f0cb9a9e4f9b15e52aa5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록을</target>
        </trans-unit>
        <trans-unit id="43edbc936cf9ae8a8d1677e787957e43950a7cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dollar_endonly&lt;/code&gt; - not available, use &lt;code&gt;\z&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;dollar_endonly&lt;/code&gt; - 사용 불가, 대신 &lt;code&gt;\z&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="81166ee1fc1c5f6aa3345e5c1516903114a049ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description in &lt;code&gt;xref_graph.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -에서 DOT 그래프 설명 생산 &lt;code&gt;xref_graph.dot&lt;/code&gt; 현재 디렉토리에 있습니다. 경고 : 이전에 생성 된 파일보다 우선합니다</target>
        </trans-unit>
        <trans-unit id="2d738dd7421b12b1a016e326ba2d61a77f72e728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the application tree in &lt;code&gt;app_tree.dot&lt;/code&gt; in the current directory. Warning: this will overwrite any previously generated file.</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the application tree in &lt;code&gt;app_tree.dot&lt;/code&gt; in the current directory. Warning: this will overwrite any previously generated file.</target>
        </trans-unit>
        <trans-unit id="7f0188ed62d4d0a891a4d684caeeb5e48721569b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the dependency tree in &lt;code&gt;deps_tree.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file.</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description of the dependency tree in &lt;code&gt;deps_tree.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file.</target>
        </trans-unit>
        <trans-unit id="5aa86ef28d23f77d91172ba542c09d2cc5b7637b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dotall&lt;/code&gt; (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; according to &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;dotall&lt;/code&gt; (s)-점이 개행과 일치하고 개행을 anycrlf로 설정합니다. &lt;code&gt;:re&lt;/code&gt; documentation 에 따라 &lt;code&gt;(*CR)&lt;/code&gt; 또는 &lt;code&gt;(*LF)&lt;/code&gt; 또는 &lt;code&gt;(*CRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANY)&lt;/code&gt; 를 설정하여 줄 바꿈 설정을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df6f1675aa9801dfb22096bcea57d03ccca2fb4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="d4c769601399680023c8ba6fd6b77d7373a374a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses allow the result of the body passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; to be pattern matched on:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 절을 사용하면 &lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 에 전달 된 본문의 결과를 다음 과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cddbb9fd21a3bab1166f759ba9181e02747b988c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; can also be &amp;ldquo;caught&amp;rdquo; using &lt;code&gt;try/catch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 는 &lt;code&gt;try/catch&lt;/code&gt; 를 사용하여&amp;ldquo;잡힐 수 있습니다&amp;rdquo; :</target>
        </trans-unit>
        <trans-unit id="17e496cdf50605afa594c0a2b3b48bf5f1fd62d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; signals are an important part of the fault tolerant system provided by the Erlang</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 신호는 Erlang이 제공하는 내결함성 시스템의 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="db3067f33775b9f16e85d2c27602d9e6760ad782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extended&lt;/code&gt; (x) - whitespace characters are ignored except when escaped and allow &lt;code&gt;#&lt;/code&gt; to delimit comments</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; (x)-이스케이프 된 경우를 제외하고 공백 문자는 무시되며 &lt;code&gt;#&lt;/code&gt; 로 주석을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="5dd94be61300bd55483654aaa07e30abd3dae510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - ignores padding from the input string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; - 입력 문자열에서 패딩을 무시합니다</target>
        </trans-unit>
        <trans-unit id="0f2f2cad3367ff4259e6a85005d20253c790cbd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - omit padding from the output string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; - 출력 문자열에서 패딩 생략</target>
        </trans-unit>
        <trans-unit id="0dd4008fc42804b6bf3e46bd4df4d0ea81c26c3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; - the current file name as a binary</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; - 바이너리로 현재 파일 이름</target>
        </trans-unit>
        <trans-unit id="89e027d1ed05b4018b4a08d0262f23b3ff60ce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstline&lt;/code&gt; (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline</source>
          <target state="translated">&lt;code&gt;firstline&lt;/code&gt; (f)-일치하는 텍스트가 개행을 계속할 수 있지만 고정되지 않은 패턴이 첫 번째 개행 이전 또는 첫 번째 개행과 일치하도록합니다.</target>
        </trans-unit>
        <trans-unit id="6908e3631ddb64d7fcca5b3480aa8fd1cfac7e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; - used for anonymous function definitions</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; - 익명 함수 정의에 사용</target>
        </trans-unit>
        <trans-unit id="7b569c1f1b88d633c8ae41253689a2f767acd2bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; - accesses a map/struct field; in case the field is not present, an error is raised</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; - 지도 / 구조체 필드에 접근합니다; 필드가없는 경우 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="f4b838ac959304b5441479216a13abe7cbdbbcf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo[bar]&lt;/code&gt; - accesses the key &lt;code&gt;bar&lt;/code&gt; in &lt;code&gt;foo&lt;/code&gt;; in case &lt;code&gt;foo&lt;/code&gt; is nil, &lt;code&gt;nil&lt;/code&gt; is returned</source>
          <target state="translated">&lt;code&gt;foo[bar]&lt;/code&gt; - 키에 액세스하는 &lt;code&gt;bar&lt;/code&gt; 의 &lt;code&gt;foo&lt;/code&gt; 는 ; 경우에 &lt;code&gt;foo&lt;/code&gt; 는이 전무하다, &lt;code&gt;nil&lt;/code&gt; 반환된다</target>
        </trans-unit>
        <trans-unit id="eef0f2d09999efe1c1a474dc48a013215ea64e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprof&lt;/code&gt; can be useful when you want to discover the bottlenecks of a sequential code.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 는 순차 코드의 병목 현상을 발견 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7bedba0b383b7f10d86c6ad80100844e60be3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 아래의 현재 값 불려 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; )와, 2 요소 튜플을 반환해야합니다 다음은 &quot;GET&quot;값 (반환하기 전에에서 작동 할 수 검색된 값) 새 값 은 결과 새 맵 에서 &lt;code&gt;key&lt;/code&gt; 아래에 저장 됩니다. &lt;code&gt;fun&lt;/code&gt; 은 또한 &lt;code&gt;:pop&lt;/code&gt; 을 반환 할 수 있습니다 . 즉, 현재 값이 &lt;code&gt;map&lt;/code&gt; 에서 제거되어 반환됩니다 (이 기능을 &lt;code&gt;Map.pop(map, key)&lt;/code&gt; 처럼 동작하게 함 ).</target>
        </trans-unit>
        <trans-unit id="1497d120ffa4d64ecfb633cbede2202bdb558511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt; ) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt; , which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="73987292ec55c205146407f70cc34101bc201e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the module name of the given &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt;. The return value of this function is the return value of &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 주어진 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 의 모듈 이름으로 fun 이 호출됩니다 . 이 함수의 반환 값은 &lt;code&gt;fun&lt;/code&gt; 의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0344ca817de66fc2cf01667d06d78a915e393ff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 제로 익명의 기능이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bec4f976c611de0387ba3b8e5bc5a82998ebd9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 제로 익명의 기능이어야합니다. 이 함수는 호출자 프로세스에 연결되고 모니터되는 프로세스를 생성합니다. 관련 정보가 포함 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 구조체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba04c9a31c6587cb12b54223a008938c6c36fce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt; - a tuple as &lt;code&gt;{atom, integer}&lt;/code&gt;, where the first element is the function name and the second its arity; returns &lt;code&gt;nil&lt;/code&gt; if not inside a function</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; - &lt;code&gt;{atom, integer}&lt;/code&gt; 의 튜플 . 여기서 첫 번째 요소는 함수 이름이고 두 번째 요소는 arity입니다. 함수 안에 있지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환</target>
        </trans-unit>
        <trans-unit id="fdce62b51d95c967bffec92639abb05fa80a816f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;functions&lt;/code&gt; - a list of functions imported from each module</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; -각 모듈에서 가져온 함수 목록</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 는 검색된 값입니다 (반환되기 전에 작동 가능).</target>
        </trans-unit>
        <trans-unit id="24a178311ad224c4a60feb7863864b4d30e88cd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; - 파일을 소유 한 그룹을 나타냅니다. 비 유닉스 파일 시스템의 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="1f43a02c647206e5b6b07cf646b10821f30b84ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix-like file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix-like file systems.</target>
        </trans-unit>
        <trans-unit id="64ea8480a297125c017fea9dde76f546c7b7fe47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_leader&lt;/code&gt; is the group leader of the process which logged the message</source>
          <target state="translated">&lt;code&gt;group_leader&lt;/code&gt; 는 메시지를 기록한 프로세스의 그룹 리더입니다.</target>
        </trans-unit>
        <trans-unit id="70ac6a68765cc03d71749e0430309afdc39b2cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h round/1&lt;/code&gt; works because it is defined in &lt;code&gt;Kernel&lt;/code&gt; module. All functions in the &lt;code&gt;Kernel&lt;/code&gt; module are automatically imported into our namespace. Most often you will also include the module name when looking up for documentation for a given function:</source>
          <target state="translated">&lt;code&gt;h round/1&lt;/code&gt; works because it is defined in &lt;code&gt;Kernel&lt;/code&gt; module. All functions in the &lt;code&gt;Kernel&lt;/code&gt; module are automatically imported into our namespace. Most often you will also include the module name when looking up for documentation for a given function:</target>
        </trans-unit>
        <trans-unit id="7e4a6ea58f48db7fc69ef53cf936a56a08b467db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_call/3&lt;/code&gt; must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful backpressure mechanism.</source>
          <target state="translated">&lt;code&gt;handle_call/3&lt;/code&gt; 동기 요청에는 handle_call / 3을 사용해야합니다. 서버 응답을 기다리는 것이 유용한 역압 메커니즘이므로 기본 선택이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a2af7471be23ef0937ae1a0fe2c62f92e8f8d066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_cast/2&lt;/code&gt; must be used for asynchronous requests, when you don&amp;rsquo;t care about a reply. A cast does not even guarantee the server has received the message and, for this reason, should be used sparingly. For example, the &lt;code&gt;create/2&lt;/code&gt; function we have defined in this chapter should have used &lt;code&gt;call/2&lt;/code&gt;. We have used &lt;code&gt;cast/2&lt;/code&gt; for didactic purposes.</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 응답에 신경 쓰지 않으면 비동기 요청에 handle_cast / 2를 사용해야합니다. 캐스트는 서버가 메시지를 수신했음을 보증하지도 않기 때문에 드물게 사용해야합니다. 예를 들어, 이 장에서 정의한 &lt;code&gt;create/2&lt;/code&gt; 함수는 &lt;code&gt;call/2&lt;/code&gt; 를 사용해야합니다 . 우리는 교훈적인 목적으로 &lt;code&gt;cast/2&lt;/code&gt; 를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="ba53ab70dc78f0a9b7412ec3b2bb0f747a7d63ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_info/2&lt;/code&gt; must be used for all other messages a server may receive that are not sent via &lt;code&gt;GenServer.call/2&lt;/code&gt; or &lt;code&gt;GenServer.cast/2&lt;/code&gt;, including regular messages sent with &lt;code&gt;send/2&lt;/code&gt;. The monitoring &lt;code&gt;:DOWN&lt;/code&gt; messages are an example of this.</source>
          <target state="translated">&lt;code&gt;handle_info/2&lt;/code&gt; 는 &lt;code&gt;send/2&lt;/code&gt; 로 전송 된 일반 메시지를 포함하여 &lt;code&gt;GenServer.call/2&lt;/code&gt; 또는 &lt;code&gt;GenServer.cast/2&lt;/code&gt; 를 통해 전송되지 않은 서버가 수신 할 수있는 다른 모든 메시지에 사용해야합니다 . 모니터링 &lt;code&gt;:DOWN&lt;/code&gt; 메시지는 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8e34c824ac05b21ab757c5fbf6100951dcd8cb12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; - 하위 스펙에 정의 된대로</target>
        </trans-unit>
        <trans-unit id="a955d26c8cf2d713bf003551df2c96067ee51799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - it is always &lt;code&gt;:undefined&lt;/code&gt; for dynamic supervisors</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; - 동적 관리자에 대해 항상 &lt;code&gt;:undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9254b1d6d22c5cafac5af8f10ed37f33275d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 에 &lt;code&gt;unless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89169d2e3dce0e0e3f3d300ab237fbc286465d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for!/1&lt;/code&gt; - same as above but raises an error if an implementation is not found</source>
          <target state="translated">&lt;code&gt;impl_for!/1&lt;/code&gt; - 위와 동일하지만 구현을 찾지 못하면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="dd4dcd3de4db76dbf5cd688389ee6bc144a73c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - receives a structure and returns the module that implements the protocol for the structure, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; - 구조를 수신하고 구조에 대한 프로토콜을 구현하는 모듈을 리턴합니다. 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07a626f31f573838ae13727b9af9053a68b4bf36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - returns the module that implements the protocol for the given argument, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; - returns the module that implements the protocol for the given argument, &lt;code&gt;nil&lt;/code&gt; otherwise</target>
        </trans-unit>
        <trans-unit id="77adafb3f8e1c04dc649c8a27bf4a028398d3422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;import Config&lt;/code&gt; 는 &lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; 기능&lt;/a&gt; 을 가져와 구성 관리에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4616b488ff51bfbaf80546fbb756faeba6d758dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; also supports &lt;code&gt;:macros&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; to be given to &lt;code&gt;:only&lt;/code&gt;. For example, to import all macros, one could write:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 는 &lt;code&gt;:macros&lt;/code&gt; 와 &lt;code&gt;:functions&lt;/code&gt; 을 &lt;code&gt;:only&lt;/code&gt; 에만 제공 합니다. 예를 들어, 모든 매크로를 가져 오기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6778e8370969e09cdb7b6d95b8411befab07014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;&lt;code&gt;not in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; &lt;code&gt;not in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b77d9288e8177ffb5c0fdea530e9078c1f6cab7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt; , it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</target>
        </trans-unit>
        <trans-unit id="1c71b4bbf5308a944ca78d7e8a7957ad9301c49e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; 는 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 이어야합니다 . &lt;code&gt;enumerable&lt;/code&gt; 하면 &lt;code&gt;index_range.first&lt;/code&gt; (제로베이스) 앞에 요소를 제거한 다음 &lt;code&gt;index_range.last&lt;/code&gt; 요소 (포함) 까지 요소를 취합니다 .</target>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_arg&lt;/code&gt; 는 start_link &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 전달 된 인수 용어 (두 번째 인수) 입니다.</target>
        </trans-unit>
        <trans-unit id="42ccdeed4cb31f96c120a6107473e17cfa988fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; -inode 번호를 제공합니다. Unix 이외의 파일 시스템에서는이 필드가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="b6ea18a5d36717bfe706a8d2aa403ba6e826028c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix-like file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix-like file systems, this field will be zero.</target>
        </trans-unit>
        <trans-unit id="a082bb1049b72730ef91489b19d870c7f2e5f5fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cac343e7ca30a47b6b2cafdd3b896dfb0b1254c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f662fb245490dd208672d79aaf08db7f1d03ffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04dc3cb7748f4ca9dc612c4051de3bbd8865f718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;invalid&lt;/code&gt; is a list of invalid options as &lt;code&gt;{option_name, value}&lt;/code&gt; where &lt;code&gt;option_name&lt;/code&gt; is the raw option and &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option</source>
          <target state="translated">&lt;code&gt;invalid&lt;/code&gt; 는 &lt;code&gt;{option_name, value}&lt;/code&gt; 와 같은 유효하지 않은 옵션 목록입니다. 여기서 &lt;code&gt;option_name&lt;/code&gt; 은 원시 옵션이고 옵션이 예상되지 않은 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이거나 값에 해당 옵션에 대한 예상 유형이없는 경우 문자열 값입니다.</target>
        </trans-unit>
        <trans-unit id="55411785328be352b733c3e64dd054a411983253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 는 실제로 파일을 처리하는 프로세스의 PID입니다. 이 프로세스는 원래 파일을 연 프로세스와 연결되어 있습니다. &lt;code&gt;io_device&lt;/code&gt; 가 연결된 프로세스가 종료되면 파일이 닫히고 프로세스 자체가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2069292f94f4f2165e4255f81f033e84ed34215f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process monitors the process that originally opened the file (the owner process). If the owner process terminates, the file is closed and the process itself terminates too. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated. An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process monitors the process that originally opened the file (the owner process). If the owner process terminates, the file is closed and the process itself terminates too. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated. An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; module functions.</target>
        </trans-unit>
        <trans-unit id="5af2f0d60c8ca31bd9daa14054f2d8834771b498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iodata&lt;/code&gt; and &lt;code&gt;chardata&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iodata&lt;/code&gt; 와 &lt;code&gt;chardata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea30f7281c750bcdb363bf792a71040fa82420b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e622f1b70f9ca4dde650995469cb5ac546f01dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_&lt;/code&gt; prefix (&lt;code&gt;is_foo&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;is_&lt;/code&gt; 접두사 ( &lt;code&gt;is_foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0ae12fa1bd5cefeb45ca87984e5434aa6c1ab55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner&lt;/code&gt; can be either a binary or a list and the result will be of the same type as &lt;code&gt;joiner&lt;/code&gt;. If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty binary.</source>
          <target state="translated">&lt;code&gt;joiner&lt;/code&gt; 는 이진 또는 목록 일 수 있으며 결과는 &lt;code&gt;joiner&lt;/code&gt; 와 동일한 유형 입니다. 경우 &lt;code&gt;joiner&lt;/code&gt; 전혀 전달되지 빈 이진 기본값.</target>
        </trans-unit>
        <trans-unit id="050495ebb57fd238ad025920a895b7b1b31f5954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; - if the message is a &lt;code&gt;:report&lt;/code&gt; or &lt;code&gt;:format&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; - 메시지가 &lt;code&gt;:report&lt;/code&gt; 또는 &lt;code&gt;:format&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="341383e5f6f763ffb092f6be26a117949ada5934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; can be any of &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt;, or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 는 &lt;code&gt;:def&lt;/code&gt; , &lt;code&gt;:defp&lt;/code&gt; , &lt;code&gt;:defmacro&lt;/code&gt; 또는 &lt;code&gt;:defmacrop&lt;/code&gt; 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a606e3b01bc357576e2067b4913ba6530c37d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - set it to &lt;code&gt;:erlang&lt;/code&gt; for Erlang projects managed by Mix. Doing so will ensure Elixir is not embedded by default. Your app will still be started as part of escript loading, with the config used during build.</source>
          <target state="translated">&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - Mix에서 관리하는 Erlang 프로젝트의 경우 &lt;code&gt;:erlang&lt;/code&gt; 으로 설정하십시오 . 그렇게하면 Elixir가 기본적으로 포함되지 않습니다. 빌드하는 동안 사용 된 구성을 사용하여 앱은 여전히 ​​escript 로딩의 일부로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1615078eab6862c1223e38ceca7c0c858e7fb3ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left not in right&lt;/code&gt; is parsed by the compiler into the AST:</source>
          <target state="translated">&lt;code&gt;left not in right&lt;/code&gt; 이 아닌 왼쪽 은 컴파일러에 의해 AST로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="04daa36a0e26e29c02251806cbf56bde90f72442" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - the level of the message being translated</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; - 메시지의 수준은 번역되고</target>
        </trans-unit>
        <trans-unit id="a0cdec75a5c5e0d6470766585fef67da68441fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 은 앞에서 설명한 것처럼 &lt;code&gt;:debug&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="a4d5841581a184cf1414acb4f60c9a23be456dac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described (for compatibility with pre 1.10 backends the &lt;code&gt;:notice&lt;/code&gt; will be translated to &lt;code&gt;:info&lt;/code&gt; and all messages above &lt;code&gt;:error&lt;/code&gt; will be translated to &lt;code&gt;:error&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; , or &lt;code&gt;:error&lt;/code&gt; , as previously described (for compatibility with pre 1.10 backends the &lt;code&gt;:notice&lt;/code&gt; will be translated to &lt;code&gt;:info&lt;/code&gt; and all messages above &lt;code&gt;:error&lt;/code&gt; will be translated to &lt;code&gt;:error&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ad467d7b51aa9a22263cef951086b6316700c37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_tracker&lt;/code&gt; - PID of the lexical tracker which is responsible for keeping user info</source>
          <target state="translated">&lt;code&gt;lexical_tracker&lt;/code&gt; - 사용자 정보를 유지하는 어휘 추적기의 PID</target>
        </trans-unit>
        <trans-unit id="00b7f69aa97db45047c5fc9677b43d58013c72d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the current line as an integer</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; - 정수로 현재 행</target>
        </trans-unit>
        <trans-unit id="8a637d2453fa7712dde78a4184c51cb4f28ba3e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line_or_bytes&lt;/code&gt; - if reading should read lines or a given number of bytes</source>
          <target state="translated">&lt;code&gt;line_or_bytes&lt;/code&gt; - 읽은 줄이나 주어진 바이트 수를 읽어야하는 경우</target>
        </trans-unit>
        <trans-unit id="de043cb51af4ab5a147a2fd2fb7510e6d4f6968b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;links&lt;/code&gt; - the number of links to this file. This is always 1 for file systems which have no concept of links.</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; - 이 파일에 대한 링크 수 링크 개념이없는 파일 시스템의 경우 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="b6df45129219eb88ff0e445a634f5ec40fa7565a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list(binary)&lt;/code&gt; - a list of named captures to capture</source>
          <target state="translated">&lt;code&gt;list(binary)&lt;/code&gt; -캡처 할 명명 된 캡처 목록</target>
        </trans-unit>
        <trans-unit id="b30b2f2ca39cc18127aed43526b57922054977d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro_aliases&lt;/code&gt; - a list of aliases defined inside the current macro</source>
          <target state="translated">&lt;code&gt;macro_aliases&lt;/code&gt; - 현재 매크로 내에 정의 된 별명 목록</target>
        </trans-unit>
        <trans-unit id="e68229a8f305b62b43dd03a0bee3d8371fd691cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macros&lt;/code&gt; - a list of macros imported from each module</source>
          <target state="translated">&lt;code&gt;macros&lt;/code&gt; -각 모듈에서 가져온 매크로 목록</target>
        </trans-unit>
        <trans-unit id="da01a0ff55acb30995528624346541bfd079654b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_device&lt;/code&gt; - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">&lt;code&gt;major_device&lt;/code&gt; - 파일이있는 파일 시스템을 식별합니다. Windows에서 숫자는 다음과 같이 드라이브를 나타냅니다. 0은 A :를 의미하고 1은 B :를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="122658d8aed547a03014a89daa76d75e7458af25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - the message to format. If it is &lt;code&gt;:report&lt;/code&gt;, it is a tuple with &lt;code&gt;{report_type, report_data}&lt;/code&gt;, if it is &lt;code&gt;:format&lt;/code&gt;, it is a tuple with &lt;code&gt;{format_message, format_args}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; - 형식화 할 메시지 이 경우 &lt;code&gt;:report&lt;/code&gt; , 그것은을 가진 튜플이다 &lt;code&gt;{report_type, report_data}&lt;/code&gt; 는 경우 &lt;code&gt;:format&lt;/code&gt; , 그것은을 가진 튜플 &lt;code&gt;{format_message, format_args}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758cc0c5ee8acd71fe0b83a3e86f48dd145a827c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; is the actual message (as chardata)</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 는 실제 메시지입니다 (chardata).</target>
        </trans-unit>
        <trans-unit id="876c3f9a8c4fd0d3cc2d1f037866f3debf0464cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; is a keyword list of metadata used when logging the message</source>
          <target state="translated">&lt;code&gt;metadata&lt;/code&gt; 는 메시지를 기록 할 때 사용되는 메타 데이터의 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a589d4f6762768ff5257c5bba38458ca30db3f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_level&lt;/code&gt; - the current Logger level</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; - 현재 로거 레벨</target>
        </trans-unit>
        <trans-unit id="ed12497f2b56facc6f9492f4e4c4032a391d9c99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix-like systems. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -Unix 계열 시스템의 문자 장치에만 유효합니다. 다른 모든 경우이 필드는 0입니다.</target>
        </trans-unit>
        <trans-unit id="3885fa3becd34b396b52f6d8056bdc58ee479e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -Unix의 문자 장치에만 유효합니다. 다른 모든 경우에는이 필드가 0입니다.</target>
        </trans-unit>
        <trans-unit id="24b263dd8a1d1347bf64bee3038f26998b4b840b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mix.exs&lt;/code&gt; - invokes &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; -&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b6340174a39f21a758f5572a672b194a9d24cc3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; - the file permissions.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; - 파일 권한</target>
        </trans-unit>
        <trans-unit id="8a3927965ac3d6f77c51036b665e6f351a35212d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:always&lt;/code&gt;, which means nesting always happen, or &lt;code&gt;:break&lt;/code&gt;, which means nesting only happens inside a group that has been broken.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:always&lt;/code&gt; 일 수 있습니다 . 이는 중첩이 항상 발생 함을 의미하거나 &lt;code&gt;:break&lt;/code&gt; 는 중첩 된 그룹 내에서만 중첩이 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58c0879f979115e580bc917136d2b58ff8c9f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:enabled&lt;/code&gt; or &lt;code&gt;:disabled&lt;/code&gt;. When &lt;code&gt;:enabled&lt;/code&gt;, it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; in search of the next break.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:enabled&lt;/code&gt; 또는 &lt;code&gt;:disabled&lt;/code&gt; 일 수 있습니다. 시 &lt;code&gt;:enabled&lt;/code&gt; 효과적으로 휴식을 취소, 다음 휴식을 발견, 그것은 바로 적합로 문서를 고려할 것입니다. 또한 다음 나누기를 검색 할 때 &lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt; 을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="50100399cfb27f3841672acd2f4af9b485e65862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; lowercases only the letters A to Z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:default&lt;/code&gt; , &lt;code&gt;:ascii&lt;/code&gt; 또는 &lt;code&gt;:greek&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;:default&lt;/code&gt; 모드는 유니 코드 표준에 명시된 이외의 모든 조건 변환을 고려한다. &lt;code&gt;:ascii&lt;/code&gt; 는 소문자 A부터 Z까지만 소문자로 표기합니다. &lt;code&gt;:greek&lt;/code&gt; 에는 그리스어로 된 문맥 인식 매핑이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a1aa428e4e231b54bacb63710c1631f262151d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; uppercases only the letters a to z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:default&lt;/code&gt; , &lt;code&gt;:ascii&lt;/code&gt; 또는 &lt;code&gt;:greek&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;:default&lt;/code&gt; 모드는 유니 코드 표준에 명시된 이외의 모든 조건 변환을 고려한다. &lt;code&gt;:ascii&lt;/code&gt; 는 대문자 a에서 z까지만 대문자입니다. &lt;code&gt;:greek&lt;/code&gt; 에는 그리스어로 된 문맥 감지 매핑이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a86fdaff8bc5148e78a1c4c04f8fce0a3900889d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes&lt;/code&gt; - the file modes</source>
          <target state="translated">&lt;code&gt;modes&lt;/code&gt; - 파일 모드</target>
        </trans-unit>
        <trans-unit id="8d0e52c287df97f7b63fd739d48b6d486974eb14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes_or_function&lt;/code&gt; can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt;. See the documentation for &lt;a href=&quot;#open/3&quot;&gt;&lt;code&gt;open/3&lt;/code&gt;&lt;/a&gt; for more information on this function.</source>
          <target state="translated">&lt;code&gt;modes_or_function&lt;/code&gt; 은 모드 목록이거나 함수일 수 있습니다. 목록 인 경우 모드 목록으로 간주됩니다 (아래에 설명되어 있음). 함수 인 경우 &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt; 을 호출하는 것과 같습니다 . 이 기능에 대한 자세한 내용 은 &lt;a href=&quot;#open/3&quot;&gt; &lt;code&gt;open/3&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34262bd30becc8991857017eb2e5b09e7a70e4f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - the current module name</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; - 현재 모듈 이름</target>
        </trans-unit>
        <trans-unit id="698d9c8f57c8e28a58401b70d215fc5e4dfe9978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; has to be an Elixir module, as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; won't work with Erlang-style modules (for example, &lt;code&gt;split(:lists)&lt;/code&gt; raises an error).</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 로서, 엘릭서 모듈이어야 &lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt; (예컨대, 윌 얼랑 스타일 모듈하지 일 &lt;code&gt;split(:lists)&lt;/code&gt; 에러를 발생).</target>
        </trans-unit>
        <trans-unit id="548b3515fdb43f8aa1119d92ad82f1b43b9de201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 하위 스펙에 정의 된 모듈</target>
        </trans-unit>
        <trans-unit id="5b0d17e736b2173d4e4a1a204473eec63e0cda5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as specified by the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 하위 스펙에 지정된 모듈</target>
        </trans-unit>
        <trans-unit id="b3e68cee7399cd5a129a86e8776d09db0b50d6de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; is the message and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. When a timeout occurs the message is &lt;code&gt;:timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 는 메시지이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 . 시간 초과가 발생하면 메시지는 &lt;code&gt;:timeout&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="235eae13b2d8f1e8b35533fb20776ffccdd37a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mtime&lt;/code&gt; - the last time the file was written.</source>
          <target state="translated">&lt;code&gt;mtime&lt;/code&gt; - 파일이 마지막으로 작성된 시간</target>
        </trans-unit>
        <trans-unit id="4413bd051f5b2ef5173fbddf4ea926ec05b4ccf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt; (m) - causes &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to mark the beginning and end of each line; use &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; to match the end or beginning of the string</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt; (m)- &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 각 줄의 시작과 끝을 표시합니다. &lt;code&gt;\A&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 를 사용 하여 문자열의 끝이나 시작과 일치</target>
        </trans-unit>
        <trans-unit id="1aa7f499be35910aae1a7c96d198532426312d81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, &lt;code&gt;v(-2)&lt;/code&gt; returns the value of the expression evaluated before the last evaluated expression. In particular, &lt;code&gt;v(-1)&lt;/code&gt; returns the result of the last evaluated expression and &lt;code&gt;v()&lt;/code&gt; does the same.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 음수 값일 수 있습니다. 값이면 현재 값을 기준으로 해당 표현식 값이 반환됩니다. 예를 들어, &lt;code&gt;v(-2)&lt;/code&gt; 는 마지막으로 평가 된 표현식 전에 평가 된 표현식의 값을 반환합니다. 특히 &lt;code&gt;v(-1)&lt;/code&gt; 은 마지막으로 평가 된 식의 결과를 반환하고 &lt;code&gt;v()&lt;/code&gt; 는 동일하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="45c8a3e19ab3e2ddbc2090990f79c346b752b3be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is an integer greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 이상의 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="5659d6236346e538cb5cb8cba7c914efd4b16565" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/0&lt;/code&gt; to create a new record with default values for all fields</source>
          <target state="translated">&lt;code&gt;name/0&lt;/code&gt; 모든 필드의 기본값으로 새 레코드를 작성하려면 name / 0</target>
        </trans-unit>
        <trans-unit id="f6ba1c0b71b535b43431e95788b71f1fdb5ee903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/1&lt;/code&gt; to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list</source>
          <target state="translated">&lt;code&gt;name/1&lt;/code&gt; 주어진 필드 및 값으로 새 레코드를 작성하거나, 레코드에서 지정된 필드의 0부터 시작하는 색인을 얻거나, 주어진 레코드를 키워드 목록으로 변환하기 위해 name / 1</target>
        </trans-unit>
        <trans-unit id="cd9835c312b0e62d1d19feb8dd6a112dd5f5a0e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/2&lt;/code&gt; to update an existing record with the given fields and values or to access a given field in a given record</source>
          <target state="translated">&lt;code&gt;name/2&lt;/code&gt; 지정된 필드 및 값으로 기존 레코드를 업데이트하거나 지정된 레코드의 지정된 필드에 액세스하려면 이름 / 2</target>
        </trans-unit>
        <trans-unit id="11db5b5b41604eea36b6926eb7a04818f3d804d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 원자 여야하며 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 로&lt;/a&gt; 메시지를 보낼 때 PID / 포트 식별자 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64a47b8a0625c2774e6a643cd7191d74cfc61cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 아톰이어야하며 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 로&lt;/a&gt; 메시지를 보낼 때 PID / 포트 식별자 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91d48a3d18e54472d43b317cb1d047ea37a8ead4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;, which is the name of the extracted record, is expected to be an atom &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 추출 된 레코드의 이름이고, 원자 것으로 예상된다 &lt;em&gt;컴파일시&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3f729a0f6c717fcfbc43d515a7ec59810c5367" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native&lt;/code&gt; is determined by the VM at startup and will depend on the host operating system.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 은 시작시 VM에 의해 결정되며 호스트 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 는 인 &lt;code&gt;data&lt;/code&gt; 의 값을 업데이트 한 후 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;update_value&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8f28f31350f1c7665853e6d4b5999e6152b971b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline&lt;/code&gt; - not available, use &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANYCRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; at the beginning of the regexp according to the &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;newline&lt;/code&gt; -사용할 수없는 경우 &lt;code&gt;:re&lt;/code&gt; documentation 에 따라 정규 표현식 시작 부분에 &lt;code&gt;(*CR)&lt;/code&gt; 또는 &lt;code&gt;(*LF)&lt;/code&gt; 또는 &lt;code&gt;(*CRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANYCRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANY)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="22526a6e658f1a28d28bf75f04eb407c154f8ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="6fab3275a5dbf0c17e6bb5dbfbc499091c5cb4ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; if the task keeps running past the timeout</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 작업이 시간 초과를지나 계속 실행되면 nil</target>
        </trans-unit>
        <trans-unit id="0d2d366e73b9ec112919fa2886cd3525aa66ea55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_auto_capture&lt;/code&gt; - not available, use &lt;code&gt;?:&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;no_auto_capture&lt;/code&gt; - 사용할 수 없습니다 &lt;code&gt;?:&lt;/code&gt; 대신 ? :를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="408ece252fdd1021e44cd3be96e784b7803ec157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nodes&lt;/code&gt; is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</source>
          <target state="translated">&lt;code&gt;nodes&lt;/code&gt; 는 요청이 전송되는 노드 이름 목록입니다. 기본값은 알려진 모든 노드 (이 노드 포함)의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8137eb4c3f6c478804bd118d3101e44c85663fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 는 음이 아닌 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f3b3f1b4b4b341558fb4af537b367fd2795f31d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either a &lt;code&gt;pid&lt;/code&gt; of the monitored process (if monitoring a PID) or &lt;code&gt;{name, node}&lt;/code&gt; (if monitoring a remote or local name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 중 하나 인 &lt;code&gt;pid&lt;/code&gt; 또는 (a PID 감시 경우) 모니터링 프로세스 &lt;code&gt;{name, node}&lt;/code&gt; (원격 또는 로컬 이름을 모니터링하는 경우);</target>
        </trans-unit>
        <trans-unit id="60373c8878902ec332f31b76bff00eee4691253c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either the &lt;code&gt;port&lt;/code&gt; being monitored (when monitoring by port ID) or &lt;code&gt;{name, node}&lt;/code&gt; (when monitoring by a port name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 는 모니터중인 &lt;code&gt;port&lt;/code&gt; (포트 ID로 모니터링 할 때) 또는 &lt;code&gt;{name, node}&lt;/code&gt; (포트 이름으로 모니터링 할 때)입니다.</target>
        </trans-unit>
        <trans-unit id="f4103502bdc67af84a755c711febd0144e731649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_vsn&lt;/code&gt; is the previous version of the module (defined by the &lt;code&gt;@vsn&lt;/code&gt; attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element &lt;code&gt;:down&lt;/code&gt;. &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;extra&lt;/code&gt; is any extra data required to change the state.</source>
          <target state="translated">&lt;code&gt;old_vsn&lt;/code&gt; 은 업그레이드시 모듈의 이전 버전 ( &lt;code&gt;@vsn&lt;/code&gt; 속성으로 정의 )입니다. 이전 버전을 다운 그레이드 할 때 첫 번째 요소 &lt;code&gt;:down&lt;/code&gt; 과 함께 2 개의 튜플로 래핑 됩니다 . &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태 이며 &lt;code&gt;extra&lt;/code&gt; 는 상태를 변경하는 데 필요한 추가 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="571d94e13302249f0de59d56d782ae3e234cacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options_or_function&lt;/code&gt; can be a keyword list of options or a function.</source>
          <target state="translated">&lt;code&gt;options_or_function&lt;/code&gt; 은 키워드 옵션 또는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bab089b1bf1e41f034e7ae6bdb132bc0001b94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;and&lt;/code&gt; 단락 회로 운영된다. 왼쪽이 결과를 결정하기에 충분하지 않은 경우에만 오른쪽을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ccbe854a095f6f33ceeba28c9b8d43c2cbc1d56a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is a keyword list of parsed switches with &lt;code&gt;{switch_name, value}&lt;/code&gt; tuples in it; &lt;code&gt;switch_name&lt;/code&gt; is the atom representing the switch name while &lt;code&gt;value&lt;/code&gt; is the value for that switch parsed according to &lt;code&gt;opts&lt;/code&gt; (see the &quot;Examples&quot; section for more information)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 &lt;code&gt;{switch_name, value}&lt;/code&gt; 튜플이있는 구문 분석 된 스위치의 키워드 목록입니다 . &lt;code&gt;switch_name&lt;/code&gt; 은 스위치 이름을 나타내는 원자이고 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;opts&lt;/code&gt; 에 따라 구문 분석 된 스위치의 값입니다 (자세한 내용은 &quot;예&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="b1fbee1588161b4bf8e5a810b28d741081f25011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 구문 분석 된 스위치의 목록입니다 ( &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="2788d1165c4896248d485fc9d7605024d3d940c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 구문 분석 된 스위치 목록입니다 ( &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="56a1d646feea00078c3dafde93470f5d90c7d9db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the file path</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; - 파일 경로</target>
        </trans-unit>
        <trans-unit id="c68a85ae9613cab9896c95f71c08475d4a1e6f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; has to be a literal string and is automatically expanded via &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 는 리터럴 문자열이어야하며 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 을&lt;/a&gt; 통해 자동으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="bff908c352a7c02daae4149d788dab257dcc7734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdict_and_state&lt;/code&gt; is a two-elements list &lt;code&gt;[pdict, state]&lt;/code&gt; where &lt;code&gt;pdict&lt;/code&gt; is a list of &lt;code&gt;{key, value}&lt;/code&gt; tuples representing the current process dictionary of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pdict_and_state&lt;/code&gt; 이 두 요소 목록 &lt;code&gt;[pdict, state]&lt;/code&gt; 여기서 &lt;code&gt;pdict&lt;/code&gt; 이 목록이다 &lt;code&gt;{key, value}&lt;/code&gt; 의 현재 프로세스 사전 나타내는 튜플 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 및 &lt;code&gt;state&lt;/code&gt; 의 현재 상태 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c00f6b21503d6f14ec9e351116f82e98a1a573d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="283bbf3a7e63361529544f57e65445c33be2473a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; is the PID of the caller and &lt;code&gt;tag&lt;/code&gt; is a unique term used to identify the call.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 는 호출자의 PID이며 &lt;code&gt;tag&lt;/code&gt; 는 호출을 식별하는 데 사용되는 고유 한 용어입니다.</target>
        </trans-unit>
        <trans-unit id="7472d33de0e4e4c6d6bc5be3bc64d1117f76ab97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 는 로컬 노드에서 실행중인 프로세스를 참조해야합니다 . 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="87f6156bd80de24e4a8c659010f40070dcf0cd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 는 로컬 노드에서 실행중인 프로세스를 참조해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b460b4fb7f2948315666a3696deeaf29f7c5fac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - does not use Unicode code points for formatting the tree. This is the default on Windows.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -트리 형식화에 유니 코드 코드 포인트를 사용하지 않습니다. 이것은 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="167a28851306fdaf355a0b9d87bd9e06c3264602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - the same as pretty except ASCII characters are used instead of Unicode characters. This is the default on Windows;</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -유니 코드 문자 대신 ASCII 문자가 사용된다는 점을 제외하고는 거의 동일합니다. 이것이 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d8a4a973778edbc3b9292682c2961c04afdada51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 는 문자열, 문자열 목록 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a7b88e7dfa1815defebaaadeadc69b2b64802d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - prints the graph to the terminal using Unicode characters. Each prints each file followed by the files it depends on. This is the default except on Windows;</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; - 유니 코드 문자를 사용하여 그래프를 터미널에 인쇄합니다. 각각은 각 파일과 그에 의존하는 파일을 인쇄합니다. 이것이 Windows를 제외한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0ff046f53f79369619f74d0275786f73ba6cad39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - uses Unicode code points for formatting the tree. This is the default except on Windows.</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; - 트리 형식화에 유니 코드 코드 포인트를 사용합니다. 이것은 Windows를 제외하고 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a5c6719a29e3444d2a98704658b2abe3abc07b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;raw&lt;/code&gt; - a boolean indicating if bin functions should be used</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; -bin 함수를 사용해야하는지 여부를 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="2413f2dcbac9c52ab69f886cdee3aec797acde03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is exit reason and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 은 종료 reason이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d14f1d74048b142cf9c3c866e8baef03f5f628e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is the exit reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 는 종료 이유입니다.</target>
        </trans-unit>
        <trans-unit id="6d577afb9a7d7b11f4e9b26cc4f2b99ca0cd4414" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar PATH&lt;/code&gt; - specifies a path for &lt;code&gt;rebar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar PATH&lt;/code&gt; -에 대한 경로를 지정 &lt;code&gt;rebar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb8b62aa3c01480881b0ff737a93cf393955b7ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar.config&lt;/code&gt; - invokes &lt;code&gt;rebar compile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar.config&lt;/code&gt; - &lt;code&gt;rebar compile&lt;/code&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5ea1f065e3dfe97d2f4adaffe2e923025e9a488c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebar3 PATH&lt;/code&gt; - specifies a path for &lt;code&gt;rebar3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rebar3 PATH&lt;/code&gt; -에 대한 경로를 지정 &lt;code&gt;rebar3&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="017b38f6c3a63b34a77cb61fad862a0108619da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; is a monitor reference returned by this function;</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 는이 함수에 의해 반환되는 모니터 참조입니다.</target>
        </trans-unit>
        <trans-unit id="f67bb08de7b98445d3c88e9a2ee8208aab548754" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and are executed on every command to set up environment variables, including specific ones to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 및 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - 모든 릴리스에 복사되고 모든 명령에서 실행되어 VM 및 일반 환경에 대한 특정 변수를 포함하여 환경 변수를 설정하는 템플릿 파일</target>
        </trans-unit>
        <trans-unit id="f1dac4945e37fa410a22296831615f2618a6f8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and executed on every command to set up environment variables, including ones specific to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 및 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - 모든 릴리스에 복사되고 모든 명령에서 실행되어 VM과 관련된 환경 변수 및 일반 환경을 포함한 환경 변수를 설정하는 템플릿 파일</target>
        </trans-unit>
        <trans-unit id="c19918b14a9453c91c643c933cd15244538fc1e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - a template file that is copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags</source>
          <target state="translated">&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - 모든 릴리즈에 복사되고 Erlang 가상 머신 및 기타 런타임 플래그의 정적 구성을 제공하는 템플리트 파일</target>
        </trans-unit>
        <trans-unit id="7f40a3451ab81b3153487e704b02d37b9b6a4ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replies&lt;/code&gt; - is a list of &lt;code&gt;{node, reply}&lt;/code&gt; tuples where &lt;code&gt;node&lt;/code&gt; is the node that replied and &lt;code&gt;reply&lt;/code&gt; is its reply</source>
          <target state="translated">&lt;code&gt;replies&lt;/code&gt; - &lt;code&gt;{node, reply}&lt;/code&gt; 튜플 의 목록입니다. 여기서 &lt;code&gt;node&lt;/code&gt; 는 응답 한 노드이고 &lt;code&gt;reply&lt;/code&gt; 는 해당 응답입니다.</target>
        </trans-unit>
        <trans-unit id="1e85e74a7cd5534b5dc26bb806f6e8445febf275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from&lt;/code&gt; is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 는 &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 의해 전송 된 요청 메시지 이며 &lt;code&gt;from&lt;/code&gt; 은 호출자의 PID와 호출을 고유하게 식별하는 용어를 포함하는 2- 튜플이며 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="04e74abb0f4cf0d18536a2a96e905cc0f6069b33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 는 &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; 에&lt;/a&gt; 의해 전송 된 요청 메시지 이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="93816bb90205c96752dc4b1f4768e5dfd91ffd4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; - the list of required modules</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; - 필수 모듈 목록</target>
        </trans-unit>
        <trans-unit id="6c48083bf2c441634af8637cbd181b09103d558d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="c088bb2e30718916b5822f6df8045124d80cf2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fafec51a6ba058e17a08730a003c35a45d91a237" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 는 인수 목록입니다 ( &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="99d571b4f50dd13d3d5dab2e90c0858010d81600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 는 인수 목록입니다 ( &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="3bfa723258218ecec6b8ad74fe2b88b2c40ccf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: words in the list are strings (default)</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; : 목록의 단어는 문자열입니다 (기본값)</target>
        </trans-unit>
        <trans-unit id="62965b3fa200d2fcdd302a063393661d33658602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2218676f02b43a5d86faf5ba604881574737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serve/1&lt;/code&gt; is another loop that reads a line from the socket and writes those lines back to the socket. Note that the &lt;code&gt;serve/1&lt;/code&gt; function uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;the pipe operator &lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/a&gt; to express this flow of operations. The pipe operator evaluates the left side and passes its result as the first argument to the function on the right side. The example above:</source>
          <target state="translated">&lt;code&gt;serve/1&lt;/code&gt; 은 소켓에서 한 줄을 읽고 해당 줄을 다시 소켓에 쓰는 또 다른 루프입니다. 노트는 그 &lt;code&gt;serve/1&lt;/code&gt; 함수를 사용하여 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;파이프 연산자 &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;/a&gt; 동작의 흐름을 표현. 파이프 연산자는 왼쪽을 평가하고 결과를 첫 번째 인수로 오른쪽의 함수에 전달합니다. 위의 예 :</target>
        </trans-unit>
        <trans-unit id="4035242838ff6348de2918394188b203c1cec888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 는이 모듈에 대한 문서의 &quot;이름 등록&quot;섹션에 설명 된 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd4d2b94c9ed5de47dab724a819b4256c36fb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks can be defined by a block, by passing an atom naming a one-arity function, or by passing a list of such atoms. Both can opt to receive the current context by specifying it as parameter if defined by a block. Functions used to define a test setup must accept the context as single argument.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백은 하나의 원자 이름을 갖는 원자를 전달하거나 그러한 원자의 목록을 전달하여 블록으로 정의 할 수 있습니다. 둘 다 블록으로 정의 된 경우 현재 컨텍스트를 매개 변수로 지정하여 현재 컨텍스트를 수신하도록 선택할 수 있습니다. 테스트 설정을 정의하는 데 사용되는 함수는 컨텍스트를 단일 인수로 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="74e50f77430f1a1bdfe5ca63476784209360d3eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; and &lt;code&gt;unsigned&lt;/code&gt; are only used for matching binaries (see below) and are only used for integers.</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 와 &lt;code&gt;unsigned&lt;/code&gt; 는 이진 일치 (아래 참조)에만 사용되며 정수에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa5ba00cd0c9fad3ce7a3c8fe2e154e61d87770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - size of file in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 바이트에서 파일의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0a4f18566a210c559013bf9a5086044257909566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source_file&lt;/code&gt; and &lt;code&gt;destination_file&lt;/code&gt; must be a file or a symbolic link to one, or in the case of destination, a path to a non-existent file. If either one of them is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;source_file&lt;/code&gt; 및 &lt;code&gt;destination_file&lt;/code&gt; 은 파일이거나 대상의 경우 존재하지 않는 파일의 경로에 대한 파일 또는 심볼릭 링크 여야합니다. 둘 중 하나가 디렉토리이면 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="38212c1b9d372738da7952d34b2b9942eed99263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt; are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let&amp;rsquo;s see the most common one, called tasks.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 및 &lt;code&gt;spawn_link/1&lt;/code&gt; 은 Elixir에서 프로세스를 생성하기위한 기본 프리미티브입니다. 우리는 지금까지 독점적으로 사용했지만 대부분은 그 위에 구축 된 추상화를 사용할 것입니다. 가장 일반적인 작업 인 작업을 봅시다.</target>
        </trans-unit>
        <trans-unit id="ef8e38976f8ee83eeb6656542cc862dd86ba301d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; takes a function which it will execute in another process.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 은 다른 프로세스에서 실행될 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 사양 키 에서 응용 프로그램으로 전달되는 인수입니다 (예 &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1befc5d39644d1bc3134d4c35ea706fb5258286c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (for example, &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 사양 키 에서 애플리케이션에 전달되는 인수입니다 (예 &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe417925fd6a03a1cadb38a84034165856ff0856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_link/2&lt;/code&gt;, &lt;code&gt;init/2&lt;/code&gt;, and strategies</source>
          <target state="translated">&lt;code&gt;start_link/2&lt;/code&gt; , &lt;code&gt;init/2&lt;/code&gt; 및 전략</target>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 은 응용 프로그램이 시작되는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6346aa15c5ba367a190147de81ac212a3a013075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;starting_on&lt;/code&gt; can also be &lt;code&gt;:default&lt;/code&gt;, which is equivalent to &lt;code&gt;:monday&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;starting_on&lt;/code&gt; 은 또한 &lt;code&gt;:default&lt;/code&gt; 일 수 있으며 , 이는 &lt;code&gt;:monday&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bed6184e7c750cc712f2203171e1d9b7e789646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. If the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt; is present, &lt;code&gt;state&lt;/code&gt; is its return value instead.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 에 의해 반환 된 상태 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 가 한 경우, 또는, &lt;code&gt;[]&lt;/code&gt; 그렇지. 선택적 콜백 &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt; 이 있으면 &lt;code&gt;state&lt;/code&gt; 는 대신 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="2e6893ab1b754c2ae7dc9f997ecb10ec083f344f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt; - prints general statistics about the graph;</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; -그래프에 대한 일반 통계를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2790d8f945460f49048af9ed95a7afa73085f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer value which is returned by the runtime system to the operating system.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 는 음수가 아닌 정수 값이어야하며 런타임 시스템에서 운영 체제로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8c1f069e75f041dd495821b88b772c17da451669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer, the atom &lt;code&gt;:abort&lt;/code&gt; or a binary.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 는 음이 아닌 정수, atom &lt;code&gt;:abort&lt;/code&gt; 또는 2 진 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ac53a1094c979479b6f1b561f3e74f3968e85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; is optional and, if not passed, defaults to &lt;code&gt;count&lt;/code&gt;, i.e. chunks do not overlap.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 은 선택 사항이며, 전달되지 않은 경우 기본값은 &lt;code&gt;count&lt;/code&gt; 입니다 . 즉 청크가 겹치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07277647df2178950f06633decd26215f156ae7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;float#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 소수점을 포함한 float의 문자열 표현이어야합니다. 소수점이없는 문자열을 부동 소수점으로 구문 분석하려면 &lt;a href=&quot;float#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d88be8a0ed663da6633319f9f9081e4b82fb323" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 소수점을 포함하는 부동 소수점의 문자열 표현이어야합니다. 소수점이없는 문자열을 float로 구문 분석하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다. 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a57ce393e0bf34dc0ca576de7675a4598947d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;integer#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 정수의 문자열 표현이어야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 형식이 잘못된 정수를 포함 할 수있는 문자열을 구문 분석하려면 &lt;a href=&quot;integer#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; 을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c40c085b7a127dc3368869ad8c744f3545f95330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 정수의 문자열 표현이어야합니다. 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 형식이 잘못된 정수를 포함 할 수있는 문자열을 구문 분석하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; 을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8f508a843dbaf6b9d5439d982a8903dd2999cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; will be the initial input of the newly created device.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 새로 생성 된 장치의 초기 입력입니다.</target>
        </trans-unit>
        <trans-unit id="572985c443231f1ffed373013f737ade9f044914" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suffixes&lt;/code&gt; can be either a single suffix or a list of suffixes.</source>
          <target state="translated">&lt;code&gt;suffixes&lt;/code&gt; 는 단일 접미사 또는 접미사 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbf5dd9e7ab5c58f01c1dec17c4fb41c8b81931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 0보다 큰 정수로, 에이전트가 함수를 실행하고 결과 값을 반환하기 전에 허용되는 밀리 초 (밀리 초) 또는 무기 &lt;code&gt;:infinity&lt;/code&gt; 대기 시간을 지정합니다. 지정된 시간 내에 결과가 수신되지 않으면 함수 호출이 실패하고 호출자가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d95411839d7e41402b228ea7bab4f308778467d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. The default value is &lt;code&gt;5000&lt;/code&gt;. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 응답을 기다리는 시간 (밀리 초) 또는 atom &lt;code&gt;:infinity&lt;/code&gt; 를 무한정 기다리는 시간을 지정하는 0보다 큰 정수 입니다. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다. 지정된 시간 내에 응답이 수신되지 않으면 함수 호출이 실패하고 호출자가 종료됩니다. 호출자가 실패를 발견하고 계속 실행하고 서버가 응답이 늦어지면 언제든지 호출자의 메시지 큐에 도착할 수 있습니다. 이 경우 호출자는이를 준비하고 첫 번째 요소로 참조되는 두 요소 튜플 인 가비지 메시지를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f68b2a1cb84499ed2c00c6482e49eeac64039aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is either the number of milliseconds to sleep as an integer or the atom &lt;code&gt;:infinity&lt;/code&gt;. When &lt;code&gt;:infinity&lt;/code&gt; is given, the current process will sleep forever, and not consume or reply to messages.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 정수로 잠자기하는 밀리 초 수 또는 atom &lt;code&gt;:infinity&lt;/code&gt; 입니다. 때 &lt;code&gt;:infinity&lt;/code&gt; 주어, 현재 프로세스 영원히 잠, 그리고 소비 또는 메시지에 회신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d03dca1cbfe2406a67e381ab2870ef2bddd059b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is the timestamp for when the message was logged, as a &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; tuple</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 는 메시지가 &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; 튜플 로 기록 된 타임 스탬프 입니다.</target>
        </trans-unit>
        <trans-unit id="08d7a6e449b07af8124dddd49b8a31de7399fb11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - pad the output string to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 출력 문자열을 가장 가까운 8의 배수로 채 웁니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="4948e3624434de9113da8f38917d02367479d2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - requires the input string to be padded to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 입력 문자열을 가장 가까운 8의 배수로 채 웁니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="37f317994df4c5094e8b2eff3348d68fdc66f93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5f7234d664879c7a94dbc62ea230645de6ab29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f74a2bb6fb5fbbcf93b8f217f0cc291412b0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; - used as atoms</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; - 원자로 사용</target>
        </trans-unit>
        <trans-unit id="040c2cc20f87605723b2be4cdc0803a474de3d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt; are reserved words that are represented by the atoms &lt;code&gt;:true&lt;/code&gt;, &lt;code&gt;:false&lt;/code&gt; and &lt;code&gt;:nil&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 은 각각 원자 &lt;code&gt;:true&lt;/code&gt; , &lt;code&gt;:false&lt;/code&gt; 및 &lt;code&gt;:nil&lt;/code&gt; 로 표시되는 예약어 입니다.</target>
        </trans-unit>
        <trans-unit id="256ad4bcf7e37fd9a26fac8676e48361c0ed6b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt;; the type of the file.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt; ; 파일의 형태</target>
        </trans-unit>
        <trans-unit id="300d31ca0e6078f76938d4d6e305aff178a1dd44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt; as defined in the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 또는 &lt;code&gt;:supervisor&lt;/code&gt; 자식 사양에 정의 된대로</target>
        </trans-unit>
        <trans-unit id="1b592d0e2922f716b9d2f7ecf2cb31932d6201bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt;, as specified by the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 나 &lt;code&gt;:supervisor&lt;/code&gt; , 아이 사양에 지정된대로</target>
        </trans-unit>
        <trans-unit id="c53830ff73ee4bc1cf4e63694e58c8a37efe371d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; - 파일의 소유자를 나타냅니다. 비 유닉스 파일 시스템의 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0b465a5be832bc5b6b71e76009205aaeca5144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix-like file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; - 파일 소유자를 나타냅니다. Unix와 유사하지 않은 파일 시스템의 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="11d146eb39b484665d14fa72a8f2163b4c09bdef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ungreedy&lt;/code&gt; (U) - inverts the &quot;greediness&quot; of the regexp (the previous &lt;code&gt;r&lt;/code&gt; option is deprecated in favor of &lt;code&gt;U&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ungreedy&lt;/code&gt; (U)-정규 표현식의 &quot;greediness&quot;를 반전시킵니다 (이전 &lt;code&gt;r&lt;/code&gt; 옵션은 &lt;code&gt;U&lt;/code&gt; 를 위해 더 이상 사용되지 않습니다 )</target>
        </trans-unit>
        <trans-unit id="7c18fe6e2d8bd072b618387739a87dc0d858fa03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and causes character classes like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, etc. to also match on Unicode (see examples below in &quot;Character classes&quot;). It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; (u)- &lt;code&gt;\p&lt;/code&gt; 와 같은 유니 코드 특정 패턴을 활성화 하고 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 가 유니 코드에서도 일치하도록합니다 (아래 &quot;문자 클래스&quot;의 예 참조). 일치시 유효한 유니 코드 문자열이 제공 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="2b1493a8644a9f711c2b660f18b2fd58dc57c6be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and change modifiers like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and friends to also match on Unicode. It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; (u)- &lt;code&gt;\p&lt;/code&gt; 와 같은 유니 코드 특정 패턴을 활성화 하고 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 friends와 같은 수정자를 유니 코드에서도 일치시킬 수 있습니다. 유효한 유니 코드 문자열이 일치 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="3e21f4d0f150e8661e7894e55a7889cd5ea7c932" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unquote&lt;/code&gt; can even be used to inject function names:</source>
          <target state="translated">&lt;code&gt;unquote&lt;/code&gt; 를 사용하여 함수 이름을 삽입 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17f1b91056678deff5c7f31333a1d38b43965f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래에 저장 될 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="be70aa90b34d9b75607b8ad2c0d7e7068392c466" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Agent&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Agent&lt;/code&gt; 는 하위 사양을 구성하는 옵션 목록과 감독자에서 실행되는 방식도 허용합니다. 생성 된 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d929111db564f10be37ff4f2d784720755bf5dc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; defines a default implementation of this function which does nothing and just returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 은이 기능의 기본 구현을 정의하고 아무것도 수행하지 않고 &lt;code&gt;:ok&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 은 &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백에 대한 기본 구현을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8a3cd0a6ee94294da88b60ba9da6b647450af00b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use ExUnit.Case&lt;/code&gt; is responsible for setting up our module for testing and imports many test-related functionality, such as the &lt;code&gt;test/2&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 는 테스트를 위해 모듈을 설정하고 &lt;code&gt;test/2&lt;/code&gt; 매크로 와 같은 많은 테스트 관련 기능을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0384590b7214948d657738c3d5bfaf0a2cce9c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use GenServer&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;code&gt;child_spec/1&lt;/code&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use GenServer&lt;/code&gt; 는 하위 사양을 구성하는 옵션 목록과 감독자에서 실행되는 방식도 허용합니다. 생성 된 &lt;code&gt;child_spec/1&lt;/code&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9efc1ff6af2e783df9ff3c05cff5c9496b06d302" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Mix.Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;use Mix.Config&lt;/code&gt; 를 사용 하면 &lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; 기능&lt;/a&gt; 을 가져와 구성을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="19aacd0bb192aebbc1eaab7675d05f8b371c3c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Supervisor&lt;/code&gt; also defines a &lt;code&gt;child_spec/1&lt;/code&gt; function which allows us to run &lt;code&gt;MyApp.Supervisor&lt;/code&gt; as a child of another supervisor or at the top of your supervision tree as:</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 는 또한 다음 &lt;code&gt;MyApp.Supervisor&lt;/code&gt; 같이 MyApp.Supervisor 를 다른 감독자의 자식으로 또는 감독 트리의 최상위에서 실행할 수 있는 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="32f3cdd98eaec66584c149fc480cbffd83f3560c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Task&lt;/code&gt; defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, allowing the defined module to be put under a supervision tree. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Task&lt;/code&gt; 는 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 함수를 정의하여 정의 된 모듈을 감독 트리 아래에 둘 수 있습니다. 생성 된 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbf41816587fbe42f4bce2c3bd242b8da116833a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 은 부울이어야합니다. 그렇지 않은 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9001f343f267d4f2ca6c3f31d0f08dd106421221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; - a list keeping all defined variables as &lt;code&gt;{var, context}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; - 모든 정의 된 변수를 &lt;code&gt;{var, context}&lt;/code&gt; 로 유지하는 목록</target>
        </trans-unit>
        <trans-unit id="c6656f8557f89b74ee5b1266b3a4c9d4655c1a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt; - see &lt;a href=&quot;patterns-and-guards#guards&quot;&gt;Guards&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; - &lt;a href=&quot;patterns-and-guards#guards&quot;&gt;경비원&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="39f4537522a5331ce77a3c7353321177c38c05b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; - used as operators</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; - 연산자로 사용</target>
        </trans-unit>
        <trans-unit id="9ccd1761f004157a607955393cdd4a8c9b980865" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with&lt;/code&gt; also supports the &lt;code&gt;else&lt;/code&gt; keyword, which supports patterns matching and guards.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 는 패턴 일치 및 보호를 지원하는 &lt;code&gt;else&lt;/code&gt; 키워드 도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a2513b6e343efdb3f9d26eeabec520aa38f1a707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 로 인해 &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt; 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="f61ce99a9a56276c62bed185d0f0b8dde3175729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 로 인해 &lt;a href=&quot;https://hexdocs.pm/elixir/CompileError.html&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt; 가 발생했습니다. 예외를 발생 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f10cb46a7888b0c5592ef3405b96b453cace5d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; - exit signals in case the port crashes. If reason is not &lt;code&gt;:normal&lt;/code&gt;, this message will only be received if the owner process is trapping exits</source>
          <target state="translated">&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; -포트가 충돌하는 경우 종료 신호. reason이 (가) 아닌 경우 &lt;code&gt;:normal&lt;/code&gt; 소유자 프로세스가 종료를 트래핑하는 경우에만이 메시지가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="065a347a5c8149198567fd9f55e5f4c28abdefcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias, meta, alias, as, opts}&lt;/code&gt; - traced whenever &lt;code&gt;alias&lt;/code&gt; is aliased to &lt;code&gt;as&lt;/code&gt;. &lt;code&gt;meta&lt;/code&gt; is the alias AST metadata and &lt;code&gt;opts&lt;/code&gt; are the alias options.</source>
          <target state="translated">&lt;code&gt;{:alias, meta, alias, as, opts}&lt;/code&gt; - &lt;code&gt;alias&lt;/code&gt; 이로 별칭 이 지정 될 때마다 추적 &lt;code&gt;as&lt;/code&gt; . &lt;code&gt;meta&lt;/code&gt; 별칭 AST 메타 데이터이며 &lt;code&gt;opts&lt;/code&gt; 는 별칭 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="082404bfe2437ad4bd067635d72a3999fb3e2dae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias_expansion, meta, as, alias}&lt;/code&gt; traced whenever there is an alias expansion for a previously defined &lt;code&gt;alias&lt;/code&gt;, i.e. when the user writes &lt;code&gt;as&lt;/code&gt; which is expanded to &lt;code&gt;alias&lt;/code&gt;. &lt;code&gt;meta&lt;/code&gt; is the alias expansion AST metadata.</source>
          <target state="translated">&lt;code&gt;{:alias_expansion, meta, as, alias}&lt;/code&gt; 는 이전에 정의 된 &lt;code&gt;alias&lt;/code&gt; 대한 별칭 확장이있을 때마다 추적 됩니다. 즉, 사용자 가 &lt;code&gt;alias&lt;/code&gt; 으로 확장 된 &lt;code&gt;as&lt;/code&gt; 쓸 때 추적 됩니다 . &lt;code&gt;meta&lt;/code&gt; 는 별칭 확장 AST 메타 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="6a890edd2324777883e6844077da60f97a9d6609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:alias_reference, meta, module}&lt;/code&gt; - traced whenever there is an alias in the code, i.e. whenever the user writes &lt;code&gt;MyModule.Foo.Bar&lt;/code&gt; in the code, regardless if it was expanded or not.</source>
          <target state="translated">&lt;code&gt;{:alias_reference, meta, module}&lt;/code&gt; -코드에 별칭이있을 때마다, 즉 사용자가 쓸 때마다 추적됩니다. &lt;code&gt;MyModule.Foo.Bar&lt;/code&gt; , 확장 여부에 관계없이 가 코드에 MyModule.Foo.Bar 를 됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ed0adc88ae3ddaebc212331dcf48c5613f80ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:case_finished, test_module}&lt;/code&gt; - a test module has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:case_finished, test_module}&lt;/code&gt; -테스트 모듈이 완료되었습니다. &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cfe221b7da4019de03a758ec67212053a813890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:case_started, test_module}&lt;/code&gt; - a test module has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:case_started, test_module}&lt;/code&gt; -테스트 모듈이 시작되었습니다. &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc109206f208d54c435135b2ed115830f37e260b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:compile, modules, warnings}&lt;/code&gt; - to continue compilation with a list of further modules to compile</source>
          <target state="translated">&lt;code&gt;{:compile, modules, warnings}&lt;/code&gt; -컴파일 할 추가 모듈 목록을 사용하여 컴파일을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="9cf15a4b4877415b55cb1833700221f7d6ae839d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:compile_env, app, path, return}&lt;/code&gt; - traced whenever &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/3&quot;&gt;&lt;code&gt;Application.compile_env/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env!/2&quot;&gt;&lt;code&gt;Application.compile_env!/2&lt;/code&gt;&lt;/a&gt; are called. &lt;code&gt;app&lt;/code&gt; is an atom, &lt;code&gt;path&lt;/code&gt; is a list of keys to traverse in the application environment and &lt;code&gt;return&lt;/code&gt; is either &lt;code&gt;{:ok, value}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:compile_env, app, path, return}&lt;/code&gt; &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/3&quot;&gt; &lt;code&gt;Application.compile_env/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env!/2&quot;&gt; &lt;code&gt;Application.compile_env!/2&lt;/code&gt; &lt;/a&gt; 가 호출 될 때마다 추적 됩니다. &lt;code&gt;app&lt;/code&gt; 은 원자이고 &lt;code&gt;path&lt;/code&gt; 는 애플리케이션 환경에서 순회 할 키 목록이며 &lt;code&gt;return&lt;/code&gt; 은 &lt;code&gt;{:ok, value}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="9a4a7ed7743b808212846bc29e7788b55113c253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:cont, acc}&lt;/code&gt; to continue the reduction with &lt;code&gt;acc&lt;/code&gt; as the new accumulator or</source>
          <target state="translated">&lt;code&gt;{:cont, acc}&lt;/code&gt; 를 사용하여 &lt;code&gt;acc&lt;/code&gt; 를 새 축 압기로 계속 줄이거 나</target>
        </trans-unit>
        <trans-unit id="d680d1ab4f34debbf293fabb4c907ec127e5d9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - other (rare) error condition; for instance, &lt;code&gt;{:error, :estale}&lt;/code&gt; if reading from an NFS volume</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -기타 (드문) 오류 조건; 예를 들어, NFS 볼륨에서 읽을 경우 &lt;code&gt;{:error, :estale}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="583a02e135d23d6e385e3fd6dec1ef2ebace7264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - the file could not be opened.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b6d8de35ac50e9117049f505f7b0ce980f3a49c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, rest}&lt;/code&gt; - there are no switches at the head of the given &lt;code&gt;argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:error, rest}&lt;/code&gt; -주어진 &lt;code&gt;argv&lt;/code&gt; 의 헤드에 스위치가 없습니다</target>
        </trans-unit>
        <trans-unit id="905947e36e510a423fa76acaab54776f74a95e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has died</source>
          <target state="translated">&lt;code&gt;{:exit, reason}&lt;/code&gt; 작업이 종료 된 경우 {: 종료, 이유}</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; - 응용 프로그램이 배포되고 있기 때문에 노드에 장애 조치의 현재 노드에서 시작되는 경우에 사용 &lt;code&gt;node&lt;/code&gt; , 응용 프로그램 사양 키 &lt;code&gt;:start_phases&lt;/code&gt; 은 아니다 &lt;code&gt;:undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6493ada3691c289f4563082f5504570c40c851bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; - accesses file descriptors, &lt;code&gt;fd_in&lt;/code&gt; and &lt;code&gt;fd_out&lt;/code&gt; opened by the VM.</source>
          <target state="translated">&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; &lt;code&gt;fd_out&lt;/code&gt; 열린 파일 디스크립터 &lt;code&gt;fd_in&lt;/code&gt; 및 fd_out에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="14377d50e215463748eff219d9c02d214d948fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; - the GenServer is registered globally with the given term using the functions in the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; -GenServer는 &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 모듈&lt;/a&gt; 의 함수를 사용하여 주어진 용어로 전체적으로 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="53c120865859b22092af466d2b931e7ac0b771c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; if the server is globally registered</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; 서버가 전체적으로 등록 된 경우 {: global, term}</target>
        </trans-unit>
        <trans-unit id="ef45711b970d4f5ebbd374f8b94ce469f1caf938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:halt, acc}&lt;/code&gt; to halt the reduction</source>
          <target state="translated">&lt;code&gt;{:halt, acc}&lt;/code&gt; 감소를 중단시키는 {: halt, acc}</target>
        </trans-unit>
        <trans-unit id="06e121f623dc4144b41238906f22fa65a8ff1bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:import, meta, module, opts}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt; is imported. &lt;code&gt;meta&lt;/code&gt; is the import AST metadata and &lt;code&gt;opts&lt;/code&gt; are the import options.</source>
          <target state="translated">&lt;code&gt;{:import, meta, module, opts}&lt;/code&gt; - &lt;code&gt;module&lt;/code&gt; 을 가져올 때마다 추적 됩니다. &lt;code&gt;meta&lt;/code&gt; 가져 오기 AST 메타 데이터이며 &lt;code&gt;opts&lt;/code&gt; 는 가져 오기 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="38709f8fda71690dafe2be34764221212b52066c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:imported_function, meta, module, name, arity}&lt;/code&gt; and &lt;code&gt;{:imported_macro, meta, module, name, arity}&lt;/code&gt; - traced whenever an imported function or macro is invoked. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, &lt;code&gt;module&lt;/code&gt; is the module the import is from, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt; of the imported function/macro.</source>
          <target state="translated">&lt;code&gt;{:imported_function, meta, module, name, arity}&lt;/code&gt; 및 &lt;code&gt;{:imported_macro, meta, module, name, arity}&lt;/code&gt; -가져온 함수 또는 매크로가 호출 될 때마다 추적됩니다. &lt;code&gt;meta&lt;/code&gt; 는 호출 AST 메타 데이터이고, &lt;code&gt;module&lt;/code&gt; 은 가져 오기가 &lt;code&gt;arity&lt;/code&gt; 모듈이며 그 뒤에 가져온 함수 / 매크로 의 &lt;code&gt;name&lt;/code&gt; 과 배열이옵니다 .</target>
        </trans-unit>
        <trans-unit id="df2e65d7200b3a773f87421feb6af3b00afa9729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is invalid with &lt;code&gt;value&lt;/code&gt; (returned when the value cannot be parsed according to the switch type)</source>
          <target state="translated">&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; -옵션 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;value&lt;/code&gt; 유효하지 않습니다 (스위치 유형에 따라 값을 구문 분석 할 수없는 경우 반환 됨)</target>
        </trans-unit>
        <trans-unit id="d22ea9a831b4e750f4a7deb2f6398228dd603aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:local_function, meta, name, arity}&lt;/code&gt; and &lt;code&gt;{:local_macro, meta, name, arity}&lt;/code&gt; - traced whenever a local function or macro is referenced. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:local_function, meta, name, arity}&lt;/code&gt; 및 &lt;code&gt;{:local_macro, meta, name, arity}&lt;/code&gt; -로컬 함수 또는 매크로가 참조 될 때마다 추적됩니다. &lt;code&gt;meta&lt;/code&gt; 는 호출 AST 메타 데이터이며 그 뒤에 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;arity&lt;/code&gt; 가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="4d9e4ebeed749539e0779650148edbda53e98c0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:module_finished, test_module}&lt;/code&gt; - a test module has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:module_finished, test_module}&lt;/code&gt; -테스트 모듈이 완료되었습니다. &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="336e80413658853e833a1e7e92e6610ddd62c9d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:module_started, test_module}&lt;/code&gt; - a test module has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt;&lt;code&gt;ExUnit.TestModule&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:module_started, test_module}&lt;/code&gt; -테스트 모듈이 시작되었습니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.TestModule.html&quot;&gt; &lt;code&gt;ExUnit.TestModule&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70b5edb9ec5c74f3f67332fddbfa4c82e88ce245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; - if the message translation with its metadata</source>
          <target state="translated">&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; -메시지가 메타 데이터로 번역 된 경우</target>
        </trans-unit>
        <trans-unit id="996ab638f8c8d4d802e499bedf1f4770ab7fbb80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata}&lt;/code&gt; - the translated message</source>
          <target state="translated">&lt;code&gt;{:ok, chardata}&lt;/code&gt; -번역 된 메시지</target>
        </trans-unit>
        <trans-unit id="e3a6f52fcc50382042712f66d3261d0c08067f8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, io_device}&lt;/code&gt; - the file has been opened in the requested mode.</source>
          <target state="translated">&lt;code&gt;{:ok, io_device}&lt;/code&gt; -파일이 요청 된 모드에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="a0b6d7c9a83237db145690056b0e8a37a74e66c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; was successfully parsed</source>
          <target state="translated">&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - &lt;code&gt;value&lt;/code&gt; 이 있는 옵션 &lt;code&gt;key&lt;/code&gt; 가 구문 분석되었습니다.</target>
        </trans-unit>
        <trans-unit id="7268c1f7f90baff55c1875a554395341ede463ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, term}&lt;/code&gt; if the task has successfully reported its result back in the given time interval</source>
          <target state="translated">&lt;code&gt;{:ok, term}&lt;/code&gt; 작업이 주어진 시간 간격으로 결과를 성공적으로보고 한 경우 {: ok, term}</target>
        </trans-unit>
        <trans-unit id="5a0025dce43d3ec421b2a7d6b5d906ef9dfeda7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:remote_function, meta, module, name, arity}&lt;/code&gt; and &lt;code&gt;{:remote_macro, meta, module, name, arity}&lt;/code&gt; - traced whenever a remote function or macro is referenced. &lt;code&gt;meta&lt;/code&gt; is the call AST metadata, &lt;code&gt;module&lt;/code&gt; is the invoked module, followed by the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:remote_function, meta, module, name, arity}&lt;/code&gt; 및 &lt;code&gt;{:remote_macro, meta, module, name, arity}&lt;/code&gt; -원격 함수 또는 매크로가 참조 될 때마다 추적됩니다. &lt;code&gt;meta&lt;/code&gt; 는 호출 AST 메타 데이터이고, &lt;code&gt;module&lt;/code&gt; 은 호출 된 모듈이며 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;arity&lt;/code&gt; 가 뒤 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="4907bf582e669d083cd73a78fa6927d7145e6417" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:require, meta, module, opts}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt; is required. &lt;code&gt;meta&lt;/code&gt; is the require AST metadata and &lt;code&gt;opts&lt;/code&gt; are the require options.</source>
          <target state="translated">&lt;code&gt;{:require, meta, module, opts}&lt;/code&gt; - &lt;code&gt;module&lt;/code&gt; 이 필요할 때마다 추적 됩니다. &lt;code&gt;meta&lt;/code&gt; AST 메타 데이터와 요구되는 &lt;code&gt;opts&lt;/code&gt; 는 필수 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="ff00c961233a1e2c73ed6d683a2899cff9a55847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:runtime, modules, warnings}&lt;/code&gt; - to stop compilation and verify the list of modules because dependent modules have changed</source>
          <target state="translated">&lt;code&gt;{:runtime, modules, warnings}&lt;/code&gt; -종속 모듈이 변경되었으므로 컴파일을 중지하고 모듈 목록을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="15f17eecf5beefa66ca856a267346c5b572581dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn, command}&lt;/code&gt; - runs an external program. &lt;code&gt;command&lt;/code&gt; must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option.</source>
          <target state="translated">&lt;code&gt;{:spawn, command}&lt;/code&gt; -외부 프로그램을 실행합니다. &lt;code&gt;command&lt;/code&gt; 는 프로그램 이름과 선택적으로 공백으로 구분 된 인수 목록을 포함해야합니다. 이름에 공백이있는 프로그램이나 인수를 전달하는 경우 다음 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6ebca30f0cc1777601d5fcf5ac5189ec02cece8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; - spawns so-called port drivers.</source>
          <target state="translated">&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; -소위 포트 드라이버를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="66e3057e6196a07aafd175143d071fd417be195c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; - runs the executable given by the absolute file name &lt;code&gt;filename&lt;/code&gt;. Arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; -절대 파일 이름 &lt;code&gt;filename&lt;/code&gt; 으로 지정된 실행 파일을 실행합니다 . 인수는 &lt;code&gt;:args&lt;/code&gt; 옵션을 통해 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be94e236baf94b78cb30d77bbb4ebd4da68c9b56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:struct_expansion, meta, module, keys}&lt;/code&gt; - traced whenever &lt;code&gt;module&lt;/code&gt;'s struct is expanded. &lt;code&gt;meta&lt;/code&gt; is the struct AST metadata and &lt;code&gt;keys&lt;/code&gt; are the keys being used by expansion</source>
          <target state="translated">&lt;code&gt;{:struct_expansion, meta, module, keys}&lt;/code&gt; - &lt;code&gt;module&lt;/code&gt; 의 구조체가 확장 될 때마다 추적 됩니다. &lt;code&gt;meta&lt;/code&gt; 는 구조체 AST 메타 데이터이고 &lt;code&gt;keys&lt;/code&gt; 는 확장에 사용되는 키입니다.</target>
        </trans-unit>
        <trans-unit id="d1386d6f87a3f87789d9b775ccc84560bf0eae35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:suite_finished, run_us, load_us}&lt;/code&gt; - the suite has finished. &lt;code&gt;run_us&lt;/code&gt; and &lt;code&gt;load_us&lt;/code&gt; are the run and load times in microseconds respectively.</source>
          <target state="translated">&lt;code&gt;{:suite_finished, run_us, load_us}&lt;/code&gt; -스위트가 완료되었습니다. &lt;code&gt;run_us&lt;/code&gt; 및 &lt;code&gt;load_us&lt;/code&gt; 는 각각 마이크로 초 단위의 실행 및로드 시간입니다.</target>
        </trans-unit>
        <trans-unit id="a6e2e6cee0edee1861330cc7bd688a9ea27b8c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:suite_started, opts}&lt;/code&gt; - the suite has started with the specified options to the runner.</source>
          <target state="translated">&lt;code&gt;{:suite_started, opts}&lt;/code&gt; 지정된 옵션으로 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -응용 프로그램이 배포되고 노드 &lt;code&gt;node&lt;/code&gt; 의 장애 조치로 인해 현재 노드에서 시작된 경우 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="20e4bddf70360e9ac231b1938a4cb8644bf0a079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:test_finished, test}&lt;/code&gt; - a test has finished. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:test_finished, test}&lt;/code&gt; -테스트가 완료되었습니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="33cd63400c35c42b44de188a407ed8bc57ab11fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:test_started, test}&lt;/code&gt; - a test has started. See &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt;&lt;code&gt;ExUnit.Test&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;{:test_started, test}&lt;/code&gt; -테스트가 시작되었습니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Test.html&quot;&gt; &lt;code&gt;ExUnit.Test&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c26b97b81c2506b473edb7172c2f617dcec5b26d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms)</source>
          <target state="translated">&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; -옵션 &lt;code&gt;key&lt;/code&gt; 가 정의되지 않음 (스위치를 알 수 없거나 원자가없는 경우 엄격 모드로 반환)</target>
        </trans-unit>
        <trans-unit id="85bdb5005d451e7a63cf262238f500974e283030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, name}&lt;/code&gt; if the server is registered through an alternative registry</source>
          <target state="translated">&lt;code&gt;{:via, module, name}&lt;/code&gt; 서버가 대체 레지스트리를 통해 등록 된 경우 {: via, module, name}</target>
        </trans-unit>
        <trans-unit id="c5d0cf1ea956f6839d57a4b353eb908c39c5c01c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer는 주어진 메커니즘과 이름으로 등록됩니다. &lt;code&gt;:via&lt;/code&gt; 옵션을 수출하는 모듈 예상 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt; . 하나의 예는 Elixir 노드의 네트워크에 전역 적으로 사용 가능한 프로세스 이름 및 관련 PID 목록을 유지하기 위해 이러한 함수를 사용 하는 &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 모듈&lt;/a&gt; 입니다. Elixir는 또한 동적으로 생성되는 이름을 로컬에 저장하기 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 라고하는 분산되고 확장 가능한 로컬 레지스트리와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b29339dcb62621d0d8075c996c9fab09ff31622" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer는 지정된 메커니즘과 이름으로 등록됩니다. &lt;code&gt;:via&lt;/code&gt; 옵션을 수출하는 모듈 예상 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; 및 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt; . 이러한 예 중 하나는 &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 모듈&lt;/a&gt; 인데,이 기능을 사용하여 Elixir 노드 네트워크에 대해 전체적으로 사용 가능한 프로세스 이름 및 관련 PID 목록을 유지합니다. Elixir는 동적으로 생성 된 이름을 로컬에 저장하기 위해 &lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 라는 로컬, 분산 및 확장 가능한 레지스트리와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc2c818f59492934d15abff13439c0782289f3e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c6157992132973e0f3d822fb7bbb7d409431fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; is a tuple containing information about the logged message:</source>
          <target state="translated">&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; 는 기록 된 메시지에 대한 정보가 포함 된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="db1f5193dbaaf9fec82f82738b42e72b2810c7d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{atom, node}&lt;/code&gt; if the server is locally registered at another node</source>
          <target state="translated">&lt;code&gt;{atom, node}&lt;/code&gt; 서버가 다른 노드에 로컬로 등록 된 경우 {atom, node}</target>
        </trans-unit>
        <trans-unit id="2d5e8a342d00497e80fb0e1378891350b6989d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{item1,item2,...}&lt;/code&gt; - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;{item1,item2,...}&lt;/code&gt; -대안 중 하나와 일치합니다. 공백 문자 자체를 포함하는 경로와 일치하므로 쉼표 앞뒤에 공백을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a7691a8a9c5c0f0c080c5918b2771046501cab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{level, group_leader, {Logger, message, timestamp, metadata}}&lt;/code&gt; where:</source>
          <target state="translated">&lt;code&gt;{level, group_leader, {Logger, message, timestamp, metadata}}&lt;/code&gt; 여기서 :</target>
        </trans-unit>
        <trans-unit id="ac157d52ecf1d75482d9d1aeecc889281122e50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, :close}&lt;/code&gt; - closes the port. Unless the port is already closed, the port will reply with &lt;code&gt;{port, :closed}&lt;/code&gt; message once it has flushed its buffers and effectively closed. See &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, :close}&lt;/code&gt; -포트를 닫습니다. 포트가 이미 닫히지 않으면 포트는 버퍼를 비우고 효과적으로 닫으면 &lt;code&gt;{port, :closed}&lt;/code&gt; 메시지로 응답 합니다. &lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a895632430cc7c653dfc0e0b7e07abf543b5e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; - sends the given data to the port. See &lt;a href=&quot;#command/3&quot;&gt;&lt;code&gt;command/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; -주어진 데이터를 포트로 보냅니다. 참조 &lt;a href=&quot;#command/3&quot;&gt; &lt;code&gt;command/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="288f6592e3c497e594f8671f3ea30d712d05da67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - sets the &lt;code&gt;new_pid&lt;/code&gt; as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes &lt;code&gt;new_pid&lt;/code&gt; the new connected processes. Unless the port is dead, the port will reply to the old owner with &lt;code&gt;{port, :connected}&lt;/code&gt;. See &lt;a href=&quot;#connect/2&quot;&gt;&lt;code&gt;connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - &lt;code&gt;new_pid&lt;/code&gt; 를 포트의 새로운 소유자로 설정합니다 . 포트가 열리면 포트는 호출자 프로세스에 연결되고 연결되며 포트와의 통신은 연결된 프로세스를 통해서만 이루어집니다. 이 메시지는 &lt;code&gt;new_pid&lt;/code&gt; 를 새로운 연결된 프로세스로 만듭니다. 포트가 작동하지 않으면 포트는 &lt;code&gt;{port, :connected}&lt;/code&gt; 이전 소유자에게 응답합니다 . &lt;a href=&quot;#connect/2&quot;&gt; &lt;code&gt;connect/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e874c9f986bcbc4835de87b79c60801c982748f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :closed}&lt;/code&gt; - reply to the &lt;code&gt;{pid, :close}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :closed}&lt;/code&gt; - &lt;code&gt;{pid, :close}&lt;/code&gt; 메시지에 회신</target>
        </trans-unit>
        <trans-unit id="fa93e43d244395859c46aade03423cd222f87032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :connected}&lt;/code&gt; - reply to the &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :connected}&lt;/code&gt; - &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; 메시지에 회신</target>
        </trans-unit>
        <trans-unit id="efc9c7697827d4669aad3228ed4c07741bb10c50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, {:data, data}}&lt;/code&gt; - data sent by the port</source>
          <target state="translated">&lt;code&gt;{port, {:data, data}}&lt;/code&gt; -포트에서 전송 한 데이터</target>
        </trans-unit>
        <trans-unit id="8331cbf97282804d067bb29ba8bd9b7caf6144bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a1fc7b83a3791c9f16933b021a993fc251a976d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 와 &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c515caea553b7a18b81d363c568a315a5150f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="036d3dd0689aaa1e1f2cd3395422e4acf8dcaf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&amp;gt;&lt;/code&gt; will never include pre-release versions of its upper bound, regardless of the usage of the &lt;code&gt;:allow_pre&lt;/code&gt; option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for &lt;code&gt;~&amp;gt;&lt;/code&gt; requirements and their corresponding translations.</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; 는 &lt;code&gt;:allow_pre&lt;/code&gt; 옵션 의 사용 또는 피연산자가 시험판 버전인지 여부에 상관없이 시험판 버전의 상한을 포함하지 않습니다 . 주 버전 부분에만 상한을 설정하는 데에도 사용할 수 있습니다. &lt;code&gt;~&amp;gt;&lt;/code&gt; 요구 사항 및 해당 번역에 대해서는 아래 표를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3a808d1b26854bfff9e3a0b3845ea1a05448e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e23e262f305f153040f0582095898a4190393fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09579eaf4feb9e28fce9fc17746e4ff55890bca0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;None&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;None&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d79e4e6ea4fe26e44ae09fe2933d731631027ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: unlike &lt;code&gt;@after_compile&lt;/code&gt;, the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist).</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;@after_compile&lt;/code&gt; 과 달리 콜백 함수 / 매크로는 별도의 모듈에 배치해야합니다 (콜백이 호출 될 때 현재 모듈이 아직 없기 때문에).</target>
        </trans-unit>
        <trans-unit id="4f08c9a12c9ca68459deea27c07cfa5cbf312698" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The leading underscore in &lt;code&gt;_sep&lt;/code&gt; means that the variable will be ignored in this function; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;_sep&lt;/code&gt; 에서 밑줄 은 변수가이 함수에서 무시 됨을 의미합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;명명 규칙을&lt;/a&gt; 참조하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d76d0c90116afc56a7d7c36ee9aa1c61ab7189e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The trailing question mark in &lt;code&gt;zero?&lt;/code&gt; means that this function returns a boolean; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;후행 물음표는 &lt;code&gt;zero?&lt;/code&gt; 이 함수는 부울을 리턴 함을 의미합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;명명 규칙을&lt;/a&gt; 참조하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64b3259a23cbcee4b6f5269de5bf892f183bee1a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API Reference</source>
          <target state="translated">&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API 참조</target>
        </trans-unit>
        <trans-unit id="ecdafb6979a08deb1f64b585c6ae8d1c3aad60c6" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Getting Started&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;시작하기&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b4788aa3df60b3245cde2a89f8ad4433addb6e87" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Meta-programming in Elixir&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;Elixir의 메타 프로그래밍&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5989ccc62afedfde6898bb6ed0007714bf2b045b" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Mix and OTP&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;믹스 및 OTP&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3775fefac93bd98a436d0d00b0aab5a204bb7bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a test-unit based framework that ships with Elixir;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 은 Elixir와 함께 제공되는 테스트 단위 기반 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="79fc31f88ea6f7006047293577c94843734d6c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 는 Elixir와 함께 제공되는 빌드 도구로, 응용 프로그램 작성, 컴파일, 테스트, 종속성 관리 등의 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7760e740159ba1e4a18006d398566be346370d1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;(Open Telecom Platform)&lt;/em&gt; is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; (Open Telecom Platform)&lt;/em&gt; 는 Erlang과 함께 제공되는 라이브러리 세트입니다. Erlang 개발자는 OTP를 사용하여 강력하고 내결함성이있는 애플리케이션을 구축합니다. 이 장에서는 감독 트리, 이벤트 관리자 등 OTP의 몇 가지 측면이 Elixir와 통합되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="88c0e166c78e581a32cc00488db4dd2a2485ff1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A binary is a bitstring where the number of bits is divisible by 8.&lt;/strong&gt; That means that every binary is a bitstring, but not every bitstring is a binary. We can use the &lt;code&gt;is_bitstring/1&lt;/code&gt; and &lt;code&gt;is_binary/1&lt;/code&gt; functions to demonstrate this.</source>
          <target state="translated">&lt;strong&gt;바이너리는 비트 수를 8로 나눌 수있는 비트 문자열입니다.&lt;/strong&gt; 즉, 모든 바이너리가 비트 문자열이지만 모든 비트 문자열이 바이너리 인 것은 아닙니다. 우리는 사용할 수 &lt;code&gt;is_bitstring/1&lt;/code&gt; 및 &lt;code&gt;is_binary/1&lt;/code&gt; 이를 입증하는 기능.</target>
        </trans-unit>
        <trans-unit id="336831bc9d7d14d606049e8d100d4d10f2fcd283" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A charlist is a list of integers where all the integers are valid code points.&lt;/strong&gt; In practice, you will not come across them often, except perhaps when interfacing with Erlang, in particular when using older libraries that do not accept binaries as arguments.</source>
          <target state="translated">&lt;strong&gt;charlist는 모든 정수가 유효한 코드 포인트 인 정수 목록입니다. &lt;/strong&gt;실제로, Erlang과 인터페이스 할 때를 제외하고, 특히 바이너리를 인수로 받아들이지 않는 오래된 라이브러리를 사용할 때를 제외하고는 자주 접하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e636b218c0e3e0b13d91ec18a5e99e58de43d704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A string is a UTF-8 encoded binary&lt;/strong&gt;, where the code point for each character is encoded using 1 to 4 bytes. Thus every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string.</source>
          <target state="translated">&lt;strong&gt;문자열은 UTF-8로 인코딩 된 바이너리&lt;/strong&gt; 이며 각 문자의 코드 포인트는 1 ~ 4 바이트를 사용하여 인코딩됩니다. 따라서 모든 문자열은 바이너리이지만 UTF-8 표준 인코딩 규칙으로 인해 모든 바이너리가 유효한 문자열은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="08113db7fca81fb8e42233f3eb8aa29c2802e31c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see &lt;a href=&quot;#compile_env!/2&quot;&gt;&lt;code&gt;compile_env!/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;중요 :&lt;/strong&gt; 예를 들어 함수 내부가 아닌 모듈 정의 내부와 같이 컴파일 시간에 애플리케이션 환경을 읽는 경우 대신 &lt;a href=&quot;#compile_env!/2&quot;&gt; &lt;code&gt;compile_env!/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a738399c9df445c8f274660ea67228dc4666ce43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are reading the application environment at compilation time, for example, inside the module definition instead of inside of a function, see &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;중요 :&lt;/strong&gt; 예를 들어 함수 내부가 아닌 모듈 정의 내부와 같이 컴파일 시간에 애플리케이션 환경을 읽는 경우 대신 &lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45bdb2bd826dc57156f3bf24a36a9c22bb6b679a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our &lt;a href=&quot;library-guidelines&quot;&gt;library guidelines&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중요 사항 :&lt;/strong&gt; 다른 개발자가 사용할 라이브러리를 작성하는 경우 애플리케이션 환경은 사실상 글로벌 스토리지이므로 애플리케이션 환경을 피하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;library-guidelines&quot;&gt;라이브러리 지침을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cebf98b4bce979e6d8b77444f797642d0aeb4c22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: in Elixir, you don&amp;rsquo;t have to define the &lt;code&gt;Foo&lt;/code&gt; module before being able to define the &lt;code&gt;Foo.Bar&lt;/code&gt; module, as the language translates all module names to atoms. You can define arbitrarily-nested modules without defining any module in the chain (e.g., &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; without defining &lt;code&gt;Foo&lt;/code&gt; or &lt;code&gt;Foo.Bar&lt;/code&gt; first).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Elixir에서는 언어가 모든 모듈 이름을 원자로 변환 하므로 &lt;code&gt;Foo.Bar&lt;/code&gt; 모듈 을 정의하기 전에 &lt;code&gt;Foo&lt;/code&gt; 모듈 을 정의 할 필요가 없습니다 . 사용자는 (예를 들면, 체인의 모든 모듈을 정의하지 않고 임의로 중첩 모듈을 정의 할 수 &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; 을 정의하지 않고 &lt;code&gt;Foo&lt;/code&gt; 또는 &lt;code&gt;Foo.Bar&lt;/code&gt; 첫번째).</target>
        </trans-unit>
        <trans-unit id="4830045d3f9fb785bdafea364ad01a0303638b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this function must be used only for debugging purposes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 기능은 디버깅 목적으로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c1f94fbf601c6ec501544925ca954903163e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this function with extreme care&lt;/strong&gt;. For almost all situations where you would use &lt;a href=&quot;#sleep/1&quot;&gt;&lt;code&gt;sleep/1&lt;/code&gt;&lt;/a&gt; in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing.</source>
          <target state="translated">&lt;strong&gt;이 기능은 매우주의해서 사용하십시오&lt;/strong&gt; . Elixir에서 &lt;a href=&quot;#sleep/1&quot;&gt; &lt;code&gt;sleep/1&lt;/code&gt; &lt;/a&gt; 을 사용하는 거의 모든 상황에서 메시지 전달을 통해보다 정확하고 빠르며 정확한 방법을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac3b6f8e5ab64ac8a9b9ba5343d9c93a85c8ca8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 함수가 호출 될 때마다 파일 설명자가 열리고 파일에 쓰기 위해 새 프로세스가 생성됩니다. 이러한 이유로 루프에서 여러 번 쓰기를 수행하는 경우 &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt; 를 통해 파일을 열고 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 의 함수를 사용 하여 파일에 기록하면이 함수를 여러 번 호출하는 것보다 훨씬 더 나은 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d8fa24c5f50dfc16b2c10bf309baf5a47726342" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;file#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 함수가 호출 될 때마다 파일 디스크립터가 열리고 파일에 쓸 새 프로세스가 생성됩니다. 이러한 이유로 루프에서 여러 번 쓰기를 수행하는 경우 &lt;a href=&quot;file#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt; 를 통해 파일을 열고 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 의 함수를 사용 하여 파일에 쓰면이 함수를 여러 번 호출하는 것보다 훨씬 나은 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365ce4331359866dc083be4a975f43b82fadac5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#compile_string/2&quot;&gt;&lt;code&gt;compile_string/2&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;string&lt;/code&gt; 은 모든 Elixir 코드 일 수 있으며 Erlang VM과 동일한 권한으로 코드를 실행할 수 있습니다. 즉, 이러한 코드는 시스템 명령을 실행하여 시스템을 손상시킬 수 있습니다. 신뢰할 수없는 입력 (예 : 네트워크에서 오는 문자열)과 함께 &lt;a href=&quot;#compile_string/2&quot;&gt; &lt;code&gt;compile_string/2&lt;/code&gt; &lt;/a&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9945569acc699104fbc382a7f6902cdbb849ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;string&lt;/code&gt; 은 모든 Elixir 코드 일 수 있으며 Erlang VM과 동일한 권한으로 실행됩니다. 즉, 이러한 코드는 시스템 명령을 실행하여 시스템을 손상시킬 수 있습니다. 신뢰할 수없는 입력 (예 : 네트워크에서 오는 문자열)과 함께 &lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="2875bd2bb7c9486ad98cafa18ea844a4e68bfa0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 매크로 내에서이 함수를 호출하면 컴파일 타임에 런타임 값을 평가하려고하므로 나쁜 습관으로 간주됩니다. 매크로 인수는 일반적으로 평가 대신에 인용 된 표현식으로 인용 부호를 지정하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="993e7a2f2e8a8af096a402bf2629008a4fb49467" translate="yes" xml:space="preserve">
          <source>= (2)</source>
          <target state="translated">= (2)</target>
        </trans-unit>
        <trans-unit id="070f4bb5062b181b2dab5baebd4e926e8227b544" translate="yes" xml:space="preserve">
          <source>== (2)</source>
          <target state="translated">== (2)</target>
        </trans-unit>
        <trans-unit id="80782192fde18010086342ec452afa4a2968c387" translate="yes" xml:space="preserve">
          <source>=== (2)</source>
          <target state="translated">=== (2)</target>
        </trans-unit>
        <trans-unit id="7d042330e275b9df07c1b99a60576379d66570eb" translate="yes" xml:space="preserve">
          <source>=~ (2)</source>
          <target state="translated">= ~ (2)</target>
        </trans-unit>
        <trans-unit id="3ac5ef8377daeb708c25b635e6c467ff0bfcb4e4" translate="yes" xml:space="preserve">
          <source>@expr</source>
          <target state="translated">@expr</target>
        </trans-unit>
        <trans-unit id="3fb5c30970be466c24df6f91f050369f404a45eb" translate="yes" xml:space="preserve">
          <source>@expr (1)</source>
          <target state="translated">@expr (1)</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="212381917bbc6314dd3515bae3faeae224b2edde" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use GenServer&lt;/code&gt;, it automatically defines a &lt;code&gt;child_spec/1&lt;/code&gt; function that allows us to start the &lt;code&gt;Stack&lt;/code&gt; directly under a supervisor. To start a default stack of &lt;code&gt;[:hello]&lt;/code&gt; under a supervisor, one may do:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 는&lt;/a&gt; 가장 일반적으로 감독의 나무 아래에서 시작됩니다. &lt;code&gt;use GenServer&lt;/code&gt; 을 호출 하면 Supervisor 에서 직접 &lt;code&gt;Stack&lt;/code&gt; 을 시작할 수 있는 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 자동으로 정의합니다 . 수퍼바이저에서 &lt;code&gt;[:hello]&lt;/code&gt; 의 기본 스택을 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b04250c280e3b81f91e1d5dd337c0df8de26b240" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is represented internally using the &lt;code&gt;%MapSet{}&lt;/code&gt; struct. This struct can be used whenever there's a need to pattern match on something being a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 에이&lt;/a&gt; 은 USING 내부 표현 &lt;code&gt;%MapSet{}&lt;/code&gt; 구조체. 이 구조체는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 인&lt;/a&gt; 무언가에 패턴 일치가 필요할 때마다 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5592a96e74b3dea455cad3a6cdcc2a71d33e7e9c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; IO 장치가있는 대부분의 기능을 &quot;장치&quot;로서 전달 될 수 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="96991deff4ed5a082a254d0673af19964e04b750" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; IO 장치가있는 대부분의 기능을 &quot;장치&quot;로서 전달 될 수 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="11c30e3595630fd2ed85f755977f5e0806af282c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 는&lt;/a&gt; A와 같은 이름의 등록 규칙에 바인딩 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서 에서 자세한 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b2e4d521318bcdf190d785d923c77a3515720622" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 는&lt;/a&gt; A와 같은 이름의 등록 규칙에 바인딩 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서 에서 이에 대해 자세히 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="55645d6c06d3271f36e9be3f5d20e93cd6d7aa12" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">관련 정보가 포함 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 구조체가 반환됩니다. 개발자는 결국 반환 된 작업에서 &lt;a href=&quot;#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt; 다음에 &lt;a href=&quot;#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="04a844239e65727f5eb23023aa50bf8c3c86fe4c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;task#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">관련 정보가 포함 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 구조체가 반환됩니다. 개발자는 결국 호출해야합니다 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;task#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt; 다음 &lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; 반환 작업에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99b78808a672297ddd7132ed2c68ad7b242b61f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;%Date{}&lt;/a&gt; struct contains the fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, and &lt;code&gt;calendar&lt;/code&gt;. You can create one using the &lt;code&gt;~D&lt;/code&gt; sigil:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html&quot;&gt;% 날짜 {}&lt;/a&gt; 구조체 필드를 포함 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;day&lt;/code&gt; 및 &lt;code&gt;calendar&lt;/code&gt; . &lt;code&gt;~D&lt;/code&gt; 시길을 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca463d32e6d6ecf67f11f02d3da51e0794706014" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;%DateTime{}&lt;/a&gt; struct contains the same fields as a &lt;code&gt;NaiveDateTime&lt;/code&gt; with the addition of fields to track timezones. The &lt;code&gt;~U&lt;/code&gt; sigil allows developers to create a DateTime in the UTC timezone:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;% 날짜 시간 {}&lt;/a&gt; 구조체는 동일한 필드가 포함 &lt;code&gt;NaiveDateTime&lt;/code&gt; 시간대를 추적 필드가 추가한다. &lt;code&gt;~U&lt;/code&gt; 시길 개발자는 UTC 시간대의 날짜 시간을 만들 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9a8c365525108d9b02bcf9ac0efff934b78be9b7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--module&lt;/code&gt; option can be given in order to name the modules in the generated code skeleton.</source>
          <target state="translated">&lt;code&gt;--module&lt;/code&gt; 옵션은 생성 된 코드 골격의 모듈 이름을하기 위해 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ae153a76bb9eaf92dda3893cc5ead4482398e3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--sup&lt;/code&gt; option can be given to generate an OTP application skeleton including a supervision tree. Normally an app is generated without a supervisor and without the app callback.</source>
          <target state="translated">&lt;code&gt;--sup&lt;/code&gt; 옵션은 감독 트리를 포함한 골격 OTP 애플리케이션을 생성하기 위해 부여 할 수 있습니다. 일반적으로 앱은 감독자 및 앱 콜백없이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6b893cfed0032b8cee12fcb9d4b611446984d618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:name&lt;/code&gt; option could also be given to &lt;code&gt;Agent.start_link/2&lt;/code&gt; and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called &lt;code&gt;GenServer&lt;/code&gt;), tasks, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt; which will build a complete Elixir application from start to finish.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 부여 할 수 &lt;code&gt;Agent.start_link/2&lt;/code&gt; 및 자동 등록됩니다. 에이전트 외에도 Elixir는 일반 서버 ( &lt;code&gt;GenServer&lt;/code&gt; 라고 함 ), 작업 등 을 구축 할 수있는 API를 제공합니다 . 그것들은 감독 트리와 함께 &lt;strong&gt;&lt;em&gt;Mix and OTP 안내서&lt;/em&gt;&lt;/strong&gt; 에서 더 자세히 살펴볼 것입니다.이 &lt;strong&gt;&lt;em&gt;안내서&lt;/em&gt;&lt;/strong&gt; 는 처음부터 끝까지 완전한 Elixir 응용 프로그램을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e18a4ffc55e5c9028c4e176af5316103f1339b8d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;post_config&lt;/code&gt; can be passed that will be merged into the project configuration.</source>
          <target state="translated">&lt;code&gt;post_config&lt;/code&gt; 은 프로젝트 구성에 병합 될 것이다 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953f85d383aa733b4232421e096ff53630a36ae0" translate="yes" xml:space="preserve">
          <source>A Date struct and functions.</source>
          <target state="translated">Date 구조체와 함수</target>
        </trans-unit>
        <trans-unit id="41bff3f5550cc14457144dffbdae442d3deffbd2" translate="yes" xml:space="preserve">
          <source>A GUI should pop-up containing all sorts of information about our system, from general statistics to load charts as well as a list of all running processes and applications.</source>
          <target state="translated">일반 통계에서로드 차트, 실행중인 모든 프로세스 및 응용 프로그램 목록에 이르기까지 시스템에 대한 모든 종류의 정보가 포함 된 GUI가 팝업되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce30e5498af53503d24e931e06501bf314a92d8d" translate="yes" xml:space="preserve">
          <source>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</source>
          <target state="translated">GenServer는 다른 Elixir 프로세스와 같은 프로세스이며 상태를 유지하고 코드를 비동기식으로 실행하는 데 사용할 수 있습니다. 이 모듈을 사용하여 구현 된 일반 서버 프로세스 (GenServer)의 장점은 표준 인터페이스 기능 세트를 가지며 추적 및 오류보고 기능을 포함한다는 것입니다. 또한 감시 트리에도 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e1d021610e2e2d5fff8dcc8068b986d35f87da19" translate="yes" xml:space="preserve">
          <source>A GenServer is a process that invokes a limited set of functions under specific conditions. When we used an &lt;code&gt;Agent&lt;/code&gt;, we would keep both the client code and the server code side by side, like this:</source>
          <target state="translated">GenServer는 특정 조건 하에서 제한된 기능 세트를 호출하는 프로세스입니다. &lt;code&gt;Agent&lt;/code&gt; 를 사용할 때 다음 과 같이 클라이언트 코드와 서버 코드를 나란히 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fa09e34f4344d6d1e3072b5dbac5303f17145bcc" translate="yes" xml:space="preserve">
          <source>A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we&amp;rsquo;ll use a single module for both the server callbacks and the client API.</source>
          <target state="translated">GenServer는 클라이언트 API와 서버 콜백의 두 부분으로 구현됩니다. 두 부분을 단일 모듈로 결합하거나 클라이언트 모듈과 서버 모듈로 분리 할 수 ​​있습니다. 클라이언트는 클라이언트 기능을 호출하는 모든 프로세스입니다. 서버는 항상 프로세스 식별자 또는 프로세스 이름으로 클라이언트 API에 인수로 명시 적으로 전달합니다. 여기서는 서버 콜백과 클라이언트 API 모두에 단일 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c3564c401d9bcae5f982375952ba5b0f96579bf" translate="yes" xml:space="preserve">
          <source>A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes.</source>
          <target state="translated">시스템의 런타임 특성을 모델링하려면 GenServer 또는 일반적인 프로세스를 사용해야합니다. 코드 구성 목적으로 GenServer를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6c4080de87ee470f7abb62ce27d54db9157b6efe" translate="yes" xml:space="preserve">
          <source>A Mix compiler task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task.Compiler&lt;/code&gt;&lt;/a&gt; in a module whose name starts with &lt;code&gt;Mix.Tasks.Compile.&lt;/code&gt; and defining the &lt;a href=&quot;#c:run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Mix 컴파일러 작업은 이름이 &lt;code&gt;Mix.Tasks.Compile.&lt;/code&gt; 시작하는 모듈에서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task.Compiler&lt;/code&gt; &lt;/a&gt; 를 사용하여 정의 할 수 있습니다 . &lt;a href=&quot;#c:run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 함수 정의 :</target>
        </trans-unit>
        <trans-unit id="4c204de36640465711bc67da137f234cf9e4f98d" translate="yes" xml:space="preserve">
          <source>A Mix project is defined by calling &lt;code&gt;use Mix.Project&lt;/code&gt; in a module, usually placed in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">믹스 프로젝트는 보통 &lt;code&gt;mix.exs&lt;/code&gt; 에 배치 된 모듈에서 &lt;code&gt;use Mix.Project&lt;/code&gt; 을 호출 하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4077ad8fe6f71eae596391489d6e96f0ea24015b" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module starting with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and defining the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Mix 작업은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; s&lt;/a&gt; 로 시작하는 모듈에서 Mix.Task 를 사용하여 간단히 정의 할 수 있습니다 &lt;code&gt;Mix.Tasks.&lt;/code&gt; &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="56400b7c36038183acc14a25e0a3549d626f0ddc" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module whose name begins with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and which defines the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function. Typically, task modules live inside the &lt;code&gt;lib/mix/tasks/&lt;/code&gt; directory, and their file names use dot separators instead of underscores (e.g. &lt;code&gt;deps.clean.ex&lt;/code&gt;) - although ultimately the file name is not relevant.</source>
          <target state="translated">Mix 태스크는 이름이 &lt;code&gt;Mix.Tasks.&lt;/code&gt; 시작하는 모듈에서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; &lt;/a&gt; 를 사용하여 정의 할 수 있습니다 . 그리고 이것은 &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 함수 를 정의합니다 . 일반적으로 작업 모듈은 &lt;code&gt;lib/mix/tasks/&lt;/code&gt; 디렉토리에 있으며 파일 이름은 밑줄 대신 점 구분 기호를 사용합니다 (예 : &lt;code&gt;deps.clean.ex&lt;/code&gt; )-궁극적으로 파일 이름은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed54926907bf0ba78a3375ef0d22019252f3389e" translate="yes" xml:space="preserve">
          <source>A NaiveDateTime struct (without a time zone) and functions.</source>
          <target state="translated">NaiveDateTime 구조체 (시간대 제외) 및 기능.</target>
        </trans-unit>
        <trans-unit id="555fb6c5e065889ab4dcadeaa574e32486d7fb5d" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind it is not guaranteed two regular expressions from the same source are equal, for example:</source>
          <target state="translated">정규식은 내부적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 구조체로 표시됩니다. 따라서 &lt;code&gt;%Regex{}&lt;/code&gt; 는 일치해야 할 때마다 사용할 수 있습니다. 예를 들어, 동일한 소스에서 나온 두 개의 정규 표현식이 동일하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b641f005f95d171d045430ceaf72d4ba2227ac3" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind that all of the structs fields are private. There is also not guarantee two regular expressions from the same source are equal, for example:</source>
          <target state="translated">Regex는 내부적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 구조체 로 표현됩니다 . 따라서 &lt;code&gt;%Regex{}&lt;/code&gt; 는 일치해야 할 때마다 사용할 수 있습니다. 모든 structs 필드는 비공개라는 점에 유의하세요. 또한 동일한 소스의 두 정규 표현식이 동일하다는 보장도 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2afaaf5f34eb9535b346406765e25f28777ebcbf" translate="yes" xml:space="preserve">
          <source>A String in Elixir is a UTF-8 encoded binary.</source>
          <target state="translated">Elixir의 문자열은 UTF-8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="1d40f8897ae8fea751dfe1a3787ebde9eaf60e69" translate="yes" xml:space="preserve">
          <source>A TCP server, in broad strokes, performs the following steps:</source>
          <target state="translated">광범위한 스트로크로 TCP 서버는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9b4c21dfcd9b32e19a4da6bba2ed1b078799abfe" translate="yes" xml:space="preserve">
          <source>A Time struct and functions.</source>
          <target state="translated">시간 구조와 기능.</target>
        </trans-unit>
        <trans-unit id="8ed92df07fe6e75daa797531db7710c5a365538d" translate="yes" xml:space="preserve">
          <source>A UTF-8 code point. It may be one or more bytes.</source>
          <target state="translated">UTF-8 코드 포인트 하나 이상의 바이트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4551e142fcb8c6dfcab6f6c771c1757c5d408c6" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded binary.</source>
          <target state="translated">UTF-8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="c6baac594934e18050d15b336369478a962b486d" translate="yes" xml:space="preserve">
          <source>A basic setup for ExUnit is shown below:</source>
          <target state="translated">ExUnit의 기본 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d872a4d789410051d4047736ebac85378931dcb1" translate="yes" xml:space="preserve">
          <source>A beginning is inclusive. An ending is exclusive. Eg. if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00, the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00.</source>
          <target state="translated">시작은 포괄적입니다. 엔딩은 배타적입니다. 예 : 기간이 2015-03-29 01:00:00부터 2015-10-25 01:00:00까지 인 경우 기간은 2015-03-29 01:00:00을 포함하여 시작하여 2015-03-29 01:00:00부터 시작하여 2015-10-25 01:00:00 직전에.</target>
        </trans-unit>
        <trans-unit id="4b46e9949a74e5098958730c1a927a02cf0e1c74" translate="yes" xml:space="preserve">
          <source>A beginning or end for certain periods are infinite. For instance the latest period for time zones without DST or plans to change. However for the purpose of this behaviour they are only used for gaps in wall time where the needed period limits are at a certain time.</source>
          <target state="translated">특정 기간의 시작 또는 끝은 무한합니다. 예를 들어 DST가 없거나 시간대를 변경하려는 시간대의 최신 기간입니다. 그러나이 동작의 목적을 위해 필요한 시간 제한이 특정 시간에있는 벽 시간 간격에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb34fc850ae56e44c450bb71c054995b2321814e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">비헤이비어 모듈은 해당 비헤이비어를 구현하는 콜백 모듈이 내 보내야하는 함수 및 매크로 ( &lt;em&gt;콜백&lt;/em&gt; 이라고 함) 세트를 정의 합니다. 이 &quot;인터페이스&quot;는 구성 요소의 특정 부분을 식별합니다. 예를 들어, &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 동작 및 기능은 &quot;서버&quot;프로세스가이 서버 프로세스가 수행해야하는 작업과 같은 특정 부분에서 구현하고자하는 모든 메시지 전달 (송수신) 및 오류보고를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="db41558e90a255b03a8dc01169dd1f98b2391f4e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">비헤이비어 모듈은 해당 비헤이비어를 구현하는 콜백 모듈이 내 보내야 하는 일련의 함수 및 매크로 ( &lt;em&gt;콜백&lt;/em&gt; 이라고 함)를 정의 합니다. 이 &quot;인터페이스&quot;는 구성 요소의 특정 부분을 식별합니다. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 동작 및 기능은 &quot;서버&quot;프로세스가이 서버 프로세스가 수행해야하는 작업과 같은 특정 부분에서 구현하기를 원할 것이라는 모든 메시지 전달 (송신 및 수신) 및 오류보고를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="7c9e867bc2a6fb80d40eab6dcf2caa49046c25ae" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing supervisors.</source>
          <target state="translated">감독자를 구현하기위한 행동 모듈.</target>
        </trans-unit>
        <trans-unit id="605d4ad9d9fdab9c7d0d8facad9343748a300de2" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing the server of a client-server relation.</source>
          <target state="translated">클라이언트-서버 관계의 서버를 구현하기위한 행동 모듈.</target>
        </trans-unit>
        <trans-unit id="00f8ebc260124e1ab7b63ede984d78166228dd40" translate="yes" xml:space="preserve">
          <source>A better function definition would be:</source>
          <target state="translated">더 나은 기능 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">바이너리는 항상 완전한 바이트 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d08e886402089500f760cd62e9be33847d11368c" translate="yes" xml:space="preserve">
          <source>A binary is a sequence of bytes. Those bytes can be organized in any way, even in a sequence that does not make them a valid string:</source>
          <target state="translated">이진은 일련의 바이트입니다. 이러한 바이트는 유효한 문자열이 아닌 순서로도 어떤 방식 으로든 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4b7277d1938d9dc02215252a72af388262f382" translate="yes" xml:space="preserve">
          <source>A bitstring generator can be mixed with &amp;ldquo;regular&amp;rdquo; enumerable generators, and supports filters as well.</source>
          <target state="translated">비트 스트링 생성기는 &quot;일반&quot;열거 가능 생성기와 혼합 할 수 있으며 필터도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="18fa63ca56fa56c911a7c87acd788299f0b5e786" translate="yes" xml:space="preserve">
          <source>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</source>
          <target state="translated">비트 열은 많은 세그먼트로 구성되며 각 세그먼트에는 유형이 있습니다. 비트 열에는 9 가지 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cc225102a641a743fb78156d8a9bef53771d8" translate="yes" xml:space="preserve">
          <source>A byte of Erlang</source>
          <target state="translated">얼랭 바이트</target>
        </trans-unit>
        <trans-unit id="79fd446d748480ae656763877da9c4cf859f5647" translate="yes" xml:space="preserve">
          <source>A calendar implementation</source>
          <target state="translated">캘린더 구현</target>
        </trans-unit>
        <trans-unit id="45adc33f9e352c348aeb6f71e9cae2cc39cef184" translate="yes" xml:space="preserve">
          <source>A calendar implementation that follows to ISO 8601.</source>
          <target state="translated">ISO 8601을 따르는 캘린더 구현.</target>
        </trans-unit>
        <trans-unit id="abb29a18596674b0600471f06a0b774c5ee65d42" translate="yes" xml:space="preserve">
          <source>A captured remote function in the format of &amp;amp;Mod.fun/arity</source>
          <target state="translated">&amp;amp; Mod.fun / arity 형식으로 캡처 된 원격 함수</target>
        </trans-unit>
        <trans-unit id="4983d0390c0cc88fb62df8a53e3ded20887e73ee" translate="yes" xml:space="preserve">
          <source>A charlist is nothing more than a list of code points. Char lists may be created with single-quoted literals:</source>
          <target state="translated">charlist는 코드 포인트 목록에 지나지 않습니다. 작은 따옴표로 리터럴을 사용하여 문자 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14e2847d8fdb35b747294036ae2ad35a22ccd61" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to a string to see its inner binary representation:</source>
          <target state="translated">Elixir의 일반적인 트릭은 null 바이트 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 을 문자열에 연결하여 내부 이진 표현을 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ab960785cbfb3aadf16ce8c8af561b378d6faa72" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir when you want to see the inner binary representation of a string is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to it:</source>
          <target state="translated">Elixir에서 문자열의 내부 바이너리 표현을보고 싶을 때 일반적인 트릭은 null 바이트 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 를 여기 에 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1bfb26f32033c8d890b9980e9f88f657ab247fd3" translate="yes" xml:space="preserve">
          <source>A common use case of &lt;code&gt;:into&lt;/code&gt; can be transforming values in a map, without touching the keys:</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 의 일반적인 사용 사례 는 키를 터치하지 않고도 맵에서 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f0ae652ebbfbd5531320563e778f58becfe7bb" translate="yes" xml:space="preserve">
          <source>A compiled pattern can also be given:</source>
          <target state="translated">컴파일 된 패턴도 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76869e54063c0294aaea20a8943a0f7504376d4" translate="yes" xml:space="preserve">
          <source>A compiled pattern:</source>
          <target state="translated">컴파일 된 패턴 :</target>
        </trans-unit>
        <trans-unit id="0d84ab3be01cbc1dc689657ecb9175e041485e11" translate="yes" xml:space="preserve">
          <source>A compiler supports the same attributes for configuration and documentation as a regular Mix task. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">컴파일러는 일반 Mix 태스크와 동일한 구성 및 문서 속성을 지원합니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Task.html&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4854fa789ccf4924d0dea2f4dbb87c84c9909913" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;.</source>
          <target state="translated">바이너리 / 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 에 대한 완전한 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;는 Elixir 문서에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ab1c60e70dbccd5bb3b6385dfc22cb20961df9" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;. This concludes our tour of bitstrings, binaries and strings. A string is a UTF-8 encoded binary and a binary is a bitstring where the number of bits is divisible by 8. Although this shows the flexibility Elixir provides for working with bits and bytes, 99% of the time you will be working with binaries and using the &lt;code&gt;is_binary/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; functions.</source>
          <target state="translated">바이너리 / 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 에 대한 완전한 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;는 Elixir 문서에서&lt;/a&gt; 찾을 수 있습니다 . 이것으로 비트 스트링, 바이너리 및 스트링 둘러보기를 마칩니다. 문자열은 UTF-8로 인코딩 된 이진수이고 이진수는 비트 수를 8로 나눌 수있는 비트 열입니다. 이는 Elixir가 비트 및 바이트 작업을 위해 제공하는 유연성을 보여 주지만 이진으로 작업하는 시간의 99 % 상기 사용 &lt;code&gt;is_binary/1&lt;/code&gt; 및 &lt;code&gt;byte_size/1&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="105058c6913b6aca65f638c1f413a6d39b69929a" translate="yes" xml:space="preserve">
          <source>A comprehension accepts many generators and filters. Enumerable generators are defined using &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">이해력은 많은 발전기와 필터를 수용합니다. 열거 가능한 생성기는 &lt;code&gt;&amp;lt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2254d1e3c598efd95bae0fbcd5261dc7a19b584" translate="yes" xml:space="preserve">
          <source>A comprehension is made of three parts: generators, filters, and collectables.</source>
          <target state="translated">이해는 생성기, 필터 및 수집품의 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="57e82275e50252bbe2085b03c1d0b32e426de8c6" translate="yes" xml:space="preserve">
          <source>A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback is useful to verify the arguments given to the provider and prepare the state that will be given to &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 제공자는 일반적으로 대상 시스템이 아닌 시스템이 조립 된 시스템에서 초기화됩니다. &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 제공자에게 주어진 인자를 확인하고 설명한다 상태를 준비 할 때 유용 &lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2d91cecc19bd9b6373cb65cc2b96981847455a7" translate="yes" xml:space="preserve">
          <source>A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.</source>
          <target state="translated">감소 함수가 꼬리 재귀 방식으로 정의되는 한 연속은 간단하게 구현 될 수 있습니다. 함수가 꼬리 재귀 인 경우 모든 상태가 인수로 전달되므로 계속되는 부분은 축소 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d9d07f696d7dfca22202afba7e8f633e04a8e575" translate="yes" xml:space="preserve">
          <source>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</source>
          <target state="translated">오른쪽 (표현식)이 왼쪽 (패턴)과 일치하는지 확인하는 편의 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="519bb29b1d6986fcd05f0a99d472d916cc9bd057" translate="yes" xml:space="preserve">
          <source>A datetime implementation with a time zone.</source>
          <target state="translated">시간대가있는 날짜 / 시간 구현입니다.</target>
        </trans-unit>
        <trans-unit id="b6db3633bda62d2390f3bfd7494f15fde875e846" translate="yes" xml:space="preserve">
          <source>A default value can also be given as third argument. If any of the keys in the path along the way is missing, the default value is used:</source>
          <target state="translated">기본값은 세 번째 인수로 제공 될 수도 있습니다. 경로에서 누락 된 키가 있으면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="67d109facb82e3da7d9ccbd5e6e026c506c1e1ee" translate="yes" xml:space="preserve">
          <source>A dependency that wants to export formatter configuration needs to have a &lt;code&gt;.formatter.exs&lt;/code&gt; file at the root of the project. In this file, the dependency can export a &lt;code&gt;:export&lt;/code&gt; option with configuration to export. For now, only one option is supported under &lt;code&gt;:export&lt;/code&gt;: &lt;code&gt;:locals_without_parens&lt;/code&gt; (whose value has the same shape as the value of the &lt;code&gt;:locals_without_parens&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#format_string!/2&quot;&gt;&lt;code&gt;Code.format_string!/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">포맷터 구성을 내보내 &lt;code&gt;.formatter.exs&lt;/code&gt; 은 프로젝트의 루트에 .formatter.exs 파일 이 있어야합니다 . 이 파일에서 종속성은 내보낼 구성과 함께 &lt;code&gt;:export&lt;/code&gt; 옵션을 내보낼 수 있습니다. 지금은 하나의 옵션에서 지원되는 &lt;code&gt;:export&lt;/code&gt; : &lt;code&gt;:locals_without_parens&lt;/code&gt; (그 값의 값과 같은 모양이 있습니다 &lt;code&gt;:locals_without_parens&lt;/code&gt; 에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#format_string!/2&quot;&gt; &lt;code&gt;Code.format_string!/2&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="78f3b8cdfef736d240c67d26318dec43ff774694" translate="yes" xml:space="preserve">
          <source>A developer can filter to import only macros or functions via the only option:</source>
          <target state="translated">개발자는 유일한 옵션을 통해 매크로 또는 함수 만 가져 오도록 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f52246bffbbbb2db795496e80d43d32453cd29" translate="yes" xml:space="preserve">
          <source>A developer can set a string as an input. The default input is an empty string. If capturing a named device asynchronously, an input can only be given to the first capture. Any further capture that is given to a capture on that device will raise an exception and would indicate that the test should be run synchronously.</source>
          <target state="translated">개발자는 문자열을 입력으로 설정할 수 있습니다. 기본 입력은 빈 문자열입니다. 이름이 지정된 장치를 비동기 적으로 캡처하는 경우 입력은 첫 번째 캡처에만 제공 될 수 있습니다. 해당 장치의 캡처에 제공되는 추가 캡처는 예외를 발생시키고 테스트가 동 기적으로 실행되어야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5a911f4ab0ec30f4f88b0aebbdc462456eb2bb1d" translate="yes" xml:space="preserve">
          <source>A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as:</source>
          <target state="translated">개발자는 코드 구성 목적으로 프로세스를 사용해서는 안됩니다. 다음과 같은 런타임 특성을 모델링하려면 프로세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="84906ae4b0b03202e187ef303aa6f0bec88d2611" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, a supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;), and a name:</source>
          <target state="translated">동적 감독자는 하위, 감독 전략 (현재 지원되는 유일한 전략은 &lt;code&gt;:one_for_one&lt;/code&gt; ) 및 이름으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1073f62e845462d6a9fa22958360b75968c4eb" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, often under a supervisor with the supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;) and a name:</source>
          <target state="translated">동적 감독자는 자식없이 시작하며, 종종 감독 전략 (현재 지원되는 유일한 전략은 &lt;code&gt;:one_for_one&lt;/code&gt; )과 이름을 가진 감독자 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="206a7ca6f86f975f7d383ad0847c73bb36ab55be" translate="yes" xml:space="preserve">
          <source>A event manager with event handlers behaviour.</source>
          <target state="translated">이벤트 핸들러 동작이있는 이벤트 관리자</target>
        </trans-unit>
        <trans-unit id="5b9f82bdf9353661bdb7bfb129accfcfc67cacc8" translate="yes" xml:space="preserve">
          <source>A file can also be opened with &lt;code&gt;:utf8&lt;/code&gt; encoding, which tells the &lt;code&gt;File&lt;/code&gt; module to interpret the bytes read from the file as UTF-8-encoded bytes.</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; 인코딩을 사용하여 &lt;code&gt;File&lt;/code&gt; 열 수도 있습니다 . 파일 모듈에서 파일에서 읽은 바이트를 UTF-8로 인코딩 된 바이트로 해석하도록합니다.</target>
        </trans-unit>
        <trans-unit id="26174891cb43d56e620f230c7e58f6661e413141" translate="yes" xml:space="preserve">
          <source>A file named &lt;code&gt;mix.exs&lt;/code&gt; was generated inside our new project folder (&lt;code&gt;kv&lt;/code&gt;) and its main responsibility is to configure our project. Let&amp;rsquo;s take a look at it:</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; 파일이 새 프로젝트 폴더 ( &lt;code&gt;kv&lt;/code&gt; ) 내에 생성 되었으며 주된 책임은 프로젝트를 구성하는 것입니다. 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="b7f8081cbb17a898eeed9fb6829112a813894639" translate="yes" xml:space="preserve">
          <source>A finished test can be in one of five states:</source>
          <target state="translated">완료된 테스트는 5 가지 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fed755e476e5364797de1ef4e79f28c16e21183" translate="yes" xml:space="preserve">
          <source>A first attempt at improving it could be with ranges:</source>
          <target state="translated">그것을 개선하기위한 첫 번째 시도는 범위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433ee9a9f829c196fd1ee1abea74ddd48c74e24a" translate="yes" xml:space="preserve">
          <source>A flex break still causes a group to break, like &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;, but it is re-evaluated when the documented is rendered.</source>
          <target state="translated">플렉스 브레이크는 여전히 &lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt; 과 같이 그룹을 중단 시키지만 문서화가 렌더링 될 때 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c789b9878ed6a8416701bcc8a3653070d47748c6" translate="yes" xml:space="preserve">
          <source>A full match spec used when selecting objects in the registry</source>
          <target state="translated">레지스트리에서 객체를 선택할 때 사용되는 전체 일치 사양</target>
        </trans-unit>
        <trans-unit id="a3614f0c3cc10c91c4e5886008e5901952c470af" translate="yes" xml:space="preserve">
          <source>A function clause will be executed if and only if its guard expression evaluates to &lt;code&gt;true&lt;/code&gt;. If any other value is returned, the function clause will be skipped. In particular, guards have no concept of &quot;truthy&quot; or &quot;falsey&quot;.</source>
          <target state="translated">함수 절은 가드 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가되는 경우에만 실행됩니다 . 다른 값이 반환되면 함수 절을 건너 뜁니다. 특히 경비원은 &quot;진정한&quot;또는 &quot;거짓&quot;이라는 개념이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d5721d8d9a91361a538da41fa6ecb3b70b6fe95" translate="yes" xml:space="preserve">
          <source>A function that expects arguments can be defined as follows:</source>
          <target state="translated">인수를 기대하는 함수는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d355151786999a1eeed6fd34569b3fb108130e3c" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;application#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">일반적인 지침은 일반적으로 &lt;a href=&quot;application#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; 콜백 에서 감독 트리 상단에서만 콜백 모듈없이 수퍼바이저를 사용하는 것 입니다. 응용 프로그램의 다른 수퍼바이저에 대해 모듈 기반 수퍼바이저를 사용하여 트리에서 다른 수퍼바이저의 자식으로 실행할 수 있도록하는 것이 좋습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 가 자동으로 생성 한 &lt;code&gt;child_spec/1&lt;/code&gt; 은 다음 옵션으로 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d26632b07b76b36fb14c1f0930f3f860b35b498" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">일반적인 지침은 일반적으로 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; 콜백 에서 감독 트리의 맨 위에 만 콜백 모듈없이 감독자를 사용하는 것 입니다. 응용 프로그램의 다른 감독자에 대해 모듈 기반 감독자를 사용하여 트리에서 다른 감독자의 자식으로 실행할 수 있도록하는 것이 좋습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 가 자동으로 생성 한 &lt;code&gt;child_spec/1&lt;/code&gt; 은 다음 옵션을 사용하여 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b4711dc1275381e6488c7af769cb77bdc74fad" translate="yes" xml:space="preserve">
          <source>A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute:</source>
          <target state="translated">주어진 바이트 코드 또는 프로토콜 구현은 프로토콜 속성을 분석하여 통합 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b0b35ef86b280f67197dee5c9182e1ddbec041" translate="yes" xml:space="preserve">
          <source>A given include/exclude filter can be given more than once:</source>
          <target state="translated">지정된 포함 / 제외 필터는 두 번 이상 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace5acb901e1cf11450076f19fc37584bf1d2ad7" translate="yes" xml:space="preserve">
          <source>A group with linebreaks will fit if all lines in the group fit.</source>
          <target state="translated">그룹의 모든 줄이 맞으면 줄 바꿈이있는 그룹이 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d57f1441409523fcaba5ede0a6bbc3934bffdaa3" translate="yes" xml:space="preserve">
          <source>A guard to be evaluated when matching on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치 할 때 평가할 가드</target>
        </trans-unit>
        <trans-unit id="d0ff20995d6baf3cafcf4ec6d8e37185e4734ce5" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, for example, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">중복 된 키를 처리하는 몇 가지 함수가 있습니다. 예를 들어 &lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt; 는 주어진 키에 대한 모든 값을 반환하고 &lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt; 는 기존 항목 중 하나만 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="f530d85d2682e767c664f63f19c8edab6f12a410" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, in particular, &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; allows creating new keywords without removing duplicated keys, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">중복 키를 처리하는 소수의 기능이 있습니다. 특히 &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; 는 중복 키를 제거하지 않고 새 키워드를 만들 수 있으며 &lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt; 는 지정된 키의 모든 값을 반환하며 &lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt; 는 기존 항목 중 하나만 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="015b83a7f5c39d5e87a14fcb109161e605efd575" translate="yes" xml:space="preserve">
          <source>A higher level and more convenient API is also available via &lt;a href=&quot;#format/1&quot;&gt;&lt;code&gt;IO.ANSI.format/1&lt;/code&gt;&lt;/a&gt;, where you use atoms to represent each ANSI escape sequence and by default checks if ANSI is enabled:</source>
          <target state="translated">&lt;a href=&quot;#format/1&quot;&gt; &lt;code&gt;IO.ANSI.format/1&lt;/code&gt; 을&lt;/a&gt; 통해 더 높은 수준의 편리한 API를 사용할 수도 있습니다 . 여기서는 원자를 사용하여 각 ANSI 이스케이프 시퀀스를 나타내고 기본적으로 ANSI가 활성화되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="596a9b5a3a8aa9b50ec41bf23a4f842662a8cb81" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled.</source>
          <target state="translated">모듈이 컴파일되기 전에 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="a0a0a51df914ce59ba1556541b6506e53ae5b94d" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled. Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">모듈이 컴파일되기 전에 호출되는 후크입니다. 모듈 또는 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 튜플을 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6987134a6eff9f82a6141f1c9cc8c83ffe79d180" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled.</source>
          <target state="translated">현재 모듈이 컴파일 된 직후에 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="83dcc203e6f45c9ceed02fc70bb7ce0dc9022031" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled. Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt;. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">현재 모듈이 컴파일 된 직후에 호출되는 후크입니다. 모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7281774c2eebc7eedcdde8f4eb9495e25954bfba" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</source>
          <target state="translated">현재 모듈의 각 함수 또는 매크로가 정의 될 때 호출되는 후크입니다. 함수에 주석을 달 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b574e1f9586eced8b5deb66bb46ac24d0c228cae" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked whenever the module is loaded.</source>
          <target state="translated">모듈이로드 될 때마다 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="3230b053994c4f824d19b0f0c39c5b461d162140" translate="yes" xml:space="preserve">
          <source>A keyword list can also be given if there is a need to change the child specification for the given child process:</source>
          <target state="translated">지정된 자식 프로세스에 대한 자식 사양을 변경해야 할 경우 키워드 목록을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f0445b17da9c462d7db8862e1b68f43ab27b20" translate="yes" xml:space="preserve">
          <source>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</source>
          <target state="translated">표현식 평가 결과를 인쇄 할 때 쉘에서 사용하는 검사 옵션을 포함하는 키워드 목록. 기본값은 50 개 항목으로 구성된 예쁜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="61fe73f02ff5a301c92071887b054a01257fbb87" translate="yes" xml:space="preserve">
          <source>A keyword list is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</source>
          <target state="translated">키워드 목록은 튜플의 첫 번째 요소가 원자이고 두 번째 요소가 임의의 값일 수있는 두 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a6fa0b36a31d21b7bbaef70cccf2751fe2ed4b92" translate="yes" xml:space="preserve">
          <source>A keyword list is a list that consists exclusively of two-element tuples.</source>
          <target state="translated">키워드 목록은 요소가 두 개인 튜플로만 구성된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5a590eff23e0d301e8846f76f5edec42c61cc765" translate="yes" xml:space="preserve">
          <source>A keyword list of AST metadata.</source>
          <target state="translated">AST 메타 데이터의 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="352c6325949d916dfbf48e00d1fe4d030d4dc592" translate="yes" xml:space="preserve">
          <source>A keyword list that encapsulates all color settings used by the shell. See documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt;&lt;code&gt;IO.ANSI&lt;/code&gt;&lt;/a&gt; module for the list of supported colors and attributes.</source>
          <target state="translated">쉘에서 사용하는 모든 색상 설정을 캡슐화하는 키워드 목록. 지원되는 색상 및 속성 목록은 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt; &lt;code&gt;IO.ANSI&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90fd8fbcd55ac37d5c84cb3c58c955ad51a59d87" translate="yes" xml:space="preserve">
          <source>A keyword list:</source>
          <target state="translated">키워드 목록 :</target>
        </trans-unit>
        <trans-unit id="b0d83669bf620b5b45fad88effbdaebb1342a611" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value data type. However most of the functions in this module behave exactly as a key-value so they work similarly to the functions you would find in the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. For example, &lt;a href=&quot;#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#delete/2&quot;&gt;&lt;code&gt;Keyword.delete/2&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts.</source>
          <target state="translated">키워드에 중복 된 키가있을 수 있으므로 엄격하게 키-값 데이터 유형이 아닙니다. 그러나이 모듈의 대부분의 함수는 정확히 키-값으로 작동하므로 &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수있는 함수와 유사하게 작동 합니다. 예를 들어 &lt;a href=&quot;#get/3&quot;&gt; &lt;code&gt;Keyword.get/3&lt;/code&gt; &lt;/a&gt; 은 중복 항목이 있는지 여부에 관계없이 주어진 키와 일치하는 첫 번째 항목을 가져옵니다. 마찬가지로 &lt;a href=&quot;#put/3&quot;&gt; &lt;code&gt;Keyword.put/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#delete/2&quot;&gt; &lt;code&gt;Keyword.delete/2&lt;/code&gt; &lt;/a&gt; 는 호출시 지정된 키에 대한 모든 중복 항목이 제거되도록합니다. 그러나 키워드 목록 작업은 키를 찾기 위해 전체 목록을 탐색해야하므로 이러한 작업은 해당 맵 작업보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="207a17d66a4d274303a0b808b876e2f07cab4cdc" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">키워드에 중복 키가있을 수 있으므로 키-값 저장소가 아닙니다. 그러나이 모듈의 대부분의 함수는 사전으로 정확하게 작동하므로 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾은 함수와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="7d3c9948a05d7abcab99c9cefbe9438aa010a2dc" translate="yes" xml:space="preserve">
          <source>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return &lt;code&gt;false&lt;/code&gt; if it does not support the concept of leap years.</source>
          <target state="translated">윤년은 정상보다 길이가 더 길다. 정확한 의미는 달력에 달려 있습니다. 윤년 개념을 지원하지 않는 달력은 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb9fe9c85fbf7d3fb18bb99ccf2350f33242ce20" translate="yes" xml:space="preserve">
          <source>A library should not provide &lt;code&gt;use MyLib&lt;/code&gt; functionality if all &lt;code&gt;use MyLib&lt;/code&gt; does is to &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;alias&lt;/code&gt; the module itself. For example, this is an anti-pattern:</source>
          <target state="translated">라이브러리는 제공하지 않아야 &lt;code&gt;use MyLib&lt;/code&gt; 모든 경우 기능을 &lt;code&gt;use MyLib&lt;/code&gt; 하지가입니다 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;alias&lt;/code&gt; 모듈 자체. 예를 들어, 이것은 안티 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="86a187cb80a7c4ad0fb8e723a871bc21c28d506c" translate="yes" xml:space="preserve">
          <source>A link is created between the calling process and the new process, atomically. If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason &lt;code&gt;:noconnection&lt;/code&gt; will be received).</source>
          <target state="translated">호출 프로세스와 새 프로세스간에 원자 적으로 링크가 작성됩니다. 경우 &lt;code&gt;node&lt;/code&gt; 존재하지 않는, 쓸모없는 PID가 반환 (인해 링크, 출구 이유가 종료 신호에있다 &lt;code&gt;:noconnection&lt;/code&gt; 가 수신됩니다).</target>
        </trans-unit>
        <trans-unit id="f32efab7c564ee44d8dbdb445e6ef037578935c8" translate="yes" xml:space="preserve">
          <source>A list also supports matching on its own head and tail:</source>
          <target state="translated">리스트는 또한 머리와 꼬리에 일치하는 것을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="b51c3a4547f02d7e7f4e5168a995c1a16dcdbcfa" translate="yes" xml:space="preserve">
          <source>A list can be checked if it is made of only printable ASCII characters with &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; 인&lt;/a&gt; 인쇄 가능한 ASCII 문자로만 구성된 경우 목록을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09109009b595afbd12ae9a2a04f05c373522edd5" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;code#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">환경 옵션 목록을 인수로 제공 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;code#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0a39f6289583bb5f5f00c8514b83d6750f110e0a" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">환경 옵션 목록도 인수로 제공 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d66ba38cf190fb69cf061a0304e059a09b5cac80" translate="yes" xml:space="preserve">
          <source>A list of files and/or directories can be given after the task name in order to select the files to run:</source>
          <target state="translated">실행할 파일을 선택하기 위해 작업 이름 뒤에 파일 및 / 또는 디렉토리 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa40d2c95d1592c3f577816c839f4bfb9a0eb32" translate="yes" xml:space="preserve">
          <source>A list of files can be given after the task name in order to select the files to compile:</source>
          <target state="translated">컴파일 할 파일을 선택하기 위해 작업 이름 뒤에 파일 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f891471b493829a13afb97466625b0b354b781" translate="yes" xml:space="preserve">
          <source>A list of guards to be evaluated when matching on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치 할 때 평가할 가드 목록</target>
        </trans-unit>
        <trans-unit id="a09af47acaa10fb69360523f8594ec6d2a340887" translate="yes" xml:space="preserve">
          <source>A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents.</source>
          <target state="translated">기본 목록의 각 항목은 일치를 나타내고 보조 목록의 각 항목은 캡처 된 내용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea96d09747a4aa343151e0377aac270bb2119eb2" translate="yes" xml:space="preserve">
          <source>A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on &lt;code&gt;start_link/1&lt;/code&gt; to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</source>
          <target state="translated">서버 이름과 같은 항목을 지정하는 데 사용할 수있는 옵션 목록입니다. 지금 은 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 에서 받는 옵션 목록 을 GenServer에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="14180540c9dfb80b1033daf7503e57620771cedc" translate="yes" xml:space="preserve">
          <source>A list of patterns:</source>
          <target state="translated">패턴 목록 :</target>
        </trans-unit>
        <trans-unit id="2579a07d3781330f2b03068754b700311c87706a" translate="yes" xml:space="preserve">
          <source>A list with all variable bindings.</source>
          <target state="translated">모든 변수 바인딩이있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bfadb8e1f57e1fb13ad2e8d3a0b69f6c2d5144ae" translate="yes" xml:space="preserve">
          <source>A local, decentralized and scalable key-value process storage.</source>
          <target state="translated">로컬, 분산 및 확장 가능한 키-값 프로세스 스토리지.</target>
        </trans-unit>
        <trans-unit id="fea558b9d01d10708bd232eedeea8d9affdc8614" translate="yes" xml:space="preserve">
          <source>A logger for Elixir applications.</source>
          <target state="translated">Elixir 애플리케이션 용 로거.</target>
        </trans-unit>
        <trans-unit id="0f699b34255da40ccc76a38c897571c0c579e349" translate="yes" xml:space="preserve">
          <source>A mandatory linebreak.</source>
          <target state="translated">필수 줄 바꿈.</target>
        </trans-unit>
        <trans-unit id="a06294fa5d8aaf5ba345cd5c76ff398b3966ffbf" translate="yes" xml:space="preserve">
          <source>A map representing the results of running a test suite</source>
          <target state="translated">테스트 스위트 실행 결과를 나타내는 맵</target>
        </trans-unit>
        <trans-unit id="3d6bcd31c59bce4c517c58779221986c48c5763e" translate="yes" xml:space="preserve">
          <source>A meta task that compiles source files.</source>
          <target state="translated">소스 파일을 컴파일하는 메타 작업입니다.</target>
        </trans-unit>
        <trans-unit id="6a1a9dcccbb902320d46c5c63b16e41809e26be8" translate="yes" xml:space="preserve">
          <source>A module for working with applications and defining application callbacks.</source>
          <target state="translated">응용 프로그램 작업 및 응용 프로그램 콜백 정의를위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="393ee42f919d889432d7d012d4db2df21c1d324c" translate="yes" xml:space="preserve">
          <source>A module implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt; behaviour.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt; 동작을 구현하는 모듈 입니다.</target>
        </trans-unit>
        <trans-unit id="8dd0cdfde3f3104d72c5cb46bfa86d5986868373" translate="yes" xml:space="preserve">
          <source>A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.</source>
          <target state="translated">모듈이 현재 정의되어 있고 해당 속성과 기능을 수정할 수있는 경우 &quot;개방&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="bcc80a2d15eb1ca0fa95f140b2ab076769a58202" translate="yes" xml:space="preserve">
          <source>A module may export a &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; function that can cause the module to be recompiled using custom rules. For example, &lt;code&gt;@external_resource&lt;/code&gt; already adds a compile-time dependency on an external file, however to depend on a &lt;em&gt;dynamic&lt;/em&gt; list of files we can do:</source>
          <target state="translated">모듈은 사용자 지정 규칙을 사용하여 모듈을 재 컴파일 할 수 있는 &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; 함수를 내보낼 수 있습니다. 예를 들어 &lt;code&gt;@external_resource&lt;/code&gt; 는 이미 외부 파일에 대한 컴파일 시간 종속성을 추가하지만 &lt;em&gt;동적&lt;/em&gt; 파일 목록에 의존하기 위해 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0c1125a7c9859ba806c52d2b8389c8da71008d" translate="yes" xml:space="preserve">
          <source>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with &lt;code&gt;@doc false&lt;/code&gt;, &lt;code&gt;@impl true&lt;/code&gt;, or functions that aren't explicitly documented and where the function name is in the form of &lt;code&gt;__foo__&lt;/code&gt;.</source>
          <target state="translated">모듈은 직접 사용되지 않는 기능을 내보낼 수 있습니다. 이러한 기능은 IEx에 의해 자동 완성되지 않습니다. IEx는 &lt;code&gt;@doc false&lt;/code&gt; , &lt;code&gt;@impl true&lt;/code&gt; 로 주석이 달린 함수 또는 명시 적으로 문서화되지 않은 함수와 함수 이름이 &lt;code&gt;__foo__&lt;/code&gt; 형식 인 함수를 자동 완성 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="32cd185a5680fc74f94a90987dd36d929f10c20a" translate="yes" xml:space="preserve">
          <source>A module responsible for compiling and requiring files in parallel.</source>
          <target state="translated">파일을 병렬로 컴파일하고 요구하는 모듈.</target>
        </trans-unit>
        <trans-unit id="29645843a5110b928d9faeadea534106995dc37f" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; fetches the last element).</source>
          <target state="translated">음수 &lt;code&gt;index&lt;/code&gt; 를 전달할 수 있는데, 이는 &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 &lt;code&gt;index&lt;/code&gt; 가 끝부터 계산 됨을 의미합니다 (예 : &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소를 가져옵니다).</target>
        </trans-unit>
        <trans-unit id="26cdfdc092bdd1d22ed3029d691848711d9f566b" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; finds the last element).</source>
          <target state="translated">음수 &lt;code&gt;index&lt;/code&gt; 를 전달할 수 있습니다. 즉, &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 &lt;code&gt;index&lt;/code&gt; 가 끝부터 계산됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 이 마지막 요소를 찾습니다).</target>
        </trans-unit>
        <trans-unit id="7237cde12b43d44a106f66033ee7470522a9c3a4" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;length&lt;/code&gt; can be used to extract bytes that come &lt;em&gt;before&lt;/em&gt; the byte at &lt;code&gt;start&lt;/code&gt;:</source>
          <target state="translated">음수 &lt;code&gt;length&lt;/code&gt; 를 사용하여 &lt;code&gt;start&lt;/code&gt; 바이트 &lt;em&gt;앞에&lt;/em&gt; 오는 바이트를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36a3b9605725fcc95fe9b23e674356e7e27c98c9" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;start_index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the index is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; starts slicing from the last element).</source>
          <target state="translated">음수 &lt;code&gt;start_index&lt;/code&gt; 를 전달할 수 있습니다. 즉, &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 색인부터 끝까지 계산됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소에서 슬라이스 시작).</target>
        </trans-unit>
        <trans-unit id="81c58f8de418e8cd25d1b22380a53e0273247707" translate="yes" xml:space="preserve">
          <source>A negative assertion, expects the expression to be &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">부정 어설 션은 표현식이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="f88876dd5bc14e91399b8aa67a2ddb2e03a67c34" translate="yes" xml:space="preserve">
          <source>A non-local return from a function.</source>
          <target state="translated">함수에서 로컬이 아닌 리턴.</target>
        </trans-unit>
        <trans-unit id="0eaabe61fdbf51208eaa83fc1dc3996aba60b1e8" translate="yes" xml:space="preserve">
          <source>A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;a href=&quot;#restart_child/2&quot;&gt;&lt;code&gt;restart_child/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#delete_child/2&quot;&gt;&lt;code&gt;delete_child/2&lt;/code&gt;&lt;/a&gt; to remove the child specification.</source>
          <target state="translated">비 임시적 하위 프로세스는 나중에 감독자가 다시 시작할 수 있습니다. 자식 프로세스는 &lt;a href=&quot;#restart_child/2&quot;&gt; &lt;code&gt;restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출하여 명시 적으로 다시 시작할 수도 있습니다 . 하위 스펙을 제거 하려면 &lt;a href=&quot;#delete_child/2&quot;&gt; &lt;code&gt;delete_child/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f2c93e683b0d27c8800a0f19ebf6094692e37b8" translate="yes" xml:space="preserve">
          <source>A partially applied reduce function.</source>
          <target state="translated">부분적으로 적용된 감소 기능.</target>
        </trans-unit>
        <trans-unit id="e00db969c5f31283ff3f80e6b605d47156f36587" translate="yes" xml:space="preserve">
          <source>A path may start with a variable, local or remote call, and must be followed by one or more:</source>
          <target state="translated">경로는 변수, 로컬 또는 원격 호출로 시작할 수 있으며 뒤에 하나 이상이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="5e11bed9e1e8a8a0b7c8ded2d01ff3d9a7368c94" translate="yes" xml:space="preserve">
          <source>A path pointing to a configuration file.</source>
          <target state="translated">구성 파일을 가리키는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="41835ab5b136f3e0eaefd676f9827017842ad941" translate="yes" xml:space="preserve">
          <source>A pattern match error will occur if the sides can&amp;rsquo;t be matched, for example if the tuples have different sizes:</source>
          <target state="translated">튜플의 크기가 다른 경우와 같이면을 일치시킬 수없는 경우 패턴 일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79fa4792dd24d1c9ce95071d9547feb6a4d474ba" translate="yes" xml:space="preserve">
          <source>A pattern to match on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치하는 패턴</target>
        </trans-unit>
        <trans-unit id="3d346e75c8c6987f80b82de7253d52d8aba958ff" translate="yes" xml:space="preserve">
          <source>A pattern used to representing the output format part of a match spec</source>
          <target state="translated">일치 스펙의 출력 형식 부분을 나타내는 데 사용되는 패턴</target>
        </trans-unit>
        <trans-unit id="a00cd65793f8f99aab040156d050cf1a0b39a869" translate="yes" xml:space="preserve">
          <source>A period where a certain combination of UTC offset, standard offset and zone abbreviation is in effect.</source>
          <target state="translated">UTC 오프셋, 표준 오프셋 및 영역 약어의 특정 조합이 적용되는 기간입니다.</target>
        </trans-unit>
        <trans-unit id="a5288558e1086c80bf20bc1087103275b3133199" translate="yes" xml:space="preserve">
          <source>A port can be closed via the &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; function or by sending a &lt;code&gt;{pid, :close}&lt;/code&gt; message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but &lt;strong&gt;it won't be automatically terminated&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt; 기능을 통해 또는 &lt;code&gt;{pid, :close}&lt;/code&gt; 메시지 를 보내 포트를 닫을 수 있습니다 . 그러나 VM이 충돌하면 포트에서 시작한 장기 실행 프로그램의 stdin 및 stdout 채널이 닫히지 만 &lt;strong&gt;자동으로 종료되지는 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b2122c1973c2dda96664be48d7e0ad6fbebe03e1" translate="yes" xml:space="preserve">
          <source>A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters:</source>
          <target state="translated">Elixir의 인쇄 가능한 문자 목록에는 표준 7 비트 ASCII 문자 인코딩의 인쇄 가능한 문자 (십진수 표기법으로 32에서 126까지의 문자)와 다음 제어 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b3af7c971656040987518db1c82f85c014263d8e" translate="yes" xml:space="preserve">
          <source>A process destination.</source>
          <target state="translated">프로세스 대상</target>
        </trans-unit>
        <trans-unit id="4b7c7e3dbab6f551e809bcd37eae034f6b3551ed" translate="yes" xml:space="preserve">
          <source>A project at the given PATH will be created. The application name and module name will be retrieved from the path, unless &lt;code&gt;--module&lt;/code&gt; or &lt;code&gt;--app&lt;/code&gt; is given.</source>
          <target state="translated">주어진 PATH에 프로젝트가 생성됩니다. &lt;code&gt;--module&lt;/code&gt; 또는 &lt;code&gt;--app&lt;/code&gt; 이 제공 되지 않으면 애플리케이션 이름과 모듈 이름이 경로에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0fec4c2c4c04c0f55fd194db047a9dd66ea084b" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로토콜은 구현에 의해 정의되어야하는 API를 지정합니다. 프로토콜은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 로 정의 되고 해당 구현은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; 로 정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fcf40e109a152697e452d59c6feb366ea55241fd" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로토콜은 구현에 의해 정의되어야하는 API를 지정합니다. 프로토콜이 정의된다 &lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 와 함께 그 구현 &lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40779d1515587d6db075e7f5314df3d534311c89" translate="yes" xml:space="preserve">
          <source>A protocol to traverse data structures.</source>
          <target state="translated">데이터 구조를 통과하는 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="faabe41c6f24d8fc609c47ff799c87b178b75359" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">범위는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다 . 이는 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위를 처리 할 수 ​​있음 을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="2d52cd8c9685cc3a9e0c6c8bc2ca91497bbfa62d" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">범위는 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다. 즉, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c19f0802d8f5cc7c36ac99c9fcb0b292b74f36a" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">범위는 내부적으로 구조체로 표시됩니다. 그러나 범위를 만들고 일치시키는 가장 일반적인 형태는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 자동으로 가져온 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt; 매크로 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c2bc069750ea0a5631ff0d83641bb81ba15fed6b" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;kernel#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">범위는 내부적으로 구조체로 표시됩니다. 그러나 범위에서 만들고 생성하는 가장 일반적인 형태는 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 자동으로 가져 오는 &lt;a href=&quot;kernel#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt; 매크로 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="28e7d9d80973e28b2fb29cdc49aa8ec0aa8cccf3" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">날짜 범위는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다. 즉 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe5b28deb10fda5ba1b89dbda06bf2a014043ab" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">날짜 범위는 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다. 즉, &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef459269461f63f29663369bbbf33d383fe471b6" translate="yes" xml:space="preserve">
          <source>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</source>
          <target state="translated">날짜 범위는 첫 번째 값과 마지막 값이 달력과 일치하는 날짜 인 이산 날짜 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="857a01be27effa9640fcaf21a35ced2eddd4ea08" translate="yes" xml:space="preserve">
          <source>A range represents a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">범위는 하나 이상의 오름차순 또는 내림차순 연속 정수 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fb37b0dc70a7a2ede2ae25048520f07b813bb7c" translate="yes" xml:space="preserve">
          <source>A regular expression:</source>
          <target state="translated">정규식 :</target>
        </trans-unit>
        <trans-unit id="fde0b7800eb1831e2b2dcfa6756a9337fbe2e1f7" translate="yes" xml:space="preserve">
          <source>A release can be configured in your &lt;code&gt;mix.exs&lt;/code&gt; file under the &lt;code&gt;:releases&lt;/code&gt; key inside &lt;code&gt;def project&lt;/code&gt;:</source>
          <target state="translated">릴리스는 &lt;code&gt;def project&lt;/code&gt; 내의 &lt;code&gt;:releases&lt;/code&gt; 키 아래 &lt;code&gt;mix.exs&lt;/code&gt; 파일에서 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be263ca652770d8e713a67b34a6b5d617a6d08fc" translate="yes" xml:space="preserve">
          <source>A release is a self-contained directory that consists of your application code, all of its dependencies, plus the whole Erlang Virtual Machine (VM) and runtime. Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.</source>
          <target state="translated">릴리스는 응용 프로그램 코드, 모든 종속 항목 및 전체 Erlang 가상 머신 (VM) 및 런타임으로 구성된 독립형 디렉토리입니다. 릴리스가 조립되면 대상이 릴리스를 조립 한 시스템과 동일한 운영 체제 (OS) 배포 및 버전에서 실행되는 한 패키지를 대상에 배포하고 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b854f9766a4f0c513ad5b3d7f5739e28f8893848" translate="yes" xml:space="preserve">
          <source>A release is built on a &lt;strong&gt;host&lt;/strong&gt;, a machine which contains Erlang, Elixir, and any other dependencies needed to compile your application. A release is then deployed to a &lt;strong&gt;target&lt;/strong&gt;, potentially the same machine as the host, but usually separate, and often there are many targets (either multiple instances, or the release is deployed to heterogeneous environments).</source>
          <target state="translated">릴리스는 &lt;strong&gt;호스트&lt;/strong&gt; , Erlang, Elixir 및 애플리케이션을 컴파일하는 데 필요한 기타 종속성이 포함 된 시스템 에 빌드됩니다 . 그런 다음 릴리스가 호스트와 잠재적으로 동일한 시스템 인 &lt;strong&gt;대상에&lt;/strong&gt; 배포 되지만 일반적으로 분리되어 있고 종종 많은 대상이 있습니다 (여러 인스턴스 또는 릴리스가 이기종 환경에 배포 됨).</target>
        </trans-unit>
        <trans-unit id="081a4af35cb82d84d3baced50f94a0f210c0215f" translate="yes" xml:space="preserve">
          <source>A release is organized as follows:</source>
          <target state="translated">릴리스는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c42536b2192014c69ae4b22e18c222e0b18ad99c" translate="yes" xml:space="preserve">
          <source>A remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">다른 노드에서 등록 된 이름에 대한 원격 또는 로컬 PID, 로컬 포트, 로컬로 등록 된 이름 또는 &lt;code&gt;{registered_name, node}&lt;/code&gt; 형식의 튜플 .</target>
        </trans-unit>
        <trans-unit id="ed74d2fa39cb6d22ba41097b9f56baec46115768" translate="yes" xml:space="preserve">
          <source>A runtime error can be raised any time by using &lt;code&gt;raise/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;raise/1&lt;/code&gt; 을 사용하면 언제든지 런타임 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd43801a9dc45b9bee09b2dbc25b3cf49922533" translate="yes" xml:space="preserve">
          <source>A set can be constructed using &lt;a href=&quot;#new/0&quot;&gt;&lt;code&gt;MapSet.new/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#new/0&quot;&gt; &lt;code&gt;MapSet.new/0&lt;/code&gt; 을&lt;/a&gt; 사용하여 집합을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecf229e1b88c6de3ab419f5af0149c86ba96a100" translate="yes" xml:space="preserve">
          <source>A set can contain any kind of elements, and elements in a set don't have to be of the same type. By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op.</source>
          <target state="translated">집합은 모든 종류의 요소를 포함 할 수 있으며 집합의 요소는 같은 유형일 필요는 없습니다. 정의에 따르면, 세트는 중복 요소를 포함 할 수 없습니다. 이미 존재하는 세트에 요소를 삽입 할 때 삽입은 단순히 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="707ec361763bdb2e00f730f12d75204db159aa81" translate="yes" xml:space="preserve">
          <source>A set is a data structure that can contain unique elements of any kind, without any particular order. &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is the &quot;go to&quot; set data structure in Elixir.</source>
          <target state="translated">집합은 특별한 순서없이 모든 종류의 고유 한 요소를 포함 할 수있는 데이터 구조입니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 은 Elixir의 &quot;이동&quot;세트 데이터 구조입니다.</target>
        </trans-unit>
        <trans-unit id="69129ee232976b3cda2ab262254ae0307e0e66f5" translate="yes" xml:space="preserve">
          <source>A set of aliases can be specified in the &lt;code&gt;:aliases&lt;/code&gt; option:</source>
          <target state="translated">별명 세트는 &lt;code&gt;:aliases&lt;/code&gt; 옵션 에서 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77bfe7434af33915219476e72f8afa049afc81c9" translate="yes" xml:space="preserve">
          <source>A set of files that contain tests that failed the last time they ran. The paths are absolute paths.</source>
          <target state="translated">마지막으로 실행했을 때 실패한 테스트가 포함 된 파일 집합입니다. 경로는 절대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e06834fc00f6bb288e0de824ba38e921ca02021c" translate="yes" xml:space="preserve">
          <source>A set of functions for creating and manipulating algebra documents.</source>
          <target state="translated">대수 문서를 작성하고 조작하기위한 함수 세트.</target>
        </trans-unit>
        <trans-unit id="88d1b0f8b81589767cdd10b2d4eb2dac1c18cfad" translate="yes" xml:space="preserve">
          <source>A set of functions for working with functions.</source>
          <target state="translated">함수 작업을위한 함수 집합입니다.</target>
        </trans-unit>
        <trans-unit id="730d44e1645bfae97fe7c12ff77a7bf08210ea3c" translate="yes" xml:space="preserve">
          <source>A set of functions for working with keywords.</source>
          <target state="translated">키워드 작업을위한 일련의 기능.</target>
        </trans-unit>
        <trans-unit id="dfb7a76606ff3c8779b3a99cd95301d320dbf7d1" translate="yes" xml:space="preserve">
          <source>A set of functions for working with maps.</source>
          <target state="translated">맵 작업을위한 함수 세트입니다.</target>
        </trans-unit>
        <trans-unit id="9f7b7bb83b1ac5ba845f1d4d693eba42524cef2e" translate="yes" xml:space="preserve">
          <source>A set of functions that perform calculations on bits.</source>
          <target state="translated">비트에 대해 계산을 수행하는 함수 집합입니다.</target>
        </trans-unit>
        <trans-unit id="5f326a556060d175497aed660d915fb196c3082f" translate="yes" xml:space="preserve">
          <source>A set of macros that perform calculations on bits.</source>
          <target state="translated">비트에 대한 계산을 수행하는 매크로 세트.</target>
        </trans-unit>
        <trans-unit id="0f36a297b599bd007efe012e6a6da2cbf2b3692f" translate="yes" xml:space="preserve">
          <source>A set of test IDs that failed the last time they ran</source>
          <target state="translated">마지막으로 실행했을 때 실패한 테스트 ID 세트</target>
        </trans-unit>
        <trans-unit id="7d47059c046e5014c34e11ea59ece30879e2953e" translate="yes" xml:space="preserve">
          <source>A short example is:</source>
          <target state="translated">간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb763bbb5e88ec5f61d4da245e4ae7009da3216" translate="yes" xml:space="preserve">
          <source>A similar example is when the formatter breaks a function definition over multiple clauses:</source>
          <target state="translated">비슷한 예는 포맷터가 여러 절에 대해 함수 정의를 어기는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f0bbc03071215c2e0f6a6903b25b4b7e9d6e31a3" translate="yes" xml:space="preserve">
          <source>A simple configuration API and functions for managing config files.</source>
          <target state="translated">구성 파일 관리를위한 간단한 구성 API 및 기능.</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="50c4d47f669eefd6925f54ce413c2f2d2b593c55" translate="yes" xml:space="preserve">
          <source>A simple example of a custom type implementation is to provide a more descriptive alias of an existing type. For example, defining &lt;code&gt;year&lt;/code&gt; as a type makes your function specs more descriptive than if they had simply used &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">사용자 지정 형식 구현의 간단한 예는 기존 형식의보다 설명적인 별칭을 제공하는 것입니다. 예를 들어 &lt;code&gt;year&lt;/code&gt; 를 유형으로 정의 하면 단순히 &lt;code&gt;integer&lt;/code&gt; 를 사용한 경우보다 함수 사양을 더 설명 적으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70f5ef2ef60f95969333b92d42f3f374f63b82f9" translate="yes" xml:space="preserve">
          <source>A simple keyword-based configuration API.</source>
          <target state="translated">간단한 키워드 기반 구성 API</target>
        </trans-unit>
        <trans-unit id="c8561655e8b17e9fc3693ef2633482210d43ebb9" translate="yes" xml:space="preserve">
          <source>A simple module that provides conveniences for creating, loading and manipulating tasks.</source>
          <target state="translated">작업을 생성,로드 및 조작 할 수있는 편의성을 제공하는 간단한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="15571e3a35bf5ea9940001cd7a008535588aae55" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">더 간단한 옵션은 글자의 매핑과 필터링에 이해력을 사용하는 것입니다. 그런 다음 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 를 호출 하여 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3b0c96451986330669665045ba5856473caa87a1" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">더 간단한 옵션은 문자 매핑 및 필터링에 이해력을 사용한 다음 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 를 호출 하여 맵을 만드는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5961d93e1fd6c1a5f3b6d9b27c8ebaac2a4e2eb8" translate="yes" xml:space="preserve">
          <source>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</source>
          <target state="translated">UTF-8로 인코딩 된 단일 유니 코드 코드 포인트입니다. 하나 이상의 바이트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b7224e7f04fc46b45efe7b42b88ffb7dce900f" translate="yes" xml:space="preserve">
          <source>A slicing function that receives the initial position and the number of elements in the slice.</source>
          <target state="translated">슬라이스의 초기 위치와 요소 수를받는 슬라이싱 기능입니다.</target>
        </trans-unit>
        <trans-unit id="9542d8f0337c374d610ba8edde94615ef17ee5bc" translate="yes" xml:space="preserve">
          <source>A solution is to make sure the child processes listen to the standard input and terminate when standard input is closed. We discuss this topic at length in the &quot;Zombie operating system processes&quot; of the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">해결책은 하위 프로세스가 표준 입력을 청취하고 표준 입력이 닫힐 때 종료되도록하는 것입니다. 이 주제에 대해서는 &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; 모듈 설명서 의 &quot;좀비 운영 체제 프로세스&quot;에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c87e0295b0434ce8d6e0bea2a0090734199f18b2" translate="yes" xml:space="preserve">
          <source>A specification for a function can be defined as follows:</source>
          <target state="translated">함수의 스펙은 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db516f2d9f13380d21782abf7bf499d7db55707d" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 추적은 인수로 제공되어야합니다. 그렇지 않은 경우 스택 추적은 &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt; 에서 검색됩니다. .</target>
        </trans-unit>
        <trans-unit id="cb5a957f0b3dafd85aa37ba4fcf8ab83b116491b" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;process#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 추적은 인수로 제공되어야합니다. 그렇지 않은 경우 스택 추적은 &lt;a href=&quot;process#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt; 에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="024c57bba13b29b29ec58526f15dcb1593786c12" translate="yes" xml:space="preserve">
          <source>A string is a UTF-8 encoded binary. In order to understand exactly what we mean by that, we need to understand the difference between bytes and code points.</source>
          <target state="translated">문자열은 UTF-8로 인코딩 된 이진입니다. 우리가 의미하는 바를 정확히 이해하려면 바이트와 코드 포인트의 차이점을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="3135dbc4cf4ce228f4aedafff7fb3268b76ca8f3" translate="yes" xml:space="preserve">
          <source>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</source>
          <target state="translated">구조체는 개발자가 키에 대한 기본값, 다형성 디스패치에 사용되는 태그 및 컴파일 시간 명제를 제공 할 수있는 태그 된 맵입니다.</target>
        </trans-unit>
        <trans-unit id="9134cc0bb82067454750b89f0528401b6a9bc1d3" translate="yes" xml:space="preserve">
          <source>A struct that holds compile time environment information.</source>
          <target state="translated">컴파일 시간 환경 정보를 보유하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="2aab307089f5f9db7819dc7a115a812e5a3fa578" translate="yes" xml:space="preserve">
          <source>A struct that holds file information.</source>
          <target state="translated">파일 정보를 보유하는 구조체</target>
        </trans-unit>
        <trans-unit id="682f2bb617fd3f67f3ee1da2f3c9e406cf26c520" translate="yes" xml:space="preserve">
          <source>A struct that holds version requirement information.</source>
          <target state="translated">버전 요구 사항 정보를 보유하는 구조체.</target>
        </trans-unit>
        <trans-unit id="41babc3e64f09380f0db683d589523654ce213d8" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test case.</source>
          <target state="translated">테스트 케이스에 대한 정보를 유지하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="c75627e28a62723b736494f2d433aeb4bca5337b" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test module.</source>
          <target state="translated">테스트 모듈에 대한 정보를 보관하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="977bdad55f17ecd8ee2f048b6fc658fc29753b9a" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test.</source>
          <target state="translated">테스트에 대한 정보를 유지하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="ac118fd8485fc091bbf3bccd439369617ac9e067" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as &lt;em&gt;child processes&lt;/em&gt;. Supervisors are used to build a hierarchical process structure called a &lt;em&gt;supervision tree&lt;/em&gt;. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.</source>
          <target state="translated">감독자는 다른 프로세스를 감독하는 프로세스로, 우리는 &lt;em&gt;자식 프로세스라고&lt;/em&gt; 합니다. 감독자는 &lt;em&gt;감독 트리&lt;/em&gt; 라고하는 계층 적 프로세스 구조를 구축하는 데 사용됩니다 . 감독 트리는 내결함성을 제공하고 애플리케이션 시작 및 종료 방법을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="55d0b2c21ea69ec921c9ed14e37c45764559b92c" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities. The first one is to start child processes. Once a child process is running, the supervisor may restart a child process, either because it terminated abnormally or because a certain condition was reached. For example, a supervisor may restart all children if any child dies. Finally, a supervisor is also responsible for shutting down the child processes when the system is shutting down. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; module for a more in-depth discussion.</source>
          <target state="translated">감독자는 다른 프로세스를 감독하는 프로세스로, 우리는 자식 프로세스라고합니다. 프로세스를 감독하는 행위에는 세 가지 책임이 있습니다. 첫 번째는 자식 프로세스를 시작하는 것입니다. 하위 프로세스가 실행되면 수퍼바이저가 비정상적으로 종료되었거나 특정 조건에 도달하여 하위 프로세스를 다시 시작할 수 있습니다. 예를 들어, 감독관은 자녀가 사망하면 모든 자녀를 다시 시작할 수 있습니다. 마지막으로, 관리자는 시스템이 종료 될 때 자식 프로세스를 종료해야합니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2148e1ac9ba1ddbf69713d1fe8062e24faf800f8" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">감독자는 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 동일한 이름 등록 규칙에 바인딩됩니다 . &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 설명서에서 이러한 규칙에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2be41b998235003f44a6fb66b52b2e8add1dfc50" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">감독자는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 동일한 이름 등록 규칙에 바인딩됩니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서에서 이러한 규칙에 대해 자세히 알아보십시오. .</target>
        </trans-unit>
        <trans-unit id="789257e49c9248f0d549832ff687e69eea5012dc" translate="yes" xml:space="preserve">
          <source>A supervisor may be started directly with a list of children via &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; or you may define a module-based supervisor that implements the required callbacks. The sections below use &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; to start supervisors in most examples, but it also includes a specific section on module-based ones.</source>
          <target state="translated">수퍼바이저는 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 를 통해 하위 목록으로 직접 시작 하거나 필요한 콜백을 구현하는 모듈 기반 수퍼바이저를 정의 할 수 있습니다. 아래 섹션 은 대부분의 예에서 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 수퍼바이저를 시작하지만 모듈 기반 섹션에 대한 특정 섹션도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="73975472006297ae3fcad167925a215d573e02d7" translate="yes" xml:space="preserve">
          <source>A supervisor restarts a child process depending on its &lt;code&gt;:restart&lt;/code&gt; configuration. For example, when &lt;code&gt;:restart&lt;/code&gt; is set to &lt;code&gt;:transient&lt;/code&gt;, the supervisor does not restart the child in case it exits with reason &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">감독자는 &lt;code&gt;:restart&lt;/code&gt; 구성 에 따라 하위 프로세스를 다시 시작 합니다. 예를 들어, &lt;code&gt;:restart&lt;/code&gt; 가 &lt;code&gt;:transient&lt;/code&gt; 로 설정 되면 수퍼바이저는 reason &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 되는 경우 하위를 다시 시작하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60c5977b15b358f6b78f3ae1aad052bb829be570" translate="yes" xml:space="preserve">
          <source>A supervisor that starts children dynamically.</source>
          <target state="translated">자식을 동적으로 시작하는 감독자.</target>
        </trans-unit>
        <trans-unit id="615c68fd3df9515609693344bfb85db4d952662a" translate="yes" xml:space="preserve">
          <source>A tag can be set for all tests in a module or describe block by setting &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; inside each context respectively:</source>
          <target state="translated">각 컨텍스트 내에서 각각 &lt;code&gt;@moduletag&lt;/code&gt; 또는 &lt;code&gt;@describetag&lt;/code&gt; 를 설정하여 모듈 또는 describe 블록의 모든 테스트에 대해 태그를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0662f79c653f0ec45efdb5f488b2e4dad7e4bc27" translate="yes" xml:space="preserve">
          <source>A task needs to implement &lt;code&gt;run&lt;/code&gt; which receives a list of command line args.</source>
          <target state="translated">작업 은 명령 행 인수 목록을 수신하는 &lt;code&gt;run&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e97df0f46736141ff7a6d7cb0a21370015757093" translate="yes" xml:space="preserve">
          <source>A task supervisor is started with no children, often under a supervisor and a name:</source>
          <target state="translated">작업 감독자는 자식없이 시작하며 종종 감독자와 이름으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ff48cedfb7c96d7c2ed5d2fcc23ecbe5aa13422a" translate="yes" xml:space="preserve">
          <source>A task supervisor is typically started under a supervision tree using the tuple format:</source>
          <target state="translated">작업 감독자는 일반적으로 튜플 형식을 사용하여 감독 트리에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="400405b3406f1f222a1d0498ff7d0e89bdd37f83" translate="yes" xml:space="preserve">
          <source>A task supervisor.</source>
          <target state="translated">작업 감독자.</target>
        </trans-unit>
        <trans-unit id="b1a878391a15d93f73108d99ebb6b02880382654" translate="yes" xml:space="preserve">
          <source>A task that simply instructs users to run &lt;code&gt;iex -S mix&lt;/code&gt;.</source>
          <target state="translated">사용자에게 &lt;code&gt;iex -S mix&lt;/code&gt; 를 실행하도록 지시하는 작업 .</target>
        </trans-unit>
        <trans-unit id="2894abc710a014ff1c5c80e21ac1103d9d069763" translate="yes" xml:space="preserve">
          <source>A term of type &lt;strong&gt;IO data&lt;/strong&gt; is a binary or a list containing bytes (integers in &lt;code&gt;0..255&lt;/code&gt;) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &lt;code&gt;&quot;hello&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;IO 데이터&lt;/strong&gt; 유형의 용어는 바이트 ( &lt;code&gt;0..255&lt;/code&gt; 의 정수 ) 또는 중첩 된 IO 데이터를 포함하는 이진 또는 목록 입니다. 유형은 재귀 적입니다. 바이너리 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 를 나타내는 가능한 IO 데이터 중 하나의 예를 보자 .</target>
        </trans-unit>
        <trans-unit id="7c720a57b20bbb00d7cd6e1d7bb642e1d8d5947c" translate="yes" xml:space="preserve">
          <source>A test module can define multiple &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks, and they are invoked in order of appearance.</source>
          <target state="translated">테스트 모듈은 여러 개의 &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백을 정의 할 수 있으며 모양 순서대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4945e7afe50419c6b9cae97faa15dec66d7711" translate="yes" xml:space="preserve">
          <source>A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in &lt;code&gt;1 / parts_per_second&lt;/code&gt; seconds. For example, using the &lt;code&gt;:millisecond&lt;/code&gt; time unit is equivalent to using &lt;code&gt;1000&lt;/code&gt; as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).</source>
          <target state="translated">시간 단위는 또한 양의 정수일 수 있습니다. 이 경우 &quot;초당 파트 수&quot;를 나타냅니다. 시간은 &lt;code&gt;1 / parts_per_second&lt;/code&gt; 초로 반환됩니다 . 예를 들어, &lt;code&gt;:millisecond&lt;/code&gt; 시간 단위를 사용 하는 것은 시간 단위로 &lt;code&gt;1000&lt;/code&gt; 을 사용하는 것과 같습니다 (시간은 1/1000 초-밀리 초로 반환 됨).</target>
        </trans-unit>
        <trans-unit id="f8027bb61ebc1be6167e83dd5aa3351e16405a8f" translate="yes" xml:space="preserve">
          <source>A timeout in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 시간 초과가 초과되면 현재 프로세스가 종료됩니다. 작업 프로세스가 작업이 &lt;code&gt;async&lt;/code&gt; 로 시작된 경우 인 현재 프로세스에 링크 된 경우 작업 프로세스도 종료됩니다. 작업 프로세스가 종료되고 있거나 현재 프로세스에 연결되어 있지 않으면 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="198be1f82bcaf7ef6e87003105d7f1bb0913880a" translate="yes" xml:space="preserve">
          <source>A timeout of 0 can be given when you already expect the message to be in the mailbox.</source>
          <target state="translated">메시지가 이미 사서함에있을 것으로 예상되면 시간 초과 0이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdda64adffbe29ce867f4e13216350c2cecaa35a" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68fd1acb1d049659698dd0e6399a2faf0bb992be" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the time runs out before a message from the task is received, this function will return &lt;code&gt;nil&lt;/code&gt; and the monitor will remain active. Therefore &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; can be called multiple times on the same task.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 작업에서 메시지를 받기 전에 시간이 부족하면이 기능은 &lt;code&gt;nil&lt;/code&gt; 을 반환 하고 모니터는 활성 상태를 유지합니다. 따라서 동일한 작업에서 &lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt; 를 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da9b2c8f037d5e02cc94898fc8fb88cecc6bb373" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. Any task processes that are linked to the current process (which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;) will also exit. Any task processes that are trapping exits or not linked to the current process will continue to run.</source>
          <target state="translated">제한 시간 (밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; )은 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 제한 시간을 초과하면 현재 프로세스가 종료됩니다. 현재 프로세스에 연결된 모든 작업 프로세스 (작업이 &lt;code&gt;async&lt;/code&gt; 로 시작되는 경우) 도 종료됩니다. 종료를 트래핑하고 있거나 현재 프로세스에 연결되지 않은 모든 작업 프로세스는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bef32f4d33eabc5b73b7963784b14e838138302d" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">제한 시간 (밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; )은 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 제한 시간을 초과하면 현재 프로세스가 종료됩니다. 작업 프로세스가 현재 프로세스에 연결되어있는 경우 (즉, 작업이 &lt;code&gt;async&lt;/code&gt; 로 시작되는 경우) 작업 프로세스도 종료됩니다. 작업 프로세스가 트래핑 종료되거나 현재 프로세스에 연결되지 않은 경우 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0d4ddbed899c477cc9f6352b9a36db821efe20" translate="yes" xml:space="preserve">
          <source>A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.</source>
          <target state="translated">후행 뱅 (느낌표)은 실패 사례가 예외를 발생시키는 기능 또는 매크로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1557d725dec0291342c366743098a942c2c285d9" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">변환기는 &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 추가 및 제거 할 수있는 모듈과 함수를 포함하는 튜플 이며 4 개의 인수를 사용하여 최소 로그 수준 이상의 모든 Erlang 메시지에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="595193044562313fed22c09af41ccc775c92d1e5" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;logger#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">변환기는 단순히 모듈과 &lt;a href=&quot;logger#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;logger#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 추가 및 제거 할 수있는 기능을 포함하는 튜플이며, 네 개의 인수를 사용하여 최소 로그 레벨 이상의 모든 Erlang 메시지에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="977fa89e1a9a5fcdc6a2202879cd6a99f38e175d" translate="yes" xml:space="preserve">
          <source>A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals.</source>
          <target state="translated">튜플은 메모리에 연속적으로 저장된 다른 유형의 요소를 포함 할 수 있습니다. 요소에 액세스하는 데는 시간이 걸리지 만 얕은 복사본을 생성하는 튜플을 수정하면 선형 시간이 걸립니다. 튜플은 데이터를 읽는 데 좋고리스트는 순회에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="016c5c6429720a5f0c24e4c4b0bbc87c166f277a" translate="yes" xml:space="preserve">
          <source>A tuple representing the &lt;code&gt;day&lt;/code&gt; and the &lt;code&gt;era&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;day&lt;/code&gt; 와 &lt;code&gt;era&lt;/code&gt; 나타내는 튜플 .</target>
        </trans-unit>
        <trans-unit id="3b70a1f3c40082637faa4be4833ceb4685eae005" translate="yes" xml:space="preserve">
          <source>A type defined with &lt;code&gt;@typep&lt;/code&gt; is private. An opaque type, defined with &lt;code&gt;@opaque&lt;/code&gt; is a type where the internal structure of the type will not be visible, but the type is still public.</source>
          <target state="translated">&lt;code&gt;@typep&lt;/code&gt; 로 정의 된 유형 은 개인용입니다. &lt;code&gt;@opaque&lt;/code&gt; 로 정의 된 불투명 한 형식 은 형식의 내부 구조가 보이지 않지만 형식은 여전히 ​​공용 인 형식입니다.</target>
        </trans-unit>
        <trans-unit id="8d3bd389baf78dba20b0d8db318aee60b33e011c" translate="yes" xml:space="preserve">
          <source>A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup.</source>
          <target state="translated">이 등록과 관련된 값도 제공해야합니다. 이 값은 디스패치하거나 키 조회를 수행 할 때마다 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="e27b2906462bb426d4db8b9c875eb3719eb195a6" translate="yes" xml:space="preserve">
          <source>A variable assigned inside a function does not affect its surrounding environment:</source>
          <target state="translated">함수 내부에 지정된 변수는 주변 환경에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eefe91c5b1f2dca4795e8c30b3e66948a135ee4c" translate="yes" xml:space="preserve">
          <source>A variable can only be assigned on the left side of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">변수는 &lt;code&gt;=&lt;/code&gt; 의 왼쪽에만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74219847f96158b812f49f7af3b9dcb687e015d5" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전은 특정 형식의 문자열이거나 &lt;a href=&quot;#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; 을&lt;/a&gt; 통해 구문 분석 한 후 생성 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc60d48fd93ed889b691c632db601f39d5eb520c" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;version#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전은 특정 형식의 문자열이거나 &lt;a href=&quot;version#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; 을&lt;/a&gt; 통해 구문 분석 한 후 생성 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e264f31a676a2f05ae95352027c4734997cd7f9" translate="yes" xml:space="preserve">
          <source>A very basic example is:</source>
          <target state="translated">매우 기본적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddca9755179e1f59903c4ddf6f15ddbb4628e05" translate="yes" xml:space="preserve">
          <source>A warning will be printed on missing assigns. Future versions will raise.</source>
          <target state="translated">누락 된 어사 인에 경고가 인쇄됩니다. 향후 버전이 올라갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ca63c80632d0cf1aa32c53e95d09843a1d1dd72" translate="yes" xml:space="preserve">
          <source>A word on distributed agents</source>
          <target state="translated">분산 에이전트에 대한 단어</target>
        </trans-unit>
        <trans-unit id="be1bb8f888ee7021de890698fb2afa717b6c1550" translate="yes" xml:space="preserve">
          <source>ACC - total time spent in the function</source>
          <target state="translated">ACC-함수에 소요 된 총 시간</target>
        </trans-unit>
        <trans-unit id="1afeece78fd2f8c83db0f4140c005969fde50b55" translate="yes" xml:space="preserve">
          <source>AM, PM</source>
          <target state="translated">오전 오후</target>
        </trans-unit>
        <trans-unit id="fcdb408000857fa7b09129071afdc276c3c00665" translate="yes" xml:space="preserve">
          <source>ANSI escapes are typically enabled on all Unix terminals. They are also available on Windows consoles from Windows 10, although it must be explicitly enabled for the current user in the registry by running the following command:</source>
          <target state="translated">ANSI 이스케이프는 일반적으로 모든 Unix 터미널에서 활성화됩니다. 다음 명령을 실행하여 레지스트리에서 현재 사용자에 대해 명시 적으로 활성화해야하지만 Windows 10의 Windows 콘솔에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="586d4163da04d5ab6791e3c06e9ffe5c9db509ec" translate="yes" xml:space="preserve">
          <source>ANSI escapes in &lt;code&gt;string&lt;/code&gt; are not processed in any way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; ANSI 이스케이프는 어떤 식으로도 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="7c131b6fb9555cb305f8aaa2c2c98e087084d42b" translate="yes" xml:space="preserve">
          <source>API Reference &lt;small&gt;Mix v1.11.2&lt;/small&gt;</source>
          <target state="translated">API 참조 &lt;small&gt;믹스 v1.11.2&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="08955ef48e12709a927739991a3df46487d19807" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정의 설정 파일 읽기위한 API &lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b2a5e26234b2a9ea3b34162d62a110a48636bad" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; 로&lt;/a&gt; 정의 된 구성 파일을 읽기위한 API .</target>
        </trans-unit>
        <trans-unit id="8b349aa6f5c8405e74e0ce2c3f7201bebe1b4de3" translate="yes" xml:space="preserve">
          <source>AST considerations</source>
          <target state="translated">AST 고려 사항</target>
        </trans-unit>
        <trans-unit id="722e9952d5c095e4d71bce17445a76597f676acc" translate="yes" xml:space="preserve">
          <source>AST representation</source>
          <target state="translated">AST 표현</target>
        </trans-unit>
        <trans-unit id="c3b1354957064f90a14a0b8903ae1bce0e675785" translate="yes" xml:space="preserve">
          <source>Abbreviated month name</source>
          <target state="translated">약식 월 이름</target>
        </trans-unit>
        <trans-unit id="137c90672799288dc1f78441e61fc461964bf9c8" translate="yes" xml:space="preserve">
          <source>Abbreviated name of day</source>
          <target state="translated">요일의 약칭</target>
        </trans-unit>
        <trans-unit id="266c0ed1029b1e5c3251173a36c9d608b25b8d14" translate="yes" xml:space="preserve">
          <source>Aborts when a command exits with a non-zero status.</source>
          <target state="translated">명령이 0이 아닌 상태로 종료되면 중단합니다.</target>
        </trans-unit>
        <trans-unit id="451a24b564c25a56a12bc821b009bb17521b7976" translate="yes" xml:space="preserve">
          <source>Above, &lt;code&gt;x&lt;/code&gt; matched on only the first byte of the multibyte &lt;code&gt;&amp;uuml;&lt;/code&gt; character.</source>
          <target state="translated">위의 &lt;code&gt;x&lt;/code&gt; 는 멀티 바이트 &lt;code&gt;&amp;uuml;&lt;/code&gt; 문자 의 첫 번째 바이트에서만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="fff456f1c782da0b35f8fa5b303ce271025c27f6" translate="yes" xml:space="preserve">
          <source>Abstract Syntax Tree (AST)</source>
          <target state="translated">추상 구문 트리 (AST)</target>
        </trans-unit>
        <trans-unit id="23b0c80e9057a10f37a2f52e111994951df16105" translate="yes" xml:space="preserve">
          <source>Accepted formats</source>
          <target state="translated">허용되는 형식</target>
        </trans-unit>
        <trans-unit id="c4bbf6c7d04ca5c93be2107e4482d4ce88d69909" translate="yes" xml:space="preserve">
          <source>Accepted padding options</source>
          <target state="translated">허용되는 패딩 옵션</target>
        </trans-unit>
        <trans-unit id="16d98934b253153ce90ef5967a4ab32ed934fb4d" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;ignore: :whitespace&lt;/code&gt; option which will ignore all the whitespace characters in the input string.</source>
          <target state="translated">입력 문자열의 모든 공백 문자를 무시하는 &lt;code&gt;ignore: :whitespace&lt;/code&gt; 옵션을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="ff9572ac36a4e1f1c2d3b6e7fe1206f556bcd6be" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will ignore padding from the input string.</source>
          <target state="translated">&lt;code&gt;padding: false&lt;/code&gt; 옵션을 허용 합니다. 입력 문자열에서 패딩을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e6606a70939f51500cf29d0104ea455b8e57bbbd" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will omit padding from the output string.</source>
          <target state="translated">&lt;code&gt;padding: false&lt;/code&gt; 허용 : 출력 문자열에서 패딩을 생략하는 false 옵션.</target>
        </trans-unit>
        <trans-unit id="d11f73644b7b3add855698ef69a041b85cac741e" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located.</source>
          <target state="translated">&lt;code&gt;relative_to&lt;/code&gt; 를 인수로 받아 들여 파일의 위치를 ​​알려줍니다.</target>
        </trans-unit>
        <trans-unit id="312c5b592fe6d7dd571d6c8037a1f4c663f75282" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located. If the file was already required, &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; doesn't do anything and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;relative_to&lt;/code&gt; 를 인수로 받아 들여 파일의 위치를 ​​알려줍니다. 파일이 이미 필요한 경우 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 는 아무것도하지 않고 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8f51a20bef3da7c165ebe3b333dbb26c7d054f" translate="yes" xml:space="preserve">
          <source>Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms.</source>
          <target state="translated">원자 또는 그러한 원자 목록의 형태로 단일 배열 함수의 블록 또는 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8001c91fcbcc7035c433992b44685f5330523f6b" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c68ab20eebd551a8183d8a271c2a11f2f59f798e" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take 6 arguments:</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 이 함수는 6 개의 인수를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7bebfa805f9fa42810edbee6281c1119c222c690" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be &lt;code&gt;__after_compile__/2&lt;/code&gt;.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 함수는 모듈 환경과 바이트 코드의 두 가지 인수를 가져야합니다. 모듈 만 제공되는 경우 함수는 &lt;code&gt;__after_compile__/2&lt;/code&gt; 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e8eec1dc724492ff94d0553bb6ff5b22253d396" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 튜플을 승인합니다 . 함수 / 매크로는 모듈 환경이라는 하나의 인수를 취해야합니다. 매크로 인 경우 컴파일이 시작되기 전에 반환 된 값이 모듈 정의의 끝에 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="b8a02787b1528282c9b913825c8890849c97b169" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@doc false&lt;/code&gt; will make the entity invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;code&gt;@doc false&lt;/code&gt; 를 사용하면 &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; &lt;/a&gt; 과 같은 문서 추출 도구에서 엔티티를 볼 수 없게 되는 문자열 ( 여기서는 heredoc ) 또는 &lt;code&gt;false&lt;/code&gt; 를 허용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e201112d9033197e821f8bcdf23e660e950b4fd3" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@moduledoc false&lt;/code&gt; will make the module invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@moduledoc false&lt;/code&gt; 를 사용하면 &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; &lt;/a&gt; 과 같은 문서 추출 도구에서 모듈을 볼 수 없는 문자열 ( 여기서는 heredoc ) 또는 &lt;code&gt;false&lt;/code&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="ca7b2060d47af260a69b6e20f3d794d68fe54093" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 &lt;code&gt;amount_to_add&lt;/code&gt; 를 허용합니다 . 음수 값은 시간이지나면서 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a5cd37e51e05c989f61c56fcc8057339b69ee344" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 &lt;code&gt;amount_to_add&lt;/code&gt; 를 승인합니다 . 음수 값은 시간이 지나면 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9c7e182b3105eb309155a16cd4d01036199f0e2d" translate="yes" xml:space="preserve">
          <source>Accepts an atom, a tuple, or a list of atoms and tuples. For example:</source>
          <target state="translated">원자, 튜플 또는 원자 및 튜플 목록을 승인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6f11dba90273a10068990877edcdfb26f22547" translate="yes" xml:space="preserve">
          <source>Accepts the function name (as an atom) of a function in the current module or &lt;code&gt;{function_name, 0}&lt;/code&gt; tuple where &lt;code&gt;function_name&lt;/code&gt; is the name of a function in the current module. The function must be public and have an arity of 0 (no arguments). If the function does not return &lt;code&gt;:ok&lt;/code&gt;, the loading of the module will be aborted. For example:</source>
          <target state="translated">현재 모듈 또는 &lt;code&gt;{function_name, 0}&lt;/code&gt; 튜플에서 &lt;code&gt;function_name&lt;/code&gt; 의 함수 이름 (원자)을 승인합니다. 여기서 function_name 은 현재 모듈의 함수 이름입니다. 이 함수는 public이어야하고 arity가 0이어야합니다 (인수 없음). 함수가 &lt;code&gt;:ok&lt;/code&gt; 를 반환하지 않으면 모듈 로딩이 중단됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1882f04cc0835dbca87fc3529d0d49574c5244e" translate="yes" xml:space="preserve">
          <source>Accepts the same options as &lt;a href=&quot;#read!/2&quot;&gt;&lt;code&gt;read!/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#read!/2&quot;&gt; &lt;code&gt;read!/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="16bd460f20e6be8ef8de7ddd09d7916ce4c21b09" translate="yes" xml:space="preserve">
          <source>Accepts the same options as &lt;a href=&quot;#read!/2&quot;&gt;&lt;code&gt;read!/2&lt;/code&gt;&lt;/a&gt;. Although note the &lt;code&gt;:imports&lt;/code&gt; option cannot be disabled in &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#read!/2&quot;&gt; &lt;code&gt;read!/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 . 참고 있지만 &lt;code&gt;:imports&lt;/code&gt; 옵션은 비활성화 할 수 없습니다 &lt;a href=&quot;#read_imports!/2&quot;&gt; &lt;code&gt;read_imports!/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2f81a22de0af5e9eab19326e19693f86ce612518" translate="yes" xml:space="preserve">
          <source>Access</source>
          <target state="translated">Access</target>
        </trans-unit>
        <trans-unit id="61eeb1ced62d9d70c3a7da771b7e65111efa9eeb" translate="yes" xml:space="preserve">
          <source>Access &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">액세스 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="32cc0e2e72b4a5cd8e1d10f3088022c273757f9c" translate="yes" xml:space="preserve">
          <source>Access syntax</source>
          <target state="translated">액세스 구문</target>
        </trans-unit>
        <trans-unit id="ffaea95d2c8c2a121901ac8053918362a2259c0d" translate="yes" xml:space="preserve">
          <source>Accesses an already bound variable in match clauses. Also known as the pin operator.</source>
          <target state="translated">match 절에서 이미 바인딩 된 변수에 액세스합니다. 핀 연산자라고도합니다.</target>
        </trans-unit>
        <trans-unit id="114bded9b29083adea70f97a0e2b9cca28f2f55b" translate="yes" xml:space="preserve">
          <source>Accessing and updating structs</source>
          <target state="translated">구조체 접근 및 업데이트</target>
        </trans-unit>
        <trans-unit id="d92e8c05ab3b611d5a9111ea714f7aba0dcfee85" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">구조 / 캐치 외부에서 스택 추적에 액세스하는 것은 더 이상 사용되지 않습니다. Elixir v1.7 + 만 지원하려면 구조 / 잡기 내에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 액세스해야합니다 . 이전 Elixir 버전을 지원하려면 구조 / 캐치 내에서 &lt;a href=&quot;#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; 을&lt;/a&gt; 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="778701a39f61d1d0d376ec6add6756493d3c6f48" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;system#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">구조 / 캐치 외부의 스택 추적에 액세스하는 것은 더 이상 사용되지 않습니다. Elixir v1.7 + 만 지원하려면 복구 / 캐치 내의 &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 액세스해야합니다 . 이전 Elixir 버전을 지원하려면 복구 / 캐치 내에서 &lt;a href=&quot;system#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; 을&lt;/a&gt; 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="c08435b6ee1c53e0f3db32fa2d67cb282966fb48" translate="yes" xml:space="preserve">
          <source>According to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table. Since this is a race condition, you may not be able to reproduce it on your machine, but it is there.</source>
          <target state="translated">실패 메시지에 따르면 버킷이 더 이상 테이블에 존재하지 않을 것으로 예상되지만 여전히 존재합니다! 이 문제는 방금 해결 한 것과 반대입니다. 이전에는 버킷을 생성하는 명령과 테이블을 업데이트하는 명령 사이에 지연이 있었지만 이제 버킷 프로세스 종료와 해당 항목이 테이블에서 제거되는 사이에 지연이있었습니다. 이것은 경쟁 조건이므로 컴퓨터에서 재현 할 수 없지만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82c99de451613d4c3468e6d7fc04fc56efcc179" translate="yes" xml:space="preserve">
          <source>Actually expands to:</source>
          <target state="translated">실제로 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="202286aca5e6c6b464a262fb2ffaeb8e0a69b604" translate="yes" xml:space="preserve">
          <source>Adding a backend calls the &lt;code&gt;init/1&lt;/code&gt; function in that backend with the name of the backend as its argument. For example, calling</source>
          <target state="translated">백엔드를 추가하면 백엔드 의 이름을 인수로 사용하여 해당 백엔드에서 &lt;code&gt;init/1&lt;/code&gt; 함수를 호출합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="9e4e792ab5793275266dbf12ecb483ea47d35fb1" translate="yes" xml:space="preserve">
          <source>Adding explicit parentheses is enough to bind the block to &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">명시 적 괄호를 추가 &lt;code&gt;if&lt;/code&gt; 다음 과 같은 경우에 블록을 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b78cd7b823ca5c0a3d8b8957b6fa3d25e3152ce" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; 는이 AST의 모든 발생을 &lt;code&gt;left not in right&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="be05b1119a34ef95ba3623420677cc256aa4984b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; 는이 AST의 모든 항목을 &lt;code&gt;left not in right&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="a9250bc8f269bb31b837fb16fb14515407c5ad27" translate="yes" xml:space="preserve">
          <source>Additionally, it documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="translated">또한 두 가지 특수 형식 인 &lt;a href=&quot;#__block__/1&quot;&gt; &lt;code&gt;__block__/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#__aliases__/1&quot;&gt; &lt;code&gt;__aliases__/1&lt;/code&gt; &lt;/a&gt; 문서화합니다.이 형식 은 개발자가 직접 호출 할 수는 없지만 Elixir의 구성에 필수적이기 때문에 인용 된 내용으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="084086258188a6f83f3c0621f1d91c6afb01428b" translate="yes" xml:space="preserve">
          <source>Additionally, the following functions and operators for lists are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에는 다음과 같은 목록의 함수와 연산자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78d4c95ca68cd548509bceede9d001db1a210fc" translate="yes" xml:space="preserve">
          <source>Additionally, the following scope values can be configured:</source>
          <target state="translated">또한 다음 범위 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4dc66f0bc20a88e0f32abc42201d155226df5e" translate="yes" xml:space="preserve">
          <source>Additionally, there are a few other operators that Elixir parses but doesn't actually use. See &lt;a href=&quot;#custom-and-overridden-operators&quot;&gt;Custom and overridden operators&lt;/a&gt; below for a list and for guidelines about their use.</source>
          <target state="translated">또한 Elixir가 구문 분석하지만 실제로 사용하지 않는 몇 가지 다른 연산자가 있습니다. 페이지의 &lt;a href=&quot;#custom-and-overridden-operators&quot;&gt;사용자 정의 및 오버라이드 (override) 사업자&lt;/a&gt; 목록은 다음과 사용에 대한 지침.</target>
        </trans-unit>
        <trans-unit id="c6de0ba362d2990726a5406d543d6c577cd47aac" translate="yes" xml:space="preserve">
          <source>Adds a callback that runs after a given compiler.</source>
          <target state="translated">주어진 컴파일러 이후에 실행되는 콜백을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="edc18d92bf1b07aac7b2b79037d7ed0c830219fc" translate="yes" xml:space="preserve">
          <source>Adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에게 자식 사양을 추가하고 해당 자식을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="af3a79b1bbb83ca34755ad54eebe67e43975dc73" translate="yes" xml:space="preserve">
          <source>Adds a new backend.</source>
          <target state="translated">새로운 백엔드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4547e3e08756cb2ef5ae23175de234a94738c653" translate="yes" xml:space="preserve">
          <source>Adds a new translator.</source>
          <target state="translated">새 번역기를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9653b7fdeddd56fa913d9c1e6e4dd46142fe6bb5" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0fefe8eff4657ca8af82a86c4c01dcdded8f65fb" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b33fc73fd1c20e1aa238dde8be82279974905542" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;number&lt;/code&gt; of &lt;code&gt;unit&lt;/code&gt;s to the given &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;time&lt;/code&gt; 에 &lt;code&gt;unit&lt;/code&gt; &lt;code&gt;number&lt;/code&gt; 를 더 합니다 .</target>
        </trans-unit>
        <trans-unit id="ad9a4469809cf0d6f045e57922aa36fef739da3f" translate="yes" xml:space="preserve">
          <source>Adds the number of days to the given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 에 일 수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="789089ca60682ff54ac072e501a17b9c7a45b283" translate="yes" xml:space="preserve">
          <source>Adopting a behaviour is straightforward:</source>
          <target state="translated">행동을 채택하는 것은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="3aa1232b05d45b3e4a3b9d5865607daf60ef5d9b" translate="yes" xml:space="preserve">
          <source>Adopting behaviours</source>
          <target state="translated">행동 채택</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="9ffdfdf4928b7893065d8f9388d98cfc7e4718e4" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;IO.write/2&lt;/code&gt;, we can see the request sent by the &lt;code&gt;IO&lt;/code&gt; module (a four-elements tuple) printed out. Soon after that, we see that it fails since the &lt;code&gt;IO&lt;/code&gt; module expected some kind of result, which we did not supply.</source>
          <target state="translated">&lt;code&gt;IO.write/2&lt;/code&gt; 후에 는 &lt;code&gt;IO&lt;/code&gt; 모듈 (4 요소 튜플)이 보낸 요청이 인쇄 된 것을 볼 수 있습니다. 그 후 곧 우리는 &lt;code&gt;IO&lt;/code&gt; 모듈이 우리가 제공하지 않은 어떤 종류의 결과를 기대 했기 때문에 실패한다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="2ddb14dc4a5af806ba7555a5887878788a5f483a" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">모듈이 컴파일 된 후이 모듈의 많은 함수를 사용하면 런타임 데이터를 검사하는 범위를 벗어나므로 오류가 발생합니다. 대부분의 런타임 데이터는 컴파일 된 각 모듈에 연결된 &lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83a04e6c0b27ee981def4e7b4af06e562bbb3d2e" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">모듈이 컴파일 된 후이 모듈의 많은 함수를 사용하면 런타임 데이터를 검사 할 수있는 범위를 벗어나므로 오류가 발생합니다. 대부분의 런타임 데이터는 컴파일 된 각 모듈에 연결된 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6dcdc4f162ba136a3bc34f25783a0a1ec25d1f72" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;shell&lt;/code&gt; becomes the shell that is returned by &lt;a href=&quot;#shell/0&quot;&gt;&lt;code&gt;shell/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;shell&lt;/code&gt; 은 &lt;a href=&quot;#shell/0&quot;&gt; &lt;code&gt;shell/0&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 쉘이 됩니다.</target>
        </trans-unit>
        <trans-unit id="015771d68b1b737818fe24be939749860bc0bbd0" translate="yes" xml:space="preserve">
          <source>After closing the pair, zero or more ASCII letters can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with &lt;code&gt;sigil_&lt;/code&gt; where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers:</source>
          <target state="translated">쌍을 닫은 후 0 개 이상의 ASCII 문자를 수정 자로 지정할 수 있습니다. 비공 호출 접두사로서 Sigils 표현된다 &lt;code&gt;sigil_&lt;/code&gt; 첫 번째 인수는 문자열과 상기 제 인수로 인장 내용이 개질제로서 정수의 목록이다 :</target>
        </trans-unit>
        <trans-unit id="08a92d7d688a663eb3eb033ee1302c04449e9c25" translate="yes" xml:space="preserve">
          <source>After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:</source>
          <target state="translated">언어의 기본에 익숙해지면 간단한 프로그램을 작성해 볼 수 있습니다. 다음과 같은 Elixir 코드를 파일에 넣으면됩니다.</target>
        </trans-unit>
        <trans-unit id="a5362624d23008d521bcd0d5c26b23351f7a9875" translate="yes" xml:space="preserve">
          <source>After installation, the escript can be invoked as</source>
          <target state="translated">설치 후 escript를 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb046b5f9d4fee0d614358484f4e987759694e75" translate="yes" xml:space="preserve">
          <source>After installation, the tasks in the archive are available locally:</source>
          <target state="translated">설치 후 아카이브의 작업을 로컬에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef5d6001f62dd7d7ca161d7e6411b62975177f6c" translate="yes" xml:space="preserve">
          <source>After running the command above, you must restart your current console.</source>
          <target state="translated">위의 명령을 실행 한 후 현재 콘솔을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b0b8b87bea42239c7cce2999de90ae444ed1e38" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Note that the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">이 두 메시지를 보낸 후 포트에서받은 모든 메시지를 인쇄 하는 IEx 도우미 &lt;code&gt;flush()&lt;/code&gt; 호출 했습니다.이 경우 &quot;hello&quot;와 &quot;world&quot;가 다시 표시됩니다. &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt; 에서 포트를 열 때 &lt;code&gt;:binary&lt;/code&gt; 옵션을 전달했기 때문에 메시지는 바이너리로 되어 있습니다 . 이러한 옵션이 없으면 바이트 목록이 생성되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="01d3a5404436a56254e32994bb8c7a88df4d1e46" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Notice the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;port#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">이 두 메시지를 보낸 후 포트에서받은 모든 메시지를 인쇄 한 IEx 도우미 &lt;code&gt;flush()&lt;/code&gt; 호출 했습니다.이 경우 &quot;hello&quot;와 &quot;world&quot;가 다시 나타납니다. &lt;a href=&quot;port#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt; 에서 포트를 열 때 &lt;code&gt;:binary&lt;/code&gt; 옵션을 전달했기 때문에 메시지가 바이너리로 되어 있습니다 . 이러한 옵션이 없으면 바이트 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c5a6d820a4e4b08554b8cba7d6f0f399ab90d4" translate="yes" xml:space="preserve">
          <source>After the child specification is retrieved, the fields on &lt;code&gt;overrides&lt;/code&gt; are directly applied on the child spec. If &lt;code&gt;overrides&lt;/code&gt; has keys that do not map to any child specification field, an error is raised.</source>
          <target state="translated">하위 스펙을 검색 한 후 &lt;code&gt;overrides&lt;/code&gt; 의 필드 가 하위 스펙에 직접 적용됩니다. 경우 &lt;code&gt;overrides&lt;/code&gt; 하위 사양 필드에 매핑되지 않는 키가 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e6e228112ef9b4259dcc6e0928e5df6bda71427" translate="yes" xml:space="preserve">
          <source>After the parsing is done, we will update our server to dispatch the parsed commands to the &lt;code&gt;:kv&lt;/code&gt; application we built previously.</source>
          <target state="translated">구문 분석이 완료되면 서버를 업데이트하여 구문 분석 된 명령을 이전에 빌드 한 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 으로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="ce3b3ab3e45322474dff11a84ad17efa34605f34" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">포트가 생성 된 후 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 메시지 형태로 두 개의 명령을 보냈습니다 . 첫 번째 명령에는 &quot;hello&quot;의 바이너리 페이로드가 있고 두 번째 명령에는 &quot;world&quot;가 있습니다.</target>
        </trans-unit>
        <trans-unit id="126c87f3f297e14cbbd86077daaca606cae164a1" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">포트가 생성 된 후 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 메시지 형태로 두 개의 명령을 보냈습니다 . 첫 번째 명령에는 &quot;hello&quot;라는 이진 페이로드가 있고 두 번째 명령에는 &quot;world&quot;가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a727cf7abfa15b42a8b410dabb9bf09752b2748" translate="yes" xml:space="preserve">
          <source>After the supervisor retrieves all child specifications, it proceeds to start its children one by one, in the order they were defined, using the information in the &lt;code&gt;:start&lt;/code&gt; key in the child specification. For our current specification, it will call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저는 모든 하위 사양을 검색 한 후 하위 사양의 &lt;code&gt;:start&lt;/code&gt; 키에있는 정보를 사용하여 정의 된 순서대로 하위를 하나씩 시작 합니다. 현재 사양에서는 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="287bb38e4e6cedef8023aef386835e79ed530f95" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">위의 두 번 가져 오기 호출 후에는 &lt;a href=&quot;https://hexdocs.pm/elixir/List.html#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt; 만 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5ae1d560c6b4b698d633609ab136df680bf93a49" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;list#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">위의 두 번의 가져 오기 호출 후 &lt;a href=&quot;list#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt; 만 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5d98e7e2a0b904bdc0ce797580a3b0c7291ef112" translate="yes" xml:space="preserve">
          <source>After this function is called, &lt;code&gt;port&lt;/code&gt; will be returned by &lt;a href=&quot;#default_port/1&quot;&gt;&lt;code&gt;default_port/1&lt;/code&gt;&lt;/a&gt; for the given scheme &lt;code&gt;scheme&lt;/code&gt;. Note that this function changes the default port for the given &lt;code&gt;scheme&lt;/code&gt;&lt;em&gt;globally&lt;/em&gt;, meaning for every application.</source>
          <target state="translated">이 함수가 호출 된 후 주어진 체계 &lt;code&gt;scheme&lt;/code&gt; 대해 &lt;code&gt;port&lt;/code&gt; 는 &lt;a href=&quot;#default_port/1&quot;&gt; &lt;code&gt;default_port/1&lt;/code&gt; &lt;/a&gt; 에 의해 리턴됩니다 . 이 함수는 주어진 &lt;code&gt;scheme&lt;/code&gt; 의 기본 포트를 &lt;em&gt;전역 적으로&lt;/em&gt; 변경하므로 모든 응용 프로그램에 적용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ce2e6f40299204d94dfc0abf19fa8ab52d6c211" translate="yes" xml:space="preserve">
          <source>Agent</source>
          <target state="translated">Agent</target>
        </trans-unit>
        <trans-unit id="64acf7e2a7590f731f683acd7aa2c04794d8cfee" translate="yes" xml:space="preserve">
          <source>Agents</source>
          <target state="translated">Agents</target>
        </trans-unit>
        <trans-unit id="42dff267934990ba61a679256d1501706a0e086a" translate="yes" xml:space="preserve">
          <source>Agents are a simple abstraction around state.</source>
          <target state="translated">에이전트는 상태에 대한 간단한 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="471de3b97e03acd6d8c9e778e9edad48b7ff717f" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">에이전트는 클라이언트와 서버 API ( &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 유사)를 분리 합니다. 특히 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 함수 호출에 인수로 전달 된 함수는 에이전트 (서버) 내부에서 호출됩니다. 이 구별은 요청이 이행 될 때까지 에이전트를 효과적으로 차단하므로 에이전트 내부에서 값 비싼 조작을 피할 수 있기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d487a9a82d7ef9002acb21970078ec8fea1c1465" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">에이전트는 클라이언트와 서버 API ( &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 유사)를 분리 합니다. 특히 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 함수 호출에 인수로 전달 된 함수는 에이전트 (서버) 내에서 호출됩니다. 요청이 이행 될 때까지 에이전트를 효과적으로 차단하므로 에이전트 내부에서 비용이 많이 드는 작업을 피하려고 할 수 있으므로 이러한 구분이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e95c6b8e92e1e60f6213d7958b0da2f180bb6e84" translate="yes" xml:space="preserve">
          <source>Alias shortcut</source>
          <target state="translated">별명 단축키</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9908d354e7b00c08a0a26e0405d0c3d4105165ab" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">별칭은 컴파일 타임에 원자로 확장되는 구조입니다. 별칭 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 은 atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 로 확장됩니다 . 별칭은 ASCII 대문자로 시작해야하며 그 뒤에 ASCII 문자, 숫자 또는 밑줄이 올 수 있습니다. 비 ASCII 문자는 별칭에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5851935f3ef549bdaa12137353f49d219f63837" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">별칭은 컴파일 타임에 원자로 확장되는 구문입니다. 별명 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 은 atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 으로 확장됩니다 . 별명은 ASCII 대문자로 시작해야하며 뒤에 ASCII 문자, 숫자 또는 밑줄이 올 수 있습니다. 비 ASCII 문자는 별명에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f30b783a5f1e139f6a5d96cc53a7d69f34c844f" translate="yes" xml:space="preserve">
          <source>Aliases are expanded (if possible) and return atoms</source>
          <target state="translated">별명 확장 (가능한 경우) 및 원자 반환</target>
        </trans-unit>
        <trans-unit id="4a6b274949d1238578afe2d23ab6b398292dddae" translate="yes" xml:space="preserve">
          <source>Aliases are frequently used to define shortcuts. In fact, calling &lt;code&gt;alias&lt;/code&gt; without an &lt;code&gt;:as&lt;/code&gt; option sets the alias automatically to the last part of the module name, for example:</source>
          <target state="translated">별칭은 바로 가기를 정의하는 데 자주 사용됩니다. 실제로 &lt;code&gt;:as&lt;/code&gt; 옵션 없이 &lt;code&gt;alias&lt;/code&gt; 를 호출 하면 다음과 같이 별명이 모듈 이름의 마지막 부분으로 자동 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47bc7db39f959bb0d4762319a37898eaad71d649" translate="yes" xml:space="preserve">
          <source>Aliases are represented by an &lt;code&gt;__aliases__&lt;/code&gt; call with each segment separated by dot as an argument:</source>
          <target state="translated">별명은 인수로 점으로 구분 된 각 세그먼트와 함께 &lt;code&gt;__aliases__&lt;/code&gt; 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e23b34bcabd70da598f18dfcddb8220122d3216a" translate="yes" xml:space="preserve">
          <source>Aliases are shortcuts or tasks specific to the current project.</source>
          <target state="translated">별칭은 현재 프로젝트와 관련된 바로 가기 또는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0ce137f58fb14f4c5735e756413156223cbdec1d" translate="yes" xml:space="preserve">
          <source>Aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Clean.html&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="translated">별칭을 사용하여 기존 작업을 확장 할 수도 있습니다. Mix가 모르는 다른 디렉토리를 정리 하기 위해 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Clean.html&quot;&gt; &lt;code&gt;mix clean&lt;/code&gt; &lt;/a&gt; 을 늘리고 싶다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="dc86688ecfcf9059408582f98b57b9f4cbad8152" translate="yes" xml:space="preserve">
          <source>Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example:</source>
          <target state="translated">Alixir 스크립트와 쉘 명령을 실행하기 위해 별칭을 매우 강력하게 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dd7a63c3cd9394fafd3a4d7cedc21c8e943565f" translate="yes" xml:space="preserve">
          <source>Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.</source>
          <target state="translated">현재 프로젝트에 정의 된 별칭은 해당 종속성에 영향을 미치지 않으며 종속성에 정의 된 별칭은 현재 프로젝트에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abd1a8b6bae9484ed0f8605fb305658910cefe92" translate="yes" xml:space="preserve">
          <source>Aliases expand to atoms because in the Erlang</source>
          <target state="translated">Erlang에서 별칭은 원자로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f82ba68692bccb420e6f34813f0fa1ce8af8c883" translate="yes" xml:space="preserve">
          <source>Aliases inside quote are hygienic by default. Consider the following example:</source>
          <target state="translated">인용 부호 안의 별칭은 기본적으로 위생적입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fb42d78167a0f8c042ef1bf76a5e556ce9a643e9" translate="yes" xml:space="preserve">
          <source>Aliases may also be lists, specifying multiple tasks to be run consecutively:</source>
          <target state="translated">여러 작업을 연속적으로 실행하도록 지정하여 별칭을 목록으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb194589028d8ecdd8a81b698121fdd94e9a4477" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 모듈 이름으로 사용되는 별칭 은 &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.html&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; 와 같이 &lt;code&gt;CamelCase&lt;/code&gt; 로 대문자로 작성하고 작성해야하므로 예외 입니다. 별칭의 경우 대문자는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt; 과 같은 두문자어로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8d1c898fa93e8bcfa2c17a37c421760581f9672" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 모듈 이름으로 사용되는 별명 은 &lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; 와 같이 대문자로 작성하고 &lt;code&gt;CamelCase&lt;/code&gt; 로 작성해야하므로 예외 입니다. 별칭의 경우 대문자는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt; 과 같은 두문자어로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="493ad9ebd988ff9d7cf101317d6dd33763da348c" translate="yes" xml:space="preserve">
          <source>All Elixir code runs inside processes that communicate with each other. When a process dies of &amp;ldquo;natural causes&amp;rdquo; (e.g., unhandled exceptions), it sends an &lt;code&gt;exit&lt;/code&gt; signal. A process can also die by explicitly sending an &lt;code&gt;exit&lt;/code&gt; signal:</source>
          <target state="translated">모든 Elixir 코드는 서로 통신하는 프로세스 내에서 실행됩니다. 프로세스가 &quot;자연적 원인&quot;(예 : 처리되지 않은 예외)으로 죽으면 &lt;code&gt;exit&lt;/code&gt; 신호를 보냅니다 . &lt;code&gt;exit&lt;/code&gt; 신호를 명시 적으로 전송하여 프로세스를 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc3c548d2fd0d5198604c9d4a51b137d915ab1ca" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again.</source>
          <target state="translated">시스템이 모든 응용 프로그램을 다시 시작하기 전에 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 모든 포트가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="32c3b583cda24a964ba5c0b1c5db5a5180eab7bc" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 시스템이 종료되기 전에 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 모든 포트가 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="ea13d46d1a7a005cc3e73f0e566c97f99798c880" translate="yes" xml:space="preserve">
          <source>All arguments, except the first, are guaranteed to be atoms.</source>
          <target state="translated">첫 번째 인수를 제외한 모든 인수는 원자임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="a450b0f803f6ae1fce87a01c5eeb4990d00edaa1" translate="yes" xml:space="preserve">
          <source>All available modes are discussed below.</source>
          <target state="translated">사용 가능한 모든 모드는 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a205f1c716c887255b02393e7cb3d73d2a1cc6f" translate="yes" xml:space="preserve">
          <source>All bitwise functions can be used in guards:</source>
          <target state="translated">모든 비트 함수는 가드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c9708ca0238b22e7c13c00b06e3da882c3696d" translate="yes" xml:space="preserve">
          <source>All bitwise functions work only on integers; otherwise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">모든 비트 함수는 정수에서만 작동합니다. 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0506e345cce0be172d12fdeec69c477b8538823" translate="yes" xml:space="preserve">
          <source>All bitwise macros can be used in guards:</source>
          <target state="translated">모든 비트 단위 매크로는 가드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b23070b414d2fa6a5985bf7370f737d23a7cab53" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래의 모든 구성은 구성 파일 (예 : &lt;code&gt;config/config.exs&lt;/code&gt; )을 통해 설정할 수 있지만 런타임 중에 &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; 을&lt;/a&gt; 통해 동적으로 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f24df6aca6fef7279aa46c984d854c8399f1b8a" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;logger#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래의 모든 구성은 구성 파일 (예 : &lt;code&gt;config/config.exs&lt;/code&gt; )을 통해 설정할 수 있지만 런타임 중에 &lt;a href=&quot;logger#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; 을&lt;/a&gt; 통해 동적으로 변경 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f86cb886460af2d7afbabd4518c2a4ae8d572dd7" translate="yes" xml:space="preserve">
          <source>All configuration for Xref should be placed under the key &lt;code&gt;:xref&lt;/code&gt;.</source>
          <target state="translated">외부 참조에 대한 모든 구성은 키 &lt;code&gt;:xref&lt;/code&gt; 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="71cd59b6f93fc3e7ecfe59f630540043ab20c0b6" translate="yes" xml:space="preserve">
          <source>All dependencies are automatically recompiled after update.</source>
          <target state="translated">모든 종속성은 업데이트 후 자동으로 다시 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0d2ee2fbfbf3acfd326c27d7a8c9cdf22d871f" translate="yes" xml:space="preserve">
          <source>All duplicated keys are removed. See &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; for removing only the first entry.</source>
          <target state="translated">모든 중복 키가 제거됩니다. 첫 번째 항목 만 제거하려면 &lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="962493e8f49621899a7a8fb10598ca516db9a007" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 모든 요소 는 이진으로 변환 가능 해야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62d126d7fed26d3474d703ba63d0072a8589e3cc" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a string, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 모든 요소 는 문자열로 변환 할 수 있어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75780da216d4a9fe9a0de4cd507f0ecf910086a9" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 를 호출하여 반환 된 모든 요소 는 이진으로 변환 가능해야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0e64b00e325d388a4149fd69452dd2198b576ec" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a string, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 호출에서 반환 된 모든 요소 는 문자열로 변환 할 수 있어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a81afb8178e29a9385a90fd94857e3690f36f499" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">모든 표현식은 템플릿 출력 무언가가 있다고 &lt;strong&gt;한다&lt;/strong&gt; 등호 기호 (사용 &lt;code&gt;=&lt;/code&gt; 을 ). Elixir의 모든 것은 표현이므로이 규칙에 대한 예외는 없습니다. 예를 들어 일부 템플릿 언어는 특수한 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 절이지만 EEx에서는 동일하게 취급되며 결과를 인쇄 하려면 &lt;code&gt;=&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e209a7fdf9ec613b8d4f8cfecf15e0dabebad2c5" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;code&gt;if&lt;/code&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">모든 표현식은 템플릿 출력 무언가가 있다고 &lt;strong&gt;한다&lt;/strong&gt; 등호 기호 (사용 &lt;code&gt;=&lt;/code&gt; 을 ). Elixir의 모든 것은 표현식이므로이 규칙에 대한 예외는 없습니다. 예를 들어, 일부 템플릿 언어는 &lt;code&gt;if&lt;/code&gt; 절이 특수한 경우 이지만 EEx에서 동일하게 처리되며 결과를 인쇄 하려면 &lt;code&gt;=&lt;/code&gt; 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="64dc310c834981873443bb0c895820130d8003ed" translate="yes" xml:space="preserve">
          <source>All functions in this module accept EEx-related options. They are:</source>
          <target state="translated">이 모듈의 모든 기능은 EEx 관련 옵션을 허용합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="b894afac8aa8f48058b57f650cf4e765dcf379d8" translate="yes" xml:space="preserve">
          <source>All functions in this module are inlined by the compiler.</source>
          <target state="translated">이 모듈의 모든 함수는 컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="1f14031fee2bc02634aba88d8e6180547c70d0ae" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;, overriding any existing one (i.e., the keys in &lt;code&gt;map2&lt;/code&gt; &quot;have precedence&quot; over the ones in &lt;code&gt;map1&lt;/code&gt;).</source>
          <target state="translated">모든 키 &lt;code&gt;map2&lt;/code&gt; 추가됩니다 &lt;code&gt;map1&lt;/code&gt; 기존 하나를 (즉,의 키 무시, &lt;code&gt;map2&lt;/code&gt; 있는 사람을 통해 &quot;우선 순위가&quot; &lt;code&gt;map1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c4382006c46118de92713063dd12ca0d2391ea22" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;. The given function will be invoked when there are duplicate keys; its arguments are &lt;code&gt;key&lt;/code&gt; (the duplicate key), &lt;code&gt;value1&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map1&lt;/code&gt;), and &lt;code&gt;value2&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map2&lt;/code&gt;). The value returned by &lt;code&gt;fun&lt;/code&gt; is used as the value under &lt;code&gt;key&lt;/code&gt; in the resulting map.</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 의 모든 키 가 &lt;code&gt;map1&lt;/code&gt; 에 추가됩니다 . 주어진 기능은 중복 키가있을 때 호출됩니다. 인수는 &lt;code&gt;key&lt;/code&gt; (중복 키), &lt;code&gt;value1&lt;/code&gt; (값 &lt;code&gt;key&lt;/code&gt; 에서 &lt;code&gt;map1&lt;/code&gt; )과 &lt;code&gt;value2&lt;/code&gt; (값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;map2&lt;/code&gt; ). &lt;code&gt;fun&lt;/code&gt; 에 의해 리턴 된 값 은 결과 맵 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="81067fca2a4826fa2b861dc9ccff01a040457240" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;, overriding any existing one.</source>
          <target state="translated">주어진 중복 키를 포함한 모든 키, &lt;code&gt;keywords2&lt;/code&gt; 이 추가됩니다 &lt;code&gt;keywords1&lt;/code&gt; 기존 하나를 오버라이드 (override).</target>
        </trans-unit>
        <trans-unit id="e2c2426bd83d495cefd1511dd9e29d2650392f21" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;. The given function will be invoked to solve conflicts.</source>
          <target state="translated">주어진 중복 키를 포함한 모든 키, &lt;code&gt;keywords2&lt;/code&gt; 이 추가됩니다 &lt;code&gt;keywords1&lt;/code&gt; . 주어진 함수는 충돌을 해결하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5fd7c77cbce8d2bd6aeafdabf4cfeac9e29a80" translate="yes" xml:space="preserve">
          <source>All modifiers listed above can be combined; repeated modifiers in &lt;code&gt;modifiers&lt;/code&gt; will be ignored.</source>
          <target state="translated">위에 나열된 모든 수정자를 결합 할 수 있습니다. 반복 된 수정 &lt;code&gt;modifiers&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e93bb97d241121b4f4dee22d57fba8b3e522ddbd" translate="yes" xml:space="preserve">
          <source>All of the configuration defined in &lt;code&gt;config/config.exs&lt;/code&gt; will be included as part of the escript. &lt;code&gt;config/runtime.exs&lt;/code&gt;is also included for Elixir escripts. Once the configuration is loaded, this task starts the current application. If this is not desired, set the &lt;code&gt;:app&lt;/code&gt; configuration to nil.</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; 에 정의 된 모든 구성 은 escript의 일부로 포함됩니다. &lt;code&gt;config/runtime.exs&lt;/code&gt; 도 Elixir escript에 포함되어 있습니다. 구성이로드되면이 작업은 현재 응용 프로그램을 시작합니다. 원하지 않는 경우 &lt;code&gt;:app&lt;/code&gt; 구성을 nil로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9db69ff5fd80f1c32d968ebb750da1bd96e5703" translate="yes" xml:space="preserve">
          <source>All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that &quot;desugar&quot; to one of the constructs explored above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence.</source>
          <target state="translated">위의 모든 구문은 Elixir 구문의 일부이며 Elixir AST의 일부로 자체 표현이 있습니다. 이 섹션에서는 위에서 살펴본 구성 중 하나에 &quot;탈당&quot;하는 나머지 구성에 대해 설명합니다. 다시 말해, 아래의 구성은 엘릭서 코드에서 하나 이상의 방식으로 표현되고 AST 동등성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efecbd33be6692e33153d5c191da2fd42dffe301" translate="yes" xml:space="preserve">
          <source>All operators in Elixir are also valid atoms. Valid examples are &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:FOO&lt;/code&gt;, &lt;code&gt;:foo_42&lt;/code&gt;, &lt;code&gt;:foo@bar&lt;/code&gt;, and &lt;code&gt;:++&lt;/code&gt;. Invalid examples are &lt;code&gt;:@foo&lt;/code&gt; (&lt;code&gt;@&lt;/code&gt; is not allowed at start), &lt;code&gt;:123&lt;/code&gt; (numbers are not allowed at start), and &lt;code&gt;:(*)&lt;/code&gt; (not a valid operator).</source>
          <target state="translated">Elixir의 모든 연산자는 유효한 원자입니다. 유효한 예는 &lt;code&gt;:foo&lt;/code&gt; , &lt;code&gt;:FOO&lt;/code&gt; , &lt;code&gt;:foo_42&lt;/code&gt; , &lt;code&gt;:foo@bar&lt;/code&gt; 및 &lt;code&gt;:++&lt;/code&gt; 입니다. 유효 하지 않은 예는 &lt;code&gt;:@foo&lt;/code&gt; ( &lt;code&gt;@&lt;/code&gt; 는 시작시 허용되지 않음), &lt;code&gt;:123&lt;/code&gt; (시작시 숫자 허용되지 않음) 및 &lt;code&gt;:(*)&lt;/code&gt; (유효한 연산자가 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="a68a6061ed529e7321fbab2a1e1466c173d56718" translate="yes" xml:space="preserve">
          <source>All terms in Elixir can be compared with each other.</source>
          <target state="translated">Elixir의 모든 용어는 서로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8a32aefda3f349478b8a4289ce78ffc774e378" translate="yes" xml:space="preserve">
          <source>All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests:</source>
          <target state="translated">모든 테스트는 컨텍스트를 인수로받습니다. 컨텍스트는 콜백과 테스트간에 정보를 공유 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="46f1e0081d7ff3ef1598ee1f4611d0858df9a878" translate="yes" xml:space="preserve">
          <source>All tests start with a state of &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">모든 테스트는 &lt;code&gt;nil&lt;/code&gt; 상태로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="471fbe4680a438c1f34492b7155396825fbf6e7e" translate="yes" xml:space="preserve">
          <source>All the functions in the &lt;code&gt;Enum&lt;/code&gt; module are eager. Many functions expect an enumerable and return a list back:</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 모듈 의 모든 기능 이 간절합니다. 많은 함수가 열거 가능할 것으로 예상하고 목록을 다시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad97f344ca26467cc845b62f0e8a053c5eb38fe0" translate="yes" xml:space="preserve">
          <source>All the values of caller functions describe the marked function. For example, the first row means that &lt;code&gt;Mod.caller1/0&lt;/code&gt; invoked &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3 times. 200ms of the total time spent in &lt;code&gt;Mod.some_function/0&lt;/code&gt; was spent processing calls from this particular caller.</source>
          <target state="translated">호출자 함수의 모든 값은 표시된 함수를 설명합니다. 예를 들어 첫 번째 행은 &lt;code&gt;Mod.caller1/0&lt;/code&gt; 이 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 을 3 번 호출 했음을 의미합니다 . &lt;code&gt;Mod.some_function/0&lt;/code&gt; 에 소비 된 총 시간의 200ms는 이 특정 발신자의 통화 처리에 소비되었습니다.</target>
        </trans-unit>
        <trans-unit id="ab62fee1181d53e168d5ddca4b76c2a3f0f14d49" translate="yes" xml:space="preserve">
          <source>All these macros are public macros (as defined by &lt;code&gt;defmacro&lt;/code&gt;).</source>
          <target state="translated">이 매크로는 모두 공개 매크로입니다 ( &lt;code&gt;defmacro&lt;/code&gt; 에 의해 정의 됨 ).</target>
        </trans-unit>
        <trans-unit id="34f3030dbffbd799437c8acd75092b93db7172e2" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses.</source>
          <target state="translated">가드 조항에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="16b8d71f3125091140d0f8672105255771ac2803" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses. Inlined by the compiler.</source>
          <target state="translated">가드 조항에서 허용됩니다. 컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="translated">가드 테스트에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="af6c8de133dbdc2f69863328f74fb83aacfb7360" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests. Inlined by the compiler.</source>
          <target state="translated">가드 테스트에서 허용됩니다. 컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="2b173cc6a1f043289cd7c3164ac03625499e4950" translate="yes" xml:space="preserve">
          <source>Allows a developer to customize the using block when the case template is used.</source>
          <target state="translated">사례 템플릿을 사용할 때 개발자가 사용 블록을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce229aa087121abe44456ef91f4d85fd2c83436e" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;cprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;cprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e890e59c1727dd986c090acbf3706458233a86" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;eprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;eprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec7e6385a65f90ce774de5cfa85e6c67d629db7" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;fprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;fprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fb76106047518ce4fb611a343f5cfc33db811df" translate="yes" xml:space="preserve">
          <source>Alongside the observer application, Erlang also includes a &lt;code&gt;:crashdump_viewer&lt;/code&gt; to view crash dumps</source>
          <target state="translated">Erlang은 옵저버 애플리케이션과 함께 &lt;code&gt;:crashdump_viewer&lt;/code&gt; 를 볼 수 있는 : crashdump_viewer 도 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="7b9345037b9e6e5f6f050e0e1c3ba89d21df3bda" translate="yes" xml:space="preserve">
          <source>Alphanumeric characters: &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;</source>
          <target state="translated">영숫자 : &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc66c0fdb05c288a2d0be6731b80e56ea10955b8" translate="yes" xml:space="preserve">
          <source>Also note that Erlang&amp;rsquo;s formatting functions require special attention to Unicode handling.</source>
          <target state="translated">또한 Erlang의 서식 기능에는 유니 코드 처리에 특별한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="25e5fdf8b80ad209b572bf379ee2d97f709f491c" translate="yes" xml:space="preserve">
          <source>Also note the &lt;code&gt;async: true&lt;/code&gt; option passed to &lt;code&gt;ExUnit.Case&lt;/code&gt;. This option makes the test case run in parallel with other &lt;code&gt;:async&lt;/code&gt; test cases by using multiple cores in our machine. This is extremely useful to speed up our test suite. However, &lt;code&gt;:async&lt;/code&gt; must &lt;em&gt;only&lt;/em&gt; be set if the test case does not rely on or change any global values. For example, if the test requires writing to the filesystem or access a database, keep it synchronous (omit the &lt;code&gt;:async&lt;/code&gt; option) to avoid race conditions between tests.</source>
          <target state="translated">또한 &lt;code&gt;async: true&lt;/code&gt; 옵션이 &lt;code&gt;ExUnit.Case&lt;/code&gt; 로 전달되었습니다 . 이 옵션은 머신에서 여러 코어를 사용하여 테스트 케이스 를 다른 &lt;code&gt;:async&lt;/code&gt; 테스트 케이스 와 병렬로 실행 합니다. 테스트 스위트 속도를 높이는 데 매우 유용합니다. 그러나 테스트 케이스가 전역 값에 의존하지 않거나 전역 값을 변경하지 않는 경우 &lt;em&gt;에만 &lt;/em&gt; &lt;code&gt;:async&lt;/code&gt; 를 설정 해야 합니다. 예를 들어, 테스트에서 파일 시스템에 쓰거나 데이터베이스에 액세스해야하는 경우 테스트 간에 경쟁 조건을 피하기 위해 동기식으로 유지하십시오 ( &lt;code&gt;:async&lt;/code&gt; 옵션 생략 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99f95b6ecaf40ea41137c6dd421e917e63ab648f" translate="yes" xml:space="preserve">
          <source>Also, keep in mind that profiling might significantly increase the running time of the profiled processes. This might skew your results if, for example, those processes perform some I/O operations, since running time of those operations will remain unchanged, while CPU bound operations of the profiled processes might take significantly longer. Thus, when profiling some intensive program, try to reduce such dependencies, or be aware of the resulting bias.</source>
          <target state="translated">또한 프로파일 링은 프로파일 링 된 프로세스의 실행 시간을 크게 증가시킬 수 있습니다. 예를 들어, 해당 프로세스의 실행 시간이 변경되지 않고 프로파일 된 프로세스의 CPU 바운드 조작이 상당히 오래 걸릴 수 있기 때문에 해당 프로세스가 일부 I / O 조작을 수행하는 경우 결과가 왜곡 될 수 있습니다. 따라서 일부 집중적 인 프로그램을 프로파일 링 할 때는 이러한 종속성을 줄이거 나 결과적인 편견을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="92516fadfd2f18efb90c2a6ec6fde01d43c3b8e5" translate="yes" xml:space="preserve">
          <source>Also, note that we started the documentation string using &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt;. The &lt;code&gt;~S&lt;/code&gt; prevents the &lt;code&gt;\r\n&lt;/code&gt; characters from being converted to a carriage return and line feed until they are evaluated in the test.</source>
          <target state="translated">또한 &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt; 사용하여 문서화 문자열을 시작했습니다 . &lt;code&gt;~S&lt;/code&gt; 는 &lt;code&gt;\r\n&lt;/code&gt; 문자가 테스트에서 평가 될 때까지 캐리지 리턴 및 줄 바꿈으로 변환되지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="48be7d4f57a1ff8c0c8de01d6b7c49d0f740172b" translate="yes" xml:space="preserve">
          <source>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</source>
          <target state="translated">동기화 모드와 비동기 모드 사이를 전환하여 필요할 때 성능을 유지하지만 스트레스를받을 때 배압을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="56a32fedc781d04589b1e27a4190731f2b801a94" translate="yes" xml:space="preserve">
          <source>Alternatively to pattern matching, filters can be used to select some particular elements. For example, we can select the multiples of 3 and discard all others:</source>
          <target state="translated">패턴 일치 대신 필터를 사용하여 일부 특정 요소를 선택할 수 있습니다. 예를 들어, 3의 배수를 선택하고 나머지는 모두 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738072000214e7dd8d85de9d3d93ddc937487ae4" translate="yes" xml:space="preserve">
          <source>Alternatively, Elixir allows a developer to pass pairs of name/arities to &lt;code&gt;:only&lt;/code&gt; or &lt;code&gt;:except&lt;/code&gt; as a fine grained control on what to import (or not):</source>
          <target state="translated">또는 Elixir를 사용하면 개발자 가 가져올 이름에 대한 세밀한 제어로 이름 / 군목 쌍을 &lt;code&gt;:only&lt;/code&gt; 또는 &lt;code&gt;:except&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36ad95769db69aaf7f63f387429da94f20ab6a71" translate="yes" xml:space="preserve">
          <source>Alternatively, since doctest results are actually evaluated, you can have the MapSet building expression as the doctest result:</source>
          <target state="translated">또는 doctest 결과가 실제로 평가되므로 MapSet 빌드 표현식을 doctest 결과로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520fd3033d5bc943230748094ad592f85a64e858" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;code&gt;stops&lt;/code&gt; 인수 를 전달하여 정류장 수를 늘릴 수 있습니다 . &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 숫자를 다시 0으로 재설정 할 수 있습니다. 모든 중단 점의 모든 중지가 소비 된 후에도 모듈은 &quot;계측&quot;된 상태로 유지됩니다. 다음을 호출하여 주어진 모듈에서 계측을 제거 할 수 있습니다.&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 모든 모듈.</target>
        </trans-unit>
        <trans-unit id="6f1d115c4cc71092e4215eb5349ece403f7a97dc" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;code&gt;stops&lt;/code&gt; 인수 를 전달하여 중지 수를 늘릴 수 있습니다 . &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt; 을 사용하여 숫자를 다시 0으로 재설정 할 수 있습니다. 모든 중단 점에서 모든 정지가 소비 된 후에도 모듈은 &quot;계측 된&quot;상태로 유지됩니다. &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 지정된 모듈 및 &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 모든 모듈 에서 계측을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cc0d6b358d92b06480447a0e7b647b01a1915a4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also bundle the compiled object files in the release, as long as they were compiled for the same target. If doing so, you need to update &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable with the paths containing the bundled objects on Unix-like systems or the &lt;code&gt;PATH&lt;/code&gt; environment variable on Windows systems.</source>
          <target state="translated">또는 동일한 대상에 대해 컴파일 된 경우 컴파일 된 개체 파일을 릴리스에 번들로 제공 할 수도 있습니다. 이 경우 업데이트해야합니다. &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; Unix 계열 시스템의 번들 개체가 포함 된 경로 또는 Windows 시스템 의 &lt;code&gt;PATH&lt;/code&gt; 환경 변수로 LD_LIBRARY_PATH 환경 변수 합니다.</target>
        </trans-unit>
        <trans-unit id="bd5ba0c8b5719d085aa77f348942d4ad38576999" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">또는 &lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 사용 하여 제어 할 수없는 지정된 모듈, 기능 및 arity에 중단 점을 설정할 수 있습니다. 동안&lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 더 유연, 그것은 소스 코드에서 수입 및 별칭에 대한 정보는 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f6b64d93c6e1bd876f47c2efd90152e6697540d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">또는 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 사용 하여 제어 할 수없는 특정 모듈, 기능 및 특성에 중단 점을 설정할 수 있습니다. &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 는 융통성이 있지만 소스 코드에서 가져 오기 및 별명에 대한 정보는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d79671dc1ec87eb565237239995efff47dca0e9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can view a string&amp;rsquo;s binary representation by using &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt;:</source>
          <target state="translated">또는 다음을 사용하여 문자열의 이진 표현을 볼 수 있습니다. &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt; IO.inspect / 2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="b0a8089f58c0c54576c2250b325fc6b97e8e0b35" translate="yes" xml:space="preserve">
          <source>Alters the current process metadata according the given keyword list.</source>
          <target state="translated">주어진 키워드 목록에 따라 현재 프로세스 메타 데이터를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6b160e130daad190a032bd2c82f16a239367a706" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">변경합니다 아래에 저장된 값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; ,하지만 진입하면 &lt;code&gt;key&lt;/code&gt; 이미 존재하는 &lt;code&gt;keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9aed7587419c22040987ccddf36342ed35dbbef" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">변경합니다 아래에 저장된 값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; ,하지만 진입하면 &lt;code&gt;key&lt;/code&gt; 이미 존재하는 &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="375d49ba0682b4200a357c23af57a8fe3e771407" translate="yes" xml:space="preserve">
          <source>Although Elixir includes specific functions such as &lt;code&gt;tuple_size&lt;/code&gt;, &lt;code&gt;binary_size&lt;/code&gt; and &lt;code&gt;map_size&lt;/code&gt;, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:</source>
          <target state="translated">Elixir에는 &lt;code&gt;tuple_size&lt;/code&gt; , &lt;code&gt;binary_size&lt;/code&gt; 및 &lt;code&gt;map_size&lt;/code&gt; 와 같은 특정 기능이 포함되어 있지만 유형에 관계없이 데이터 구조의 크기를 검색 할 수있는 경우가 있습니다. Elixir에서는 프로토콜을 사용하여 다형성 코드, 즉 다른 모양 / 유형으로 작동하는 코드를 작성할 수 있습니다. 크기 프로토콜은 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="868b9d8c908b99a2015b9ea01a789f020942a3d4" translate="yes" xml:space="preserve">
          <source>Although Elixir projects are not required to follow SemVer, they must follow the format outlined on &lt;a href=&quot;https://semver.org/&quot;&gt;SemVer 2.0 schema&lt;/a&gt;.</source>
          <target state="translated">Elixir 프로젝트는 SemVer를 따라야하는 것은 아니지만 &lt;a href=&quot;https://semver.org/&quot;&gt;SemVer 2.0 스키마&lt;/a&gt; 에 설명 된 형식을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="271db6153eba80f48b3cb5615c2c7cf2befa189f" translate="yes" xml:space="preserve">
          <source>Although Mix generates and maintains the &lt;code&gt;.app&lt;/code&gt; file for us, we can customize its contents by adding new entries to the &lt;code&gt;application/0&lt;/code&gt; function inside the &lt;code&gt;mix.exs&lt;/code&gt; project file. We are going to do our first customization soon.</source>
          <target state="translated">Mix는 &lt;code&gt;.app&lt;/code&gt; 파일을 생성하고 유지 관리하지만 &lt;code&gt;mix.exs&lt;/code&gt; 프로젝트 파일 의 &lt;code&gt;application/0&lt;/code&gt; 함수에 새 항목을 추가하여 내용을 사용자 정의 할 수 있습니다 . 우리는 곧 첫 번째 사용자 정의를 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e1f61fc70481b8e1a6521771f177855b8a68b86" translate="yes" xml:space="preserve">
          <source>Although code points are represented as integers, this module represents code points in their encoded format as strings. For example:</source>
          <target state="translated">코드 포인트는 정수로 표시되지만이 모듈은 인코딩 된 형식의 코드 포인트를 문자열로 표시합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b17471efb7e8b7966f0aa39356cf0b8489d5f43b" translate="yes" xml:space="preserve">
          <source>Although code points could be represented as integers, this module represents all code points as strings. For example:</source>
          <target state="translated">코드 포인트는 정수로 표현 될 수 있지만이 모듈은 모든 코드 포인트를 문자열로 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14fda69fb3ca698206ce8ef9fa7ae0f578b2ed83" translate="yes" xml:space="preserve">
          <source>Although doing so is not recommended as it may affect your test suite performance.</source>
          <target state="translated">테스트 스위트 성능에 영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1601918b924ec8be73d09596361453ea4e02508" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">부적절한 목록은 일반적으로 피하지만 iodata 및 chardata 엔터티와 같은 일부 특수 상황에서 사용됩니다 ( &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 참조 ).</target>
        </trans-unit>
        <trans-unit id="7089c4bbd915ddfe4f12d574def40357ae4ad792" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">부적절한 목록은 일반적으로 피하지만 iodata 및 chardata 엔티티와 같은 특수한 환경에서 사용됩니다 ( &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 참조 ).</target>
        </trans-unit>
        <trans-unit id="64c7cf26cc8984dd2eacea7d69ec4e1e732253fe" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">위의 예에서는 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt; 및 친구들을 사용하여 서버를 직접 시작하고 통신했지만 대부분의 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 함수를 직접 호출하지 않습니다 . 대신 서버의 공용 API를 나타내는 새 함수로 호출을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="1fac951d9acd827630fc984ba5e390c89493d219" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;genserver#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;genserver#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt; 및 friends를 사용하여 서버를 직접 시작하고 통신했지만 대부분 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 함수를 직접 호출하지는 않습니다 . 대신 서버의 공개 API를 나타내는 새로운 함수로 호출을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="05cad5e03ed101afeda99f24e9baf0f87a53f9f2" translate="yes" xml:space="preserve">
          <source>Although our tests pass, our testing structure is getting more complex. In particular, running tests with only &lt;code&gt;mix test&lt;/code&gt; causes failures in our suite, since our test requires a connection to another node.</source>
          <target state="translated">테스트는 통과했지만 테스트 구조는 점점 복잡해지고 있습니다. 특히 &lt;code&gt;mix test&lt;/code&gt; 만으로 테스트를 실행 하면 테스트에서 다른 노드에 연결해야하므로 스위트에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff729d77091a6064c1d998a90b46541e7d7f75c9" translate="yes" xml:space="preserve">
          <source>Although pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:</source>
          <target state="translated">패턴 매칭은 강력한 구조를 만들 수 있지만 사용법은 제한적입니다. 예를 들어, 일치하는 왼쪽에서 함수 호출을 수행 할 수 없습니다. 다음 예는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7b600d39b3f1acbfb8a882dbb3ff05d15ab87d6" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">구조체는 맵이지만 기본적으로 구조체는 맵에 대해 구현 된 프로토콜을 구현하지 않습니다. 다형성 디스패치를위한 프로토콜과 함께 구조체를 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 . 또한 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt;구조체를 동적으로 만들고 업데이트하는 방법에 대한 예제는 Kernel.struct! / 2 를.</target>
        </trans-unit>
        <trans-unit id="e1d430d2d6fb0548beb47e18ecfea58c354f9cde" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">구조체는 맵이지만 기본적으로 구조체는 맵에 구현 된 프로토콜을 구현하지 않습니다. 구조체를 다형성 디스패치 프로토콜과 함께 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 . 구조체를 동적으로 만들고 업데이트하는 방법에 대한 예제는 &lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="870fe0c59e3d007685ea9833cb1390f52f0e514b" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the &lt;code&gt;User&lt;/code&gt; struct leads to an error:</source>
          <target state="translated">구조체는 맵이지만 기본적으로 구조체는 맵에 구현 된 프로토콜을 구현하지 않습니다. 예를 들어, &lt;code&gt;User&lt;/code&gt; 구조체 와 함께 프로토콜을 사용하려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="431f21d40dbb5403d9bd326700ba842d9364814b" translate="yes" xml:space="preserve">
          <source>Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute &lt;code&gt;:spawn_executable&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 편리하지만 이름이나 인수에 공백이있는 실행 파일을 호출 할 수 없다는 것을 의미합니다. 이러한 이유로 대부분의 경우 &lt;code&gt;:spawn_executable&lt;/code&gt; 을 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5fb3fdd978f27b5125e369d37a21e919df537b80" translate="yes" xml:space="preserve">
          <source>Although the directory can be accessed as &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">디렉토리는 &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt; 로 액세스 할 수 있지만 이 매크로는 편리한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="08556dd674acbaa5235d5a6dd7ba968777f84148" translate="yes" xml:space="preserve">
          <source>Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!</source>
          <target state="translated">최종 결과는 동일하지만 요소 인쇄 순서가 변경되었습니다! 스트림을 사용하여 첫 번째 요소를 인쇄 한 다음 이중 요소를 인쇄합니다. 이 예에서는 목록이 한 번만 열거되었습니다!</target>
        </trans-unit>
        <trans-unit id="34317ca951c3b1fca45985dcc2015a9c9f8ee491" translate="yes" xml:space="preserve">
          <source>Although the example above is made of two characters, it is perceived by users as one.</source>
          <target state="translated">위의 예는 두 문자로 구성되어 있지만 사용자가 하나의 문자로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a4ac7eba93e375ca0b8410e005578a589bad8a11" translate="yes" xml:space="preserve">
          <source>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;full&lt;/code&gt; strings, then slice the &lt;code&gt;full&lt;/code&gt; one, traversing it again.</source>
          <target state="translated">위의 기능은 작동하지만 성능이 저하됩니다. 문자열의 길이를 계산하기 위해, 우리는 우리가 모두 통과, 그래서 그것을 완전히 통과 할 필요는 &lt;code&gt;prefix&lt;/code&gt; 와 &lt;code&gt;full&lt;/code&gt; 문자열, 다음 슬라이스 &lt;code&gt;full&lt;/code&gt; 를 다시 통과.</target>
        </trans-unit>
        <trans-unit id="2ad64b2ae9d7779aeafe9f53ba81c4ac6a8c3bcb" translate="yes" xml:space="preserve">
          <source>Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of &lt;code&gt;0&lt;/code&gt;. That's one of the reasons why &lt;code&gt;@fallback_to_any&lt;/code&gt; is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour.</source>
          <target state="translated">위의 구현은 아마도 합리적인 것이 아닙니다. 예를 들어 PID 또는 정수의 크기가 &lt;code&gt;0&lt;/code&gt; 이라고 말하는 것은 의미가 없습니다 . 이것이 &lt;code&gt;@fallback_to_any&lt;/code&gt; 가 옵트 인 동작 인 이유 중 하나입니다 . 대부분의 프로토콜에서 프로토콜이 구현되지 않은 경우 오류를 발생시키는 것이 올바른 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2d80e43bdc8417d6590a2fd8779a42e453b4510f" translate="yes" xml:space="preserve">
          <source>Although the module can be accessed in the &lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 에서 모듈에 액세스 할 수 있지만 이 매크로는 편리한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="523bba024fe01ece815e7c56ce1e3c3d7d5ff12a" translate="yes" xml:space="preserve">
          <source>Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections.</source>
          <target state="translated">이전 섹션을 &quot;매크로 방지&quot;로 요약 할 수 있지만 두 항목 모두 자체 섹션을 사용할 수있을만큼 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8a45380bdb24cc0394ac693565319d64e7fe3702" translate="yes" xml:space="preserve">
          <source>Although this chapter was the first time we implemented a supervisor, it was not the first time we used one! In the previous chapter, when we used &lt;code&gt;start_supervised!&lt;/code&gt; to start the registry during our tests, &lt;code&gt;ExUnit&lt;/code&gt; started the registry under a supervisor managed by the ExUnit framework itself. By defining our own supervisor, we provide more structure on how we initialize, shutdown and supervise processes in our applications, aligning our production code and tests with best practices.</source>
          <target state="translated">이 장은 처음으로 관리자를 구현했지만 처음 사용한 것은 아닙니다! 이전 장에서 &lt;code&gt;start_supervised!&lt;/code&gt; 우리의 테스트 기간 동안 레지스트리를 시작, &lt;code&gt;ExUnit&lt;/code&gt; 는 ExUnit 프레임 워크 자체에 의해 관리 감독자 아래 레지스트리를 시작했다. 자체 감독자를 정의함으로써 애플리케이션에서 프로세스를 초기화, 종료 및 감독하는 방법에 대한 더 많은 구조를 제공하여 프로덕션 코드와 테스트를 모범 사례에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="3c9f4ae19a7eeeab2983d7dec1f1792d10b1c1ba" translate="yes" xml:space="preserve">
          <source>Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions. Binaries are already represented by the underlying bytes and as such their representation is always &amp;ldquo;raw&amp;rdquo;.</source>
          <target state="translated">이것은 미묘한 차이이지만 목록을 해당 함수에 전달하려는 경우 이러한 세부 정보 만 걱정하면됩니다. 바이너리는 이미 기본 바이트로 표시되므로 항상 &quot;raw&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a39c028c0e69f90f27ee19565121bb2984ad9e8e" translate="yes" xml:space="preserve">
          <source>Although this task does not show up in &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;, it is part of Mix public API and can be depended on.</source>
          <target state="translated">이 작업은 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Help.html&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 표시되지 않지만 Mix 공용 API의 일부이며 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c3d8b250459ad3c47db87432253967c9d495f1" translate="yes" xml:space="preserve">
          <source>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</source>
          <target state="translated">키워드 목록에서 패턴 일치를 할 수는 있지만, 목록에서 패턴 일치는 항목 수와 순서가 일치해야하기 때문에 실제로는 거의 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1624e83a6f323b5d4e4763fd7f94a95a8d4f3768" translate="yes" xml:space="preserve">
          <source>Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:</source>
          <target state="translated">우리는 대부분의 프로그램이 시간이 지남에 따라 호환성을 유지하기를 기대하지만 향후 변경으로 인해 프로그램이 중단되지는 않을 것입니다. 가능성이 거의없는 상황에서 기존 코드를 손상시키는 변경 사항이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1172d58adce51402da1aca26a42f17b4f8158b48" translate="yes" xml:space="preserve">
          <source>Although we have covered code points and UTF-8 encoding, we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the &lt;strong&gt;bitstring&lt;/strong&gt;. A bitstring is a fundamental data type in Elixir, denoted with the &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; syntax. &lt;strong&gt;A bitstring is a contiguous sequence of bits in memory.&lt;/strong&gt;</source>
          <target state="translated">코드 포인트와 UTF-8 인코딩을 다루었지만 인코딩 된 바이트를 정확히 저장하는 방법에 대해 좀 더 자세히 살펴 봐야합니다 . 여기에서 &lt;strong&gt;bitstring&lt;/strong&gt; 을 소개합니다 . 비트 문자열은 Elixir의 기본 데이터 유형이며 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 구문으로 표시됩니다 .&lt;strong&gt;비트 문자열은 메모리에서 연속적인 비트 시퀀스입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b17a13f88c530e5861a53d56146266cecae866f" translate="yes" xml:space="preserve">
          <source>Although we have overlooked some details, this is the main idea behind creating domain-specific modules in Elixir. Macros enable us to return quoted expressions that are executed in the caller, which we can then use to transform code and store relevant information in the target module via module attributes. Finally, callbacks such as &lt;code&gt;@before_compile&lt;/code&gt; allow us to inject code into the module when its definition is complete.</source>
          <target state="translated">우리는 몇 가지 세부 사항을 간과했지만 이것이 Elixir에서 도메인 별 모듈을 생성하는 주요 아이디어입니다. 매크로를 사용하면 호출자에서 실행되는 따옴표로 묶인 표현식을 반환 할 수 있습니다. 그러면 코드를 변환하고 모듈 속성을 통해 대상 모듈에 관련 정보를 저장할 수 있습니다. 마지막으로 &lt;code&gt;@before_compile&lt;/code&gt; 과 같은 콜백을 통해 정의가 완료되면 모듈에 코드를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3359c56da801ba4eef5b9504bfbf16ddf4e8ca4b" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;:ok&lt;/code&gt; and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; to read more about the &quot;owner&quot;.</source>
          <target state="translated">항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하고 현재 프로세스와 연관된 키가 더 이상 없으면 현재 프로세스를 소유자와 자동으로 연결 해제합니다. &quot;소유자&quot;에 대한 자세한 내용은 &lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c0244fa532d1e23d46ac34ccb91bfb72ffc273" translate="yes" xml:space="preserve">
          <source>Ambiguous function/macro names</source>
          <target state="translated">모호한 함수 / 매크로 이름</target>
        </trans-unit>
        <trans-unit id="a049ff1aa2d29c7c72357b2f704f3d8dea2f8d78" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use Agent&lt;/code&gt;, it automatically defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 가장 일반적으로 감독의 나무 아래에서 시작됩니다. &lt;code&gt;use Agent&lt;/code&gt; 를 호출 하면 수퍼바이저에서 에이전트를 직접 시작할 수 있는 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 함수가 자동으로 정의됩니다 . 초기 카운터가 0 인 수퍼바이저에서 에이전트를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0cd52ac6bbd448008fc9991be40af1235993cec9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 패딩이 잘못 또는 비 알파벳 문자가 문자열에있는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7daf3eed2b4a99b57bedfcc7b4244779d37a819" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 패딩이 잘못 또는 비 알파벳 문자가 문자열에있는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b9f67eed7d2f0b73dd7c830850ce2ec24e88aa7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://hexdocs.pm/elixir/IO.Stream.html&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/IO.Stream.html&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; 의&lt;/a&gt; 구현 모두 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 와 &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 가 읽기 및 쓰기 모두에 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="e7f62694e798684b6b70596713962c709a802b67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">&lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; 은&lt;/a&gt; 모두 구현 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 와 &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 가 읽기 및 쓰기 모두에 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="ce760285f3ceb17ed57c0e119cfae44c3f14604f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;--app&lt;/code&gt; option can be given in order to name the OTP application for the project.</source>
          <target state="translated">- &lt;code&gt;--app&lt;/code&gt; 옵션은 프로젝트의 OTP 응용 프로그램의 이름을하기 위해 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ac0d09a1976576207aae2b02067561f24502c7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;--umbrella&lt;/code&gt; option can be given to generate an umbrella project.</source>
          <target state="translated">- &lt;code&gt;--umbrella&lt;/code&gt; 옵션은 우산 프로젝트를 생성하기 위해 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64cd9fe6934e48aac677a5c7974fdad201f15ae" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;.app&lt;/code&gt; file is a file containing Erlang terms that defines your application. Mix automatically generates this file based on your &lt;code&gt;mix.exs&lt;/code&gt; configuration.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일은 응용 프로그램을 정의 얼랑 용어를 포함하는 파일입니다. Mix는 &lt;code&gt;mix.exs&lt;/code&gt; 구성 에 따라이 파일을 자동으로 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="afe086c320e6384512964bd01dec4f5547e66922" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;after&lt;/code&gt; clause allows you to define cleanup logic that will be invoked both when the block of code passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the &lt;code&gt;after&lt;/code&gt; clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절은 코드의 블록에 전달하면 모두 호출됩니다 정리 논리를 정의 할 수 있습니다 &lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 오류가 발생할 때 또한 성공하고있다. 종료 신호를 수신하면 프로세스가 갑자기 종료되어 프로세스 가 정상적으로 종료되므로 &lt;code&gt;after&lt;/code&gt; 절이 실행되지는 않습니다. 다행히 Elixir의 대부분의 리소스 (예 : 열린 파일, ETS 테이블, 포트, 소켓 등)는 소유 프로세스에 연결되거나 모니터링되며 프로세스가 종료되면 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="d9b71baa3ec4aca419614eb83a6884fce9738af0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to modify what is being returned from &lt;code&gt;with&lt;/code&gt; in the case of a failed match:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 옵션에서 반환되는 내용 수정 주어질 수 &lt;code&gt;with&lt;/code&gt; 실패한 경기의 경우 :</target>
        </trans-unit>
        <trans-unit id="ff7e359bf597a6fd9ce8084d91ed80c5b7ad85f6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to specify the opposite:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 옵션은 반대를 지정 주어질 수있다 :</target>
        </trans-unit>
        <trans-unit id="e95cabc5495eb242ab85459b1aeff5cf96a48942" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">이 호출에서 반환 된 &lt;code&gt;io_device&lt;/code&gt; 는 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 함수 의 인수로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f97b9473a3f0b32057fd9dcd3bc6ae93dc6f50c3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;edit script&lt;/em&gt; is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring &lt;code&gt;list1&lt;/code&gt; closer to being equal to &lt;code&gt;list2&lt;/code&gt;; a key can be &lt;code&gt;:eq&lt;/code&gt;, &lt;code&gt;:ins&lt;/code&gt;, or &lt;code&gt;:del&lt;/code&gt;. Each value is a sublist of either &lt;code&gt;list1&lt;/code&gt; or &lt;code&gt;list2&lt;/code&gt; that should be inserted (if the corresponding key &lt;code&gt;:ins&lt;/code&gt;), deleted (if the corresponding key is &lt;code&gt;:del&lt;/code&gt;), or left alone (if the corresponding key is &lt;code&gt;:eq&lt;/code&gt;) in &lt;code&gt;list1&lt;/code&gt; in order to be closer to &lt;code&gt;list2&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;편집 스크립트는&lt;/em&gt; 키워드 목록입니다. 각 키는 &lt;code&gt;list1&lt;/code&gt; 을 &lt;code&gt;list2&lt;/code&gt; 와 더 가깝게 하기 위해 수행 할 &quot;편집 작업&quot;을 설명합니다 . 키는 &lt;code&gt;:eq&lt;/code&gt; , &lt;code&gt;:ins&lt;/code&gt; 또는 &lt;code&gt;:del&lt;/code&gt; 일 수 있습니다. 각 값은 하나의 서브리스트 인 &lt;code&gt;list1&lt;/code&gt; 또는 &lt;code&gt;list2&lt;/code&gt; (해당 키 경우 삽입한다 &lt;code&gt;:ins&lt;/code&gt; (해당 키 인 경우, 삭제) &lt;code&gt;:del&lt;/code&gt; ) 또는 (대응하는 키인지 방치 &lt;code&gt;:eq&lt;/code&gt; )의 &lt;code&gt;list1&lt;/code&gt; 순서대로 &lt;code&gt;list2&lt;/code&gt; 에 더 가깝습니다 .</target>
        </trans-unit>
        <trans-unit id="b968d4ec51b4353a379f80bf32b0dc9347be2642" translate="yes" xml:space="preserve">
          <source>An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:</source>
          <target state="translated">IO 장치는 원자 또는 PID 일 수 있습니다. 원자 인 경우 원자는 등록 된 프로세스의 이름이어야합니다. 또한 Elixir는 두 가지 단축키를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d60cf8ae86edc9af73dfcd3cc01f5bc137486aa4" translate="yes" xml:space="preserve">
          <source>An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named &lt;code&gt;:sample&lt;/code&gt; and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction:</source>
          <target state="translated">에이전트는 단순히 모듈, 함수 및 인수 튜플을 업데이트 명령에 전달하여 코드를 핫스왑 할 수 있습니다. 예를 들어, 이름이 &lt;code&gt;:sample&lt;/code&gt; 인 에이전트가 있고 내부 상태를 키워드 목록에서 맵으로 변환하려고한다고 가정하십시오. 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b354895b4d9f46ba32dcc5d6d21ad6dbac64a90c" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">에이전트는 GenServer와 동일한 이름 등록 규칙에 바인딩됩니다. 이에 대한 자세한 내용은 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c1a72284f98b833f1b474c204b90da86458f9ff" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">에이전트는 GenServer와 동일한 이름 등록 규칙에 바인딩됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서 에서 자세한 내용을 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="2d060fe1a8daedc42f287a49cf8e64646cafb9fe" translate="yes" xml:space="preserve">
          <source>An alias in Elixir is a capitalized identifier (like &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Keyword&lt;/code&gt;, etc) which is converted to an atom during compilation. For instance, the &lt;code&gt;String&lt;/code&gt; alias translates by default to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;:</source>
          <target state="translated">Elixir의 별칭은 컴파일하는 동안 원자로 변환 되는 대문자 식별자 (예 : &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Keyword&lt;/code&gt; 등)입니다. 예를 들어, &lt;code&gt;String&lt;/code&gt; 별명은 기본적으로 atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2eed296e4d116b1286a08b5abb835c217ff22cd0" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and life cycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;. Each application also has its own environment, which provides a unified API for configuring each application.</source>
          <target state="translated">응용 프로그램은 표준화 된 디렉터리 구조, 구성 및 수명주기를 사용하여 특정 기능을 구현하는 구성 요소입니다. 응용 프로그램이 &lt;em&gt;로드&lt;/em&gt; , &lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;중지됩니다.&lt;/em&gt; 됩니다. 각 애플리케이션에는 각 애플리케이션을 구성하기위한 통합 API를 제공하는 자체 환경도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1c5142518fdf011cadf3f17245bcd8f2a562ce8" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and lifecycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;.</source>
          <target state="translated">응용 프로그램은 표준화 된 디렉토리 구조, 구성 및 수명주기와 함께 특정 기능을 구현하는 구성 요소입니다. 응용 프로그램이 &lt;em&gt;로드&lt;/em&gt; , &lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;중지되었습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3fcb6166c3639e8ba7a2f7130be093979e1d4e4" translate="yes" xml:space="preserve">
          <source>An atom is a constant whose value is its own name. Some other languages call these symbols. They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">원자는 값이 자신의 이름 인 상수입니다. 다른 언어는 이러한 기호를 호출합니다. 다음과 같은 고유 한 값을 열거하는 데 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="86fb449cced27f4191bdd440f9d6ef1683f1583a" translate="yes" xml:space="preserve">
          <source>An attempt to call a macro that was not loaded will raise an error.</source>
          <target state="translated">로드되지 않은 매크로를 호출하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0f945f62fb0dc4d4db64326ebccd5ac85f209b4e" translate="yes" xml:space="preserve">
          <source>An attribute is defined if it has been registered with &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt; or assigned a value. If an attribute has been deleted with &lt;a href=&quot;#delete_attribute/2&quot;&gt;&lt;code&gt;delete_attribute/2&lt;/code&gt;&lt;/a&gt; it is no longer considered defined.</source>
          <target state="translated">&lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;register_attribute/3&lt;/code&gt; 에 등록&lt;/a&gt; 되었거나 값 이 지정된 경우 속성이 정의됩니다 . &lt;a href=&quot;#delete_attribute/2&quot;&gt; &lt;code&gt;delete_attribute/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 속성이 삭제 된 경우 더 이상 정의 된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be3bd9f0eca00ecaf433384dd9dcab4453a5b9a4" translate="yes" xml:space="preserve">
          <source>An easy way to do so is by sending a synchronous request to the registry before we do the bucket lookup. The &lt;code&gt;Agent.stop/2&lt;/code&gt; operation is synchronous and only returns after the bucket process terminates and all &lt;code&gt;:DOWN&lt;/code&gt; messages are delivered. Therefore, once &lt;code&gt;Agent.stop/2&lt;/code&gt; returns, the registry has already received the &lt;code&gt;:DOWN&lt;/code&gt; message but it may not have processed it yet. In order to guarantee the processing of the &lt;code&gt;:DOWN&lt;/code&gt; message, we can do a synchronous request. Since messages are processed in order, once the registry replies to the synchronous request, then the &lt;code&gt;:DOWN&lt;/code&gt; message will definitely have been processed.</source>
          <target state="translated">버킷 조회를 수행하기 전에 동기식 요청을 레지스트리에 전송하는 것이 쉬운 방법입니다. &lt;code&gt;Agent.stop/2&lt;/code&gt; 작업은 동기 만 반환 버킷 프로세스 종료 및 모든 이후 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 전달됩니다. 따라서 &lt;code&gt;Agent.stop/2&lt;/code&gt; 가 반환되면 레지스트리는 이미 &lt;code&gt;:DOWN&lt;/code&gt; 메시지를 받았지만 아직 처리하지 않았을 수 있습니다. &lt;code&gt;:DOWN&lt;/code&gt; 메시지 의 처리를 보장하기 위해 동기 요청을 수행 할 수 있습니다. 메시지가 순서대로 처리되므로 레지스트리가 동기 요청에 응답하면 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 확실히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bc95a79f72a6064f19e08b29349826dd25b216ee" translate="yes" xml:space="preserve">
          <source>An empty list can be passed to avoid stacktrace printing.</source>
          <target state="translated">스택 트레이스 인쇄를 방지하기 위해 빈 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276e3d577cef8507d9164a96e53206098957da90" translate="yes" xml:space="preserve">
          <source>An empty list if there is no match.</source>
          <target state="translated">일치하는 항목이 없으면 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f6764a9eb225a20637ece5e74ca6e79cd54f249b" translate="yes" xml:space="preserve">
          <source>An empty list will be returned if there is no match.</source>
          <target state="translated">일치하는 항목이 없으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7a57e0b595be7bebd781fac5740e7fc7f12ace" translate="yes" xml:space="preserve">
          <source>An empty string will always match:</source>
          <target state="translated">빈 문자열은 항상 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bb794abcdf1956bbd61a3d6b9cb82432c85ee4f0" translate="yes" xml:space="preserve">
          <source>An empty suffix will always match:</source>
          <target state="translated">빈 접미사는 항상 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc88b4de65545bb70648538e7fb3eb0cf86cc242" translate="yes" xml:space="preserve">
          <source>An engine may also &lt;code&gt;use EEx.Engine&lt;/code&gt; to get the default behaviour but this is not advised. In such cases, if any of the callbacks are overridden, they must call &lt;code&gt;super()&lt;/code&gt; to delegate to the underlying &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;EEx.Engine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">엔진은 기본 동작을 얻기 &lt;code&gt;use EEx.Engine&lt;/code&gt; 을 사용할 수도 있지만 권장되지는 않습니다. 이러한 경우 콜백이 재정의되면 기본 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;EEx.Engine&lt;/code&gt; &lt;/a&gt; 에 위임하려면 &lt;code&gt;super()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2319178933b7fc280516f48198d763f0d06241ea" translate="yes" xml:space="preserve">
          <source>An engine needs to implement all callbacks below.</source>
          <target state="translated">엔진은 아래의 모든 콜백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d57834eea31257f109e7c789d7d41f86df67542" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a list:</source>
          <target state="translated">액세스 한 구조가 목록이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5f8f5a5cd7e9dceea4cbf840417ae0c08edc2e95" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map or a struct:</source>
          <target state="translated">액세스 한 구조가 맵 또는 구조체가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50fb59be68cf5f14388edcb66f9d042d984c8dde" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map/struct:</source>
          <target state="translated">액세스 한 구조가 맵 / 구조가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55f9d11748bcf3c144604b93c6b2ae25f8aeccb1" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a tuple:</source>
          <target state="translated">액세스 한 구조가 튜플이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="de94d63a6d219c4ead87b23e065fc7de46de12f5" translate="yes" xml:space="preserve">
          <source>An error is raised if the predicate is not a function or is of the incorrect arity:</source>
          <target state="translated">술어가 기능이 아니거나 올바르지 않은 arity 인 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cde03332fee4ff115f16002c9f108e996e9a75a6" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">오류가 발생했으며 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 다른 메커니즘으로 처리됩니다 . 이 방법은 지연 후 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출 하여 재시작을 시도하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b078cb3fc34c37337f004467d0ce9378efe754a" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">오류가 발생했으며 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 다른 메커니즘으로 처리됩니다 . 이 방법은 지연 후 &lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출 하여 재시작을 시도하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee6f2f4da896a18384f200b0e36a0f349ec99076" translate="yes" xml:space="preserve">
          <source>An escript is an executable that can be invoked from the command line. An escript can run on any machine that has Erlang/OTP installed and by default does not require Elixir to be installed, as Elixir is embedded as part of the escript.</source>
          <target state="translated">escript는 명령 줄에서 호출 할 수있는 실행 파일입니다. Erlang / OTP가 설치된 모든 컴퓨터에서 escript를 실행할 수 있으며, Elixir가 escript의 일부로 내장되어 있기 때문에 기본적으로 Elixir를 설치할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="21ae8235dad3d0eb05c1b7a4b8d8a02b347ddf84" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;code#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 인스턴스는 직접 수정해서는 안됩니다. &lt;a href=&quot;code#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt; 에 전달할 사용자 정의 환경을 작성해야하는 경우 다음 트릭을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e05b13bfc6d99bc82c0aaed709610f0a943ff0f8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 의 인스턴스는 손으로 수정해서는 안됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt; 에 전달할 사용자 지정 환경을 만들어야하는 경우 다음 트릭을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd8bc729544e66eee698242f46c5404236f10a6e" translate="yes" xml:space="preserve">
          <source>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of &lt;code&gt;:io.columns&lt;/code&gt;. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</source>
          <target state="translated">출력에 사용할 최대 열 수를 나타내는 정수입니다. 기본값은 80 열입니다. 실제 출력 너비는이 숫자의 최소값이며 결과는 &lt;code&gt;:io.columns&lt;/code&gt; 입니다. 이렇게하면 IEx를 가장 큰 화면 크기로 구성 할 수 있으며 항상 현재 터미널 화면의 전체 너비를 차지해야합니다.</target>
        </trans-unit>
        <trans-unit id="62dfd3ff7081b119a8a16043b2a10c06d4c45481" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;after&lt;/code&gt; clause can be given in case the message was not received after the given timeout period, specified in milliseconds:</source>
          <target state="translated">지정된 시간 초과 기간 이후에 메시지가 수신되지 않은 경우 (밀리 초로 지정된 경우) 선택적 &lt;code&gt;after&lt;/code&gt; 절을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509d438b27e12dd94c38e2a190b7ee190fb17b57" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; to the corresponding integer can be provided. If &lt;code&gt;base&lt;/code&gt; is not given, 10 will be used.</source>
          <target state="translated">해당 정수에 대한 선택적 &lt;code&gt;base&lt;/code&gt; 이 제공 될 수 있습니다. 경우 &lt;code&gt;base&lt;/code&gt; 주어지지, 10이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bda79df01bfb65a34e0eb465b572e1c22d155d69" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the &lt;code&gt;digits&lt;/code&gt;. Base has to be an integer greater than or equal to &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;digits&lt;/code&gt; 의 기수를 나타내는 선택적 &lt;code&gt;base&lt;/code&gt; 값이 제공 될 수 있습니다 . 밑은 &lt;code&gt;2&lt;/code&gt; 이상의 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="5139348d1208b18f1412d9ff5406b136dc7222e8" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the returned digits. This one must be an integer &amp;gt;= 2.</source>
          <target state="translated">반환 된 숫자의 기수를 나타내는 선택적 &lt;code&gt;base&lt;/code&gt; 값이 제공 될 수 있습니다. 이것은 정수&amp;gt; = 2 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ac126c925abfbfed6be9468e1aea794193196b62" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;starting_on&lt;/code&gt; value may be supplied, which configures the weekday the week starts on. The default value for it is &lt;code&gt;:default&lt;/code&gt;, which translates to &lt;code&gt;:monday&lt;/code&gt; for the built-in ISO calendar. Any other weekday may be given to.</source>
          <target state="translated">주가 시작되는 요일을 구성 하는 선택적 &lt;code&gt;starting_on&lt;/code&gt; 값이 제공 될 수 있습니다. 기본값은 &lt;code&gt;:default&lt;/code&gt; 이며 , 내장 ISO 달력의 경우 &lt;code&gt;:monday&lt;/code&gt; 로 변환됩니다 . 다른 평일이 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a979cd20856e6e7b0398abc497d56ec40c554a" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will be emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">실제 ANSI 코드 방출을 활성화 또는 비활성화하기 위해 선택적 부울 매개 변수를 전달할 수 있습니다. 때 &lt;code&gt;false&lt;/code&gt; , 더 ANSI 코드가 방출되지 않습니다. 기본적으로 &lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 ANSI가 활성화되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="141cb8c089b77fc45a4b599501be2124087d63c3" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">실제 ANSI 코드 방출을 활성화 또는 비활성화하기 위해 선택적 부울 매개 변수를 전달할 수 있습니다. 때 &lt;code&gt;false&lt;/code&gt; , 더 ANSI 코드가 방출되지 않습니다. 기본적으로 &lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 ANSI가 활성화되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="bf23a52f10d72db5a4b065e517b53575b77a702f" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">재정의 가능한 함수는 느리게 정의되어 개발자가이를 사용자 지정할 수 있습니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오. 정보와 문서는 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="670e0435cab9da74bff554f172d6191175f5b29a" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;kernel#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">재정의 가능한 함수는 느리게 정의되어 개발자가이를 사용자 지정할 수 있습니다. 자세한 내용과 설명서는 &lt;a href=&quot;kernel#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f06ca58408ebbb2e2d18da83ab38dd0e2381bfd3" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to override it.</source>
          <target state="translated">재정의 가능한 함수가 느리게 정의되어 개발자가이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735f79f261a0a1398e39bb2ba9f23bdd5b445481" translate="yes" xml:space="preserve">
          <source>An unknown key:</source>
          <target state="translated">알 수없는 키 :</target>
        </trans-unit>
        <trans-unit id="4eb360277b153c599c984a044f3a3b8d7442bbcf" translate="yes" xml:space="preserve">
          <source>An update operation specific for structs is also available:</source>
          <target state="translated">구조체에 특정한 업데이트 작업도 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="dbebd5f66bf57539f1cae5d05912dfd58e43605d" translate="yes" xml:space="preserve">
          <source>Ancestor and Caller Tracking</source>
          <target state="translated">조상 및 발신자 추적</target>
        </trans-unit>
        <trans-unit id="4bf59e857bc43e008d05f39c6798933eabe92a7b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;:greek&lt;/code&gt; properly handles the context sensitive sigma in Greek:</source>
          <target state="translated">그리고 &lt;code&gt;:greek&lt;/code&gt; 는 그리스어 에서 상황에 민감한 시그마를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="57f523660878f0ae5422d81e21ff0f2d992fab43" translate="yes" xml:space="preserve">
          <source>And also in umbrella dependencies:</source>
          <target state="translated">또한 우산 의존성에서 :</target>
        </trans-unit>
        <trans-unit id="7475479141d0c8752fe853a18f88400575acc441" translate="yes" xml:space="preserve">
          <source>And also when comparing different types:</source>
          <target state="translated">또한 다른 유형을 비교할 때 :</target>
        </trans-unit>
        <trans-unit id="a30f504a098cdbb3e9933ddf69fbccd69bd0d89e" translate="yes" xml:space="preserve">
          <source>And an example &lt;code&gt;:my_included_app&lt;/code&gt; defines on its &lt;code&gt;mix.exs&lt;/code&gt; the function:</source>
          <target state="translated">그리고 예제 &lt;code&gt;:my_included_app&lt;/code&gt; 은 &lt;code&gt;mix.exs&lt;/code&gt; 에서 함수를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="ddcbca0482883ea8e4091eaadee210a79869f2e4" translate="yes" xml:space="preserve">
          <source>And execute it as:</source>
          <target state="translated">그리고 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="419827a34eea4ec811bd9357533fc68ae720c124" translate="yes" xml:space="preserve">
          <source>And finally successfully boot it:</source>
          <target state="translated">그리고 마지막으로 성공적으로 부팅하십시오.</target>
        </trans-unit>
        <trans-unit id="72688afe4af65ced53cacec5689d360d88950fb2" translate="yes" xml:space="preserve">
          <source>And here is an example of how you can define &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; from the above configuration:</source>
          <target state="translated">위 구성에서 &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; 를 정의하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0d1bd4c59aaee11683223b356559849183e2699" translate="yes" xml:space="preserve">
          <source>And it then returned a quoted expression as follows:</source>
          <target state="translated">그런 다음 다음과 같이 따옴표로 묶은 표현식을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="e0b5f0362b86f72e75548b22466dd13d5a1cf84b" translate="yes" xml:space="preserve">
          <source>And it will provide the same behaviour. You may use &lt;code&gt;do:&lt;/code&gt; for one-liners but always use &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; for functions spanning multiple lines.</source>
          <target state="translated">그리고 그것은 같은 행동을 제공 할 것입니다. 하나의 라이너에는 &lt;code&gt;do:&lt;/code&gt; 를 사용할 수 있지만 여러 줄에 걸친 함수 에는 항상 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3be6c2d0cb8b49833135e767d2d7a4fbac9b3c5" translate="yes" xml:space="preserve">
          <source>And it works!</source>
          <target state="translated">그리고 작동합니다!</target>
        </trans-unit>
        <trans-unit id="e5ff9d5b10d267dee51c69e79f2c679b450ef8f6" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s connect to it and issue a request in another terminal:</source>
          <target state="translated">연결하고 다른 터미널에서 요청을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="aef6f548c63d313f3e6febdf170c4b53e23d4948" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s try to start our application again:</source>
          <target state="translated">그리고 우리의 응용 프로그램을 다시 시작해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0a3e48a60746f6b847d997fa0fbe9c121a13a5e1" translate="yes" xml:space="preserve">
          <source>And more</source>
          <target state="translated">그리고 더</target>
        </trans-unit>
        <trans-unit id="3975c92bca370daedd767ed422d2ad2a60b72331" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it once more:</source>
          <target state="translated">이제 다시 한 번 조립하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="d14e640d4bda56647f06d50190912bc628cfe672" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it:</source>
          <target state="translated">이제 조립하자 :</target>
        </trans-unit>
        <trans-unit id="450675268dca95ea69df946fd7052040689b26b5" translate="yes" xml:space="preserve">
          <source>And now run tests with:</source>
          <target state="translated">이제 다음을 사용하여 테스트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="91c1d6064e2642eec275bb2697301c83bf002443" translate="yes" xml:space="preserve">
          <source>And play a bit with agents:</source>
          <target state="translated">그리고 에이전트들과 조금 놀아보십시오.</target>
        </trans-unit>
        <trans-unit id="2dadb42bf111f89bf23b4940e02183ac02eb51a8" translate="yes" xml:space="preserve">
          <source>And play with those definitions:</source>
          <target state="translated">그리고 그 정의를 가지고 놀아 라 :</target>
        </trans-unit>
        <trans-unit id="16ce5c350460be5d7d537d13e7f1131d9b8fad50" translate="yes" xml:space="preserve">
          <source>And the variable can be defined in the match itself (prior to its use):</source>
          <target state="translated">그리고 변수는 사용하기 전에 일치 자체에서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8b021dea943d8ac4bd67ab292eb615322244df" translate="yes" xml:space="preserve">
          <source>And then a module may use it as:</source>
          <target state="translated">그런 다음 모듈은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118cdbf4ebff67474fde8aa873dcc8b30629e9be" translate="yes" xml:space="preserve">
          <source>And then explicitly attached in your &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; 콜백 에 명시 적으로 첨부합니다 .</target>
        </trans-unit>
        <trans-unit id="a9c544212c0f62fab7a929bdf6254c14ee92c57a" translate="yes" xml:space="preserve">
          <source>And then passing it to the supervisor:</source>
          <target state="translated">그런 다음 감독자에게 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="75d0f7371704fa5ce1ab31b056a3610c4f01dd6d" translate="yes" xml:space="preserve">
          <source>And then start it:</source>
          <target state="translated">그런 다음 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="46195fee28b6f3924859b2e05c7f84e26d2f56e8" translate="yes" xml:space="preserve">
          <source>And then you can define the implementations specific to the test environment inside &lt;code&gt;test/support/some_file.ex&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;test/support/some_file.ex&lt;/code&gt; 내에 테스트 환경에 특정한 구현을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08c3be653aad70d807268164f869ff1d1f07cee8" translate="yes" xml:space="preserve">
          <source>And to run them:</source>
          <target state="translated">그리고 그들을 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="462519e135281467088215ccc649f512ae9b84ce" translate="yes" xml:space="preserve">
          <source>Anonymous functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="bb9a933ae349228e32e1f073b740f4f65715b58c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;</source>
          <target state="translated">익명 함수는 -func / arity-anonfn-count-로보고됩니다. 여기서 func는 둘러싸는 함수의 이름입니다. &quot;func / arity의 익명 fn&quot;으로 변환</target>
        </trans-unit>
        <trans-unit id="0ad3d840ff5e9c0e8ea7f52dc6172ac4b039510c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are typically created by using &lt;code&gt;fn&lt;/code&gt;:</source>
          <target state="translated">익명 함수는 일반적으로 &lt;code&gt;fn&lt;/code&gt; 을 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e2e0b675b3d9b8858e0c45385fd95f27e5170f3" translate="yes" xml:space="preserve">
          <source>Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:</source>
          <target state="translated">익명 함수는 여러 절을 가질 수도 있습니다. 모든 절은 동일한 개수의 인수를 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfa301a3c21795199d13e7b6588d342af94a24a1" translate="yes" xml:space="preserve">
          <source>Anonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a function is of any given arity by using &lt;code&gt;is_function/2&lt;/code&gt;:</source>
          <target state="translated">엘릭서의 익명 함수는 또한 그들이받는 인수의 수로 식별됩니다. &lt;code&gt;is_function/2&lt;/code&gt; 를 사용하여 함수가 주어진 arity인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3478c83b0f2c05d9c65b14ae56037cbfc0b5c6" translate="yes" xml:space="preserve">
          <source>Anonymous functions with no expression after &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">뒤에 표현식이없는 익명 함수 &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f9ea76dc507dd1537d2a78a7f363a18e4775cd5" translate="yes" xml:space="preserve">
          <source>Another alternative to &lt;code&gt;@derive&lt;/code&gt; is to explicitly tell the protocol to fallback to &lt;code&gt;Any&lt;/code&gt; when an implementation cannot be found. This can be achieved by setting &lt;code&gt;@fallback_to_any&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 의 또 다른 대안 은 구현을 찾을 수 없을 때 프로토콜을 &lt;code&gt;Any&lt;/code&gt; 로 대체하도록 명시 적으로 지시 하는 것입니다. 프로토콜 정의에서 &lt;code&gt;@fallback_to_any&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ce311858ef69483871a91631dbd1d6d4dde210e" translate="yes" xml:space="preserve">
          <source>Another approach is to disable protocol consolidation during tests in your mix.exs:</source>
          <target state="translated">또 다른 방법은 mix.exs에서 테스트하는 동안 프로토콜 통합을 비활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd6916cf153042850a0d4907b1527f29fbe844df" translate="yes" xml:space="preserve">
          <source>Another common metadata is &lt;code&gt;:deprecated&lt;/code&gt;, which emits a warning in the documentation, explaining that its usage is discouraged:</source>
          <target state="translated">또 다른 일반적인 메타 데이터는 &lt;code&gt;:deprecated&lt;/code&gt; 로 , 설명서에 경고가 표시되고 사용법이 권장되지 않는다고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2b8f4fcb03038d3204cf32a1e07964ca7ae1e5e9" translate="yes" xml:space="preserve">
          <source>Another common need in releases is to compute configuration when the release runs, not when the release is assembled. The &lt;code&gt;config/config.exs&lt;/code&gt; file we defined at the beginning of this chapter runs on every Mix command, when we build, test and run our application. This is great, because it provides a unified configuration for dev, test, and prod.</source>
          <target state="translated">릴리스에서 또 다른 일반적인 요구 사항은 릴리스가 조립 될 때가 아니라 릴리스가 실행될 때 구성을 계산하는 것입니다. &lt;code&gt;config/config.exs&lt;/code&gt; 우리가 테스트를 구축하고 우리의 응용 프로그램을 실행할 때, 우리는 모든 믹스 명령에 대한이 장 실행의 시작 부분에 정의 된 파일. dev, test 및 prod에 대한 통합 구성을 제공하기 때문에 훌륭합니다.</target>
        </trans-unit>
        <trans-unit id="d2d6bcdc6f9dd5a9edc0684e098b03c84e550047" translate="yes" xml:space="preserve">
          <source>Another example comes from &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;the ExUnit framework&lt;/a&gt; which uses module attributes as annotation and storage:</source>
          <target state="translated">또 다른 예는 주석 및 스토리지로 모듈 속성을 사용 &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;하는 ExUnit 프레임 워크&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa358ec240cab1628444ba9ff9bd76a8046b33fc" translate="yes" xml:space="preserve">
          <source>Another example while using an imported or local function:</source>
          <target state="translated">가져온 함수 또는 로컬 함수를 사용하는 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="745cb32af8a59b8749a4860fd9efe56fe285cd4a" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">또 다른 중요한 차이점은 &lt;a href=&quot;#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; 를&lt;/a&gt; 사용하면 모듈을 정의 할 때 사용되는 환경 변수를 제어 할 수있는 반면 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; 는&lt;/a&gt; 자동으로 호출되는 환경을 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbe451732076cc22d41fb430c0f2cb877351509f" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;module#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;kernel#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">또 다른 중요한 차이점은 &lt;a href=&quot;module#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; 를&lt;/a&gt; 사용하면 모듈을 정의 할 때 사용되는 환경 변수를 제어 할 수 있지만 &lt;a href=&quot;kernel#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; &lt;/a&gt; 는 호출 된 환경을 자동으로 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d8f88bdbecc2925caf0ed41e2d35ff7613e7a59" translate="yes" xml:space="preserve">
          <source>Another interesting function is &lt;code&gt;Stream.resource/3&lt;/code&gt; which can be used to wrap around resources, guaranteeing they are opened right before enumeration and closed afterwards, even in the case of failures. For example, &lt;code&gt;File.stream!/1&lt;/code&gt; builds on top of &lt;code&gt;Stream.resource/3&lt;/code&gt; to stream files:</source>
          <target state="translated">또 다른 흥미로운 기능은 &lt;code&gt;Stream.resource/3&lt;/code&gt; 로, 리소스를 래핑하는 데 사용할 수 있으며, 오류가 발생하더라도 열거 직전에 열리고 나중에 닫힐 수 있습니다. 예를 들어 &lt;code&gt;File.stream!/1&lt;/code&gt; 은 &lt;code&gt;Stream.resource/3&lt;/code&gt; 위에 빌드됩니다. 파일을 스트리밍합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
