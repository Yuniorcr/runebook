<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="a4164178e5929ed3fb0cfbbf5db866fa640026ff" translate="yes" xml:space="preserve">
          <source>The returned value is a tuple with the current value returned by &lt;code&gt;fun&lt;/code&gt; and a new keyword list with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;fun&lt;/code&gt; 이 반환 한 현재 값이있는 튜플과 &lt;code&gt;key&lt;/code&gt; 아래에 업데이트 된 값이있는 새 키워드 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="bcdf4e0951183ef655924f609aa3f331a6262b10" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the &quot;get&quot; value returned by &lt;code&gt;fun&lt;/code&gt; and a new container with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;fun&lt;/code&gt; 에 의해 리턴 된 &quot;get&quot;값을 가진 2 요소 튜플이며 &lt;code&gt;key&lt;/code&gt; 아래에 업데이트 된 값을 가진 새 컨테이너입니다 .</target>
        </trans-unit>
        <trans-unit id="0f9b50979454240749ecdc91833d5801c156188c" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the current value returned by &lt;code&gt;fun&lt;/code&gt; and a new map with the updated value under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;fun&lt;/code&gt; 에서 현재 값이 반환 된 요소가 2 개인 튜플과 &lt;code&gt;key&lt;/code&gt; 아래에 업데이트 된 값이있는 새 맵입니다 .</target>
        </trans-unit>
        <trans-unit id="4ee34714ba69b3d5a504684c39dd1f4988c4abdf" translate="yes" xml:space="preserve">
          <source>The returned value is a two-element tuple with the number of seconds and microseconds.</source>
          <target state="translated">반환 된 값은 초와 마이크로 초의 수를 가진 2 요소 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="7e65f7f051c44e5c9c75a8f2f854fabd880fc538" translate="yes" xml:space="preserve">
          <source>The returned value of the environment variable &lt;code&gt;varname&lt;/code&gt; is a string. If the environment variable is not set, returns the string specified in &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; if none is specified.</source>
          <target state="translated">환경 변수 &lt;code&gt;varname&lt;/code&gt; 의 리턴 값은 문자열입니다. 환경 변수가 설정되어 있지 않은 경우에 지정된 문자열을 반환 &lt;code&gt;default&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 을 지정하지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="0f847cce0d292ae271a717b61d78816a1f1ea3fd" translate="yes" xml:space="preserve">
          <source>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</source>
          <target state="translated">올바른 경로는 항상 상대 형식으로 확장되며 결합 할 때 후행 슬래시가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="643a7d1289fc8c2df27def8f3faf469415ebab11" translate="yes" xml:space="preserve">
          <source>The right side of &lt;code&gt;.&lt;/code&gt; may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</source>
          <target state="translated">의 오른쪽 &lt;code&gt;.&lt;/code&gt; 별명, 소문자 또는 밑줄로 시작하는 단어, 유효한 언어 연산자 또는 작은 따옴표 또는 큰 따옴표로 묶은 이름을 나타내는 대문자로 시작하는 단어 일 수 있습니다. 이것들은 모두 유효한 예입니다.</target>
        </trans-unit>
        <trans-unit id="c04e1c8f69c2f1a88e36a20e9901940c66e8dcfe" translate="yes" xml:space="preserve">
          <source>The rounding direction always ties to half up. The operation is performed on the binary floating point, without a conversion to decimal.</source>
          <target state="translated">반올림 방향은 항상 반으로 연결됩니다. 이진수 부동 소수점에서 10 진수로 변환하지 않고 연산이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4144dd4219963dfd0900f8f0b48ec21d6f4d014e" translate="yes" xml:space="preserve">
          <source>The router will check the first byte of the bucket name against the table and dispatch to the appropriate node based on that. For example, a bucket starting with the letter &amp;ldquo;a&amp;rdquo; (&lt;code&gt;?a&lt;/code&gt; represents the Unicode codepoint of the letter &amp;ldquo;a&amp;rdquo;) will be dispatched to node &lt;code&gt;foo@computer-name&lt;/code&gt;.</source>
          <target state="translated">라우터는 버킷 이름의 첫 번째 바이트를 테이블과 비교하여이를 기준으로 적절한 노드로 디스패치합니다. 예를 들어, 문자 &quot;a&quot;로 시작하는 버킷 ( &lt;code&gt;?a&lt;/code&gt; 는 문자 &quot;a&quot; 의 유니 코드 코드 포인트를 나타냄)이 &lt;code&gt;foo@computer-name&lt;/code&gt; 노드로 발송됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ff8ac86ff623f4bf3fb0733f54cbe348a65e9dc" translate="yes" xml:space="preserve">
          <source>The routing layer will receive a routing table of the following format:</source>
          <target state="translated">라우팅 계층은 다음 형식의 라우팅 테이블을받습니다.</target>
        </trans-unit>
        <trans-unit id="4c154bbe6784f06daaef10626cc0bf86a4376497" translate="yes" xml:space="preserve">
          <source>The same applies to duplicate registries:</source>
          <target state="translated">중복 레지스트리에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8461a29f68bfc60f9acb948d5fe98c088c56fd3e" translate="yes" xml:space="preserve">
          <source>The same applies to maps where each pair is treated as a list of tuples with two elements:</source>
          <target state="translated">각 쌍이 두 개의 요소가있는 튜플 목록으로 취급되는 맵에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b487f77f15de12365c59e270fe90d68cbbe73146" translate="yes" xml:space="preserve">
          <source>The same applies to qualified calls such as &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt;, which is the same as &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt;. However, remember parentheses are not optional for non-qualified calls with no arguments, such as &lt;code&gt;sum()&lt;/code&gt;. Removing the parentheses for &lt;code&gt;sum&lt;/code&gt; causes it to be represented as the variable &lt;code&gt;sum&lt;/code&gt;, which means they would be no longer equivalent.</source>
          <target state="translated">동일한 같은 정규화 통화 적용 &lt;code&gt;Foo.bar(1, 2, 3)&lt;/code&gt; 와 동일 &lt;code&gt;Foo.bar 1, 2, 3&lt;/code&gt; . 그러나 &lt;code&gt;sum()&lt;/code&gt; 과 같은 인수가없는 규정되지 않은 호출의 경우 괄호는 선택 사항이 아닙니다 . &lt;code&gt;sum&lt;/code&gt; 의 괄호를 제거하면 변수 &lt;code&gt;sum&lt;/code&gt; 로 표시되므로 더 이상 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47e032a5027ea138ef1f6dce21b412d852e000c1" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">&lt;a href=&quot;#cd/1&quot;&gt; &lt;code&gt;cd/1&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4648fcff80dd7d416297fa509f0fce7c20f51db4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cd/1&quot;&gt;&lt;code&gt;cd/1&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">&lt;a href=&quot;#cd/1&quot;&gt; &lt;code&gt;cd/1&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18e01d0d75a4c60af88fee26dd31622d04f96a97" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 그렇지 않으면 &lt;code&gt;bytes_copied&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a58fcd56739bfa5248246728d465bb758d5e5ea2" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the &lt;code&gt;bytes_copied&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 그렇지 않으면 &lt;code&gt;bytes_copied&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2cf6de4f99822a7c8fe3b408ab5d4cf7f42930ca" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 반환 &lt;code&gt;:ok&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="696de6f1529a7a564fc637bc60de66470a73fed7" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 반환 &lt;code&gt;:ok&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="f92c875af9b9262d24ee988fee5dadfcecefeb5a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.copyerror&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="translated">&lt;a href=&quot;#cp_r/3&quot;&gt; &lt;code&gt;cp_r/3&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;file.copyerror&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 그렇지 않으면 복사 된 파일 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dced03231a36fd3a83cda83b79431542ee58a767" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cp_r/3&quot;&gt;&lt;code&gt;cp_r/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt;&lt;code&gt;File.CopyError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns the list of copied files otherwise.</source>
          <target state="translated">&lt;a href=&quot;#cp_r/3&quot;&gt; &lt;code&gt;cp_r/3&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.CopyError.html&quot;&gt; &lt;code&gt;File.CopyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 그렇지 않으면 복사 된 파일 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f459fdf18e68c368ea8cc4aa8ed5c7cc8b9dd88a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">&lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;cwd/0&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0eee2e06aac8b82f8ed48294c71a788555a3adf5" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;cwd/0&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if it fails.</source>
          <target state="translated">&lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;cwd/0&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa8efe783d469a71d442d2785e538f32a3f185b8" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#eval!/2&quot;&gt;&lt;code&gt;eval!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="translated">&lt;a href=&quot;#eval!/2&quot;&gt; &lt;code&gt;eval!/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 가져온 경로를 반환하지 않고 지정된 파일의 구성 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e983c20087a73c47c1b91cd7c2c300a823c39d00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="translated">&lt;a href=&quot;#ls/1&quot;&gt; &lt;code&gt;ls/1&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 오류가 발생 하면 &lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2619800bcffc51ddabf679c548f67d8d665df758" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#ls/1&quot;&gt;&lt;code&gt;ls/1&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception in case of an error.</source>
          <target state="translated">&lt;a href=&quot;#ls/1&quot;&gt; &lt;code&gt;ls/1&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 오류가 발생 하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.Error.html&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e26cc2d303c7d487aeb4684f8a5ec5296d428a79" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 유효하지 않은 옵션이 제공되면 &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94d50f21dfa011da9b3d948e9722047f3d7526a9" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">&lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 유효하지 않은 옵션이 제공되면 &lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2165b5941176ebd36f68f510b06c8757c380d9a" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 유효하지 않은 옵션이 제공되면 &lt;a href=&quot;https://hexdocs.pm/elixir/OptionParser.ParseError.html&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5050ef6fcebfe967949f495038b1cf5998440f0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; but raises an &lt;a href=&quot;optionparser.parseerror&quot;&gt;&lt;code&gt;OptionParser.ParseError&lt;/code&gt;&lt;/a&gt; exception if any invalid options are given.</source>
          <target state="translated">&lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 유효하지 않은 옵션이 제공되면 &lt;a href=&quot;optionparser.parseerror&quot;&gt; &lt;code&gt;OptionParser.ParseError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44ad2c47fd323d50a1b7a9d773f54ea42bbc2572" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#read_imports!/2&quot;&gt;&lt;code&gt;read_imports!/2&lt;/code&gt;&lt;/a&gt; but only returns the configuration in the given file, without returning the imported paths.</source>
          <target state="translated">&lt;a href=&quot;#read_imports!/2&quot;&gt; &lt;code&gt;read_imports!/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 가져온 경로를 반환하지 않고 지정된 파일의 구성 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76551e442cf0920ecab6d0eb8ea56bcf94c15620" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;file.renameerror&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#rename/2&quot;&gt; &lt;code&gt;rename/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;file.renameerror&quot;&gt; &lt;code&gt;File.RenameError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 반환 &lt;code&gt;:ok&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="be26fa6408a4ea8bda26cf7e98b553592e7fd2e6" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#rename/2&quot;&gt;&lt;code&gt;rename/2&lt;/code&gt;&lt;/a&gt; but raises a &lt;a href=&quot;https://hexdocs.pm/elixir/File.RenameError.html&quot;&gt;&lt;code&gt;File.RenameError&lt;/code&gt;&lt;/a&gt; exception if it fails. Returns &lt;code&gt;:ok&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;a href=&quot;#rename/2&quot;&gt; &lt;code&gt;rename/2&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/File.RenameError.html&quot;&gt; &lt;code&gt;File.RenameError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 반환 &lt;code&gt;:ok&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="ff7e3f389bbffc2c11af04820517b44446f5b5b0" translate="yes" xml:space="preserve">
          <source>The second approach uses function calls which better suits more complex APIs (for example, if you need to pass many options) and reads nicely in Elixir thanks to the pipe operator.</source>
          <target state="translated">두 번째 방법은 더 복잡한 API (예 : 많은 옵션을 전달해야하는 경우)에 더 적합한 함수 호출을 사용하고 파이프 연산자 덕분에 Elixir에서 잘 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4989f7d201fe4b48e470058521e1ca80ae6c9569" translate="yes" xml:space="preserve">
          <source>The second argument is a keyword list of options:</source>
          <target state="translated">두 번째 인수는 키워드 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="43642aa7f67e7784c0b111753a92ead35aec4a5a" translate="yes" xml:space="preserve">
          <source>The second argument is either a timeout or &lt;code&gt;:brutal_kill&lt;/code&gt;. In case of a timeout, a &lt;code&gt;:shutdown&lt;/code&gt; exit signal is sent to the task process and if it does not exit within the timeout, it is killed. With &lt;code&gt;:brutal_kill&lt;/code&gt; the task is killed straight away. In case the task terminates abnormally (possibly killed by another process), this function will exit with the same reason.</source>
          <target state="translated">두 번째 인수는 시간 초과 또는 &lt;code&gt;:brutal_kill&lt;/code&gt; 입니다. 시간 초과의 경우 &lt;code&gt;:shutdown&lt;/code&gt; 종료 신호가 작업 프로세스로 전송되고 시간 초과 내에 종료되지 않으면 종료됩니다. 로 &lt;code&gt;:brutal_kill&lt;/code&gt; 작업이 바로 사망한다. 작업이 비정상적으로 종료 된 경우 (다른 프로세스에 의해 종료 된 경우)이 기능은 같은 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb757bd7051270d8c819a13491903d89a8704fd" translate="yes" xml:space="preserve">
          <source>The second argument is first expanded to an absolute path.</source>
          <target state="translated">두 번째 인수는 먼저 절대 경로로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="524ef427f3aceff5423ab5acc031269f5e3169df" translate="yes" xml:space="preserve">
          <source>The second argument specifying every &lt;code&gt;nth&lt;/code&gt; element must be a non-negative integer.</source>
          <target state="translated">모든 &lt;code&gt;nth&lt;/code&gt; 요소를 지정하는 두 번째 인수 는 음이 아닌 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6a6d508d801e049e82fe48d35683e28b76dc2200" translate="yes" xml:space="preserve">
          <source>The second change is in the &lt;code&gt;application&lt;/code&gt; function inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">두 번째 변경 사항은 &lt;code&gt;mix.exs&lt;/code&gt; 내부 의 &lt;code&gt;application&lt;/code&gt; 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="36314cd4001b7103421433826074baa427430f61" translate="yes" xml:space="preserve">
          <source>The second concern is that, while using &lt;code&gt;mix run&lt;/code&gt; is completely fine to run our software in production, the command we use to start our services is getting increasingly more complex. For example, imagine we also want to &lt;code&gt;--preload-modules&lt;/code&gt;, to all code is loaded upfront, as well as set the &lt;code&gt;MIX_ENV=prod&lt;/code&gt; environment variable:</source>
          <target state="translated">두 번째 관심사는 프로덕션에서 소프트웨어를 실행하기 위해 &lt;code&gt;mix run&lt;/code&gt; 을 사용 하는 것이 완벽하지만 서비스를 시작하는 데 사용하는 명령이 점점 더 복잡해지고 있다는 것입니다. 예를 들어 &lt;code&gt;--preload-modules&lt;/code&gt; 를 실행 하고 &lt;code&gt;MIX_ENV=prod&lt;/code&gt; 환경 변수 를 설정하는 것뿐만 아니라 모든 코드를 미리로드 한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="59db642f7ebf3826674361ba0acf5de33120795d" translate="yes" xml:space="preserve">
          <source>The second definition matches the pattern and has no guard so it will be executed. It first prints our &lt;code&gt;msg&lt;/code&gt; and then calls itself passing &lt;code&gt;n - 1&lt;/code&gt; (&lt;code&gt;2&lt;/code&gt;) as the second argument.</source>
          <target state="translated">두 번째 정의는 패턴과 일치하며 가드가 없으므로 실행됩니다. 먼저 &lt;code&gt;msg&lt;/code&gt; 를 인쇄 한 다음 &lt;code&gt;n - 1&lt;/code&gt; ( &lt;code&gt;2&lt;/code&gt; )를 두 번째 인수로 전달하여 자신을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dae9460a51adde13fd535bc1aee22f1354a6ed7b" translate="yes" xml:space="preserve">
          <source>The second element is a keyword list containing metadata, like numbers and contexts;</source>
          <target state="translated">두 번째 요소는 숫자 및 컨텍스트와 같은 메타 데이터를 포함하는 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="21d656a71ac68bd8b82b5427ffa0a32c0e82e5b7" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#t:metadata/0&quot;&gt;metadata&lt;/a&gt;.</source>
          <target state="translated">튜플의 두 번째 요소는 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#t:metadata/0&quot;&gt;메타 데이터를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="09930d4769fdab8c631461548dda5978d0ffac47" translate="yes" xml:space="preserve">
          <source>The second element of the tuple represents metadata.</source>
          <target state="translated">튜플의 두 번째 요소는 메타 데이터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49369ce9190f9083bafea50347ba1f7b69ded63d" translate="yes" xml:space="preserve">
          <source>The second flaw is related to the supervision strategy. If &lt;code&gt;KV.Registry&lt;/code&gt; dies, all information linking &lt;code&gt;KV.Bucket&lt;/code&gt; names to bucket processes is lost. Therefore the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; and all children must terminate too - otherwise we will have orphan processes.</source>
          <target state="translated">두 번째 결함은 감독 전략과 관련이 있습니다. 경우 &lt;code&gt;KV.Registry&lt;/code&gt; 가 죽으면, 연결 모든 정보 &lt;code&gt;KV.Bucket&lt;/code&gt; 의 버킷 프로세스 이름은 손실됩니다. 따라서 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 및 모든 어린이도 종료해야합니다. 그렇지 않으면 고아 프로세스가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b27ec208e18d1eae9448f08cbc57e44112bc1f3" translate="yes" xml:space="preserve">
          <source>The second is to make sure your &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; calls do not have a wildcard character. If so, you need to perform the wildcard lookup manually. For example, if you did:</source>
          <target state="translated">두 번째는 &lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; &lt;/a&gt; 호출에 와일드 카드 문자가 없는지 확인하는 것 입니다. 그렇다면 와일드 카드 조회를 수동으로 수행해야합니다. 예를 들어, 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="3f52940a3eb4585da7a86f017cdfc1095c4a0962" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, and so forth.</source>
          <target state="translated">두 번째 부분 인 가드는 결과를 필터링 할 수있는 조건 목록입니다. 각 가드는 패턴의 지정된 부분에 의해 전달되어야하는 검사를 설명하는 튜플입니다. 예를 들어 &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 보호 조건은 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 튜플로 표현됩니다. 가드 조건은 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 등과 같이 할당 된 변수에 대해서만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="03c8c69c3a8917dcc36201eb8826bb675ed3a306" translate="yes" xml:space="preserve">
          <source>The second part, the guards, is a list of conditions that allow filtering the results. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">두 번째 부분 인 가드는 결과를 필터링 할 수있는 조건 목록입니다. 각 가드는 튜플이며 지정된 패턴 부분이 통과해야하는 검사를 설명합니다. 예를 들어 &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 가드 조건은 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 튜플로 표현됩니다. 보호 조건은 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 등과 같은 할당 된 변수에 대해서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8279ae6c0770b2c5c483279a964f5a0fd686e18a" translate="yes" xml:space="preserve">
          <source>The second pitfall is that the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator works on calls. For example, when you write:</source>
          <target state="translated">두 번째 함정은 &lt;code&gt;|&amp;gt;&lt;/code&gt; 연산자가 호출에 대해 작업 한다는 것 입니다. 예를 들어 다음과 같이 쓸 때</target>
        </trans-unit>
        <trans-unit id="494117d2d88c4ce9741e6ac16716fddbb8f4cbe4" translate="yes" xml:space="preserve">
          <source>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</source>
          <target state="translated">두 번째 원칙은 가능한 한 적은 구성을 제공하는 것입니다. 이를 통해 커뮤니티 전체에서 단일 스타일을 일관되게 따르는 동시에 경합 지점을 제거하여 포맷터 채택을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="661a367f5412305ec9e82e19ba1e4e566dc26d28" translate="yes" xml:space="preserve">
          <source>The second test checks that the code raises for unknown entries.</source>
          <target state="translated">두 번째 테스트는 코드에서 알 수없는 항목이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8cd7d01257f835cc5a3247359bf87ad73936ce2f" translate="yes" xml:space="preserve">
          <source>The server is now running, and you will even notice the console is blocked. Let&amp;rsquo;s use &lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt;a &lt;code&gt;telnet&lt;/code&gt; client&lt;/a&gt; to access our server. There are clients available on most operating systems, and their command lines are generally similar:</source>
          <target state="translated">이제 서버가 실행 중이며 콘솔이 차단 된 것을 볼 수도 있습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Telnet&quot;&gt; &lt;code&gt;telnet&lt;/code&gt; &lt;/a&gt; 클라이언트 를 사용 하여 서버에 액세스 합시다 . 대부분의 운영 체제에서 사용 가능한 클라이언트가 있으며 해당 명령 줄은 일반적으로 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="fd585ae8b1d0205e194512ad32642a694a88c604" translate="yes" xml:space="preserve">
          <source>The server reference.</source>
          <target state="translated">서버 참조</target>
        </trans-unit>
        <trans-unit id="d40bf167b8d71e1dda39cd357ab868e4586251d2" translate="yes" xml:space="preserve">
          <source>The server responsibilities include:</source>
          <target state="translated">서버 책임은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff65793db264093aa3a7a1cf46e0cbfc1e4b8a04" translate="yes" xml:space="preserve">
          <source>The setup callbacks are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as &lt;code&gt;context&lt;/code&gt;. The context to be used in the tests can be optionally extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="translated">설정 콜백은 매크로를 통해 정의되며 각각은 선택적으로 테스트 상태 및 메타 데이터 (일반적으로 &lt;code&gt;context&lt;/code&gt; 라고 함)가있는 맵을 수신 할 수 있습니다 . 테스트에 사용되는 컨텍스트는 적절히 구조화 된 값을 반환하여 설정 콜백에 의해 선택적으로 확장 될 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="beb94809dde5c8a8ccc0fe6fd795a37a627a36a9" translate="yes" xml:space="preserve">
          <source>The setup callbacks may be used to define &lt;a href=&quot;https://en.wikipedia.org/wiki/Test_fixture#Software&quot;&gt;test fixtures&lt;/a&gt; and run any initialization code which help bring the system into a known state. They are defined via macros and each one can optionally receive a map with test state and metadata, usually referred to as the &lt;code&gt;context&lt;/code&gt;. Optionally, the context to be used in the tests can be extended by the setup callbacks by returning a properly structured value (see below).</source>
          <target state="translated">설정 콜백은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Test_fixture#Software&quot;&gt;테스트 픽스처&lt;/a&gt; 를 정의 하고 시스템을 알려진 상태로 만드는 데 도움이되는 초기화 코드를 실행하는 데 사용할 수 있습니다 . 매크로를 통해 정의되며 각 항목은 일반적으로 &lt;code&gt;context&lt;/code&gt; 라고하는 테스트 상태 및 메타 데이터가 포함 된지도를 선택적으로받을 수 있습니다 . 선택적으로 테스트에서 사용할 컨텍스트는 적절하게 구조화 된 값을 반환하여 설정 콜백으로 확장 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="be70f07b576f3a68fa738cef7302c8e28346ebfb" translate="yes" xml:space="preserve">
          <source>The shutdown process happens in reverse order.</source>
          <target state="translated">종료 프로세스는 역순으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a344948a2691ee6269fc2879136d40e4dca1f373" translate="yes" xml:space="preserve">
          <source>The size can be a variable:</source>
          <target state="translated">크기는 변수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8111a6aa75f3c6e4735d59b2e853a7faeadebe29" translate="yes" xml:space="preserve">
          <source>The size of a map is the number of key-value pairs that the map contains.</source>
          <target state="translated">지도의 크기는지도에 포함 된 키-값 쌍의 수입니다.</target>
        </trans-unit>
        <trans-unit id="0078ede4075127860c2ade218ba7d232c2981cd7" translate="yes" xml:space="preserve">
          <source>The snippet above only works because numbers implement the &lt;code&gt;String.Chars&lt;/code&gt; protocol. Passing a tuple, for example, will lead to an error:</source>
          <target state="translated">위의 코드 조각은 숫자가 &lt;code&gt;String.Chars&lt;/code&gt; 프로토콜을 구현하기 때문에 작동 합니다. 예를 들어 튜플을 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c615bba281ebbef820e4ccb712d2aa12dcf9a32" translate="yes" xml:space="preserve">
          <source>The solution here is to use &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#take/2&quot;&gt;&lt;code&gt;Stream.take/2&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt;&lt;code&gt;Enum.take/2&lt;/code&gt;&lt;/a&gt; to filter elements before-hand:</source>
          <target state="translated">여기서 해결책은 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#take/2&quot;&gt; &lt;code&gt;Stream.take/2&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt; &lt;code&gt;Enum.take/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 요소를 미리 필터링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6272c1202f90648d2a2419029598638bd1dd5c26" translate="yes" xml:space="preserve">
          <source>The solution is to provide configuration as close as possible to where it is used and not via the application environment. In case of a function, you could expect keyword lists as a new argument:</source>
          <target state="translated">해결책은 응용 프로그램 환경을 통하지 않고 사용되는 위치에 최대한 가깝게 구성을 제공하는 것입니다. 함수의 경우 키워드 목록을 새로운 인수로 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2456d942f9ee207983a501b269e82c8ae7c4b6" translate="yes" xml:space="preserve">
          <source>The sorting algorithm will be stable as long as the given function returns &lt;code&gt;true&lt;/code&gt; for values considered equal:</source>
          <target state="translated">주어진 함수가 동일한 것으로 간주되는 값에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환하는 한 정렬 알고리즘은 안정적입니다 .</target>
        </trans-unit>
        <trans-unit id="972944894d27378714ceb941dffde3e2074c4f7f" translate="yes" xml:space="preserve">
          <source>The spec also provides a &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; set but Elixir does not include any character on this set. Therefore the identifier rule has been simplified to consider this.</source>
          <target state="translated">이 사양은 또한 &lt;code&gt;&amp;lt;Medial&amp;gt;&lt;/code&gt; 세트를 제공하지만 Elixir는이 세트에 문자를 포함하지 않습니다. 따라서 식별자 규칙이이를 고려하여 단순화되었습니다.</target>
        </trans-unit>
        <trans-unit id="fc80cf8cc0e875b59d4cb7a74f58a13e82e8e79b" translate="yes" xml:space="preserve">
          <source>The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching.</source>
          <target state="translated">스택은 목록을 둘러싼 작은 래퍼입니다. 목록 앞에 추가하여 스택 맨 위에 요소를 배치하고 패턴 일치로 스택 맨 위에 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="c90a34e2afaa39e30146b58a596138ac46c6ee44" translate="yes" xml:space="preserve">
          <source>The steps necessary to work across nodes is already commented out as an example. You can enable full distribution by uncommenting the last two lines by removing the leading &lt;code&gt;# &lt;/code&gt;.</source>
          <target state="translated">여러 노드에서 작업하는 데 필요한 단계는 이미 예로 설명되어 있습니다. 선행 &lt;code&gt;# &lt;/code&gt; 을 제거하여 마지막 두 줄의 주석을 해제하여 전체 배포를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6547b77a17d5ef12542c7afee97cc798fc8b1249" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="translated">이 스트림은 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜을 모두 구현하므로 읽기 및 쓰기에 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee85dc5e71fc294b36604877aa25393a7df8e42" translate="yes" xml:space="preserve">
          <source>The stream implements both &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocols, which means it can be used both for read and write.</source>
          <target state="translated">스트림은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Collectable.html&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜을 모두 구현합니다. 즉, 읽기 및 쓰기 모두에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a2b7409cbfc04d5907be0d98cbcaddcde54753" translate="yes" xml:space="preserve">
          <source>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt;&lt;code&gt;node/0&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">프롬프트에서 괄호 사이의 문자열은 노드의 이름입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#node/0&quot;&gt; &lt;code&gt;node/0&lt;/code&gt; &lt;/a&gt; 함수를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81e25ea527122c6269507a786b1fac990f5269a4" translate="yes" xml:space="preserve">
          <source>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</source>
          <target state="translated">문자열 연결은 코드를 한 줄에 맞추고 포맷터에 더 많은 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86cdec7e4462e9309a1a4eb1db8bbf7175736e0b" translate="yes" xml:space="preserve">
          <source>The string concatenation operation is actually a binary concatenation operator:</source>
          <target state="translated">문자열 연결 작업은 실제로 이진 연결 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="7f69f0cddd44731ccae3984440903fe5c39c51ec" translate="yes" xml:space="preserve">
          <source>The string concatenation operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is actually a binary concatenation operator:</source>
          <target state="translated">문자열 연결 연산자 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 는 실제로 이진 연결 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="8259167cccd8df309147297c84a34df6a1de5df3" translate="yes" xml:space="preserve">
          <source>The string is split into as many parts as possible by default, but can be controlled via the &lt;code&gt;:parts&lt;/code&gt; option.</source>
          <target state="translated">문자열은 기본적으로 가능한 많은 부분으로 분할되지만 &lt;code&gt;:parts&lt;/code&gt; 옵션을 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff34135d2b9fe9bf18a8b4692de3737dabb31735" translate="yes" xml:space="preserve">
          <source>The struct fields are private and should not be accessed.</source>
          <target state="translated">구조체 필드는 비공개이므로 액세스해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="571837e3b232d92d474e8917fdedc1786ba58276" translate="yes" xml:space="preserve">
          <source>The struct fields can be given when building the struct:</source>
          <target state="translated">구조체를 만들 때 구조체 필드를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bf51de3e3e5df1170754020b84a38130fd526e" translate="yes" xml:space="preserve">
          <source>The supervision strategy dictates what happens when one of the children crashes. &lt;code&gt;:one_for_one&lt;/code&gt; means that if a child dies, it will be the only one restarted. Since we have only one child now, that&amp;rsquo;s all we need. The &lt;code&gt;Supervisor&lt;/code&gt; behaviour supports many different strategies and we will discuss them in this chapter.</source>
          <target state="translated">감독 전략은 자녀 중 하나가 추락 할 때 발생하는 상황을 나타냅니다. &lt;code&gt;:one_for_one&lt;/code&gt; 은 자식이 죽으면 다시 시작한다는 것을 의미합니다. 지금 우리에게는 자녀가 하나뿐이므로 이것이 전부입니다. &lt;code&gt;Supervisor&lt;/code&gt; 동작은 여러 가지 전략을 지원하고 우리는이 장에서이를 논의 할 것이다.</target>
        </trans-unit>
        <trans-unit id="d45ea759f46bff3ba089e89707b504285b2e2aff" translate="yes" xml:space="preserve">
          <source>The supervisor flags returned on init</source>
          <target state="translated">관리자 플래그가 init에 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="e3742ff69698c4acf77e80f28496fe07172ab4b1" translate="yes" xml:space="preserve">
          <source>The supervisor reference</source>
          <target state="translated">감독자 참조</target>
        </trans-unit>
        <trans-unit id="5aec5d17ff71d8a46be456b119441ed148f52e07" translate="yes" xml:space="preserve">
          <source>The supervisor specification</source>
          <target state="translated">감독자 사양</target>
        </trans-unit>
        <trans-unit id="55243bfac4a971c230124af0cb70d274159f15f1" translate="yes" xml:space="preserve">
          <source>The supervisor will then invoke &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; to retrieve a child specification. Now the &lt;code&gt;Stack&lt;/code&gt; module is responsible for building its own specification, for example, we could write:</source>
          <target state="translated">감독자는 그런 다음 &lt;code&gt;Stack.child_spec([:hello])&lt;/code&gt; 을 호출 하여 자식 사양을 검색합니다. 이제 &lt;code&gt;Stack&lt;/code&gt; 모듈은 자체 사양을 작성해야합니다. 예를 들어 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48df4bde49257478d542a437f9de2f0a2ea29a61" translate="yes" xml:space="preserve">
          <source>The supported class names are:</source>
          <target state="translated">지원되는 클래스 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2acb742979d49cdd1ce894f691b11d6c69ead543" translate="yes" xml:space="preserve">
          <source>The supported forms are:</source>
          <target state="translated">지원되는 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f9a7d8961a3767298fcfbab64cbbb6e0e6ee0b" translate="yes" xml:space="preserve">
          <source>The supported keys in the &lt;code&gt;:colors&lt;/code&gt; keyword list are:</source>
          <target state="translated">&lt;code&gt;:colors&lt;/code&gt; 키워드 목록 에서 지원되는 키는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3179160c7ddd0151d004050775f2d167fb2bf259" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by importance, are:</source>
          <target state="translated">중요도 순으로 지원되는 수준은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7878d33057652c5e4e57d591e83ecedf612c203" translate="yes" xml:space="preserve">
          <source>The supported levels, ordered by precedence, are:</source>
          <target state="translated">지원되는 수준은 우선 순위에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="db2280a174b18020a2620736642518bf66a11dab" translate="yes" xml:space="preserve">
          <source>The supported options are:</source>
          <target state="translated">지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a909fba4eceb102c979e5e9c2b15d4702c456bf4" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (e.g., &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">Elixir가 형식 사양에 제공하는 구문 &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;은 Erlang&lt;/a&gt; 의 구문과 유사합니다 . Erlang에서 제공하는 대부분의 내장 유형 (예 : &lt;code&gt;pid()&lt;/code&gt; )은 &lt;code&gt;pid()&lt;/code&gt; (또는 단순히 &lt;code&gt;pid&lt;/code&gt; ) 와 같은 방식으로 표현됩니다 . 매개 변수화 된 유형 (예 : &lt;code&gt;list(integer)&lt;/code&gt; )도 지원되며 원격 유형 (예 : &lt;code&gt;Enum.t&lt;/code&gt; )도 지원됩니다. 정수 및 원자 리터럴은 유형으로 허용됩니다 (예 &lt;code&gt;:atom&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; , : atom 또는 &lt;code&gt;false&lt;/code&gt; ). 다른 모든 유형은 사전 정의 된 유형의 조합으로 구성됩니다. &lt;code&gt;[...]&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;{...}&lt;/code&gt; 과 같은 일부 속기가 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="11e8b05ebb02ab602f5c99e81c78f285a85d25bf" translate="yes" xml:space="preserve">
          <source>The syntax Elixir provides for type specifications is similar to &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;the one in Erlang&lt;/a&gt;. Most of the built-in types provided in Erlang (for example, &lt;code&gt;pid()&lt;/code&gt;) are expressed in the same way: &lt;code&gt;pid()&lt;/code&gt; (or simply &lt;code&gt;pid&lt;/code&gt;). Parameterized types (such as &lt;code&gt;list(integer)&lt;/code&gt;) are supported as well and so are remote types (such as &lt;code&gt;Enum.t&lt;/code&gt;). Integers and atom literals are allowed as types (for example, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;). All other types are built out of unions of predefined types. Some shorthands are allowed, such as &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">Elixir가 타입 스펙을 위해 제공하는 구문 &lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;은 Erlang&lt;/a&gt; 의 구문과 유사합니다 . Erlang에서 제공되는 대부분의 내장 유형 (예 : &lt;code&gt;pid()&lt;/code&gt; )은 동일한 방식으로 표현됩니다 : &lt;code&gt;pid()&lt;/code&gt; (또는 간단히 &lt;code&gt;pid&lt;/code&gt; ). 매개 변수화 된 유형 (예 : &lt;code&gt;list(integer)&lt;/code&gt; )도 지원되며 원격 유형 (예 : &lt;code&gt;Enum.t&lt;/code&gt; )도 지원됩니다. 정수 및 원자 리터럴은 유형으로 허용됩니다 (예 &lt;code&gt;:atom&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; , : atom 또는 &lt;code&gt;false&lt;/code&gt; ). 다른 모든 유형은 사전 정의 된 유형의 공용체로 작성됩니다. &lt;code&gt;[...]&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;{...}&lt;/code&gt; 와 같은 일부 속기가 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0036cfb43509daaf5a87c862104d3f9568ed85" translate="yes" xml:space="preserve">
          <source>The syntax above requires the given key to exist. It cannot be used to add new keys. For example, using it with the &lt;code&gt;:c&lt;/code&gt; key failed because there is no &lt;code&gt;:c&lt;/code&gt; in the map.</source>
          <target state="translated">위의 구문에는 주어진 키가 있어야합니다. 새 키를 추가하는 데 사용할 수 없습니다. 예를 들어, 그것을 사용하여 &lt;code&gt;:c&lt;/code&gt; 더 있기 때문에 키가 실패하지 &lt;code&gt;:c&lt;/code&gt; 지도한다.</target>
        </trans-unit>
        <trans-unit id="e74604ffed887af469a3ff79efc01a49993440e8" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;badstructerror&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">위의 구문은 주어진 키가 컴파일 타임에 유효 함을 보장하고 런타임에 주어진 인수가 구조체이며, 그렇지 않으면 &lt;a href=&quot;badstructerror&quot;&gt; &lt;code&gt;BadStructError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 함을 보장 합니다.</target>
        </trans-unit>
        <trans-unit id="7180700097f6ff908399744578d9873946673ba9" translate="yes" xml:space="preserve">
          <source>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with &lt;a href=&quot;https://hexdocs.pm/elixir/BadStructError.html&quot;&gt;&lt;code&gt;BadStructError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">위의 구문은 주어진 키가 컴파일 시간에 유효 함을 보장하고 런타임에 주어진 인수가 구조체임을 보장하고 그렇지 않으면 &lt;a href=&quot;https://hexdocs.pm/elixir/BadStructError.html&quot;&gt; &lt;code&gt;BadStructError&lt;/code&gt; 로&lt;/a&gt; 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="3346ccb7be2d14285ad110f9bf13a253d6668e2a" translate="yes" xml:space="preserve">
          <source>The syntax is to put the function and its input on the left side of the &lt;code&gt;::&lt;/code&gt; and the return value&amp;rsquo;s type on the right side. Be aware that types &lt;em&gt;may&lt;/em&gt; omit parentheses.</source>
          <target state="translated">구문은 함수와 입력을 &lt;code&gt;::&lt;/code&gt; 의 왼쪽에 배치 하고 반환 값의 유형을 오른쪽에 배치하는 것입니다. 유형 &lt;em&gt;은&lt;/em&gt; 괄호를 생략 &lt;em&gt;할 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b84a63985dcdfb17ccdca5bd58bdd7687878200d" translate="yes" xml:space="preserve">
          <source>The system sets different environment variables. The following variables are set early on and can only be read by &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt;:</source>
          <target state="translated">시스템은 다른 환경 변수를 설정합니다. 다음 변수는 초기에 설정되며 &lt;code&gt;env.sh&lt;/code&gt; 및 &lt;code&gt;env.bat&lt;/code&gt; 에서만 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15e9fc5e9c4c2be91d093aa25daa8c7249775f24" translate="yes" xml:space="preserve">
          <source>The tail elements of aliases are guaranteed to always be atoms.</source>
          <target state="translated">별칭의 꼬리 요소는 항상 원자임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="0bcdf2274bc91e89bdf8524fe117cd1e390a0aae" translate="yes" xml:space="preserve">
          <source>The task can now be invoked with &lt;code&gt;mix hello&lt;/code&gt;.</source>
          <target state="translated">이제 작업을 &lt;code&gt;mix hello&lt;/code&gt; 로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ca9f432a46eddec31b6e992a693b8edf32b4e5d" translate="yes" xml:space="preserve">
          <source>The template in &lt;code&gt;source&lt;/code&gt; is evaluated with the given &lt;code&gt;assigns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 의 템플릿 은 주어진 &lt;code&gt;assigns&lt;/code&gt; 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fec88603f65815ad051446d1e908302ee019778" translate="yes" xml:space="preserve">
          <source>The temporary directory path is unique (includes the test module and test name) and thus appropriate for running tests concurrently. You can customize the path further by setting the tag to a string, e.g.: &lt;code&gt;tmp_dir: &quot;my_path&quot;&lt;/code&gt;, which would make the final path to be: &lt;code&gt;tmp/&amp;lt;module&amp;gt;/&amp;lt;test&amp;gt;/my_path&lt;/code&gt;.</source>
          <target state="translated">임시 디렉토리 경로는 고유하므로 (테스트 모듈 및 테스트 이름 포함) 테스트를 동시에 실행하는 데 적합합니다. 태그를 문자열로 설정하여 경로를 추가로 사용자 정의 할 수 있습니다 (예 : &lt;code&gt;tmp_dir: &quot;my_path&quot;&lt;/code&gt; ). 그러면 최종 경로가 &lt;code&gt;tmp/&amp;lt;module&amp;gt;/&amp;lt;test&amp;gt;/my_path&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="60d7de295785ea0605333a1eba6bb25d621b6acc" translate="yes" xml:space="preserve">
          <source>The terms are only considered to be exactly equal if they have the same value and are of the same type. For example, &lt;code&gt;1 == 1.0&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but since they are of different types, &lt;code&gt;1 === 1.0&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">용어는 값이 같고 유형이 같은 경우에만 정확히 동일한 것으로 간주됩니다. 예를 들어 &lt;code&gt;1 == 1.0&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 를 반환 하지만 형식이 다르기 때문에 &lt;code&gt;1 === 1.0&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="705df9c2e6adef6ee615fd1500b80411120b3a6b" translate="yes" xml:space="preserve">
          <source>The test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.</source>
          <target state="translated">버킷 프로세스가 중지 된 후에도 버킷 이름이 레지스트리에 남아 있으므로 위 테스트는 마지막 어설 션에서 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c419758630890afee6c5cb360c0c3e39b020572b" translate="yes" xml:space="preserve">
          <source>The test files are sorted upfront in a round-robin fashion. Note the partition itself is given as an environment variable so it can be accessed in config files and test scripts. For example, it can be used to setup a different database instance per partition in &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="translated">테스트 파일은 라운드 로빈 방식으로 미리 정렬됩니다. 파티션 자체는 환경 변수로 제공되므로 구성 파일 및 테스트 스크립트에서 액세스 할 수 있습니다. 예를 들어 &lt;code&gt;config/test.exs&lt;/code&gt; 에서 파티션별로 다른 데이터베이스 인스턴스를 설정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2570223385e731ad04d7b7880f45f2e4a73c2ce4" translate="yes" xml:space="preserve">
          <source>The test is similar to &amp;ldquo;removes bucket on exit&amp;rdquo; except that we are being a bit more harsh by sending &lt;code&gt;:shutdown&lt;/code&gt; as the exit reason instead of &lt;code&gt;:normal&lt;/code&gt;. If a process terminates with a reason different than &lt;code&gt;:normal&lt;/code&gt;, all linked processes receive an EXIT signal, causing the linked process to also terminate unless it is trapping exits.</source>
          <target state="translated">테스트는 &lt;code&gt;:normal&lt;/code&gt; 대신 종료 이유로 &lt;code&gt;:shutdown&lt;/code&gt; 을 전송하여 조금 더 가혹하다는 점을 제외하고는 &quot; 종료시 버킷 제거&quot;와 유사합니다 . 프로세스가 &lt;code&gt;:normal&lt;/code&gt; 과 다른 이유로 종료 되면 모든 링크 된 프로세스가 EXIT 신호를 수신하여 트랩 된 프로세스가 종료되지 않으면 링크 된 프로세스도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="80778ceb5bc9dd6da4a613a6cd5240315d4115bd" translate="yes" xml:space="preserve">
          <source>The test may also define a &lt;code&gt;var&lt;/code&gt;, which will pattern match on the test context. For more information on contexts, see &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트는 테스트 컨텍스트에서 패턴 일치를 수행 하는 &lt;code&gt;var&lt;/code&gt; 를 정의 할 수도 있습니다 . 컨텍스트에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdde6c13039b2d4b85652376fce95fabfa20deef" translate="yes" xml:space="preserve">
          <source>The test should pass.</source>
          <target state="translated">테스트는 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bf29b425a5cead446e53e0022f0fce0236e0195" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;exunit#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="translated">테스트 유형은 문자열로 변환되어 표시 될 수 있도록 복수화됩니다. &lt;a href=&quot;exunit#plural_rule/2&quot;&gt; &lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 사용자 지정 복수형을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04db17fea40288d1a870e2f7e8d0c93c33a565d3" translate="yes" xml:space="preserve">
          <source>The test type will be converted to a string and pluralized for display. You can use &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#plural_rule/2&quot;&gt;&lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt;&lt;/a&gt; to set a custom pluralization.</source>
          <target state="translated">테스트 유형은 문자열로 변환되고 표시를 위해 복수화됩니다. &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html#plural_rule/2&quot;&gt; &lt;code&gt;ExUnit.plural_rule/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 사용자 지정 복수화를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a927d1705beb862013fa4736d80e7112683437e5" translate="yes" xml:space="preserve">
          <source>The third approach uses macros, and is by far the most complex. It will take more lines of code to implement, it is hard and expensive to test (compared to testing simple functions), and it limits how the user may use the library since all validations need to be defined inside a module.</source>
          <target state="translated">세 번째 방법은 매크로를 사용하며 훨씬 복잡합니다. 구현하는 데 더 많은 코드 줄이 필요하고 테스트하기가 어렵고 비용이 많이 들며 (단순 함수 테스트와 비교할 때) 모든 유효성 검사를 모듈 내부에서 정의해야하기 때문에 사용자가 라이브러리를 사용할 수있는 방법을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1d45004d92cd0fa8dd37a67dc40c34ac5fe7a8f6" translate="yes" xml:space="preserve">
          <source>The third argument given to &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; is a value associated to the current process. While in the previous section we used it when dispatching, in this particular example we are not interested in it, so we have set it to an empty list. You could store a more meaningful value if necessary.</source>
          <target state="translated">&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; 에&lt;/a&gt; 주어진 세 번째 인수 는 현재 프로세스와 연관된 값입니다. 이전 섹션에서 디스패치 할 때 사용했지만이 특정 예제에서는 관심이 없으므로 빈 목록으로 설정했습니다. 필요한 경우보다 의미있는 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286a4f81139162ba612e0fc78d910245b92506ae" translate="yes" xml:space="preserve">
          <source>The third argument is the stacktrace which is used to enrich a normalized error with more information. It is only used when the kind is an error.</source>
          <target state="translated">세 번째 인수는 추가 정보로 정규화 된 오류를 보강하는 데 사용되는 스택 추적입니다. 종류가 오류 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0469bb3fc164355009dcbe32b659229c5de7434" translate="yes" xml:space="preserve">
          <source>The third element is either a list of arguments for the function call or an atom. When this element is an atom, it means the tuple represents a variable.</source>
          <target state="translated">세 번째 요소는 함수 호출에 대한 인수 목록 또는 원자입니다. 이 요소가 원자 인 경우 튜플은 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="61d0bd68d9312dd1a2b6bc353f3631650af592e9" translate="yes" xml:space="preserve">
          <source>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).</source>
          <target state="translated">튜플의 세 번째 요소는 함수 호출에 대한 인수입니다. 세 번째 인수는 일반적으로 변수 또는 로컬 호출 인 원자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03e20762e8bbf0a5e287057fa9da1be08a2ebb0" translate="yes" xml:space="preserve">
          <source>The third part, the body, is a list of shapes of the returned entries. Like guards, you have access to assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, which you can combine with hardcoded values to freely shape entries Note that tuples have to be wrapped in an additional tuple. To get a result format like &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt;, assuming you bound those variables in order in the match part, you would provide a body like &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt;. Like guards, you can use some operations like &lt;code&gt;:element&lt;/code&gt; to modify the output format.</source>
          <target state="translated">세 번째 부분 인 본문은 반환 된 항목의 모양 목록입니다. 보호자와 마찬가지로 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 과 같은 할당 된 변수에 액세스 할 수 있습니다. 하드 코딩 된 값과 결합하여 항목을 자유롭게 구성 할 수 있습니다. 튜플은 추가 튜플에 래핑해야합니다. &lt;code&gt;%{key: key, pid: pid, value: value}&lt;/code&gt; 와 같은 결과 형식을 얻으려면 일치 부분에서 해당 변수를 순서대로 바인딩한다고 가정하면 &lt;code&gt;[%{key: :&quot;$1&quot;, pid: :&quot;$2&quot;, value: :&quot;$3&quot;}]&lt;/code&gt; 와 같은 본문을 제공하게 됩니다. : : &quot;$ 2&quot;, 값 : : &quot;$ 3&quot;}] . 가드와 마찬가지로 &lt;code&gt;:element&lt;/code&gt; 와 같은 일부 작업을 사용 하여 출력 형식을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8a93e3bf717eed4a2e3026f8f31870641fb464" translate="yes" xml:space="preserve">
          <source>The time functions in this module work in the &lt;code&gt;:native&lt;/code&gt; unit (unless specified otherwise), which is operating system dependent. Most of the time, all calculations are done in the &lt;code&gt;:native&lt;/code&gt; unit, to avoid loss of precision, with &lt;a href=&quot;#convert_time_unit/3&quot;&gt;&lt;code&gt;convert_time_unit/3&lt;/code&gt;&lt;/a&gt; being invoked at the end to convert to a specific time unit like &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:microsecond&lt;/code&gt;. See the &lt;a href=&quot;#t:time_unit/0&quot;&gt;&lt;code&gt;time_unit/0&lt;/code&gt;&lt;/a&gt; type for more information.</source>
          <target state="translated">이 모듈의 시간 기능 은 운영 체제에 따라 다른 &lt;code&gt;:native&lt;/code&gt; 단위 (달리 명시되지 않는 한)에서 작동합니다. 대부분의 경우 모든 계산은 정밀도 손실을 피하기 위해 &lt;code&gt;:native&lt;/code&gt; 단위 로 수행되며 마지막에 &lt;a href=&quot;#convert_time_unit/3&quot;&gt; &lt;code&gt;convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 가 호출되어 &lt;code&gt;:millisecond&lt;/code&gt; 또는 &lt;code&gt;:microsecond&lt;/code&gt; 와 같은 특정 시간 단위로 변환됩니다 . 자세한 내용은 &lt;a href=&quot;#t:time_unit/0&quot;&gt; &lt;code&gt;time_unit/0&lt;/code&gt; &lt;/a&gt; 유형을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c81a5f56c30620f4ca3fdbd7994e540bcd3307ec" translate="yes" xml:space="preserve">
          <source>The time type returned in &lt;code&gt;atime&lt;/code&gt;, &lt;code&gt;mtime&lt;/code&gt;, and &lt;code&gt;ctime&lt;/code&gt; is dependent on the time type set in options. &lt;code&gt;{:time, type}&lt;/code&gt; where type can be &lt;code&gt;:local&lt;/code&gt;, &lt;code&gt;:universal&lt;/code&gt;, or &lt;code&gt;:posix&lt;/code&gt;. Default is &lt;code&gt;:universal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; 및 &lt;code&gt;ctime&lt;/code&gt; 으로 리턴 되는 시간 유형은 옵션에 설정된 시간 유형에 따라 다릅니다. &lt;code&gt;{:time, type}&lt;/code&gt; 여기서 type은 &lt;code&gt;:local&lt;/code&gt; , &lt;code&gt;:universal&lt;/code&gt; 또는 &lt;code&gt;:posix&lt;/code&gt; 일 수 있습니다. 기본값은 &lt;code&gt;:universal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ccc7b51abb959b7b6a642bc36ea122d38002d9a" translate="yes" xml:space="preserve">
          <source>The time unit to be passed to functions like &lt;a href=&quot;#monotonic_time/1&quot;&gt;&lt;code&gt;monotonic_time/1&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">&lt;a href=&quot;#monotonic_time/1&quot;&gt; &lt;code&gt;monotonic_time/1&lt;/code&gt; &lt;/a&gt; 등의 함수에 전달할 시간 단위 입니다.</target>
        </trans-unit>
        <trans-unit id="1bbd3b4515f159eff3b51909840a9c295b77b423" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (e.g. Europe/Zurich)</source>
          <target state="translated">IANA tz 데이터베이스에 따른 시간대 ID (예 : 유럽 / 취리히)</target>
        </trans-unit>
        <trans-unit id="9e127d4e3ff4d398a6cfe90803c629c4523b576a" translate="yes" xml:space="preserve">
          <source>The time zone ID according to the IANA tz database (for example, Europe/Zurich)</source>
          <target state="translated">IANA tz 데이터베이스에 따른 시간대 ID (예 : Europe / Zurich)</target>
        </trans-unit>
        <trans-unit id="b125596c86be66bad3036f66746716d52648f027" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds</source>
          <target state="translated">표준 시간대 UTC 오프셋 (초)</target>
        </trans-unit>
        <trans-unit id="3df5c55c74cecebffe247785901344586d62d59b" translate="yes" xml:space="preserve">
          <source>The time zone UTC offset in seconds for standard time.</source>
          <target state="translated">표준 시간의 표준 시간대 UTC 오프셋 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="4a33e0326e0255c69b66326b76b995f67cc50bc7" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (e.g. CET or CEST or BST etc.)</source>
          <target state="translated">시간대 약어 (예 : CET 또는 CEST 또는 BST 등)</target>
        </trans-unit>
        <trans-unit id="e483f17410a33eb44510ffea9561b18ac2cf91e9" translate="yes" xml:space="preserve">
          <source>The time zone abbreviation (for example, CET or CEST or BST, and such)</source>
          <target state="translated">시간대 약어 (예 : CET, CEST 또는 BST 등)</target>
        </trans-unit>
        <trans-unit id="fcad795376e4abb458cc8e3841c41b9eba5c998c" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (not zero in summer times)</source>
          <target state="translated">시간대 표준 오프셋 (초) (서머 타임에는 0이 아님)</target>
        </trans-unit>
        <trans-unit id="25fd14442f68de45c7fa315a32da5dbaeb94d1d8" translate="yes" xml:space="preserve">
          <source>The time zone standard offset in seconds (typically not zero in summer times).</source>
          <target state="translated">시간대 표준 오프셋 (초)입니다 (일반적으로 여름철에는 0이 아님).</target>
        </trans-unit>
        <trans-unit id="cce73f4a8a7c3c6d7d87f75bc5aa727351d2f2f2" translate="yes" xml:space="preserve">
          <source>The timer will be automatically canceled if the given &lt;code&gt;dest&lt;/code&gt; is a PID which is not alive or when the given PID exits. Note that timers will not be automatically canceled when &lt;code&gt;dest&lt;/code&gt; is an atom (as the atom resolution is done on delivery).</source>
          <target state="translated">주어진 &lt;code&gt;dest&lt;/code&gt; 이 아직 존재하지 않는 PID이거나 주어진 PID가 종료되면 타이머가 자동으로 취소 됩니다. &lt;code&gt;dest&lt;/code&gt; 가 원자 인 경우 타이머는 자동으로 취소되지 않습니다 (전달시 원자 분해능이 수행되므로).</target>
        </trans-unit>
        <trans-unit id="95f67c03b8dd416c9af30e47423ea3401d29e99a" translate="yes" xml:space="preserve">
          <source>The trait can be one of two options:</source>
          <target state="translated">특성은 두 가지 옵션 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c51e1e67805ed16c58e9c1e802e36335ea6aca4" translate="yes" xml:space="preserve">
          <source>The trouble with state</source>
          <target state="translated">상태의 고민</target>
        </trans-unit>
        <trans-unit id="a1d02c2f92fc207d7072d19d88bfe702734e4f16" translate="yes" xml:space="preserve">
          <source>The tuple above represents a function call to &lt;code&gt;sum&lt;/code&gt; passing 1, 2 and 3 as arguments. The tuple elements are:</source>
          <target state="translated">투플은 상술 된 함수 호출을 나타내는 &lt;code&gt;sum&lt;/code&gt; 의 인수 1, 2 및 3을 전달한다. 튜플 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88ca5571ed44473b8f3ce89710c5edfce0720f58" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keyword lists keys must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="translated">두 구문은 완전히 동일합니다. 원자와 마찬가지로 키워드 목록 키는 문자, 숫자, 밑줄 및 &lt;code&gt;@&lt;/code&gt; 와 같은 유니 코드 문자로 구성되어야합니다 . 키워드에 공백과 같이 위의 범주에 속하지 않는 문자가있는 경우 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be32613fcd0e0034d6c53c421573b087961e380" translate="yes" xml:space="preserve">
          <source>The two syntaxes are completely equivalent. Like atoms, keywords must be composed of Unicode characters such as letters, numbers, underscore, and &lt;code&gt;@&lt;/code&gt;. If the keyword has a character that does not belong to the category above, such as spaces, you can wrap it in quotes:</source>
          <target state="translated">두 구문은 완전히 같습니다. 원자와 마찬가지로 키워드는 문자, 숫자, 밑줄 및 &lt;code&gt;@&lt;/code&gt; 과 같은 유니 코드 문자로 구성되어야합니다 . 키워드에 공백과 같이 위 카테고리에 속하지 않는 문자가 있으면 따옴표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c03fb1d89c3fb5cf593c60e9aa138dedff7e09ba" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="translated">키 액세스를위한 두 가지 구문은 맵의 이중 특성을 보여줍니다. &lt;code&gt;map[key]&lt;/code&gt; 구 어떤 유형의 키를 가질 수 있으며 동적으로 생성 된지도를 사용한다. &lt;code&gt;map.key&lt;/code&gt; 는 항상 존재하는 것으로 예상되는 미리 결정된 원자 키 세트를 보유하는 맵과 함께 사용됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; 을&lt;/a&gt; 통해 정의 된 구조체 는 이러한 &quot;정적 맵&quot;의 한 예입니다. 여기서 키는 컴파일 시간 동안 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf824f894b5901f732af99ee1c6741c2c8f9460" translate="yes" xml:space="preserve">
          <source>The two syntaxes for accessing keys reveal the dual nature of maps. The &lt;code&gt;map[key]&lt;/code&gt; syntax is used for dynamically created maps that may have any key, of any type. &lt;code&gt;map.key&lt;/code&gt; is used with maps that hold a predetermined set of atoms keys, which are expected to always be present. Structs, defined via &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt;, are one example of such &quot;static maps&quot;, where the keys can also be checked during compile time.</source>
          <target state="translated">키에 액세스하기위한 두 가지 구문은 맵의 이중 특성을 나타냅니다. &lt;code&gt;map[key]&lt;/code&gt; 구 어떤 유형의 키를 가질 수 있으며 동적으로 생성 된지도를 사용한다. &lt;code&gt;map.key&lt;/code&gt; 는 항상 존재할 것으로 예상되는 미리 정해진 원자 키 세트를 보유하는 맵과 함께 사용됩니다. &lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; 을&lt;/a&gt; 통해 정의 된 Structs 는 이러한 &quot;정적 맵&quot;의 한 예이며 컴파일 시간 동안 키를 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b2df44172f3a57aa97a9d731e7cf407e529ef4" translate="yes" xml:space="preserve">
          <source>The type of keys allowed on registration</source>
          <target state="translated">등록시 허용되는 키 유형</target>
        </trans-unit>
        <trans-unit id="2981849bde4b665272891869623a6b0939beaaa5" translate="yes" xml:space="preserve">
          <source>The type of registry metadata keys</source>
          <target state="translated">레지스트리 메타 데이터 키의 유형</target>
        </trans-unit>
        <trans-unit id="1b222464dab205a6bd54b94d0bb3729d611af5dc" translate="yes" xml:space="preserve">
          <source>The type of registry metadata values</source>
          <target state="translated">레지스트리 메타 데이터 값의 유형</target>
        </trans-unit>
        <trans-unit id="1d6b108d320c16acf0d32c924ccacb139089d8c7" translate="yes" xml:space="preserve">
          <source>The type of the registry</source>
          <target state="translated">레지스트리 유형</target>
        </trans-unit>
        <trans-unit id="53279e10023dca8a2288968b9bcf710b0c986964" translate="yes" xml:space="preserve">
          <source>The type of values allowed on registration</source>
          <target state="translated">등록시 허용되는 값의 유형</target>
        </trans-unit>
        <trans-unit id="96d309a1ca8c9b49d61652c9574ee5761b49d46b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">&lt;code&gt;String.t()&lt;/code&gt; 및 &lt;code&gt;binary()&lt;/code&gt; 유형 은 분석 도구와 동일합니다. 문서를 읽는 사람들에게 &lt;code&gt;String.t()&lt;/code&gt; 는 UTF-8로 인코딩 된 바이너리임을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="fd984a4e58cc83d476fe33ed807205982b711883" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%User{}&lt;/code&gt; 포함되지 않은 구조체 필드의 유형은 기본적으로 &lt;code&gt;term()&lt;/code&gt; 으로 설정됩니다 ( &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#built-in-types&quot;&gt; &lt;code&gt;term/0&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cb8c250a62b4261ebc510b4a71573c121311d0bb" translate="yes" xml:space="preserve">
          <source>The types of the struct fields that are not included in &lt;code&gt;%User{}&lt;/code&gt; default to &lt;code&gt;term()&lt;/code&gt; (see &lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;term/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%User{}&lt;/code&gt; 포함되지 않은 구조체 필드의 유형은 기본적으로 &lt;code&gt;term()&lt;/code&gt; ( &lt;a href=&quot;typespecs#built-in-types&quot;&gt; &lt;code&gt;term/0&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b4b4572dc37f28e7b3a1df4f6c8add52491639ae" translate="yes" xml:space="preserve">
          <source>The underscore variable (&lt;code&gt;_&lt;/code&gt;) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:</source>
          <target state="translated">밑줄 변수 ( &lt;code&gt;_&lt;/code&gt; )는 어떤 값에도 바인딩 될 수 없기 때문에 특별한 의미를 갖습니다. 패턴의 특정 값에 관심이 없을 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d2b5512b33fdcb38fab8fdf28a5c744cc440968f" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">단위는 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서와 같이 정수일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b47b534c105a2118838e65f4bd8f13e6c75b738" translate="yes" xml:space="preserve">
          <source>The unit can also be an integer as in &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">단위는 &lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서와 같이 정수일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a447ce422905d13f06edc954109b01bb1211f3ed" translate="yes" xml:space="preserve">
          <source>The unreachable and deprecated checks below happen every time your project is compiled via &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;mix compile.xref&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">아래의 도달 할 수없고 사용되지 않는 확인은 프로젝트가 &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;mix compile.xref&lt;/code&gt; &lt;/a&gt; 를 통해 컴파일 될 때마다 발생합니다 . 자세한 내용은 &lt;a href=&quot;mix.tasks.compile.xref&quot;&gt; &lt;code&gt;Mix.Tasks.Compile.Xref&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f350c7b62e10906702ea9465bc4c4e8ee009110d" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;:ok&lt;/code&gt;/&lt;code&gt;:error&lt;/code&gt; tuples is about the domain that the function works on, in this case, file system access. Bad arguments, logical errors, invalid options should raise regardless of the function name. If in doubt, prefer to return tuples instead of raising, as users of your library can always match on the results and raise if necessary.</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; / &lt;code&gt;:error&lt;/code&gt; 튜플 의 사용법은 이 기능이 작동하는 도메인 (이 경우 파일 시스템 액세스)에 관한 것입니다. 잘못된 인수, 논리적 오류, 유효하지 않은 옵션은 함수 이름에 관계없이 발생해야합니다. 확실하지 않은 경우 라이브러리 사용자가 항상 결과와 일치하고 필요한 경우 올릴 수 있으므로 올리지 않고 튜플을 반환하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="f2761fc5ed5c6c550d3c3f11fa24ee7951107bd4" translate="yes" xml:space="preserve">
          <source>The user must press Enter or type one of &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot; or &quot;Yes&quot;.</source>
          <target state="translated">사용자는 Enter 키를 누르거나 &quot;y&quot;, &quot;yes&quot;, &quot;Y&quot;, &quot;YES&quot;또는 &quot;Yes&quot;중 하나를 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="067adddb8899b26a44c6d119cc5060679343ac3f" translate="yes" xml:space="preserve">
          <source>The valid parameters you can use are:</source>
          <target state="translated">사용할 수있는 유효한 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e5fe130617142d21e815f74a253669918514b41" translate="yes" xml:space="preserve">
          <source>The value emitted is &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given time until the element is streamed.</source>
          <target state="translated">방출되는 값은 &lt;code&gt;0&lt;/code&gt; 입니다. 이 작업은 요소가 스트리밍 될 때까지 지정된 시간까지 호출자를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="d90bdb7c5d59a88b306900023f5ca84001349ca6" translate="yes" xml:space="preserve">
          <source>The value is a keyword list with two possible keys representing prompt types:</source>
          <target state="translated">값은 프롬프트 유형을 나타내는 두 가지 가능한 키가있는 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="caa6577865e36568b3711626c14e00f9b424ae56" translate="yes" xml:space="preserve">
          <source>The value is no longer a binary, but a bitstring &amp;ndash; a bunch of bits! So a binary is a bitstring where the number of bits is divisible by 8.</source>
          <target state="translated">이 값은 더 이상 이진이 아니라 비트 열입니다. 따라서 이진은 비트 수를 8로 나눌 수있는 비트 열입니다.</target>
        </trans-unit>
        <trans-unit id="3cc68a54cd0dbc959bc6164a6a2b53075dfa30ea" translate="yes" xml:space="preserve">
          <source>The values emitted are an increasing counter starting at &lt;code&gt;0&lt;/code&gt;. This operation will block the caller by the given interval every time a new element is streamed.</source>
          <target state="translated">방출되는 값은 &lt;code&gt;0&lt;/code&gt; 부터 시작하는 카운터 증가 입니다. 이 작업은 새 요소가 스트리밍 될 때마다 지정된 간격으로 호출자를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="be1b57a18ace41fb8f93930afe8b1ad887b40d1d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:case&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:case&lt;/code&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a8416871ca07e4a4f59fb2e54024c09ce510c3d" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:padding&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48b014b54ab14e39b32c6219693fd725eede8847" translate="yes" xml:space="preserve">
          <source>The values for &lt;code&gt;:time&lt;/code&gt; can be:</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; 의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21f3f4f945d9026f4fff4e43f08cf7f4707e46e4" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;_&lt;/code&gt; is special in that it can never be read from. Trying to read from it gives a compile error:</source>
          <target state="translated">변수 &lt;code&gt;_&lt;/code&gt; 은 읽을 수 없다는 점에서 특별합니다. 그것을 읽으려고하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e1be81239623e7fbf2a82d7e2a4f2b80599067d" translate="yes" xml:space="preserve">
          <source>The variables defined inside &lt;code&gt;quote&lt;/code&gt; won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</source>
          <target state="translated">내부에 정의 된 변수 &lt;code&gt;quote&lt;/code&gt; 인용 표현의 위생 메커니즘에 의한 캐고 동안 사용할 수 없습니다. 위생 메커니즘은 따옴표로 묶인 표현식에서 변수 이름을 변경하여 매크로 사용자가 정의한 변수와 충돌하지 않도록합니다. 따라서 원래 이름을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8744b53eaf293e92df6d8b3f6054f83b09340e5" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer 2.0: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="translated">버전은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 구조체로 표시되며 필드는 SemVer 2.0 : &lt;code&gt;:major&lt;/code&gt; , &lt;code&gt;:minor&lt;/code&gt; , &lt;code&gt;:patch&lt;/code&gt; , &lt;code&gt;:pre&lt;/code&gt; 및 &lt;code&gt;:build&lt;/code&gt; 에 따라 이름이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d0b621f78879c76c317ddf557989e7b4d0a18c9" translate="yes" xml:space="preserve">
          <source>The version is represented by the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct and fields are named according to SemVer: &lt;code&gt;:major&lt;/code&gt;, &lt;code&gt;:minor&lt;/code&gt;, &lt;code&gt;:patch&lt;/code&gt;, &lt;code&gt;:pre&lt;/code&gt;, and &lt;code&gt;:build&lt;/code&gt;.</source>
          <target state="translated">버전은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 구조체로 표시되며 필드는 SemVer : &lt;code&gt;:major&lt;/code&gt; , &lt;code&gt;:minor&lt;/code&gt; , &lt;code&gt;:patch&lt;/code&gt; , &lt;code&gt;:pre&lt;/code&gt; 및 &lt;code&gt;:build&lt;/code&gt; 에 따라 이름이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="64e09f157d5e5070ea793feca6351f0810f54544" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;!&lt;/code&gt; is preferred when you want to handle different outcomes using pattern matching:</source>
          <target state="translated">없는 버전 &lt;code&gt;!&lt;/code&gt; 패턴 일치를 사용하여 다른 결과를 처리하려는 경우 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="e2528fcfa71e426e6f186925ba5d183a72e0825f" translate="yes" xml:space="preserve">
          <source>The wildcard looks like an ordinary path, except that the following &quot;wildcard characters&quot; are interpreted in a special way:</source>
          <target state="translated">와일드 카드 문자는 다음과 같은 &quot;와일드 카드 문자&quot;가 특별한 방식으로 해석된다는 점을 제외하면 일반적인 경로처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="0fcbc9b2e71d94abc862c5aacc86295bf5f87ef7" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits and, while ISO 8601 allows datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Note leap seconds are not supported by the built-in Calendar.ISO.</source>
          <target state="translated">이 함수로 구문 분석 된 연도는 4 자리로 제한되며 ISO 8601에서는 날짜 시간이 다음 날 0 시로 24:00:00을 지정할 수 있지만이 표기법은 Elixir에서 지원되지 않습니다. 내장 된 Calendar.ISO는 윤초를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43359a56ca5b9f74f8ed54225f235a4eac841d33" translate="yes" xml:space="preserve">
          <source>The year parsed by this function is limited to four digits.</source>
          <target state="translated">이 함수로 파싱 된 연도는 4 자리로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="42c8fd279491ba3a5a79a3fc57c18b896f2e8d7e" translate="yes" xml:space="preserve">
          <source>The zip and zlib modules</source>
          <target state="translated">zip 및 zlib 모듈</target>
        </trans-unit>
        <trans-unit id="a928b0d99e54733f051669ca9f28257ad67f0a00" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable completes.</source>
          <target state="translated">열거 형이 완료되면 압축이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="92c61e8c081422e6cb087e5091e2eef8743332a7" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any enumerable in the given collection completes.</source>
          <target state="translated">지정된 컬렉션에서 열거 가능한 항목이 완료되면 압축이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="5390d109c8d9531238497e8770981143c5154c71" translate="yes" xml:space="preserve">
          <source>The zipping finishes as soon as any list terminates.</source>
          <target state="translated">목록이 종료 되 자마자 압축이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="b625dd872916e65cdac731dbaa58c2540d9b95a9" translate="yes" xml:space="preserve">
          <source>Then we define a &lt;code&gt;start_link/1&lt;/code&gt; function, which will effectively start the agent. It is a convention to define a &lt;code&gt;start_link/1&lt;/code&gt; function that always accepts a list of options. We don&amp;rsquo;t plan on using any options right now, but we might later on. We then proceed to call &lt;code&gt;Agent.start_link/1&lt;/code&gt;, which receives an anonymous function that returns the Agent&amp;rsquo;s initial state.</source>
          <target state="translated">그런 다음 에이전트를 효과적으로 시작 하는 &lt;code&gt;start_link/1&lt;/code&gt; 함수를 정의합니다 . 항상 옵션 목록을 허용하는 &lt;code&gt;start_link/1&lt;/code&gt; 함수 를 정의하는 규칙 입니다. 지금은 옵션을 사용할 계획이 없지만 나중에 나올 수도 있습니다. 그런 다음 &lt;code&gt;Agent.start_link/1&lt;/code&gt; 을 호출 하여 에이전트의 초기 상태를 반환하는 익명 함수를받습니다.</target>
        </trans-unit>
        <trans-unit id="87d5cb2e280470b50ded81bad6b2dc9e656de005" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider in the release configuration:</source>
          <target state="translated">그런 다음 릴리스를 지정할 때 릴리스 구성에서 공급자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9efffd6370bf177135cf0838aedef8c490edaff" translate="yes" xml:space="preserve">
          <source>Then when specifying your release, you can specify the provider:</source>
          <target state="translated">그런 다음 릴리스를 지정할 때 제공자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90be63383bb86c2a9b4266d11b3e7f59bb1305ef" translate="yes" xml:space="preserve">
          <source>Then, we add the head of the list to the accumulator &lt;code&gt;head + accumulator&lt;/code&gt; and call &lt;code&gt;sum_list&lt;/code&gt; again, recursively, passing the tail of the list as its first argument. The tail will once again match &lt;code&gt;[head | tail]&lt;/code&gt; until the list is empty, as seen below:</source>
          <target state="translated">그런 다음리스트 헤드를 누산기 &lt;code&gt;head + accumulator&lt;/code&gt; 에 추가하고리스트의 꼬리를 첫 번째 인수로 전달하여 재귀 적으로 &lt;code&gt;sum_list&lt;/code&gt; 를 다시 호출 합니다. 꼬리는 다시 한 번 &lt;code&gt;[head | tail]&lt;/code&gt; 아래에 표시된대로 목록이 비워 질 때까지 :</target>
        </trans-unit>
        <trans-unit id="6b87f84651e39aeea5d926774256f894a29c7180" translate="yes" xml:space="preserve">
          <source>Then, whenever desired, those tests could be included in the run via the &lt;code&gt;--include&lt;/code&gt; option:</source>
          <target state="translated">그런 다음 원할 때마다 &lt;code&gt;--include&lt;/code&gt; 옵션을 통해 해당 테스트를 실행에 포함시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34c7a694bb4b3edc18ed538476727a5e7423da3d" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to guarantee that a release is built on a host with the same properties as the target. A simple option is to fetch the source, compile the code and assemble the release on the target itself. It would be something like this:</source>
          <target state="translated">릴리스가 대상과 동일한 속성을 가진 호스트에 빌드되도록 보장하는 몇 가지 방법이 있습니다. 간단한 옵션은 소스를 가져 와서 코드를 컴파일하고 타겟 자체에서 릴리스를 어셈블하는 것입니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b194d7af362d9259824b1fbfd5de6ca884c3d2da" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve a character integer code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="translated">문자 정수 코드 포인트를 검색하는 몇 가지 방법이 있습니다. 하나를 사용할 수 &lt;code&gt;?&lt;/code&gt; 구성 :</target>
        </trans-unit>
        <trans-unit id="fd47a0efe22eeb6657bd6cb7a37660028cc2160e" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to retrieve the character code point. One may use the &lt;code&gt;?&lt;/code&gt; construct:</source>
          <target state="translated">문자 코드 포인트를 검색하는 몇 가지 방법이 있습니다. 하나는 &lt;code&gt;?&lt;/code&gt; 구성 :</target>
        </trans-unit>
        <trans-unit id="d172ca4ba6fbab564abb0cac6cec14ca318e2156" translate="yes" xml:space="preserve">
          <source>There are a couple other modifiers that can be useful when doing pattern matches on binaries. The &lt;code&gt;binary-size(n)&lt;/code&gt; modifier will match &lt;code&gt;n&lt;/code&gt; bytes in a binary:</source>
          <target state="translated">바이너리에서 패턴 일치를 수행 할 때 유용 할 수있는 몇 가지 다른 수정자가 있습니다. &lt;code&gt;binary-size(n)&lt;/code&gt; 수정 일치 &lt;code&gt;n&lt;/code&gt; 바이너리 바이트 :</target>
        </trans-unit>
        <trans-unit id="1fd8e7b8f98e5336f83be9a7d713b450297e94ab" translate="yes" xml:space="preserve">
          <source>There are a couple other options here. One option is to spawn the distributed node programmatically at the beginning of &lt;code&gt;test/test_helper.exs&lt;/code&gt;. Erlang/OTP does provide APIs for doing so, but they are non-trivial and therefore we won&amp;rsquo;t cover them here.</source>
          <target state="translated">여기에 몇 가지 다른 옵션이 있습니다. 한 가지 옵션은 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 시작시 프로그래밍 방식으로 분산 노드를 생성하는 것 입니다. Erlang / OTP는이를위한 API를 제공하지만 사소한 것은 아니므로 여기서는 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5c718f04d68cfff9168f654a99aa0bd9577e3dd" translate="yes" xml:space="preserve">
          <source>There are a couple ways in which developers can customize the generated artifacts inside a release.</source>
          <target state="translated">개발자가 릴리스 내에서 생성 된 아티팩트를 사용자 정의 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36172e9cd5c05c77e84149217392745df0757dd" translate="yes" xml:space="preserve">
          <source>There are a few attributes available in Mix tasks to configure them in Mix:</source>
          <target state="translated">믹스 작업에서 믹스로 구성 할 수있는 몇 가지 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="29207daf154a421b800aeacb77caf5c5eb506793" translate="yes" xml:space="preserve">
          <source>There are a few suitable alternatives to replace GenEvent. Each of them can be the most beneficial based on the use case.</source>
          <target state="translated">GenEvent를 대체 할 수있는 몇 가지 적절한 대안이 있습니다. 각각은 유스 케이스에 따라 가장 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10bcc082a2d994b16cb89b80b77c2f9140673c29" translate="yes" xml:space="preserve">
          <source>There are a few ways to quit the IEx shell:</source>
          <target state="translated">IEx 쉘을 종료하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="622f4d4a041d29a7624f6c3efe7c38d00a98501a" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="translated">IEx에서 제공하는 다양한 사용자 지정 옵션이 있습니다. &lt;code&gt;h IEx.configure/1&lt;/code&gt; 을 입력하여 &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt; 기능에 대한 문서를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="7d8ce000a8dc139890c07c24e80b5de5ae99f4f0" translate="yes" xml:space="preserve">
          <source>There are a number of customization options provided by IEx. Take a look at the docs for the &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; function by typing &lt;code&gt;h IEx.configure/1&lt;/code&gt;.</source>
          <target state="translated">IEx가 제공하는 많은 사용자 정의 옵션이 있습니다. &lt;code&gt;h IEx.configure/1&lt;/code&gt; 을 입력하여 &lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt; 기능에 대한 문서를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="09d8b4775b01e8f623175d798409cd369f28544b" translate="yes" xml:space="preserve">
          <source>There are a number of ways to debug code in Elixir. In this chapter we will cover some of the more common ways of doing so.</source>
          <target state="translated">Elixir에서 코드를 디버깅하는 방법에는 여러 가지가 있습니다. 이 장에서는 일반적인 방법 중 몇 가지를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa57737d9360fbe5afeae180cdd5ea0fce51697c" translate="yes" xml:space="preserve">
          <source>There are additional macros for other levels.</source>
          <target state="translated">다른 레벨에 대한 추가 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a57a74b23748fb93cbfac3d76920a5b6c297f9f8" translate="yes" xml:space="preserve">
          <source>There are also other known problems like flooring or rounding numbers. See &lt;a href=&quot;#round/2&quot;&gt;&lt;code&gt;round/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#floor/2&quot;&gt;&lt;code&gt;floor/2&lt;/code&gt;&lt;/a&gt; for more details about them.</source>
          <target state="translated">바닥 수 또는 반올림 숫자와 같은 다른 알려진 문제도 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;#round/2&quot;&gt; &lt;code&gt;round/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#floor/2&quot;&gt; &lt;code&gt;floor/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5aa51c40876eefd1b0d73b2bb1e06b02c0333f56" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뱅이 아닌 변형이없는 일부 비 페어링 기능도 있습니다. 강타는 여전히 실패시 예외가 발생한다는 것을 의미합니다. 예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html#assert_protocol!/1&quot;&gt; &lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e4e195bc2fdfc89b8bda777699ef0647f0c7ff7" translate="yes" xml:space="preserve">
          <source>There are also some non-paired functions, with no non-bang variant. The bang still signifies that it will raise an exception on failure. Example: &lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt;&lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뱅이 아닌 변형이없는 비 페어링 기능도 있습니다. 뱅은 여전히 ​​실패에 대한 예외를 제기 할 것임을 나타냅니다. 예 : &lt;a href=&quot;protocol#assert_protocol!/1&quot;&gt; &lt;code&gt;Protocol.assert_protocol!/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae5ae6e32d973b8c6e5e16938f53a6274e7ce3ca" translate="yes" xml:space="preserve">
          <source>There are currently no plans for a major v2 release.</source>
          <target state="translated">현재 주요 v2 릴리스에 대한 계획은 없습니다.</target>
        </trans-unit>
        <trans-unit id="579246d0821bd1ab37dccebc3ea342f2ad2e0066" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈에도 부동 소수점 숫자와 관련된 함수가 있습니다. 다음은 그 목록입니다.</target>
        </trans-unit>
        <trans-unit id="70fbc19347af9335ddb73d64b97e33f72c2ab414" translate="yes" xml:space="preserve">
          <source>There are functions related to floating-point numbers on the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module too. Here is a list of them:</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈에는 부동 소수점 숫자와 관련된 기능 도 있습니다. 그 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0447596598be1689749a73489423ead2b26c8b89" translate="yes" xml:space="preserve">
          <source>There are many functions in Elixir's standard library that return streams, some examples are:</source>
          <target state="translated">스트림을 반환하는 Elixir의 표준 라이브러리에는 많은 함수가 있습니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87db69fabab6d8aebc72fcaa67f0f5d2378adab2" translate="yes" xml:space="preserve">
          <source>There are many other helpers available, here are some examples:</source>
          <target state="translated">사용 가능한 다른 도우미가 많이 있습니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="926409681cd9a91dbce4de89116e3485c968a501" translate="yes" xml:space="preserve">
          <source>There are many situations where using the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module can be avoided in favor of binary functions or pattern matching. For example, imagine you have a string &lt;code&gt;prefix&lt;/code&gt; and you want to remove this prefix from another string named &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">이진 함수 나 패턴 일치 를 위해 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈 사용을 피할 수있는 상황이 많이 있습니다 . 예를 들어 문자열 &lt;code&gt;prefix&lt;/code&gt; 있고 &lt;code&gt;full&lt;/code&gt; 이라는 다른 문자열에서이 접두사를 제거 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d8989cd7033f2099b81956882184639864ede98b" translate="yes" xml:space="preserve">
          <source>There are no guarantees about the order of keys in the returned keyword.</source>
          <target state="translated">반환 된 키워드의 키 순서에 대한 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="54c0f70e4a42a4d0d67a77196f05623f3bcdb80e" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones.</source>
          <target state="translated">Elixir에는 다른 프로토콜이 있지만 가장 일반적인 프로토콜을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="acb7aab73db89a3f93bdbd205b772057e9bacc95" translate="yes" xml:space="preserve">
          <source>There are other protocols in Elixir but this covers the most common ones. You can learn more about protocols and implementations in the &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Elixir에는 다른 프로토콜이 있지만 가장 일반적인 프로토콜을 다룹니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; 모듈 에서 프로토콜 및 구현에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3101471cbaca1a87da38ada818ec10b102a0a294" translate="yes" xml:space="preserve">
          <source>There are other tuple formats both &lt;code&gt;handle_call/3&lt;/code&gt; and &lt;code&gt;handle_cast/2&lt;/code&gt; callbacks may return. There are also other callbacks like &lt;code&gt;terminate/2&lt;/code&gt; and &lt;code&gt;code_change/3&lt;/code&gt; that we could implement. You are welcome to explore the &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;full GenServer documentation&lt;/a&gt; to learn more about those.</source>
          <target state="translated">&lt;code&gt;handle_call/3&lt;/code&gt; 및 &lt;code&gt;handle_cast/2&lt;/code&gt; 콜백 모두 반환 될 수 있는 다른 튜플 형식이 있습니다. &lt;code&gt;terminate/2&lt;/code&gt; 및 &lt;code&gt;code_change/3&lt;/code&gt; 와 같은 다른 콜백도 구현할 수 있습니다. 당신은있는 탐구에 오신 것을 환영합니다 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;전체 GenServer 문서를&lt;/a&gt; 그에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="8c6bd7329e736075fbed60e12572ebdf4871cb55" translate="yes" xml:space="preserve">
          <source>There are probably many more to come too!</source>
          <target state="translated">아마도 더 많은 것들이있을 것입니다!</target>
        </trans-unit>
        <trans-unit id="eabb9c46f92e64d3211aa2057e1cb64ad70409b3" translate="yes" xml:space="preserve">
          <source>There are some modules that Elixir does not currently implement but it may be implement in the future. Those modules are reserved and defining them will result in a compilation error:</source>
          <target state="translated">Elixir가 현재 구현하지 않지만 향후 구현 될 수있는 일부 모듈이 있습니다. 해당 모듈은 예약되어 있으며이를 정의하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb77960230e6dd3139afa82409f2f1ffc3a5c2e5" translate="yes" xml:space="preserve">
          <source>There are some very well known problems with floating-point numbers and arithmetics due to the fact most decimal fractions cannot be represented by a floating-point binary and most operations are not exact, but operate on approximations. Those issues are not specific to Elixir, they are a property of floating point representation itself.</source>
          <target state="translated">대부분의 소수는 부동 소수점 이진수로 표현할 수없고 대부분의 연산이 정확하지는 않지만 근사치에서 작동한다는 사실로 인해 부동 소수점 숫자와 산술에 대해 잘 알려진 문제가 있습니다. 이러한 문제는 Elixir에만 국한된 것이 아니라 부동 소수점 표현 자체의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e3154b8cdccf8ec261d752f5f3690d9739db0824" translate="yes" xml:space="preserve">
          <source>There are three better alternatives to &lt;code&gt;Node.spawn_link/2&lt;/code&gt; that we could use in our implementation:</source>
          <target state="translated">구현에 사용할 수있는 &lt;code&gt;Node.spawn_link/2&lt;/code&gt; 에 대한 세 가지 더 나은 대안 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a011fd8fc19265bbdfa804b9e46482377afe2df" translate="yes" xml:space="preserve">
          <source>There are three callbacks that are invoked when functions are defined, as well as before and immediately after the module bytecode is generated.</source>
          <target state="translated">모듈 바이트 코드가 생성되기 직전과 직후뿐만 아니라 함수가 정의 될 때 호출되는 3 개의 콜백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cff0a96056604973d2ce970f4952a288926525" translate="yes" xml:space="preserve">
          <source>There are three main use cases for not replying using the return value:</source>
          <target state="translated">반환 값을 사용하여 응답하지 않는 세 가지 주요 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="adbd396ed0556c8293f2a87ae93d14c10746024c" translate="yes" xml:space="preserve">
          <source>There are two APIs for working with ports. It can be either asynchronous via message passing, as in the example above, or by calling the functions on this module.</source>
          <target state="translated">포트 작업을위한 두 가지 API가 있습니다. 위의 예와 같이 메시지 전달을 통해 또는이 모듈에서 함수를 호출하여 비동기식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701240237d3a52a3d32e044be779f88e8b80021f" translate="yes" xml:space="preserve">
          <source>There are two common pitfalls when using the pipe operator.</source>
          <target state="translated">파이프 연산자를 사용할 때 두 가지 일반적인 함정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="406dbf0d435a200ca4cabd1441349a8cdaeded38" translate="yes" xml:space="preserve">
          <source>There are two concerns in this approach.</source>
          <target state="translated">이 접근법에는 두 가지 우려가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cac6c30b6750da044a369458652387600eab8a0" translate="yes" xml:space="preserve">
          <source>There are two data types without an accompanying module:</source>
          <target state="translated">모듈이없는 두 가지 데이터 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b081e88ef54c7ae6048998f8dea958b729c0be39" translate="yes" xml:space="preserve">
          <source>There are two important things to consider when using &lt;code&gt;async&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 사용할 때 고려해야 할 두 가지 중요한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a03d1dfcb5538f40d22abd10d512a80d2c451bc1" translate="yes" xml:space="preserve">
          <source>There are two topics left before we move on to the next chapter.</source>
          <target state="translated">다음 장으로 넘어 가기 전에 두 가지 주제가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6bcf7cf68be2f9527622d710936107d32e56ffb" translate="yes" xml:space="preserve">
          <source>There are two types of captured functions: &lt;strong&gt;external&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. External functions are functions residing in modules that are captured with &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt;, such as &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt;. Local functions are anonymous functions defined with &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt;&lt;code&gt;fn/1&lt;/code&gt;&lt;/a&gt; or with the capture operator &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt;&lt;code&gt;&amp;amp;/1&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;&amp;amp;1&lt;/code&gt;, &lt;code&gt;&amp;amp;2&lt;/code&gt;, and so on as replacements.</source>
          <target state="translated">캡처 된 기능에는 &lt;strong&gt;external&lt;/strong&gt; 및 &lt;strong&gt;local&lt;/strong&gt; 의 두 가지 유형이 있습니다 . 외부 함수는 &lt;code&gt;&amp;amp;String.length/1&lt;/code&gt; 과 같이 &amp;amp; &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; &lt;/a&gt; 로 캡처 된 모듈에 상주하는 함수 입니다. 로컬 함수는 &lt;a href=&quot;kernel.specialforms#fn/1&quot;&gt; &lt;code&gt;fn/1&lt;/code&gt; &lt;/a&gt; 또는 대체 연산자로 &lt;code&gt;&amp;amp;1&lt;/code&gt; , &lt;code&gt;&amp;amp;2&lt;/code&gt; 등을 사용 하는 캡처 연산자 &lt;a href=&quot;kernel.specialforms#&amp;amp;/1&quot;&gt; &lt;code&gt;&amp;amp;/1&lt;/code&gt; 로&lt;/a&gt; 정의 된 익명 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="71487477c04c1e20b0a1c8eb6cde1dc3cb98c687" translate="yes" xml:space="preserve">
          <source>There are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server &lt;strong&gt;must&lt;/strong&gt; send a response back to such requests. While the server computes the response, the client is &lt;strong&gt;waiting&lt;/strong&gt;. Casts are asynchronous: the server won&amp;rsquo;t send a response back and therefore the client won&amp;rsquo;t wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the &lt;code&gt;:create&lt;/code&gt; messages, to be handled as cast, and on the &lt;code&gt;:lookup&lt;/code&gt; messages, to be handled as call.</source>
          <target state="translated">GenServer에 보낼 수있는 요청에는 전화와 캐스트의 두 가지 유형이 있습니다. 호출은 동 기적이며 서버 &lt;strong&gt;는&lt;/strong&gt; 이러한 요청에 대한 응답을 다시 보내야합니다. 서버가 응답을 계산하는 동안 클라이언트는 &lt;strong&gt;대기 중&lt;/strong&gt; 입니다. 캐스트는 비동기 적입니다. 서버는 응답을 다시 보내지 않으므로 클라이언트는 응답을 기다리지 않습니다. 두 요청은 모두 서버로 전송되는 메시지이며 순서대로 처리됩니다. 위의 구현에서 &lt;code&gt;:create&lt;/code&gt; cast로 처리 할 : create 메시지 와 호출로 처리 할 &lt;code&gt;:lookup&lt;/code&gt; 메시지에서 패턴 일치를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="99e8c78e4095307ef4673f7069817242c3a373e9" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt; expressions in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. The following code:</source>
          <target state="translated">가드에서 &lt;code&gt;or&lt;/code&gt; 표현식 체인을 단순화하는 추가 방법이 있습니다 . Elixir는 동일한 절에서 &quot;다중 가드&quot;작성을 지원합니다. 다음 코드 :</target>
        </trans-unit>
        <trans-unit id="3c9ea73ebc91f0affdf337778b29e743e68daec7" translate="yes" xml:space="preserve">
          <source>There exists an additional way to simplify a chain of &lt;code&gt;or&lt;/code&gt;s in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. This:</source>
          <target state="translated">가드 체인 &lt;code&gt;or&lt;/code&gt; 가드 를 단순화하는 추가 방법이 있습니다 . Elixir는 동일한 절에서 &quot;다중 가드&quot;작성을 지원합니다. 이:</target>
        </trans-unit>
        <trans-unit id="36182dc39abbf8ba08b014521f410bb7023fa49b" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, that is rarely changed. It is set automatically based on the value in &lt;code&gt;:start&lt;/code&gt;.</source>
          <target state="translated">거의 변경되지 않는 여섯 번째 키인 &lt;code&gt;:modules&lt;/code&gt; 가 있습니다. &lt;code&gt;:start&lt;/code&gt; 의 값에 따라 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3abc172d49d7232eeddc547e457e9a9da963ba98" translate="yes" xml:space="preserve">
          <source>There is a sixth key, &lt;code&gt;:modules&lt;/code&gt;, which is optional and is rarely changed. It is set automatically based on the &lt;code&gt;:start&lt;/code&gt; value.</source>
          <target state="translated">선택 사항이며 거의 변경되지 않는 여섯 번째 키 &lt;code&gt;:modules&lt;/code&gt; 가 있습니다. &lt;code&gt;:start&lt;/code&gt; 값 에 따라 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cacb5192e79338de26b6ff207a8ab99cd8a36150" translate="yes" xml:space="preserve">
          <source>There is also a deprecated strategy called &lt;code&gt;:simple_one_for_one&lt;/code&gt; which has been replaced by the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;:simple_one_for_one&lt;/code&gt; supervisor was similar to &lt;code&gt;:one_for_one&lt;/code&gt; but suits better when dynamically attaching children. Many functions in this module behaved slightly differently when this strategy was used. See the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module for more information and migration strategies.</source>
          <target state="translated">또한 &lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 로 대체 된 더 이상 사용되지 않는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 전략이 있습니다 . &lt;code&gt;:simple_one_for_one&lt;/code&gt; 의 관리자는 유사했다 &lt;code&gt;:one_for_one&lt;/code&gt; 하지만 정장 더 동적으로 아이들을 부착 할 때. 이 전략을 사용할 때이 모듈의 많은 기능이 약간 다르게 작동합니다. 자세한 정보 및 마이그레이션 전략 은 &lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="21605b424eea559d8c71a63a6ba5de9f7a6c7351" translate="yes" xml:space="preserve">
          <source>There is also a private function named &lt;code&gt;deps&lt;/code&gt;, which is invoked from the &lt;code&gt;project&lt;/code&gt; function, that defines our project dependencies. Defining &lt;code&gt;deps&lt;/code&gt; as a separate function is not required, but it helps keep the project configuration tidy.</source>
          <target state="translated">프로젝트 의존성을 정의 하는 &lt;code&gt;project&lt;/code&gt; 함수 에서 호출되는 &lt;code&gt;deps&lt;/code&gt; 라는 개인 함수도 있습니다 . &lt;code&gt;deps&lt;/code&gt; 를 별도의 기능으로 정의 할 필요는 없지만 프로젝트 구성을 깔끔하게 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb7b6e86fbf7b732fa4c4c68a1745621601d30ca" translate="yes" xml:space="preserve">
          <source>There is more to learn about &lt;code&gt;put_in/2&lt;/code&gt; and &lt;code&gt;update_in/2&lt;/code&gt;, including the &lt;code&gt;get_and_update_in/2&lt;/code&gt; that allows us to extract a value and update the data structure at once. There are also &lt;code&gt;put_in/3&lt;/code&gt;, &lt;code&gt;update_in/3&lt;/code&gt; and &lt;code&gt;get_and_update_in/3&lt;/code&gt; which allow dynamic access into the data structure. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;Check their respective documentation in the &lt;code&gt;Kernel&lt;/code&gt; module for more information&lt;/a&gt;.</source>
          <target state="translated">값을 추출하고 한 번에 데이터 구조를 업데이트 할 수 있는 &lt;code&gt;get_and_update_in/2&lt;/code&gt; 를 포함하여 &lt;code&gt;put_in/2&lt;/code&gt; 및 &lt;code&gt;update_in/2&lt;/code&gt; 에 대해 더 배울 것이 있습니다. 도있다 &lt;code&gt;put_in/3&lt;/code&gt; , &lt;code&gt;update_in/3&lt;/code&gt; 및 &lt;code&gt;get_and_update_in/3&lt;/code&gt; 데이터 구조로 동적 접근을 허용한다. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;자세한 내용 &lt;/a&gt;은 &lt;code&gt;Kernel&lt;/code&gt; 모듈 에서 해당 설명서를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b4424ea8037c81012b4a89fa0c4119c6711e1c4" translate="yes" xml:space="preserve">
          <source>There is much more to Mix, and we will continue to explore it as we build our project. A &lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;general overview is available on the Mix documentation&lt;/a&gt;. Read &lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;the Mix source code here&lt;/a&gt;.</source>
          <target state="translated">Mix에는 더 많은 것이 있으며, 프로젝트를 빌드 할 때 계속 탐색 할 것입니다. &lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;일반적인 개요는 믹스 문서를 볼 수 있습니다&lt;/a&gt; . &lt;a href=&quot;https://github.com/elixir-lang/elixir/tree/master/lib/mix&quot;&gt;여기에서 믹스 소스 코드를&lt;/a&gt; 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="237778ff123bf6054865096a64c61845e79b8f82" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;try/rescue&lt;/code&gt; here. In case you want to handle multiple outcomes of opening a file, you can use pattern matching within the &lt;code&gt;case&lt;/code&gt; construct:</source>
          <target state="translated">여기에는 &lt;code&gt;try/rescue&lt;/code&gt; 가 없습니다 . 파일을 여는 여러 결과를 처리하려는 &lt;code&gt;case&lt;/code&gt; 구문 내에서 패턴 일치를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0bc74ac50000eb990e97f6493bd512424cfda40" translate="yes" xml:space="preserve">
          <source>There is one important difference between the &lt;code&gt;setup&lt;/code&gt; block we wrote for &lt;code&gt;KV.Registry&lt;/code&gt; and the one we wrote for &lt;code&gt;KV.Bucket&lt;/code&gt;. Instead of starting the registry by hand by calling &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt;, we instead called &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;the &lt;code&gt;start_supervised!/2&lt;/code&gt; function&lt;/a&gt;, passing the &lt;code&gt;KV.Registry&lt;/code&gt; module.</source>
          <target state="translated">사이 한 가지 중요한 차이가 &lt;code&gt;setup&lt;/code&gt; 우리가 쓴 블록 &lt;code&gt;KV.Registry&lt;/code&gt; 우리가 쓴 한 &lt;code&gt;KV.Bucket&lt;/code&gt; 은 . 대신 호출하여 손으로 레지스트리를 시작하는 &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; , 우리는 대신 호출 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised!/2&lt;/code&gt; &lt;/a&gt; 기능을 통과, &lt;code&gt;KV.Registry&lt;/code&gt; 의 모듈을.</target>
        </trans-unit>
        <trans-unit id="02df8421114d1f579a4430e4f56430c17c3fdd06" translate="yes" xml:space="preserve">
          <source>There is one project-level option that affects how the escript is generated:</source>
          <target state="translated">escript 생성 방법에 영향을주는 하나의 프로젝트 레벨 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="690ca402cdab5a8902f2e2787a305dd6116dc3d0" translate="yes" xml:space="preserve">
          <source>There is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.</source>
          <target state="translated">GenServer 코드에는 약간의식이 있지만 앞으로 살펴 보 겠지만 몇 가지 이점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cfa9d95846d7cc788a552bbc32762f5176596e" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">많은 Mix 작업이이 구성에서 읽은 자체 옵션을 정의하기 때문에 &lt;code&gt;project/0&lt;/code&gt; 에서 반환 할 수있는 모든 옵션의 포괄적 인 목록이 없습니다 . 예를 들어 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt; 작업 에 대한 설명서의 &quot;구성&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="868c9d3de02a9c397e5804f3e5b1beeb25227226" translate="yes" xml:space="preserve">
          <source>There isn't a comprehensive list of all the options that can be returned by &lt;code&gt;project/0&lt;/code&gt; since many Mix tasks define their own options that they read from this configuration. For example, look at the &quot;Configuration&quot; section in the documentation for the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task.</source>
          <target state="translated">많은 믹스 작업이이 구성에서 읽은 자체 옵션을 정의하므로 &lt;code&gt;project/0&lt;/code&gt; 에서 반환 할 수있는 모든 옵션의 전체 목록이 없습니다 . 예를 들어 &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;Mix.Tasks.Compile&lt;/code&gt; &lt;/a&gt; 작업 에 대한 설명서의 &quot;구성&quot;섹션을 보십시오 .</target>
        </trans-unit>
        <trans-unit id="06cb32d59125a8444c6ab67709a472cedf77eb2d" translate="yes" xml:space="preserve">
          <source>There, &lt;code&gt;byte_size/1&lt;/code&gt; counts the underlying raw bytes, and &lt;code&gt;String.length/1&lt;/code&gt; counts characters.</source>
          <target state="translated">여기에서 &lt;code&gt;byte_size/1&lt;/code&gt; 은 기본 원시 바이트를 계산 하고 &lt;code&gt;String.length/1&lt;/code&gt; 은 문자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4307601f224307e22cd02454aa0b8b4d5545438a" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (e.g. &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;file#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">따라서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 종료 될 때 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 가 호출되는 것은 보장되지 않습니다 . 따라서 모니터링을 사용하거나 링크 자체를 통해 분리 된 프로세스에서 중요한 정리 규칙을 수행하는 것이 좋습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;port&lt;/code&gt; (예 &lt;code&gt;:gen_tcp.socket&lt;/code&gt; ) 또는 &lt;a href=&quot;file#t:io_device/0&quot;&gt; &lt;code&gt;File.io_device/0&lt;/code&gt; 을&lt;/a&gt; 제어 할 때 정리가 필요하지 않습니다 . GenServer 의 종료 신호 를 수신하면 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 에서 수동으로 닫을 필요가 없기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="7f067dca9ef5e27637d0921507ba04af5a01c66e" translate="yes" xml:space="preserve">
          <source>Therefore it is not guaranteed that &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called when a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; exits. For such reasons, we usually recommend important clean-up rules to happen in separated processes either by use of monitoring or by links themselves. There is no cleanup needed when the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; controls a &lt;code&gt;port&lt;/code&gt; (for example, &lt;code&gt;:gen_tcp.socket&lt;/code&gt;) or &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#t:io_device/0&quot;&gt;&lt;code&gt;File.io_device/0&lt;/code&gt;&lt;/a&gt;, because these will be closed on receiving a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s exit signal and do not need to be closed manually in &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">따라서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 종료 될 때 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 가 호출 된다는 보장은 없습니다 . 이러한 이유로 일반적으로 모니터링 또는 링크 자체를 사용하여 분리 된 프로세스에서 발생하는 중요한 정리 규칙을 권장합니다. 더 필요한 정리가 없습니다 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 이&lt;/a&gt; 제어 &lt;code&gt;port&lt;/code&gt; (예 &lt;code&gt;:gen_tcp.socket&lt;/code&gt; 또는) &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#t:io_device/0&quot;&gt; &lt;code&gt;File.io_device/0&lt;/code&gt; 는&lt;/a&gt; 이러한 수신에 폐쇄되기 때문에, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 종료 신호를과에서 수동으로 폐쇄 할 필요가 없습니다 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4064ff8458c4f5d1958ee9109a3740ff3b2b0e6" translate="yes" xml:space="preserve">
          <source>Therefore, an Elixir developer prefers to &amp;ldquo;let it crash&amp;rdquo; or &amp;ldquo;fail fast&amp;rdquo;. And one of the most common ways we can recover from a failure is by restarting whatever part of the system crashed.</source>
          <target state="translated">따라서 Elixir 개발자는 &quot;충돌&quot;또는 &quot;실패&quot;를 선호합니다. 또한 장애로부터 복구 할 수있는 가장 일반적인 방법 중 하나는 시스템의 충돌 부분을 다시 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="67da13e4777f268949639e3941225f274f61e540" translate="yes" xml:space="preserve">
          <source>Therefore, if you don&amp;rsquo;t want to handle the error outcomes, prefer using &lt;code&gt;File.read!/1&lt;/code&gt;.</source>
          <target state="translated">따라서 오류 결과를 처리하지 않으려면 &lt;code&gt;File.read!/1&lt;/code&gt; 사용을 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="88ef416d8b169a4f47a3dda56e98187b8d57d742" translate="yes" xml:space="preserve">
          <source>Therefore, if you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">따라서 여러 문자열을 한 번에 여러 번 비교하려는 경우 사전에 정규화하고 직접 비교하여 여러 정규화 패스를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb2ec194ba3355670294e9c457ea3adb567e875" translate="yes" xml:space="preserve">
          <source>Therefore, in order to minimize the distributed tests, let&amp;rsquo;s pick a routing table that does not require distribution. Then, for the distributed tests, we will programatically change the routing table. Back in &lt;code&gt;config/config.exs&lt;/code&gt;, add this line:</source>
          <target state="translated">따라서 분산 테스트를 최소화하기 위해 분산이 필요없는 라우팅 테이블을 선택하겠습니다. 그런 다음 분산 테스트를 위해 프로그래밍 방식으로 라우팅 테이블을 변경합니다. &lt;code&gt;config/config.exs&lt;/code&gt; 로 돌아가서 다음 줄을 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="5587ebee880284a6f70ef3328784590a49e488e5" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="translated">따라서이 함수는 모듈을 사용하기 전에로드되었는지 확인하고 그에 따라 대응할 수 있도록합니다. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/elixir/URI.html&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 모듈은이 함수를 사용하여 주어진 URI 체계에 대해 특정 파서가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af72f8d5888562059c52cc4bad66a2a3aa2e8b0b" translate="yes" xml:space="preserve">
          <source>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module uses this function to check if a specific parser exists for a given URI scheme.</source>
          <target state="translated">따라서이 기능은 모듈을 사용하기 전에 모듈이로드되었는지 확인하고 그에 따라 반응하도록합니다. 예를 들어, &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 모듈은이 함수를 사용하여 특정 URI 스키마에 대해 특정 구문 분석기가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="de86214129da9f1e44a45df425ff060e9ce48710" translate="yes" xml:space="preserve">
          <source>Therefore, using a combination of &lt;code&gt;--sink&lt;/code&gt; with &lt;code&gt;--label&lt;/code&gt; is useful to find all files that will change once the sink changes, alongside the transitive dependencies that will cause said recompilations.</source>
          <target state="translated">따라서 &lt;code&gt;--sink&lt;/code&gt; 와 &lt;code&gt;--label&lt;/code&gt; 의 조합을 사용 하면 싱크가 변경되면 변경 될 모든 파일과 해당 재 컴파일을 유발하는 전 이적 종속성을 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f4b754bf2a64e107bf9d3b99490d4c968dbf741e" translate="yes" xml:space="preserve">
          <source>Therefore, when pattern matching on strings, it is important to use the &lt;code&gt;utf8&lt;/code&gt; modifier:</source>
          <target state="translated">따라서 문자열에 대한 패턴 일치시 &lt;code&gt;utf8&lt;/code&gt; 수정자를 사용하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="d10b167c94497dff77b11dad17668b97ba38a48a" translate="yes" xml:space="preserve">
          <source>These are a few options that are not used by just one Mix task (and will thus be documented here):</source>
          <target state="translated">다음은 하나의 믹스 작업에서 사용되지 않는 몇 가지 옵션입니다 (따라서 여기에 문서화 됨).</target>
        </trans-unit>
        <trans-unit id="41d198d3d66dfd7fa75bf909de01737698c3fc91" translate="yes" xml:space="preserve">
          <source>These are the reserved words in the Elixir language. They are detailed throughout this guide but summed up here for convenience:</source>
          <target state="translated">이들은 엘릭서 언어로 예약 된 단어입니다. 이 가이드 전체에 자세히 설명되어 있지만 편의상 여기에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ad74fbcf6aea4c5436fcd89c622233b6bfb3f0" translate="yes" xml:space="preserve">
          <source>These building blocks are defined in this module. Some of these special forms are lexical (such as &lt;a href=&quot;#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#case/2&quot;&gt;&lt;code&gt;case/2&lt;/code&gt;&lt;/a&gt;). The macros &lt;a href=&quot;#%7B%7D/1&quot;&gt;&lt;code&gt;{}/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; are also special forms used to define tuple and binary data structures respectively.</source>
          <target state="translated">이러한 빌딩 블록은이 모듈에서 정의됩니다. 이러한 특수 형식 중 일부는 어휘입니다 (예 : &lt;a href=&quot;#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#case/2&quot;&gt; &lt;code&gt;case/2&lt;/code&gt; &lt;/a&gt; ). 매크로 &lt;a href=&quot;#%7B%7D/1&quot;&gt; &lt;code&gt;{}/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; 은 각각 튜플 및 이진 데이터 구조를 정의하는 데 사용되는 특수 형식입니다.</target>
        </trans-unit>
        <trans-unit id="26cd6bcff6d81ebade774a0f501e5b9a49a3141c" translate="yes" xml:space="preserve">
          <source>These can be used anywhere you want to refer to a characters codepoint.</source>
          <target state="translated">문자 코드 포인트를 참조하려는 모든 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01193dcf91e904667491de473d13c72e0b284bc" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned that the following syntax is supported:</source>
          <target state="translated">이러한 특성으로 인해 키워드 목록이 Elixir의 함수에 옵션을 전달하는 기본 메커니즘이되었습니다. 5 장에서 &lt;code&gt;if/2&lt;/code&gt; 매크로에 대해 논의 할 때 다음 구문이 지원된다고 언급했습니다.</target>
        </trans-unit>
        <trans-unit id="a33f02a3cf972439fc9644228266bf6ac583f283" translate="yes" xml:space="preserve">
          <source>These characteristics are what prompted keyword lists to be the default mechanism for passing options to functions in Elixir. In chapter 5, when we discussed the &lt;code&gt;if/2&lt;/code&gt; macro, we mentioned the following syntax is supported:</source>
          <target state="translated">이러한 특징은 키워드 목록이 Elixir의 함수에 옵션을 전달하기위한 기본 메커니즘이되게했던 것입니다. 5 장에서 &lt;code&gt;if/2&lt;/code&gt; 매크로를 논의 할 때 다음 구문이 지원된다고 언급했습니다.</target>
        </trans-unit>
        <trans-unit id="8fea9325510bd25065ba64a7fe2de349a02f06d3" translate="yes" xml:space="preserve">
          <source>These configurations can be set in the &lt;code&gt;def project&lt;/code&gt; section of your &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">이러한 구성은 &lt;code&gt;mix.exs&lt;/code&gt; 의 &lt;code&gt;def project&lt;/code&gt; 섹션 에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76567fa6ed57b5e28a73659cbd673c9a7f350853" translate="yes" xml:space="preserve">
          <source>These functions and macros follow the Erlang convention of an &lt;code&gt;is_&lt;/code&gt; prefix, instead of a trailing question mark, precisely to indicate that they are allowed in guard clauses.</source>
          <target state="translated">이러한 함수와 매크로 는 후행 물음표 대신 &lt;code&gt;is_&lt;/code&gt; 접두사 의 Erlang 규칙을 따라 가드 절에서 허용됨을 정확하게 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="add5b2dbfbafe6da3d0a22b6f870b2eed75d677f" translate="yes" xml:space="preserve">
          <source>These options are expected to be literals (including the binary values) at compile time.</source>
          <target state="translated">이러한 옵션은 컴파일 타임에 리터럴 (2 진 값 포함)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ec1191cd2717326d5b2f8e25c4fb58ff593d194" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's Code Server.</source>
          <target state="translated">이 옵션들은 Elixir의 코드 서버에 의해 저장되기 때문에 전역 적입니다.</target>
        </trans-unit>
        <trans-unit id="626e3d5b2ff83140a65abc0074ea71a000293b27" translate="yes" xml:space="preserve">
          <source>These options are global since they are stored by Elixir's code server.</source>
          <target state="translated">이 옵션은 Elixir의 코드 서버에 저장되기 때문에 전역 적입니다.</target>
        </trans-unit>
        <trans-unit id="8aca497f05ede32d92fad7a0a08861307fed5d02" translate="yes" xml:space="preserve">
          <source>These paths are based on the &lt;code&gt;:apps_path&lt;/code&gt; and &lt;code&gt;:apps&lt;/code&gt; configurations.</source>
          <target state="translated">이러한 경로는 &lt;code&gt;:apps_path&lt;/code&gt; 및 &lt;code&gt;:apps&lt;/code&gt; 구성을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="90f90a0bd1abd66881352917a593420e21df4638" translate="yes" xml:space="preserve">
          <source>They also support &lt;code&gt;else&lt;/code&gt; blocks:</source>
          <target state="translated">또한 &lt;code&gt;else&lt;/code&gt; 블록을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="c272e830fb2eeca6af73d25f9dc7ec1a9ffc0efc" translate="yes" xml:space="preserve">
          <source>They are discussed individually in the sections below.</source>
          <target state="translated">아래 섹션에서 개별적으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d328fd2e41813b144fcdf9de5a1a99985a2c6ade" translate="yes" xml:space="preserve">
          <source>They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">다음과 같은 고유 한 값을 열거하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d984bcb0628847679167196f524ecb516b6c251c" translate="yes" xml:space="preserve">
          <source>They serve to annotate the module, often with information to be used by the user or the</source>
          <target state="translated">이들은 종종 사용자 또는 사용자가 사용할 정보로 모듈에 주석을다는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="97ca407460ebb22e0ec5bdeff0b3e028c669bf37" translate="yes" xml:space="preserve">
          <source>They work as a temporary module storage to be used during compilation.</source>
          <target state="translated">컴파일 중에 사용되는 임시 모듈 스토리지로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ee6dd5d64b66e821ff94c4d17d21b9f93db749f2" translate="yes" xml:space="preserve">
          <source>They work as constants.</source>
          <target state="translated">그들은 상수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e53339d9d0bc53c58fe8778d10ade8bb49736f46" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang Syntax: A Crash Course&lt;/a&gt; provides a concise intro to Erlang&amp;rsquo;s syntax. Each code snippet is accompanied by equivalent code in Elixir. This is an opportunity for you to not only get some exposure to Erlang&amp;rsquo;s syntax but also review some of the things you have learned in this guide.</source>
          <target state="translated">이 &lt;a href=&quot;https://elixir-lang.org/crash-course.html&quot;&gt;Erlang 구문 : Crash Course&lt;/a&gt; 는 Erlang 구문에 대한 간략한 소개를 제공합니다. 각 코드 스 니펫에는 Elixir의 동등한 코드가 함께 제공됩니다. 이것은 Erlang의 구문에 대한 노출뿐만 아니라이 안내서에서 배운 것들 중 일부를 검토 할 수있는 기회입니다.</target>
        </trans-unit>
        <trans-unit id="c3d65d16574f84519ba2e69aa0d37e68059885e5" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="translated">이 &lt;code&gt;fun&lt;/code&gt; 인수의 값 수신 &lt;code&gt;key&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 하면 &lt;code&gt;key&lt;/code&gt; 존재하지 않는)과, 2 요소 튜플을 반환해야합니다 : 값 (반환하기 전에에서 작동 할 수 검색된 값)와 새로운 값을 &quot;얻을&quot; &lt;code&gt;key&lt;/code&gt; 아래에 저장됩니다 . &lt;code&gt;fun&lt;/code&gt; 도 반환 할 수 있습니다 &lt;code&gt;:pop&lt;/code&gt; , 현재 값이 키워드 목록에서 제거하고 반환되어야 의미.</target>
        </trans-unit>
        <trans-unit id="7730fb9921d8f6aa0bc9c8111d351054831c02de" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, implying the current value shall be removed from the keyword list and returned.</source>
          <target state="translated">이 &lt;code&gt;fun&lt;/code&gt; 인수는 &lt;code&gt;key&lt;/code&gt; 의 값 (또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;nil&lt;/code&gt; )을 수신하고 두 요소 튜플을 반환해야합니다. 현재 값 (반환되기 전에 작동 할 수있는 검색된 값) 및 저장할 새 값 &lt;code&gt;key&lt;/code&gt; 아래 . &lt;code&gt;fun&lt;/code&gt; 도 반환 할 수 있습니다 &lt;code&gt;:pop&lt;/code&gt; , 현재 값이 키워드 목록에서 제거하고 반환되어야 의미.</target>
        </trans-unit>
        <trans-unit id="21531bdd28fd8a4fab193e8f907a1304804427e8" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;fun&lt;/code&gt; 인수는 &lt;code&gt;key&lt;/code&gt; 값을 수신하며 &quot;get&quot;값 (반환되기 전에 조작 할 수있는 검색된 값)과 &lt;code&gt;key&lt;/code&gt; 아래에 저장 될 새 값의 두 요소 튜플을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53bda49c2b15fa76b2cbd3fb19123910db00ced4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;fun&lt;/code&gt; argument receives the value of &lt;code&gt;key&lt;/code&gt; and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;fun&lt;/code&gt; 인수는 &lt;code&gt;key&lt;/code&gt; 값을 받고, 현재 값 (반환되기 전에 작동 할 수있는 검색된 값)과 &lt;code&gt;key&lt;/code&gt; 아래에 저장 될 새 값의 두 요소 튜플을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="106724662d1a48acf5e96ebf33c77969eed35e72" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="translated">이 조언은 라이브러리뿐만 아니라 Elixir 코드에도 적용됩니다. 여러 옵션을 받거나 외부 데이터로 작업 할 때마다 경계에서 데이터의 유효성을 검사하고 구조화 된 데이터로 변환해야합니다. 예를 들어, 여러 옵션으로 시작할 수 있는 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 제공하는 경우 서버가 시작될 때 해당 옵션의 유효성을 검사하고 프로세스 수명주기 동안 구조화 된 데이터에만 의존하려고합니다. 마찬가지로 데이터베이스 나 소켓에서 문자열 맵을 제공하는 경우 데이터를 수신 한 후 데이터를 검증하고 잠재적으로이를 구조체 나 원자 맵으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ca51ca3cb9bf6182cc66703ef3fbbdd192c7934" translate="yes" xml:space="preserve">
          <source>This advice does not only apply to libraries but to any Elixir code. Every time you receive multiple options or work with external data, you should validate the data at the boundary and convert it to structured data. For example, if you provide a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; that can be started with multiple options, you want to validate those options when the server starts and rely only on structured data throughout the process life cycle. Similarly, if a database or a socket gives you a map of strings, after you receive the data, you should validate it and potentially convert it to a struct or a map of atoms.</source>
          <target state="translated">이 조언은 라이브러리뿐만 아니라 모든 Elixir 코드에도 적용됩니다. 여러 옵션을 받거나 외부 데이터로 작업 할 때마다 경계에서 데이터의 유효성을 검사하고 구조화 된 데이터로 변환해야합니다. 예를 들어, 여러 옵션으로 시작할 수 있는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 제공하는 경우 서버가 시작될 때 해당 옵션의 유효성을 검사하고 프로세스 수명주기 동안 구조화 된 데이터에만 의존하려고합니다. 마찬가지로 데이터베이스 나 소켓이 문자열 맵을 제공하는 경우 데이터를받은 후 유효성을 검사하고 잠재적으로 구조체 또는 원자 맵으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="38b51c7863a18d9dea71afde173bd863c4339d77" translate="yes" xml:space="preserve">
          <source>This also works with nested structs and the &lt;code&gt;struct.path.to.value&lt;/code&gt; way to specify paths:</source>
          <target state="translated">이것은 또한 중첩 구조체 및 경로를 지정 하는 &lt;code&gt;struct.path.to.value&lt;/code&gt; 방법 과 함께 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="35f4524e9d598f3528101bd75ddd379bcc553a48" translate="yes" xml:space="preserve">
          <source>This approach has one big limitation: if you change the value of the application environment after the code is compiled, the value used at runtime is not going to change! For example, if your &lt;code&gt;config/runtime.exs&lt;/code&gt; has:</source>
          <target state="translated">이 접근 방식에는 한 가지 큰 제한이 있습니다. 코드가 컴파일 된 후 애플리케이션 환경의 값을 변경하면 런타임에 사용되는 값이 변경되지 않습니다! 예를 들어, &lt;code&gt;config/runtime.exs&lt;/code&gt; 에 다음 이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="0cc4748ce3f5882d3817d17380c6efaea1cbe2e2" translate="yes" xml:space="preserve">
          <source>This behaviour function checks out dependencies.</source>
          <target state="translated">이 동작 함수는 종속성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8063234c54496c74deb524505ab53e03e89b8cac" translate="yes" xml:space="preserve">
          <source>This behaviour function checks the status of the lock. In particular, it checks if the revision stored in the lock is the same as the repository it is currently in.</source>
          <target state="translated">이 동작 기능은 잠금 상태를 확인합니다. 특히 잠금에 저장된 개정이 현재있는 저장소와 동일한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d1a9f92cb4e97a9d75cd6dadc068bea5309a11a2" translate="yes" xml:space="preserve">
          <source>This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency</source>
          <target state="translated">This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency</target>
        </trans-unit>
        <trans-unit id="5b3cf369974ea57c7d2b5f2b67a09ff6bb9cb520" translate="yes" xml:space="preserve">
          <source>This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency:</source>
          <target state="translated">This behaviour function receives a keyword list of &lt;code&gt;opts&lt;/code&gt; and should return an updated list in case the SCM consumes the available options. For example, when a developer specifies a dependency:</target>
        </trans-unit>
        <trans-unit id="3e3e7ef108fbc0b5b099888c738ff953bc262988" translate="yes" xml:space="preserve">
          <source>This behaviour function returns a boolean if the dependency is available.</source>
          <target state="translated">This behaviour function returns a boolean if the dependency is available.</target>
        </trans-unit>
        <trans-unit id="0b4620b1a57c643e178ccb4b09127ceadcd467a0" translate="yes" xml:space="preserve">
          <source>This behaviour function updates dependencies. It may be called by &lt;code&gt;deps.get&lt;/code&gt; or &lt;code&gt;deps.update&lt;/code&gt;.</source>
          <target state="translated">This behaviour function updates dependencies. It may be called by &lt;code&gt;deps.get&lt;/code&gt; or &lt;code&gt;deps.update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86b0384c6fa0ab23e023705951a2e26ece47398" translate="yes" xml:space="preserve">
          <source>This behaviour is deprecated. Use Erlang/OTP's :gen_event module instead.</source>
          <target state="translated">이 동작은 더 이상 사용되지 않습니다. 대신 Erlang / OTP의 : gen_event 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72f035035b3d70bcbf1171738b7f8c7d508d05aa" translate="yes" xml:space="preserve">
          <source>This behaviour is relied on in many different places. For example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; uses &lt;code&gt;exit(:shutdown)&lt;/code&gt; when exiting the test process to signal linked processes, supervision trees and so on to politely shut down too.</source>
          <target state="translated">이 동작은 여러 곳에서 사용됩니다. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 은 테스트 프로세스를 종료 할 때 &lt;code&gt;exit(:shutdown)&lt;/code&gt; 사용 하여 연결된 프로세스, 감시 트리 등을 정중하게 종료하도록 신호합니다.</target>
        </trans-unit>
        <trans-unit id="c8eb2df7e5f6ba76a64892942e28c56d4c4a7f04" translate="yes" xml:space="preserve">
          <source>This break can be rendered as a linebreak or as the given &lt;code&gt;string&lt;/code&gt;, depending on the &lt;code&gt;mode&lt;/code&gt; of the chosen layout.</source>
          <target state="translated">이 레이아웃은 선택한 레이아웃 의 &lt;code&gt;mode&lt;/code&gt; 에 따라 줄 바꿈 또는 주어진 &lt;code&gt;string&lt;/code&gt; 로 렌더링 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab7ad5339c141f0de9e312dc2f25b5df3e7d8cb4" translate="yes" xml:space="preserve">
          <source>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt;, the macro will receive the AST representing the &lt;code&gt;self()&lt;/code&gt; call, and not the PID itself.</source>
          <target state="translated">매크로가 PID를 수신하지 않기 때문에이 중단 점에 도달하지 않습니다. 매크로를 &lt;code&gt;MyModule.some_macro(self())&lt;/code&gt; 로 호출하더라도 매크로 자체는 PID 자체가 아니라 &lt;code&gt;self()&lt;/code&gt; 호출을 나타내는 AST를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="8761ea35931ac08c3f3679fbf6f993fa3ef09746" translate="yes" xml:space="preserve">
          <source>This calendar implements the proleptic Gregorian calendar and is therefore compatible with the calendar used in most countries today. The proleptic means the Gregorian rules for leap years are applied for all time, consequently the dates give different results before the year 1583 from when the Gregorian calendar was adopted.</source>
          <target state="translated">이 달력은 다발성 Gregorian 달력을 구현하므로 오늘날 대부분의 국가에서 사용되는 달력과 호환됩니다. 도발은 윤년에 대한 그레고리오 규칙이 모든 시간에 적용됨을 의미하므로 결과는 1583 년 이전에 그레고리오 력이 채택 된 날짜와 다른 결과를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7991ee0aa425c7d3f3afff7118c6225869810d3f" translate="yes" xml:space="preserve">
          <source>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</source>
          <target state="translated">이 호출은 중단 점을 한 번 설정합니다. 10 회 중지되는 중단 점을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b325289ad4384d9c3ff3e14f0e004ec0fadc1690" translate="yes" xml:space="preserve">
          <source>This callback can be useful to control the &lt;em&gt;appearance&lt;/em&gt; of the status of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. For example, it can be used to return a compact representation of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;'s state to avoid having large state terms printed.</source>
          <target state="translated">이 콜백은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 상태의 &lt;em&gt;모양&lt;/em&gt; 을 제어하는 ​​데 유용 할 수 있습니다 . 예를 들어, 큰 상태 용어가 인쇄되지 않도록 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 상태 의 간단한 표현을 반환하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1327f9cbc59e218b07255d5dfd814547d5d8807b" translate="yes" xml:space="preserve">
          <source>This callback is only supported on Erlang/OTP 21+.</source>
          <target state="translated">이 콜백은 Erlang / OTP 21+에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5f243ca65efd502d5c4c6af5c8cd9dfd5d476c" translate="yes" xml:space="preserve">
          <source>This callback is optional.</source>
          <target state="translated">이 콜백은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f2424dc84d136b7783611865075888a14d9c990b" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the received message will be logged.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 하나를 구현하지 않으면 수신 된 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="985bade6a0d966231f4d34d8934365d5ebe8193e" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a call is performed against it.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 구현되지 않은 경우 서버에 대한 호출이 수행되면 서버가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f84f9f7a0fb58e5af47a01d8f797b8c62ea95537" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 하나를 구현하지 않으면 서버에서 캐스트를 수행하면 서버가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a8f931c4cb12fef7b434a37af006aef2ba0d46a" translate="yes" xml:space="preserve">
          <source>This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.</source>
          <target state="translated">이 콜백은 선택 사항입니다. 하나를 구현하지 않으면 계속 명령을 사용하면 서버가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ddfd8ff82f8cdfbfeb3d06aa0134b83f46048ef4" translate="yes" xml:space="preserve">
          <source>This can be added to any custom engine by invoking &lt;a href=&quot;#handle_assign/1&quot;&gt;&lt;code&gt;handle_assign/1&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; 로&lt;/a&gt;&lt;a href=&quot;#handle_assign/1&quot;&gt; &lt;code&gt;handle_assign/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 모든 사용자 정의 엔진에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a48050cb80bb5c2bc634b01accf3b4f5bd8c332" translate="yes" xml:space="preserve">
          <source>This chapter is a quick introduction to input/output mechanisms and file-system-related tasks, as well as to related modules like &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 장은 입출력 메커니즘 및 파일 시스템 관련 작업과 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 와 같은 관련 모듈에 대한 빠른 소개 입니다.</target>
        </trans-unit>
        <trans-unit id="3b602041d24e676175f7fd300fe9987bf2555172" translate="yes" xml:space="preserve">
          <source>This chapter is part of the</source>
          <target state="translated">이 장은</target>
        </trans-unit>
        <trans-unit id="d39494a06027e3ecee2968740895a5b78940cdae" translate="yes" xml:space="preserve">
          <source>This checks the version stored in the regular expression and recompiles the regex in case of version mismatch.</source>
          <target state="translated">정규식에 저장된 버전을 확인하고 버전이 일치하지 않는 경우 정규식을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9ba63be17004fe209fc861513a8577afc4eb4889" translate="yes" xml:space="preserve">
          <source>This code counts the number of files in a ZIP file:</source>
          <target state="translated">이 코드는 ZIP 파일의 파일 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b9d6dcf55f45221cfb511f9790e81d0872563106" translate="yes" xml:space="preserve">
          <source>This code generates a warning letting you know that you are mistakenly implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;. You can read more about &lt;code&gt;@impl&lt;/code&gt; in the &lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;module documentation&lt;/a&gt;.</source>
          <target state="translated">이 코드 는 &lt;code&gt;parse/1&lt;/code&gt; 대신 &lt;code&gt;parse/0&lt;/code&gt; 을 실수로 구현하고 있음을 알리는 경고를 생성합니다 . &lt;code&gt;@impl&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/master/Module.html#module-impl&quot;&gt;모듈 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7461ed387e3c81526760cfc0eb288d63eeb1988f" translate="yes" xml:space="preserve">
          <source>This command deletes all build artifacts for the current project. Dependencies' sources and build files are cleaned only if the &lt;code&gt;--deps&lt;/code&gt; option is given.</source>
          <target state="translated">이 명령은 현재 프로젝트의 모든 빌드 아티팩트를 삭제합니다. 종속성 소스 및 빌드 파일은 &lt;code&gt;--deps&lt;/code&gt; 옵션이 제공된 경우에만 정리됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e27e95f38d4b57c9fdf5d7529c98e07460e6cfe" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="translated">This command only works inside a pry session started manually via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; or a breakpoint set via &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt; session will print an error.</target>
        </trans-unit>
        <trans-unit id="f03f46afb53748c93f12e42d7a94c9567ade9ff8" translate="yes" xml:space="preserve">
          <source>This command only works inside a pry session started manually via &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or a breakpoint set via &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. Calling this function during a regular &lt;a href=&quot;iex&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; session will print an error.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; 을&lt;/a&gt; 통해 수동으로 시작된 Pry 세션 또는 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 통해 설정된 중단 점 에서만 작동합니다 . 일반 &lt;a href=&quot;iex&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt; 세션 중에이 기능을 호출 하면 오류가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="9a69791b2bccfac2d2c8e3aaab714d3c02736c70" translate="yes" xml:space="preserve">
          <source>This concludes our introduction to associative data structures in Elixir. You will find out that, given keyword lists and maps, you will always have the right tool to tackle problems that require associative data structures in Elixir.</source>
          <target state="translated">이것으로 Elixir의 연관 데이터 구조에 대한 소개를 마칩니다. 키워드 목록과 맵이 주어지면 Elixir의 연관 데이터 구조가 필요한 문제를 해결할 수있는 올바른 도구가 항상 있다는 것을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="16f934bff72f27aaf7d700d67cebd5f253fc677d" translate="yes" xml:space="preserve">
          <source>This concludes our optimization chapter. We have used ETS as a cache mechanism where reads can happen from any processes but writes are still serialized through a single process. More importantly, we have also learned that once data can be read asynchronously, we need to be aware of the race conditions it might introduce.</source>
          <target state="translated">이것으로 최적화 장을 마칩니다. ETS는 모든 프로세스에서 읽기가 가능하지만 쓰기는 단일 프로세스를 통해 직렬화되는 캐시 메커니즘으로 사용되었습니다. 더 중요한 것은, 일단 데이터를 비동기 적으로 읽을 수있게되면 데이터가 도입 될 수있는 경쟁 조건을 알아야한다는 사실도 알게되었습니다.</target>
        </trans-unit>
        <trans-unit id="5688f14ee7763837295cf0cfb6c3645fbb0e591b" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="translated">This configuration can be read using &lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;config/0&lt;/code&gt; &lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</target>
        </trans-unit>
        <trans-unit id="e537b568fbfe0eb80dc56346fdc7829c98d99600" translate="yes" xml:space="preserve">
          <source>This configuration can be read using &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#config/0&quot;&gt;&lt;code&gt;config/0&lt;/code&gt;&lt;/a&gt; won't fail if a project is not defined; this allows many Mix tasks to work without a project.</source>
          <target state="translated">이 구성은 &lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; 을&lt;/a&gt; 사용하여 읽을 수 있습니다 . 참고 &lt;a href=&quot;#config/0&quot;&gt; &lt;code&gt;config/0&lt;/code&gt; &lt;/a&gt; 프로젝트가 정의되지 않은 경우 실패하지 않을 것이다; 이를 통해 프로젝트없이 많은 믹스 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e1f3335434ce7c6c1db9f585fc250ca17087fe" translate="yes" xml:space="preserve">
          <source>This configuration is split in three categories:</source>
          <target state="translated">이 구성은 세 가지 범주로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="50abf55bb08a41598a90aba43d936a7f680d70a0" translate="yes" xml:space="preserve">
          <source>This configures a routing table that always points to the current node. Now remove &lt;code&gt;@tag :distributed&lt;/code&gt; from the test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; and run the suite, the test should now pass.</source>
          <target state="translated">항상 현재 노드를 가리키는 라우팅 테이블을 구성합니다. 이제 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 의 테스트에서 @tag &lt;code&gt;@tag :distributed&lt;/code&gt; 를 제거 하고 스위트를 실행하면 테스트가 통과합니다.</target>
        </trans-unit>
        <trans-unit id="300ecf84b2025cc5045f1e2f3e97de582fbc3fe7" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by checking equality instead, like &lt;code&gt;val == %{}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt; 같은 유형 검사를 통해 또는 &lt;code&gt;val == %{}&lt;/code&gt; 와 같이 동등성을 검사 하여 예외가 발생하지 않도록하여이를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d60706226e387d43664cfb1abdf069dc132f410b" translate="yes" xml:space="preserve">
          <source>This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt;, or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">This could be corrected by ensuring that no exception is raised, either via type checks like &lt;code&gt;is_map(val) and map_size(val) == 0&lt;/code&gt; , or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</target>
        </trans-unit>
        <trans-unit id="9c9bc7bb0b19c22166e70549a7bdc2d167883d30" translate="yes" xml:space="preserve">
          <source>This datetime can be seen as an ephemeral snapshot of a datetime at a given time zone. For such purposes, it also includes both UTC and Standard offsets, as well as the zone abbreviation field used exclusively for formatting purposes.</source>
          <target state="translated">이 날짜 시간은 주어진 시간대에서 날짜 시간의 임시 스냅 샷으로 볼 수 있습니다. 이러한 목적을 위해 UTC 및 표준 오프셋뿐만 아니라 형식 용도로만 사용되는 영역 약어 필드도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="025523ae9891a8ad2cd843de98bd87706ff12c27" translate="yes" xml:space="preserve">
          <source>This day fraction should be in its most simplified form possible, to make comparisons fast.</source>
          <target state="translated">이 날 분수는 비교를 빠르게하기 위해 가능한 가장 단순화 된 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="99d3f98fe052dbacd8470e76a4e43e20ad18ae6f" translate="yes" xml:space="preserve">
          <source>This default can be overridden by &lt;code&gt;@tag capture_log: false&lt;/code&gt; or &lt;code&gt;@moduletag capture_log: false&lt;/code&gt;.</source>
          <target state="translated">이 기본값은 오버라이드 (override) 할 수 &lt;code&gt;@tag capture_log: false&lt;/code&gt; 또는 &lt;code&gt;@moduletag capture_log: false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc33441b7a8711ad3ca32a6f565dfd02fa511842" translate="yes" xml:space="preserve">
          <source>This dependency refers to the latest version of Plug in the 1.x.x version series that has been pushed to Hex. This is indicated by the &lt;code&gt;~&amp;gt;&lt;/code&gt; preceding the version number. For more information on specifying version requirements, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;documentation for the Version module&lt;/a&gt;.</source>
          <target state="translated">이 종속성은 16 진수로 푸시 된 1.xx 버전 시리즈의 최신 Plug 버전을 나타냅니다. 버전 번호 앞에 &lt;code&gt;~&amp;gt;&lt;/code&gt; 가 표시됩니다 . 버전 요구 사항 지정에 대한 자세한 내용 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.html&quot;&gt;은 버전 모듈 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c49f1989fcd795b139792169130547ab503617" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="translated">이 디자인은 의도적입니다. &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 은 무한한 컬렉션, 리소스 및 기타 모양이 고정 된 구조를 지원하도록 설계되었습니다. 예를 들어 범위 제한 만 저장되는 고정 된 모양을 가지므로 값을 범위에 삽입하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e5cd48930bfba2e7e8edb59d564ea07b6d9edb0" translate="yes" xml:space="preserve">
          <source>This design is intentional. &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</source>
          <target state="translated">This design is intentional. &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; was designed to support infinite collections, resources and other structures with fixed shape. For example, it doesn't make sense to insert values into a range, as it has a fixed shape where just the range limits are stored.</target>
        </trans-unit>
        <trans-unit id="7534091aa8dce080c878d8bf8e2b8c4a424f0e53" translate="yes" xml:space="preserve">
          <source>This difference is exclusive, so the test will fail if the difference and the delta are equal.</source>
          <target state="translated">이 차이는 배타적이므로 차이와 델타가 같으면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2dd776fd236b4c910c6f960d04bcbda080e07c54" translate="yes" xml:space="preserve">
          <source>This difference is inclusive, so the test will pass if the difference and the &lt;code&gt;delta&lt;/code&gt; are equal.</source>
          <target state="translated">이 차이는 포괄적이므로 차이와 &lt;code&gt;delta&lt;/code&gt; 가 같으면 검정을 통과합니다 .</target>
        </trans-unit>
        <trans-unit id="98215fb8db656d563463f8fe38acbb92d7848ad1" translate="yes" xml:space="preserve">
          <source>This distinction is important. If there are expensive actions to be done, you must consider if it will be better to perform these actions on the client or on the server. For example:</source>
          <target state="translated">이 구별이 중요합니다. 값 비싼 조치가 수행되는 경우 클라이언트 또는 서버에서 이러한 조치를 수행하는 것이 더 나은지 고려해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df29062cd643c03ef91e3b2f35c7d26d81006829" translate="yes" xml:space="preserve">
          <source>This document covers all of Elixir syntax constructs as a reference and then discuss their exact AST representation.</source>
          <target state="translated">이 문서는 모든 Elixir 구문 구성을 참조로 다루고 정확한 AST 표현에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5ca6dcbf01e5b678fc80bf68968384a6697f2309" translate="yes" xml:space="preserve">
          <source>This document covers operators in Elixir, how they are parsed, how they can be defined, and how they can be overridden.</source>
          <target state="translated">이 문서는 Elixir의 연산자, 구문 분석 방법, 정의 방법 및 재정의 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="76b6d6a8fc49e94c927ef5f992d5906c281ba114" translate="yes" xml:space="preserve">
          <source>This document covers some naming conventions in Elixir code, from casing to punctuation characters.</source>
          <target state="translated">이 문서는 대소 문자부터 문장 부호까지 Elixir 코드의 일부 명명 규칙을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e522e86f1169f55700b99174079a5a7fddfa90ed" translate="yes" xml:space="preserve">
          <source>This document defines the commonly used base 16, base 32, and base 64 encoding schemes.</source>
          <target state="translated">이 문서는 일반적으로 사용되는 base 16, base 32 및 base 64 인코딩 체계를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d8780e3a54cb0fb8d842fe0203eab3683b262d16" translate="yes" xml:space="preserve">
          <source>This document outlines general guidelines, anti-patterns, and rules for those writing and publishing Elixir libraries meant to be consumed by other developers.</source>
          <target state="translated">이 문서는 다른 개발자들이 사용하는 Elixir 라이브러리를 작성하고 게시하는 사람들을위한 일반적인 지침, 안티 패턴 및 규칙을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7635e286607ededea5965d1544a7717ea9ae091d" translate="yes" xml:space="preserve">
          <source>This document provides a reference to Elixir syntax, exploring its constructs and their AST equivalents.</source>
          <target state="translated">이 문서는 Elixir 구문에 대한 참조를 제공하며 해당 구문과 AST 동등 물을 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="36fa202c6f9b610fe0535f0fc2890016238cbe23" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#inspect/2&quot;&gt; &lt;code&gt;Kernel.inspect/2&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cb11a86f08fe1f7ebc5f36609a52188a6715fc6d" translate="yes" xml:space="preserve">
          <source>This documentation refers to implementing the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol for your own data structures. To learn more about using inspect, see &lt;a href=&quot;kernel#inspect/2&quot;&gt;&lt;code&gt;Kernel.inspect/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 문서는 자체 데이터 구조에 대한 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜 구현을 참조합니다 . inspect 사용에 대한 자세한 내용은 &lt;a href=&quot;kernel#inspect/2&quot;&gt; &lt;code&gt;Kernel.inspect/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eb21e9b605b4017af593e4546f378df0b372b6e" translate="yes" xml:space="preserve">
          <source>This effectively loads the non-instrumented version of currently instrumented modules into memory.</source>
          <target state="translated">This effectively loads the non-instrumented version of currently instrumented modules into memory.</target>
        </trans-unit>
        <trans-unit id="1e8dce1c252882c1cf04fa14931f6945bcc1320f" translate="yes" xml:space="preserve">
          <source>This effectively loads the non-instrumented version of the module into memory.</source>
          <target state="translated">This effectively loads the non-instrumented version of the module into memory.</target>
        </trans-unit>
        <trans-unit id="1c15107405a954dcb039847f9ffc0e90a3a08175" translate="yes" xml:space="preserve">
          <source>This example shows how to get everything from the registry.</source>
          <target state="translated">이 예제는 레지스트리에서 모든 것을 얻는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="370c43dc94083c1b83066d682a8c408a4aa46d4b" translate="yes" xml:space="preserve">
          <source>This feature is considered experimental and may change in future releases.</source>
          <target state="translated">이 기능은 실험적인 것으로 간주되며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e35a46b080fba070b1bb9706d962577f541321" translate="yes" xml:space="preserve">
          <source>This file can be compiled using &lt;code&gt;elixirc&lt;/code&gt;:</source>
          <target state="translated">이 파일은 &lt;code&gt;elixirc&lt;/code&gt; 를 사용하여 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b21275a067c181042b1ef479348b07d28e434640" translate="yes" xml:space="preserve">
          <source>This file contains Erlang terms (written using Erlang syntax). Even though we are not familiar with Erlang, it is easy to guess this file holds our application definition. It contains our application &lt;code&gt;version&lt;/code&gt;, all the modules defined by it, as well as a list of applications we depend on, like Erlang&amp;rsquo;s &lt;code&gt;kernel&lt;/code&gt;, &lt;code&gt;elixir&lt;/code&gt; itself, and &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">이 파일에는 Erlang 용어 (Erlang 구문을 사용하여 작성 됨)가 포함되어 있습니다. Erlang에 익숙하지 않더라도이 파일에 응용 프로그램 정의가있는 것으로 추측하기 쉽습니다. 여기에는 애플리케이션 &lt;code&gt;version&lt;/code&gt; , 해당 모듈에 의해 정의 된 모든 모듈 및 Erlang의 &lt;code&gt;kernel&lt;/code&gt; , &lt;code&gt;elixir&lt;/code&gt; 자체 및 &lt;code&gt;logger&lt;/code&gt; 와 같이 우리가 의존하는 애플리케이션 목록이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3fde4ae93a3daf8d4be0e8acc8e91d708da691b" translate="yes" xml:space="preserve">
          <source>This file will be executed whenever your Mix project or your release starts.</source>
          <target state="translated">This file will be executed whenever your Mix project or your release starts.</target>
        </trans-unit>
        <trans-unit id="d4e5090203b164b7b8cda10cfcc22848f5f4e098" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">이 파일은 테스트를 실행하기 전에 매번 Mix에 필요합니다. &lt;code&gt;mix test&lt;/code&gt; 테스트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7951ed44572734ba9901e12d5c5112665c200cb8" translate="yes" xml:space="preserve">
          <source>This file will be required by Mix every time before we run our tests. We can run tests with:</source>
          <target state="translated">This file will be required by Mix every time before we run our tests. We can run tests with:</target>
        </trans-unit>
        <trans-unit id="5c84c085804b613daf8adcad4e1c5bc2c3c89312" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;rescue&lt;/code&gt;. You will find they are used less frequently in Elixir than in other languages, although they may be handy in some situations where a library or some particular code is not playing &amp;ldquo;by the rules&amp;rdquo;.</source>
          <target state="translated">이것은 &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;rescue&lt;/code&gt; 대한 소개를 마 칩니다 . 라이브러리 나 특정 코드가&amp;ldquo;규칙에 따라&amp;rdquo;재생되지 않는 일부 상황에서는 유용 할 수 있지만 다른 언어보다 Elixir에서 덜 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e21f5a627b95129ae5af664e7fd87944d88dfd3" translate="yes" xml:space="preserve">
          <source>This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs.</source>
          <target state="translated">이것으로 패턴 매칭에 대한 소개를 마칩니다. 다음 장에서 볼 수 있듯이 패턴 일치는 많은 언어 구조에서 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="8a8c048ae2840f3778becb01897e7dcb0a936037" translate="yes" xml:space="preserve">
          <source>This finishes our short introduction to modules. In the next chapters, we will learn how to use named functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules and discuss module attributes.</source>
          <target state="translated">이것으로 모듈에 대한 간단한 소개를 마칩니다. 다음 장에서는 재귀에 명명 된 함수를 사용하고 다른 모듈에서 함수를 가져 오는 데 사용할 수있는 Elixir 어휘 지시문을 살펴보고 모듈 속성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d37728bdb738ca01b9639cfc5853b77bca6e2f31" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about four Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="translated">이것으로 IO 장치 및 IO 관련 기능 둘러보기를 마칩니다. 우리는 4 가지 Elixir 모듈 ( &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/StringIO.html&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; )&lt;/a&gt; 에 대해 배웠습니다 .</target>
        </trans-unit>
        <trans-unit id="38be33edc941fc8a3ad680d80133cb5df88f95ae" translate="yes" xml:space="preserve">
          <source>This finishes our tour of IO devices and IO related functionality. We have learned about three Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; - as well as how the</source>
          <target state="translated">This finishes our tour of IO devices and IO related functionality. We have learned about three Elixir modules - &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; - as well as how the</target>
        </trans-unit>
        <trans-unit id="8c32849fe51611a16560a9bffff17dd6edd351d8" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="translated">This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; to &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt;. &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</target>
        </trans-unit>
        <trans-unit id="4be537303d97003eb7a277c4a7ca1256fe24cb96" translate="yes" xml:space="preserve">
          <source>This function accepts any map or struct that contains at least the same fields as a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct. The most common example of that is a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;. In this case the information about the time zone of that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is completely ignored. This is the same principle as passing a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; extracts only the date-specific fields (calendar, year, month and day) of the given structure and ignores all others.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체 와 적어도 동일한 필드를 포함하는 모든 맵 또는 구조체를 허용합니다 . 가장 일반적인 예는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 입니다. 이 경우 해당 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 의&lt;/a&gt; 시간대에 대한 정보 는 완전히 무시됩니다. 이것은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 로 전달하는 것과 같은 원리 입니다. &lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 는 주어진 구조의 날짜 별 필드 (달력, 연도, 월 및 일) 만 추출하고 다른 모든 필드는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5bf6aff9caccdb3a64ed2f33e59b9d34b47e60ba" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt; 에 따라 측정 된 &lt;code&gt;number&lt;/code&gt; 허용합니다 . 시간은 주어진 것과 동일한 달력으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e2dd6bd7df969320413c030c37f5eb3baf88d93" translate="yes" xml:space="preserve">
          <source>This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;. The time is returned in the same calendar as it was given in.</source>
          <target state="translated">This function accepts the &lt;code&gt;number&lt;/code&gt; measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;. The time is returned in the same calendar as it was given in.</target>
        </trans-unit>
        <trans-unit id="e2a89e508cd312bb2a9827f189a0607424832acb" translate="yes" xml:space="preserve">
          <source>This function accepts the following options, which are exclusive to each other (i.e., only one of them can be used in the same call):</source>
          <target state="translated">이 함수는 서로 배타적 인 다음 옵션을 허용합니다 (즉, 하나의 호출 만 동일한 호출에서 사용될 수 있음).</target>
        </trans-unit>
        <trans-unit id="01d34bc3e6a8b2f03537e43d3d5e42ba54d0dddb" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped.</source>
          <target state="translated">이 함수는 &lt;code&gt;predicate&lt;/code&gt; 함수를 선택적 인수로 허용합니다 . 전달 된 경우,이 기능이 각 바이트로 호출됩니다 &lt;code&gt;string&lt;/code&gt; 인수로하고 (이외 어떤 다른 truthy 값을 반환해야합니다 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; , 지정된 바이트가 남아 있어야하는 경우와 같이), 또는 falsy 값을 반환 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; ) 캐릭터를 이스케이프해야하는 경우</target>
        </trans-unit>
        <trans-unit id="bc20380be19f829ddb16dcf0ed86935745a4613d" translate="yes" xml:space="preserve">
          <source>This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the given byte should be left as is, or return a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) if the character should be escaped. Defaults to &lt;a href=&quot;#char_unescaped?/1&quot;&gt;&lt;code&gt;URI.char_unescaped?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This function also accepts a &lt;code&gt;predicate&lt;/code&gt; function as an optional argument. If passed, this function will be called with each byte in &lt;code&gt;string&lt;/code&gt; as its argument and should return a truthy value (anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; ) if the given byte should be left as is, or return a falsy value ( &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; ) if the character should be escaped. Defaults to &lt;a href=&quot;#char_unescaped?/1&quot;&gt; &lt;code&gt;URI.char_unescaped?/1&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="95e711242672aeb8dcafbe40b2392be2c750c645" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="translated">This function also accepts all options accepted by &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; &lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</target>
        </trans-unit>
        <trans-unit id="b98eb6f021aa33018c50a97a2ae82859d4b9d5d9" translate="yes" xml:space="preserve">
          <source>This function also accepts all options accepted by &lt;a href=&quot;regex#split/3&quot;&gt;&lt;code&gt;Regex.split/3&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pattern&lt;/code&gt; is a regular expression.</source>
          <target state="translated">이 기능은 수락 모든 옵션을 받아 &lt;a href=&quot;regex#split/3&quot;&gt; &lt;code&gt;Regex.split/3&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;pattern&lt;/code&gt; 정규 표현식이다.</target>
        </trans-unit>
        <trans-unit id="ac6f41672cc7456ee783ae52a0830c9c41b7db86" translate="yes" xml:space="preserve">
          <source>This function also notifies the compiler a warning was printed (in case --warnings-as-errors was enabled). It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">이 함수는 또한 컴파일러에 경고가 인쇄되었음을 알려줍니다 (오류로 경고가 활성화 된 경우). 성공하면 &lt;code&gt;:ok&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f335fe1ab0a202ff3768395fb418ab92d63c45f8" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt; regardless of whether the destination &lt;code&gt;server&lt;/code&gt; (or node) exists. Therefore it is unknown whether the destination &lt;code&gt;server&lt;/code&gt; successfully handled the message.</source>
          <target state="translated">이 함수 는 대상 &lt;code&gt;server&lt;/code&gt; (또는 노드)의 존재 여부에 관계없이 항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환 합니다. 따라서 대상 &lt;code&gt;server&lt;/code&gt; 가 메시지를 성공적으로 처리 했는지 여부를 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bc08e67f2fe286bbaa38c013f9a0710de372c88c" translate="yes" xml:space="preserve">
          <source>This function always returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">이 함수는 항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f38b1ffa237bfd139fe63c018eb6902804eab77a" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">This function always returns a float. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</target>
        </trans-unit>
        <trans-unit id="440a46241c8ccf32d2a66af8c374d6f2f268c12c" translate="yes" xml:space="preserve">
          <source>This function always returns a float. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">이 함수는 항상 float를 반환합니다. 그 후 결과를 정수로 자르기 위해 &lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; 을&lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502243a350ea8c22efdb92a69f5b1758006a416e" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">This function always returns floats. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; &lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</target>
        </trans-unit>
        <trans-unit id="57434e8d5ce39ceeb05917e87327e9180f6a8556" translate="yes" xml:space="preserve">
          <source>This function always returns floats. &lt;a href=&quot;kernel#trunc/1&quot;&gt;&lt;code&gt;Kernel.trunc/1&lt;/code&gt;&lt;/a&gt; may be used instead to truncate the result to an integer afterwards.</source>
          <target state="translated">이 함수는 항상 float를 반환합니다. 그 후 결과를 정수로 자르기 위해 &lt;a href=&quot;kernel#trunc/1&quot;&gt; &lt;code&gt;Kernel.trunc/1&lt;/code&gt; 을&lt;/a&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0953d55a24fb80955003844da1bc3b8af51086cb" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">이 기능은 작업의 모니터가 여전히 활성 상태이거나 모니터의 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 메시지 큐에 있다고 가정합니다 . 모니터가 해제되었거나 메시지가 이미 수신 된 경우이 기능은 메시지를 기다리는 시간 초과 기간 동안 대기합니다.</target>
        </trans-unit>
        <trans-unit id="7b478825975b2adf1e339715031349cd41d1d953" translate="yes" xml:space="preserve">
          <source>This function assumes the task's monitor is still active or the monitor's &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If it has been demonitored, or the message already received, this function will wait for the duration of the timeout awaiting the message.</source>
          <target state="translated">이 기능은 작업의 모니터가 여전히 활성 상태이거나 모니터의 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 메시지 큐에 있다고 가정합니다 . 모니터가 해제되었거나 메시지가 이미 수신 된 경우이 기능은 메시지를 기다리는 시간 초과 기간 동안 대기합니다.</target>
        </trans-unit>
        <trans-unit id="61db13a99cd2b6f7c8e9e14b335594be40a81ac4" translate="yes" xml:space="preserve">
          <source>This function assumes the tasks' monitors are still active or the monitors' &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout.</source>
          <target state="translated">This function assumes the tasks' monitors are still active or the monitors' &lt;code&gt;:DOWN&lt;/code&gt; message is in the message queue. If any tasks have been demonitored, or the message already received, this function will wait for the duration of the timeout.</target>
        </trans-unit>
        <trans-unit id="a19b113270ec008da90487c67a8732f8a8235703" translate="yes" xml:space="preserve">
          <source>This function behaves like &lt;a href=&quot;#pop/3&quot;&gt;&lt;code&gt;pop/3&lt;/code&gt;&lt;/a&gt;, but raises in cases the &lt;code&gt;key&lt;/code&gt; is not present in the given &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">This function behaves like &lt;a href=&quot;#pop/3&quot;&gt; &lt;code&gt;pop/3&lt;/code&gt; &lt;/a&gt;, but raises in cases the &lt;code&gt;key&lt;/code&gt; is not present in the given &lt;code&gt;keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bd78dfccf68211322b54eebf7d9f19fae21105" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare a DateTime without the time zone information:</source>
          <target state="translated">이 기능을 사용하면 표준 시간대 정보없이 DateTime을 비교할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6685e43cbdb2479bfe075aeca3ae08082570222e" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the date fields:</source>
          <target state="translated">이 기능을 사용하면 날짜 필드 만 고려하여 더 복잡한 달력 유형을 비교할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="abca05fe88ba596b97d33bdad630bb0ce33ca0d8" translate="yes" xml:space="preserve">
          <source>This function can also be used to compare across more complex calendar types by considering only the time fields:</source>
          <target state="translated">이 기능은 또한 시간 필드 만 고려하여보다 복잡한 달력 유형을 비교하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50c88d683e6ca48ffff95675148916e0e611983e" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to ISO 8601 without the time zone information:</source>
          <target state="translated">이 기능을 사용하면 표준 시간대 정보없이 DateTime을 ISO 8601로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41a09a6604ea410d09611cc0508b8a9905bff4c2" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a erl format without the time zone information:</source>
          <target state="translated">이 함수는 또한 시간대 정보없이 DateTime을 erl 형식으로 변환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90561437b8e4f9d3679b45a602783e2cfc785f58" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to a string without the time zone information:</source>
          <target state="translated">이 함수는 또한 시간대 정보없이 DateTime을 문자열로 변환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a058c913c46d45fd26854e6d03a3a8d889e6bda9" translate="yes" xml:space="preserve">
          <source>This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information:</source>
          <target state="translated">This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information:</target>
        </trans-unit>
        <trans-unit id="607aaac2692d9ae79c5be1d1f95f4b67e7e30692" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This function can be seen as a combination of &lt;a href=&quot;#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt; with &lt;a href=&quot;#transform/3&quot;&gt; &lt;code&gt;Stream.transform/3&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d7b8cf5df777bb4d4ddd30603ec1dffb30552797" translate="yes" xml:space="preserve">
          <source>This function can be seen as a combination of &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;stream#transform/3&quot;&gt;&lt;code&gt;Stream.transform/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;stream#transform/3&quot;&gt; &lt;code&gt;Stream.transform/3&lt;/code&gt; &lt;/a&gt; 의 조합으로 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8bf264a9f407b070cd0c90cff65f5b5b2f3cb5a" translate="yes" xml:space="preserve">
          <source>This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function.</source>
          <target state="translated">This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function.</target>
        </trans-unit>
        <trans-unit id="65aef6f44f45a3fc1e3176aa1c4a4acc551773fb" translate="yes" xml:space="preserve">
          <source>This function can be used to explicitly send a reply to a client that called &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multi_call/4&quot;&gt;&lt;code&gt;multi_call/4&lt;/code&gt;&lt;/a&gt; when the reply cannot be specified in the return value of &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 의 리턴 값에 응답을 지정할 수없는 경우이 함수를 사용하여 &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multi_call/4&quot;&gt; &lt;code&gt;multi_call/4&lt;/code&gt; &lt;/a&gt; 라는 클라이언트에 응답을 명시 적으로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e57ccc748f6208d195990a8cc4f2ec6d283e0449" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 기능은 주어진 작업에 대해 한 번만 호출 할 수 있습니다. 장시간 실행되는 작업이 계산을 완료 한 경우 여러 번 확인할 수 있으려면 &lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dbc62789df38c8a43882a7041f6f112d727b0b2b" translate="yes" xml:space="preserve">
          <source>This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield_many/2&quot;&gt;&lt;code&gt;yield_many/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">This function can only be called once for any given task. If you want to be able to check multiple times if a long-running task has finished its computation, use &lt;a href=&quot;#yield_many/2&quot;&gt; &lt;code&gt;yield_many/2&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="1236468bd1c1382c4248a39818bd66a17820a8e1" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled.</source>
          <target state="translated">This function can only be used on modules that have not yet been compiled.</target>
        </trans-unit>
        <trans-unit id="f3167d5a749467583b4064a26d582340a4353d73" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="translated">This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt; &lt;code&gt;Kernel.function_exported?/3&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt; &lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt; &lt;/a&gt; to check for public functions and macros respectively in compiled modules.</target>
        </trans-unit>
        <trans-unit id="98e8c080a62ccf76ac34e7992cc0abb94cb3247b" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;Kernel.function_exported?/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt;&lt;/a&gt; to check for public functions and macros respectively in compiled modules.</source>
          <target state="translated">이 기능은 아직 컴파일되지 않은 모듈에서만 사용할 수 있습니다. 컴파일 된 모듈에서 공개 함수와 매크로를 각각 확인 하려면 &lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;Kernel.function_exported?/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;Kernel.macro_exported?/3&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1f12a9ef0b2d87e6b97c45dc8af653b0c41485" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="translated">This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</target>
        </trans-unit>
        <trans-unit id="fd3fe0cfc1b1ddd655c5e5aa49bdc3d3f6ab9cce" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="translated">This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt; callback to get the public functions and macros in compiled modules.</target>
        </trans-unit>
        <trans-unit id="b999fb0a29efbf4b7d7e63844d3c5a01d70c5786" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get all persisted attributes, or &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; to retrieve all documentation related attributes in compiled modules.</source>
          <target state="translated">이 기능은 아직 컴파일되지 않은 모듈에서만 사용할 수 있습니다. 사용 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt; 콜백 얻기 위해 모든 속성을 지속, 또는 &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 컴파일 된 모듈에있는 모든 문서 관련 속성을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8efbd3ec7525b3bf67461748ab16a84e708bda9c" translate="yes" xml:space="preserve">
          <source>This function can only be used on modules that have not yet been compiled. Use the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;Module.__info__/1&lt;/code&gt;&lt;/a&gt; callback to get the public functions and macros in compiled modules.</source>
          <target state="translated">이 기능은 아직 컴파일되지 않은 모듈에서만 사용할 수 있습니다. 컴파일 된 모듈에서 공용 함수 및 매크로를 가져 오려면 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;Module.__info__/1&lt;/code&gt; &lt;/a&gt; 콜백을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d5f5ab7615681bbf6fd8b48511d63b244920517" translate="yes" xml:space="preserve">
          <source>This function changes the current working directory and loads the project at the given directory onto the project stack.</source>
          <target state="translated">이 기능은 현재 작업 디렉토리를 변경하고 주어진 디렉토리에서 프로젝트를 프로젝트 스택으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="8e3b67a18d5ef72f20a07d2887c95146e1126e8b" translate="yes" xml:space="preserve">
          <source>This function checks if &lt;code&gt;map_set1&lt;/code&gt; is a subset of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">이 기능을 검사하는 경우 &lt;code&gt;map_set1&lt;/code&gt; 은 의 서브 세트 인 &lt;code&gt;map_set2&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="c2d91333f4d34514a5b0456ce852915cb7c3b1bf" translate="yes" xml:space="preserve">
          <source>This function could also receive &lt;code&gt;:restart&lt;/code&gt; and &lt;code&gt;:shutdown&lt;/code&gt; as options but those two options have been deprecated and it is now preferred to give them directly to &lt;code&gt;start_child&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;:restart&lt;/code&gt; 및 &lt;code&gt;:shutdown&lt;/code&gt; 을 옵션으로 수신 할 수 있지만이 두 옵션은 더 이상 사용되지 않으며 이제 &lt;code&gt;start_child&lt;/code&gt; 및 &lt;code&gt;async&lt;/code&gt; 에 직접 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ff81d1869547c10033febe62aa38e4cdb8f5c51e" translate="yes" xml:space="preserve">
          <source>This function discards all formatting of the original code.</source>
          <target state="translated">이 함수는 원래 코드의 모든 형식을 버립니다.</target>
        </trans-unit>
        <trans-unit id="bc64919f284870e1f397d0b40b0bdb1f6bff9e2a" translate="yes" xml:space="preserve">
          <source>This function does not load the protocol at any point nor loads the new bytecode for the compiled module. However each implementation must be available and it will be loaded.</source>
          <target state="translated">이 함수는 어떤 시점에서도 프로토콜을로드하지 않으며 컴파일 된 모듈의 새 바이트 코드를로드하지 않습니다. 그러나 각 구현을 사용할 수 있어야하며로드됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9ba48e0ab714ebacb38f83050628f3e221fabd" translate="yes" xml:space="preserve">
          <source>This function does not query the file system, so it assumes no symlinks between the paths.</source>
          <target state="translated">이 함수는 파일 시스템을 쿼리하지 않으므로 경로간에 심볼릭 링크가 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="352c8d36738c6dbc1f9234ecd7c20913e38da8c4" translate="yes" xml:space="preserve">
          <source>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</source>
          <target state="translated">이 함수는 의도적으로 정규식을 지원하지 않습니다. 정규식을 사용할 때이 함수처럼 정규식이 문자열을 한 번에 한 번에 통과하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="e8a6e9d8eb826748ee60c4f58dedbbe4f6cb4a1b" translate="yes" xml:space="preserve">
          <source>This function does nothing if the given directory already exists; in this case, it still logs the directory creation.</source>
          <target state="translated">This function does nothing if the given directory already exists; in this case, it still logs the directory creation.</target>
        </trans-unit>
        <trans-unit id="36b23a290c43ebbc586e10e0e06f96b58b15d87c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="translated">This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; before unquoting.</target>
        </trans-unit>
        <trans-unit id="df30bac7bb7c4cc8e50dfd93b53e8ccc88b71e0c" translate="yes" xml:space="preserve">
          <source>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to &lt;code&gt;unquote&lt;/code&gt; any value, such as a map or a four-element tuple, you should call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before unquoting.</source>
          <target state="translated">이 함수는 인용 된 표현식이라고도하는 유효한 Elixir AST를 인수로 예상합니다. 당신이하려는 경우 &lt;code&gt;unquote&lt;/code&gt; 값을, 같은지도 또는 네 개의 요소 튜플, 당신은 호출해야 &lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; unquoting 전에.</target>
        </trans-unit>
        <trans-unit id="9f41d20e5f7f0240b4127af0359d8f266f1d505e" translate="yes" xml:space="preserve">
          <source>This function expects the &lt;code&gt;id&lt;/code&gt; in the child specification. For example:</source>
          <target state="translated">이 함수는 하위 스펙 의 &lt;code&gt;id&lt;/code&gt; 를 예상합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a24e422135d3a72abf7a20c0e4887299173a50a" translate="yes" xml:space="preserve">
          <source>This function expects the file to be closed with success, which is usually the case unless the &lt;code&gt;:delayed_write&lt;/code&gt; option is given. For this reason, we do not recommend passing &lt;code&gt;:delayed_write&lt;/code&gt; to this function.</source>
          <target state="translated">이 함수는 파일이 성공적으로 닫힐 것으로 예상합니다. 일반적으로 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션이 지정 되지 않은 경우 입니다. &lt;code&gt;:delayed_write&lt;/code&gt; 함수에 : delayed_write 를 전달하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="295cf4a022ae9886df00b43f0a66cd0e9487ce78" translate="yes" xml:space="preserve">
          <source>This function fails unless &lt;code&gt;enumerable&lt;/code&gt; is or can be converted into a list of tuples with &lt;em&gt;exactly&lt;/em&gt; two elements in each tuple.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 하거나 각 튜플에 &lt;em&gt;정확히&lt;/em&gt; 두 개의 요소가있는 튜플 목록으로 변환 할 수 없으면이 함수는 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="2b4e5979f3e77e3276f95ef316da429597fdbf6e" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a directory, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수는 기호 링크를 따르므로 기호 링크가 디렉토리를 가리키는 경우 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3644ab39c8ba48b5055b8839db30ad7f73881153" translate="yes" xml:space="preserve">
          <source>This function follows symbolic links, so if a symbolic link points to a regular file, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">이 함수는 심볼릭 링크를 따르므로 심볼릭 링크가 일반 파일을 가리키면 &lt;code&gt;true&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b2249c2f938c82b4201fa3098032739f601917fd" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="translated">This function is called after &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; finishes but before &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</target>
        </trans-unit>
        <trans-unit id="ffa8e1b3e795c072d918d9fb7e14d1f0f556146a" translate="yes" xml:space="preserve">
          <source>This function is called after &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; finishes but before &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; returns. It will be called once for every start phase defined in the application's (and any included applications') specification, in the order they are listed in.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 가 완료된 후 &lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; 가&lt;/a&gt; 반환 되기 전에 호출 됩니다. 응용 프로그램 (및 포함 된 응용 프로그램) 스펙에 정의 된 모든 시작 단계에 대해 나열된 순서대로 한 번씩 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="324f00c4d8269119ff0a84cb2a42e9f018297cf4" translate="yes" xml:space="preserve">
          <source>This function is called after an application has been stopped, i.e., after its supervision tree has been stopped. It should do the opposite of what the &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback did, and should perform any necessary cleanup. The return value of this callback is ignored.</source>
          <target state="translated">이 기능은 응용 프로그램이 중지 된 후, 즉 관리 트리가 중지 된 후에 호출됩니다. &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백과는 반대의 작업을 수행하고 필요한 정리 작업을 수행해야합니다. 이 콜백의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e69bba301a1e9a02d953f1b325981a44e10b03" translate="yes" xml:space="preserve">
          <source>This function is called before the top-level supervisor is terminated. It receives the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value is later passed to &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 최상위 수퍼바이저가 종료되기 전에 호출됩니다. &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된 상태를 수신하고 , 그렇지 않으면 &lt;code&gt;[]&lt;/code&gt; 를 수신 합니다. 리턴 값은 나중에 &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; 로&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9100c3a64f894ac6d7e9c96487fe6fde6165a293" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">This function is called when an application is started using &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</target>
        </trans-unit>
        <trans-unit id="82b44336c3cb3815e176b242c09b89fad73c5747" translate="yes" xml:space="preserve">
          <source>This function is called when an application is started using &lt;a href=&quot;application#start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; (and functions on top of that, such as &lt;a href=&quot;application#ensure_started/2&quot;&gt;&lt;code&gt;Application.ensure_started/2&lt;/code&gt;&lt;/a&gt;). This function should start the top-level process of the application (which should be the top supervisor of the application's supervision tree if the application follows the OTP design principles around supervision).</source>
          <target state="translated">애플리케이션이 기동 된 경우이 함수를 호출 &lt;a href=&quot;application#start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; (예컨대 그 위에,과 기능 &lt;a href=&quot;application#ensure_started/2&quot;&gt; &lt;code&gt;Application.ensure_started/2&lt;/code&gt; &lt;/a&gt; ). 이 기능은 응용 프로그램의 최상위 프로세스를 시작해야합니다 (응용 프로그램이 감독과 관련된 OTP 설계 원칙을 따르는 경우 응용 프로그램 감독 트리의 최고 감독자 여야 함).</target>
        </trans-unit>
        <trans-unit id="6397213a49d0900b8102d7287a15cef482e32621" translate="yes" xml:space="preserve">
          <source>This function is commonly used on sigil implementations (like &lt;code&gt;~r&lt;/code&gt;, &lt;code&gt;~s&lt;/code&gt; and others) which receive a raw, unescaped string.</source>
          <target state="translated">이 함수는 일반적으로 이스케이프 처리되지 않은 원시 문자열을 수신하는 시길 구현 (예 : &lt;code&gt;~r&lt;/code&gt; , &lt;code&gt;~s&lt;/code&gt; 및 기타)에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d995248df30d102cca47a9415c594b82af5a6b24" translate="yes" xml:space="preserve">
          <source>This function is deprecated in favor of register&lt;em&gt;test/6 which performs better under tight loops by avoiding `&lt;em&gt;_ENV&lt;/em&gt;&lt;/em&gt;`.</source>
          <target state="translated">This function is deprecated in favor of register&lt;em&gt;test/6 which performs better under tight loops by avoiding `&lt;em&gt;_ENV&lt;/em&gt;&lt;/em&gt;`.</target>
        </trans-unit>
        <trans-unit id="c1d006a8fc94dd9c7e1ba97fca6cd955efbe08aa" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Code.get_docs/2 always returns nil as its outdated documentation is no longer stored on BEAM files. Use Code.fetch_docs/1 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 오래된 문서는 더 이상 BEAM 파일에 저장되지 않으므로 Code.get_docs / 2는 항상 nil을 반환합니다. 대신 Code.fetch_docs / 1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d817e277c636af5ee8696b4df5a417a3f80ca798" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use :unicode.characters_to_nfc_binary/1 or :unicode.characters_to_nfd_binary/1 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 : unicode.characters_to_nfc_binary / 1 또는 : unicode.characters_to_nfd_binary / 1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="60a45058b6790fa9239d39a09ba1cdda7435ef0c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Application.put_all_env/2 instead.</source>
          <target state="translated">This function is deprecated. Use Application.put_all_env/2 instead.</target>
        </trans-unit>
        <trans-unit id="0b23beae139d2fe3b8dd9e0473697f46a6bf3126" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.merge/2 instead.</source>
          <target state="translated">This function is deprecated. Use Config.Reader.merge/2 instead.</target>
        </trans-unit>
        <trans-unit id="86105be5ebb65f8fc111c1f572d090b08b31bb9f" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.read!/2 instead.</source>
          <target state="translated">This function is deprecated. Use Config.Reader.read!/2 instead.</target>
        </trans-unit>
        <trans-unit id="32063e9041204452ecaa501f77654e27a25810d5" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Config.Reader.read_imports!/2 instead.</source>
          <target state="translated">This function is deprecated. Use Config.Reader.read_imports!/2 instead.</target>
        </trans-unit>
        <trans-unit id="6d197dc51c7a88c8b078c1ba4ae70a662b56ba4a" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd!/0 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 File.cwd! / 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="68131068aaa063f7af71e9caaedd8601eae221d0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use File.cwd/0 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 File.cwd / 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0d830aeb45447ac17882f0a978208672f2f7513b" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Kernel.is_exception/1 instead.</source>
          <target state="translated">This function is deprecated. Use Kernel.is_exception/1 instead.</target>
        </trans-unit>
        <trans-unit id="ad1c80a22d94657b35b167d9b5a2864907218fe0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Kernel.is_struct/2 or pattern match on %Regex{} instead.</source>
          <target state="translated">This function is deprecated. Use Kernel.is_struct/2 or pattern match on %Regex{} instead.</target>
        </trans-unit>
        <trans-unit id="d9e5b31b2e69678e54278c031112af02d71d6009" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use Mix.Project.compile_path/1 instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 Mix.Project.compile_path / 1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="276ba4e5a68c3327954a5805cb6a3557ffa0219d" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use System.pid/0 instead.</source>
          <target state="translated">This function is deprecated. Use System.pid/0 instead.</target>
        </trans-unit>
        <trans-unit id="f81151223ea682b301965bb3a3e0dd982cec6acb" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use __STACKTRACE__ instead.</source>
          <target state="translated">This function is deprecated. Use __STACKTRACE__ instead.</target>
        </trans-unit>
        <trans-unit id="135f175d7851a47b5eed88f4c873758b05277e6c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use compilation tracers described in the Code module.</source>
          <target state="translated">This function is deprecated. Use compilation tracers described in the Code module.</target>
        </trans-unit>
        <trans-unit id="a03218696b1f2f17e92328d8d93708ef4f7e2fab" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use maps and the Map module instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 맵과 맵 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5383727db2a4be3cae258dc51e6f2efc4de4ed67" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use register_test/6 instead.</source>
          <target state="translated">This function is deprecated. Use register_test/6 instead.</target>
        </trans-unit>
        <trans-unit id="294ad166bf50a35c62c560f0efcfd8102e974b3c" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Config module instead.</source>
          <target state="translated">This function is deprecated. Use the Config module instead.</target>
        </trans-unit>
        <trans-unit id="afca0b7ebdad39b2deed844f934a667e8bfea571" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the Map module for working with maps or the Keyword module for working with keyword lists.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 맵 작업에는 맵 모듈을 사용하고 키워드 목록 작업에는 키워드 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a82ec0a465ee3ffdfcf230d76d58430e9467641" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module for working with sets.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 세트 작업에 MapSet 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="01a53758d90cccf848faf6930295f5427dfb10e9" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the MapSet module instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 MapSet 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc379a87241e5a13ab44a63bf4ea91b193d573b0" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="translated">This function is deprecated. Use the new child specifications outlined in the Supervisor module instead.</target>
        </trans-unit>
        <trans-unit id="03ea43b93839fafbcde7b68af462e5f9eed5a8d0" translate="yes" xml:space="preserve">
          <source>This function is meant to be used for development and debugging purposes. Do not depend on it in production code.</source>
          <target state="translated">이 기능은 개발 및 디버깅 목적으로 사용됩니다. 프로덕션 코드에서는 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a44ba9065763e466dc65d136dacf651b48b4c551" translate="yes" xml:space="preserve">
          <source>This function is often used to set an &lt;code&gt;:id&lt;/code&gt; option when the same module needs to be started multiple times in the supervision tree:</source>
          <target state="translated">이 기능은 감독 트리에서 동일한 모듈을 여러 번 시작해야 할 때 &lt;code&gt;:id&lt;/code&gt; 옵션 을 설정하는 데 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b1fd4e59486849679c33280edfff500c42ca784" translate="yes" xml:space="preserve">
          <source>This function is often used with &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; since any evaluation is delayed until the stream is executed. See &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">이 기능은 스트림이 실행될 때까지 평가가 지연되므로 &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 과 함께 자주 사용됩니다 . 예제는 &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35db107573e34332f733e95b887f5793867baa7f" translate="yes" xml:space="preserve">
          <source>This function is only available for modules being compiled.</source>
          <target state="translated">이 기능은 컴파일중인 모듈에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104264e00ba2e4cbd7fe3847934c61231f453ccd" translate="yes" xml:space="preserve">
          <source>This function is rarely invoked in practice. Instead, nodes are named and started via the command line by using the &lt;code&gt;--sname&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; flags. If you need to use this function to dynamically name a node, please make sure the &lt;code&gt;epmd&lt;/code&gt; operating system process is running by calling &lt;code&gt;epmd -daemon&lt;/code&gt;.</source>
          <target state="translated">This function is rarely invoked in practice. Instead, nodes are named and started via the command line by using the &lt;code&gt;--sname&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; flags. If you need to use this function to dynamically name a node, please make sure the &lt;code&gt;epmd&lt;/code&gt; operating system process is running by calling &lt;code&gt;epmd -daemon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6bf228951da57a994d903de6610ec9973c50adc" translate="yes" xml:space="preserve">
          <source>This function is used by &lt;a href=&quot;#container_doc/6&quot;&gt;&lt;code&gt;container_doc/6&lt;/code&gt;&lt;/a&gt; and friends to the maximum number of entries on the same line.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#container_doc/6&quot;&gt; &lt;code&gt;container_doc/6&lt;/code&gt; &lt;/a&gt; 및 friends에서 같은 줄의 최대 항목 수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4934d4902c08909612efec0de002f5df60337c47" translate="yes" xml:space="preserve">
          <source>This function is useful for development and debugging when you have code that has been compiled or updated locally that you want to run on other nodes.</source>
          <target state="translated">이 기능은 다른 노드에서 실행하려는 로컬에서 컴파일 또는 업데이트 된 코드가있는 경우 개발 및 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="50108ad28c85db6aa26c7746481f7a06145abb10" translate="yes" xml:space="preserve">
          <source>This function is useful for dynamically creating and updating structs, as well as for converting maps to structs; in the latter case, just inserting the appropriate &lt;code&gt;:__struct__&lt;/code&gt; field into the map may not be enough and &lt;a href=&quot;#struct/2&quot;&gt;&lt;code&gt;struct/2&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">이 함수는 구조체를 동적으로 생성 및 업데이트하고 맵을 구조체로 변환하는 데 유용합니다. 후자의 경우 맵에 적절한 &lt;code&gt;:__struct__&lt;/code&gt; 필드를 삽입하는 것만 으로는 충분하지 않을 수 있으며 대신 &lt;a href=&quot;#struct/2&quot;&gt; &lt;code&gt;struct/2&lt;/code&gt; 를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5385bb3c5cc1848788f9b3bfe82e294efa3644f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you have templates but you want to precompile inside a module for speed.</source>
          <target state="translated">이 기능은 템플릿이 있지만 속도를 위해 모듈 내부에서 사전 컴파일하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d4f1c9110eb148d436155bff7b34df88e2134afb" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present (e.g., the value is expensive to calculate or generally difficult to setup and teardown again).</source>
          <target state="translated">이 기능은 &lt;code&gt;key&lt;/code&gt; 가없는 경우에만 &lt;code&gt;key&lt;/code&gt; 아래에 놓을 값을 계산하려는 경우에 유용합니다 (예 : 값이 계산하기에 비싸거나 일반적으로 설정 및 해제하기가 ​​어렵습니다).</target>
        </trans-unit>
        <trans-unit id="e5bb11de88319e8025850f4eadfe13c588a0a62f" translate="yes" xml:space="preserve">
          <source>This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present, as for example, when the value is expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">This function is useful in case you want to compute the value to put under &lt;code&gt;key&lt;/code&gt; only if &lt;code&gt;key&lt;/code&gt; is not already present, as for example, when the value is expensive to calculate or generally difficult to setup and teardown again.</target>
        </trans-unit>
        <trans-unit id="bf89a2dec2302779e475a219a3cc56e86137d9f9" translate="yes" xml:space="preserve">
          <source>This function is useful when there is a need to retrieve the current value (or something calculated in function of the current value) and update it at the same time. For example, it could be used to read the current age of a user while increasing it by one in one pass:</source>
          <target state="translated">이 기능은 현재 값 (또는 현재 값에 따라 계산 된 값)을 검색하고 동시에 업데이트해야 할 때 유용합니다. 예를 들어, 사용자의 현재 연령을 읽는 동안 한 번에 하나씩 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a1bac27fa5baaa472b5537d1c8fee1ec1e9478" translate="yes" xml:space="preserve">
          <source>This function is useful when you know the bytecode for module has been updated in the file system and you want to tell the VM to load it.</source>
          <target state="translated">이 기능은 파일 시스템에서 모듈의 바이트 코드가 업데이트되었고 VM에로드하도록 지시 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="80a765f43bfbc2222f8ba2acffb613f97fc1ff91" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change.</source>
          <target state="translated">이 기능은 일반적으로 구성 파일이 변경 될 때마다 전체 재 컴파일을 트리거하기 위해 컴파일 작업에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5161d32c18b7b4c986062d2c9d65d697f139b8ce" translate="yes" xml:space="preserve">
          <source>This function is usually used in compilation tasks to trigger a full recompilation whenever such configuration files change. For this reason, the mtime is cached to avoid file system lookups.</source>
          <target state="translated">이 기능은 일반적으로 구성 파일이 변경 될 때마다 전체 재 컴파일을 트리거하기 위해 컴파일 작업에서 사용됩니다. 이러한 이유로 mtime은 파일 시스템 조회를 피하기 위해 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="79351219ceeb1dfd5ceb68c4d1517bb1d53f3be9" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report is logged.</source>
          <target state="translated">이 기능은 오류보고에 관한 OTP 시맨틱을 유지합니다. 이유가 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 이 아닌 경우 오류 보고서가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb9a7593d63fc692737aa5ebbecdecf78a06b53" translate="yes" xml:space="preserve">
          <source>This function keeps OTP semantics regarding error reporting. If the reason is any other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, _}&lt;/code&gt;, an error report will be logged.</source>
          <target state="translated">이 기능은 오류보고에 관한 OTP 시맨틱을 유지합니다. 이유가 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, _}&lt;/code&gt; 이 아닌 경우 오류 보고서가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="78ffeed4e3d53d08c6f8c5350cc948af11ad5cb9" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Unix and Windows. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="translated">이 함수는 Unix 및 Windows에서 환경 변수 PATH를 사용하여 이름이 지정된 실행 프로그램을 찾습니다. 또한 각 운영 체제에 적합한 실행 가능한 확장명을 고려하므로 Windows의 경우 &lt;code&gt;.com&lt;/code&gt; , &lt;code&gt;.cmd&lt;/code&gt; 또는 유사한 확장명으로 파일을 검색하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="f333cc8d70b1f8c9b88e75ba1e997bdd40b786ac" translate="yes" xml:space="preserve">
          <source>This function looks up an executable program given its name using the environment variable PATH on Windows and Unix-like operating systems. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</source>
          <target state="translated">This function looks up an executable program given its name using the environment variable PATH on Windows and Unix-like operating systems. It also considers the proper executable extension for each operating system, so for Windows it will try to lookup files with &lt;code&gt;.com&lt;/code&gt; , &lt;code&gt;.cmd&lt;/code&gt; or similar extensions.</target>
        </trans-unit>
        <trans-unit id="5b2d601e721f14118337f53a36587c0e933c7a5a" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="03c6c18f32c36e354994adeed127bb47604a29a4" translate="yes" xml:space="preserve">
          <source>This function maps each element of the &lt;code&gt;enumerable&lt;/code&gt; using the provided &lt;code&gt;mapper&lt;/code&gt; function. The enumerable is then sorted by the mapped elements using the &lt;code&gt;sorter&lt;/code&gt; function, which defaults to &lt;a href=&quot;kernel#%253C=/2&quot;&gt;&lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수 는 제공된 &lt;code&gt;mapper&lt;/code&gt; 함수를 사용하여 &lt;code&gt;enumerable&lt;/code&gt; 각 요소를 매핑 합니다. 열거 가능한이어서 사용 매핑 소자 정렬 &lt;code&gt;sorter&lt;/code&gt; 에 기능을 디폴트 &lt;a href=&quot;kernel#%253C=/2&quot;&gt; &lt;code&gt;Kernel.&amp;lt;=/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23713134a12e3df672b0e8ed70b6c1e947176852" translate="yes" xml:space="preserve">
          <source>This function may fail while copying files, in such cases, it will leave the destination directory in a dirty state, where file which have already been copied won't be removed.</source>
          <target state="translated">파일을 복사하는 동안이 기능이 실패 할 수 있습니다. 이러한 경우 대상 디렉토리가 더티 상태로 남아 있습니다. 이미 복사 된 파일은 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc53ec83419111665403d3184c5309cb3ac3114b" translate="yes" xml:space="preserve">
          <source>This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">이 함수는 &lt;code&gt;child_id&lt;/code&gt; 를 찾을 수 없거나 현재 프로세스가 실행 중이거나 재시작중인 경우 적절한 오류 튜플과 함께 오류를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae84d6b7d02c1f5e4d3d90e843aa4994fe5afbb" translate="yes" xml:space="preserve">
          <source>This function merges two URIs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986, section 5.2&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2&quot;&gt;RFC 3986 섹션 5.2에&lt;/a&gt; 따라 두 개의 URI를 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="37485440bd71be8d2898fa309650b1d1cd41ee6d" translate="yes" xml:space="preserve">
          <source>This function must be invoked passing a keyword list. Each key in the keyword list can be accessed in the template using the &lt;code&gt;@&lt;/code&gt; macro.</source>
          <target state="translated">This function must be invoked passing a keyword list. Each key in the keyword list can be accessed in the template using the &lt;code&gt;@&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="05add340c108b6747380b0569be39878bbcf49a1" translate="yes" xml:space="preserve">
          <source>This function mutes the &lt;code&gt;:console&lt;/code&gt; backend and captures any log messages sent to Logger from the calling processes. It is possible to ensure explicit log messages from other processes are captured by waiting for their exit or monitor signal.</source>
          <target state="translated">This function mutes the &lt;code&gt;:console&lt;/code&gt; backend and captures any log messages sent to Logger from the calling processes. It is possible to ensure explicit log messages from other processes are captured by waiting for their exit or monitor signal.</target>
        </trans-unit>
        <trans-unit id="590e88bd007ad46708757dcaddaef35962698f85" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="translated">This function only accepts floats and always returns a float. Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt; &lt;code&gt;Kernel.round/1&lt;/code&gt; &lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</target>
        </trans-unit>
        <trans-unit id="7249b2b7e8627d3ee0f960577e5cfe5cf5a1c42f" translate="yes" xml:space="preserve">
          <source>This function only accepts floats and always returns a float. Use &lt;a href=&quot;kernel#round/1&quot;&gt;&lt;code&gt;Kernel.round/1&lt;/code&gt;&lt;/a&gt; if you want a function that accepts both floats and integers and always returns an integer.</source>
          <target state="translated">이 함수는 float 만 허용하고 항상 float를 반환합니다. 부동 소수점과 정수를 모두 허용하고 항상 정수를 반환하는 함수를 원하면 &lt;a href=&quot;kernel#round/1&quot;&gt; &lt;code&gt;Kernel.round/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="50d8af487774d9f7e007fed31c88d7f628e11c28" translate="yes" xml:space="preserve">
          <source>This function only ever needs to store the last emitted element.</source>
          <target state="translated">이 함수는 마지막으로 방출 된 요소 만 저장하면됩니다.</target>
        </trans-unit>
        <trans-unit id="295eba0c064a53ae3a651500b18114cd09951154" translate="yes" xml:space="preserve">
          <source>This function only works if ANSI escape codes are enabled on the shell, which means this function is by default unavailable on Windows machines.</source>
          <target state="translated">이 기능은 쉘에서 ANSI 이스케이프 코드가 활성화 된 경우에만 작동합니다. 즉,이 기능은 기본적으로 Windows 시스템에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8e779fa093dd3331e4911e8f1f5e060533eb427" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="translated">This function produces the same result as the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt; operator for lists.</target>
        </trans-unit>
        <trans-unit id="528389cc0cdba8ed58acc495892cfb708eb725e7" translate="yes" xml:space="preserve">
          <source>This function produces the same result as the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; operator for lists.</source>
          <target state="translated">이 함수는 목록에 대한 &lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt; 연산자 와 동일한 결과를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2bd92c0ea07d00b8bd2fd96f2a2022d49efc3e5e" translate="yes" xml:space="preserve">
          <source>This function purges all modules currently kept by the compiler, allowing old compiler module names to be reused. If there are any processes running any code from such modules, they will be terminated too.</source>
          <target state="translated">이 함수는 컴파일러가 현재 보유하고있는 모든 모듈을 제거하여 이전 컴파일러 모듈 이름을 재사용 할 수 있도록합니다. 그러한 모듈에서 코드를 실행하는 프로세스가 있으면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e3b8f5e13f2da9604ba811f1ee787c3cba445b85" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="translated">This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of the results, in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</target>
        </trans-unit>
        <trans-unit id="0c8f05dda04bc767a1282d611e4af5dafdcb7b8d" translate="yes" xml:space="preserve">
          <source>This function receives a list of tasks and waits for their replies in the given time interval. It returns a list of two-element tuples, with the task as the first element and the yielded result as the second. The tasks in the returned list will be in the same order as the tasks supplied in the &lt;code&gt;tasks&lt;/code&gt; input argument.</source>
          <target state="translated">이 기능은 작업 목록을 수신하고 주어진 시간 간격으로 응답을 기다립니다. 작업이 첫 번째 요소이고 결과가 두 번째 요소 인 두 요소 튜플의 목록을 반환합니다. 리턴 된 목록의 태스크는 &lt;code&gt;tasks&lt;/code&gt; 입력 인수에 제공된 태스크와 동일한 순서 입니다.</target>
        </trans-unit>
        <trans-unit id="66ca8de099428d7febba36a7eae6660d193647fb" translate="yes" xml:space="preserve">
          <source>This function reruns the given task; to do that, it first re-enables the task and then runs it as normal.</source>
          <target state="translated">이 기능은 주어진 작업을 다시 실행합니다. 이를 위해 먼저 작업을 다시 활성화 한 다음 정상적으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7f88acb523db6223367758a20b1546d9d8c207d7" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, owner}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt;. The &lt;code&gt;owner&lt;/code&gt; is the PID in the registry partition responsible for the PID. The owner is automatically linked to the caller.</source>
          <target state="translated">이 함수는 &lt;code&gt;{:ok, owner}&lt;/code&gt; 또는 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환합니다 . &lt;code&gt;owner&lt;/code&gt; 는 PID에 대한 책임 레지스트리 파티션의 PID입니다. 소유자는 발신자와 자동으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="902dd92c08e25103df4b50bae4697cf10a6fc6fd" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;{:ok, pid}&lt;/code&gt; in case of success, otherwise it returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">이 함수는 성공한 경우 &lt;code&gt;{:ok, pid}&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9f3353899fe4360fc7c94245abd3933c4141ee40" translate="yes" xml:space="preserve">
          <source>This function returns a list of &lt;code&gt;{id, child, type, modules}&lt;/code&gt; tuples, where:</source>
          <target state="translated">이 함수는 &lt;code&gt;{id, child, type, modules}&lt;/code&gt; 튜플 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c22e6a9591d2580a185def76ec2a7822b6c5d175" translate="yes" xml:space="preserve">
          <source>This function returns a list of tuples containing:</source>
          <target state="translated">이 함수는 다음을 포함하는 튜플 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ffb7797732e8eabda6ec4358625e5d11748d93c" translate="yes" xml:space="preserve">
          <source>This function returns a new enumerable built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together; conceptually, this is similar to a combination of &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#concat/1&quot;&gt;&lt;code&gt;concat/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 호출 한 결과 추가에 의해 만들어진 새로운 열거 반환 &lt;code&gt;fun&lt;/code&gt; 의 각 요소에 대해 &lt;code&gt;enumerable&lt;/code&gt; 함께를; 개념적으로 이것은 &lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#concat/1&quot;&gt; &lt;code&gt;concat/1&lt;/code&gt; &lt;/a&gt; 의 조합과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a4c4692a1b2085c0d5c4c7060abeb21e5e80d789" translate="yes" xml:space="preserve">
          <source>This function returns a new stream built by appending the result of invoking &lt;code&gt;fun&lt;/code&gt; on each element of &lt;code&gt;enumerable&lt;/code&gt; together.</source>
          <target state="translated">이 함수는 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 &lt;code&gt;fun&lt;/code&gt; 호출 결과를 추가하여 빌드 된 새 스트림을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9207161e31f07b71a8de0abeb84876a37ff477ac" translate="yes" xml:space="preserve">
          <source>This function returns a timer reference, which can be read with &lt;a href=&quot;#read_timer/1&quot;&gt;&lt;code&gt;read_timer/1&lt;/code&gt;&lt;/a&gt; or canceled with &lt;a href=&quot;#cancel_timer/1&quot;&gt;&lt;code&gt;cancel_timer/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수로 읽을 수있는 타이머 레퍼런스 리턴 &lt;a href=&quot;#read_timer/1&quot;&gt; &lt;code&gt;read_timer/1&lt;/code&gt; &lt;/a&gt; 또는 취소에 &lt;a href=&quot;#cancel_timer/1&quot;&gt; &lt;code&gt;cancel_timer/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3b4424c23b3b31b7bea686c83f6fbd90413317a" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the collected result and the command exit status.</source>
          <target state="translated">이 함수는 수집 된 결과와 명령 종료 상태를 포함하는 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c1572156370222a67bdcd453345528785b5b103" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor flags and child specifications.</source>
          <target state="translated">이 함수는 감독자 플래그와 자식 사양이 포함 된 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a236219391c9665ab6cd417a5f529892164a5643" translate="yes" xml:space="preserve">
          <source>This function returns a tuple containing the supervisor options.</source>
          <target state="translated">이 함수는 감독자 옵션이 포함 된 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f10657fb9f9d2dbe8abd5fb7b8f8b43416880ed5" translate="yes" xml:space="preserve">
          <source>This function returns an empty list when used at the root of an umbrella project because there is no compile manifest to extract the function call information from. To get the function calls of each child in an umbrella, execute the function at the root of each individual application.</source>
          <target state="translated">이 함수는 함수 호출 정보를 추출 할 컴파일 매니페스트가 없으므로 우산 프로젝트의 루트에서 사용될 때 빈 목록을 반환합니다. 우산에있는 각 자식의 함수 호출을 얻으려면 각 개별 응용 프로그램의 루트에서 함수를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a6fbf0f83b2acb02bb139f54eef721ae8347767a" translate="yes" xml:space="preserve">
          <source>This function returns either &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt;. Where &lt;code&gt;definition&lt;/code&gt; is &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt; or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;{:ok, definition, clauses}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 를 반환합니다 . 여기서 &lt;code&gt;definition&lt;/code&gt; 는 &lt;code&gt;:def&lt;/code&gt; , &lt;code&gt;:defp&lt;/code&gt; , &lt;code&gt;:defmacro&lt;/code&gt; 또는 &lt;code&gt;:defmacrop&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5908984f567478e4a60e81ad1b7f0e0a95ff38d7" translate="yes" xml:space="preserve">
          <source>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</source>
          <target state="translated">이 함수는 즉시 리턴하여 존재하지 않거나 서버 이름이없는 노드를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3c26de55ed91737da0adcc687c60b204ef4f41f8" translate="yes" xml:space="preserve">
          <source>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</source>
          <target state="translated">이 함수는 중단 점 ID를 리턴하고 중단 점 설정 오류가있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac0ff9db2cb58b04d706d4d0f95101c014828e27" translate="yes" xml:space="preserve">
          <source>This function returns the current application name, but only if the application name should be printed.</source>
          <target state="translated">This function returns the current application name, but only if the application name should be printed.</target>
        </trans-unit>
        <trans-unit id="e9031a38e543bd6739ba00dbc5fed0a5a01f11ea" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;calendar.iso&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;calendar.iso&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt; 에 따라 초가 측정되는 초 단위의 차이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5af0f8f1d39fdde7d2176a52228d4efede75942" translate="yes" xml:space="preserve">
          <source>This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt;&lt;code&gt;Calendar.ISO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This function returns the difference in seconds where seconds are measured according to &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.ISO.html&quot;&gt; &lt;code&gt;Calendar.ISO&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ef0ad46bb886f62fbf2201ba9b9f859d8daf73a5" translate="yes" xml:space="preserve">
          <source>This function returns:</source>
          <target state="translated">이 함수는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc16b8c0d60d4a66a61b6088df628cb2cdbe5f10" translate="yes" xml:space="preserve">
          <source>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</source>
          <target state="translated">이 함수는 경로 목록을 경로로 변환하는 데 사용해야합니다. 연결시 후행 슬래시가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f72643333bea463c7a8ea5767e80e22d1a7036bf" translate="yes" xml:space="preserve">
          <source>This function should be used to remove a specific extension which may or may not be there.</source>
          <target state="translated">이 기능은 존재하거나 존재하지 않을 수있는 특정 확장자를 제거하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fc59171af9c1101b367bf06403fbdf95aa428ac" translate="yes" xml:space="preserve">
          <source>This function should either return &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; if startup is successful. &lt;code&gt;pid&lt;/code&gt; should be the PID of the top supervisor. &lt;code&gt;state&lt;/code&gt; can be an arbitrary term, and if omitted will default to &lt;code&gt;[]&lt;/code&gt;; if the application is later stopped, &lt;code&gt;state&lt;/code&gt; is passed to the &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback (see the documentation for the &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback for more information).</source>
          <target state="translated">시작에 성공하면 이 함수는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 또는 &lt;code&gt;{:ok, pid, state}&lt;/code&gt; 를 반환해야합니다 . &lt;code&gt;pid&lt;/code&gt; 는 최고 감독자의 PID 여야합니다. &lt;code&gt;state&lt;/code&gt; 는 임의의 용어 일 수 있으며 생략하면 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다 . 응용 프로그램이 나중에 중지되면 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 콜백으로 전달됩니다 (자세한 내용은 &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 콜백 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="21a65796034b404efe85bb5cf745e9599f9e6028" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</source>
          <target state="translated">이 기능은 애플리케이션 코드에서 런타임에 사용해서는 안됩니다 (믹스 작업과 같은 인프라 및 빌드 코드와 반대). Mix는 빌드 도구이며 코드가 컴파일 된 후 (예 : 릴리스에서) 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d9efdf471f60e2ed682dd93f955c9a027ea855c" translate="yes" xml:space="preserve">
          <source>This function should not be used at runtime in application code (see &lt;a href=&quot;#env/0&quot;&gt;&lt;code&gt;env/0&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">이 기능은 응용 프로그램 코드에서 런타임시 사용해서는 안됩니다 (자세한 내용은 &lt;a href=&quot;#env/0&quot;&gt; &lt;code&gt;env/0&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bf1fdd59778e871792165fd9cd597befae6dbe8a" translate="yes" xml:space="preserve">
          <source>This function should return &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if the key exists in the term, or &lt;code&gt;:error&lt;/code&gt; if the key does not exist in the term.</source>
          <target state="translated">이 기능은 반환해야합니다 &lt;code&gt;{:ok, value}&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 아래의 값이 &lt;code&gt;key&lt;/code&gt; 키가 장기에 존재하는 경우, 또는 &lt;code&gt;:error&lt;/code&gt; 키가 용어에 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="ec58ff70bd307ba9cba1f4ad5eec25344d58ad92" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="translated">This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt;. Everywhere else, &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Algebra.html#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt; should be preferred as it handles structs and exceptions.</target>
        </trans-unit>
        <trans-unit id="4e0b499c79fbb5106ff12e9b189fd33d1ca2f878" translate="yes" xml:space="preserve">
          <source>This function shouldn't be invoked directly, unless when implementing a custom &lt;code&gt;inspect_fun&lt;/code&gt; to be given to &lt;a href=&quot;inspect.opts&quot;&gt;&lt;code&gt;Inspect.Opts&lt;/code&gt;&lt;/a&gt;. Everywhere else, &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt;&lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt;&lt;/a&gt; should be preferred as it handles structs and exceptions.</source>
          <target state="translated">사용자 정의 구현할 때하지 않는 한이 기능은, 직접 호출해서는 안 &lt;code&gt;inspect_fun&lt;/code&gt; 하는 것은 부여 할 &lt;a href=&quot;inspect.opts&quot;&gt; &lt;code&gt;Inspect.Opts&lt;/code&gt; &lt;/a&gt; . 다른 곳에서는 &lt;a href=&quot;inspect.algebra#to_doc/2&quot;&gt; &lt;code&gt;Inspect.Algebra.to_doc/2&lt;/code&gt; &lt;/a&gt; 가 구조체와 예외를 처리하므로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7b31de7bb27ac0e240dd4370dcbe439841a348" translate="yes" xml:space="preserve">
          <source>This function simply reads the configuration value for &lt;code&gt;:ansi_enabled&lt;/code&gt; in the &lt;code&gt;:elixir&lt;/code&gt; application. The value is by default &lt;code&gt;false&lt;/code&gt; unless Elixir can detect during startup that both &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; are terminals.</source>
          <target state="translated">이 함수는 단순히 &lt;code&gt;:elixir&lt;/code&gt; 응용 프로그램 에서 &lt;code&gt;:ansi_enabled&lt;/code&gt; 의 구성 값을 읽습니다 . Elixir가 시작 중에 &lt;code&gt;stdout&lt;/code&gt; 과 &lt;code&gt;stderr&lt;/code&gt; 이 모두 터미널 임을 감지 할 수 없으면 값은 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="334f3d5e4471a23891371c10f4d6629f6f864306" translate="yes" xml:space="preserve">
          <source>This function spawns a process that is linked to and monitored by the caller process. The linking part is important because it aborts the task if the parent process dies. It also guarantees the code before async/await has the same properties after you add the async call. For example, imagine you have this:</source>
          <target state="translated">이 함수는 호출자 프로세스에 연결되고 모니터되는 프로세스를 생성합니다. 부모 프로세스가 종료되면 연결 부분이 작업을 중단하기 때문에 연결 부분이 중요합니다. 또한 비동기 호출을 추가 한 후 async / await가 동일한 속성을 갖기 전에 코드를 보장합니다. 예를 들어, 이것을 가지고 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="c734a84fb40ac9d66210c296db69e31b0a02eadc" translate="yes" xml:space="preserve">
          <source>This function splits the given &lt;code&gt;string&lt;/code&gt; into a list of strings in a similar way to many shells.</source>
          <target state="translated">이 함수 는 많은 문자열과 비슷한 방식으로 주어진 &lt;code&gt;string&lt;/code&gt; 을 문자열 목록으로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2d261f9369eef612d3e5142c44d6cc0051a05a" translate="yes" xml:space="preserve">
          <source>This function takes the same options as &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This function takes the same options as &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2feb07f1ca6bdd2a159c3be3d1d2d967088b7ce0" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#expand_once/2&quot;&gt;&lt;code&gt;expand_once/2&lt;/code&gt;&lt;/a&gt; under the hood. Check it out for more information and examples.</source>
          <target state="translated">이 함수는 후드 아래에서 &lt;a href=&quot;#expand_once/2&quot;&gt; &lt;code&gt;expand_once/2&lt;/code&gt; &lt;/a&gt; 를 사용합니다. 자세한 내용과 예제를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6e2fc530fdd36a8deb023fe2c739cc5eac5cf4d5" translate="yes" xml:space="preserve">
          <source>This function uses Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt;&lt;code&gt;:rand&lt;/code&gt; module&lt;/a&gt; to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</source>
          <target state="translated">이 함수는 Erlang의 &lt;a href=&quot;http://www.erlang.org/doc/man/rand.html&quot;&gt; &lt;code&gt;:rand&lt;/code&gt; 모듈&lt;/a&gt; 을 사용하여 임의의 값을 계산합니다. 다른 임의 알고리즘 또는 다른 시드 설정에 대한 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="97aac23199beb8d9422f08074a16068341921614" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">이 함수는 &lt;code&gt;key&lt;/code&gt; 가 함수가 아니라면 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 순회합니다 .</target>
        </trans-unit>
        <trans-unit id="f5a185e1be937b1dd6a14d707efd0c65f663b9df" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">This function uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt; , unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</target>
        </trans-unit>
        <trans-unit id="8aa0a6bd6b734aebad750c42bf0f37171db0b991" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; environment variable and falls back to &lt;code&gt;EDITOR&lt;/code&gt; if the former is not available.</source>
          <target state="translated">이 함수는 &lt;code&gt;ELIXIR_EDITOR&lt;/code&gt; 환경 변수를 사용하고 전자를 사용할 수없는 경우 &lt;code&gt;EDITOR&lt;/code&gt; 로폴백 합니다 .</target>
        </trans-unit>
        <trans-unit id="b61a016ed8075bfc5c39ffca808acebff61a6a18" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. Do not use this function to sort structs, see &lt;a href=&quot;#sort/2&quot;&gt;&lt;code&gt;sort/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">This function uses the merge sort algorithm. Do not use this function to sort structs, see &lt;a href=&quot;#sort/2&quot;&gt; &lt;code&gt;sort/2&lt;/code&gt; &lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="a8837dfaf4412802924cfa8f14dc7efe7bf20108" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes or is in the same place as the second one.</source>
          <target state="translated">This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes or is in the same place as the second one.</target>
        </trans-unit>
        <trans-unit id="9cbfcbb53a61b66a747c2491e188753fa8068b44" translate="yes" xml:space="preserve">
          <source>This function uses the merge sort algorithm. The given function should compare two arguments, and return &lt;code&gt;true&lt;/code&gt; if the first argument precedes the second one.</source>
          <target state="translated">이 함수는 병합 정렬 알고리즘을 사용합니다. 주어진 함수는 두 개의 인수를 비교 하고 첫 번째 인수가 두 번째 인수 앞에 오면 &lt;code&gt;true&lt;/code&gt; 를 리턴 해야합니다.</target>
        </trans-unit>
        <trans-unit id="862ee811fb4cabde3cfb7ab7a9097a9d6c254988" translate="yes" xml:space="preserve">
          <source>This function uses the parsing regular expression as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986, Appendix B&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#appendix-B&quot;&gt;RFC 3986, 부록 B에&lt;/a&gt; 정의 된 구문 분석 정규식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d26051019e95731e1d7b99be08f5928a37367d27" translate="yes" xml:space="preserve">
          <source>This function was designed to camelize language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">이 함수는 언어 식별자 / 토큰을 카멜 리즈하도록 설계되었으므로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt; 모듈에 속합니다 . Elixir 식별자에서 유효하지 않은 유니 코드 또는 문자를 지원하지 않으므로 문자열을 카멜 리자 잉 문자열에 대한 일반적인 메커니즘으로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="582211980e20afdfe93b93a25608463f5c56a8bf" translate="yes" xml:space="preserve">
          <source>This function was designed to underscore language identifiers/tokens, that's why it belongs to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro&lt;/code&gt;&lt;/a&gt; module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</source>
          <target state="translated">이 함수는 언어 식별자 / 토큰을 강조하기 위해 설계되었으므로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt; 모듈에 속합니다 . Elixir 식별자에서 유효하지 않은 유니 코드 또는 문자를 지원하지 않으므로 문자열 밑줄을위한 일반적인 메커니즘으로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ddcb598fb0ce62c01ead735edd62ec7ef5afb147" translate="yes" xml:space="preserve">
          <source>This function will instrument the given module and load a new version in memory with breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</source>
          <target state="translated">이 함수는 주어진 모듈을 계측하고 주어진 함수와 arity에 중단 점이있는 메모리에 새 버전을로드합니다. 모듈이 다시 컴파일되면 모든 중단 점이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8f47c44e23aa37c7285c683f845cd5e9a96e09" translate="yes" xml:space="preserve">
          <source>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to &lt;code&gt;nil&lt;/code&gt;, which will remove that key from the metadata.</source>
          <target state="translated">이 함수는 키를 &lt;code&gt;nil&lt;/code&gt; 로 설정하는 것을 제외하고는 주어진 키워드 목록을 기존 메타 데이터로 병합하여 메타 데이터에서 해당 키를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="11a397f1ed689beeb86c4bc32143ddefc115ba76" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;functionclauseerror&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="translated">주어진 &lt;code&gt;node&lt;/code&gt; 가 존재하지 않으면 이 함수는 &lt;a href=&quot;functionclauseerror&quot;&gt; &lt;code&gt;FunctionClauseError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d3549fd2102012a4f6115406e1d4d00d9843abf5" translate="yes" xml:space="preserve">
          <source>This function will raise &lt;a href=&quot;https://hexdocs.pm/elixir/FunctionClauseError.html&quot;&gt;&lt;code&gt;FunctionClauseError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</source>
          <target state="translated">This function will raise &lt;a href=&quot;https://hexdocs.pm/elixir/FunctionClauseError.html&quot;&gt; &lt;code&gt;FunctionClauseError&lt;/code&gt; &lt;/a&gt; if the given &lt;code&gt;node&lt;/code&gt; is not alive.</target>
        </trans-unit>
        <trans-unit id="e6b9fdfcab204aeb9ec68e1e7116d2ac8debacde" translate="yes" xml:space="preserve">
          <source>This function will retrieve the available clauses from bytecode and evaluate them against the given arguments. The clauses are returned as a list of &lt;code&gt;{args, guards}&lt;/code&gt; pairs where each argument and each top-level condition in a guard separated by &lt;code&gt;and&lt;/code&gt;/&lt;code&gt;or&lt;/code&gt; is wrapped in a tuple with blame metadata.</source>
          <target state="translated">이 함수는 바이트 코드에서 사용 가능한 절을 검색하여 주어진 인수에 대해 평가합니다. 이 절은 &lt;code&gt;{args, guards}&lt;/code&gt; 쌍 의 목록으로 리턴되며 여기서 가드의 각 인수 및 각 최상위 레벨 조건은 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 분리되어 Blame 메타 데이터가있는 튜플에 랩됩니다.</target>
        </trans-unit>
        <trans-unit id="029c82ca4692615f6cc90f101026e01c3b5dc4e0" translate="yes" xml:space="preserve">
          <source>This functionality starts the &lt;code&gt;:net_kernel&lt;/code&gt; and other related processes.</source>
          <target state="translated">이 기능은 &lt;code&gt;:net_kernel&lt;/code&gt; 및 기타 관련 프로세스를 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="a5c0fe11d15d66b3e64978f03cccbe68ad69f39c" translate="yes" xml:space="preserve">
          <source>This guarantees all messages sent to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; prior to this call will be processed. This is useful for testing and it should not be called in production code.</source>
          <target state="translated">이렇게 하면이 호출 전에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 로&lt;/a&gt; 전송 된 모든 메시지 가 처리됩니다. 이것은 테스트에 유용하며 프로덕션 코드에서 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="931eb8597cbb84926c09fb6a3b1aa749f547e621" translate="yes" xml:space="preserve">
          <source>This guide aims to introduce the meta-programming techniques available in Elixir. The ability to represent an Elixir program by its own data structures is at the heart of meta-programming. This chapter starts by exploring those structures and the associated &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt; constructs, so we can take a look at macros in the next chapter and finally build our own domain specific language.</source>
          <target state="translated">이 안내서는 Elixir에서 사용할 수있는 메타 프로그래밍 기술을 소개합니다. 자체 데이터 구조로 Elixir 프로그램을 표현할 수있는 능력은 메타 프로그래밍의 핵심입니다. 이 장에서는 그 구조와 관련된 탐구하는 것으로 시작 &lt;code&gt;quote&lt;/code&gt; 과 &lt;code&gt;unquote&lt;/code&gt; 우리는 다음 장에서 매크로를 살펴보고 마지막으로 우리 자신의 도메인 특정 언어를 구축 할 수 있도록 구조를.</target>
        </trans-unit>
        <trans-unit id="217ac3dbe93c0cad13af56d1e1ef16871421d82f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C%3E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="5849b2456045ed3a32dde6f55db3e066f023528f" translate="yes" xml:space="preserve">
          <source>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator &lt;a href=&quot;kernel#%253C%253E/2&quot;&gt;&lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">코드 의미를 변경하지 않고 포맷터가 새 줄을 도입 할 수있는 유일한 위치는 보간에 있기 때문입니다. 이러한 시나리오에서는 개발자가 코드를 직접 조정하는 것이 좋습니다. 여기서 이진 연결 연산자 &lt;a href=&quot;kernel#%253C%253E/2&quot;&gt; &lt;code&gt;&amp;lt;&amp;gt;/2&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccb1f24686f9c6bcd91b3b281d116c9f04cb68f5" translate="yes" xml:space="preserve">
          <source>This helper only works when IEx is started with a Mix project, for example, &lt;code&gt;iex -S mix&lt;/code&gt;. The application is not restarted after compilation, which means any long running process may crash as any changed module will be temporarily removed and recompiled, without going through the proper code changes callback.</source>
          <target state="translated">이 도우미는 IEx가 Mix 프로젝트 (예 : &lt;code&gt;iex -S mix&lt;/code&gt; )로 시작된 경우에만 작동합니다 . 컴파일 후 응용 프로그램이 다시 시작되지 않습니다. 즉, 적절한 코드 변경 콜백을 거치지 않고 변경된 모듈이 일시적으로 제거되고 다시 컴파일되므로 장기 실행 프로세스가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af9ea0d60815c82f22be854ae11982e7962bd190" translate="yes" xml:space="preserve">
          <source>This implementation also adds &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#next_break_fits/2&quot;&gt;&lt;code&gt;next_break_fits/2&lt;/code&gt;&lt;/a&gt; which give more control over the document fitting.</source>
          <target state="translated">이 구현은 또한 문서 피팅을보다 강력하게 제어 할 수있는 &lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#next_break_fits/2&quot;&gt; &lt;code&gt;next_break_fits/2&lt;/code&gt; &lt;/a&gt; 를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ecf1cb6c3f0131a137b0e41a93d52ab7359f8a7c" translate="yes" xml:space="preserve">
          <source>This implementation provides two types of breaks: &lt;code&gt;:strict&lt;/code&gt; and &lt;code&gt;:flex&lt;/code&gt;. When a group does not fit, all strict breaks are treated as newlines. Flex breaks however are re-evaluated on every occurrence and may still be rendered flat. See &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 구현은 &lt;code&gt;:strict&lt;/code&gt; 및 &lt;code&gt;:flex&lt;/code&gt; 의 두 가지 유형의 구분을 제공합니다 . 그룹이 적합하지 않으면 모든 엄격한 휴식이 줄 바꿈으로 처리됩니다. 그러나 플렉스 브레이크는 모든 상황에서 다시 평가되며 여전히 평평하게 렌더링 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc54167321bb690ef67cdb4d7c3892839915a92e" translate="yes" xml:space="preserve">
          <source>This information is returned based on the code path. Here is an example:</source>
          <target state="translated">이 정보는 코드 경로에 따라 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0ecce7e0d6c0fe3474303fad5ddb7ee794ff9c6" translate="yes" xml:space="preserve">
          <source>This interpretation is the same regardless if &lt;code&gt;--source&lt;/code&gt; or &lt;code&gt;--sink&lt;/code&gt; flags are used. For example, if we use the &lt;code&gt;--sink lib/c.ex&lt;/code&gt; flag, we would see the same tree:</source>
          <target state="translated">This interpretation is the same regardless if &lt;code&gt;--source&lt;/code&gt; or &lt;code&gt;--sink&lt;/code&gt; flags are used. For example, if we use the &lt;code&gt;--sink lib/c.ex&lt;/code&gt; flag, we would see the same tree:</target>
        </trans-unit>
        <trans-unit id="d91881e1d6ed1dd4db7e1e2c49686c721a6638ef" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell when the &lt;code&gt;MIX_QUIET&lt;/code&gt; environment variable is set.</source>
          <target state="translated">This is Mix's default shell when the &lt;code&gt;MIX_QUIET&lt;/code&gt; environment variable is set.</target>
        </trans-unit>
        <trans-unit id="60031e59b55c11c2eb9a171c6db3ebaf52a6c050" translate="yes" xml:space="preserve">
          <source>This is Mix's default shell.</source>
          <target state="translated">이것은 믹스의 기본 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="5053391a8e72e9d443f680cf9656acc6cdd0a4d5" translate="yes" xml:space="preserve">
          <source>This is a bad idea, as we don&amp;rsquo;t want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.</source>
          <target state="translated">버킷이 충돌 할 때 레지스트리가 충돌하는 것을 원하지 않기 때문에 이것은 나쁜 생각입니다. 올바른 수정은 실제로 버킷을 레지스트리에 연결하지 않는 것입니다. 대신 각 버킷을 수퍼바이저라는 특수 유형의 프로세스에 연결합니다.이 프로세스는 장애 및 충돌을 처리하도록 명시 적으로 설계되었습니다. 다음 장에서 이에 대해 자세히 알아볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e5ab726c57b0fb6f6da70a28676a9b1f70f7bab" translate="yes" xml:space="preserve">
          <source>This is a hard-deprecation as it emits warnings and annotates the documentation as deprecated:</source>
          <target state="translated">이것은 경고를 표시하고 더 이상 사용되지 않는 것으로 문서에 주석을 달기 때문에 사용이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="c34842432839543d617525657c5d1288600c6c0e" translate="yes" xml:space="preserve">
          <source>This is a soft-deprecation as it simply annotates the documentation as deprecated:</source>
          <target state="translated">이것은 더 이상 사용되지 않는 것으로 문서에 주석을 달기 때문에 소프트 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b525f4650716afc52d0be5f7a029605ace74f36" translate="yes" xml:space="preserve">
          <source>This is a task that can be aliased by projects that need to execute certain tasks before compiling dependencies:</source>
          <target state="translated">This is a task that can be aliased by projects that need to execute certain tasks before compiling dependencies:</target>
        </trans-unit>
        <trans-unit id="77df0c1b4e2776653e0c5177f9ffa6268916531c" translate="yes" xml:space="preserve">
          <source>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</source>
          <target state="translated">이것은 실제로 매크로를 개발할 때 흔히 발생하는 함정입니다. 우리는 매크로에서 특정 모양을 가정합니다. 우리는 따옴표로 묶인 표현식 안의 변수를 인용하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc899362b8fa129cf65071f623d739413cc73aa" translate="yes" xml:space="preserve">
          <source>This is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.</source>
          <target state="translated">이것은 모두 훌륭하지만 여전히 구현 세부 정보를 숨길 수있는 API를 사용자에게 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f7b133b5999cc2d686bfdd612eea0550282bc0a5" translate="yes" xml:space="preserve">
          <source>This is also the syntax that Elixir uses to inspect keyword lists:</source>
          <target state="translated">이것은 또한 Elixir가 키워드 목록을 검사하는 데 사용하는 구문입니다.</target>
        </trans-unit>
        <trans-unit id="695d7b0825ac4fbdcbd163159a7fc336c49f943b" translate="yes" xml:space="preserve">
          <source>This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly:</source>
          <target state="translated">이것은 안티 패턴이며 이는 계산기 로직을 ​​복잡하게 할뿐만 아니라 계산기 로직을 ​​단일 프로세스 뒤에 배치하여 잠재적으로 시스템의 병목 현상이 발생할 가능성이 있으며 특히 통화 수가 증가 할 때 발생합니다. 대신 함수를 직접 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="9d1d1dd333c995d40a1c0f70de189cf4bf055fbb" translate="yes" xml:space="preserve">
          <source>This is an extension of &lt;a href=&quot;#myers_difference/2&quot;&gt;&lt;code&gt;myers_difference/2&lt;/code&gt;&lt;/a&gt; where a &lt;code&gt;diff_script&lt;/code&gt; function can be given in case it is desired to compute nested differences. The function may return a list with the inner edit script or &lt;code&gt;nil&lt;/code&gt; in case there is no such script. The returned inner edit script will be under the &lt;code&gt;:diff&lt;/code&gt; key.</source>
          <target state="translated">이것의 확장 &lt;a href=&quot;#myers_difference/2&quot;&gt; &lt;code&gt;myers_difference/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;diff_script&lt;/code&gt; 중첩 차이를 계산하는 것이 요구되는 경우 기능을들 수있다. 이 함수는 내부 편집 스크립트가있는 목록을 반환하거나 해당 스크립트 가없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 할 수 있습니다 . 반환 된 내부 편집 스크립트는 &lt;code&gt;:diff&lt;/code&gt; 키 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c0d7fab04e5bf783756a7f428e6b36128d23270" translate="yes" xml:space="preserve">
          <source>This is an optimization for &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;enumerable |&amp;gt; Enum.reverse() |&amp;gt; Enum.concat(tail)&lt;/code&gt; 대한 최적화입니다 .</target>
        </trans-unit>
        <trans-unit id="b8a27bb1d6f71fa4c6c204cb8cc47805a7ed11d7" translate="yes" xml:space="preserve">
          <source>This is an option determining the prompt displayed to the user when awaiting input.</source>
          <target state="translated">입력을 기다릴 때 사용자에게 표시되는 프롬프트를 결정하는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="aae1c3bc3412e0ceca9643bedadc02d43a2f03a1" translate="yes" xml:space="preserve">
          <source>This is because by the time Elixir starts, Erlang's kernel has already been started, which means the configuration above would have no effect.</source>
          <target state="translated">This is because by the time Elixir starts, Erlang's kernel has already been started, which means the configuration above would have no effect.</target>
        </trans-unit>
        <trans-unit id="d40bb6ddf99cda982a812b8ae52262c178bb85e3" translate="yes" xml:space="preserve">
          <source>This is because the macro is expecting its arguments to be a keyword list at &lt;strong&gt;compilation&lt;/strong&gt; time. Since in the example above we are passing the representation of the variable &lt;code&gt;kv&lt;/code&gt;, our code fails.</source>
          <target state="translated">이는 매크로가 &lt;strong&gt;컴파일&lt;/strong&gt; 시 인수가 키워드 목록이되기를 기대하기 때문 입니다. 위의 예제에서 변수 &lt;code&gt;kv&lt;/code&gt; 의 표현을 전달하므로 코드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="69794bbecc9e248ec94d8fbad95cc7668576d9ad" translate="yes" xml:space="preserve">
          <source>This is done by loading &lt;code&gt;config/runtime.exs&lt;/code&gt; if one exists.</source>
          <target state="translated">This is done by loading &lt;code&gt;config/runtime.exs&lt;/code&gt; if one exists.</target>
        </trans-unit>
        <trans-unit id="21f107c1b12d2af11cc6fc5fce200280f5598e01" translate="yes" xml:space="preserve">
          <source>This is either a plain PID or a value representing a registered name. See the &quot;Name registration&quot; section of this document for more information.</source>
          <target state="translated">이것은 일반 PID이거나 등록 된 이름을 나타내는 값입니다. 자세한 내용은이 문서의 &quot;이름 등록&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08a0e9ee70b7df166382e2da0f79cdb8aafbbed0" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used much less frequently here).</source>
          <target state="translated">This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used much less frequently here).</target>
        </trans-unit>
        <trans-unit id="b9679cc98b384d2fae74f5c4e147d814a3605b34" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;else if&lt;/code&gt; clauses in many imperative languages (although used way less frequently here).</source>
          <target state="translated">이것은 많은 명령형 언어의 &lt;code&gt;else if&lt;/code&gt; 절 과 동일합니다 (여기서는 자주 사용되지는 않지만).</target>
        </trans-unit>
        <trans-unit id="20b3f3a29153ddca60608cf1ff19217f8f298150" translate="yes" xml:space="preserve">
          <source>This is implemented as a macro so it can be used in guard clauses.</source>
          <target state="translated">이것은 매크로로 구현되어 가드 절에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ca1cc005536f5b89386dac5e9eaab2c71326b3" translate="yes" xml:space="preserve">
          <source>This is in contrast to &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt; which splits the entire string upfront.</source>
          <target state="translated">이것은 전체 문자열을 미리 분할하는 &lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;split/3&lt;/code&gt; &lt;/a&gt; 와 대조적 입니다.</target>
        </trans-unit>
        <trans-unit id="d6a69df7f8c6fe2ffd7e21f569ce958484e18a07" translate="yes" xml:space="preserve">
          <source>This is mainly useful in tests, allowing us to assert if given messages were received or not instead of performing checks on some captured IO. Since we need to guarantee a clean slate between tests, there is also a &lt;a href=&quot;#flush/1&quot;&gt;&lt;code&gt;flush/1&lt;/code&gt;&lt;/a&gt; function responsible for flushing all &lt;code&gt;:mix_shell&lt;/code&gt; related messages from the process inbox.</source>
          <target state="translated">이것은 주로 테스트에 유용하며, 일부 캡처 된 IO에서 검사를 수행하는 대신 지정된 메시지를 받았는지 여부를 확인할 수 있습니다. 테스트 사이에 깨끗한 슬레이트를 보장해야하므로 프로세스받은 편지함에서 모든 &lt;code&gt;:mix_shell&lt;/code&gt; 관련 메시지를 &lt;a href=&quot;#flush/1&quot;&gt; &lt;code&gt;flush/1&lt;/code&gt; &lt;/a&gt; 하는 flush / 1 함수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0fa3a9b78fa54d020541ab16426b8460b60af20" translate="yes" xml:space="preserve">
          <source>This is most commonly used by shell implementations but can also be invoked directly.</source>
          <target state="translated">This is most commonly used by shell implementations but can also be invoked directly.</target>
        </trans-unit>
        <trans-unit id="72d44ff95753d13859fe1556278fcc193088f3be" translate="yes" xml:space="preserve">
          <source>This is most often used to execute conditional code:</source>
          <target state="translated">This is most often used to execute conditional code:</target>
        </trans-unit>
        <trans-unit id="06d6ae37e05a3ae9f28e4ea5d06be5fb1cde0b89" translate="yes" xml:space="preserve">
          <source>This is often represented in the form of target triples, for example, &lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt;, &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt;, &lt;code&gt;x86_64-apple-darwin&lt;/code&gt;.</source>
          <target state="translated">This is often represented in the form of target triples, for example, &lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt; , &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; , &lt;code&gt;x86_64-apple-darwin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3cb696d174caaa2396a3c713ad639f81cfe5da1" translate="yes" xml:space="preserve">
          <source>This is often used to emulate configuration across environments:</source>
          <target state="translated">이것은 종종 여러 환경에서 구성을 에뮬레이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="58dabc93b2ce93a10dc83d366ab232e1eea3c140" translate="yes" xml:space="preserve">
          <source>This is often used to start the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; as part of a supervision tree.</source>
          <target state="translated">이것은 감독 트리의 일부로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 시작하는 데 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="320f2d885658e9db2171a44a753f72f41faf6056" translate="yes" xml:space="preserve">
          <source>This is often used to start the agent as part of a supervision tree.</source>
          <target state="translated">이것은 종종 감독 트리의 일부로 에이전트를 시작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="626d510108035955935a541c301f344a380255ad" translate="yes" xml:space="preserve">
          <source>This is often used to start the process as part of a supervision tree.</source>
          <target state="translated">이것은 종종 감독 트리의 일부로 프로세스를 시작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71cf2a71b0daa952a75b8e9a75ad4350e4dc2204" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="translated">This is often useful when used with &lt;a href=&quot;#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</target>
        </trans-unit>
        <trans-unit id="30067513715299ced12cf77d1d47bd85e8cef7ec" translate="yes" xml:space="preserve">
          <source>This is often useful when used with &lt;a href=&quot;macro#prewalk/2&quot;&gt;&lt;code&gt;Macro.prewalk/2&lt;/code&gt;&lt;/a&gt; to remove information like lines and hygienic counters from the expression for either storage or comparison.</source>
          <target state="translated">이것은 저장 또는 비교를 위해 식에서 행 및 위생 카운터와 같은 정보를 제거하기 위해 &lt;a href=&quot;macro#prewalk/2&quot;&gt; &lt;code&gt;Macro.prewalk/2&lt;/code&gt; &lt;/a&gt; 와 함께 사용될 때 종종 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4240cfedebaf42c2fac3f95a041f2d57c453967e" translate="yes" xml:space="preserve">
          <source>This is only used when the task is used for side-effects (i.e. no interest in the returned result) and it should not be linked to the current process.</source>
          <target state="translated">이는 작업이 부작용에 사용되는 경우에만 사용되며 (즉, 반환 된 결과에 관심이 없음) 현재 프로세스에 연결되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="077e7548b6aaec650e916de489ebe79d6d5f3c44" translate="yes" xml:space="preserve">
          <source>This is pretty much all we need to implement our echo server. Let&amp;rsquo;s give it a try!</source>
          <target state="translated">이것이 에코 서버를 구현하는 데 필요한 전부입니다. 한번 해보자!</target>
        </trans-unit>
        <trans-unit id="6e08b933f971cdb50d5df304426433cd92e87e4c" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">This is reported as &quot;error&quot; in Elixir's logger backends for backwards compatibility reasons.</target>
        </trans-unit>
        <trans-unit id="5ec5639249ca1a34b536a5264b41327593f5fb5f" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;info&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">This is reported as &quot;info&quot; in Elixir's logger backends for backwards compatibility reasons.</target>
        </trans-unit>
        <trans-unit id="a3346bf358b79fcbcf2b055d550e9935fe8f45fd" translate="yes" xml:space="preserve">
          <source>This is reported as &quot;warn&quot; in Elixir's logger backends for backwards compatibility reasons.</source>
          <target state="translated">This is reported as &quot;warn&quot; in Elixir's logger backends for backwards compatibility reasons.</target>
        </trans-unit>
        <trans-unit id="81016b61e7a2b5883ac247d4885c2d149315bdb9" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">이것은 경로가 목록을 전달하지 않고 매크로를 통해 추출된다는 점을 제외하고 &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50c031832816906ca789ff0f4ad1f1b4dfcf5d4e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#pop_in/2&quot;&gt;&lt;code&gt;pop_in/2&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">이것은 경로가 목록을 전달하는 대신 매크로를 통해 추출된다는 점을 제외하고 &lt;a href=&quot;#pop_in/2&quot;&gt; &lt;code&gt;pop_in/2&lt;/code&gt; &lt;/a&gt; 와 유사 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7523a1751f43741a0a08ddae723c5c9199fa87e6" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#put_in/3&quot;&gt;&lt;code&gt;put_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">이것은 경로가 목록을 전달하지 않고 매크로를 통해 추출된다는 점을 제외하고 &lt;a href=&quot;#put_in/3&quot;&gt; &lt;code&gt;put_in/3&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22e8ffb1e74ab770f905747e9a80ef5c0478eb99" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#update_in/3&quot;&gt;&lt;code&gt;update_in/3&lt;/code&gt;&lt;/a&gt;, except the path is extracted via a macro rather than passing a list. For example:</source>
          <target state="translated">이것은 경로가 목록을 전달하지 않고 매크로를 통해 추출된다는 점을 제외하고 &lt;a href=&quot;#update_in/3&quot;&gt; &lt;code&gt;update_in/3&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08ab0b2ff940cf63760635df2e0fe23beb3cbaa7" translate="yes" xml:space="preserve">
          <source>This is similar to the mistake we made when we called &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; straight from the registry. That meant a failure in any bucket would bring the whole registry down.</source>
          <target state="translated">이것은 레지스트리에서 &lt;code&gt;KV.Bucket.start_link/1&lt;/code&gt; 을 직접 호출했을 때의 실수와 비슷합니다 . 이는 모든 버킷의 장애로 인해 전체 레지스트리가 다운 될 수 있음을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="3ba1fb1b640495bd967734dfd1acecd010aa5148" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both &lt;a href=&quot;#char_reserved?/1&quot;&gt;reserved&lt;/a&gt; and &lt;a href=&quot;#char_unreserved?/1&quot;&gt;unreserved characters&lt;/a&gt; are kept unescaped.</source>
          <target state="translated">This is the default used by &lt;a href=&quot;#encode/2&quot;&gt; &lt;code&gt;URI.encode/2&lt;/code&gt; &lt;/a&gt; where both &lt;a href=&quot;#char_reserved?/1&quot;&gt;reserved&lt;/a&gt; and &lt;a href=&quot;#char_unreserved?/1&quot;&gt;unreserved characters&lt;/a&gt; are kept unescaped.</target>
        </trans-unit>
        <trans-unit id="e61420057f50d9b6c715f4347be7ca8efd78730b" translate="yes" xml:space="preserve">
          <source>This is the default used by &lt;a href=&quot;uri#encode/2&quot;&gt;&lt;code&gt;URI.encode/2&lt;/code&gt;&lt;/a&gt; where both reserved and unreserved characters are kept unescaped.</source>
          <target state="translated">이것은 예약 된 문자와 예약되지 않은 문자가 모두 이스케이프되지 않은 &lt;a href=&quot;uri#encode/2&quot;&gt; &lt;code&gt;URI.encode/2&lt;/code&gt; &lt;/a&gt; 에서 사용되는 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="0dc79651e84bb5089915ce0f6bd2c110d8036119" translate="yes" xml:space="preserve">
          <source>This is the function invoked when there is string interpolation.</source>
          <target state="translated">문자열 보간이있을 때 호출되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9b687c89eb6e152da4dd73f09f730d0ddb490ab0" translate="yes" xml:space="preserve">
          <source>This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">Erlang VM이 모듈 코드를 찾는 데 사용하는 디렉토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a08d7b564f58b24087fbb35fa3617eff44897de1" translate="yes" xml:space="preserve">
          <source>This is the moment, in your calendar, when the current day ends and the next day starts.</source>
          <target state="translated">이것은 현재 날짜가 끝나고 다음 날이 시작되는 캘린더의 순간입니다.</target>
        </trans-unit>
        <trans-unit id="9162b52e4ae81113f3c3ee3bea2997ff399ccecc" translate="yes" xml:space="preserve">
          <source>This is the number of days including the fractional part that has passed of the last day since 0000-01-01+00:00T00:00.000000 in ISO 8601 notation (also known as midnight 1 January BC 1 of the proleptic Gregorian calendar).</source>
          <target state="translated">ISO 8601 표기법으로 0000-01-01 + 00 : 00T00 : 00.000000 이후 마지막 날이 지 났던 분수 부분을 포함한 일 수입니다 (도발 력 그레고리력의 BC 1 월 1 일 자정이라고도 함).</target>
        </trans-unit>
        <trans-unit id="289ea50e9ca33fea490350d4d95a5411c3088228" translate="yes" xml:space="preserve">
          <source>This is the same AST as &lt;code&gt;not(left in right)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;not(left in right)&lt;/code&gt; 과 동일한 AST 입니다.</target>
        </trans-unit>
        <trans-unit id="e66f4430d7555e8a783dad322115e9a5ec53c0d1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;#compile_env/3&quot;&gt;&lt;code&gt;compile_env/3&lt;/code&gt;&lt;/a&gt; but it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the configuration is not available.</source>
          <target state="translated">This is the same as &lt;a href=&quot;#compile_env/3&quot;&gt; &lt;code&gt;compile_env/3&lt;/code&gt; &lt;/a&gt; but it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; if the configuration is not available.</target>
        </trans-unit>
        <trans-unit id="a74b9fe2a2d8c864a5673ce9cb8533effa232a81" translate="yes" xml:space="preserve">
          <source>This is the same supervisor as used by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt;&lt;code&gt;ExUnit.Callbacks.start_supervised/2&lt;/code&gt;&lt;/a&gt; and similar, see &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt; module documentation for more information.</source>
          <target state="translated">This is the same supervisor as used by &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised/2&quot;&gt; &lt;code&gt;ExUnit.Callbacks.start_supervised/2&lt;/code&gt; &lt;/a&gt; and similar, see &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; &lt;/a&gt; module documentation for more information.</target>
        </trans-unit>
        <trans-unit id="b6d704491ec250974e27401b8e2b811c3f199e66" translate="yes" xml:space="preserve">
          <source>This is the same template generated by &lt;code&gt;mix new --sup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mix new --sup&lt;/code&gt; 에 의해 생성 된 것과 동일한 템플릿 입니다.</target>
        </trans-unit>
        <trans-unit id="5580fdfd5d3be89e971bd5cfbc417edd38ca5b8e" translate="yes" xml:space="preserve">
          <source>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</source>
          <target state="translated">이것은 Elixir에 표현 블록이있을 때마다 사용되는 특별한 형식입니다. 이 특수 양식은 비공개이며 직접 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7417af7c2a4cf8300b3d4dd8d7d38b6e9711f6" translate="yes" xml:space="preserve">
          <source>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check &lt;a href=&quot;#unescape_string/2&quot;&gt;&lt;code&gt;unescape_string/2&lt;/code&gt;&lt;/a&gt; for information on how to customize the escaping map.</source>
          <target state="translated">이것은 Elixir 작은 따옴표와 큰 따옴표로 묶인 문자열에서 기본적으로 사용되는 탈출 동작입니다. 이스케이프 맵을 사용자 정의하는 방법에 대한 정보는 &lt;a href=&quot;#unescape_string/2&quot;&gt; &lt;code&gt;unescape_string/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="13cd7a952e7bcf9bdf6ec9068841b4aa1581c6f4" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the &quot;Module-based supervisors&quot; section in the module documentation for more information.</source>
          <target state="translated">이것은 일반적으로 모듈 기반 수퍼바이저 의 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백이 끝날 때 호출됩니다 . 자세한 내용은 모듈 설명서의 &quot;모듈 기반 감독자&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3451cd606049c68c6fdb6bd088a1087ca448fd" translate="yes" xml:space="preserve">
          <source>This is typically invoked at the end of the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback of module-based supervisors. See the sections &quot;Module-based supervisors&quot; and &quot;start_link/2, init/2, and strategies&quot; in the module documentation for more information.</source>
          <target state="translated">이것은 일반적으로 모듈 기반 수퍼바이저 의 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백이 끝날 때 호출됩니다 . 자세한 내용은 모듈 설명서의 &quot;모듈 기반 감독자&quot;및 &quot;start_link / 2, init / 2 및 전략&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af7248045672bdf709fa9a7434ee693bbb5b3f33" translate="yes" xml:space="preserve">
          <source>This is used by Elixir's code formatter to avoid breaking code at some specific locations. For example, consider this code:</source>
          <target state="translated">이것은 특정 위치에서 코드가 깨지는 것을 피하기 위해 Elixir의 코드 포맷터에 의해 사용됩니다. 예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b9e62f945dfe72ca17b7bcf35230b54a13d5ce33" translate="yes" xml:space="preserve">
          <source>This is used by third-party projects, like QuickCheck, to implement macros like &lt;code&gt;property/3&lt;/code&gt; that works like &lt;code&gt;test&lt;/code&gt; but instead defines a property. See &lt;a href=&quot;#test/3&quot;&gt;&lt;code&gt;test/3&lt;/code&gt;&lt;/a&gt; implementation for an example of invoking this function.</source>
          <target state="translated">이것은 QuickCheck와 같은 타사 프로젝트에서 &lt;code&gt;test&lt;/code&gt; 처럼 작동 하지만 속성을 정의하는 property &lt;code&gt;property/3&lt;/code&gt; 와 같은 매크로를 구현 하는 데 사용됩니다. 이 함수를 호출하는 예는 &lt;a href=&quot;#test/3&quot;&gt; &lt;code&gt;test/3&lt;/code&gt; &lt;/a&gt; 구현을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37d46fa38c10dd65a76b1733d8c4d14f6e5122f5" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#respawn/0&quot;&gt; &lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt; &lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</target>
        </trans-unit>
        <trans-unit id="7c60447d6bcf0312eb4c4e52c080f8e8aeffd1b2" translate="yes" xml:space="preserve">
          <source>This is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">이는 특정 프로세스에서 실행될 때 특정 코드 청크를 디버깅하는 데 유용합니다. 프로세스는 IEx 명령의 평가자가되고 사용자 정의 그룹 리더를 갖도록 임시로 변경됩니다. 이러한 값은 &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;IEx.Helpers.respawn/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 되돌려집니다. 그러면 새 IEx 쉘이 시작되어 프라이버시가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="aaba5c733f8e5f3a464f80421ccdf2cbfb12126e" translate="yes" xml:space="preserve">
          <source>This is useful if the default value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">이는 기본값이 계산하기에 너무 비싸거나 일반적으로 설정 및 해제가 어려운 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e90f6c096938c0c1b08fe0f1a4ed6112b1726e64" translate="yes" xml:space="preserve">
          <source>This is useful if the value is very expensive to calculate or generally difficult to setup and teardown again.</source>
          <target state="translated">이는 계산하기에 값이 매우 비싸거나 일반적으로 설정 및 분해가 어려운 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7ade3c8c2220433a36448cb76b4d6669b0207f9" translate="yes" xml:space="preserve">
          <source>This is useful in two cases:</source>
          <target state="translated">This is useful in two cases:</target>
        </trans-unit>
        <trans-unit id="5a46a616db1ce450247219cde25e3ee509bdc87d" translate="yes" xml:space="preserve">
          <source>This is useful when a stream needs to be run, for side effects, and there is no interest in its return result.</source>
          <target state="translated">이것은 부작용을 위해 스트림을 실행해야 할 때 유용하며 리턴 결과에 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="64ec9debc1653fe16f8858cb9974d03451f758f7" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled.</source>
          <target state="translated">This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled.</target>
        </trans-unit>
        <trans-unit id="8454071c897ae3b3f6c5cf6b435c8859ed4d0efe" translate="yes" xml:space="preserve">
          <source>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is even capable of expanding structs defined under the module being compiled.</source>
          <target state="translated">컴파일 타임에 구조체를 확장해야하고 확장중인 구조체가 컴파일되었거나 컴파일되지 않았을 때 유용합니다. 이 함수는 컴파일중인 모듈에 정의 된 구조체를 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f647f53c93e0adaedcaedcde7d2a04c6e11b1a" translate="yes" xml:space="preserve">
          <source>This is useful when the result is something variable (like a PID in the example above) or when the result is a complicated data structure and you don't want to show it all, but just parts of it or some of its properties.</source>
          <target state="translated">This is useful when the result is something variable (like a PID in the example above) or when the result is a complicated data structure and you don't want to show it all, but just parts of it or some of its properties.</target>
        </trans-unit>
        <trans-unit id="42708290411e38f509da43bac650f9a95ec98921" translate="yes" xml:space="preserve">
          <source>This is useful when there are a set of setup callbacks or a set of functions that should be shared between test modules.</source>
          <target state="translated">This is useful when there are a set of setup callbacks or a set of functions that should be shared between test modules.</target>
        </trans-unit>
        <trans-unit id="bca60e4733f4f8f89c26ce0231040f2ac6f94040" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="translated">This is usually called by sessions started with &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</target>
        </trans-unit>
        <trans-unit id="5765e6f4f6c943fc2869a6d958ffb07d4ecdc95a" translate="yes" xml:space="preserve">
          <source>This is usually called by sessions started with &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;. This allows the current process to execute until the next breakpoint, which will automatically yield control back to IEx without requesting permission to pry.</source>
          <target state="translated">이것은 일반적으로 &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; 로&lt;/a&gt; 시작된 세션에 의해 호출됩니다 . 이를 통해 현재 프로세스가 다음 중단 점까지 실행될 수 있으며,이 경우 중단 권한을 요청하지 않고 IEx에 대한 제어권이 자동으로 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="9795df452756bfa4ad139a3e1454b0c1c3e19967" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="translated">This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; exception in case no project is available.</target>
        </trans-unit>
        <trans-unit id="d5c28e5992d11ab017599cfba8c0660377868c31" translate="yes" xml:space="preserve">
          <source>This is usually called by tasks that need additional functions on the project to be defined. Since such tasks usually depend on a project being defined, this function raises a &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; exception in case no project is available.</source>
          <target state="translated">일반적으로 프로젝트에서 추가 기능을 정의해야하는 작업에 의해 호출됩니다. 이러한 작업은 일반적으로 정의중인 프로젝트에 의존하기 &lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; 함수 는 프로젝트를 사용할 수없는 경우 Mix.NoProjectError 예외를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="70a55e5fc2aa3b9db64d4f94cf960265a3232cd2" translate="yes" xml:space="preserve">
          <source>This is where protocols can help us: protocols allow us to extend the original behavior for as many data types as we need. That&amp;rsquo;s because &lt;strong&gt;dispatching on a protocol is available to any data type that has implemented the protocol&lt;/strong&gt; and a protocol can be implemented by anyone, at any time.</source>
          <target state="translated">This is where protocols can help us: protocols allow us to extend the original behavior for as many data types as we need. That&amp;rsquo;s because &lt;strong&gt;dispatching on a protocol is available to any data type that has implemented the protocol&lt;/strong&gt; and a protocol can be implemented by anyone, at any time.</target>
        </trans-unit>
        <trans-unit id="b871a08121731acae06ea58fe3ca7e1bb16748e0" translate="yes" xml:space="preserve">
          <source>This keeps only significant chunks necessary for the VM operation, discarding documentation, debug info, compile information and others.</source>
          <target state="translated">This keeps only significant chunks necessary for the VM operation, discarding documentation, debug info, compile information and others.</target>
        </trans-unit>
        <trans-unit id="89c99ecc9ec64bbd119250b6f605dbf4510f1e46" translate="yes" xml:space="preserve">
          <source>This key is optional, only needed for applications that start a supervision tree.</source>
          <target state="translated">이 키는 선택 사항이며 감독 트리를 시작하는 응용 프로그램에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="29ecf7d31c543b3beaa11f8d6b32d12f2cddd50a" translate="yes" xml:space="preserve">
          <source>This lets you put imports in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">이를 통해 모듈을 사용할 수없는 콘솔을 열면 컴파일 오류없이 &lt;code&gt;.iex.exs&lt;/code&gt; 파일 ( &lt;code&gt;~/.iex.exs&lt;/code&gt; 포함) 에 가져 오기를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5847e98d18087e669daaf541b861bb0616506ae" translate="yes" xml:space="preserve">
          <source>This lets you use the module in &lt;code&gt;.iex.exs&lt;/code&gt; files (including &lt;code&gt;~/.iex.exs&lt;/code&gt;) without getting compile errors if you open a console where the module is not available.</source>
          <target state="translated">이를 통해 모듈을 사용할 수 없는 콘솔을 열면 컴파일 오류없이 &lt;code&gt;.iex.exs&lt;/code&gt; 파일 ( &lt;code&gt;~/.iex.exs&lt;/code&gt; 포함 )에서 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e593f23f33013dc92ddfcd3a9c60d10f99bd1858" translate="yes" xml:space="preserve">
          <source>This linear behaviour should also be expected on operations like &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#at/2&quot;&gt;&lt;code&gt;at/2&lt;/code&gt;&lt;/a&gt; and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</source>
          <target state="translated">이 선형 동작은 &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#at/2&quot;&gt; &lt;code&gt;at/2&lt;/code&gt; &lt;/a&gt; 등의 작업에서도 예상됩니다 . Elixir는 데이터 유형이 이러한 작업에 대한 성능 변형을 제공하도록 허용하지만 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈은 다양한 데이터 유형과 함께 작동하도록되어 있으며 모든 데이터 유형이 최적화 된 동작을 제공 할 수있는 것은 아니기 때문에 항상 사용 가능한 것으로 기 대해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0519fbd8b9b5639ec90e00d83250f771f4f40453" translate="yes" xml:space="preserve">
          <source>This macro addresses this issue by checking if the file exists or not in behalf of the user.</source>
          <target state="translated">이 매크로는 파일이 사용자 대신 존재하는지 여부를 확인하여이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="5cc6e8a94ed92b3b0f91dd0c407badd0f4cd9583" translate="yes" xml:space="preserve">
          <source>This macro defines a module with the given &lt;code&gt;alias&lt;/code&gt; as its name and with the given contents. It returns a tuple with four elements:</source>
          <target state="translated">이 매크로는 주어진 &lt;code&gt;alias&lt;/code&gt; 과 이름 및 주어진 내용으로 모듈을 정의합니다 . 네 가지 요소가있는 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba5022c9c8161864d7b55a2f306a7cb1932890b2" translate="yes" xml:space="preserve">
          <source>This macro evaluates and returns the &lt;code&gt;do&lt;/code&gt; block passed in as the second argument if &lt;code&gt;condition&lt;/code&gt; evaluates to a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;). Otherwise, it returns the value of the &lt;code&gt;else&lt;/code&gt; block if present or &lt;code&gt;nil&lt;/code&gt; if not.</source>
          <target state="translated">이 매크로는 &lt;code&gt;condition&lt;/code&gt; 이 잘못된 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; )으로 평가 되면 두 번째 인수로 전달 된 &lt;code&gt;do&lt;/code&gt; 블록을 평가하고 리턴합니다 . 그렇지 않으면 &lt;code&gt;else&lt;/code&gt; 블록 의 값이 있으면 반환하고, 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed734b49c8a157748138d4db51538d7e06cee2ee" translate="yes" xml:space="preserve">
          <source>This macro expects a variable and it is typically invoked inside &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt; to mark that a variable should not be hygienized. See &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">This macro expects a variable and it is typically invoked inside &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; to mark that a variable should not be hygienized. See &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="053dc4326086a38d85524369b85300ca1b5d0614" translate="yes" xml:space="preserve">
          <source>This macro expects the first argument to be a condition and the second argument to be a keyword list.</source>
          <target state="translated">이 매크로는 첫 번째 인수가 조건이고 두 번째 인수는 키워드 목록이 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="09100845f4d4f229d78b6113f1e6a5dce38e078d" translate="yes" xml:space="preserve">
          <source>This macro is auto-imported with every &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This macro is auto-imported with every &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="116b64f16c1348abfeaaf5c29004dd2cd4513959" translate="yes" xml:space="preserve">
          <source>This macro is deprecated in favour of &lt;a href=&quot;#warning/2&quot;&gt;&lt;code&gt;warning/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">This macro is deprecated in favour of &lt;a href=&quot;#warning/2&quot;&gt; &lt;code&gt;warning/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1884b82116e213d51fde668f93db8aefff68f2db" translate="yes" xml:space="preserve">
          <source>This macro is deprecated. Use the Config module instead.</source>
          <target state="translated">This macro is deprecated. Use the Config module instead.</target>
        </trans-unit>
        <trans-unit id="fa58f8e50bd6c8d47ad7511ec3aec19833923a02" translate="yes" xml:space="preserve">
          <source>This macro is used to generate ExUnit test cases for doctests.</source>
          <target state="translated">This macro is used to generate ExUnit test cases for doctests.</target>
        </trans-unit>
        <trans-unit id="b7318b11fdb5ce2984ea08a62c18118bc9d28bcc" translate="yes" xml:space="preserve">
          <source>This makes your code clearer and easier to test and maintain, as you can invoke and test &lt;code&gt;do_this_that_and_that/3&lt;/code&gt; directly. It also helps you design an actual API for developers that do not want to rely on macros.</source>
          <target state="translated">&lt;code&gt;do_this_that_and_that/3&lt;/code&gt; 을 직접 호출하고 테스트 할 수 있으므로 코드를보다 명확하고 쉽게 테스트하고 유지 관리 할 수 있습니다. 또한 매크로에 의존하고 싶지 않은 개발자를위한 실제 API를 설계하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="781a3479b6ef9afbd878f1e315bbde3afc7381db" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">즉, &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; &lt;/a&gt; 을 확장하여 사용자 정의 조회를 제공 할 수 있습니다. 단점은 기능을 액세스 된 데이터 구조에 키로 저장할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31c83c38260c43e23e00b1d110954e0ba5266ba4" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">This means &lt;a href=&quot;#get_in/2&quot;&gt; &lt;code&gt;get_in/2&lt;/code&gt; &lt;/a&gt; can be extended to provide custom lookups. In the example below, we use a function to get all the maps inside a list:</target>
        </trans-unit>
        <trans-unit id="cfd9674170ea7f680e0ec4f0f9ace7b923ad6168" translate="yes" xml:space="preserve">
          <source>This means &lt;a href=&quot;#get_in/2&quot;&gt;&lt;code&gt;get_in/2&lt;/code&gt;&lt;/a&gt; can be extended to provide custom lookups. The downside is that functions cannot be stored as keys in the accessed data structures.</source>
          <target state="translated">이는 &lt;a href=&quot;#get_in/2&quot;&gt; &lt;code&gt;get_in/2&lt;/code&gt; &lt;/a&gt; 를 확장하여 사용자 정의 조회를 제공 할 수 있음을 의미 합니다. 단점은 기능을 액세스 된 데이터 구조에 키로 저장할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a04c313f02da8b2b423b92a32377c49ecdd6219" translate="yes" xml:space="preserve">
          <source>This means files can be passed between nodes and message passing guarantees they can write to the same file in a network.</source>
          <target state="translated">즉, 노드간에 파일을 전달할 수 있으며 메시지 전달을 통해 네트워크에서 동일한 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e15019a33fea88c51d5e497980380e75ee3dd48" translate="yes" xml:space="preserve">
          <source>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</source>
          <target state="translated">이는 바이너리와 직접 작동하는보다 낮은 수준의 작업과 비교하여이 모듈의 기능을 사용하는 데 종종 성능 비용이 발생한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8571bea1bef1bde6a2d1b2d12776f78df57e4340" translate="yes" xml:space="preserve">
          <source>This means our implementation is going in the correct direction, but it doesn&amp;rsquo;t look very elegant, does it?</source>
          <target state="translated">이것은 우리의 구현이 올바른 방향으로 가고 있음을 의미하지만 매우 우아하게 보이지는 않습니까?</target>
        </trans-unit>
        <trans-unit id="64cb76e001bde4ce0c23b9ae9350ed13f2f87e6d" translate="yes" xml:space="preserve">
          <source>This means reserved characters, such as &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, and the so-called unreserved characters, which have the same meaning both escaped and unescaped, won't be escaped by default.</source>
          <target state="translated">이는 &lt;code&gt;:&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 와 같은 예약 문자를 의미하며, 이스케이프 및 이스케이프되지 않은 동일한 의미를 가진 소위 예약되지 않은 문자는 기본적으로 이스케이프되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="466121cf36d188101adba56c09d86681a5f8592b" translate="yes" xml:space="preserve">
          <source>This means that when performing multiple operations with &lt;code&gt;Enum&lt;/code&gt;, each operation is going to generate an intermediate list until we reach the result:</source>
          <target state="translated">이것은 &lt;code&gt;Enum&lt;/code&gt; 으로 여러 작업을 수행 할 때 각 작업이 결과에 도달 할 때까지 중간 목록을 생성 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e439478d8b723981d4581d054a8682120535699c" translate="yes" xml:space="preserve">
          <source>This means the VM no longer needs to keep the stacktrace once inside an &lt;code&gt;else&lt;/code&gt; clause and so tail recursion is possible when using a &lt;code&gt;try&lt;/code&gt; with a tail call as the final call inside an &lt;code&gt;else&lt;/code&gt; clause. The same is true for &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; clauses.</source>
          <target state="translated">이 수단 VM은 더 이상 내부되면 스택 트레이스를 유지할 필요가 없습니다 &lt;code&gt;else&lt;/code&gt; 절과 사용할 때 꼬리 재귀 수 있도록 &lt;code&gt;try&lt;/code&gt; 내부 최종 호출과 같은 꼬리 호출로 &lt;code&gt;else&lt;/code&gt; 절을. &lt;code&gt;rescue&lt;/code&gt; 및 &lt;code&gt;catch&lt;/code&gt; 절 에서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="03cbb2743a8fea6a87cdaa1b5871df611958047b" translate="yes" xml:space="preserve">
          <source>This means we can also configure our &lt;code&gt;:routing_table&lt;/code&gt; directly in the &lt;code&gt;config/config.exs&lt;/code&gt; file. However, which configuration value should we use?</source>
          <target state="translated">이는 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 &lt;code&gt;:routing_table&lt;/code&gt; 을 직접 구성 할 수도 있음을 의미 합니다. 그러나 어떤 구성 값을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="d88b91b0ac64ad4e82abb4e5d0dae196f85569c8" translate="yes" xml:space="preserve">
          <source>This message was triggered by invoking the helper &lt;code&gt;h()&lt;/code&gt;, usually referred to as &lt;a href=&quot;#h/0&quot;&gt;&lt;code&gt;h/0&lt;/code&gt;&lt;/a&gt; (since it expects 0 arguments).</source>
          <target state="translated">이 메시지는 헬퍼 &lt;code&gt;h()&lt;/code&gt; 를 호출하여 트리거되는데 , 일반적으로 &lt;a href=&quot;#h/0&quot;&gt; &lt;code&gt;h/0&lt;/code&gt; &lt;/a&gt; 이라고합니다 (0 개의 인수가 필요하기 때문에).</target>
        </trans-unit>
        <trans-unit id="0f38cc8ed71ef5111e6f4d0950287ab1718bd370" translate="yes" xml:space="preserve">
          <source>This module allows a developer to define a test case template to be used throughout their tests. This is useful when there are a set of functions that should be shared between tests or a set of setup callbacks.</source>
          <target state="translated">이 모듈을 통해 개발자는 테스트 전체에서 사용할 테스트 케이스 템플릿을 정의 할 수 있습니다. 테스트 또는 설정 콜백간에 공유해야하는 함수 세트가있을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="29465ded0e12b42e58045ba6de87bf204437ce87" translate="yes" xml:space="preserve">
          <source>This module allows developers to specify a string that serves as template for log messages, for example:</source>
          <target state="translated">이 모듈을 통해 개발자는 로그 메시지의 템플릿 역할을하는 문자열을 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4305f790d0ec82e224afef341de114e73b6a1e74" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 또한 ( &lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; ) 과 같은 Elixir의 컴파일 환경에 대한 정보를 리턴하는 매크로를 문서화합니다 .</target>
        </trans-unit>
        <trans-unit id="3741d9dd92ba5c7f8bc185d6546445601bc27a51" translate="yes" xml:space="preserve">
          <source>This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">This module also documents macros that return information about Elixir's compilation environment, such as (&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d8c660841c33dff8911e93abdee348ab3a09d4db" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">This module also includes helpers for debugging purposes, see &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="b8d05e55cf46fce50db35799f75e85316f97b59d" translate="yes" xml:space="preserve">
          <source>This module also includes helpers for debugging purposes, see &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 모듈에는 디버깅을위한 헬퍼도 포함되어 있습니다. 자세한 내용 은 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef6795d77de60f24997761f8faf2a5faa8a9879b" translate="yes" xml:space="preserve">
          <source>This module also provides low-level functions, such as &lt;a href=&quot;#next/2&quot;&gt;&lt;code&gt;next/2&lt;/code&gt;&lt;/a&gt;, for parsing switches manually, as well as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#to_argv/1&quot;&gt;&lt;code&gt;to_argv/1&lt;/code&gt;&lt;/a&gt; for parsing from and converting switches to strings.</source>
          <target state="translated">이 모듈은 또한 수동으로 스위치를 구문 분석하기위한 &lt;a href=&quot;#next/2&quot;&gt; &lt;code&gt;next/2&lt;/code&gt; &lt;/a&gt; 와 같은 저수준 기능 과 스위치를 문자열에서 구문 분석하고 문자열로 변환하기위한 &lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#to_argv/1&quot;&gt; &lt;code&gt;to_argv/1&lt;/code&gt; &lt;/a&gt; 을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5a3684a4a565b66b7520e22d3fbaa6d25f44fe28" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">This module also provides many convenience functions for creating streams, like &lt;a href=&quot;#cycle/1&quot;&gt; &lt;code&gt;Stream.cycle/1&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#unfold/2&quot;&gt; &lt;code&gt;Stream.unfold/2&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt; and more.</target>
        </trans-unit>
        <trans-unit id="08818329b397b72cb93efb576183f5c8fee90efe" translate="yes" xml:space="preserve">
          <source>This module also provides many convenience functions for creating streams, like &lt;a href=&quot;stream#cycle/1&quot;&gt;&lt;code&gt;Stream.cycle/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#unfold/2&quot;&gt;&lt;code&gt;Stream.unfold/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stream#resource/3&quot;&gt;&lt;code&gt;Stream.resource/3&lt;/code&gt;&lt;/a&gt; and more.</source>
          <target state="translated">이 모듈은 또한 &lt;a href=&quot;stream#cycle/1&quot;&gt; &lt;code&gt;Stream.cycle/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stream#unfold/2&quot;&gt; &lt;code&gt;Stream.unfold/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stream#resource/3&quot;&gt; &lt;code&gt;Stream.resource/3&lt;/code&gt; &lt;/a&gt; 등과 같은 스트림 작성을위한 많은 편리한 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ad2b3a4e9085aa555ad326d7ab4e688a30372b07" translate="yes" xml:space="preserve">
          <source>This module also provides other convenience functions like &lt;code&gt;assert_in_delta&lt;/code&gt; and &lt;code&gt;assert_raise&lt;/code&gt; to easily handle other common cases such as checking a floating-point number or handling exceptions.</source>
          <target state="translated">이 모듈은 또한 같은 다른 편의 기능을 제공합니다 &lt;code&gt;assert_in_delta&lt;/code&gt; 및 &lt;code&gt;assert_raise&lt;/code&gt; 을 쉽게 부동 소수점 숫자를 확인하거나 예외를 처리 같은 다른 일반적인 사례를 처리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e2d831a828a6863612cdac8824ced54a83aa6de" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;exunit.callbacks&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process lifecycle.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;exunit.callbacks&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 콜백이 자동으로 포함됩니다 . &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;start_supervised&lt;/code&gt; , &lt;code&gt;on_exit&lt;/code&gt; 및 테스트 프로세스 라이프 사이클 에 대한 자세한 정보는 해당 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be140f9c425b22d10787335e62d9c0f4bf2df955" translate="yes" xml:space="preserve">
          <source>This module automatically includes all callbacks defined in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt;&lt;code&gt;ExUnit.Callbacks&lt;/code&gt;&lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;start_supervised&lt;/code&gt;, &lt;code&gt;on_exit&lt;/code&gt; and the test process life cycle.</source>
          <target state="translated">This module automatically includes all callbacks defined in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html&quot;&gt; &lt;code&gt;ExUnit.Callbacks&lt;/code&gt; &lt;/a&gt;. See that module for more information on &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;start_supervised&lt;/code&gt; , &lt;code&gt;on_exit&lt;/code&gt; and the test process life cycle.</target>
        </trans-unit>
        <trans-unit id="a6257d1fd58c649338860fae4d9c7189fabdb3f2" translate="yes" xml:space="preserve">
          <source>This module complements Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt; to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</source>
          <target state="translated">이 모듈은 Erlang의 &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt; &lt;code&gt;:code&lt;/code&gt; 모듈&lt;/a&gt; 을 보완 하여 Elixir와 관련된 동작을 추가합니다. 이 모듈의 거의 모든 기능은 Elixir의 동작에 대한 전반적인 부작용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="653ac253ebf8eeb2f4ad27098db4993bb2625263" translate="yes" xml:space="preserve">
          <source>This module contains a set of assertion functions that are imported by default into your test cases.</source>
          <target state="translated">이 모듈에는 기본적으로 테스트 사례로 가져 오는 일련의 어설 션 함수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="922f087298c98adf032ad8b0ed4a5b0046285656" translate="yes" xml:space="preserve">
          <source>This module contains functions to manipulate files.</source>
          <target state="translated">이 모듈에는 파일을 조작하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="999b5229e2658017fe9fe551f8ab83bda85a2221" translate="yes" xml:space="preserve">
          <source>This module contains three functions for compiling and evaluating files. Here is a summary of them and their behaviour:</source>
          <target state="translated">이 모듈에는 파일 컴파일 및 평가를위한 세 가지 기능이 있습니다. 다음은 그들과 그들의 행동에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="6edd43c8bb392184539818160b2c1a73b42dd599" translate="yes" xml:space="preserve">
          <source>This module defines a behaviour for providing time zone data.</source>
          <target state="translated">이 모듈은 시간대 데이터를 제공하기위한 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fc612a9ae903e6387df477d371e55523892dcb6f" translate="yes" xml:space="preserve">
          <source>This module defines a supervisor which can be used to dynamically supervise tasks.</source>
          <target state="translated">이 모듈은 작업을 동적으로 감독하는 데 사용할 수있는 감독자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ff54a5422bbcc14ae0339cf9003ae87e696322e7" translate="yes" xml:space="preserve">
          <source>This module defines the &lt;a href=&quot;#setup/1&quot;&gt;&lt;code&gt;setup/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup/2&quot;&gt;&lt;code&gt;setup/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#setup_all/1&quot;&gt;&lt;code&gt;setup_all/1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#setup_all/2&quot;&gt;&lt;code&gt;setup_all/2&lt;/code&gt;&lt;/a&gt; callbacks, as well as the &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#stop_supervised/1&quot;&gt;&lt;code&gt;stop_supervised/1&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;#setup/1&quot;&gt; &lt;code&gt;setup/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setup/2&quot;&gt; &lt;code&gt;setup/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#setup_all/1&quot;&gt; &lt;code&gt;setup_all/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#setup_all/2&quot;&gt; &lt;code&gt;setup_all/2&lt;/code&gt; &lt;/a&gt; 콜백과 &lt;a href=&quot;#on_exit/2&quot;&gt; &lt;code&gt;on_exit/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#start_supervised/2&quot;&gt; &lt;code&gt;start_supervised/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#stop_supervised/1&quot;&gt; &lt;code&gt;stop_supervised/1&lt;/code&gt; &lt;/a&gt; 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7bb87d9bb4c75afab1fe54071112deb7c5a60247" translate="yes" xml:space="preserve">
          <source>This module defines the behaviour for a Mix task that does compilation.</source>
          <target state="translated">이 모듈은 컴파일을 수행하는 Mix 작업의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="adca2c4f19b234afbf1c3981b55410081f195e79" translate="yes" xml:space="preserve">
          <source>This module defines the responsibilities for working with calendars, dates, times and datetimes in Elixir.</source>
          <target state="translated">이 모듈은 Elixir에서 달력, 날짜, 시간 및 날짜 / 시간 작업에 대한 책임을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1b157bc741bdfd8ba6ae8d42ded3b63cf4cd77d7" translate="yes" xml:space="preserve">
          <source>This module implements the functionality described in &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;&quot;Strictly Pretty&quot; (2000) by Christian Lindig&lt;/a&gt; with small additions, like support for binary nodes and a break mode that maximises use of horizontal space.</source>
          <target state="translated">이 모듈 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.2200&quot;&gt;은 Christian Lindig의 &quot;Strictly Pretty&quot;(2000)에&lt;/a&gt; 설명 된 기능 을 이진 노드 지원 및 가로 공간 사용을 최대화하는 중단 모드와 같은 작은 추가 기능으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="112202a17c89837b3a647d3e666a456f2e4b078d" translate="yes" xml:space="preserve">
          <source>This module includes the built-in guards used by Elixir developers. They are a predefined set of functions and macros that augment pattern matching, typically invoked after the &lt;code&gt;when&lt;/code&gt; operator. For example:</source>
          <target state="translated">이 모듈에는 Elixir 개발자가 사용하는 내장 가드가 포함되어 있습니다. 그것들은 패턴 매칭을 향상시키는 사전 정의 된 함수 및 매크로 세트이며, 일반적으로 &lt;code&gt;when&lt;/code&gt; 연산자 이후에 호출됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc9a3de9fefb0b3c084b5528aedf73062faf9707" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다 . 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 모듈을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="83714cee8828e8f9110c531415bac329978b2d35" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다 . 대신 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0495cc6d49a1f2bcfa929825091c762ee979f726" translate="yes" xml:space="preserve">
          <source>This module is deprecated, use the modules &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt;&lt;code&gt;Config.Reader&lt;/code&gt;&lt;/a&gt; from Elixir's standard library instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다 . 대신 Elixir 표준 라이브러리의 &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt; &lt;code&gt;Config.Reader&lt;/code&gt; &lt;/a&gt; 모듈을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="60fd8da7254ec766067fc2237c8a6fbc5505757a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;#defcallback/1&quot;&gt; &lt;code&gt;defcallback/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#defmacrocallback/1&quot;&gt; &lt;code&gt;defmacrocallback/1&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;@callback&lt;/code&gt; 및 &lt;code&gt;@macrocallback&lt;/code&gt; 모듈 특성은 (각각)이 사용될 수있다. 이러한 속성에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="698253e94267be04646f8c090c390fb2cc54ab28" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Instead of &lt;a href=&quot;#defcallback/1&quot;&gt;&lt;code&gt;defcallback/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#defmacrocallback/1&quot;&gt;&lt;code&gt;defmacrocallback/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (respectively). See the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information on these attributes.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;#defcallback/1&quot;&gt; &lt;code&gt;defcallback/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#defmacrocallback/1&quot;&gt; &lt;code&gt;defmacrocallback/1&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;@callback&lt;/code&gt; 및 &lt;code&gt;@macrocallback&lt;/code&gt; 모듈 특성은 (각각)이 사용될 수있다. 이러한 속성에 대한 자세한 내용 은 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fdf2b70f41d95f88ee9e4aeda784850c33cb6114" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use @callback and @macrocallback attributes instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 @callback 및 @macrocallback 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d00a52e370b2dc890428ed554a01c357e7af552" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Config and Config.Reader instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 Config 및 Config.Reader를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21c46dbb91fb819b2c0d1361c70dbb30920cffa0" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 맵을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="39e094eeeb209ce88d3bf96eb154f3cef16627e8" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use Map or Keyword modules instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 맵 또는 키워드 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45cb95722786d1fc420f1550713942a3d2a40ee4" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use MapSet instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 MapSet을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8bfe2ac5b2ad8a73d077417b66f5ed47d757f034" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="46e498b026f4f6f31e26916a4df3d6d96afaccb2" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d2e8897e9809b530aad6556d1d82b7d911062f" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff61ace86ab234eb7df8bf6ecf37e092b5b0882a" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51805cd79a5e913405d55c2dfa613daced6e0652" translate="yes" xml:space="preserve">
          <source>This module is deprecated. Use the new child specifications outlined in the Supervisor module instead.</source>
          <target state="translated">이 모듈은 더 이상 사용되지 않습니다. 대신 Supervisor 모듈에 요약 된 새 하위 사양을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="090a0510a4b709bb729894c57c0c587dc11055ba" translate="yes" xml:space="preserve">
          <source>This module is most commonly used to define application configuration, typically in &lt;code&gt;config/config.exs&lt;/code&gt;:</source>
          <target state="translated">이 모듈은 일반적으로 &lt;code&gt;config/config.exs&lt;/code&gt; 에서 애플리케이션 구성을 정의하는 데 가장 일반적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2befac5116f60db9c19a013fd1aa9a67a87481ad" translate="yes" xml:space="preserve">
          <source>This module must be used in other modules as a way to configure and prepare them for testing.</source>
          <target state="translated">이 모듈은 테스트를 위해 구성 및 준비하는 방법으로 다른 모듈에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b22afa6be61052c1f9cdf8dac15ff3c336d6750" translate="yes" xml:space="preserve">
          <source>This module provides 3 main APIs for you to use:</source>
          <target state="translated">이 모듈은 3 가지 주요 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="769d078447abaa6265ad7bb0de8a70d942cff612" translate="yes" xml:space="preserve">
          <source>This module provides a Mix shell implementation that uses the current process mailbox for communication instead of IO.</source>
          <target state="translated">이 모듈은 IO 대신 현재 프로세스 사서함을 사용하여 통신하는 혼합 셸 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97378d1871eb3d3c2cbd5fdcf8a5c1c351518c6d" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 튜플 및 목록과 같은 다른 구조를 탐색하기위한 편리한 기능을 제공합니다. 이러한 함수는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; 의&lt;/a&gt; 모든 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 관련 함수 및 매크로에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61d141fedc9a9bf97077c1d4c4dd489c9b785e1b" translate="yes" xml:space="preserve">
          <source>This module provides convenience functions for traversing other structures, like tuples and lists. These functions can be used in all the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt;-related functions and macros in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 튜플 및 목록과 같은 다른 구조를 순회하기위한 편리한 기능을 제공합니다. 이러한 기능은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모든 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 관련 기능 및 매크로에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="782a5e74e17fd10ef3053ba12c4f6db6d729bfdd" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for manipulating or retrieving file system paths.</source>
          <target state="translated">이 모듈은 파일 시스템 경로를 조작하거나 검색 할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="da08bc2535ffa10b4ff19a553d1b9ea3a60095e8" translate="yes" xml:space="preserve">
          <source>This module provides conveniences for working with records at compilation time, where compile-time field names are used to manipulate the tuples, providing fast operations on top of the tuples' compact structure.</source>
          <target state="translated">이 모듈은 컴파일 타임에 레코드 작업에 편리함을 제공합니다. 컴파일 타임 필드 이름은 튜플을 조작하는 데 사용되며 튜플의 컴팩트 한 구조에서 빠른 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d8865f287fbd66961e8c5ed897c4cb1e98bb7854" translate="yes" xml:space="preserve">
          <source>This module provides data encoding and decoding functions according to &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt; 에 따른 데이터 인코딩 및 디코딩 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="775daee9805ae8be33fdd0d2d338cd5f646e58b6" translate="yes" xml:space="preserve">
          <source>This module provides functions for working with URIs (for example, parsing URIs or encoding query strings). The functions in this module are implemented according to &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 URI 작업 (예 : URI 구문 분석 또는 쿼리 문자열 인코딩)을위한 기능을 제공합니다. 이 모듈의 기능은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; 에 따라 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="1925b1b9c75dedb57897285758fc633fa67f4392" translate="yes" xml:space="preserve">
          <source>This module provides helper functions and defines the behaviour required by any source code manager (SCM) used by Mix.</source>
          <target state="translated">이 모듈은 도우미 기능을 제공하고 Mix에서 사용하는 모든 소스 코드 관리자 (SCM)에 필요한 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="975d761a831604643250ee0022304cbf208c888f" translate="yes" xml:space="preserve">
          <source>This module relies on this behaviour to ignore such invalid characters. For example, &lt;a href=&quot;#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; will return a correct result even if an invalid code point is fed into it.</source>
          <target state="translated">이 모듈은 유효하지 않은 문자를 무시하기 위해이 동작에 의존합니다. 예를 들어, &lt;a href=&quot;#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 은 유효하지 않은 코드 포인트가 입력 되더라도 올바른 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0fcf25a6b73787d9a7e552929b18116ce2e70ec" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="translated">이 모듈은 바이트 크기를 사용하여 남은 공간을 계산합니다. 문서에 문자열이 포함 된 경우 문자열을 &lt;a href=&quot;#string/1&quot;&gt; &lt;code&gt;string/1&lt;/code&gt; &lt;/a&gt; 로 래핑해야합니다. 문자열 은 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt; 에 의존 하여 문서 크기를 미리 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a2a3fd3d8cfc91e72f80f4c370ccf8f3a32b7b9d" translate="yes" xml:space="preserve">
          <source>This module uses the byte size to compute how much space there is left. If your document contains strings, then those need to be wrapped in &lt;a href=&quot;#string/1&quot;&gt;&lt;code&gt;string/1&lt;/code&gt;&lt;/a&gt;, which then relies on &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; to precompute the document size.</source>
          <target state="translated">이 모듈은 바이트 크기를 사용하여 남은 공간을 계산합니다. 문서에 문자열이 포함되어 있으면 &lt;a href=&quot;#string/1&quot;&gt; &lt;code&gt;string/1&lt;/code&gt; &lt;/a&gt; 로 줄 바꿈해야합니다. 그런 다음 &lt;a href=&quot;string#length/1&quot;&gt; &lt;code&gt;String.length/1&lt;/code&gt; &lt;/a&gt; 에 의존 하여 문서 크기를 미리 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bf6c5bbe802615e0aa5a1527fbeb868a3dd4e46f" translate="yes" xml:space="preserve">
          <source>This operation happens in constant time.</source>
          <target state="translated">이 작업은 일정한 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0323d90aa13d0480aa31c479eb72ceeb1afc3cbd" translate="yes" xml:space="preserve">
          <source>This operation is meant to be used with &quot;raw&quot; devices that are started without an encoding. The given &lt;code&gt;iodata&lt;/code&gt; is written as is to the device, without conversion. For more information on IO data, see the &quot;IO data&quot; section in the module documentation.</source>
          <target state="translated">이 작업은 인코딩없이 시작된 &quot;원시&quot;장치와 함께 사용하기위한 것입니다. 주어진 &lt;code&gt;iodata&lt;/code&gt; 는 장치에 그대로 변환없이 기록됩니다. IO 데이터에 대한 자세한 내용은 모듈 설명서의 &quot;IO 데이터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="caa455aca538782e938e4b888f46d0efc72ad432" translate="yes" xml:space="preserve">
          <source>This operation is not recursive.</source>
          <target state="translated">이 작업은 재귀 적이 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cf233431f4056abd018dbc95c859c52d627d1ab" translate="yes" xml:space="preserve">
          <source>This operation is potentially expensive, as it reads data from the file system, parses beam files, evaluates code and so on.</source>
          <target state="translated">파일 시스템에서 데이터를 읽고, 빔 파일을 구문 분석하고, 코드를 평가하는 등의 작업으로 인해이 작업은 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="4ac87cbe297ccc151c1adeb864d9d02cdda18b09" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;enum#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="translated">이 연산자 (매크로)는 단순히 &lt;a href=&quot;enum#member?/2&quot;&gt; &lt;code&gt;Enum.member?/2&lt;/code&gt; &lt;/a&gt; 에 대한 호출로 변환합니다 . 위의 예는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="dce7f3b5f6d1002f08c83e9f800ba97413046570" translate="yes" xml:space="preserve">
          <source>This operator (which is a macro) simply translates to a call to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#member?/2&quot;&gt;&lt;code&gt;Enum.member?/2&lt;/code&gt;&lt;/a&gt;. The example above would translate to:</source>
          <target state="translated">이 연산자 (매크로)는 단순히 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#member?/2&quot;&gt; &lt;code&gt;Enum.member?/2&lt;/code&gt; &lt;/a&gt; 에 대한 호출로 변환됩니다 . 위의 예는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="331fe094cd09d757ad66d6f225117b31c709d88f" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For match comparison, use &lt;a href=&quot;#!==/2&quot;&gt;&lt;code&gt;!==/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 연산자는 1과 1.0이 같다고 간주합니다. 일치 비교를 위해서는 대신 &lt;a href=&quot;#!==/2&quot;&gt; &lt;code&gt;!==/2&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a93d5027785794a41da95cb35f0cd6d2acb007f9" translate="yes" xml:space="preserve">
          <source>This operator considers 1 and 1.0 to be equal. For stricter semantics, use &lt;a href=&quot;#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 연산자는 1과 1.0이 같다고 간주합니다. 보다 의미 론적으로, 대신 &lt;a href=&quot;#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9d9501c58df67371e18635ed16fc7a445f5df561" translate="yes" xml:space="preserve">
          <source>This operator introduces the expression on the left-hand side as the first argument to the function call on the right-hand side.</source>
          <target state="translated">이 연산자는 왼쪽의 표현식을 오른쪽의 함수 호출에 대한 첫 번째 인수로 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f341e422c93c5bb9c0446195cea1180bec59b5b7" translate="yes" xml:space="preserve">
          <source>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</source>
          <target state="translated">이 연산자는 Elixir에서 두 가지 다른 경우에 사용됩니다. 변수, 함수 또는 형식 자체의 유형을 지정하기 위해 typespecs에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0255b05dbc6a872386af8aa97dc81394e15f507f" translate="yes" xml:space="preserve">
          <source>This page describes the semantics of patterns and guards, where they are all allowed, and how to extend them.</source>
          <target state="translated">이 페이지에서는 패턴 및 가드의 의미, 모두 허용되는 위치 및 확장 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="769404e29fd0d9c0c1b74fd982594f4931cda146" translate="yes" xml:space="preserve">
          <source>This protocol requires four functions to be implemented, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#member?/2&quot;&gt;&lt;code&gt;member?/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#slice/1&quot;&gt;&lt;code&gt;slice/1&lt;/code&gt;&lt;/a&gt;. The core of the protocol is the &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.</source>
          <target state="translated">이 프로토콜은 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#member?/2&quot;&gt; &lt;code&gt;member?/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#slice/1&quot;&gt; &lt;code&gt;slice/1&lt;/code&gt; 의&lt;/a&gt; 네 가지 기능을 구현해야합니다 . 프로토콜의 핵심은 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 기능입니다. 다른 모든 함수는 선형 시간보다 더 나은 특정 속성을 구현할 수있는 데이터 구조에 대한 최적화 경로로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="fb7da1dc23c1e9f315adf4ca89a991f2f576c3b4" translate="yes" xml:space="preserve">
          <source>This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the &lt;code&gt;zip/1&lt;/code&gt; and &lt;code&gt;zip/2&lt;/code&gt; functions).</source>
          <target state="translated">이 프로토콜은 태그가 달린 튜플을 사용하여 감속기 기능과 프로토콜을 구현하는 데이터 유형간에 정보를 교환합니다. 이를 통해 파일과 같은 리소스의 열거를 효율적으로 수행 할 수있을뿐만 아니라 열거의 끝에서 리소스가 닫히도록 보장 할 수 있습니다. 이 프로토콜은 또한 열거의 일시 중단을 허용합니다. 이는 &lt;code&gt;zip/1&lt;/code&gt; 및 &lt;code&gt;zip/2&lt;/code&gt; 함수에서 와 같이 많은 열거 가능 항목 사이에 인터리빙이 필요할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="2a476c9109b8e7bd77f398d609ce8b45633486cf" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="translated">이것은 IO에서 UTF-8로 읽습니다. IO를 원시 바이너리로 처리하려면 &lt;a href=&quot;#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d2faccf1f4cab6a9360849e0c4b192286433613" translate="yes" xml:space="preserve">
          <source>This reads from the IO as UTF-8. Check out &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt; to handle the IO as a raw binary.</source>
          <target state="translated">IO에서 UTF-8로 읽습니다. IO를 원시 바이너리로 처리하려면 &lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb3289e1168d746e447207053b10b0f0b058ccb5" translate="yes" xml:space="preserve">
          <source>This returns true if a task is marked as recursive and it is being executed inside an umbrella project.</source>
          <target state="translated">작업이 재귀로 표시되고 우산 프로젝트 내에서 실행되는 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea9af91069aa4c9d64215d6cd9db073871191b73" translate="yes" xml:space="preserve">
          <source>This section covers built-in attributes. However, attributes can also be used by developers or extended by libraries to support custom behaviour.</source>
          <target state="translated">이 섹션에서는 내장 속성에 대해 설명합니다. 그러나 개발자가 속성을 사용하거나 라이브러리에서 확장하여 사용자 지정 동작을 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8870a170daeec23154d49d471c2dd9485fac0a" translate="yes" xml:space="preserve">
          <source>This shortcut will be extremely useful as we build our project, allowing us to quickly iterate by running a single test.</source>
          <target state="translated">이 바로 가기는 프로젝트를 빌드 할 때 매우 유용하므로 단일 테스트를 실행하여 빠르게 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd1e1ed3f015a12c58d63db1a9d93b599be9e3dd" translate="yes" xml:space="preserve">
          <source>This structure is enough to compile our project:</source>
          <target state="translated">이 구조는 프로젝트를 컴파일하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="5aeacadd2f95dc684bd082e5479290a732535d0b" translate="yes" xml:space="preserve">
          <source>This syntax is very convenient as it can be nested arbitrarily:</source>
          <target state="translated">이 구문은 임의로 중첩 될 수 있으므로 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="a3f217bb694fd565ea5471a5519af65161e8bfcb" translate="yes" xml:space="preserve">
          <source>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</source>
          <target state="translated">이 구문은 크기에 단위를 곱하여 유효 크기가 제공된다는 사실을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="d91886050dfd3b8b0ffcd36baeadec3113935150" translate="yes" xml:space="preserve">
          <source>This task also removes documentation and debugging chunks from the compiled &lt;code&gt;.beam&lt;/code&gt; files to reduce the size of the escript. If this is not desired, check the &lt;code&gt;:strip_beams&lt;/code&gt; option.</source>
          <target state="translated">이 작업은 또한 컴파일 된 &lt;code&gt;.beam&lt;/code&gt; 파일 에서 문서 및 디버깅 청크를 제거 하여 escript의 크기를 줄입니다. 이것이 바람직하지 않은 경우 &lt;code&gt;:strip_beams&lt;/code&gt; 옵션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e372a4a60d70f77f44ec0d0a534418195e400445" translate="yes" xml:space="preserve">
          <source>This task attempts to detect if the project contains one of the following files and act accordingly:</source>
          <target state="translated">이 작업은 프로젝트에 다음 파일 중 하나가 포함되어 있는지 감지하고 그에 따라 조치를 취합니다.</target>
        </trans-unit>
        <trans-unit id="5435e4488fd4c9f6223b1ef1bcd4f2e99c900fe4" translate="yes" xml:space="preserve">
          <source>This task consolidates all protocols in the code path and outputs the new binary files to the given directory. Defaults to &quot;_build/MIX_ENV/lib/YOUR_APP/consolidated&quot; for regular apps and &quot;_build/MIX_ENV/consolidated&quot; in umbrella projects.</source>
          <target state="translated">이 작업은 코드 경로의 모든 프로토콜을 통합하고 새 바이너리 파일을 지정된 디렉터리에 출력합니다. 일반 앱의 경우 기본값은 &quot;_build / MIX_ENV / lib / YOUR_APP / consolidated&quot;이고 우산 프로젝트의 경우 &quot;_build / MIX_ENV / consolidated&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1b4cda0b866fc4bd88710556e9ee176eb8201a71" translate="yes" xml:space="preserve">
          <source>This task guarantees the project and its dependencies are compiled and packages them inside an escript. Before invoking &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, it is only necessary to define a &lt;code&gt;:escript&lt;/code&gt; key with a &lt;code&gt;:main_module&lt;/code&gt; option in your &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">이 작업은 프로젝트와 해당 종속성이 컴파일되어 escript 안에 패키지되도록합니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;mix.exs&lt;/code&gt; 파일 에서 &lt;code&gt;:main_module&lt;/code&gt; 옵션 을 사용하여 &lt;code&gt;:escript&lt;/code&gt; 키만 정의하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e94347be43d3ad1c1f8b54ecc6bc826651d565" translate="yes" xml:space="preserve">
          <source>This task guarantees this option is respected.</source>
          <target state="translated">이 작업은이 옵션이 존중되도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="0d0f25b9bb663d2e0c92536a5493fa56feb94b3f" translate="yes" xml:space="preserve">
          <source>This task is automatically invoked unless the project disables the &lt;code&gt;:consolidate_protocols&lt;/code&gt; option in their configuration.</source>
          <target state="translated">이 작업은 프로젝트 가 구성에서 &lt;code&gt;:consolidate_protocols&lt;/code&gt; 옵션을 비활성화하지 않는 한 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b95bdbfd4b655866a594149ce367ef4e30f87be" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times to load different configs.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 여러 구성을로드하기 위해 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60b7baa6b3d14e1c34ecb1ce263c22e53b326d02" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times with different arguments.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 다른 인수로 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26dd7e67f1b7b3ef5db86ff692753739683ca6d1" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so it can be called multiple times.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee1da0440bde8a127669b55f6844894777d90f76" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can perform multiple cross reference checks in the same Mix invocation.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 동일한 혼합 호출에서 여러 상호 참조 점검을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f0ea3aa09fb8c86fe400793e6f276b65a06e3e" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can print information multiple times in the same Mix invocation.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 동일한 Mix 호출에서 정보를 여러 번 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59102e430969db44aa9dbab5520c01e316dd3de5" translate="yes" xml:space="preserve">
          <source>This task is automatically reenabled, so you can profile multiple times in the same Mix invocation.</source>
          <target state="translated">이 작업은 자동으로 다시 활성화되므로 동일한 믹스 호출에서 여러 번 프로파일 링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="092ef0d136b59efa09b303487e88d69e710c4f88" translate="yes" xml:space="preserve">
          <source>This task is never directly invoked from the command line, but it is rather used as building block by other tasks.</source>
          <target state="translated">이 작업은 명령 줄에서 직접 호출되는 것이 아니라 다른 작업에서 빌딩 블록으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="25ec3e34affdc5b118add6428766793ecf3c3afd" translate="yes" xml:space="preserve">
          <source>This task starts the current application, loads up &lt;code&gt;test/test_helper.exs&lt;/code&gt; and then requires all files matching the &lt;code&gt;test/**/*_test.exs&lt;/code&gt; pattern in parallel.</source>
          <target state="translated">이 작업은 현재 응용 프로그램을 시작하고 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 를 로드 한 다음 &lt;code&gt;test/**/*_test.exs&lt;/code&gt; 패턴과 일치하는 모든 파일 을 병렬로 요구합니다.</target>
        </trans-unit>
        <trans-unit id="1c60c4d233c9160c073150ba4ff8097d082b6e81" translate="yes" xml:space="preserve">
          <source>This task supports importing formatter configuration from dependencies.</source>
          <target state="translated">이 태스크는 종속성에서 포맷터 구성 가져 오기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b4d9fcf010b1211b86ea4237770d26b428fafb33" translate="yes" xml:space="preserve">
          <source>This time all tests passed and ExUnit warned us that distributed tests were being excluded. If you run tests with &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt;, one extra test should run and successfully pass as long as the &lt;code&gt;bar@computer-name&lt;/code&gt; node is available.</source>
          <target state="translated">이번에는 모든 테스트가 통과되었고 ExUnit은 분산 테스트가 제외되었다고 경고했습니다. 당신이 테스트를 실행하면 &lt;code&gt;$ elixir --sname foo -S mix test&lt;/code&gt; 한 추가 테스트가 실행 성공적만큼으로 전달해야합니다 &lt;code&gt;bar@computer-name&lt;/code&gt; 노드가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477d833785327cf68017043ef90fe5f9da786575" translate="yes" xml:space="preserve">
          <source>This time is monotonically increasing and starts in an unspecified point in time.</source>
          <target state="translated">이 시간은 단조 증가하고 지정되지 않은 시점에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d29fa001afdf2d6ca161492ebf202a329eec33bb" translate="yes" xml:space="preserve">
          <source>This time let&amp;rsquo;s add a &lt;code&gt;:distributed&lt;/code&gt; tag to &lt;code&gt;test/kv/router_test.exs&lt;/code&gt;:</source>
          <target state="translated">이번에는 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; 에 : &lt;code&gt;:distributed&lt;/code&gt; 태그를 추가 하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="8a08500e8bc91707c167cbe26d52c3bd3806ea0d" translate="yes" xml:space="preserve">
          <source>This time may be adjusted forwards or backwards in time with no limitation and is not monotonic.</source>
          <target state="translated">이 시간은 제한없이 앞뒤로 조정할 수 있으며 단조롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d3ccee502b139d7db4ac43bc5181f6363d2dc18" translate="yes" xml:space="preserve">
          <source>This time the supervisor started a named registry, allowing us to create buckets without having to explicitly fetch the PID from the supervisor. You should also know how to make the registry crash again, without looking up its PID: give it a try.</source>
          <target state="translated">이번에는 수퍼바이저가 명명 된 레지스트리를 시작하여 수퍼바이저에서 PID를 명시 적으로 가져 오지 않고도 버킷을 생성 할 수있었습니다. PID를 조회하지 않고 레지스트리를 다시 충돌시키는 방법도 알아야합니다. 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="2674a77869b19062b86e06c05052e9cdedb0c192" translate="yes" xml:space="preserve">
          <source>This time, since our test relies on global data, we have not given &lt;code&gt;async: true&lt;/code&gt; to &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Furthermore, in order to guarantee our test is always in a clean state, we stop and start the &lt;code&gt;:kv&lt;/code&gt; application before each test. In fact, stopping the &lt;code&gt;:kv&lt;/code&gt; application even prints a warning on the terminal:</source>
          <target state="translated">이번 테스트에서는 전역 데이터 를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 를 사용 하기 위해 &lt;code&gt;async: true&lt;/code&gt; 를 제공 하지 않았습니다 . 또한 테스트가 항상 깨끗한 상태임을 보장하기 위해 각 테스트 전에 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션을 중지하고 시작합니다 . 실제로 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램을 중지 하면 터미널에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c22b7275344f29b83a9a0084e4877ef048fc7831" translate="yes" xml:space="preserve">
          <source>This time, we have joined two aliases, defining the final alias &lt;code&gt;Hello.World&lt;/code&gt;.</source>
          <target state="translated">이번에는 최종 별칭 &lt;code&gt;Hello.World&lt;/code&gt; 를 정의하는 두 개의 별칭에 합류했습니다 .</target>
        </trans-unit>
        <trans-unit id="b92fdce12a5311e4693203aaafe3726c0337e1b5" translate="yes" xml:space="preserve">
          <source>This tree means that &lt;code&gt;lib/a.ex&lt;/code&gt; depends on &lt;code&gt;lib/b.ex&lt;/code&gt; at compile time which then depends on &lt;code&gt;lib/c.ex&lt;/code&gt; at runtime. This is often problematic because if &lt;code&gt;lib/c.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; also has to recompile due to this indirect compile time dependency.</source>
          <target state="translated">이 나무 수단 &lt;code&gt;lib/a.ex&lt;/code&gt; 에 따라 &lt;code&gt;lib/b.ex&lt;/code&gt; 다음에 따라 컴파일시에 &lt;code&gt;lib/c.ex&lt;/code&gt; 런타임에. 이 경우 때문에 종종 문제가 &lt;code&gt;lib/c.ex&lt;/code&gt; 변경, &lt;code&gt;lib/a.ex&lt;/code&gt; 도 다시 컴파일해야 인해 간접 컴파일 시간 의존성에.</target>
        </trans-unit>
        <trans-unit id="2295ba054b7587077fd7b62e8108fca19b1176d6" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="translated">이 튜플은 Elixir에서 일반적으로 인용 된 표현식 구조를 따르며, 이름은 첫 번째 인수로, 일부 키워드 목록은 메타 데이터로, 인수 목록은 세 번째로 사용합니다. 이 경우 인수는 별칭 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 atom &lt;code&gt;:downcase&lt;/code&gt; 입니다. 원격 호출의 두 번째 인수는 &lt;strong&gt;항상&lt;/strong&gt; 원자입니다.</target>
        </trans-unit>
        <trans-unit id="5f412811fd9f81fa6e535feea04f5cd402448c56" translate="yes" xml:space="preserve">
          <source>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and the atom &lt;code&gt;:downcase&lt;/code&gt;. The second argument in a remote call is &lt;strong&gt;always&lt;/strong&gt; an atom.</source>
          <target state="translated">이 튜플은 이름이 첫 번째 인수, 일부 키워드 목록은 메타 데이터로, 인수 목록은 세 번째로 Elixir에서 일반적으로 인용되는 표현식 구조를 따릅니다. 이 경우 인수는 별명 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 및 atom &lt;code&gt;:downcase&lt;/code&gt; 입니다. 원격 호출의 두 번째 인수는 &lt;strong&gt;항상&lt;/strong&gt; 원자입니다.</target>
        </trans-unit>
        <trans-unit id="7ecec438aa5cf5d56bd4c9ece80a8b63bd733893" translate="yes" xml:space="preserve">
          <source>This value will have no effect as the code was compiled to connect to &quot;db.local&quot;, which is mostly likely unavailable in the production environment.</source>
          <target state="translated">이 값은 대부분 프로덕션 환경에서 사용할 수없는 &quot;db.local&quot;에 연결하도록 코드가 컴파일 되었기 때문에 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="09127719cfc463768ae7ae77dbace1cb3021f292" translate="yes" xml:space="preserve">
          <source>This way if you have a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in one time zone, you can get the same wall time in another time zone. For instance if you have 2018-08-24 10:00:00 in Copenhagen and want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for 2018-08-24 10:00:00 in UTC you can do:</source>
          <target state="translated">이 방법으로 한 시간대에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이있는 경우 다른 시간대에서 동일한 월 시간을 얻을 수 있습니다. 예를 들어 코펜하겐 에 2018-08-24 10:00:00이 있고 UTC에 2018-08-24 10:00:00 의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 원하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07671b087d75abe1588362cd61ce69e954d8e6a8" translate="yes" xml:space="preserve">
          <source>This will appear to the &lt;code&gt;node&lt;/code&gt; as if the local node has crashed. This function is mainly used in the Erlang network authentication protocols. Returns &lt;code&gt;true&lt;/code&gt; if disconnection succeeds, otherwise &lt;code&gt;false&lt;/code&gt;. If the local node is not alive, the function returns &lt;code&gt;:ignored&lt;/code&gt;.</source>
          <target state="translated">마치 로컬 노드가 충돌 한 것처럼 &lt;code&gt;node&lt;/code&gt; 나타납니다 . 이 기능은 주로 Erlang 네트워크 인증 프로토콜에서 사용됩니다. 연결이 끊어지면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . 로컬 노드가 활성화되어 있지 않으면이 함수는 &lt;code&gt;:ignored&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3db39e63e0c8d60956e47f7856c88ea07f5720f2" translate="yes" xml:space="preserve">
          <source>This will cause the operating system process to exit with the status given by &lt;code&gt;integer&lt;/code&gt; while signaling all linked Erlang processes to politely shut down.</source>
          <target state="translated">이로 인해 운영 체제 프로세스가 &lt;code&gt;integer&lt;/code&gt; 지정된 상태로 종료되고 연결된 모든 Erlang 프로세스가 정중하게 종료되도록 신호합니다.</target>
        </trans-unit>
        <trans-unit id="932ec01a6dc27cb0bacb799b1bb13427b2604043" translate="yes" xml:space="preserve">
          <source>This will generate a file named &lt;code&gt;Elixir.Math.beam&lt;/code&gt; containing the bytecode for the defined module. If we start &lt;code&gt;iex&lt;/code&gt; again, our module definition will be available (provided that &lt;code&gt;iex&lt;/code&gt; is started in the same directory the bytecode file is in):</source>
          <target state="translated">정의 된 모듈의 바이트 코드를 포함하는 &lt;code&gt;Elixir.Math.beam&lt;/code&gt; 파일이 생성됩니다 . &lt;code&gt;iex&lt;/code&gt; 를 다시 시작하면 모듈 정의를 사용할 수 있습니다 ( 바이트 코드 파일이있는 동일한 디렉토리에서 &lt;code&gt;iex&lt;/code&gt; 가 시작된 경우).</target>
        </trans-unit>
        <trans-unit id="8486c3ebf35a38d29570441bb6cd8b2ae73dbe68" translate="yes" xml:space="preserve">
          <source>This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project.</source>
          <target state="translated">이것은 기본 레벨 세트보다 우선하므로 프로젝트의 일부 부분의 자세한 정도를 높이거나 낮추는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e50caa68b186c476cfb0083912fddaf93761ce6" translate="yes" xml:space="preserve">
          <source>This won't work as it will rather try to invoke the local function &lt;code&gt;fun&lt;/code&gt;:</source>
          <target state="translated">로컬 함수 &lt;code&gt;fun&lt;/code&gt; 을 호출하려고 시도하므로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="988a9f0b35eb11882e7b92d107c2e4d9a3c956cd" translate="yes" xml:space="preserve">
          <source>This works because accessing anything on a &lt;code&gt;nil&lt;/code&gt; value, returns &lt;code&gt;nil&lt;/code&gt; itself:</source>
          <target state="translated">이것은 &lt;code&gt;nil&lt;/code&gt; 값 에 액세스하면 &lt;code&gt;nil&lt;/code&gt; 자체를 반환 하기 때문에 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="504c9c579f50eb0d399c3090d69552f011806877" translate="yes" xml:space="preserve">
          <source>This works because the &lt;code&gt;--partitions&lt;/code&gt; option automatically exports the coverage results.</source>
          <target state="translated">이는 &lt;code&gt;--partitions&lt;/code&gt; 옵션이 적용 범위 결과를 자동으로 내보내기 때문에 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a9ae4006317b94bfaa968ed593d618d9dbca367b" translate="yes" xml:space="preserve">
          <source>This works:</source>
          <target state="translated">이것은 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="35b2e50e251cc0ba39a82b26384abdc7366f7bc3" translate="yes" xml:space="preserve">
          <source>This would be repetitive to write every time we need this check, so, as mentioned at the beginning of this section, we can abstract this away using a macro. Remember that defining a function that performs this check wouldn't work because we can't use custom functions in guards. Use &lt;code&gt;defguard&lt;/code&gt; and &lt;code&gt;defguardp&lt;/code&gt; to create guard macros. Here's an example:</source>
          <target state="translated">이 점검이 필요할 때마다 작성하는 것이 반복적이므로,이 섹션의 시작 부분에서 언급했듯이 매크로를 사용하여이를 요약 할 수 있습니다. 경비에서 사용자 정의 기능을 사용할 수 없으므로이 검사를 수행하는 기능을 정의하면 작동하지 않습니다. 사용 &lt;code&gt;defguard&lt;/code&gt; 및 &lt;code&gt;defguardp&lt;/code&gt; 는 가드 매크로를 만들 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6043c141b8f19b7be4caf31617881f52b255da5" translate="yes" xml:space="preserve">
          <source>This would be the equivalent of getting all of the file contents and packing it all into a single line in IEx and executing it.</source>
          <target state="translated">이는 모든 파일 내용을 가져 와서 IEx에서 한 줄로 압축하여 실행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ff1d4baf9340ffd06f6ffb996d0e212cbfa8737" translate="yes" xml:space="preserve">
          <source>Those are all protocols that ship with Elixir and they are being consolidated. Because a protocol can dispatch to any data type, the protocol must check on every call if an implementation for the given type exists. This may be expensive.</source>
          <target state="translated">이것들은 Elixir와 함께 제공되는 모든 프로토콜이며 통합되고 있습니다. 프로토콜은 모든 데이터 유형으로 디스패치 할 수 있으므로 주어진 유형에 대한 구현이 존재하는 경우 프로토콜은 모든 호출을 확인해야합니다. 이것은 비쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20eb63dea1b46358d700b88edabba7314d37424c" translate="yes" xml:space="preserve">
          <source>Those constructs exist only at the syntax level. All of the examples above are represented as their underlying integers in the AST.</source>
          <target state="translated">이러한 구문은 구문 수준에서만 존재합니다. 위의 모든 예는 AST에서 기본 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2a23b257e1a8396bae8e624da37c5fa4a14cd69d" translate="yes" xml:space="preserve">
          <source>Those files are compiled in parallel and can automatically detect dependencies between them. Once a dependency is found, the current file stops being compiled until the dependency is resolved.</source>
          <target state="translated">이러한 파일은 병렬로 컴파일되며 파일 간의 종속성을 자동으로 감지 할 수 있습니다. 종속성이 발견되면 종속성이 해결 될 때까지 현재 파일의 컴파일이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e697466781be26b9795959553f68c3100b1e1fc6" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).</source>
          <target state="translated">이러한 기능은 위의 Unix Epoch 또는 Gregorian Epoch (0000-01-01 00:00:00)와 같은 일반적인 신기원을 처리하도록 최적화되었습니다.</target>
        </trans-unit>
        <trans-unit id="c4de8ddc259e007e8ba142a7f915e7b9f301d071" translate="yes" xml:space="preserve">
          <source>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</source>
          <target state="translated">이러한 기능은 위의 Unix Epoch 또는 Gregorian Epoch (0000-01-01)와 같은 일반적인 신기원을 처리하도록 최적화되었습니다.</target>
        </trans-unit>
        <trans-unit id="394d2aacfa0d4e93088c549af6bbb4449e2dc409" translate="yes" xml:space="preserve">
          <source>Those functions will be explicitly marked in their docs as &quot;inlined by the compiler&quot;.</source>
          <target state="translated">이러한 함수는 문서에서 &quot;컴파일러에 의해 인라인 된&quot;것으로 명시 적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63c1f7abeafa00aa21caec35b0a45a7d4562b860" translate="yes" xml:space="preserve">
          <source>Those options are shared across all modes:</source>
          <target state="translated">이러한 옵션은 모든 모드에서 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="d6d6ce8d2fc67ab737881fd056832c2d5309c627" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="translated">이러한 옵션은 프로젝트 구성 파일에서 구성하거나 &lt;code&gt;~/.iex.exs&lt;/code&gt; 파일 에서 &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 전역 적으로 구성 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7600e9dc66e9f49a5eef98b40a90050ef4b71a9b" translate="yes" xml:space="preserve">
          <source>Those options can be configured in your project configuration file or globally by calling &lt;a href=&quot;iex#configure/1&quot;&gt;&lt;code&gt;IEx.configure/1&lt;/code&gt;&lt;/a&gt; from your &lt;code&gt;~/.iex.exs&lt;/code&gt; file. For example:</source>
          <target state="translated">이러한 옵션은 프로젝트 구성 파일에서 또는 전역 적으로 &lt;code&gt;~/.iex.exs&lt;/code&gt; 파일 에서 &lt;a href=&quot;iex#configure/1&quot;&gt; &lt;code&gt;IEx.configure/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74a14ac9f70e4b2f7b26991bd0d257ac84bd9ed1" translate="yes" xml:space="preserve">
          <source>Those options mean all dependencies will be checked out to &lt;code&gt;kv_umbrella/deps&lt;/code&gt;, and they will share the same build, config and lock files. We haven&amp;rsquo;t talked about configuration yet, but from here we can build the intuition that all configuration and dependencies are shared across all projects in an umbrella, and it is not per application.</source>
          <target state="translated">이러한 옵션은 모든 종속성이 &lt;code&gt;kv_umbrella/deps&lt;/code&gt; 에 체크 아웃되고 동일한 빌드, 구성 및 잠금 파일을 공유 함을 의미합니다. 아직 구성에 대해서는 언급하지 않았지만 여기서는 모든 구성 및 종속성이 모든 프로젝트에서 공유되고 응용 프로그램별로가 아니라는 직감을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff34978b55b28c6dbd12a23ca68d40a4861e6f90" translate="yes" xml:space="preserve">
          <source>Those performance characteristics dictate the usage of those data structures. One very common use case for tuples is to use them to return extra information from a function. For example, &lt;code&gt;File.read/1&lt;/code&gt; is a function that can be used to read file contents. It returns a tuple:</source>
          <target state="translated">이러한 성능 특성은 해당 데이터 구조의 사용법을 나타냅니다. 튜플의 가장 일반적인 사용 사례는 함수에서 추가 정보를 반환하는 데 사용하는 것입니다. 예를 들어 &lt;code&gt;File.read/1&lt;/code&gt; 은 파일 내용을 읽는 데 사용할 수있는 기능입니다. 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4f3c9a9eefe9427c2dedc41fe39d6f07ee20806" translate="yes" xml:space="preserve">
          <source>Those situations are quite uncommon in practice except when interfacing with libraries that do not provide a proper API. For example, let&amp;rsquo;s imagine the &lt;code&gt;Enum&lt;/code&gt; module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers:</source>
          <target state="translated">이러한 상황은 적절한 API를 제공하지 않는 라이브러리와 인터페이스 할 때를 제외하고는 실제로 드문 경우입니다. 예를 들어 &lt;code&gt;Enum&lt;/code&gt; 모듈이 값을 찾기위한 API를 제공하지 않고 숫자 목록에서 13의 처음 배수를 찾아야한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="aad090c769c6e03a992f9e5138ceea80922ae0f4" translate="yes" xml:space="preserve">
          <source>Throughout the guide, we have built a very simple distributed key-value store as an opportunity to explore many constructs like generic servers, supervisors, tasks, agents, applications and more. Not only that, we have written tests for the whole application, got familiar with ExUnit, and learned how to use the Mix build tool to accomplish a wide range of tasks.</source>
          <target state="translated">이 가이드 전체에서 일반 서버, 감독자, 작업, 에이전트, 응용 프로그램 등과 같은 많은 구성을 탐색 할 수있는 기회로 매우 간단한 분산 키-값 저장소를 구축했습니다. 뿐만 아니라 전체 응용 프로그램에 대한 테스트를 작성하고 ExUnit에 익숙해졌으며 혼합 빌드 도구를 사용하여 광범위한 작업을 수행하는 방법을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="d3b0d5df9824877f9b29731225c4ba90e068aada" translate="yes" xml:space="preserve">
          <source>Throughout the tutorial, we will talk a lot about the head and tail of a list. The head is the first element of a list and the tail is the remainder of the list. They can be retrieved with the functions &lt;code&gt;hd/1&lt;/code&gt; and &lt;code&gt;tl/1&lt;/code&gt;. Let&amp;rsquo;s assign a list to a variable and retrieve its head and tail:</source>
          <target state="translated">튜토리얼 전체에서 목록의 머리와 꼬리에 대해 많이 이야기 할 것입니다. 머리는 목록의 첫 번째 요소이고 꼬리는 목록의 나머지입니다. &lt;code&gt;hd/1&lt;/code&gt; 및 &lt;code&gt;tl/1&lt;/code&gt; 함수를 사용하여 검색 할 수 있습니다 . 변수에리스트를 할당하고 머리와 꼬리를 검색해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="090c252d7880a95a839fb25bf07e4aad923532bf" translate="yes" xml:space="preserve">
          <source>Throughout this tutorial, we have been using the notation &lt;code&gt;name/arity&lt;/code&gt; to refer to functions. It happens that this notation can actually be used to retrieve a named function as a function type. Start &lt;code&gt;iex&lt;/code&gt;, running the &lt;code&gt;math.exs&lt;/code&gt; file defined above:</source>
          <target state="translated">이 튜토리얼에서는 함수 &lt;code&gt;name/arity&lt;/code&gt; 을 나타내는 표기법 이름 / arity 를 사용했습니다. 실제로이 표기법을 사용하여 명명 된 함수를 함수 유형으로 검색 할 수 있습니다. 시작 &lt;code&gt;iex&lt;/code&gt; 실행, &lt;code&gt;math.exs&lt;/code&gt; 파일은 위의 정의를 :</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="4dc17499006fce61c64e8dfd0c8c4c038df992f0" translate="yes" xml:space="preserve">
          <source>Time representations with reduced accuracy are not supported.</source>
          <target state="translated">정확도가 낮은 시간 표현은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9e59bfbdd7898eae663b5796d19938441eff8ed" translate="yes" xml:space="preserve">
          <source>Time units in its plural form, such as: &lt;code&gt;:seconds&lt;/code&gt;, &lt;code&gt;:milliseconds&lt;/code&gt;, and the like</source>
          <target state="translated">시간 등의 복수의 형태로 단위 : &lt;code&gt;:seconds&lt;/code&gt; , &lt;code&gt;:milliseconds&lt;/code&gt; , 등</target>
        </trans-unit>
        <trans-unit id="adb40cd5eccc115002264851e51de0dcee9fe00b" translate="yes" xml:space="preserve">
          <source>Time zone abbreviation (empty string if naive)</source>
          <target state="translated">시간대 약어 (순진한 경우 빈 문자열)</target>
        </trans-unit>
        <trans-unit id="9452a856dc424a6f92632b47f9b6540703986d72" translate="yes" xml:space="preserve">
          <source>Time zone database</source>
          <target state="translated">시간대 데이터베이스</target>
        </trans-unit>
        <trans-unit id="dad962fdacc68e64400f9f34e93f5814f862947c" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</source>
          <target state="translated">표준 시간대 오프셋은 문자열에 포함될 수 있지만 이러한 정보가 순진한 날짜 시간에 포함되지 않기 때문에 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="55ded65dce8b65205b0b4f7c820bffa416a68f37" translate="yes" xml:space="preserve">
          <source>Time zone offset may be included in the string but they will be simply discarded as such information is not included in times.</source>
          <target state="translated">시간대 오프셋은 문자열에 포함될 수 있지만 그러한 정보가 시간에 포함되지 않기 때문에 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f905b9189d8d13ac7a8491eceeb00e40cf5247c7" translate="yes" xml:space="preserve">
          <source>Time zone period for a point in time in UTC for a specific time zone.</source>
          <target state="translated">특정 시간대에 대한 특정 시간대의 시간대 (UTC)입니다.</target>
        </trans-unit>
        <trans-unit id="4ca2fde51c11eb446c9f4471c5d166e6cd917c52" translate="yes" xml:space="preserve">
          <source>Timeout is set to 0, so there is no waiting time.</source>
          <target state="translated">제한 시간이 0으로 설정되어 대기 시간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="25e1a3000b3069b54f62fa349e25e048a6ebb374" translate="yes" xml:space="preserve">
          <source>Tmp Dir</source>
          <target state="translated">Tmp 디렉터리</target>
        </trans-unit>
        <trans-unit id="4b72f11edef4c0745d904f701fa487d703c27edf" translate="yes" xml:space="preserve">
          <source>To access atom keys, one may also use the &lt;code&gt;map.key&lt;/code&gt; notation. Note that &lt;code&gt;map.key&lt;/code&gt; will raise a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; if the &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;, compared to &lt;code&gt;map[:key]&lt;/code&gt;, that would return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">원자 키에 액세스하려면 &lt;code&gt;map.key&lt;/code&gt; 표기법을 사용할 수도 있습니다 . 참고 &lt;code&gt;map.key&lt;/code&gt; 이 인상됩니다 &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를을&lt;/a&gt; 경우 &lt;code&gt;map&lt;/code&gt; 키를 포함하지 않는 &lt;code&gt;:key&lt;/code&gt; 에 비해 &lt;code&gt;map[:key]&lt;/code&gt; , 그 반환 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b3091799895b01e6aa24802a8c476d47d3c391" translate="yes" xml:space="preserve">
          <source>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</source>
          <target state="translated">유니 코드 표준에 따라 작동하려면이 모듈의 많은 함수가 적절한 유니 코드 코드 포인트를 고려하여 전체 문자열을 순회해야하므로 선형 시간으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce008b888ee0241e97659cba8355716eba5bef7f" translate="yes" xml:space="preserve">
          <source>To add a new key:</source>
          <target state="translated">새 키를 추가하려면 :</target>
        </trans-unit>
        <trans-unit id="916b5fa900a6f384af0597e7d8f402a05c3c1c1f" translate="yes" xml:space="preserve">
          <source>To aid in the correct implementation of behaviours, you may optionally declare &lt;code&gt;@impl&lt;/code&gt; for implemented callbacks of a behaviour. This makes callbacks explicit and can help you to catch errors in your code. The compiler will warn in these cases:</source>
          <target state="translated">동작의 올바른 구현을 돕기 위해 동작의 구현 된 콜백에 대해 &lt;code&gt;@impl&lt;/code&gt; 을 선택적으로 선언 할 수 있습니다. 이것은 콜백을 명시 적으로 만들고 코드에서 오류를 잡는 데 도움이 될 수 있습니다. 컴파일러는 다음과 같은 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="688d49bd28e977f5619e4299defc87b3580ff416" translate="yes" xml:space="preserve">
          <source>To assert exits from linked processes started from the test, trap exits with &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt;&lt;code&gt;Process.flag/2&lt;/code&gt;&lt;/a&gt; and assert the exit message with &lt;a href=&quot;#assert_received/2&quot;&gt;&lt;code&gt;assert_received/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트에서 시작된 링크 된 프로세스에서 엑시트를 선언하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#flag/2&quot;&gt; &lt;code&gt;Process.flag/2&lt;/code&gt; 로&lt;/a&gt; 엑시트를 트랩 하고 &lt;a href=&quot;#assert_received/2&quot;&gt; &lt;code&gt;assert_received/2&lt;/code&gt; 로&lt;/a&gt; 엑시트 메시지를 assert하십시오 .</target>
        </trans-unit>
        <trans-unit id="60dda8ca6a65152c1c53235c6221b24d765a7234" translate="yes" xml:space="preserve">
          <source>To avoid printing log messages during tests, ExUnit provides a neat feature called &lt;code&gt;:capture_log&lt;/code&gt;. By setting &lt;code&gt;@tag :capture_log&lt;/code&gt; before each test or &lt;code&gt;@moduletag :capture_log&lt;/code&gt; for the whole test case, ExUnit will automatically capture anything that is logged while the test runs. In case our test fails, the captured logs will be printed alongside the ExUnit report.</source>
          <target state="translated">테스트 중에 로그 메시지가 인쇄되지 않도록 ExUnit은 &lt;code&gt;:capture_log&lt;/code&gt; 라는 깔끔한 기능을 제공 합니다 . 설정하여 &lt;code&gt;@tag :capture_log&lt;/code&gt; 각 테스트 이전에 &lt;code&gt;@moduletag :capture_log&lt;/code&gt; 전체 테스트 케이스를 위해, ExUnit 자동으로 테스트를 실행하는 동안 캡처 아무것도 기록됩니다 것이다. 테스트에 실패하면 캡처 된 로그가 ExUnit 보고서와 함께 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f974b60e8a8ca0fdff2c240dbeb8be96e5b7e1d4" translate="yes" xml:space="preserve">
          <source>To avoid that late answers (after the timeout) pollute the caller's message queue, a middleman process is used to do the actual calls. Late answers will then be discarded when they arrive to a terminated process.</source>
          <target state="translated">늦은 응답 (시간 초과 후)이 발신자의 메시지 대기열을 오염시키는 것을 피하기 위해 중개인 프로세스가 실제 통화를 수행하는 데 사용됩니다. 종료 된 프로세스에 도달하면 늦은 답변이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="915324fb4db3a9cfde09b72fdeb57083f3b6ada4" translate="yes" xml:space="preserve">
          <source>To be converted to a string, a list must either be empty or only contain the following elements:</source>
          <target state="translated">문자열로 변환하려면 목록이 비어 있거나 다음 요소 만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e45579800e96aeff05376f3bbc05633e2fce0d09" translate="yes" xml:space="preserve">
          <source>To be precise, &lt;code&gt;nil&lt;/code&gt; is returned whenever a &lt;code&gt;pid&lt;/code&gt; or &lt;code&gt;{name, node}&lt;/code&gt; cannot be returned. Note there is no guarantee the returned &lt;code&gt;pid&lt;/code&gt; or &lt;code&gt;{name, node}&lt;/code&gt; is alive, as a process could terminate immediately after it is looked up.</source>
          <target state="translated">정확히 말하면 &lt;code&gt;pid&lt;/code&gt; 또는 &lt;code&gt;{name, node}&lt;/code&gt; 를 반환 할 수 없을 때마다 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다. 반환 된 &lt;code&gt;pid&lt;/code&gt; 또는 &lt;code&gt;{name, node}&lt;/code&gt; 가 살아 있다는 보장은 없습니다 . 프로세스가 조회 된 직후 종료 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f3b6088332075b01c651b352f9aa53d48a4e4c87" translate="yes" xml:space="preserve">
          <source>To capture a definition within the current module, you can skip the module prefix, such as &lt;code&gt;&amp;amp;my_fun/2&lt;/code&gt;. In those cases, the captured function can be public (&lt;code&gt;def&lt;/code&gt;) or private (&lt;code&gt;defp&lt;/code&gt;).</source>
          <target state="translated">현재 모듈 내에서 정의를 캡처하려면 &lt;code&gt;&amp;amp;my_fun/2&lt;/code&gt; 와 같은 모듈 접두사를 건너 뛸 수 있습니다 . 이러한 경우 캡처 된 함수는 공개 ( &lt;code&gt;def&lt;/code&gt; ) 또는 비공개 ( &lt;code&gt;defp&lt;/code&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc7a4b67b1cf2b13d1bec5831057b11f1a8ac991" translate="yes" xml:space="preserve">
          <source>To check the Unicode version of your current Elixir installation, run &lt;code&gt;String.Unicode.version()&lt;/code&gt;.</source>
          <target state="translated">현재 Elixir 설치의 유니 코드 버전을 확인하려면 &lt;code&gt;String.Unicode.version()&lt;/code&gt; 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="32741725588800279ae172b79b44e5964f47f63a" translate="yes" xml:space="preserve">
          <source>To convert maps into keywords and vice-versa, use the &lt;code&gt;new&lt;/code&gt; function in the respective modules.</source>
          <target state="translated">맵을 키워드로 변환하거나 그 반대로 변환하려면 해당 모듈에서 &lt;code&gt;new&lt;/code&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90fe397a356898d27888dc41d52d7983ef57d2b2" translate="yes" xml:space="preserve">
          <source>To create a custom sigil, define a function with the name &lt;code&gt;sigil_{identifier}&lt;/code&gt; that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as &lt;code&gt;sigil_x&lt;/code&gt;) then the string argument will allow interpolation. If the sigil is upper case (such as &lt;code&gt;sigil_X&lt;/code&gt;) then the string will not be interpolated.</source>
          <target state="translated">사용자 지정 sigil을 만들려면 이름이 &lt;code&gt;sigil_{identifier}&lt;/code&gt; 인 함수를 정의하여 두 개의 인수를 사용하십시오. 첫 번째 인수는 문자열이고 두 번째 인수는 수정자를 포함하는 문자 목록입니다. sigil이 소문자 인 경우 (예 : &lt;code&gt;sigil_x&lt;/code&gt; ) 문자열 인수는 보간을 허용합니다. sigil이 대문자 인 경우 (예 : &lt;code&gt;sigil_X&lt;/code&gt; ) 문자열이 보간되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb585bff51bf0b0752f3b9643ada939cb21bacf2" translate="yes" xml:space="preserve">
          <source>To define a behaviour module, it's enough to define one or more callbacks in that module. To define callbacks, the &lt;code&gt;@callback&lt;/code&gt; and &lt;code&gt;@macrocallback&lt;/code&gt; module attributes can be used (for function callbacks and macro callbacks respectively).</source>
          <target state="translated">비헤이비어 모듈을 정의하려면 해당 모듈에서 하나 이상의 콜백을 정의하면 충분합니다. 콜백을 정의하기 위해 &lt;code&gt;@callback&lt;/code&gt; 및 &lt;code&gt;@macrocallback&lt;/code&gt; 모듈 속성을 사용할 수 있습니다 (각각 함수 콜백 및 매크로 콜백).</target>
        </trans-unit>
        <trans-unit id="748c36f2db63d3a03dc4e6fadef52aac3b262d3c" translate="yes" xml:space="preserve">
          <source>To define a struct, a developer must define both &lt;code&gt;__struct__/0&lt;/code&gt; and &lt;code&gt;__struct__/1&lt;/code&gt; functions. &lt;a href=&quot;#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; is a convenience macro which defines such functions with some conveniences.</source>
          <target state="translated">구조체를 정의하려면 개발자는 &lt;code&gt;__struct__/0&lt;/code&gt; 및 &lt;code&gt;__struct__/1&lt;/code&gt; 함수를 모두 정의해야합니다 . &lt;a href=&quot;#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; 은 편의상 이러한 기능을 정의하는 편의 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="5e46e68069cc59aab3678e72e8671077b9e1f5c1" translate="yes" xml:space="preserve">
          <source>To define a struct, the &lt;code&gt;defstruct&lt;/code&gt; construct is used:</source>
          <target state="translated">구조체를 정의하기 위해 &lt;code&gt;defstruct&lt;/code&gt; 구문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15c7a0bd6bb05c83760ad9659631936c1f603b9d" translate="yes" xml:space="preserve">
          <source>To define an operator, you can use the usual &lt;code&gt;def*&lt;/code&gt; constructs (&lt;code&gt;def&lt;/code&gt;, &lt;code&gt;defp&lt;/code&gt;, &lt;code&gt;defmacro&lt;/code&gt;, and so on) but with a syntax similar to how the operator is used:</source>
          <target state="translated">연산자를 정의하려면 일반적인 &lt;code&gt;def*&lt;/code&gt; 구문 ( &lt;code&gt;def&lt;/code&gt; , &lt;code&gt;defp&lt;/code&gt; , &lt;code&gt;defmacro&lt;/code&gt; 등)을 사용하지만 연산자 사용법과 유사한 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97bc558ded88de997eb4b20c7b44aa7a1d127e07" translate="yes" xml:space="preserve">
          <source>To deploy straight from a host to a separate target without cross-compilation, the following must be the same between the host and the target:</source>
          <target state="translated">교차 컴파일없이 호스트에서 별도의 대상으로 직접 배포하려면 호스트와 대상간에 다음 사항이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1416bbc268b001f44ff03e41dd657568db375a9" translate="yes" xml:space="preserve">
          <source>To determine how many seconds the &lt;code&gt;:native&lt;/code&gt; unit represents in your current runtime, you can can call this function to convert 1 second to the &lt;code&gt;:native&lt;/code&gt; time unit: &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt;.</source>
          <target state="translated">현재 런타임에서 &lt;code&gt;:native&lt;/code&gt; 단위가 몇 초를 나타내는 지 결정하기 위해이 함수를 호출하여 1 초를 &lt;code&gt;:native&lt;/code&gt; 시간 단위 ( &lt;code&gt;System.convert_time_unit(1, :second, :native)&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb35bc4715abc885d6ad16dcca4ef00591e6ce0e" translate="yes" xml:space="preserve">
          <source>To differentiate the program behavior depending on the environment, it is recommended to use application environment through &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt;&lt;code&gt;Application.get_env/3&lt;/code&gt;&lt;/a&gt;. Proper configuration can be set in config files, often per-environment (see the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module for more information).</source>
          <target state="translated">환경에 따라 프로그램 동작을 차별화하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#get_env/3&quot;&gt; &lt;code&gt;Application.get_env/3&lt;/code&gt; 를&lt;/a&gt; 통해 애플리케이션 환경을 사용하는 것이 좋습니다 . 환경에 따라 구성 파일에서 적절한 구성을 설정할 수 있습니다 (자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Config.html&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; 모듈 참조 ).</target>
        </trans-unit>
        <trans-unit id="ade0297c81614f897441b308bffb7079cbf4b959" translate="yes" xml:space="preserve">
          <source>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</source>
          <target state="translated">모듈의 공용 기능 또는 다른 모듈을 발견하려면 모듈 이름 다음에 점을 입력 한 다음 tab을 눌러 자동 완성을 트리거하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f350e9537ca99b19347d61d7b15f4ba1b815fe4" translate="yes" xml:space="preserve">
          <source>To display &quot;What is your name?&quot; as a prompt and await user input:</source>
          <target state="translated">&quot;이름이 무엇입니까?&quot;를 표시하려면 프롬프트로 사용자 입력을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9392c58481cde14e24d585ca66473875cbcb0d13" translate="yes" xml:space="preserve">
          <source>To drive the point home, imagine you want to validate a certain attribute only if a given condition is met. We could easily achieve it with the first solution, by manipulating the data structure accordingly, or with the second solution by using conditionals (if/else) before invoking the function. However, it is impossible to do so with the macros approach unless its DSL is augmented.</source>
          <target state="translated">포인트를 집으로 몰아 가려면 주어진 조건이 충족되는 경우에만 특정 속성의 유효성을 검사한다고 가정하십시오. 첫 번째 솔루션, 데이터 구조를 적절하게 조작하거나 두 번째 솔루션을 사용하여 함수를 호출하기 전에 조건부 (if / else)를 사용하여 쉽게 달성 할 수 있습니다. 그러나 DSL을 보강하지 않으면 매크로 접근 방식으로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="691c11ca8ab2ebe304045dcb2e0736f03a5a8a17" translate="yes" xml:space="preserve">
          <source>To dynamically supervise children, see &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자녀를 동적으로 감독하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/DynamicSupervisor.html&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f7191bed803a12f545045cca3f35df2867866ca" translate="yes" xml:space="preserve">
          <source>To enable runtime configuration in your release, all you need to do is to create a file named &lt;code&gt;config/runtime.exs&lt;/code&gt;:</source>
          <target state="translated">릴리스에서 런타임 구성을 활성화하려면 &lt;code&gt;config/runtime.exs&lt;/code&gt; 라는 파일을 생성하기 만하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2fa53a2359799d77d9a3c808a0fe3f75458448c" translate="yes" xml:space="preserve">
          <source>To escape an EEx expression in EEx use &lt;code&gt;&amp;lt;%% content %&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">EEx에서 EEx 표현식을 이스케이프하려면 &lt;code&gt;&amp;lt;%% content %&amp;gt;&lt;/code&gt; 를 사용하십시오 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="842501ce37fce5610a16f26dd98d6da220a3b08e" translate="yes" xml:space="preserve">
          <source>To exit a breakpoint, the developer can either invoke &lt;code&gt;continue()&lt;/code&gt;, which will block the shell until the next breakpoint is found or the process terminates, or invoke &lt;code&gt;respawn()&lt;/code&gt;, which starts a new IEx shell, freeing up the pried one.</source>
          <target state="translated">중단 점을 종료하려면 개발자는 &lt;code&gt;continue()&lt;/code&gt; 를 호출 하여 다음 중단 점을 찾거나 프로세스가 종료 될 때까지 쉘을 차단하거나 &lt;code&gt;respawn()&lt;/code&gt; 호출 하여 새로운 IEx 쉘을 시작하여 프라이밍 된 쉘을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="77caae61840ab6ad348e3ba1e35de2b7d3be118d" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s back to &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; and change the function and its callback as follows:</source>
          <target state="translated">실패를 수정하려면 &lt;code&gt;cast/2&lt;/code&gt; 대신 &lt;code&gt;call/2&lt;/code&gt; 를 사용하여 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 를 동기식으로 만들어야 합니다. 이렇게하면 테이블이 변경된 후에 만 ​​클라이언트가 계속됩니다. &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 로 돌아가서 다음과 같이 함수와 콜백을 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a3c693fb70a5169722986ac65b4c67dfb305f68f" translate="yes" xml:space="preserve">
          <source>To fix the failure we need to make &lt;code&gt;KV.Registry.create/2&lt;/code&gt; synchronous by using &lt;code&gt;call/2&lt;/code&gt; rather than &lt;code&gt;cast/2&lt;/code&gt;. This will guarantee that the client will only continue after changes have been made to the table. Let&amp;rsquo;s change the function and its callback as follows:</source>
          <target state="translated">실패를 해결하려면 &lt;code&gt;cast/2&lt;/code&gt; 대신 &lt;code&gt;call/2&lt;/code&gt; 를 사용하여 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 를 동 기적으로 만들어야 합니다. 이를 통해 클라이언트는 테이블을 변경 한 후에 만 ​​계속할 수 있습니다. 함수와 콜백을 다음과 같이 변경해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="248a8954323fae01b279eb29892eb672151e34bd" translate="yes" xml:space="preserve">
          <source>To generate an app with a supervision tree and an application callback:</source>
          <target state="translated">감독 트리 및 애플리케이션 콜백을 사용하여 앱을 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="57b84e64c358c14778edadcae30a553429d81661" translate="yes" xml:space="preserve">
          <source>To generate an umbrella application with sub applications:</source>
          <target state="translated">하위 애플리케이션이있는 우산 애플리케이션을 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1859a67f28b2dad5db51af942e1a02086e453015" translate="yes" xml:space="preserve">
          <source>To get individual options, see &lt;a href=&quot;#get_compiler_option/1&quot;&gt;&lt;code&gt;get_compiler_option/1&lt;/code&gt;&lt;/a&gt;. For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개별 옵션을 얻으려면 &lt;a href=&quot;#get_compiler_option/1&quot;&gt; &lt;code&gt;get_compiler_option/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 모든 옵션에 대한 설명은 &lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d939e666619b837bbfc72a19c0edb64540f7b914" translate="yes" xml:space="preserve">
          <source>To give the formatter a try, change a file in the &lt;code&gt;lib&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; directories to include extra spaces or extra newlines, such as &lt;code&gt;def  hello  do&lt;/code&gt;, and then run &lt;code&gt;mix format&lt;/code&gt;.</source>
          <target state="translated">포맷터를 시험해 보려면 &lt;code&gt;lib&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 디렉토리 에서 파일을 변경하여 &lt;code&gt;def hello do&lt;/code&gt; 와 같은 여분의 공백이나 줄 바꾸기를 포함시킨 다음 &lt;code&gt;mix format&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="a15120dae8d76afe9639289d60fb9093810c397a" translate="yes" xml:space="preserve">
          <source>To help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny &lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;GenServer cheat sheet&lt;/a&gt;.</source>
          <target state="translated">개발자가 콜, 캐스트 및 정보의 차이, 지원되는 반환 값 등을 &lt;a href=&quot;https://elixir-lang.org/cheatsheets/gen-server.pdf&quot;&gt;기억할&lt;/a&gt; 수 있도록 작은 GenServer 치트 시트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="555a879eb773cd3d2dff7da0f2a52cb90ca0b876" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;Application&lt;/code&gt; behaviour, we have to &lt;code&gt;use Application&lt;/code&gt; and define a &lt;code&gt;start/2&lt;/code&gt; function. The goal of &lt;code&gt;start/2&lt;/code&gt; is to start a supervisor, which will then start any child services or execute any other code our application may need. Let&amp;rsquo;s use this opportunity to start the &lt;code&gt;KV.Supervisor&lt;/code&gt; we have implemented earlier in this chapter.</source>
          <target state="translated">&lt;code&gt;Application&lt;/code&gt; 동작 을 구현하려면 응용 프로그램 을 &lt;code&gt;use Application&lt;/code&gt; 하고 &lt;code&gt;start/2&lt;/code&gt; 기능을 정의해야 합니다. &lt;code&gt;start/2&lt;/code&gt; 의 목표는 감독자를 시작하여 자식 서비스를 시작하거나 응용 프로그램에 필요한 다른 코드를 실행하는 것입니다. 이 기회를 사용 하여이 장의 앞부분에서 구현 한 &lt;code&gt;KV.Supervisor&lt;/code&gt; 를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="4febdf906d953be4fd2821fd877395877b196fe9" translate="yes" xml:space="preserve">
          <source>To learn more about Elixir's AST and how to build them programmatically, see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 AST와이를 프로그래밍 방식으로 빌드하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee64280d1fb25258cd437b5d0c77efe55acbd252" translate="yes" xml:space="preserve">
          <source>To learn more about IEx as a whole, type &lt;code&gt;h(IEx)&lt;/code&gt;.</source>
          <target state="translated">IEx 전체에 대한 자세한 내용을 보려면 &lt;code&gt;h(IEx)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="699ef2c862a7af01ce3ea7b060fc68320ed60961" translate="yes" xml:space="preserve">
          <source>To learn more about floating-point arithmetic visit:</source>
          <target state="translated">부동 소수점 산술 방문에 대해 자세히 알아 보려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="101e8672c7193137af23129687e2ed29b0030ea4" translate="yes" xml:space="preserve">
          <source>To learn more about specific optimizations and performance considerations, check out &lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;Erlang's Efficiency Guide on handling binaries&lt;/a&gt;.</source>
          <target state="translated">특정 최적화 및 성능 고려 사항에 대한 자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/efficiency_guide/binaryhandling.html&quot;&gt;바이너리 처리에 대한 Erlang 효율성 가이드를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a32f6bfbd0a46a1fe8412990dabfb9a92464fbb" translate="yes" xml:space="preserve">
          <source>To list all IEx helpers available, which is effectively all exports (functions and macros) in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">사용 가능한 모든 IEx 헬퍼를 나열하려면 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; 모듈 에서 효과적으로 모든 내보내기 (함수 및 매크로)가 수행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="93e48689655deecbe42b747b91efa43959aec278" translate="yes" xml:space="preserve">
          <source>To list all available keys showing the keys themselves:</source>
          <target state="translated">키 자체를 보여주는 사용 가능한 모든 키를 나열하려면 :</target>
        </trans-unit>
        <trans-unit id="77bfde2bf5fe079fb8473d1b45bac69e05a6486e" translate="yes" xml:space="preserve">
          <source>To list all available keys:</source>
          <target state="translated">사용 가능한 모든 키를 나열하려면 :</target>
        </trans-unit>
        <trans-unit id="97e7dd0dfd16f5649cf89b74d291b7e7a795f96b" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="translated">코드를 프로파일 링하기 위해 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Run.html&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 태스크 와 유사한 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34f6e4a2bb843898b6a1a63430d9ad523188262e" translate="yes" xml:space="preserve">
          <source>To profile the code, you can use syntax similar to the &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; task:</source>
          <target state="translated">코드를 프로파일 링하기 위해 &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 작업 과 유사한 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b90e482b9b75d2e1ab9c0ff8e4d1e0e5aecc5f06" translate="yes" xml:space="preserve">
          <source>To quote &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;the official guide on Macros&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html&quot;&gt;매크로에 대한 공식 가이드&lt;/a&gt; 를 인용하려면 :</target>
        </trans-unit>
        <trans-unit id="e5139cf2a16e17732e5bda38b6b67324152e536b" translate="yes" xml:space="preserve">
          <source>To reply after returning from the callback because the response is not yet available.</source>
          <target state="translated">응답을 아직 사용할 수 없으므로 콜백에서 돌아온 후 응답합니다.</target>
        </trans-unit>
        <trans-unit id="716f6562922e06c13563ae83ce61a300e8352363" translate="yes" xml:space="preserve">
          <source>To reply before returning from the callback because the response is known before calling a slow function.</source>
          <target state="translated">느린 함수를 호출하기 전에 응답을 알고 있기 때문에 콜백에서 돌아 오기 전에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="e57aadf0943d8ee32b1daf18536595cdf4b85435" translate="yes" xml:space="preserve">
          <source>To reply from another process, such as a task.</source>
          <target state="translated">작업과 같은 다른 프로세스에서 회신</target>
        </trans-unit>
        <trans-unit id="5ca8eab4577e8b135c578b17a24c88f164743db6" translate="yes" xml:space="preserve">
          <source>To retrieve all dates in descending order, you can wrap the module in a tuple with &lt;code&gt;:asc&lt;/code&gt; or &lt;code&gt;:desc&lt;/code&gt; as first element:</source>
          <target state="translated">모든 날짜를 내림차순으로 검색하려면 &lt;code&gt;:asc&lt;/code&gt; 또는 &lt;code&gt;:desc&lt;/code&gt; 를 첫 번째 요소로 사용 하여 모듈을 튜플에 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07b5421b45e250d1129a17a5d3f7268bca4e4081" translate="yes" xml:space="preserve">
          <source>To retrieve code points in their natural integer representation, see &lt;a href=&quot;#to_charlist/1&quot;&gt;&lt;code&gt;to_charlist/1&lt;/code&gt;&lt;/a&gt;. For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">자연 정수 표현으로 코드 포인트를 검색하려면 &lt;a href=&quot;#to_charlist/1&quot;&gt; &lt;code&gt;to_charlist/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 코드 포인트 및 문자 소에 대한 자세한 내용은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa09c7d0058c95fdae6640e10ab83ae7e2c7d29c" translate="yes" xml:space="preserve">
          <source>To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">현재 프로세스의 스택 추적을 검색하려면 대신 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c6478efdf0d6ae4efc7373afc872fb60986f2bb5" translate="yes" xml:space="preserve">
          <source>To run doctests include them in an ExUnit case with a &lt;code&gt;doctest&lt;/code&gt; macro:</source>
          <target state="translated">doctest를 실행하려면 &lt;code&gt;doctest&lt;/code&gt; 매크로를 사용하여 ExUnit 케이스에 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="a9be81917be7c5a65d20c56cce5430337e7437a2" translate="yes" xml:space="preserve">
          <source>To run our doctests, we&amp;rsquo;ll create a file at &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; and call &lt;code&gt;doctest KVServer.Command&lt;/code&gt; in the test case:</source>
          <target state="translated">doctest를 실행하기 위해 &lt;code&gt;test/kv_server/command_test.exs&lt;/code&gt; 에 파일을 만들고 테스트 케이스에서 &lt;code&gt;doctest KVServer.Command&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c550ca70984ac8e2f646e72f7f0c9faa1dd704b7" translate="yes" xml:space="preserve">
          <source>To run the tests above, run the file using &lt;code&gt;elixir&lt;/code&gt; from the command line. Assuming you named the file &lt;code&gt;assertion_test.exs&lt;/code&gt;, you can run it as:</source>
          <target state="translated">위의 테스트를 실행하려면 명령 행에서 &lt;code&gt;elixir&lt;/code&gt; 를 사용하여 파일을 실행하십시오 . 파일 이름을 &lt;code&gt;assertion_test.exs&lt;/code&gt; 로 가정하면 다음 과 같이 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e079c912f8f4dac650321807cd475663a5b52c69" translate="yes" xml:space="preserve">
          <source>To see an example of using module attributes as for storage, look no further than Elixir&amp;rsquo;s unit test framework called &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;. ExUnit uses module attributes for multiple different purposes:</source>
          <target state="translated">모듈 속성을 스토리지로 사용하는 예를 보려면 &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt; 이라는 Elixir의 단위 테스트 프레임 워크를 살펴보십시오 . ExUnit은 다양한 목적으로 모듈 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f88b35a6396b6373f09d679595715d5f894666f2" translate="yes" xml:space="preserve">
          <source>To see documentation for each specific compiler, you must invoke &lt;code&gt;help&lt;/code&gt; directly for the compiler command:</source>
          <target state="translated">각 특정 컴파일러에 대한 설명서를 보려면 컴파일러 명령에 대한 &lt;code&gt;help&lt;/code&gt; 직접 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fcc2e5f60178276dfc7759916301cae9d1d546f" translate="yes" xml:space="preserve">
          <source>To show all entries, configure the limit to &lt;code&gt;:infinity&lt;/code&gt;:</source>
          <target state="translated">모든 항목을 표시하려면 한계를 &lt;code&gt;:infinity&lt;/code&gt; 로 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d46460a95ec8fd91d8032b072da8de876729d16" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can again look at the implementation for &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로토콜을 구현하는 방법을 보여주기 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 의 구현을 다시 살펴볼 수 있습니다 . 이 구현에서 요소를 &quot;수집&quot;한다는 것은 단순히 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html#put/2&quot;&gt; &lt;code&gt;MapSet.put/2&lt;/code&gt; 를&lt;/a&gt; 통해 요소를 세트에 삽입하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b50964644227148ad32fc703cd3d520d71c70f6b" translate="yes" xml:space="preserve">
          <source>To show how the protocol can be implemented, we can take again a look at the implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;. In this implementation &quot;collecting&quot; elements simply means inserting them in the set through &lt;a href=&quot;mapset#put/2&quot;&gt;&lt;code&gt;MapSet.put/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로토콜 구현 방법을 보여주기 위해 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 구현을 다시 살펴볼 수 있습니다 . 이 구현에서 &quot;수집&quot;요소는 &lt;a href=&quot;mapset#put/2&quot;&gt; &lt;code&gt;MapSet.put/2&lt;/code&gt; 를&lt;/a&gt; 통해 집합에 요소를 삽입하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="987c795e4ee5f17f665e41830d152e223b2b4556" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 수동으로 사용하는 방법을 보여주기 위해 &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 구현을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6baefde74a3b1948259d37f28d66b2da3cc95503" translate="yes" xml:space="preserve">
          <source>To show how to manually use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol, let's play with its implementation for &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 수동으로 사용하는 방법을 보여주기 위해 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 구현을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5683b1948dc754efdfed9ba11dc087a421c0449e" translate="yes" xml:space="preserve">
          <source>To specify that a module implements a given behaviour, the &lt;code&gt;@behaviour&lt;/code&gt; attribute must be used:</source>
          <target state="translated">모듈이 지정된 동작을 구현하도록 지정하려면 &lt;code&gt;@behaviour&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0fee1e5263eb41b6e360a95cfaf76805e6190b5" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">수퍼바이저를 시작하기 위해, 주어진 &lt;code&gt;module&lt;/code&gt; 에서 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백이 &lt;code&gt;arg&lt;/code&gt; 를 인수 로 사용하여 호출됩니다. &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백의 도움으로 생성 할 수 있습니다 감독자 사양 반환해야 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="340467355095ab2102cf53f317a261f28f43cfa1" translate="yes" xml:space="preserve">
          <source>To start the supervisor, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback will be invoked in the given &lt;code&gt;module&lt;/code&gt;, with &lt;code&gt;init_arg&lt;/code&gt; as its argument. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback must return a supervisor specification which can be created with the help of the &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">수퍼바이저를 시작하기 위해 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백이 주어진 &lt;code&gt;module&lt;/code&gt; 에서 &lt;code&gt;init_arg&lt;/code&gt; 를 인수로 사용하여 호출됩니다. &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백의 도움으로 생성 할 수 있습니다 감독자 사양 반환해야 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; &lt;/a&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="ea3cc861aafddb9c5584732baff0a5d8fc163c1d" translate="yes" xml:space="preserve">
          <source>To store individual options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;. For a description of all options, see &lt;a href=&quot;#put_compiler_option/2&quot;&gt;&lt;code&gt;put_compiler_option/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개별 옵션을 저장하려면 &lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 모든 옵션에 대한 설명은 &lt;a href=&quot;#put_compiler_option/2&quot;&gt; &lt;code&gt;put_compiler_option/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bd659c0fd4a88cb66bdff02f16f40278b81dd1f" translate="yes" xml:space="preserve">
          <source>To sum it up: since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak or refactor the code to get optimal formatting. To help better understand how to control the formatter, we describe in the next sections the cases where the formatter keeps the user encoding and how to control multiline expressions.</source>
          <target state="translated">요약하면 : 포맷터가 코드의 의미를 변경할 수 없으므로 최적의 형식을 얻으려면 코드를 조정하거나 리팩터링해야 할 때가 있습니다. 포맷터를 제어하는 ​​방법을보다 잘 이해하기 위해 다음 섹션에서는 포맷터가 사용자 인코딩을 유지하는 경우와 여러 줄 식을 제어하는 ​​방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dc5e717b9aecb2c9e25ade231bba83d35b0f1df7" translate="yes" xml:space="preserve">
          <source>To this point, we have been starting &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;. Typically the registry is started as part of a supervision tree though:</source>
          <target state="translated">지금까지 &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 를 시작했습니다 . 일반적으로 레지스트리는 감독 트리의 일부로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="16500310cbb3ebb314cb2217a6e54228c69e7280" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="translated">코드와 작업 간의 관계를 추적하기 위해 프로세스 사전에서 &lt;code&gt;$callers&lt;/code&gt; 키를 사용합니다 . 따라서 위 의 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 호출을 가정하면 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f69493266441ce87de2c6a579e769590bf4ddfcf" translate="yes" xml:space="preserve">
          <source>To track the relationship between your code and the task, we use the &lt;code&gt;$callers&lt;/code&gt; key in the process dictionary. Therefore, assuming the &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; call above, we have:</source>
          <target state="translated">코드와 작업 간의 관계를 추적하기 위해 프로세스 사전에서 &lt;code&gt;$callers&lt;/code&gt; 키를 사용합니다 . 따라서 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 호출을 가정하면 다음과 같은 이점 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8cdd3c2f7959e04910020a7c04a125591711d6" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">테스트 중에 &lt;a href=&quot;#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 사용하려면 &lt;code&gt;iex&lt;/code&gt; 명령 내에서 &lt;code&gt;mix&lt;/code&gt; 를 실행 하고 &lt;code&gt;--trace&lt;/code&gt; 를 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 에 전달하여 시간 초과가 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="aac68b9ffcf6a8ac8be05349df7088ceecbb4122" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">테스트 중에 &lt;a href=&quot;#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; 을 사용하려면 &lt;code&gt;iex&lt;/code&gt; 명령 내에서 &lt;code&gt;mix&lt;/code&gt; 를 실행 하고 &lt;code&gt;--trace&lt;/code&gt; 를 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 에 전달하여 시간 초과가 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="97175bd03b3eda9bcbde862759fc67493bd67482" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">사용하려면 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 테스트하는 동안, 당신은 실행해야 &lt;code&gt;mix&lt;/code&gt; 내부 &lt;code&gt;iex&lt;/code&gt; 명령과 통과 &lt;code&gt;--trace&lt;/code&gt; 을 위해 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 제한 시간에 실행 피하기 위해 :</target>
        </trans-unit>
        <trans-unit id="ad497a0e7b4707958b2bbdf25658f61ced2eef66" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; during tests, you need to run &lt;code&gt;mix&lt;/code&gt; inside the &lt;code&gt;iex&lt;/code&gt; command and pass the &lt;code&gt;--trace&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; to avoid running into timeouts:</source>
          <target state="translated">사용하려면 &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; 을&lt;/a&gt; 테스트하는 동안, 당신은 실행해야 &lt;code&gt;mix&lt;/code&gt; 내부 &lt;code&gt;iex&lt;/code&gt; 명령과 통과 &lt;code&gt;--trace&lt;/code&gt; 을 위해 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 제한 시간에 실행 피하기 위해 :</target>
        </trans-unit>
        <trans-unit id="525e76db8eaa15a02d475c0b25c1748678200a4e" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;:keep&lt;/code&gt; with a type other than &lt;code&gt;:string&lt;/code&gt;, use a list as the type for the switch. For example: &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:string&lt;/code&gt; 이외의 유형으로 &lt;code&gt;:keep&lt;/code&gt; 을 사용하려면 스위치 유형으로 목록을 사용하십시오. 예를 들면 : &lt;code&gt;[foo: [:integer, :keep]]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b67f756b7a47a192314501d13fc2788976f1a9c" translate="yes" xml:space="preserve">
          <source>To use the newly defined operators, we &lt;strong&gt;have to&lt;/strong&gt; import the module that defines them:</source>
          <target state="translated">새로 정의 된 연산자를 사용하려면 해당 연산자 를 정의하는 모듈 &lt;strong&gt;을&lt;/strong&gt; 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="2c8de6b1ffba1e94f756b45cb853dd0d24f391d0" translate="yes" xml:space="preserve">
          <source>To use them, first make sure it is added as a dependency in &lt;code&gt;mix.exs&lt;/code&gt;. It can then be configured either via configuration:</source>
          <target state="translated">이를 사용하려면 먼저 &lt;code&gt;mix.exs&lt;/code&gt; 에 종속성으로 추가되었는지 확인하십시오 . 그런 다음 구성을 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4e084ee0583dab5cdb8f2aaa6336b9ae8900f06" translate="yes" xml:space="preserve">
          <source>To work around this error, redefine the field with your own &amp;amp;M.f/a function, like so:</source>
          <target state="translated">이 오류를 해결하려면 다음과 같이 자신의 &amp;amp; M.f / a 함수로 필드를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="123be2f9bdd25b0f49703cfe940d72bfca8fdce4" translate="yes" xml:space="preserve">
          <source>TokenMissingError</source>
          <target state="translated">TokenMissingError</target>
        </trans-unit>
        <trans-unit id="42d5db27696210e57467dc675285521f0930aa67" translate="yes" xml:space="preserve">
          <source>TokenMissingError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TokenMissingError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="cd770bf19fa776a62cbc130cb90d8f5cd6a0b438" translate="yes" xml:space="preserve">
          <source>Tools like Mix may use this information to ensure the module is recompiled in case any of the external resources change.</source>
          <target state="translated">Mix와 같은 도구는이 정보를 사용하여 외부 리소스가 변경 될 경우 모듈을 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71f3b1bc352a87eabb6f98c3505cc5cd7766eaec" translate="yes" xml:space="preserve">
          <source>Tools may use this information to ensure the module is recompiled in case any of the external resources change, see for example: &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt;&lt;code&gt;mix compile.elixir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">도구는이 정보를 사용하여 외부 리소스가 변경된 경우 모듈이 다시 컴파일되도록 할 수 있습니다 (예 : &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Elixir.html&quot;&gt; &lt;code&gt;mix compile.elixir&lt;/code&gt; 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77431b38c8bb01a363da5bccdb519bd75745358b" translate="yes" xml:space="preserve">
          <source>Trailing bang (&lt;code&gt;foo!&lt;/code&gt;)</source>
          <target state="translated">후행 강타 ( &lt;code&gt;foo!&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ff6cffeaff58c52204a5122da57dc4b26f381da0" translate="yes" xml:space="preserve">
          <source>Trailing question mark (&lt;code&gt;foo?&lt;/code&gt;)</source>
          <target state="translated">후행 물음표 ( &lt;code&gt;foo?&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b7a933d6378a29d15a7b6795f6516bd8c8f0c0ab" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream with function-based start and finish.</source>
          <target state="translated">함수 기반 시작 및 종료로 기존 스트림을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0183630f154b045739040c0a476db00c0d8d8489" translate="yes" xml:space="preserve">
          <source>Transforms an existing stream.</source>
          <target state="translated">기존 스트림을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a0bf22bc28c174dfbe4750edd483edd80c1c1f1c" translate="yes" xml:space="preserve">
          <source>Translates to:</source>
          <target state="translated">번역 :</target>
        </trans-unit>
        <trans-unit id="ac26a7a94ea2e66490f932b6415a09ef6f2a913c" translate="yes" xml:space="preserve">
          <source>Translation</source>
          <target state="translated">Translation</target>
        </trans-unit>
        <trans-unit id="eb726f366153f5273c287e7afe4de066bacf45f4" translate="yes" xml:space="preserve">
          <source>Traverses paths according to the given &lt;code&gt;glob&lt;/code&gt; expression and returns a list of matches.</source>
          <target state="translated">주어진 &lt;code&gt;glob&lt;/code&gt; 표현식 에 따라 경로를 탐색 하고 일치하는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2b9bae059da0df068a9a43bf70813a2cc0165c80" translate="yes" xml:space="preserve">
          <source>Tries to create the directory &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">디렉토리 &lt;code&gt;path&lt;/code&gt; 를 작성하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="1274a0f5d2ed4698598c860012ff8d0e34e7aeca" translate="yes" xml:space="preserve">
          <source>Tries to delete the dir at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 디렉토리를 삭제하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="79494b7d121b41ed702af12c8820f16d4b440ca4" translate="yes" xml:space="preserve">
          <source>Tries to delete the file &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;path&lt;/code&gt; 를 삭제하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7267f3b3b246e3958379e99f6b106bc8021e929a" translate="yes" xml:space="preserve">
          <source>Tries to set up a connection to node.</source>
          <target state="translated">노드에 대한 연결을 설정하려고합니다.</target>
        </trans-unit>
        <trans-unit id="836d86c6c848f493d3ff2e48bb6f5f308c9c411f" translate="yes" xml:space="preserve">
          <source>Truthy and falsy values</source>
          <target state="translated">진실하고 거짓된 가치</target>
        </trans-unit>
        <trans-unit id="a0d62e00a429e56556bf1455c0175bc4654fbf2a" translate="yes" xml:space="preserve">
          <source>Truthy values:</source>
          <target state="translated">진실한 가치 :</target>
        </trans-unit>
        <trans-unit id="ccf6e0cd6e8c63d5ae42d6c2569741d54c61f4d5" translate="yes" xml:space="preserve">
          <source>Try to connect two telnet clients at the same time. When you do so, you will notice that the second client doesn&amp;rsquo;t echo:</source>
          <target state="translated">두 개의 텔넷 클라이언트를 동시에 연결하십시오. 그렇게하면 두 번째 클라이언트가 에코하지 않는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965b5b1e76f73cc1dd48f82e36854d491ebbe607" translate="yes" xml:space="preserve">
          <source>TryClauseError</source>
          <target state="translated">TryClauseError</target>
        </trans-unit>
        <trans-unit id="bb04413eca53d9d4f9ada422b12b458b1a19dc69" translate="yes" xml:space="preserve">
          <source>TryClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">TryClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3d6d3a96a93234d43a687b1131b3901f142d46c" translate="yes" xml:space="preserve">
          <source>Trying to access an attribute that was not defined will print a warning:</source>
          <target state="translated">정의되지 않은 속성에 액세스하려고하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="dc4f3a01c46fc5525a4e91e907b957d6688cd48a" translate="yes" xml:space="preserve">
          <source>Tuple describing the client of a call request.</source>
          <target state="translated">호출 요청의 클라이언트를 설명하는 튜플.</target>
        </trans-unit>
        <trans-unit id="eb4abd3a92bef73903da00d10d474ba4501f6bab" translate="yes" xml:space="preserve">
          <source>Tuple-based HashDict implementation.</source>
          <target state="translated">튜플 기반 HashDict 구현.</target>
        </trans-unit>
        <trans-unit id="91c1b6c09400f880e21ca1e3d43c7f7b3443b423" translate="yes" xml:space="preserve">
          <source>Tuple-based HashSet implementation.</source>
          <target state="translated">튜플 기반 HashSet 구현</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="a76966417cbfeb7cb220fffc01419f6c11debbd2" translate="yes" xml:space="preserve">
          <source>Tuples are a compound type and each tuple is identified by the types inside it (in this case, a number and a string). To understand why &lt;code&gt;String.t&lt;/code&gt; is not written as &lt;code&gt;string&lt;/code&gt;, have another look at the &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#the-string-type&quot;&gt;typespecs docs&lt;/a&gt;.</source>
          <target state="translated">튜플은 복합 유형이며 각 튜플은 내부 유형 (이 경우 숫자 및 문자열)으로 식별됩니다. &lt;code&gt;String.t&lt;/code&gt; 가 &lt;code&gt;string&lt;/code&gt; 작성되지 않은 이유를 이해하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#the-string-type&quot;&gt;typespecs 문서를&lt;/a&gt; 다시 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="793259df3cfbea29ea94e801a3dc852ba0481364" translate="yes" xml:space="preserve">
          <source>Tuples are compared by size, then element by element.</source>
          <target state="translated">튜플은 크기별로 비교 한 다음 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cbb1dd7716c923dc57835e6545295dd3e5141a82" translate="yes" xml:space="preserve">
          <source>Tuples are denoted with curly braces:</source>
          <target state="translated">튜플은 중괄호로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d295b48169d12e8a4a885f2969f7ebb5f288bf" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="translated">튜플은 여러 요소를위한 고정 크기 컨테이너로 사용됩니다. 요소 컬렉션을 조작하려면 대신 목록을 사용하십시오. &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 함수는 튜플에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c44772da431d393d0ff2d0292ec743fdb504db7" translate="yes" xml:space="preserve">
          <source>Tuples are intended as fixed-size containers for multiple elements. To manipulate a collection of elements, use a list instead. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions do not work on tuples.</source>
          <target state="translated">튜플은 여러 요소에 대한 고정 크기 컨테이너로 사용됩니다. 요소 모음을 조작하려면 대신 목록을 사용하십시오. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 함수는 튜플에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6007daf5620486dbca1cb7e87969100af322cc9f" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="translated">튜플은 일반적으로 함수에 여러 반환 값이 있거나 오류 처리에 사용됩니다. 주어진 파일을 읽은 경우 &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;{:ok, contents}&lt;/code&gt; 반환 하거나 파일이없는 경우와 같은 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c05d54cdc90ebeef0a2917964fc5bc31fa686547" translate="yes" xml:space="preserve">
          <source>Tuples are typically used either when a function has multiple return values or for error handling. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;{:ok, contents}&lt;/code&gt; if reading the given file is successful, or else &lt;code&gt;{:error, reason}&lt;/code&gt; such as when the file does not exist.</source>
          <target state="translated">튜플은 일반적으로 함수에 여러 반환 값이 있거나 오류 처리에 사용됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; 은 주어진 파일 읽기가 성공하면 &lt;code&gt;{:ok, contents}&lt;/code&gt; 반환하고, 그렇지 않으면 파일이 존재하지 않는 경우와 같은 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="db66b3f610de5841b308865fc05862649e3b269d" translate="yes" xml:space="preserve">
          <source>Tuples have their own representation, except for two-element tuples, which are represented as themselves:</source>
          <target state="translated">튜플은 두 요소로 된 튜플을 제외하고는 자체적으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f2c5c5f76542db20a27b0649c5619472b41e0e" translate="yes" xml:space="preserve">
          <source>Tuples may appear in patterns using the curly brackets syntax (&lt;code&gt;{}&lt;/code&gt;). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:</source>
          <target state="translated">튜플은 중괄호 구문 ( &lt;code&gt;{}&lt;/code&gt; )을 사용하여 패턴에 나타날 수 있습니다 . 패턴의 튜플은 동일한 크기의 튜플에만 일치하며 각 개별 튜플 요소도 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d23bff74f82a432abab310b02bda096c901d05c" translate="yes" xml:space="preserve">
          <source>Tuples store elements contiguously in memory. This means accessing a tuple element by index or getting the tuple size is a fast operation. Indexes start from zero:</source>
          <target state="translated">튜플은 메모리에 요소를 연속적으로 저장합니다. 이는 인덱스로 튜플 요소에 액세스하거나 튜플 크기를 얻는 것이 빠른 작업임을 의미합니다. 인덱스는 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4827be384e5b92dfa89593fd34e759c469d83f68" translate="yes" xml:space="preserve">
          <source>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires creating a new tuple in memory:</source>
          <target state="translated">반면에 튜플은 메모리에 연속적으로 저장됩니다. 이것은 튜플 크기를 얻거나 색인으로 요소에 액세스하는 것이 빠르다는 것을 의미합니다. 그러나 튜플에 요소를 업데이트하거나 추가하려면 메모리에 새 튜플을 만들어야하기 때문에 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="c4eeec2166369454fe72d485310480999d9e41ff" translate="yes" xml:space="preserve">
          <source>Turns a distributed node into a non-distributed node.</source>
          <target state="translated">분산 노드를 비 분산 노드로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="78cb13dab8abb15c4418dcf574cee609f60fff10" translate="yes" xml:space="preserve">
          <source>Turns a non-distributed node into a distributed node.</source>
          <target state="translated">비 분산 노드를 분산 노드로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="0d200b5cca6122d2ea47ef95bc1ae207e6bed360" translate="yes" xml:space="preserve">
          <source>Two keywords are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">두 개의 키워드에 동일한 키가 포함되어 있고 해당 키에 동일한 값이 포함되어 있으면 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ef661032731cfceb2a4bb6e8a73cfcacce40a182" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#--/2&quot;&gt; &lt;code&gt;Kernel.--/2&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 두 목록을 연결하고 뺄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fddf4faa5ad6ac7c7817431eda4bde5737ecc7a7" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated and subtracted using the &lt;a href=&quot;kernel#++/2&quot;&gt;&lt;code&gt;Kernel.++/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#--/2&quot;&gt;&lt;code&gt;Kernel.--/2&lt;/code&gt;&lt;/a&gt; operators:</source>
          <target state="translated">&lt;a href=&quot;kernel#++/2&quot;&gt; &lt;code&gt;Kernel.++/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#--/2&quot;&gt; &lt;code&gt;Kernel.--/2&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 두 개의 목록을 연결하고 뺄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6eb24ea9f355df425e35046856649369306137b" translate="yes" xml:space="preserve">
          <source>Two lists can be concatenated or subtracted using the &lt;code&gt;++/2&lt;/code&gt; and &lt;code&gt;--/2&lt;/code&gt; operators respectively:</source>
          <target state="translated">&lt;code&gt;++/2&lt;/code&gt; 및 &lt;code&gt;--/2&lt;/code&gt; 연산자를 각각 사용하여 두 개의 목록을 연결하거나 뺄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28dd04de329219b61258e459b05052b6d195ed8c" translate="yes" xml:space="preserve">
          <source>Two maps are considered to be equal if they contain the same keys and those keys contain the same values.</source>
          <target state="translated">두 개의 맵이 동일한 키를 포함하고 해당 키가 동일한 값을 포함하는 경우 두 맵이 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="130c35a2878e328189066b98bf54e31f721289db" translate="yes" xml:space="preserve">
          <source>Type &amp;ldquo;hello&amp;rdquo;, press enter, and you will get &amp;ldquo;hello&amp;rdquo; back. Excellent!</source>
          <target state="translated">&amp;ldquo;hello&amp;rdquo;를 입력하고 Enter를 누르면&amp;ldquo;hello&amp;rdquo;가 다시 나타납니다. 우수한!</target>
        </trans-unit>
        <trans-unit id="e252ef20859612096fbf35e99f3db43d0d903502" translate="yes" xml:space="preserve">
          <source>Type checks and other boolean checks that are allowed in guard clauses are named with an &lt;code&gt;is_&lt;/code&gt; prefix.</source>
          <target state="translated">가드 절에 허용되는 유형 검사 및 기타 부울 검사에는 &lt;code&gt;is_&lt;/code&gt; 접두사가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="63885d680ea99a25f2552e75b805c2d3723587d4" translate="yes" xml:space="preserve">
          <source>Type operator. Used by types and bitstrings to specify types.</source>
          <target state="translated">유형 연산자. 유형 및 비트 문자열에서 유형을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce1a99d47d96ec4a8d262432fdeeb24d34842d1c" translate="yes" xml:space="preserve">
          <source>Type specifications (sometimes referred to as &lt;em&gt;typespecs&lt;/em&gt;) are defined in different contexts using the following attributes:</source>
          <target state="translated">유형 스펙 (종종 &lt;em&gt;typespecs&lt;/em&gt; 라고도 함 )은 다음 속성을 사용하여 다른 컨텍스트에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f295ce9af290691ba77bd28066b72b6d97e560" translate="yes" xml:space="preserve">
          <source>Type variables with no restriction can also be defined using &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 를 사용하여 제한없이 타입 변수를 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="9c292c75a9bfb2deb75a816df8b4fa93d8b86cdf" translate="yes" xml:space="preserve">
          <source>Types and specs</source>
          <target state="translated">유형과 사양</target>
        </trans-unit>
        <trans-unit id="cd76b0391fb1a7a64c931e4a4dc1d98639420e28" translate="yes" xml:space="preserve">
          <source>Types and their syntax</source>
          <target state="translated">유형과 구문</target>
        </trans-unit>
        <trans-unit id="0bc4703b28f4924a9c44bceee00bf1363064b5ea" translate="yes" xml:space="preserve">
          <source>Types can be defined for tuples with the &lt;code&gt;record/2&lt;/code&gt; macro (only available in typespecs). This macro will expand to a tuple as seen in the example below:</source>
          <target state="translated">&lt;code&gt;record/2&lt;/code&gt; 매크로를 사용하여 튜플에 대한 유형을 정의 할 수 있습니다 (typespec에서만 사용 가능). 이 매크로는 아래 예제와 같이 튜플로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="aa2e6017cafdcec12ffadda705782bbfa3365007" translate="yes" xml:space="preserve">
          <source>Types can be parameterized by defining variables as parameters; these variables can then be used to define the type.</source>
          <target state="translated">변수를 매개 변수로 정의하여 유형을 매개 변수화 할 수 있습니다. 그런 다음이 변수를 사용하여 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9642fee222699c21f35d30c296f0220d194b3b26" translate="yes" xml:space="preserve">
          <source>Typespec attributes</source>
          <target state="translated">타입 스펙 속성</target>
        </trans-unit>
        <trans-unit id="ec4586f03bdf53faaacd4a0a1f5bfd0f6c72e82a" translate="yes" xml:space="preserve">
          <source>Typespecs</source>
          <target state="translated">Typespecs</target>
        </trans-unit>
        <trans-unit id="12ee67883b50a8a9b8616d935b79570fd90fb391" translate="yes" xml:space="preserve">
          <source>Typespecs and behaviours</source>
          <target state="translated">타입 스펙과 행동</target>
        </trans-unit>
        <trans-unit id="426efe2f128e5103f26a5651730adbe39dfe3a7f" translate="yes" xml:space="preserve">
          <source>Typespecs are not only useful to developers as additional documentation. The Erlang tool &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;Dialyzer&lt;/a&gt;, for example, uses typespecs in order to perform static analysis of code. That&amp;rsquo;s why, in the &lt;code&gt;QuietCalculator&lt;/code&gt; example, we wrote a spec for the &lt;code&gt;make_quiet/1&lt;/code&gt; function even though it was defined as a private function.</source>
          <target state="translated">타입 스펙은 개발자에게 추가적인 문서로 유용하지 않을 수도 있습니다. 예를 들어 Erlang 도구 &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;Dialyzer&lt;/a&gt; 는 정적 코드 분석을 수행하기 위해 typespecs를 사용합니다. 이것이 &lt;code&gt;QuietCalculator&lt;/code&gt; 예제에서 개인 함수로 정의되었지만 &lt;code&gt;make_quiet/1&lt;/code&gt; 함수에 대한 스펙을 작성한 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="27a01a6204a37c38992dd52cc20fa3db2b61cbf1" translate="yes" xml:space="preserve">
          <source>Typical error reasons are the same as in &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#read/1&quot;&gt;&lt;code&gt;read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#write/3&quot;&gt;&lt;code&gt;write/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 오류 이유는 &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#read/1&quot;&gt; &lt;code&gt;read/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#write/3&quot;&gt; &lt;code&gt;write/3&lt;/code&gt; 과 동일&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="67c8d97f0dcec5fe713e0be3b64521ea6acf59de" translate="yes" xml:space="preserve">
          <source>Typical error reasons are:</source>
          <target state="translated">일반적인 오류 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f629170b36b9e9384cae62822a95fe4136c915d" translate="yes" xml:space="preserve">
          <source>Typical error reasons:</source>
          <target state="translated">일반적인 오류 이유 :</target>
        </trans-unit>
        <trans-unit id="29820537aaefd464fe53b0df62deac28df35005d" translate="yes" xml:space="preserve">
          <source>Typically called after formatting when the data cannot be printed.</source>
          <target state="translated">일반적으로 데이터를 인쇄 할 수없는 경우 포맷 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0018f0d1c5a28ac0ba1af21c25d258db67bae7ff" translate="yes" xml:space="preserve">
          <source>Typically developers do not use the &lt;code&gt;spawn&lt;/code&gt; functions, instead they use abstractions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, built on top of &lt;code&gt;spawn&lt;/code&gt;, that spawns processes with more conveniences in terms of introspection and debugging.</source>
          <target state="translated">일반적으로 개발자는 &lt;code&gt;spawn&lt;/code&gt; 함수를 사용하지 않고 대신 introspection 및 디버깅 측면에서 더 편리하게 프로세스를 생성 하는 &lt;code&gt;spawn&lt;/code&gt; 위에 구축 된 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 와 같은 추상화를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="2ebdb0dbd819b614930942168eaeeb854d37cbf9" translate="yes" xml:space="preserve">
          <source>Typically developers do not use the &lt;code&gt;spawn&lt;/code&gt; functions, instead they use abstractions such as &lt;a href=&quot;task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt;, built on top of &lt;code&gt;spawn&lt;/code&gt;, that spawns processes with more conveniences in terms of introspection and debugging.</source>
          <target state="translated">일반적으로 개발자는 &lt;code&gt;spawn&lt;/code&gt; 기능을 사용하지 않고 대신 &lt;code&gt;spawn&lt;/code&gt; 위에 빌드 된 &lt;a href=&quot;task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 와 같은 추상화를 사용 하여 검사 및 디버깅 측면에서보다 편리한 프로세스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a41048f60fc8036bd19784fff24807617c9ba6f2" translate="yes" xml:space="preserve">
          <source>Typically, stable releases are pushed to Hex. If you want to depend on an external dependency still in development, Mix is able to manage Git dependencies too:</source>
          <target state="translated">일반적으로 안정적인 릴리스는 16 진으로 푸시됩니다. 아직 개발중인 외부 종속성에 의존하려는 경우 Mix는 Git 종속성도 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e81c0c3d0d9554aaaa890589c591cb2c6de83b83" translate="yes" xml:space="preserve">
          <source>Typically, this is used when a process started from a certain shell should have a group leader other than &lt;code&gt;:init&lt;/code&gt;.</source>
          <target state="translated">일반적으로 특정 쉘에서 시작된 프로세스에 &lt;code&gt;:init&lt;/code&gt; 이외의 그룹 리더가 있어야하는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="19526e6dfc6064b512194499eae8afdcd81dca35" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;a href=&quot;#async_nolink/3&quot;&gt;&lt;code&gt;async_nolink/3&lt;/code&gt;&lt;/a&gt; when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is meant to run a single task and track its status:</source>
          <target state="translated">일반적으로 작업이 실패 할 것으로 예상되고 호출자를 중단하지 않으려는 경우 &lt;a href=&quot;#async_nolink/3&quot;&gt; &lt;code&gt;async_nolink/3&lt;/code&gt; &lt;/a&gt; 를 사용 합니다. &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 단일 작업을 실행하고 상태를 추적 하는 예제를 보도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8798d630c8e10ea5c64e566bec0b0fe8e5e77e30" translate="yes" xml:space="preserve">
          <source>Typically, you use &lt;a href=&quot;#async_nolink/3&quot;&gt;&lt;code&gt;async_nolink/3&lt;/code&gt;&lt;/a&gt; when there is a reasonable expectation that the task may fail, and you don't want it to take down the caller. Let's see an example where a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is meant to run a single task and track its status:</source>
          <target state="translated">일반적으로 작업이 실패 할 수 있다는 합리적인 기대가 있고 호출자를 중단하지 않으려는 경우 &lt;a href=&quot;#async_nolink/3&quot;&gt; &lt;code&gt;async_nolink/3&lt;/code&gt; &lt;/a&gt; 를 사용 합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 단일 작업을 실행하고 해당 상태를 추적 하는 예를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="09f0409f5ecd55093b52d29617566df8dfd0cc27" translate="yes" xml:space="preserve">
          <source>UTF-8 and Encodings</source>
          <target state="translated">UTF-8 및 인코딩</target>
        </trans-unit>
        <trans-unit id="40d44fb77280648f021d454874b73243b9965e08" translate="yes" xml:space="preserve">
          <source>UTF-8 and Unicode</source>
          <target state="translated">UTF-8 및 유니 코드</target>
        </trans-unit>
        <trans-unit id="93fa3107e0f78c4c5bf63b64e4e03caae13e12dc" translate="yes" xml:space="preserve">
          <source>UTF-8 requires one byte to represent the characters &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, and &lt;code&gt;o&lt;/code&gt;, but two bytes to represent &lt;code&gt;ł&lt;/code&gt;. In Elixir, you can get a character&amp;rsquo;s code point by using &lt;code&gt;?&lt;/code&gt;:</source>
          <target state="translated">UTF-8은 문자 &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;o&lt;/code&gt; 를 나타내는 1 바이트가 필요 하지만 &lt;code&gt;ł&lt;/code&gt; 을 나타내는 2 바이트가 필요합니다 . Elixir에서는 &lt;code&gt;?&lt;/code&gt; 를 사용하여 캐릭터의 코드 포인트를 얻을 수 있습니다 . :</target>
        </trans-unit>
        <trans-unit id="4ba0eecf4f2b37abbf01f86b85c444b51d79130b" translate="yes" xml:space="preserve">
          <source>Umbrella applications can also be used as a stepping stone for eventually extracting an application from your codebase. For example, imagine a web application that has to send &amp;ldquo;push notifications&amp;rdquo; to its users. The whole &amp;ldquo;push notifications system&amp;rdquo; can be developed as a separate application in the umbrella, with its own supervision tree and APIs. If you ever run into a situation where another project needs the push notifications system, the system can be moved to a private repository or a Hex package.</source>
          <target state="translated">또한 우산 응용 프로그램을 코드베이스에서 응용 프로그램을 추출하기위한 디딤돌로 사용할 수도 있습니다. 예를 들어, 사용자에게 &quot;푸시 알림&quot;을 ​​보내야하는 웹 응용 프로그램을 상상해보십시오. 전체 &quot;푸시 알림 시스템&quot;은 자체 감독 트리 및 API를 통해 별도의 애플리케이션으로 개발 될 수 있습니다. 다른 프로젝트에 푸시 알림 시스템이 필요한 상황에 처한 경우 시스템을 개인 저장소 또는 Hex 패키지로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="851ed712aa0571dbe2c6f112b44c8797ec7c4c5e" translate="yes" xml:space="preserve">
          <source>Umbrella projects</source>
          <target state="translated">우산 프로젝트</target>
        </trans-unit>
        <trans-unit id="43c968179421920425ac688f848988a9c56a1013" translate="yes" xml:space="preserve">
          <source>Umbrella projects are a convenience to help you organize and manage multiple applications. While it provides a degree of separation between applications, those applications are not fully decoupled, as they share the same configuration and the same dependencies.</source>
          <target state="translated">우산 프로젝트는 여러 응용 프로그램을 구성하고 관리하는 데 편리합니다. 응용 프로그램간에 어느 정도의 분리가 제공되지만, 해당 응용 프로그램은 동일한 구성과 동일한 종속성을 공유하므로 완전히 분리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b04e40d6c4b172a53c1b297ef8e44dbbe21358ea" translate="yes" xml:space="preserve">
          <source>Umbrellas</source>
          <target state="translated">Umbrellas</target>
        </trans-unit>
        <trans-unit id="7d6b777bb78f858357184c0cf5af750b3f2ffa24" translate="yes" xml:space="preserve">
          <source>Unary</source>
          <target state="translated">Unary</target>
        </trans-unit>
        <trans-unit id="de5d06c8499ec2b6ae1a8811f2fac4af788e75b6" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError</source>
          <target state="translated">UndefinedFunctionError</target>
        </trans-unit>
        <trans-unit id="305519a8e77b6e01d180181d201634eba9423ae4" translate="yes" xml:space="preserve">
          <source>UndefinedFunctionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UndefinedFunctionError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="47bcfae4a535fdd5dc3c9474709313c0c05cda2a" translate="yes" xml:space="preserve">
          <source>Underline: none.</source>
          <target state="translated">밑줄 : 없음</target>
        </trans-unit>
        <trans-unit id="74cc1e1026bd71e93c70958a6c844e8826bbbfcc" translate="yes" xml:space="preserve">
          <source>Underline: single.</source>
          <target state="translated">밑줄 : 단일.</target>
        </trans-unit>
        <trans-unit id="f97b844a47d0ddc9c28ad5334d4b5c8bebe7ba04" translate="yes" xml:space="preserve">
          <source>Underneath a struct is just a map with a &lt;code&gt;:__struct__&lt;/code&gt; key pointing to the &lt;code&gt;User&lt;/code&gt; module:</source>
          <target state="translated">구조체 아래에는 &lt;code&gt;:__struct__&lt;/code&gt; 키가 &lt;code&gt;User&lt;/code&gt; 모듈을 가리키는 맵이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ecb7df30047a87c4fc859f515326bcb1df1fdc5" translate="yes" xml:space="preserve">
          <source>Underscore (&lt;code&gt;_foo&lt;/code&gt;)</source>
          <target state="translated">밑줄 ( &lt;code&gt;_foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="860a89de764183b070c833d2c56a715407fdf5ae" translate="yes" xml:space="preserve">
          <source>Underscore functions</source>
          <target state="translated">밑줄 기능</target>
        </trans-unit>
        <trans-unit id="07214c1f037134f45b6afd6fb6be34b85a19cbdd" translate="yes" xml:space="preserve">
          <source>Understanding Aliases</source>
          <target state="translated">별명 이해</target>
        </trans-unit>
        <trans-unit id="cf49459d86609fbaea12c1c990c331d67fab00b7" translate="yes" xml:space="preserve">
          <source>Understanding applications</source>
          <target state="translated">응용 프로그램 이해</target>
        </trans-unit>
        <trans-unit id="a5d78374ca4469419766b74347b324cc8a588c26" translate="yes" xml:space="preserve">
          <source>Understanding the printed graph</source>
          <target state="translated">인쇄 된 그래프 이해</target>
        </trans-unit>
        <trans-unit id="7e6e7909c64b19402a59c9e41bf6f2ead8be7854" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars according to the map given.</source>
          <target state="translated">주어진 맵에 따라 주어진 문자를 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="17a4b21d25e341e163b3fc9fec0b7c0beae4ac5a" translate="yes" xml:space="preserve">
          <source>Unescapes the given chars.</source>
          <target state="translated">주어진 문자를 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4f4713c47fdabdbf578d4a71eec889931003b842" translate="yes" xml:space="preserve">
          <source>Unfortunately, similar to &lt;code&gt;IO.inspect/2&lt;/code&gt;, &lt;code&gt;IEx.pry/0&lt;/code&gt; also requires us to change the code we intend to debug. Luckily IEx also provides a &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt;&lt;code&gt;break!/2&lt;/code&gt;&lt;/a&gt; function which allows you set and manage breakpoints on any Elixir code without modifying its source:</source>
          <target state="translated">불행하게도, 유사 &lt;code&gt;IO.inspect/2&lt;/code&gt; , &lt;code&gt;IEx.pry/0&lt;/code&gt; 또한 우리가 디버깅하려는 코드를 변경 우리를 필요로한다. 운 좋게도 IEx는 소스를 수정하지 않고 모든 Elixir 코드에서 중단 점을 설정하고 관리 할 수 있는 &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html#break!/2&quot;&gt; &lt;code&gt;break!/2&lt;/code&gt; &lt;/a&gt; 기능 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="c9219d4bebf3a43b3cb39fddf36fce444eec5523" translate="yes" xml:space="preserve">
          <source>Unicode Syntax</source>
          <target state="translated">유니 코드 구문</target>
        </trans-unit>
        <trans-unit id="0b474ff440f8ab612fe1e1943a887fd958d5ed36" translate="yes" xml:space="preserve">
          <source>Unicode and Code Points</source>
          <target state="translated">유니 코드 및 코드 포인트</target>
        </trans-unit>
        <trans-unit id="9230bbe0897bd3834d6a401ee2097bdf85ecad8d" translate="yes" xml:space="preserve">
          <source>Unicode atoms in Elixir follow the identifier rule above with the following modifications:</source>
          <target state="translated">Elixir의 유니 코드 원자는 다음과 같은 수정으로 위의 식별자 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="7372ec76fd7737f65218f4920228b83bfa1d58d4" translate="yes" xml:space="preserve">
          <source>Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Code Point&lt;/a&gt;.</source>
          <target state="translated">유니 코드는 레퍼토리의 모든 문자를 코드 차트로 구성하고 각 문자에는 고유 한 숫자 색인이 부여됩니다. 이 숫자 인덱스를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;코드 포인트라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c1cd0bc55280570ee38ec7b425e9a53867a918b8" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError</source>
          <target state="translated">UnicodeConversionError</target>
        </trans-unit>
        <trans-unit id="17431ce3c7303d531227e8a58c83d5667bb2fc09" translate="yes" xml:space="preserve">
          <source>UnicodeConversionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">UnicodeConversionError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="39e7100b363b0c844d4355a58d8d2bcf3d045da9" translate="yes" xml:space="preserve">
          <source>Uninstalls local archives.</source>
          <target state="translated">로컬 아카이브를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="987e61e41c4febfea2dd5909d903f8a6923f84be" translate="yes" xml:space="preserve">
          <source>Uninstalls local escripts</source>
          <target state="translated">로컬 escript를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6c7917e8b4eb34e9ee648bbddd83c2ea876861aa" translate="yes" xml:space="preserve">
          <source>Uninstalls local escripts:</source>
          <target state="translated">로컬 escript를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d24756b8871b9d0b4227e2aeadf94c161941dedb" translate="yes" xml:space="preserve">
          <source>Unit and Size</source>
          <target state="translated">단위와 크기</target>
        </trans-unit>
        <trans-unit id="7476fffdc753c76439401e20c5fa467d3860aa0e" translate="yes" xml:space="preserve">
          <source>Unit testing framework for Elixir.</source>
          <target state="translated">Elixir의 단위 테스트 프레임 워크.</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="cfbf337783a51f862d0cc59c306e1cd8f3532bc3" translate="yes" xml:space="preserve">
          <source>Unix times are always in UTC and therefore the DateTime will be returned in UTC.</source>
          <target state="translated">유닉스 시간은 항상 UTC이므로 DateTime은 UTC로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ada7bf7ca1b8ad5c554b83d4ab0831e359db85dc" translate="yes" xml:space="preserve">
          <source>Unix-like operating systems</source>
          <target state="translated">유닉스 계열 운영 체제</target>
        </trans-unit>
        <trans-unit id="37ac014f65a6115890eb6cc91e8f2865ac295f23" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#expand/2&quot;&gt;&lt;code&gt;expand/2&lt;/code&gt;&lt;/a&gt;, no attempt is made to resolve &lt;code&gt;..&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;#expand/2&quot;&gt; &lt;code&gt;expand/2&lt;/code&gt; &lt;/a&gt; , 시도를 해결하기 위해 이루어지지 않습니다 &lt;code&gt;..&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e18509c97a5b05619653ea5f9061749ced83e99e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;assert_received&lt;/code&gt;, it has a default &lt;code&gt;timeout&lt;/code&gt; of 100 milliseconds.</source>
          <target state="translated">&lt;code&gt;assert_received&lt;/code&gt; 와 달리 기본 &lt;code&gt;timeout&lt;/code&gt; 은 100 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="90388e527e157889a4f6398ea86608eb36a3d8e9" translate="yes" xml:space="preserve">
          <source>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Erlang과 달리 이러한 속성은 기본적으로 모듈에 저장되지 않습니다. Elixir에서는 컴파일시 사용할 수있는 임시 데이터를 저장하기 위해 사용자 지정 속성을 사용하는 것이 일반적이기 때문입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 사용자 지정 속성이 Erlang에 더 가깝게 작동하도록 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2436badc9eff92032ec9ac619271277eb100f7c7" translate="yes" xml:space="preserve">
          <source>Unlike Erlang, such attributes are not stored in the module by default since it is common in Elixir to use custom attributes to store temporary data that will be available at compile-time. Custom attributes may be configured to behave closer to Erlang by using &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Erlang과 달리, 이러한 속성은 Elixir에서 사용자 정의 속성을 사용하여 컴파일 타임에 사용할 수있는 임시 데이터를 저장하는 것이 일반적이기 때문에 기본적으로 모듈에 저장되지 않습니다. &lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; 를 사용하여 사용자 정의 속성을 Erlang에 더 가깝게 작동하도록 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b56b7c857aa7ffa6e7b36170f0491a230a7cf9f0" translate="yes" xml:space="preserve">
          <source>Unlike other hooks, &lt;code&gt;@on_definition&lt;/code&gt; will only invoke functions and never macros. This is to avoid &lt;code&gt;@on_definition&lt;/code&gt; callbacks from redefining functions that have just been defined in favor of more explicit approaches.</source>
          <target state="translated">다른 후크와 달리 &lt;code&gt;@on_definition&lt;/code&gt; 은 함수 만 호출하고 매크로는 사용하지 않습니다. 이것은 보다 명확한 접근 방식을 위해 정의 된 재정의 함수에서 &lt;code&gt;@on_definition&lt;/code&gt; 콜백 을 피하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="94507a67a9f296aef298df58dcc28d14f54c548d" translate="yes" xml:space="preserve">
          <source>Unlike pattern matching via &lt;code&gt;=&lt;/code&gt;, if the sizes of the left and right lists don't match, destructuring simply stops instead of raising an error.</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 를 통한 패턴 일치와 달리 왼쪽 및 오른쪽 목록의 크기가 일치하지 않으면 오류를 발생시키는 대신 파괴가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="d9890160c4982970542ec14738f7c0e637cd08c2" translate="yes" xml:space="preserve">
          <source>Unlinking the task process started with &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;. If you unlink the processes and the task does not belong to any supervisor, you may leave dangling tasks in case the parent dies.</source>
          <target state="translated">시작 작업 과정의 연결을 해제 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 를을 . 프로세스를 연결 해제하고 해당 작업이 수퍼바이저에 속하지 않으면 부모가 사망하는 경우 매달려 작업을 남길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11bf0305dcee4e7f1f93ac8f6d2c882005c71769" translate="yes" xml:space="preserve">
          <source>Unlinks and shuts down the task, and then checks for a reply.</source>
          <target state="translated">작업을 연결 해제하고 종료 한 다음 회신을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e12be5ddb337ed9c6e7cda41d5621c3350bb29f0" translate="yes" xml:space="preserve">
          <source>Unloads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;app&lt;/code&gt; 언로드합니다 .</target>
        </trans-unit>
        <trans-unit id="91e4a94ba2bbaf79b224a6d7c13a57d58235dccd" translate="yes" xml:space="preserve">
          <source>Unlocks the given dependencies.</source>
          <target state="translated">주어진 종속성을 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4a00f27d2826c92443fcf4fb80f0a03b5f251cb2" translate="yes" xml:space="preserve">
          <source>Unquoted atoms start with a colon (&lt;code&gt;:&lt;/code&gt;) which must be immediately followed by an underscore or a Unicode letter. The atom may continue using a sequence of Unicode letters, numbers, underscores, and &lt;code&gt;@&lt;/code&gt;. Atoms may end in &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification. Valid unquoted atoms are: &lt;code&gt;:ok&lt;/code&gt;, &lt;code&gt;:ISO8601&lt;/code&gt;, and &lt;code&gt;:integer?&lt;/code&gt;.</source>
          <target state="translated">(인용 부호 원자는 콜론으로 시작 &lt;code&gt;:&lt;/code&gt; ) 바로 밑줄 또는 유니 코드 문자가 와야합니다. 아톰은 일련의 유니 코드 문자, 숫자, 밑줄 및 &lt;code&gt;@&lt;/code&gt; 를 계속 사용할 수 있습니다 . 원자는 끝날 수 있습니다 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; . 공식 사양 은 &lt;a href=&quot;unicode-syntax&quot;&gt;유니 코드 구문&lt;/a&gt; 을 참조하십시오 . 인용되지 않은 유효한 원자는 : &lt;code&gt;:ok&lt;/code&gt; , &lt;code&gt;:ISO8601&lt;/code&gt; 및 &lt;code&gt;:integer?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dac4c6b4443202cc8583016a137c1afc9253dd0" translate="yes" xml:space="preserve">
          <source>Unquotes the given expression inside a quoted expression.</source>
          <target state="translated">따옴표로 묶은 표현식 안에서 주어진 표현식의 인용을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="51a3755b8963981e97be12c3f11d259db2190b9a" translate="yes" xml:space="preserve">
          <source>Unquotes the given list expanding its arguments.</source>
          <target state="translated">주어진 목록을 인용하여 인수를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="08053b86ce7b78d018827349dcd3d261a98511fd" translate="yes" xml:space="preserve">
          <source>Unquoting</source>
          <target state="translated">Unquoting</target>
        </trans-unit>
        <trans-unit id="3494d6cc701ad4351f6f7781151b09d2bb134df7" translate="yes" xml:space="preserve">
          <source>Unquoting is very useful when working with macros. When writing macros, developers are able to receive code chunks and inject them inside other code chunks, which can be used to transform code or write code that generates code during compilation.</source>
          <target state="translated">인용 부호는 매크로 작업시 매우 유용합니다. 매크로를 작성할 때 개발자는 코드 청크를 받아 다른 코드 청크 안에 삽입 할 수 있습니다.이 코드 청크는 코드를 변환하거나 컴파일 중에 코드를 생성하는 코드를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70957cdc250ef56f1d10dffbca7af3e59a0b3d13" translate="yes" xml:space="preserve">
          <source>Unregister entries for a given key matching a pattern.</source>
          <target state="translated">패턴과 일치하는 주어진 키에 대한 항목을 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="e900939218e97f5edc5de0f78b18c10f6778936f" translate="yes" xml:space="preserve">
          <source>Unregisters all entries for the given &lt;code&gt;key&lt;/code&gt; associated to the current process in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;registry&lt;/code&gt; 의 현재 프로세스와 연관된 주어진 &lt;code&gt;key&lt;/code&gt; 대한 모든 항목을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="d8766d37827e5742cd1fbee4aed47607e97dcf45" translate="yes" xml:space="preserve">
          <source>Unregisters entries for keys matching a pattern associated to the current process in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;registry&lt;/code&gt; 의 현재 프로세스와 관련된 패턴과 일치하는 키 항목을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="872098875ed11d68f92691129750cd5f8910e31e" translate="yes" xml:space="preserve">
          <source>Updates &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">주어진 기능으로 &lt;code&gt;key&lt;/code&gt; 를 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="bd67c840db661b5ff35c7988f0c313e081b6c4a7" translate="yes" xml:space="preserve">
          <source>Updates a key in a nested structure.</source>
          <target state="translated">중첩 구조에서 키를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="913040a7783b16d3a66109d11466e1f3715b2f23" translate="yes" xml:space="preserve">
          <source>Updates a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 중첩 구조를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="a6ff992d51a35ca8eeaea3b46d7a9f9c7a1d02bf" translate="yes" xml:space="preserve">
          <source>Updates modification time (mtime) and access time (atime) of the given file.</source>
          <target state="translated">지정된 파일의 수정 시간 (mtime) 및 액세스 시간 (atime)을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="97ba8cd55c834ecfd3ee8f8cbce9327196d85da6" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;keywords&lt;/code&gt; with the given function.</source>
          <target state="translated">주어진 기능으로 &lt;code&gt;keywords&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="b837a72c944278925f970add9604780f7fe0b85f" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; with the given function.</source>
          <target state="translated">주어진 함수 로 &lt;code&gt;map&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="37bc2bc502a7c11dcf205d8472d9e975015a6ad3" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;key&lt;/code&gt; with the given function.</source>
          <target state="translated">주어진 기능으로 &lt;code&gt;key&lt;/code&gt; 를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="40277704761ae2f8a4bc8d33a1fd26a3d503725b" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given anonymous function.</source>
          <target state="translated">지정된 익명 함수를 통해 에이전트 상태를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f8a3623b94bb3839740129bc6596f649a9a9ecf0" translate="yes" xml:space="preserve">
          <source>Updates the agent state via the given function.</source>
          <target state="translated">주어진 기능을 통해 에이전트 상태를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9f675d5eaf4774279a670e6224dcc645e0067b54" translate="yes" xml:space="preserve">
          <source>Updates the given dependencies.</source>
          <target state="translated">주어진 종속성을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="416682303e7f5a28e1fe42385084449506b18f32" translate="yes" xml:space="preserve">
          <source>Updates the value for &lt;code&gt;key&lt;/code&gt; for the current process in the unique &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">고유 &lt;code&gt;registry&lt;/code&gt; 에서 현재 프로세스의 &lt;code&gt;key&lt;/code&gt; 값을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="8c9bcfae2fb3ebecd029c8eccc3ce697839499a2" translate="yes" xml:space="preserve">
          <source>Upgrading a dependency often requires the projects it depends on to upgrade too. If you would rather update a single dependency and not touch its children, you can explicitly unlock the single dependency and run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt;&lt;code&gt;mix deps.get&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">종속성을 업그레이드하려면 종종 업그레이드에 의존하는 프로젝트가 필요합니다. 하위 항목을 건드리지 않고 단일 종속성을 업데이트하려는 경우 명시 적으로 단일 종속성을 잠금 해제하고 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Deps.Get.html&quot;&gt; &lt;code&gt;mix deps.get&lt;/code&gt; 을&lt;/a&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3b2c87fbdfa81069562e3801f3b834f583f3068" translate="yes" xml:space="preserve">
          <source>Usage would be:</source>
          <target state="translated">사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad0ecf3efc2fafd77bbedf42c03404f90e27c42f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#defines?/3&quot;&gt;&lt;code&gt;defines?/3&lt;/code&gt;&lt;/a&gt; to assert for a specific type.</source>
          <target state="translated">특정 유형에 대해 &lt;a href=&quot;#defines?/3&quot;&gt; &lt;code&gt;defines?/3&lt;/code&gt; &lt;/a&gt; 하려면 정의? / 3 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="787801e07ca737f4cd69bf93e70004cb3e751db3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#query_decoder/1&quot;&gt;&lt;code&gt;query_decoder/1&lt;/code&gt;&lt;/a&gt; if you want to iterate over each value manually.</source>
          <target state="translated">각 값을 수동으로 반복 하려면 &lt;a href=&quot;#query_decoder/1&quot;&gt; &lt;code&gt;query_decoder/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3797a8276a8bc54fb5a97169a1b9a858a6ddd368" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#write/2&quot;&gt;&lt;code&gt;write/2&lt;/code&gt;&lt;/a&gt; for devices with encoding.</source>
          <target state="translated">인코딩 된 장치에는 &lt;a href=&quot;#write/2&quot;&gt; &lt;code&gt;write/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b36f40ce27bbfefdab4f321df212af5d062ba4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; to traverse over the arguments (v1.0)</source>
          <target state="translated">&lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 인수 (v1.0)를 탐색 하십시오.</target>
        </trans-unit>
        <trans-unit id="e5cf1dfe97340fea8a70dd96826ef4351d80ad46" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt;&lt;code&gt;:binary.replace/4&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">사용 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html#replace-4&quot;&gt; &lt;code&gt;:binary.replace/4&lt;/code&gt; &lt;/a&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="b10d005a7cda664f5d2f9f25b76adbe1cd127651" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; to traverse over the arguments (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 인수를 탐색합니다 (v1.0).</target>
        </trans-unit>
        <trans-unit id="14cd7437712581c1861b1448cca82e849c0c602e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#def/2&quot;&gt;public functions&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#def/2&quot;&gt;공용 기능&lt;/a&gt; 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="5b50f96a6422a56c25eb2e39a749132fd99302b1" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_leading/3&quot;&gt;&lt;code&gt;String.pad_leading/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_trailing/3&quot;&gt;&lt;code&gt;String.pad_trailing/3&lt;/code&gt;&lt;/a&gt; with a binary padding (v1.3)</source>
          <target state="translated">사용 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_leading/3&quot;&gt; &lt;code&gt;String.pad_leading/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#pad_trailing/3&quot;&gt; &lt;code&gt;String.pad_trailing/3&lt;/code&gt; &lt;/a&gt; 진 패딩 (1.3)</target>
        </trans-unit>
        <trans-unit id="12d593b29c9401cb9ed1f77973372f98c62abba4" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_leading/2&quot;&gt;&lt;code&gt;String.trim_leading/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_trailing/2&quot;&gt;&lt;code&gt;String.trim_trailing/2&lt;/code&gt;&lt;/a&gt; with a binary as second argument (v1.3)</source>
          <target state="translated">사용 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_leading/2&quot;&gt; &lt;code&gt;String.trim_leading/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#trim_trailing/2&quot;&gt; &lt;code&gt;String.trim_trailing/2&lt;/code&gt; &lt;/a&gt; 번째 인수 (1.3)와 같은 바이너리</target>
        </trans-unit>
        <trans-unit id="b4a9dd9a756931a4a385ac5c2dd7ee781d1b07f9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#pad_leading/3&quot;&gt;&lt;code&gt;String.pad_leading/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#pad_trailing/3&quot;&gt;&lt;code&gt;String.pad_trailing/3&lt;/code&gt;&lt;/a&gt; with a binary padding (v1.3)</source>
          <target state="translated">이진 패딩 (v1.3)과 함께 &lt;a href=&quot;string#pad_leading/3&quot;&gt; &lt;code&gt;String.pad_leading/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string#pad_trailing/3&quot;&gt; &lt;code&gt;String.pad_trailing/3&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20040427069949a8d4027129b310722c2c30b8ff" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;string#trim_leading/2&quot;&gt;&lt;code&gt;String.trim_leading/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#trim_trailing/2&quot;&gt;&lt;code&gt;String.trim_trailing/2&lt;/code&gt;&lt;/a&gt; with a binary as second argument (v1.3)</source>
          <target state="translated">이진을 두 번째 인수 (v1.3)로 사용하여 &lt;a href=&quot;string#trim_leading/2&quot;&gt; &lt;code&gt;String.trim_leading/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string#trim_trailing/2&quot;&gt; &lt;code&gt;String.trim_trailing/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f9b8c50f1c8c820e6db1607e6e6745fc6ae1b90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;%&lt;/code&gt; (&lt;code&gt;&amp;lt;%=&lt;/code&gt; is allowed only in start expressions) (v1.0)</source>
          <target state="translated">&lt;code&gt;&amp;lt;%&lt;/code&gt; 사용 ( &lt;code&gt;&amp;lt;%=&lt;/code&gt; 은 시작 표현식에서만 허용됨) (v1.0)</target>
        </trans-unit>
        <trans-unit id="c58ca1ae3a377183620422c237e986e4c5bfdee5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;%&lt;/code&gt; (&lt;code&gt;&amp;lt;%=&lt;/code&gt; is allowed only on start expressions) (v1.0)</source>
          <target state="translated">&lt;code&gt;&amp;lt;%&lt;/code&gt; 사용 ( &lt;code&gt;&amp;lt;%=&lt;/code&gt; 은 시작 표현식에서만 허용됨) (v1.0)</target>
        </trans-unit>
        <trans-unit id="ee94c06bb86bdaca513c3a62f49490454be42e9c" translate="yes" xml:space="preserve">
          <source>Use a map (v1.0)</source>
          <target state="translated">지도 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="4d74b43fbed5164c7d0cf7a52539703c48335b7c" translate="yes" xml:space="preserve">
          <source>Use an expression or explicitly return &lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">식을 사용하거나 명시 적으로 &lt;code&gt;nil&lt;/code&gt; (v1.0)을 반환</target>
        </trans-unit>
        <trans-unit id="695acd02888c70a7bd24e240078a062e8cefd82c" translate="yes" xml:space="preserve">
          <source>Use cases for IO data</source>
          <target state="translated">IO 데이터의 사용 사례</target>
        </trans-unit>
        <trans-unit id="17ecf402c8b50a984590bda594e338082a23c4c0" translate="yes" xml:space="preserve">
          <source>Use direct message matching (v1.0)</source>
          <target state="translated">직접 메시지 일치 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="7d7bc258dd57ccdb77c4d94fa239755b4e4dbe79" translate="yes" xml:space="preserve">
          <source>Use parentheses (v1.0)</source>
          <target state="translated">괄호 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="d1a132274b1eb6b7319062ced70e808cf7c404ca" translate="yes" xml:space="preserve">
          <source>Use processes only to model runtime properties, never for code organization. And even when you think something could be done in parallel with processes, often it is best to let the callers of your library decide how to parallelize, rather than impose a certain execution flow in users of your code.</source>
          <target state="translated">코드 구성에는 사용하지 않고 런타임 속성 만 모델링하기 위해 프로세스를 사용하십시오. 프로세스와 병렬로 무언가를 수행 할 수 있다고 생각할 때도 종종 코드 사용자에게 특정 실행 흐름을 강요하기보다는 라이브러리 호출자가 병렬화 방법을 결정하도록하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="72ac53e8279e1fbc4a4e474748dc78b85a97986e" translate="yes" xml:space="preserve">
          <source>Use public functions (v1.0)</source>
          <target state="translated">공용 함수 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="e7e9e97b63195c13fec074e748d6a1b624c2147f" translate="yes" xml:space="preserve">
          <source>Use single-letter aliases (v1.0)</source>
          <target state="translated">단일 문자 별명 사용 (v1.0)</target>
        </trans-unit>
        <trans-unit id="5d5567686d3e6ae0d4956f84da54e7d67f04b834" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;:since&lt;/code&gt; key in the documentation metadata to annotate whenever new functions or modules are added to your API.</source>
          <target state="translated">새 기능이나 모듈이 API에 추가 될 때마다 문서 메타 데이터에서 &lt;code&gt;:since&lt;/code&gt; 키를 사용하여 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47f85339a5f0f7ba3fc69739fe71460337f1ced4" translate="yes" xml:space="preserve">
          <source>Use the pin operator &lt;code&gt;^&lt;/code&gt; when you want to pattern match against a variable&amp;rsquo;s &lt;em&gt;existing value&lt;/em&gt; rather than rebinding the variable.</source>
          <target state="translated">변수를 다시 바인딩하는 대신 변수의 &lt;em&gt;기존 값&lt;/em&gt; 에 대해 패턴 일치를 지정 하려면 핀 연산자 &lt;code&gt;^&lt;/code&gt; 를 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fb9026bf683fe97be9805f8d4ee8da3a7030195" translate="yes" xml:space="preserve">
          <source>Use the pin operator &lt;code&gt;^&lt;/code&gt; when you want to pattern match against an existing variable&amp;rsquo;s value rather than rebinding the variable:</source>
          <target state="translated">변수를 리 바인드하지 않고 기존 변수의 값에 패턴 일치를 설정 하려면 핀 연산자 &lt;code&gt;^&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b63a0f2b65fabcf35daab1c96a88a9c4182865a" translate="yes" xml:space="preserve">
          <source>Use the singular form, such as: &lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, and so on (v1.4)</source>
          <target state="translated">&lt;code&gt;:second&lt;/code&gt; , &lt;code&gt;:millisecond&lt;/code&gt; 등과 같은 단수 형식 사용 (v1.4)</target>
        </trans-unit>
        <trans-unit id="d62760f6801ea132b87f52fc490f15e5c30ebb87" translate="yes" xml:space="preserve">
          <source>Use this only for debugging information.</source>
          <target state="translated">정보를 디버깅 할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="654833a705a392b91db5fb486d867850f6f6d4da" translate="yes" xml:space="preserve">
          <source>Used by helpers and it has a default maximum cap of 80 chars.</source>
          <target state="translated">헬퍼가 사용하며 기본 최대 한도는 80 자입니다.</target>
        </trans-unit>
        <trans-unit id="6f19f4b56cd4eb0479f604b05000a49967ca0779" translate="yes" xml:space="preserve">
          <source>Used by types and bitstrings to specify types.</source>
          <target state="translated">유형과 비트 열에서 유형을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27f134f77aed07ba771f04e70c26fcde14c293be" translate="yes" xml:space="preserve">
          <source>Used to combine matching clauses.</source>
          <target state="translated">일치하는 절을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d3e14268db3616058b87c0710752c8757db571c3" translate="yes" xml:space="preserve">
          <source>Useful for adding side effects (like printing) to a stream.</source>
          <target state="translated">스트림에 부작용 (인쇄 등)을 추가 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b4a25e416b54812cf786abc2853d57e8a5a5d837" translate="yes" xml:space="preserve">
          <source>Useful in umbrella applications to execute a command on each child app:</source>
          <target state="translated">우산 형 응용 프로그램에서 각 자식 응용 프로그램에서 명령을 실행하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccd0085c486cb23718479523b31aac167b10d224" translate="yes" xml:space="preserve">
          <source>Useful when dependencies need to be reloaded due to change of global state.</source>
          <target state="translated">전역 상태 변경으로 인해 종속성을 다시로드해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="52dd4a7101ad34727c991e5c7418caedb4c5ab1e" translate="yes" xml:space="preserve">
          <source>User home directory, exception on error.</source>
          <target state="translated">사용자 홈 디렉토리, 오류 예외.</target>
        </trans-unit>
        <trans-unit id="3b425e136b2a26688fb41476a54559087648780b" translate="yes" xml:space="preserve">
          <source>User home directory.</source>
          <target state="translated">사용자 홈 디렉토리.</target>
        </trans-unit>
        <trans-unit id="c0ef205df825ba4213dcb43cc225636454550c49" translate="yes" xml:space="preserve">
          <source>User-defined types</source>
          <target state="translated">사용자 정의 유형</target>
        </trans-unit>
        <trans-unit id="9718cbc91389f0a24d01843793c6b8f5bef22b1f" translate="yes" xml:space="preserve">
          <source>Users can read the documentation for public Mix tasks by running &lt;code&gt;mix help my_task&lt;/code&gt;. The documentation that will be shown is the &lt;code&gt;@moduledoc&lt;/code&gt; of the task's module.</source>
          <target state="translated">&lt;code&gt;mix help my_task&lt;/code&gt; 를 실행하여 공용 Mix 작업에 대한 설명서를 읽을 수 있습니다 . 표시 될 문서 는 작업 모듈 의 &lt;code&gt;@moduledoc&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30bca3fe935d22a9fb82d1874f535be3bcc5d54b" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 함수 인 경우가 아니라면 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 순회합니다 .</target>
        </trans-unit>
        <trans-unit id="7504c890d2e677e3b9b91ddd28b0a2c13353b513" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 함수가 아닌 한 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 순회합니다 . 키가 함수 인 경우 &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 에&lt;/a&gt; 지정된대로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb5ab22fadbe3ddb46c966e8ef4864a52c44d738" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; protocol to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 함수가 아닌 한 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 프로토콜을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 순회합니다 . 키가 함수 인 경우 &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 에&lt;/a&gt; 지정된대로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b648c806a5b72ce2e22dd69f6650416bf9c513d5" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function, which is detailed in a later section.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 기능이 아닌 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 지정된 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 탐색합니다 . 이는 이후 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ccc9c406282a5ba917ce4d72d479e6ebb00bca8f" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 기능이 아닌 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 탐색합니다 . 키가 함수이면 &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 에&lt;/a&gt; 지정된대로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="649170178c35bb19e659a8d532a363cd019f5cd4" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; protocol to traverse the structures according to the given &lt;code&gt;keys&lt;/code&gt;, unless the &lt;code&gt;key&lt;/code&gt; is a function. If the key is a function, it will be invoked as specified in &lt;a href=&quot;#get_and_update_in/3&quot;&gt;&lt;code&gt;get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 기능이 아닌 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Access.html&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 프로토콜을 사용하여 주어진 &lt;code&gt;keys&lt;/code&gt; 에 따라 구조를 탐색합니다 . 키가 함수이면 &lt;a href=&quot;#get_and_update_in/3&quot;&gt; &lt;code&gt;get_and_update_in/3&lt;/code&gt; 에&lt;/a&gt; 지정된대로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef97952dc7c1cf9b1acf2d4929c04b260422cc0c" translate="yes" xml:space="preserve">
          <source>Uses the given module in the current context.</source>
          <target state="translated">현재 컨텍스트에서 지정된 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="90cad9ec714dc9a102448582d410c612025f4e51" translate="yes" xml:space="preserve">
          <source>Uses the merge sort algorithm.</source>
          <target state="translated">병합 정렬 알고리즘을 사용합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
