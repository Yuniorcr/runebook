<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="91158d4ebf885b7c2cce115618384afcd3d60c6c" translate="yes" xml:space="preserve">
          <source>Not italic.</source>
          <target state="translated">이탤릭체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e8cbaff7c13d97516b633b0d9d10f2ab0d66c800" translate="yes" xml:space="preserve">
          <source>Not only that, as you create new buckets on the terminal, you should see new processes spawned in the supervision tree shown in Observer:</source>
          <target state="translated">뿐만 아니라 터미널에서 새 버킷을 생성 할 때 관찰자에 표시된 감독 트리에 새 프로세스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ece420ef660602018d9d85c815c1206e83a9313" translate="yes" xml:space="preserve">
          <source>Not overlined.</source>
          <target state="translated">요약되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="12d014121a6d98d766e19560d6f8af18c0e40cbc" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Process.monitor(pid)&lt;/code&gt; returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can &lt;code&gt;flush/0&lt;/code&gt; all messages and notice a &lt;code&gt;:DOWN&lt;/code&gt; message arrived, with the exact reference returned by &lt;code&gt;monitor&lt;/code&gt;, notifying that the bucket process exited with reason &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Process.monitor(pid)&lt;/code&gt; 는 다음 메시지를 해당 모니터링 참조와 일치시킬 수있는 고유 한 참조를 리턴합니다. 에이전트를 중지 한 후 모든 메시지를 &lt;code&gt;flush/0&lt;/code&gt; 하고 &lt;code&gt;monitor&lt;/code&gt; 에 의해 반환 된 정확한 참조와 함께 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 도착 하여 버킷 프로세스가 reason &lt;code&gt;:normal&lt;/code&gt; 로 종료되었음을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="de7935fb5d91c63f4d9cbe857464e2239ca741ed" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;[head | tail]&lt;/code&gt; does not match empty lists:</source>
          <target state="translated">참고 &lt;code&gt;[head | tail]&lt;/code&gt; 은 빈 목록과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb3f40b5039d7c318694befb342ce3f4c9f0f60a" translate="yes" xml:space="preserve">
          <source>Note a tag can be set in two different ways:</source>
          <target state="translated">태그는 두 가지 방법으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3377b2b2eb71be892a3e682ccebe7f9b31d7572" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;:transient&lt;/code&gt; type is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;:shutdown&lt;/code&gt;, not &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">감시 트리가 종료되면 이유는 &lt;code&gt;:normal&lt;/code&gt; 이 아니라 : &lt;code&gt;:shutdown&lt;/code&gt; 설정 되므로 &lt;code&gt;:transient&lt;/code&gt; 유형은 실용성이 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c528946c2af34a0e5a1e8d711f96487c6c795447" translate="yes" xml:space="preserve">
          <source>Note anonymous functions can also have multiple clauses and guards:</source>
          <target state="translated">익명 함수에는 여러 절과 가드가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47f7c7dcfbb9a451fa8f8f1b6ccc971c2608e3d" translate="yes" xml:space="preserve">
          <source>Note by default Mix releases supports runtime configuration via a &lt;code&gt;config/runtime.exs&lt;/code&gt;. If a &lt;code&gt;config/runtime.exs&lt;/code&gt; exists in your application, it is automatically copied inside the release and automatically set as a config provider.</source>
          <target state="translated">기본적으로 Mix 릴리스는 &lt;code&gt;config/runtime.exs&lt;/code&gt; 를 통한 런타임 구성을 지원합니다 . 경우 &lt;code&gt;config/runtime.exs&lt;/code&gt; 응용 프로그램에 존재하는, 자동 방출 내부에 복사하여 자동으로 설정 공급자로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d3adc9c8853ececa9befa7c8ce8ff49c5919675" translate="yes" xml:space="preserve">
          <source>Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example:</source>
          <target state="translated">설명 블록은 중첩 될 수 없습니다. 구성을 위해 계층 구조에 의존하는 대신 개발자는 명명 된 설정을 기반으로 구축해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1825e354b3ce5f016786c4903b91e7f6fa4d294" translate="yes" xml:space="preserve">
          <source>Note designations for year, month, day, and the like, are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">연도, 월, 일 등에 대한 참고 지정은 과도하게 지정됩니다 (즉, 월 의 경우 &lt;code&gt;1..12&lt;/code&gt; 대신 정수 ). 다른 달력은 월별 일수, 연간 월 등이 다를 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a5ca0f4688d0116095aeec4a9d739e406b9afeec" translate="yes" xml:space="preserve">
          <source>Note each entry in the binary pattern is expected to match exactly 8 bits. If we want to match on a binary of unknown size, it is possible by using the binary modifier at the end of the pattern:</source>
          <target state="translated">이진 패턴의 각 항목은 정확히 8 비트와 일치해야합니다. 알 수없는 크기의 이진을 일치 시키려면 패턴 끝에서 이진 수정자를 사용하면 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fde64f5bd0b64f802365ea88627dc67abb203122" translate="yes" xml:space="preserve">
          <source>Note each release definition can be given as an anonymous function. This is useful if some release attributes are expensive to compute:</source>
          <target state="translated">각 릴리스 정의는 익명 함수로 제공 될 수 있습니다. 이는 일부 릴리스 속성이 계산 비용이 많이 드는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f5cc73ccd142703d404f49e852f936b5ae2bdd1" translate="yes" xml:space="preserve">
          <source>Note it is generally not advised to use &lt;code&gt;\xNN&lt;/code&gt; in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as &lt;code&gt;\uNNNN&lt;/code&gt;. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.</source>
          <target state="translated">일반적으로 Elixir 문자열에서 &lt;code&gt;\xNN&lt;/code&gt; 을 사용하지 않는 것이 좋습니다 . 유효하지 않은 바이트 시퀀스를 도입하면 문자열이 유효하지 않게되기 때문입니다. 16 진수 표현으로 문자를 도입해야하는 경우 &lt;code&gt;\uNNNN&lt;/code&gt; 과 같은 유니 코드 코드 포인트로 작업하는 것이 가장 좋습니다 . 사실 유니 코드 코드 포인트를 이해하는 것은 문자열의 저수준 조작을 할 때 필수적 일 수 있으므로 다음에 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e1393c185477299f5e854d4848419bacfa99c239" translate="yes" xml:space="preserve">
          <source>Note it is important to recompile a file's dependencies as there are often compile time dependencies between them.</source>
          <target state="translated">파일 간의 종속성이 종종 있기 때문에 파일의 종속성을 다시 컴파일하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="427d850ea29351ec5b9c38bb55119b54d0306d63" translate="yes" xml:space="preserve">
          <source>Note that &quot;config/config.exs&quot; is always loaded automatically by the Mix CLI when it boots. &quot;config/runtime.exs&quot; is loaded automatically by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.App.Config.html&quot;&gt;&lt;code&gt;mix app.config&lt;/code&gt;&lt;/a&gt; before starting the current application. Therefore there is no need to load those config files directly.</source>
          <target state="translated">&quot;config / config.exs&quot;는 부팅시 항상 Mix CLI에 의해 자동으로로드됩니다. &quot;config / runtime.exs&quot;는 현재 애플리케이션을 시작하기 전에 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.App.Config.html&quot;&gt; &lt;code&gt;mix app.config&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로로드됩니다 . 따라서 이러한 구성 파일을 직접로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="127cdeb36c75a2e9ea3ccb032068074d455163d3" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt; is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.</source>
          <target state="translated">참고 &lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; 일반적으로이 공급자에서 응용 프로그램을 사용할 필요가 있으므로 경우, 초기 부팅 프로세스의 호출은, 그것을 시작하는 것은 귀하 자신의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="98fcc4c0b233355a84f821a3c513063ad4e24444" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt; can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the &lt;code&gt;from&lt;/code&gt; argument somehow).</source>
          <target state="translated">참고 &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; (GenServer가 전달 된 그만큼 처음 전화를받은 과정뿐만 아니라 GenServer에서 호출 할 수 있습니다 &lt;code&gt;from&lt;/code&gt; 어떻게 든 인수).</target>
        </trans-unit>
        <trans-unit id="2d02d2557aff8e189d210c2d08f3cf6abe1f8379" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">그 주 &lt;code&gt;.&lt;/code&gt; 연산자이기도합니다. 원격 호출은 두 개의 인수와 함께 AST의 점을 사용합니다. 여기서 두 번째 인수는 항상 원자입니다.</target>
        </trans-unit>
        <trans-unit id="e1626fef0c1a33798d2c34dfc74515bf8d5c377d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">참고 &lt;code&gt;String.t()&lt;/code&gt; 와 &lt;code&gt;binary()&lt;/code&gt; 분석 도구에 해당합니다. 문서를 읽는 사람들에게 &lt;code&gt;String.t()&lt;/code&gt; 는 UTF-8로 인코딩 된 바이너리임을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="8ceb120a9be7ed748230ca821c05f6918e48cd56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\\&lt;/code&gt; can't be used with anonymous functions because they can only have a sole arity.</source>
          <target state="translated">참고 &lt;code&gt;\\&lt;/code&gt; 는 그들이 단지 단독 인수에 대응을 가질 수 있기 때문에 익명 함수와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="284b6400c5d9fc089c636125d995e2b0e56e6990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;^x&lt;/code&gt; always refers to the value of &lt;code&gt;x&lt;/code&gt; prior to the match. The following example will match:</source>
          <target state="translated">참고 &lt;code&gt;^x&lt;/code&gt; 항상의 값을 참조 &lt;code&gt;x&lt;/code&gt; 경기에 앞서. 다음 예제는 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2319e8ea6dc2453b7cac37ef1761f4dadaf1a473" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">참고 &lt;code&gt;__STACKTRACE__&lt;/code&gt; 는 현재 스택 트레이스를 검색하는 캐치 / 구조 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1877a8124459f28213b53d05b5f96adf2e6ee0c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;alias&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt;, which allows you to set aliases inside specific functions:</source>
          <target state="translated">주의 &lt;code&gt;alias&lt;/code&gt; 되는 &lt;strong&gt;어휘 범위가&lt;/strong&gt; 특정 기능 내부 설정 별칭을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5684572f42db95ac181baf9058ba1bcc12e51cad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cast&lt;/code&gt; returns &lt;code&gt;:ok&lt;/code&gt; immediately, regardless of whether &lt;code&gt;agent&lt;/code&gt; (or the node it should live on) exists.</source>
          <target state="translated">주의 &lt;code&gt;cast&lt;/code&gt; 반환 &lt;code&gt;:ok&lt;/code&gt; 즉시 여부에 관계없이의 &lt;code&gt;agent&lt;/code&gt; (또는에서 살아야 노드)가 존재한다.</target>
        </trans-unit>
        <trans-unit id="c5c4acc72c847b14f34cef90da2dbdafe8c0f864" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;defines?&lt;/code&gt; returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling &lt;a href=&quot;#overridable?/2&quot;&gt;&lt;code&gt;overridable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주의 &lt;code&gt;defines?&lt;/code&gt; 정의되었지만 재정의 가능한 것으로 표시되고 다른 구현이 제공되지 않은 함수 및 매크로에 대해서는 false를 반환합니다. &lt;a href=&quot;#overridable?/2&quot;&gt; &lt;code&gt;overridable?/2&lt;/code&gt; 를&lt;/a&gt; 호출하여 재정의 가능한 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90f8221caf1663dc39261548c92a478da7147d51" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;do/end&lt;/code&gt; become delimiters. The second example would translate to:</source>
          <target state="translated">주 &lt;code&gt;do/end&lt;/code&gt; 하게 구분 기호를. 두 번째 예는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f98e56a6b073dedf21c4fd7053a53e9bd1aea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt; too. This means that we can import specific macros or functions inside function definitions:</source>
          <target state="translated">참고 &lt;code&gt;import&lt;/code&gt; 되는 &lt;strong&gt;어휘 범위&lt;/strong&gt; 도. 즉, 함수 정의 내에서 특정 매크로 또는 함수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d91cdd66170ee21978845d99279b84980730cb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt;ing a module automatically &lt;code&gt;require&lt;/code&gt;s it.</source>
          <target state="translated">모듈 을 &lt;code&gt;import&lt;/code&gt; 자동으로 &lt;code&gt;require&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ab30e5a1bc4b404e7cb3f7adf25fbc460e6c3561" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;index&lt;/code&gt; is capped at the list length. Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;index&lt;/code&gt; 목록 길이에 덮인된다. 음수 인덱스는 &lt;code&gt;list&lt;/code&gt; 끝에서 오프셋을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="12525ea5b78a44ac5eef68af6cc8e0ed2ce006ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;serve/1&lt;/code&gt; is an infinite loop called sequentially inside &lt;code&gt;loop_acceptor/1&lt;/code&gt;, so the tail call to &lt;code&gt;loop_acceptor/1&lt;/code&gt; is never reached and could be avoided. However, as we shall see, we will need to execute &lt;code&gt;serve/1&lt;/code&gt; in a separate process, so we will need that tail call soon.</source>
          <target state="translated">주 &lt;code&gt;serve/1&lt;/code&gt; 순차적으로 내부이라는 무한 루프 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 에 꼬리를 호출하므로, &lt;code&gt;loop_acceptor/1&lt;/code&gt; 에 도달하지 않습니다와 피할 수 있습니다. 그러나 앞으로 살펴 보 겠지만 , 별도의 프로세스에서 &lt;code&gt;serve/1&lt;/code&gt; 을 실행해야 하므로 곧 테일 콜이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de063b80d08dcad20f96832929534bd43e718138" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; started with &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the &lt;code&gt;:normal&lt;/code&gt; reasons in case it is configured to trap exits in the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 시작 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 부모 프로세스에 연결되어 부모로부터 충돌의 경우에 종료됩니다. GenServer는 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 엑시트를 트랩하도록 구성된 경우 &lt;code&gt;:normal&lt;/code&gt; 이유로 인해 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="08443544f9b5807d8ae2ca59e1cdfa2a987f5f51" translate="yes" xml:space="preserve">
          <source>Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with &lt;code&gt;:normal&lt;/code&gt; reason.</source>
          <target state="translated">이 기능으로 시작한 수퍼바이저는 상위 프로세스에 연결되어 충돌시뿐만 아니라 상위 프로세스가 &lt;code&gt;:normal&lt;/code&gt; 이유로 종료되는 경우에도 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="954d4540ce99f199a6a0a382f7d567881ea15fd5" translate="yes" xml:space="preserve">
          <source>Note that all Elixir operators are also valid atoms. Therefore &lt;code&gt;:+&lt;/code&gt;, &lt;code&gt;:@&lt;/code&gt;, &lt;code&gt;:|&amp;gt;&lt;/code&gt;, and others are all valid atoms. The full description of valid atoms is available in the Syntax Reference, this document covers only the rules for identifier-based atoms.</source>
          <target state="translated">모든 Elixir 연산자도 유효한 원자입니다. 따라서 &lt;code&gt;:+&lt;/code&gt; , &lt;code&gt;:@&lt;/code&gt; , &lt;code&gt;:|&amp;gt;&lt;/code&gt; 등은 모두 유효한 원자입니다. 유효한 원자에 대한 자세한 설명은 구문 참조에 나와 있습니다.이 문서는 식별자 기반 원자에 대한 규칙 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="59807d7115e84e3f04fec688f18ad915d1e01400" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:mfa&lt;/code&gt;, &lt;code&gt;:file&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are available only inside behaviours such as GenServer, Supervisor, and others.</source>
          <target state="translated">모든 메타 데이터는 선택 사항이며 항상 사용 가능한 것은 아닙니다. &lt;code&gt;:mfa&lt;/code&gt; , &lt;code&gt;:file&lt;/code&gt; , &lt;code&gt;:line&lt;/code&gt; 사용하는 경우, 유사한 메타 데이터는 자동으로 포함됩니다 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 매크로를. &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; 는 기본적으로 &lt;code&gt;:pid&lt;/code&gt; 이외의 메타 데이터를 포함하지 않습니다 . &lt;code&gt;:crash_reason&lt;/code&gt; , &lt;code&gt;:initial_call&lt;/code&gt; 및 &lt;code&gt;:registered_name&lt;/code&gt; 과 같은 기타 메타 데이터 는 GenServer, Supervisor 등과 같은 동작 내에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0b3ec8f1db4589a8f8e1eb136c0f7227194b62" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:function&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;logger#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are extracted from Erlang/OTP crash reports and available only in those cases.</source>
          <target state="translated">모든 메타 데이터는 선택 사항이며 항상 사용 가능한 것은 아닙니다. &lt;code&gt;:module&lt;/code&gt; , &lt;code&gt;:function&lt;/code&gt; , &lt;code&gt;:line&lt;/code&gt; 사용하는 경우와 유사한 메타 데이터는 자동으로 포함 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 매크로. &lt;a href=&quot;logger#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; 는 기본적으로 &lt;code&gt;:pid&lt;/code&gt; 이외의 메타 데이터를 포함하지 않습니다 . &lt;code&gt;:crash_reason&lt;/code&gt; , &lt;code&gt;:initial_call&lt;/code&gt; 및 &lt;code&gt;:registered_name&lt;/code&gt; 과 같은 기타 메타 데이터 는 Erlang / OTP 충돌 보고서에서 추출되어 해당 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="76c7fd844c6a4b97c6af78f0323e658a0263e3d7" translate="yes" xml:space="preserve">
          <source>Note that all tests are included by default, so unless they are excluded first (either in the test helper or via the &lt;code&gt;--exclude&lt;/code&gt; option) the &lt;code&gt;--include&lt;/code&gt; option has no effect.</source>
          <target state="translated">모든 테스트는 기본적으로 포함되므로 테스트 도우미 나 &lt;code&gt;--exclude&lt;/code&gt; 옵션을 통해 먼저 제외하지 않는 한 &lt;code&gt;--include&lt;/code&gt; 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="764accc79b7e7fbac8971b738cd4bab00fe7637c" translate="yes" xml:space="preserve">
          <source>Note that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">IO 스트림에는 부작용이 있으며 스트림을 처리 할 때마다 다른 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad52b62a5c2594d2df1d229d1b57a6b8821bde" translate="yes" xml:space="preserve">
          <source>Note that both UTC and Standard offsets will be taken into account when comparison is done.</source>
          <target state="translated">비교가 완료되면 UTC 및 표준 오프셋이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="e39927967b57d902ab4163f9f2cb6338d710bb58" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션 없이 &lt;code&gt;alias&lt;/code&gt; 을 호출 하면 모듈의 마지막 부분을 기반으로 별칭이 자동으로 설정됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="dc0e0b9356beddc60c2573a3330e2dc896252a2e" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 호출 은 항상 이전에 선언 된 &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 에서 배타적입니다 . 이전 가져 오기가 없으면 모듈의 모든 함수와 매크로에 적용됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="406fc1b32b85677464e45a089ad7df7b494e5b86" translate="yes" xml:space="preserve">
          <source>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">메모리 부족 상태에서 많은 수의 자식을 감독 할 때이 함수를 호출하면 메모리 부족 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="810d95d9fca7c3168a855c66f8ec239c21983136" translate="yes" xml:space="preserve">
          <source>Note that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">엔진마다 태그마다 다른 규칙이있을 수 있습니다. 다른 태그는 향후 버전에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1375989f15fb775da5bd1afcc5b55b1b8ca50c6" translate="yes" xml:space="preserve">
          <source>Note that doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">doctest에는 제한이 있습니다. 상태 또는 부작용에 의존하기 때문에 함수를 doctest 할 수없는 경우 개발자는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 프롬프트 없이 직접 예제를 포함하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="fabe66319df854999ff8cf0e3d6fa8aaf6d30285" translate="yes" xml:space="preserve">
          <source>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.</source>
          <target state="translated">Elixir에서 문자 목록으로 제공 될 때 파일 이름은 항상 UTF-8로 처리됩니다. 특히, 쉘과 운영 체제가 UTF-8 인코딩을 사용하도록 구성되어있을 것으로 기대합니다. 이진 파일 이름은 그대로 간주되며 운영 체제로 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="103cdbd91afa6836ea7762204d98d6131437f8ac" translate="yes" xml:space="preserve">
          <source>Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions.</source>
          <target state="translated">파티션이 많은 대규모 레지스트리의 경우 모든 파티션을 연결하여 결과를 빌드하므로 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="f080d783bf0fd06342e1a61dcd384d6c89650c0e" translate="yes" xml:space="preserve">
          <source>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</source>
          <target state="translated">임시 하위의 경우 하위가 종료되면 하위 스펙이 자동으로 삭제되므로 해당 하위를 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="377cc6cbec36c42c5ad3eb7ca6f0b2467fdc4772" translate="yes" xml:space="preserve">
          <source>Note that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">참고 경우 것으로 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; 가&lt;/a&gt; 동시에 서로 다른 프로세스에 의해 호출, 첫 번째 프로세스가 호출하는 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 취득 잠금을하고 파일을 사용할 수있을 때까지 남아있는 사람은 차단합니다. 즉, &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 가 주어진 파일에 대해 두 번 이상 호출되면 해당 파일은 한 번만 컴파일됩니다. &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 를 호출하는 첫 번째 프로세스 는로드 된 모듈 목록을 가져 &lt;code&gt;nil&lt;/code&gt; 다른 프로세스 는 nil 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0ac0f2db57c845b53edfac58671ccc0da1b912b7" translate="yes" xml:space="preserve">
          <source>Note that if a backend fails to start by returning &lt;code&gt;{:error, :ignore}&lt;/code&gt; from its &lt;code&gt;init/1&lt;/code&gt; callback, then it's not added to the backends but nothing fails. If a backend fails to start by returning &lt;code&gt;{:error, reason}&lt;/code&gt; from its &lt;code&gt;init/1&lt;/code&gt; callback, the &lt;code&gt;:logger&lt;/code&gt; application will fail to start.</source>
          <target state="translated">백엔드가 &lt;code&gt;init/1&lt;/code&gt; 콜백 에서 &lt;code&gt;{:error, :ignore}&lt;/code&gt; 를 반환하여 시작 하지 못하면 백엔드에 추가되지 않지만 실패하지 않습니다. &lt;code&gt;init/1&lt;/code&gt; 콜백 에서 &lt;code&gt;{:error, reason}&lt;/code&gt; 을 반환하여 백엔드를 시작하지 못하면 &lt;code&gt;:logger&lt;/code&gt; 애플리케이션이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="997a3967a5f4bb658a4ce5f677487cb8a5c8fec2" translate="yes" xml:space="preserve">
          <source>Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, &lt;a href=&quot;#alive?/1&quot;&gt;&lt;code&gt;alive?/1&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; but its PID will be part of the list of PIDs returned by this function.</source>
          <target state="translated">프로세스가 종료되면 존재하지만 살아 있지 않은 것으로 간주됩니다. 이는 그러한 프로세스에서 &lt;a href=&quot;#alive?/1&quot;&gt; &lt;code&gt;alive?/1&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환 하지만 PID는이 함수가 반환 한 PID 목록의 일부가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a43e287fde89bfb0a88b95e0c986594cfaffdabd" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;:delayed_write&lt;/code&gt; was used when opening the file, &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; might return an old write error and not even try to close the file. See &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">파일을 열 때 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션 이 사용 된 경우 &lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt; 은 오래된 쓰기 오류를 반환하고 파일을 닫으려고하지 않을 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="821ad9a9b64479995767f73e56a4365e2e36ccc1" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 구조체를 첫 번째 인수로 전달하는 동시에 &lt;code&gt;opts&lt;/code&gt; 를 전달 하면 우선 순위가 있는 &lt;code&gt;opts&lt;/code&gt; 와 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f646c93d4eef7c70fd05d7240d6a69876a9baf5" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 도 전달하면서 &lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 구조체를 첫 번째 인수로 전달하면 우선 순위가 있는 &lt;code&gt;opts&lt;/code&gt; 와 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="64b52ff72a460cecc390aabeeeee6af670211c1b" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check &lt;a href=&quot;#get_and_update_in/2&quot;&gt;&lt;code&gt;get_and_update_in/2&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">이 매크로가 작동하려면이 매크로가 항상 전체 경로를 볼 수 있어야합니다. 지원되는 경로 표현식에 대한 자세한 내용은 &lt;a href=&quot;#get_and_update_in/2&quot;&gt; &lt;code&gt;get_and_update_in/2&lt;/code&gt; &lt;/a&gt; 문서 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b84e74a3f06c5b64c9f3f50fab344006da217376" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the &quot;Paths&quot; section below.</source>
          <target state="translated">이 매크로가 작동하려면이 매크로가 항상 전체 경로를 볼 수 있어야합니다. 아래의 &quot;경로&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e49d404776bcbe0ae060a73286ea9c896eb6178" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</source>
          <target state="translated">이 매크로가 작동하려면이 매크로가 항상 전체 경로를 볼 수 있어야합니다. 아래의 경로 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf88d15a7510f97dbf0ab0147120a93a4cb3ae1" translate="yes" xml:space="preserve">
          <source>Note that in our macro implementation, the sentence was not printed, although it was printed in our function implementation. That&amp;rsquo;s because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our &lt;code&gt;unless&lt;/code&gt; macro to become an &lt;code&gt;if&lt;/code&gt; behind the scenes.</source>
          <target state="translated">매크로 구현에서는 문장이 함수 구현으로 인쇄되었지만 문장이 인쇄되지 않았습니다. 함수 호출에 대한 인수는 함수를 호출하기 전에 평가되기 때문입니다. 그러나 매크로는 인수를 평가하지 않습니다. 대신 인수를 인용 된 표현식으로 수신 한 다음 다른 인용 된 표현식으로 변환합니다. 이 경우, 우리는 다시 한 &lt;code&gt;unless&lt;/code&gt; 매크로 될 &lt;code&gt;if&lt;/code&gt; 배후.</target>
        </trans-unit>
        <trans-unit id="3281f1a5f02ddec5e1056940255b1750f3ee3ceb" translate="yes" xml:space="preserve">
          <source>Note that in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#c:init/1&quot;&gt;&lt;code&gt;Supervisor.init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">이 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;use Supervisor&lt;/code&gt; 자동 으로 가져 오기 때문에 Supervisor.Spec 을 명시 적으로 가져올 필요가 없습니다 . 모듈 기반 감독자를 정의하는 것은 예를 들어 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#c:init/1&quot;&gt; &lt;code&gt;Supervisor.init/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 초기화 작업을 수행하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="457d54652787a94a3f6b0231b5aed3d435010820" translate="yes" xml:space="preserve">
          <source>Note that inside this new IEx session, we cannot access &lt;code&gt;Hello.world/0&lt;/code&gt;:</source>
          <target state="translated">이 새로운 IEx 세션에서는 &lt;code&gt;Hello.world/0&lt;/code&gt; 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f17b233403875e96f2f86d0e5be296449a5c7be6" translate="yes" xml:space="preserve">
          <source>Note that installing via Git, GitHub, or Hex fetches the source of the archive and builds it, while using local path uses a pre-built archive.</source>
          <target state="translated">Git, GitHub 또는 Hex를 통해 설치하면 아카이브의 소스를 가져 와서 빌드하는 반면 로컬 경로를 사용하면 사전 빌드 된 아카이브를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="501337e40a037ada414b45561640d40bc9bd67c7" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to stop an application explicitly by calling &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;. Regardless of the type of the application, no other applications will be affected.</source>
          <target state="translated">&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 응용 프로그램을 명시 적으로 중지 할 수 있습니다 . 응용 프로그램 유형에 관계없이 다른 응용 프로그램에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff7bd5f130ea7db15204ea66bfeb9aa5a7e91245" translate="yes" xml:space="preserve">
          <source>Note that like the &lt;code&gt;alias&lt;/code&gt; directive, &lt;code&gt;require&lt;/code&gt; is also lexically scoped. We will talk more about macros in a later chapter.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 지시어 와 마찬가지로 &lt;code&gt;require&lt;/code&gt; 도 어휘 범위가 있습니다. 다음 장에서 매크로에 대해 더 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="30dc33cdf6ccf0b16cb5002caa6c225d66067c88" translate="yes" xml:space="preserve">
          <source>Note that most Unicode code charts will refer to a code point by its hexadecimal representation, e.g. &lt;code&gt;97&lt;/code&gt; translates to &lt;code&gt;0061&lt;/code&gt; in hex, and we can represent any Unicode character in an Elixir string by using the &lt;code&gt;\u&lt;/code&gt; notation and the hex representation of its code point number:</source>
          <target state="translated">대부분의 유니 코드 코드 차트는 16 진수 표현으로 코드 포인트를 참조합니다. 예를 들어 &lt;code&gt;97&lt;/code&gt; 은 16 진수 &lt;code&gt;0061&lt;/code&gt; 로 변환되며 &lt;code&gt;\u&lt;/code&gt; 표기법과 코드 포인트의 16 진수 표현을 사용하여 Elixir 문자열에서 모든 유니 코드 문자를 나타낼 수 있습니다. 번호:</target>
        </trans-unit>
        <trans-unit id="609fc4219e4f54367072ec4d02e01c554eb9955f" translate="yes" xml:space="preserve">
          <source>Note that on many platforms, only the status codes 0-255 are supported by the operating system.</source>
          <target state="translated">많은 플랫폼에서 운영 체제는 상태 코드 0-255 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="058e024bfd4088c93bb70a9d4486efc9cfc43198" translate="yes" xml:space="preserve">
          <source>Note that only integers can be considered inside a range by &lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 의 범위 내에서는 정수만 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3b3ddc90ecac73bf6bd80a621ca3d36de3d554d" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">비어 있지 않은 목록을 &lt;code&gt;collectable&lt;/code&gt; 항목으로 전달하는 것은 더 이상 사용되지 않습니다. 비어 있지 않은 키워드 목록을 수집하는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; 를 사용하는 것이&lt;/a&gt; 좋습니다. 비어 있지 않은 목록으로 수집하는 경우 &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; 과 같은 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="3610787e239696d5d39dc8faf6f13f31e98d9fd3" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;keyword#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collectable&lt;/code&gt; 항목으로 비어 있지 않은 목록을 전달하는 것은 더 이상 사용되지 않습니다. 비어 있지 않은 키워드 목록을 수집하는 경우 &lt;a href=&quot;keyword#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 . 비어 있지 않은 목록으로 수집하는 경우 &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; 과 같은 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="66a707c89c7a375b67feac5256ea470e5723f333" translate="yes" xml:space="preserve">
          <source>Note that popping elements out of tuples is not possible and raises an error.</source>
          <target state="translated">튜플에서 요소를 터지는 것은 불가능하며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1829a61daf7b4386ac742e8edeb6408f81010c1d" translate="yes" xml:space="preserve">
          <source>Note that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">위의 값을 설정하면 Elixir의 기본값이 무시됩니다. 예를 들어 &lt;code&gt;:requires&lt;/code&gt; 를 &lt;code&gt;[]&lt;/code&gt; 로 설정 하면 더 이상 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈이 자동으로 필요하지 않습니다 . 같은 방식으로 설정 &lt;code&gt;:macros&lt;/code&gt; 는 더 이상 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt; 등과 같은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 매크로를 자동으로 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dcdb0a0d3694177344abe742c5030d4133620456" translate="yes" xml:space="preserve">
          <source>Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: &lt;code&gt;:opaque&lt;/code&gt; and &lt;code&gt;:defaults&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 일부 추가 메타 데이터도 정의하므로 사용시 무시되고 경고되는 몇 가지 예약 된 키가 있습니다. 현재는 : &lt;code&gt;:opaque&lt;/code&gt; 및 &lt;code&gt;:defaults&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b75c0042cd08ee62bad4db6cb1d7ba8606cfb304" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Yecc.html&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">다른 작업에 대한 설명서에서 동일한 구성 옵션이 언급되는 경우가 있습니다. 이는 많은 작업이 동일한 구성 옵션을 읽고 사용하는 것이 일반적이기 때문입니다 (예 &lt;code&gt;:erlc_paths&lt;/code&gt; 는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Erlang.html&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.Yecc.html&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt; 및 기타 작업에서 사용됨 ).</target>
        </trans-unit>
        <trans-unit id="3f7174f1e0891c9c315cf26472dfe8e8d467ed7d" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">다른 작업에 대한 설명서에서 동일한 구성 옵션이 언급되는 경우가 있습니다. 이는 많은 작업에서 동일한 구성 옵션을 읽고 사용하는 것이 일반적이기 때문입니다 (예 &lt;code&gt;:erlc_paths&lt;/code&gt; 는 &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt; 및 기타 작업에서 사용됨 ).</target>
        </trans-unit>
        <trans-unit id="3f0f13b3768bb3f2f5261f8bf7014c2406c92785" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">Elixir의 스택 트레이스는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 변수를 사용하여 catch and rescue에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb4e3794b5d058074ae9fb619182bee5deeb2d26" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">Elixir의 스택 트레이스는 &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 변수를 사용하여 캐치 및 구조 내에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e85b6039665bee3ec9b0d680c01e0c9c21351cc3" translate="yes" xml:space="preserve">
          <source>Note that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only restart if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason 과 함께 종료 됩니다. 이 경우 수퍼바이저는 하위 사양이 &lt;code&gt;:restart&lt;/code&gt; 옵션이 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정된 경우에만 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="936b4b3bd1216dcefa77865d707c7482829eb4f4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">점을 유의 &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.html&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 반드시 비약 용어의 올바른 표현을 반환하지 않습니다 프로토콜을. 이러한 경우 검사 결과는 &lt;code&gt;#&lt;/code&gt; 로 시작해야합니다 . 예를 들어 함수를 검사하면 다음이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="552be8eaba50f8b9cb5e15b8c46f2e1519134f1f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">점을 유의 &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 반드시 비약 용어의 올바른 표현을 반환하지 않습니다 프로토콜을. 이러한 경우 검사 결과는 &lt;code&gt;#&lt;/code&gt; 로 시작해야합니다 . 예를 들어 함수를 검사하면 다음이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a210d5a52a6f0f763cbec85671fca9f2120de279" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;start_link&lt;/code&gt; function starts a new process that runs the &lt;code&gt;loop/1&lt;/code&gt; function, starting with an empty map. The &lt;code&gt;loop/1&lt;/code&gt; (private) function then waits for messages and performs the appropriate action for each message. We made &lt;code&gt;loop/1&lt;/code&gt; private by using &lt;code&gt;defp&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. In the case of a &lt;code&gt;:get&lt;/code&gt; message, it sends a message back to the caller and calls &lt;code&gt;loop/1&lt;/code&gt; again, to wait for a new message. While the &lt;code&gt;:put&lt;/code&gt; message actually invokes &lt;code&gt;loop/1&lt;/code&gt; with a new version of the map, with the given &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; stored.</source>
          <target state="translated">있습니다 &lt;code&gt;start_link&lt;/code&gt; 기능이 실행되는 새로운 프로세스를 시작 &lt;code&gt;loop/1&lt;/code&gt; 빈지도로 시작, 기능. 그런 다음 &lt;code&gt;loop/1&lt;/code&gt; (비공개) 기능은 메시지를 대기하고 각 메시지에 대해 적절한 조치를 수행합니다. &lt;code&gt;def&lt;/code&gt; 대신 &lt;code&gt;defp&lt;/code&gt; 를 사용하여 &lt;code&gt;loop/1&lt;/code&gt; 을 private 로 만들었습니다 . &lt;code&gt;:get&lt;/code&gt; 메시지 의 경우 호출자에게 메시지를 다시 보내고 &lt;code&gt;loop/1&lt;/code&gt; 을 다시 호출 하여 새 메시지를 기다립니다. 그동안 &lt;code&gt;:put&lt;/code&gt; 메시지가 실제로 호출 &lt;code&gt;loop/1&lt;/code&gt; 주어진와지도의 새 버전으로 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f3b685f288df2ac141b75c4120d3ea4cba1aee" translate="yes" xml:space="preserve">
          <source>Note that the Erlang VM (and therefore this function) does not return the current stacktrace but rather the stacktrace of the latest exception. To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">Erlang VM (및이 함수)은 현재 스택 추적을 반환하지 않고 최신 예외의 스택 추적을 반환합니다. 현재 프로세스의 스택 추적을 검색하려면 대신 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc53bfc2363fa69016517d06be9fddf805a65c1d" translate="yes" xml:space="preserve">
          <source>Note that the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 제한에 도달하지 않았기 때문에 줄 바꿈이있는 그대로 표시되었습니다. 이렇게하면 개행으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="6b74fe0466cf2ea8dc50231e02541ba1b836c60b" translate="yes" xml:space="preserve">
          <source>Note that the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 바꿈은 줄 제한에 도달하지 않았기 때문에 주어진 문자열로 표시되었습니다. 이렇게하면 개행으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="8c25d0b631147ff8a481e4dcb175efe3a2f931b4" translate="yes" xml:space="preserve">
          <source>Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively:</source>
          <target state="translated">빈 맵은 모든 맵과 일치합니다. 이는 튜플 및 목록과 대조됩니다. 여기서 빈 튜플 또는 빈 목록은 각각 빈 튜플 및 빈 목록과 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="61118c7f53d4bda89916029a3a51c482ae9250a8" translate="yes" xml:space="preserve">
          <source>Note that the functions in &lt;code&gt;:digraph&lt;/code&gt; alter the graph structure in-place, this is possible because they are implemented as ETS tables, explained next.</source>
          <target state="translated">&lt;code&gt;:digraph&lt;/code&gt; 의 함수 는 그래프 구조를 제자리에서 변경 한다는 점에 유의하십시오. 이는 다음에 설명 할 ETS 테이블로 구현되기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8627c831d93f41d528783ce65921c7ddd4b6fc21" translate="yes" xml:space="preserve">
          <source>Note that the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;) does &lt;em&gt;not&lt;/em&gt; support guards:</source>
          <target state="translated">일치 연산자 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt; )는 가드를 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="642c83993efe9994a761915e7e921044f5f85c3c" translate="yes" xml:space="preserve">
          <source>Note that the purpose of the test is to check whether the registry processes the bucket&amp;rsquo;s shutdown message correctly. The fact that the &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sends us a valid bucket does not mean that the bucket is still alive by the time you call it. For example, it might have crashed for some reason. The following test depicts this situation:</source>
          <target state="translated">테스트의 목적은 레지스트리가 버킷의 종료 메시지를 올바르게 처리하는지 확인하는 것입니다. 사실 &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 는 우리에게 유효한 통을 보낸다는 버킷은 여전히 당신이 그것을 호출 시간까지 살아 있다는 것을 의미하지 않습니다. 예를 들어 어떤 이유로 추락했을 수 있습니다. 다음 테스트는이 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="67d98e4f2d8bcb03260e0b9f2837377ff066ec7f" translate="yes" xml:space="preserve">
          <source>Note that the registry uses one ETS table plus two ETS tables per partition.</source>
          <target state="translated">레지스트리는 파티션 당 하나의 ETS 테이블과 두 개의 ETS 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d23b68f4a034d408b5f29d2cab465dee9b0485c0" translate="yes" xml:space="preserve">
          <source>Note that the returned result is incorrect, because &lt;a href=&quot;#sort/1&quot;&gt;&lt;code&gt;sort/1&lt;/code&gt;&lt;/a&gt; by default uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt;&lt;code&gt;&amp;lt;=/2&lt;/code&gt;&lt;/a&gt;, which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; and then &lt;code&gt;year&lt;/code&gt;, which is the opposite of what we want.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#sort/1&quot;&gt; &lt;code&gt;sort/1&lt;/code&gt; &lt;/a&gt; 은 구조를 비교하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C=/2&quot;&gt; &lt;code&gt;&amp;lt;=/2&lt;/code&gt; 를&lt;/a&gt; 사용 하기 때문에 반환 된 결과가 올바르지 않습니다 . 구조를 비교할 때 필드는 알파벳 순서로 비교됩니다. 즉, 위의 날짜 는 우리가 원하는 것과 반대 인 &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; 별로 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec636350f4f8e5f34aed230627c7cf0452577a12" translate="yes" xml:space="preserve">
          <source>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</source>
          <target state="translated">생성 된 프로세스는 발신자와 연결되어 있지 않고 감독자에게만 연결됩니다. 이 명령은 작업이 부작용 (예 : I / O)을 수행해야하고 호출자에게 다시보고 할 필요가없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3e2844dc57fe394fb1d784abea5572c60fbbc883" translate="yes" xml:space="preserve">
          <source>Note that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason 과 함께 종료 됩니다. 이 경우 수퍼바이저는 하위 사양이 &lt;code&gt;:restart&lt;/code&gt; 옵션이 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정되어 정의 된 경우에만 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="b127c6ea8c064847d709c284556ed56f2833bb8b" translate="yes" xml:space="preserve">
          <source>Note that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 의 구문 표현 은 &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; 가 아니라 &lt;code&gt;%{}&lt;/code&gt; optional (any) =&amp;gt; any } 입니다. 표기법 &lt;code&gt;%{}&lt;/code&gt; 는 빈 맵에 대한 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="91f3a52cafb20592b005962fff487b0f78c38ad7" translate="yes" xml:space="preserve">
          <source>Note that the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 제공 함수는 &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수 로 래핑됩니다 . &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 에서 설명한 바와 같이 기능은 각 단계 후 태그 튜플을 반환해야 &lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt; 형. 마지막에 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd0116a55dff5f2bacdff852b6887f33db51d12e" translate="yes" xml:space="preserve">
          <source>Note that this applies only to the tuple itself, not its contents. For instance, when you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. In other words, tuples and lists in Elixir are capable of sharing their contents. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.</source>
          <target state="translated">이것은 내용이 아닌 튜플 자체에만 적용됩니다. 예를 들어, 튜플을 업데이트하면 교체 된 항목을 제외하고 모든 항목이 이전 튜플과 새 튜플간에 공유됩니다. 즉, Elixir의 튜플과 목록은 내용을 공유 할 수 있습니다. 이는 언어가 수행해야하는 메모리 할당량을 줄이고 언어의 불변의 의미론 덕분에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="772fcfd84a5f9fd2ad0b735b0a19d01baa41c4ae" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;code#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 기능은 모듈이로드되지 않은 경우 모듈을로드하지 않습니다. 확인 &lt;a href=&quot;code#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="eea6328af931fedba539b796b9a7e26ee026accb" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 함수는 모듈이로드되지 않은 경우로드하지 않습니다. 확인 &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="3a93b64ce36dbd9e66bfd7a4794eac8913433ad9" translate="yes" xml:space="preserve">
          <source>Note that this function does not try to discover the file encoding basing on BOM.</source>
          <target state="translated">이 기능은 BOM을 기준으로 파일 인코딩을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="daa070decb7d61349ea0b25d0768f92d17f5b20c" translate="yes" xml:space="preserve">
          <source>Note that this function expects a list of integers representing Unicode code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 유니 코드 코드 포인트를 나타내는 정수 목록이 필요합니다. 바이트 목록이있는 경우 대신 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 모듈을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd7297e7a168339d862010e69cb4610a576f96e0" translate="yes" xml:space="preserve">
          <source>Note that this function treats a &lt;code&gt;path&lt;/code&gt; with a leading &lt;code&gt;~&lt;/code&gt; as an absolute one.</source>
          <target state="translated">이 함수는 앞에 &lt;code&gt;~&lt;/code&gt; 가 있는 &lt;code&gt;path&lt;/code&gt; 를 절대 경로 로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="5dc2b06327128a221483a845cf466f49fa39da58" translate="yes" xml:space="preserve">
          <source>Note that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">이 함수는 주어진 IO 데이터의 정수를 원시 바이트로 취급하고 어떤 종류의 인코딩 변환도 수행하지 않습니다. charlist에서 UTF-8로 인코딩 된 문자열로 변환하려면 대신 &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오. IO 데이터 및 문자 데이터에 대한 자세한 내용은 모듈 설명서 의 &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO 데이터&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f46bc01d34c1a8f27d34a80d0611920215b1706" translate="yes" xml:space="preserve">
          <source>Note that this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">이 함수는 임의의 하위 목록을 얻기 위해 &lt;code&gt;enumerable&lt;/code&gt; 전체를 순회합니다 .</target>
        </trans-unit>
        <trans-unit id="1cfa9837195cf9c63349ac44a72cf8140752983a" translate="yes" xml:space="preserve">
          <source>Note that this not only works with single expressions but also with arbitrary code blocks.</source>
          <target state="translated">이것은 단일 표현식뿐만 아니라 임의의 코드 블록에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bd78885c92dbd33a6356c7fbcb303ca6f0a8b88a" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic - not only do they convert charlists to strings, they also operate on integers, atoms, and so on.</source>
          <target state="translated">이러한 함수는 다형 적이라는 점에 유의하십시오. 문자 목록을 문자열로 변환 할뿐만 아니라 정수, 원자 등에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="14ce19a4da0f58dcf26e71e7c820a5ec0bbf379f" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic. They not only convert charlists to strings, but also integers to strings, atoms to strings, and so on.</source>
          <target state="translated">이러한 함수는 다형성입니다. 문자 목록을 문자열로 변환 할뿐만 아니라 정수를 문자열, 원자를 문자열 등으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="43c532218f4ed686a0d71d554c91a77ee3c049fb" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;regex#regex?/1&quot;&gt;&lt;code&gt;Regex.regex?/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">guard 절에서 유효하지 않은 유형 검사는이 규칙을 따르지 않습니다. 예 : &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;regex#regex?/1&quot;&gt; &lt;code&gt;Regex.regex?/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d1ab8bb1656e345421bed44fb85cdb6b3df0a91" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. For example: &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가드 절에서 유효하지 않은 유형 검사는이 규칙을 따르지 않습니다. 예 : &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0b8f286916684b88b0a25d36d8f780a42be1ba5" translate="yes" xml:space="preserve">
          <source>Note that unless you explicitly use &lt;code&gt;::&lt;/code&gt; modifiers, each entry in the binary pattern is expected to match a single byte (exactly 8 bits). If we want to match on a binary of unknown size, we can use the &lt;code&gt;binary&lt;/code&gt; modifier at the end of the pattern:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 수정자를 명시 적으로 사용하지 않는 한 2 진 패턴의 각 항목은 단일 바이트 (정확히 8 비트)와 일치해야합니다. 알 수없는 크기의 바이너리와 일치 시키려면 패턴 끝에 &lt;code&gt;binary&lt;/code&gt; 수정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="174cbc748d572204ea1540b27cb5cc59e7b6deca" translate="yes" xml:space="preserve">
          <source>Note that values added to the front are the ones fetched on lookup:</source>
          <target state="translated">앞에 추가 된 값은 조회시 가져온 값입니다.</target>
        </trans-unit>
        <trans-unit id="4534808d0e30c2a0c89aefa00459683895b7a5d4" translate="yes" xml:space="preserve">
          <source>Note that variables bound in a clause do not leak to the outer context:</source>
          <target state="translated">절에 바인딩 된 변수는 외부 컨텍스트로 유출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99c494f8c4b42bfb58605596ab066b0cd0beb517" translate="yes" xml:space="preserve">
          <source>Note that we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">목록에 &lt;code&gt;size&lt;/code&gt; 정보 가 없기 때문에 목록에 대해 구현하지 않았 으며 값을 &lt;code&gt;length&lt;/code&gt; 로 계산해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4e821d9d1f900f549c2c76e6f6522fe28ec874c0" translate="yes" xml:space="preserve">
          <source>Note that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">먼저 목록의 각 요소를 인쇄 한 다음 각 요소에 2를 곱하고 마지막으로 각각의 새 값을 인쇄했습니다. 이 예에서는 목록이 세 번 열거되었습니다. 스트림이있는 예를 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ff6a8b672135b387d9a90d6cece502b550379161" translate="yes" xml:space="preserve">
          <source>Note that we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole match in the replacement string.</source>
          <target state="translated">참고 우리는 백 슬래시 이스케이프 문자를 탈출했다는 것을 (즉, 우리가 사용 &lt;code&gt;\\N&lt;/code&gt; 대신에 단지 &lt;code&gt;\N&lt;/code&gt; 백 슬래시를 탈출, 대한 똑같은 &lt;code&gt;\\g{N}&lt;/code&gt; ). &lt;code&gt;\0&lt;/code&gt; 을 주면 대체 문자열에 전체 일치 항목을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c321fccec9582dfce9477fe7768165a7a09b608" translate="yes" xml:space="preserve">
          <source>Note that we have also defined a private function named &lt;code&gt;lookup/2&lt;/code&gt; to help with the common functionality of looking up a bucket and returning its &lt;code&gt;pid&lt;/code&gt; if it exists, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">또한 버킷을 찾고 &lt;code&gt;pid&lt;/code&gt; 가있는 경우 해당 pid를 반환하는 일반적인 기능 ( &lt;code&gt;{:error, :not_found}&lt;/code&gt; 을 돕기 위해 &lt;code&gt;lookup/2&lt;/code&gt; 라는 개인 함수도 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="a4e347dc2a26896b5ad2dd01746e3c38cd3e50c6" translate="yes" xml:space="preserve">
          <source>Note that we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">원자를 포함하는 내부 튜플이 &lt;code&gt;:.&lt;/code&gt; 점을 첫 번째 요소로 표시 :</target>
        </trans-unit>
        <trans-unit id="9412a4887f881774fae5591b90049312660e64f3" translate="yes" xml:space="preserve">
          <source>Note that we need a mechanism to pass the &lt;code&gt;bucket&lt;/code&gt; pid from the callback to the test. We do so by using the &lt;em&gt;test context&lt;/em&gt;. When we return &lt;code&gt;%{bucket: bucket}&lt;/code&gt; from the callback, ExUnit will merge this map into the test context. Since the test context is a map itself, we can pattern match the bucket out of it, providing access to the bucket inside the test:</source>
          <target state="translated">콜백에서 테스트로 &lt;code&gt;bucket&lt;/code&gt; pid 를 전달하는 메커니즘이 필요합니다 . 우리는 &lt;em&gt;테스트 컨텍스트&lt;/em&gt; 를 사용하여 그렇게합니다 . 콜백에서 &lt;code&gt;%{bucket: bucket}&lt;/code&gt; 을 반환하면 ExUnit이이 맵을 테스트 컨텍스트에 병합합니다. 테스트 컨텍스트는 맵 자체이므로 버킷 내에서 버킷과 패턴을 일치시켜 테스트 내부의 버킷에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec1e62d0fd9ece09297d2ef01c229bd24cfed25d" translate="yes" xml:space="preserve">
          <source>Note that we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">범위로 시작한 다음 범위의 각 요소에 2를 곱하는 스트림을 생성했습니다.이 시점에서 계산이 수행되지 않았습니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 가 호출 될 때만 실제로 범위의 각 요소를 열거하여 2를 곱하고 1을 더합니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 의 함수 는 &lt;em&gt;게으르고 &lt;/em&gt;&lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 의 함수 는 &lt;em&gt;eager&lt;/em&gt; 라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="3e819f2e65aae690b63c5af560e6444ef3c30ff3" translate="yes" xml:space="preserve">
          <source>Note that when creating this string representation, the &lt;code&gt;:authority&lt;/code&gt; value will be used if the &lt;code&gt;:host&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Otherwise, the &lt;code&gt;:userinfo&lt;/code&gt;, &lt;code&gt;:host&lt;/code&gt;, and &lt;code&gt;:port&lt;/code&gt; will be used.</source>
          <target state="translated">이 문자열 표현을 작성할 때 &lt;code&gt;:host&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;:authority&lt;/code&gt; 값이 사용됩니다 . 그렇지 않으면 &lt;code&gt;:userinfo&lt;/code&gt; , &lt;code&gt;:host&lt;/code&gt; 및 &lt;code&gt;:port&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="059596cc4da0ec6ea079bfeb0987398e72e24193" translate="yes" xml:space="preserve">
          <source>Note that when keyword lists are passed as the last argument to a function, if the short-hand syntax is used then the square brackets around the keyword list can be omitted as well. For example, the following:</source>
          <target state="translated">키워드 목록이 함수에 대한 마지막 인수로 전달 될 때 짧은 구문을 사용하는 경우 키워드 목록 주위의 대괄호도 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91d528c940d56f0624ee74f03dcdf3ce64881a92" translate="yes" xml:space="preserve">
          <source>Note that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">GenServer를 시작할 때 이름 &lt;code&gt;Stack&lt;/code&gt; 으로 등록 하여 직접 호출하고 스택에있는 내용을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e1ebe73da349bd10b0f0a0d1133669ff102e7d" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the messages from another test might be captured. This is OK as long you consider such cases in your assertions.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 다른 테스트의 메시지가 캡처 될 수 있습니다. 주장에서 그러한 경우를 고려하는 한 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="51593dd72717840f7fb2a715f89be6d7c2e52241" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times and datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir.</source>
          <target state="translated">ISO 8601에서는 시간과 날짜 / 시간이 다음 날 0 시로 24:00:00을 지정할 수 있지만이 표기법은 Elixir에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10328798e18043813d96248d25cbd19fb081be9c" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Leap seconds are not supported as well by the built-in Calendar.ISO.</source>
          <target state="translated">ISO 8601에서는 다음 날 0 시로 24:00:00을 지정할 수 있지만 Elixir에서는이 표기법을 지원하지 않습니다. 내장 된 Calendar.ISO에서는 윤초도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="674d928e8930fc373a1ecef037a0add8d70944ab" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 또는 &lt;code&gt;:strict&lt;/code&gt; 옵션 만 제공해야합니다 . 둘 다 제공하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eec8afe83887288b4e571792afdfd03698308c34" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 또는 &lt;code&gt;:strict&lt;/code&gt; 옵션 만 제공해야합니다 . 둘 다 제공하면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a66941b089effbcc609ab8e5c6d8166e34e89b1f" translate="yes" xml:space="preserve">
          <source>Note that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">별명에도 불구하고, 그 주 &lt;code&gt;M&lt;/code&gt; 은 매크로가 확장되는 상황에서 사용할 수 없습니다, 작품 위의 코드가 있기 때문에 &lt;code&gt;M&lt;/code&gt; 은 여전히로 확장 &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5618ec783469ef4c54ca8326a639f6727694278b" translate="yes" xml:space="preserve">
          <source>Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets.</source>
          <target state="translated">그러나 struct 필드는 개인용이므로 직접 액세스하면 안됩니다. 이 모듈의 기능을 사용하여 세트에 대한 조작을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="43d19607ee0a232b2886e30e288770f0a0223896" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">&lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; &lt;/a&gt; 와 달리이 연산자는 부울뿐만 아니라 모든 표현식을 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="904787334ac92370c9a9993f8474d839a9d2466c" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#or/2&quot;&gt;&lt;code&gt;or/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">&lt;a href=&quot;#or/2&quot;&gt; &lt;code&gt;or/2&lt;/code&gt; &lt;/a&gt; 와 달리이 연산자는 부울뿐만 아니라 모든 표현식을 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5ae63c410e0feddfea821d9a3ebf91fa6fffb5c3" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">분산 작업으로 작업 할 때 익명 함수와 함께 작동하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; &lt;/a&gt; 대신 명시 적 모듈, 함수 및 인수를 예상 하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt; 함수를 사용해야합니다 . 익명 함수는 관련된 모든 노드에 동일한 모듈 버전이 존재하기를 기대하기 때문입니다. 여기에 설명 된 제한이 전체 에코 시스템에 적용되므로 분산 프로세스에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="08cd47820e470aeb0ed46fa6530b94a8d0d659ed" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;task.supervisor#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;task.supervisor#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">분산 작업을 수행 할 때는 익명 함수와 함께 작동하는 &lt;a href=&quot;task.supervisor#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; &lt;/a&gt; 대신 명시 적 모듈, 함수 및 인수를 예상 하는 &lt;a href=&quot;task.supervisor#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt; 함수를 사용해야합니다 . 익명 함수는 관련된 모든 노드에 동일한 모듈 버전이 존재할 것으로 예상하기 때문입니다. 설명 된 제한 사항이 전체 에코 시스템에 적용되는 분산 프로세스에 대한 자세한 정보 는 &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1a5de811a65c6ac8bdd702e32d5c21604ebf82d" translate="yes" xml:space="preserve">
          <source>Note that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">패턴이 매크로에 제공 될 수 있지만 매크로는 값이 아닌 인수로 AST를 수신한다는 점을 기억하십시오. 예를 들어, 다음 패턴으로 매크로를 중단하려고하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f98570973aa7e2132e68496b2b9ad6d68c9748d2" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:deprecated&lt;/code&gt; key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the &lt;code&gt;@deprecated&lt;/code&gt; attribute:</source>
          <target state="translated">참고 &lt;code&gt;:deprecated&lt;/code&gt; 개발자가 기능을 호출 할 때 키가 경고하지 않습니다. 코드에서 경고를 발생 시키려면 &lt;code&gt;@deprecated&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe12959616fed170330064dc85549503954ef06" translate="yes" xml:space="preserve">
          <source>Note the British spelling!</source>
          <target state="translated">영국 철자법에 주목하십시오!</target>
        </trans-unit>
        <trans-unit id="b1c5d08584d148be13f621a2c51eacad30bf0769" translate="yes" xml:space="preserve">
          <source>Note the behaviour of those classes may change according to the Unicode and other modifiers:</source>
          <target state="translated">이러한 클래스의 동작은 유니 코드 및 기타 수정 자에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e188c7e768551ff604bcf40bceebdb7a51cda8" translate="yes" xml:space="preserve">
          <source>Note the capture syntax can also be used as a shortcut for creating functions:</source>
          <target state="translated">캡처 구문은 함수 작성을위한 바로 가기로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f21e2c658fa1b5b1502e58a82469aca236223e3" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 규칙은 가드에서 허용되는 함수 / 매크로의 이름 을 &lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt; 과 같이 &lt;code&gt;is_&lt;/code&gt; 접두사 로 지정하는 것 입니다. 그러나 함수 / 매크로가 부울을 반환하고 가드에서 허용되지 않는 경우 접두어가 없어야하며 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; 과 같이 물음표로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc7df408c1b6e9e0aa62f81ee99961007e92e471" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 규칙은 &lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt; 과 같이 &lt;code&gt;is_&lt;/code&gt; 접두어 로 가드에서 허용되는 함수 / 매크로 이름을 지정하는 것 입니다. 그러나 함수 / 매크로가 부울을 반환하고 가드에서 허용되지 않는 경우 접두사가 없어야하며 &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; 과 같은 물음표로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="02e568f28639d3d3cf9153ba1f47b6ffc7ed4a33" translate="yes" xml:space="preserve">
          <source>Note the environment is not returned as it can be accessed via &lt;a href=&quot;#fetch_env/2&quot;&gt;&lt;code&gt;fetch_env/2&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if the application is not loaded.</source>
          <target state="translated">환경은 &lt;a href=&quot;#fetch_env/2&quot;&gt; &lt;code&gt;fetch_env/2&lt;/code&gt; &lt;/a&gt; 를 통해 액세스 할 수 있으므로 리턴되지 않습니다 . 응용 프로그램이로드되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8291debf84c93cf7420e870a4723eb8919b7abde" translate="yes" xml:space="preserve">
          <source>Note the file is deleted even if in read-only mode.</source>
          <target state="translated">읽기 전용 모드 인 경우에도 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="20b9a7e0e7cfbc515eb86ff67eaa5244b2827ea0" translate="yes" xml:space="preserve">
          <source>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</source>
          <target state="translated">이 모듈의 함수는 열거 형을 반환하도록 보장됩니다. 열거 형은 다른 모양 (구조, 익명 함수 등)을 가질 수 있으므로이 모듈의 함수는 해당 모양을 반환 할 수 있으며 언제든지 변경 될 수 있습니다. 예를 들어, 오늘 익명 함수를 반환하는 함수는 다음 릴리스에서 구조체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d438d99970ff0575f83b52d72a57ff8778a28621" translate="yes" xml:space="preserve">
          <source>Note the hook receives the quoted arguments and it is invoked before the function is stored in the module. So &lt;a href=&quot;module#defines?/2&quot;&gt;&lt;code&gt;Module.defines?/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; for the first clause of every function.</source>
          <target state="translated">후크는 인용 된 인수를 수신하며 함수가 모듈에 저장되기 전에 호출됩니다. 따라서 &lt;a href=&quot;module#defines?/2&quot;&gt; &lt;code&gt;Module.defines?/2&lt;/code&gt; &lt;/a&gt; 는 모든 함수의 첫 번째 절에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="50c96e7409829996141bb668b995e2b96d78e115" translate="yes" xml:space="preserve">
          <source>Note the lock may also belong to another SCM and as such, an structural check is required. A structural mismatch should always return &lt;code&gt;:outdated&lt;/code&gt;.</source>
          <target state="translated">잠금이 다른 SCM에 속할 수도 있으므로 구조 검사가 필요합니다. 구조적 불일치는 항상 &lt;code&gt;:outdated&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8fc73248c724a3a7729fc783a9f3f7c1f0c33c3b" translate="yes" xml:space="preserve">
          <source>Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use &lt;a href=&quot;#remove_breaks/1&quot;&gt;&lt;code&gt;remove_breaks/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">재설정시 모듈은 &quot;계기 화 된&quot;상태로 유지됩니다. 모듈에서 모든 중단 점 및 계측 코드를 효과적으로 제거하려면 대신 &lt;a href=&quot;#remove_breaks/1&quot;&gt; &lt;code&gt;remove_breaks/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78022746bf120fb73527ad51647d6b12ba5c9e69" translate="yes" xml:space="preserve">
          <source>Note the program above hijacks stdin, so you won't be able to communicate with the underlying software via stdin (on the positive side, software that reads from stdin typically terminates when stdin closes).</source>
          <target state="translated">위의 프로그램은 stdin을 하이재킹하므로 stdin을 통해 기본 소프트웨어와 통신 할 수 없습니다 (양의 측면에서 stdin에서 읽는 소프트웨어는 일반적으로 stdin이 닫힐 때 종료 됨).</target>
        </trans-unit>
        <trans-unit id="db9c44355a667468b5a8a0fc6d5bc95bf927d9a1" translate="yes" xml:space="preserve">
          <source>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</source>
          <target state="translated">결과 값은 하루 중 시간을 나타냅니다. 예를 들어 ISO 일정의 경우 24 시간을 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcdf2418808bb9ad9b914fb25ca7111d444ec598" translate="yes" xml:space="preserve">
          <source>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">연도, 월, 일 등의 지정은 월별로 일 수, 연도 등이 다를 수 있기 때문에 &lt;code&gt;1..12&lt;/code&gt; 지정되었습니다 (즉, 월의 경우 1..12 대신 정수 ).</target>
        </trans-unit>
        <trans-unit id="3ccd699f8c48bd34a5a8a8648d6828c7250f9900" translate="yes" xml:space="preserve">
          <source>Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed.</source>
          <target state="translated">이 구성은 프로젝트가 스택으로 푸시되면 캐시됩니다. 여러 번 호출해도 다시 계산되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d029ff8336c9288d7f18814c831f1d16b88a78a" translate="yes" xml:space="preserve">
          <source>Note this function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">이 기능은 AST를 통과하지 않으며 루트 노드 만 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="4362db14fb11f2864280f428b48d005c5873f981" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">이 함수는 올바른 형식의 URI를 예상하며 유효성 검사를 수행하지 않습니다. &lt;a href=&quot;#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 광범위한 URI를 구문 분석하는 방법에 대한 예제는 아래의 &quot;예제&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f1cee9305c51b1d0d2373452f46efc36d69c692" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;uri#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">이 함수는 올바른 형식의 URI를 예상하며 유효성 검사를 수행하지 않습니다. &lt;a href=&quot;uri#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 광범위한 URI를 구문 분석하는 방법에 대한 예는 아래의 &quot;예&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6f74ff98cf77b2a5593760e563d32600a4851c6" translate="yes" xml:space="preserve">
          <source>Note this function requires the task supervisor to have &lt;code&gt;:temporary&lt;/code&gt; as the &lt;code&gt;:restart&lt;/code&gt; option (the default), as &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt; keeps a direct reference to the task which is lost if the task is restarted.</source>
          <target state="translated">이 기능을 가지고 작업 관리자를 필요로합니다 &lt;code&gt;:temporary&lt;/code&gt; 는 AS &lt;code&gt;:restart&lt;/code&gt; 으로 옵션 (기본값) &lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt; 작업이 다시 시작되면 손실 된 작업에 대한 직접 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ad3d41e55f91873f9f2759e06026d6db997aaba7" translate="yes" xml:space="preserve">
          <source>Note we do not recommend configuring Erlang/OTP's logger directly under the &lt;code&gt;:kernel&lt;/code&gt; application in your &lt;code&gt;config/config.exs&lt;/code&gt;, like this:</source>
          <target state="translated">&lt;code&gt;:kernel&lt;/code&gt; 과 같이 &lt;code&gt;config/config.exs&lt;/code&gt; 의 : kernel 애플리케이션 바로 아래에 Erlang / OTP의 로거를 구성하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="670fcc75233bb15545426defd664d58989830420" translate="yes" xml:space="preserve">
          <source>Note we have wrapped it in a &lt;code&gt;Mix.env() == :prod&lt;/code&gt; check, so this configuration does not apply to other environments.</source>
          <target state="translated">&lt;code&gt;Mix.env() == :prod&lt;/code&gt; 검사로 래핑 했으므로이 구성은 다른 환경에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94cf8d3395ef431ef4381beb9ead018cca5e96ef" translate="yes" xml:space="preserve">
          <source>Note we only set the port on start/daemon commands. If you also limit the port on other commands, such as &lt;code&gt;rpc&lt;/code&gt;, then you will be unable to establish a remote connection as the port will already be in use by the node.</source>
          <target state="translated">start / daemon 명령에서만 포트를 설정합니다. &lt;code&gt;rpc&lt;/code&gt; 와 같은 다른 명령에서도 포트를 제한하면 해당 포트가 노드에서 이미 사용 중이므로 원격 연결을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa4a640e0a030948b5a35ad9f1605a103aa1b3ef" translate="yes" xml:space="preserve">
          <source>Note we removed &lt;code&gt;async: true&lt;/code&gt; from &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Since the application environment is a global storage, tests that modify it cannot run concurrently. With all changes in place, all tests should pass, including the distributed one.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 에서 &lt;code&gt;async: true&lt;/code&gt; 를 제거 했습니다 . 애플리케이션 환경은 글로벌 스토리지이므로이를 수정하는 테스트는 동시에 실행할 수 없습니다. 모든 변경 사항이 적용되면 배포 된 테스트를 포함하여 모든 테스트를 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="eac2c1b3b01e930084b33fb0d5edbf4e23375457" translate="yes" xml:space="preserve">
          <source>Note you can also start it simply as &lt;code&gt;Stack&lt;/code&gt;, which is the same as &lt;code&gt;{Stack, []}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{Stack, []}&lt;/code&gt; 과 동일한 &lt;code&gt;Stack&lt;/code&gt; 으로 간단히 시작할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="002eb13193e06aa56b8ea00565416925c92cd1a9" translate="yes" xml:space="preserve">
          <source>Note you don&amp;rsquo;t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</source>
          <target state="translated">모듈에서 동적으로 디스패치하기 위해 동작을 정의 할 필요는 없지만 이러한 기능은 종종 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="010ffd58d35ff5aa8ceade9793ef288a87b30082" translate="yes" xml:space="preserve">
          <source>Note you don't need to define all applications in &lt;code&gt;:applications&lt;/code&gt;, only the entry points. Also remember that the recommended mode for all applications in the system is &lt;code&gt;:permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:applications&lt;/code&gt; 에 모든 애플리케이션을 정의 할 필요는없고 진입 점 만 정의 할 필요가 있습니다. 또한 시스템의 모든 응용 프로그램에 권장되는 모드는 &lt;code&gt;:permanent&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7fe1cc0f5eaee6fed761d78f416437776eb240f" translate="yes" xml:space="preserve">
          <source>Note, however, some configuration files, such as &lt;code&gt;config/runtime.exs&lt;/code&gt; does not support imports, as they are meant to be copied across systems.</source>
          <target state="translated">그러나 &lt;code&gt;config/runtime.exs&lt;/code&gt; 와 같은 일부 구성 파일 은 시스템간에 복사하기위한 것이므로 가져 오기를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccaa9177febc5965f3a6e9991d73e149b8c2b3d0" translate="yes" xml:space="preserve">
          <source>Note: All modules defined in Elixir are defined inside the main &lt;code&gt;Elixir&lt;/code&gt; namespace. However, for convenience, you can omit &amp;ldquo;Elixir.&amp;rdquo; when referencing them.</source>
          <target state="translated">참고 : Elixir에 정의 된 모든 모듈은 기본 &lt;code&gt;Elixir&lt;/code&gt; 네임 스페이스 내에 정의됩니다 . 그러나 편의상&amp;ldquo;Elixir&amp;rdquo;를 생략 할 수 있습니다. 그들을 참조 할 때.</target>
        </trans-unit>
        <trans-unit id="f9375188837fda1326cbb4f55c2eddcde5896357" translate="yes" xml:space="preserve">
          <source>Note: An interesting note regarding &lt;code&gt;if/2&lt;/code&gt; and &lt;code&gt;unless/2&lt;/code&gt; is that they are implemented as macros in the language; they aren&amp;rsquo;t special language constructs as they would be in many languages. You can check the documentation and the source of &lt;code&gt;if/2&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;the &lt;code&gt;Kernel&lt;/code&gt; module docs&lt;/a&gt;. The &lt;code&gt;Kernel&lt;/code&gt; module is also where operators like &lt;code&gt;+/2&lt;/code&gt; and functions like &lt;code&gt;is_function/2&lt;/code&gt; are defined, all automatically imported and available in your code by default.</source>
          <target state="translated">참고 : &lt;code&gt;if/2&lt;/code&gt; 및 &lt;code&gt;unless/2&lt;/code&gt; 에 관한 흥미로운 참고 사항 은 언어에서 매크로로 구현된다는 것입니다. 그들은 많은 언어에서와 같이 특별한 언어 구조가 아닙니다. 당신은 문서 및 소스 확인할 수 &lt;code&gt;if/2&lt;/code&gt; 에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈 문서를 . &lt;code&gt;Kernel&lt;/code&gt; 모듈은 또한 어디 사업자와 같은 &lt;code&gt;+/2&lt;/code&gt; 와 같은 기능 &lt;code&gt;is_function/2&lt;/code&gt; 정의, 모든 자동으로 가져 기본적으로 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333c3af19d66fc17e99fc5af70f1d710e9bfc88f" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;observer&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package. Alternatively, you can skip this section and continue the guide.</source>
          <target state="translated">참고 : &lt;code&gt;observer&lt;/code&gt; 가 시작되지 않으면 다음과 같은 상황이 발생할 수 있습니다. 일부 패키지 관리자는 기본적으로 GUI 지원을 위해 WX 바인딩없이 최소화 된 Erlang을 설치합니다. 일부 패키지 관리자에서는 헤드리스 Erlang을보다 완전한 패키지로 교체 할 수 있습니다 ( Debian / Ubuntu / Arch에서 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 라는 패키지를 찾으십시오 ). 다른 관리자의 경우 별도의 &lt;code&gt;erlang-wx&lt;/code&gt; (또는 비슷한 이름의) 패키지 를 설치해야 할 수 있습니다 . 또는이 섹션을 건너 뛰고 가이드를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d918daa7b1094720a58030ddd5f21024965cb9a" translate="yes" xml:space="preserve">
          <source>Note: If you are an Erlang developer, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; in Elixir actually map to the &lt;code&gt;andalso&lt;/code&gt; and &lt;code&gt;orelse&lt;/code&gt; operators in Erlang.</source>
          <target state="translated">참고 :이 얼랑 개발자, 경우 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 비약에 실제로 매핑 &lt;code&gt;andalso&lt;/code&gt; 및 &lt;code&gt;orelse&lt;/code&gt; 얼랑 연산자.</target>
        </trans-unit>
        <trans-unit id="ff9e17f09f7587478a4a85a5f5ba16eb3160272e" translate="yes" xml:space="preserve">
          <source>Note: Maps were recently introduced into the Erlang</source>
          <target state="translated">참고 :지도는 최근 Erlang에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="96f2bbaf73f21c5d620e6ce00661ef3a7f853b26" translate="yes" xml:space="preserve">
          <source>Note: Mix is an Elixir executable. This means that in order to run &lt;code&gt;mix&lt;/code&gt;, you need to have both &lt;code&gt;mix&lt;/code&gt; and &lt;code&gt;elixir&lt;/code&gt; executables in your PATH. That&amp;rsquo;s what happens when you install Elixir.</source>
          <target state="translated">참고 : Mix는 Elixir 실행 파일입니다. 즉 , &lt;code&gt;mix&lt;/code&gt; 를 실행하려면 PATH에 &lt;code&gt;mix&lt;/code&gt; 및 &lt;code&gt;elixir&lt;/code&gt; 실행 파일 이 모두 있어야합니다 . 이것이 Elixir를 설치할 때 일어나는 일입니다.</target>
        </trans-unit>
        <trans-unit id="ccb589e6f497a521acf64f009eba87d24abf9844" translate="yes" xml:space="preserve">
          <source>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the &lt;code&gt;time: :posix&lt;/code&gt; option.</source>
          <target state="translated">참고 : 파일 시간은 대부분의 운영 체제에서 POSIX 시간 형식으로 저장되므로 &lt;code&gt;time: :posix&lt;/code&gt; 옵션을 사용하여 파일 정보를 검색하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="85c13b1aace1377737ca0a9ef86cd79955430879" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;cp&lt;/code&gt; 명령 은 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지 여부에 따라 다르게 작동합니다 . 우리는이 행동을 명시 적으로 허용하지 않기로 결정했습니다. 경우 &lt;code&gt;source&lt;/code&gt; A는 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 디렉토리입니다 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="587e5cfb89d0a03b03528404235c890650244b41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;cp&lt;/code&gt; 명령 은 대상이 기존 디렉토리인지 여부에 따라 다르게 작동합니다. 디렉토리 인 대상으로의 복사를 명시 적으로 허용하지 않기로 선택했으며 시도하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bc27a55b2f54548178ef196dd8d09255e8434e41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix-like systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">참고 : Unix 계열 시스템의 &lt;code&gt;cp&lt;/code&gt; 명령 은 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지 여부에 따라 다르게 작동합니다 . 우리는이 동작을 명시 적으로 허용하지 않기로 선택했습니다. 경우 &lt;code&gt;source&lt;/code&gt; A는 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 디렉토리입니다 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6c1c6fecf03bb5a6c13228be756f3823698bbd1" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix-like systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">참고 : Unix 계열 시스템의 &lt;code&gt;cp&lt;/code&gt; 명령 은 대상이 기존 디렉토리인지 여부에 따라 다르게 작동합니다. 디렉토리 인 대상에 대한 복사를 명시 적으로 허용하지 않도록 선택했으며 시도하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2412c082ee9452e0961827f93fc820b4560394ce" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;mv&lt;/code&gt; 명령 은 &lt;code&gt;source&lt;/code&gt; 가 파일 인지 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지에 따라 다르게 작동합니다 . 우리는이 행동을 명시 적으로 허용하지 않기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="d7aaf6f04ff253bbc95b6fc72d0ff877c2ac6e9f" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix-like systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">참고 : Unix 계열 시스템의 &lt;code&gt;mv&lt;/code&gt; 명령 은 &lt;code&gt;source&lt;/code&gt; 가 파일이고 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지 여부에 따라 다르게 작동합니다 . 우리는이 동작을 명시 적으로 허용하지 않기로 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="318ba01affa2cb83a445a4ffd6d8bf1dd6eb9f01" translate="yes" xml:space="preserve">
          <source>Note: Unlike Erlang, user defined attributes are not stored in the module by default. The value exists only during compilation time. A developer can configure an attribute to behave closer to Erlang by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : Erlang과 달리 사용자 정의 속성은 기본적으로 모듈에 저장되지 않습니다. 이 값은 컴파일 시간 동안 만 존재합니다. 개발자는 &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; 를 호출하여 속성이 Erlang에 더 가깝게 동작하도록 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbaf6796d8f2470a0ab3f99e235b2791b2fba4b" translate="yes" xml:space="preserve">
          <source>Note: do not add parens when accessing fields, such as in &lt;code&gt;data.key()&lt;/code&gt;. If parenthesis are used, Elixir will consider it to be a function call on &lt;code&gt;data&lt;/code&gt;, which would be expected to be an atom.</source>
          <target state="translated">참고 : &lt;code&gt;data.key()&lt;/code&gt; 와 같이 필드에 액세스 할 때 괄호를 추가하지 마십시오 . 괄호가 사용되면 Elixir는 이를 원자로 예상되는 &lt;code&gt;data&lt;/code&gt; 에 대한 함수 호출로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="d6501e4eb8325e3aa1733c1d78f4786f805cb16e" translate="yes" xml:space="preserve">
          <source>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">참고 : 유니 코드 모드의 IO 장치에서는이 기능을 사용하지 마십시오. 잘못된 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="767ed77ecda9bec0c064d33f222982b4d00c82a3" translate="yes" xml:space="preserve">
          <source>Note: escripts do not support projects and dependencies that need to store or read artifacts from the priv directory.</source>
          <target state="translated">참고 : escript는 priv 디렉토리에서 아티팩트를 저장하거나 읽어야하는 프로젝트 및 종속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87f046ebf1cef9cc4aa9894db1ed9941904ef965" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex --werl&lt;/code&gt; (&lt;code&gt;iex.bat --werl&lt;/code&gt; on PowerShell) which may provide a better experience depending on which console you are using.</source>
          <target state="translated">참고 : Windows 를 사용하는 경우 사용중인 콘솔에 따라 더 나은 환경을 제공 할 수있는 &lt;code&gt;iex --werl&lt;/code&gt; ( PowerShell의 &lt;code&gt;iex.bat --werl&lt;/code&gt; )을 사용해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1575464df3ee39226b1eec5b01c029bb5c0bef" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex.bat --werl&lt;/code&gt; which may provide a better experience depending on which console you are using.</source>
          <target state="translated">참고 : Windows 를 사용하는 경우 사용중인 콘솔에 따라 더 나은 환경을 제공 할 수있는 &lt;code&gt;iex.bat --werl&lt;/code&gt; 을 시도 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="912e5c0c98d6ca0f341e5fc328517d2b1fabbcad" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering &lt;code&gt;iex&lt;/code&gt; (&lt;code&gt;iex.bat&lt;/code&gt;).</source>
          <target state="translated">참고 : Windows에서 실행중인 경우 터미널에서 기본적으로 UTF-8을 사용하지 않을 수 있습니다. &lt;code&gt;iex&lt;/code&gt; ( &lt;code&gt;iex.bat&lt;/code&gt; )를 &lt;code&gt;chcp 65001&lt;/code&gt; 하기 전에 chcp 65001 을 실행하여 현재 세션의 인코딩을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4dbeaf674e0eb7ea6925af7a2318ed6c85002a1" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering IEx.</source>
          <target state="translated">참고 : Windows에서 실행중인 경우 터미널에서 기본적으로 UTF-8을 사용하지 않을 수 있습니다. IEx를 시작하기 전에 &lt;code&gt;chcp 65001&lt;/code&gt; 을 실행하여 현재 세션의 인코딩을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e6389ccfd4efe5ada7d55d154db6d0a4d03109a" translate="yes" xml:space="preserve">
          <source>Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="translated">참고 : Elixir 프로젝트에 대해이 값을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 코드 로더가 &lt;code&gt;:elixir&lt;/code&gt; 응용 프로그램 및 해당 하위 를 찾을 수 있도록 결과 escript를 실행할 때 Elixir의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 대한 경로 를 &lt;code&gt;ERL_LIBS&lt;/code&gt; 환경 변수 에 추가해야합니다 . 응용 프로그램 (사용 된 경우).</target>
        </trans-unit>
        <trans-unit id="8ccad6d1cb0c1e92a31e2fb1270a6789b9c4f735" translate="yes" xml:space="preserve">
          <source>Note: if you want to find and execute a given script in PATH so it will be loaded in &lt;code&gt;iex&lt;/code&gt; use: &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt;. Later you&amp;rsquo;ll learn about &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt;, Elixir&amp;rsquo;s build tool, and how you can compile and load entire applications with &lt;code&gt;iex -S mix run&lt;/code&gt;. See &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;Supervisor and application&lt;/a&gt; for more details.</source>
          <target state="translated">참고 : PATH에서 지정된 스크립트를 찾아서 실행하려면 &lt;code&gt;iex&lt;/code&gt; 에서로드 합니다 : &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt; . 나중에 Elixir의 빌드 도구 인 &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix에&lt;/a&gt; 대해 배우고 &lt;code&gt;iex -S mix run&lt;/code&gt; 으로 전체 애플리케이션을 컴파일하고로드하는 방법에 대해 알아 봅니다 . 자세한 내용은 &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;감독자 및 응용 프로그램&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a231dc0df4ef51799726d55cc38b62b732c2965c" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">참고 :이 함수는 자소에서 분할되므로 문자열을 선형으로 횡단해야합니다. 바이트 수에 따라 문자열 또는 바이너리를 분할하려면 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a2b2736d0228ed219724e9f93f70ec1ac8cd179" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">참고 :이 함수는 graphemes에서 분할되므로 문자열을 선형으로 통과해야합니다. 바이트 수에 따라 문자열 또는 이진을 분할하려면 대신 &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57e11fb647c860e43cb9b2c5f6c254e9e56dfddb" translate="yes" xml:space="preserve">
          <source>Note: the Debugger snippet above was retrieved from &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;&amp;ldquo;Debugging techniques in Elixir&amp;rdquo; by Plataformatec&lt;/a&gt;.</source>
          <target state="translated">참고 : 위의 디버거 스 니펫은 &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;Plataformatec의&amp;ldquo;Ellixir의 디버깅 기술&amp;rdquo;&lt;/a&gt; 에서 검색되었습니다 .</target>
        </trans-unit>
        <trans-unit id="455360e26c9eab98077492b42dd026c45ea2e164" translate="yes" xml:space="preserve">
          <source>Note: this function is equivalent to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt;, except this function does not return the accumulator once the stream is processed.</source>
          <target state="translated">참고 :이 함수는 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; &lt;/a&gt; 와 동일합니다. 단,이 함수는 스트림이 처리 된 후 누산기를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92f2e22007c90b9cbb55bb29dc07138d25f25b5c" translate="yes" xml:space="preserve">
          <source>Note: this function is similar to &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt; except the latter returns both the flat list and accumulator, while this one returns only the stream.</source>
          <target state="translated">참고 :이 함수는 &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; &lt;/a&gt; 와 유사하지만 후자는 플랫 목록과 누산기를 모두 반환 하지만이 함수는 스트림 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1838e9e0c7c7ddb2da84c8c70085cf8301982628" translate="yes" xml:space="preserve">
          <source>Note: we will be using two nodes in the same machine throughout this chapter. You are free to use two (or more) different machines on the same network but you need to do some prep work. First of all, you need to ensure all machines have a &lt;code&gt;~/.erlang.cookie&lt;/code&gt; file with exactly the same value. Second, you need to guarantee &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; is running on a port that is not blocked (you can run &lt;code&gt;epmd -d&lt;/code&gt; for debug info). Third, if you want to learn more about distribution in general, we recommend &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;this great Distribunomicon chapter from Learn You Some Erlang&lt;/a&gt;.</source>
          <target state="translated">참고 :이 장 전체에서 동일한 시스템에서 두 개의 노드를 사용합니다. 동일한 네트워크에서 두 대 이상의 다른 컴퓨터를 자유롭게 사용할 수 있지만 준비 작업을 수행해야합니다. 우선, 모든 머신에 &lt;code&gt;~/.erlang.cookie&lt;/code&gt; 파일이 정확히 동일한 값을 가지고 있는지 확인해야 합니다. 둘째, 차단되지 않은 포트에서 &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; 가 실행되고 있는지 확인 해야합니다 ( 디버그 정보에 대해 &lt;code&gt;epmd -d&lt;/code&gt; 를 실행할 수 있음 ). 셋째, 일반적인 배포에 대해 더 배우고 싶다면 &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;Learn Your Some Erlang의 Distribunomicon 장을&lt;/a&gt; 추천 합니다 .</target>
        </trans-unit>
        <trans-unit id="9a1f1223d3d0c72df45c1e2b35a2ccf27e67399b" translate="yes" xml:space="preserve">
          <source>Note: you will likely get different process identifiers than the ones we are getting in this guide.</source>
          <target state="translated">참고 :이 안내서에서 제공하는 것과 다른 프로세스 식별자를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e501dc317df6513b552e6ef09f3d93b0d31cfc45" translate="yes" xml:space="preserve">
          <source>Nothing really exciting happens but it shows how we can control our application.</source>
          <target state="translated">실제로 흥미로운 것은 없지만 애플리케이션을 제어 할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f9f6ccaa3929763f1f8329a0cf42d1567c947e3" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;spawn/1&lt;/code&gt; returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:</source>
          <target state="translated">통지 &lt;code&gt;spawn/1&lt;/code&gt; 은 PID (프로세스 식별자)를 반환합니다. 이 시점에서 스폰 된 프로세스가 죽었을 가능성이 큽니다. 스폰 된 프로세스는 주어진 함수를 실행하고 함수가 완료된 후 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="28bdc086982ce6f35c77fe8c28e2ce539fb72e7b" translate="yes" xml:space="preserve">
          <source>Notice doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">doctest에는 제한이 있습니다. 상태 또는 부작용에 의존하기 때문에 함수를 doctest 할 수없는 경우 개발자는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 프롬프트 없이 직접 예제를 포함하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b421e9b5a288fb270e5d94ac8ec254970e093c" translate="yes" xml:space="preserve">
          <source>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</source>
          <target state="translated">&quot;Returning 5&quot;가 한 번이 아닌 두 번 인쇄되는 방식에 주목하십시오. 매크로는 값이 아닌 표현식을 수신하기 때문입니다 (정규 함수에서 예상되는 값임). 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1f183e763daf66a140719d8dda2839335bb5a222" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">방법 공지 사항 &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; 수익률 &lt;code&gt;3&lt;/code&gt; 짝수 불구하고 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; 기능을 가져 오지 않습니다. 사실, &lt;code&gt;return_length/0&lt;/code&gt; 이 다른 모듈에서 동일한 이름과 배열을 가진 함수를 가져온 경우에도 함수 결과에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3892c7952171348da3fa8fc4e90871b3d046b9b8" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">방법 공지 사항 &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; 수익률 &lt;code&gt;3&lt;/code&gt; 짝수 불구하고 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; 기능을 가져 오지 않습니다. 사실, &lt;code&gt;return_length/0&lt;/code&gt; 이 다른 모듈에서 동일한 이름과 arity를 ​​가진 함수를 가져 왔어 도 함수 결과에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86cf6571366da66046772448d17be71c9b8bac4d" translate="yes" xml:space="preserve">
          <source>Notice how the example above has a comma between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;do:&lt;/code&gt;, that&amp;rsquo;s because it is using Elixir&amp;rsquo;s regular syntax where each argument is separated by a comma. We say this syntax is using &lt;em&gt;keyword lists&lt;/em&gt;. We can pass &lt;code&gt;else&lt;/code&gt; using keywords too:</source>
          <target state="translated">위 예제에서 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;do:&lt;/code&gt; 사이에 쉼표가있는 방법에 주목하십시오 . 이는 각 인수가 쉼표로 구분되는 Elixir의 정규 구문을 사용하기 때문입니다. 이 구문은 &lt;em&gt;키워드 목록을&lt;/em&gt; 사용한다고 &lt;em&gt;합니다&lt;/em&gt; . 키워드를 사용하여 &lt;code&gt;else&lt;/code&gt; 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="089ef5aec5dcab204a4dde60fdae6b22199f9d60" translate="yes" xml:space="preserve">
          <source>Notice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the &lt;code&gt;pid&lt;/code&gt; above will be able to send it messages and manipulate the state.</source>
          <target state="translated">프로세스가 어떻게 상태를 유지하는지 확인하고 프로세스 메시지를 보내서이 상태를 가져오고 업데이트 할 수 있습니다. 사실, 위 의 &lt;code&gt;pid&lt;/code&gt; 를 알고있는 모든 프로세스는 메시지를 보내고 상태를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d3a08b640aa9ec43f4df6e72697d747babcab8" translate="yes" xml:space="preserve">
          <source>Notice how the supervisor automatically started a new registry, with a new PID, in place of the first one once we caused it to crash due to a bad input.</source>
          <target state="translated">잘못된 입력으로 인해 충돌이 발생하면 수퍼바이저가 처음으로 PID 대신 새 레지스트리를 사용하여 새 레지스트리를 자동으로 시작한 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="9a6c5a958a0495f608cd080595362cf8cc21a5de" translate="yes" xml:space="preserve">
          <source>Notice how we were able to elegantly parse the commands without adding a bunch of &lt;code&gt;if/else&lt;/code&gt; clauses that check the command name and number of arguments!</source>
          <target state="translated">명령 이름과 인수 수를 확인 하는 많은 &lt;code&gt;if/else&lt;/code&gt; 절을 추가하지 않고 명령을 우아하게 구문 분석 할 수 있었던 방법에 주목 하십시오!</target>
        </trans-unit>
        <trans-unit id="6dfab922fecade531cb4dec0d9405839ea8b9d8a" translate="yes" xml:space="preserve">
          <source>Notice in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;code&gt;c:init/1&lt;/code&gt; callback.</source>
          <target state="translated">이 경우 &lt;code&gt;use Supervisor&lt;/code&gt; 자동 으로 가져 오기 때문에 명시 적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; &lt;/a&gt; 을 가져올 필요가 없습니다 . 예를 들어 &lt;code&gt;c:init/1&lt;/code&gt; 콜백 에서 초기화 작업을 수행하는 데 모듈 기반 수퍼바이저를 정의하면 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c882f5ebb65100a3d2f1cd2368d20ea86c511dfc" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">그 주목 &lt;code&gt;.&lt;/code&gt; 또한 연산자입니다. 원격 호출은 두 개의 인수와 함께 AST의 점을 사용합니다. 두 번째 인수는 항상 원자입니다.</target>
        </trans-unit>
        <trans-unit id="df067cb31b582b9b17b8ec8909cd436d56688f8e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;1 = x&lt;/code&gt; is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a &lt;code&gt;MatchError&lt;/code&gt; is raised.</source>
          <target state="translated">그 통지 &lt;code&gt;1 = x&lt;/code&gt; 올바른 표현이며, 좌우 양쪽 모두가 일치하지 않는 경우에는 1로 동일하기 때문에 일치 &lt;code&gt;MatchError&lt;/code&gt; 가 상승된다.</target>
        </trans-unit>
        <trans-unit id="ea49ec32721d567bfbb9765cea3e755b4c4e02a9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;10 / 2&lt;/code&gt; returned a float &lt;code&gt;5.0&lt;/code&gt; instead of an integer &lt;code&gt;5&lt;/code&gt;. This is expected. In Elixir, the operator &lt;code&gt;/&lt;/code&gt; always returns a float. If you want to do integer division or get the division remainder, you can invoke the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; functions:</source>
          <target state="translated">것을 알 수 &lt;code&gt;10 / 2&lt;/code&gt; 부동 소수점 반환 &lt;code&gt;5.0&lt;/code&gt; 정수 대신 &lt;code&gt;5&lt;/code&gt; . 이것은 예상됩니다. Elixir에서 연산자 &lt;code&gt;/&lt;/code&gt; 는 항상 float를 반환합니다. 정수 나누기를하거나 나누기를 나머지로하려면 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;rem&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="887a696d47512286eb5278c149faaa334a09a281" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">통지 &lt;code&gt;__STACKTRACE__&lt;/code&gt; 는 현재 스택 트레이스를 검색하는 캐치 / 구조 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d5e7850b7bd8f241d8a1343704189a623bfa62" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;put_elem/3&lt;/code&gt; returned a new tuple. The original tuple stored in the &lt;code&gt;tuple&lt;/code&gt; variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.</source>
          <target state="translated">것을 알 수 &lt;code&gt;put_elem/3&lt;/code&gt; 는 새로운 튜플을 반환했습니다. &lt;code&gt;tuple&lt;/code&gt; 변수에 저장된 원래 튜플 은 수정되지 않았습니다. 목록과 마찬가지로 튜플도 변경할 수 없습니다. 튜플의 모든 작업은 새 튜플을 반환하며 지정된 튜플은 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b802bfe2367dd2e9b70b08829bc0a53825dc5da" translate="yes" xml:space="preserve">
          <source>Notice that Elixir allows you to drop the parentheses when invoking named functions. This feature gives a cleaner syntax when writing declarations and control-flow constructs.</source>
          <target state="translated">Elixir를 사용하면 명명 된 함수를 호출 할 때 괄호를 삭제할 수 있습니다. 이 기능은 선언 및 제어 흐름 구성을 작성할 때보다 명확한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45ddeb0507e2941d4064cc4fd963a7f2bec2af71" translate="yes" xml:space="preserve">
          <source>Notice that before our changes &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That&amp;rsquo;s the main idea behind the cache mechanism we are implementing.</source>
          <target state="translated">변경 전에 &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 는 서버로 요청을 보냈지 만 이제는 모든 프로세스에서 공유되는 ETS 테이블에서 직접 읽습니다. 이것이 우리가 구현하는 캐시 메커니즘의 기본 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="6a0f0c1ec687f2ea0cd8655129747b9d7cd3f754" translate="yes" xml:space="preserve">
          <source>Notice that by running &lt;code&gt;mix test&lt;/code&gt;, Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.</source>
          <target state="translated">&lt;code&gt;mix test&lt;/code&gt; 를 실행 하면 Mix가 소스 파일을 컴파일하고 애플리케이션 매니페스트를 다시 한 번 생성했습니다. Mix는 여러 환경을 지원하기 때문에이 장의 뒷부분에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57e1fb0b39317bc0fdf150c6ab3ed9709eedac00" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션 없이 &lt;code&gt;alias&lt;/code&gt; 을 호출 하면 모듈의 마지막 부분을 기반으로하는 별칭이 자동으로 설정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9daf8eefb4c15d859869ea5da53757de4d79f368" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 를 호출하는 것은 항상 이전에 선언 된 &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 에서만 배타적입니다 . 이전에 가져 오기가 없으면 모듈의 모든 기능과 매크로에 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d111052cc1acb6679f60941ac62aab89e4c9ddf" translate="yes" xml:space="preserve">
          <source>Notice that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">엔진마다 태그마다 규칙이 다를 수 있습니다. 다른 버전은 향후 버전에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="347481b6b324efbcacea6f493fbe1e9b884fc181" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 통지 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; 가&lt;/a&gt; 동시에 서로 다른 프로세스에 의해 호출, 첫 번째 프로세스가 호출 할 수는 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 잠금을 획득하고 파일을 사용할 수있을 때까지 남아있는 것들은 차단합니다. 즉 , 주어진 파일에서 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 가 두 번 이상 호출되면 해당 파일은 한 번만 컴파일됩니다. &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 를 호출하는 첫 번째 프로세스 는로드 된 모듈 목록을 가져 &lt;code&gt;nil&lt;/code&gt; 다른 프로세스 는 nil 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4e78784f8ee1baee6a6b68c15d6d35bbd3682972" translate="yes" xml:space="preserve">
          <source>Notice that it defines the application callback function, &lt;code&gt;start/2&lt;/code&gt;, and instead of defining a supervisor named &lt;code&gt;KVServer.Supervisor&lt;/code&gt; that uses the &lt;code&gt;Supervisor&lt;/code&gt; module, it conveniently defined the supervisor inline! You can read more about such supervisors by reading &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;the Supervisor module documentation&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 콜백 함수 &lt;code&gt;start/2&lt;/code&gt; 를 정의 하고 &lt;code&gt;Supervisor&lt;/code&gt; 모듈 을 사용하는 &lt;code&gt;KVServer.Supervisor&lt;/code&gt; 라는 감독자를 정의하는 대신 감독자 인라인을 편리하게 정의했습니다! &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor 모듈 설명서를&lt;/a&gt; 읽고 그러한 감독자에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b8e7a6900c64697dfb761c739ce312b8b3c54e" translate="yes" xml:space="preserve">
          <source>Notice that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">위의 값을 설정하면 Elixir의 기본값이 무시됩니다. 예를 들어, &lt;code&gt;:requires&lt;/code&gt; 를 &lt;code&gt;[]&lt;/code&gt; 로 설정 하면 더 이상 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈이 자동으로 필요하지 않습니다 . 같은 방법으로 설정 &lt;code&gt;:macros&lt;/code&gt; 는 더 이상 &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt; 등과 같은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 매크로를 자동으로 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e1f199b3af38598b79e950aaf97a0eca8c4b82c" translate="yes" xml:space="preserve">
          <source>Notice that string interpolation in Elixir calls the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">Elixir의 문자열 보간은 &lt;code&gt;to_string&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="840aa4d2de3105a50a863883569231610137217c" translate="yes" xml:space="preserve">
          <source>Notice that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option is set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason으로 종료 됩니다. 이 경우 수퍼바이저는 하위 스펙이 &lt;code&gt;:restart&lt;/code&gt; 옵션 으로 정의 되어 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정된 경우에만 재시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="80888ed7f572f5d6e47653c01243b5f16e08dc6e" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;IO.puts/1&lt;/code&gt; function returns the atom &lt;code&gt;:ok&lt;/code&gt; after printing.</source>
          <target state="translated">주목하라 그 &lt;code&gt;IO.puts/1&lt;/code&gt; 함수가 반환 원자 &lt;code&gt;:ok&lt;/code&gt; 인쇄 후.</target>
        </trans-unit>
        <trans-unit id="4e928f1dda24dbbefd3436c4e0da759a5854ad46" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 characters. That&amp;rsquo;s because the character &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">해당 문자열의 바이트 수는 5 자이지만 6입니다. 문자 &quot;&amp;ouml;&quot;는 UTF-8로 표현되는 데 2 ​​바이트가 필요하기 때문입니다. &lt;code&gt;String.length/1&lt;/code&gt; 함수를 사용하여 문자 수에 따라 문자열의 실제 길이를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b70cce683e94cd3e61bbd344224ed09711c0bbe6" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 graphemes. That&amp;rsquo;s because the grapheme &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of graphemes, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">5 개의 자소가 있더라도 해당 문자열의 바이트 수는 6입니다. 그 이유는 문자 소&amp;ldquo;&amp;ouml;&amp;rdquo;가 UTF-8로 표현되는 데 2 ​​바이트를 사용하기 때문입니다. &lt;code&gt;String.length/1&lt;/code&gt; 함수를 사용하여 자소 수를 기반으로 문자열의 실제 길이를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8942e3ca27cf75b423a37d9bfb02178064e23332" translate="yes" xml:space="preserve">
          <source>Notice that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason으로 종료 됩니다. 이 경우 수퍼바이저는 &lt;code&gt;:restart&lt;/code&gt; 옵션이 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정된 하위 스펙이 정의 된 경우에만 재시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="46c8a4ba57727e7ee215c034d3fe51bd425fdf82" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 의 구문 표현 은 &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; 이 아니라 &lt;code&gt;%{}&lt;/code&gt; optional (any) =&amp;gt; any } 입니다. &lt;code&gt;%{}&lt;/code&gt; 표기법 은 빈 맵의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bdf28662e920e08a018b921e52faac2f13427657" translate="yes" xml:space="preserve">
          <source>Notice that the third element in the quoted variable is the atom &lt;code&gt;Sample&lt;/code&gt;, instead of &lt;code&gt;nil&lt;/code&gt;, which marks the variable as coming from the &lt;code&gt;Sample&lt;/code&gt; module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.</source>
          <target state="translated">따옴표로 묶은 변수의 세 번째 요소는 변수가 &lt;code&gt;Sample&lt;/code&gt; 모듈 에서 온 것으로 표시하는 &lt;code&gt;nil&lt;/code&gt; 대신 atom &lt;code&gt;Sample&lt;/code&gt; 입니다. 따라서, Elixir는이 두 변수가 다른 상황에서 나온 것으로 간주하고 적절하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6c70c0b543ddc39b4906e53100736219e7d916c9" translate="yes" xml:space="preserve">
          <source>Notice that the version with &lt;code&gt;!&lt;/code&gt; returns the contents of the file instead of a tuple, and if anything goes wrong the function raises an error.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 로 버전을 확인하십시오 . 튜플 대신 파일의 내용을 반환하고 문제가 발생하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac1edafa4a033fbb4dca78373c1cefb5a29180a1" translate="yes" xml:space="preserve">
          <source>Notice that this function expects a list of integers representing UTF-8 code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 UTF-8 코드 포인트를 나타내는 정수 목록이 필요합니다. 바이트 목록이 있으면 대신 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 모듈을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cdf2f5ea01fa067c0fbde027a86184d517fa295" translate="yes" xml:space="preserve">
          <source>Notice that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">이 함수는 주어진 IO 데이터의 정수를 원시 바이트로 취급하며 어떤 종류의 인코딩 변환도 수행하지 않습니다. 문자 목록에서 UTF-8로 인코딩 된 문자열로 변환하려면 대신 &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오. IO 데이터 및 chardata에 대한 자세한 내용은 모듈 설명서 의 &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO 데이터&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da2e36451104accdab1f135698969f5dbb62ea72" translate="yes" xml:space="preserve">
          <source>Notice that variables bound in a clause &quot;head&quot; do not leak to the outer context:</source>
          <target state="translated">&quot;head&quot;절에 바인딩 된 변수는 외부 컨텍스트로 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8abda6194ee78d8c7b6bf446172dbd06081bc75a" translate="yes" xml:space="preserve">
          <source>Notice that we even see the exact same error message.</source>
          <target state="translated">똑같은 오류 메시지도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f18296fb1e15bf91d08f40da7cae0240a810e85c" translate="yes" xml:space="preserve">
          <source>Notice that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">먼저 목록의 각 요소를 인쇄 한 다음 각 요소에 2를 곱한 다음 새 값을 각각 인쇄했습니다. 이 예에서는 목록이 세 번 열거되었습니다. 스트림이있는 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="e80454db9add600d6dd12ebc0cf1ec2362e0064d" translate="yes" xml:space="preserve">
          <source>Notice that we referred to structs as &lt;strong&gt;bare&lt;/strong&gt; maps because none of the protocols implemented for maps are available for structs. For example, you can neither enumerate nor access a struct:</source>
          <target state="translated">구조체에 대해 맵에 구현 된 프로토콜이 없기 때문에 구조체를 &lt;strong&gt;베어&lt;/strong&gt; 맵이라고합니다. 예를 들어 구조체를 열거하거나 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7bd2d8499eb11634d1cac7e077fdc215c19c9e6" translate="yes" xml:space="preserve">
          <source>Notice that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">GenServer를 시작할 때 이름을 &lt;code&gt;Stack&lt;/code&gt; 으로 등록 하면 직접 호출하여 스택에있는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f35a2e632227e4c4fd62aa0253d676ce9ec766" translate="yes" xml:space="preserve">
          <source>Notice that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">별명에도 불구하고, 공지 사항 &lt;code&gt;M&lt;/code&gt; 은 매크로가 확장되는 상황에서 사용할 수없는이 작품을 위의 코드가 있기 때문에 &lt;code&gt;M&lt;/code&gt; 은 여전히로 확장 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6878fe98d8554fc9f432df2a9141f6399af678" translate="yes" xml:space="preserve">
          <source>Notice that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">매크로에는 패턴이 제공 될 수 있지만 매크로는 값이 아닌 AST를 인수로받습니다. 예를 들어, 다음과 같은 패턴으로 매크로를 끊으려고하면 :</target>
        </trans-unit>
        <trans-unit id="5cf97154e72e91b95ed319e84cacaa08b368821a" translate="yes" xml:space="preserve">
          <source>Notice the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 한도에 도달하지 않았으므로 줄 바꿈이있는 그대로 나타납니다. 일단 우리는 개행 문자로 대체됩니다 :</target>
        </trans-unit>
        <trans-unit id="496f1449954afceaf9beb520372d8e05f415dd6b" translate="yes" xml:space="preserve">
          <source>Notice the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 한도에 도달하지 않았으므로 줄 바꿈은 주어진 문자열로 표시됩니다. 일단 우리는 개행 문자로 대체됩니다 :</target>
        </trans-unit>
        <trans-unit id="3e4325519e924c99a829325af4cfbcadb94f2b5a" translate="yes" xml:space="preserve">
          <source>Notice the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 제공 기능은 &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 기능 으로 래핑됩니다 . &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 에서 설명한 바와 같이 기능은 각 단계 후 태그 튜플을 반환해야 &lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt; 형. 결국 &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="07069adb0c1e46329be40dc3e44e76edaef1ef62" translate="yes" xml:space="preserve">
          <source>Notice this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">이 함수는 임의의 하위 목록을 얻기 위해 &lt;code&gt;enumerable&lt;/code&gt; 전체를 탐색합니다 .</target>
        </trans-unit>
        <trans-unit id="89e0bc5cd464e7720b387f9becc6e78a50eb339c" translate="yes" xml:space="preserve">
          <source>Notice we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">리스트에 대한 &lt;code&gt;size&lt;/code&gt; 정보 가 없기 때문에리스트에 대해 구현하지 않았으며 그 값은 &lt;code&gt;length&lt;/code&gt; 로 계산해야합니다 .</target>
        </trans-unit>
        <trans-unit id="03afe8d614ca6b25d6bf98b3847bcf90d9034dfa" translate="yes" xml:space="preserve">
          <source>Notice we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole matched pattern in the replacement string.</source>
          <target state="translated">우리는 백 슬래시 이스케이프 문자를 탈출했다 주목 (즉, 우리가 사용 &lt;code&gt;\\N&lt;/code&gt; 대신에 단지 &lt;code&gt;\N&lt;/code&gt; 백 슬래시를 탈출, 대한 똑같은 &lt;code&gt;\\g{N}&lt;/code&gt; ). &lt;code&gt;\0&lt;/code&gt; 을 주면 , 일치하는 전체 패턴을 대체 문자열에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f85b4b1b8fafa24d41295fda0f44252f687ca128" translate="yes" xml:space="preserve">
          <source>Notice we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">원자를 포함하는 내부 튜플이 &lt;code&gt;:.&lt;/code&gt; 점을 첫 번째 요소로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c69e6930b5bc92d057ccefe34bb93eda478134f" translate="yes" xml:space="preserve">
          <source>Notice we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">범위로 시작한 다음 범위의 각 요소에 2를 곱하는 스트림을 만들었습니다.이 시점에서 계산이 수행되지 않았습니다. &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 가 호출 될 때만 실제로 범위의 각 요소에 2를 곱하고 1을 더하여 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 합니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 의 함수 는 &lt;em&gt;게으르고 &lt;/em&gt;Enum 의 함수 는 &lt;em&gt;열망&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba47ef34cc51f70a00d9e0a27391c8b89cac3f5e" translate="yes" xml:space="preserve">
          <source>Now a struct can be created as follows:</source>
          <target state="translated">이제 구조체를 다음과 같이 만들 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac6a27b4457ccc07e2ad2cacdcc3e23c4356feaa" translate="yes" xml:space="preserve">
          <source>Now all data types (including structs) that have not implemented the &lt;code&gt;Size&lt;/code&gt; protocol will be considered to have a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 구현하지 않은 모든 데이터 유형 (구조체 포함) 은 크기가 &lt;code&gt;0&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="89083d1bc146a648411e0ff3f2366a0deb9fa8b8" translate="yes" xml:space="preserve">
          <source>Now if you run the tests, you will see the test that checks the server interaction will fail, as it will attempt to use the routing table. To address this failure, add &lt;code&gt;@tag :distributed&lt;/code&gt; to this test too:</source>
          <target state="translated">테스트를 실행하면 라우팅 테이블을 사용하려고 시도하므로 서버 상호 작용을 검사하는 테스트가 실패하는 것을 볼 수 있습니다. 이 실패를 해결하려면 이 테스트에도 &lt;code&gt;@tag :distributed&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="07a537a78322242c13cbe0fc9e189cb95c551f62" translate="yes" xml:space="preserve">
          <source>Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment:</source>
          <target state="translated">이제 누군가가 줄을 세 부분으로 나누기를 원한다고 상상해보십시오. 응용 프로그램 환경을 통해 부품 수를 구성 할 수 있도록 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0d4fb1978dc93bf23ded5fbfb72b901b0ff9b3c1" translate="yes" xml:space="preserve">
          <source>Now imagine that this code does not fit its line. The code formatter introduces breaks inside &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; and inside &lt;code&gt;%{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. Therefore the document would break as:</source>
          <target state="translated">이제이 코드가 해당 라인에 맞지 않는다고 상상해보십시오. 소개합니다 내부 휴식 포맷터 코드 &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt; 과 내부 &lt;code&gt;%{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; . 따라서 문서는 다음과 같이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="1776285a5ee5e0cd2e476a5e17548b25cf3e7965" translate="yes" xml:space="preserve">
          <source>Now instead of:</source>
          <target state="translated">이제 대신</target>
        </trans-unit>
        <trans-unit id="b2edaaf4e4c37a573a2f4175b7fb677e22086d38" translate="yes" xml:space="preserve">
          <source>Now invoking &lt;code&gt;squared(my_number.())&lt;/code&gt; as before will print the value just once.</source>
          <target state="translated">이전과 같이 &lt;code&gt;squared(my_number.())&lt;/code&gt; 를 호출 하면 값이 한 번만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b50389659966a7555212a28c84596f8d8bad4035" translate="yes" xml:space="preserve">
          <source>Now it is your turn to write a test for the functionality above! Also, be sure to explore &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;the documentation for the &lt;code&gt;Agent&lt;/code&gt; module&lt;/a&gt; to learn more about them.</source>
          <target state="translated">이제 위의 기능에 대한 테스트를 작성하십시오. 또한 &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈에 대한 자세한 내용은 에이전트 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cac6639a99e22abeb99b7c1fe3b72525b3c0d41b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s make the doctest pass. Let&amp;rsquo;s implement the &lt;code&gt;parse/1&lt;/code&gt; function:</source>
          <target state="translated">이제 doctest를 통과합시다. &lt;code&gt;parse/1&lt;/code&gt; 함수를 구현하자 :</target>
        </trans-unit>
        <trans-unit id="76db12a2c71759a37e441cf80092642d7e2be4dd" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start an IEx session to compile the file and start the debugger:</source>
          <target state="translated">이제 IEx 세션을 시작하여 파일을 컴파일하고 디버거를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b328e1c1e09f5be9d544c4ae079f35bf00604c7a" translate="yes" xml:space="preserve">
          <source>Now let's cover the pattern matching rules for each construct and then for each relevant data-types.</source>
          <target state="translated">이제 각 구조와 각 관련 데이터 유형에 대한 패턴 일치 규칙을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="e3bb6483a50754a9a9376b80f656c2eee83a90ac" translate="yes" xml:space="preserve">
          <source>Now let's give it a try:</source>
          <target state="translated">이제 시도해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a06cdb0293b3c757aef93c1695a911a48f527d99" translate="yes" xml:space="preserve">
          <source>Now once the system boots, it will invoke the provider early in the boot process, save the merged configuration to the disk, and reboot the system with the new values in place.</source>
          <target state="translated">이제 시스템이 부팅되면 부팅 프로세스 초기에 공급자를 호출하고 병합 된 구성을 디스크에 저장 한 다음 새 값을 사용하여 시스템을 재부팅합니다.</target>
        </trans-unit>
        <trans-unit id="f8e788006f30e3c08108a5e67aea31d230a97139" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;mix test&lt;/code&gt; again (notice this time there will be no compilation):</source>
          <target state="translated">이제 &lt;code&gt;mix test&lt;/code&gt; 다시 실행 하십시오 (이번에는 컴파일이 없음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="19fa598d84faa6a938161fe34822951938d13086" translate="yes" xml:space="preserve">
          <source>Now run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;mix test&lt;/code&gt; 테스트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="edc3c0311fb8d8402744a5dc3b64fa6e7d3ee61a" translate="yes" xml:space="preserve">
          <source>Now run the shell:</source>
          <target state="translated">이제 쉘을 실행하십시오 :</target>
        </trans-unit>
        <trans-unit id="46c1aa1ce075b93b2b67727f3d1580cca77b1e86" translate="yes" xml:space="preserve">
          <source>Now that our application runs distributed, you may be wondering how we can package our application to run in production. After all, all of our code so far depends on Erlang and Elixir versions that are installed in your current system. To achieve this goal, Elixir provides releases.</source>
          <target state="translated">이제 애플리케이션이 분산 실행되었으므로 프로덕션에서 실행되도록 애플리케이션을 패키징하는 방법이 궁금 할 것입니다. 결국, 지금까지의 모든 코드는 현재 시스템에 설치된 Erlang 및 Elixir 버전에 따라 다릅니다. 이 목표를 달성하기 위해 Elixir는 릴리스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19a25f5fcd5f38d10706db44b6313eed285f06df" translate="yes" xml:space="preserve">
          <source>Now that our buckets are properly linked and supervised, let&amp;rsquo;s see how we can speed things up.</source>
          <target state="translated">버킷이 제대로 연결되고 감독되었으므로 속도를 높일 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9e53f2ea82a2cf9a10ea7d3d3f281c742019f84a" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;KV.Bucket&lt;/code&gt; module has been defined, our test should pass! You can try it yourself by running: &lt;code&gt;mix test&lt;/code&gt;.</source>
          <target state="translated">이제 것을 &lt;code&gt;KV.Bucket&lt;/code&gt; 의 모듈이 정의되어, 우리의 테스트를 통과해야한다! &lt;code&gt;mix test&lt;/code&gt; 를 실행하여 직접 시도해 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7df359bcf6fd7b6b53a7f0116a2c64cf244a918" translate="yes" xml:space="preserve">
          <source>Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:</source>
          <target state="translated">이제 모든 데이터 구조에 대해 프로토콜을 구현할 수 있으므로 프로토콜은 다음에 대한 호환 구현을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d686a4ce79ab4cc9d9c6a38ea87b99a5fd278a" translate="yes" xml:space="preserve">
          <source>Now that the server is part of the supervision tree, it should start automatically when we run the application. Start your server, now passing the port, and once again use the &lt;code&gt;telnet&lt;/code&gt; client to make sure that everything still works:</source>
          <target state="translated">이제 서버는 감독 트리의 일부이므로 응용 프로그램을 실행할 때 자동으로 시작됩니다. 이제 포트를 전달하여 서버를 시작한 후 &lt;code&gt;telnet&lt;/code&gt; 클라이언트를 다시 사용하여 모든 것이 여전히 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e7e80fb6ff6e247ded63d0bdc578c34f9a1551f2" translate="yes" xml:space="preserve">
          <source>Now that we have defined our supervision tree, it is a great opportunity to introduce the Observer tool that ships with Erlang. Start your application with &lt;code&gt;iex -S mix&lt;/code&gt; and key this in:</source>
          <target state="translated">이제 감시 트리를 정의 했으므로 Erlang과 함께 제공되는 관찰자 도구를 소개 할 수있는 좋은 기회입니다. &lt;code&gt;iex -S mix&lt;/code&gt; 로 애플리케이션을 시작하고 다음을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="65521a82582c996b661e688c57efd31c9126bde0" translate="yes" xml:space="preserve">
          <source>Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:</source>
          <target state="translated">이제 별칭에 대해 이야기 했으므로, 엘릭서에서 중첩과 작동 방식에 대해 이야기 할 수 있습니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bab99d6cee3867d995c14e2d5733f4da26449910" translate="yes" xml:space="preserve">
          <source>Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is &lt;strong&gt;what&lt;/strong&gt; we store, an encoding deals with &lt;strong&gt;how&lt;/strong&gt; we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, etc.</source>
          <target state="translated">이제 유니 코드 표준이 무엇이며 코드 포인트가 무엇인지 이해 했으므로 마지막으로 인코딩에 대해 이야기 할 수 있습니다. 코드 포인트 인 반면 &lt;strong&gt;무엇을&lt;/strong&gt; 우리가 인코딩 거래, 저장 &lt;strong&gt;방법&lt;/strong&gt; 우리가 그것을 저장 : 인코딩 구현입니다. 즉, 코드 포인트 번호를 메모리에 저장하거나 디스크에 기록 할 수 있도록 바이트로 변환하는 메커니즘이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac080018201e9a042de2521194aa2396dd3f6137" translate="yes" xml:space="preserve">
          <source>Now that you have defined an application callback which starts our supervisor, we expect the &lt;code&gt;KV.Registry&lt;/code&gt; process to be up and running as soon we start &lt;code&gt;iex -S mix&lt;/code&gt;. Let&amp;rsquo;s give it another try:</source>
          <target state="translated">이제 관리자를 시작하는 응용 프로그램 콜백을 정의 &lt;code&gt;iex -S mix&lt;/code&gt; 시작하자마자 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스가 시작되어 실행됩니다 . 다시 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="30b5dae909c9821ba155153ad42cdbcfe385f30c" translate="yes" xml:space="preserve">
          <source>Now that you have seen an example of the type of problem protocols help solve and how they solve them, let&amp;rsquo;s look at a more in-depth example.</source>
          <target state="translated">문제 해결에 도움이되는 문제 프로토콜 유형의 예와 해결 방법을 살펴 보았으므로 이제 더 심층적 인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="328f3af23181b7aed869a7baf3feac133b09d35c" translate="yes" xml:space="preserve">
          <source>Now trying to build a struct without the name key will fail:</source>
          <target state="translated">이제 이름 키없이 구조체를 만들려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f61f095187bf437534acdc98989a52599f7a57e0" translate="yes" xml:space="preserve">
          <source>Now type any string into the terminal and you will see that the same value will be printed in upper-case. Unfortunately, this example also got your IEx shell stuck in the comprehension, so you will need to hit &lt;code&gt;Ctrl+C&lt;/code&gt; twice to get out of it. :)</source>
          <target state="translated">이제 터미널에 문자열을 입력하면 동일한 값이 대문자로 인쇄됩니다. 불행히도,이 예제는 IEx 쉘이 이해력에 갇히게되므로 &lt;code&gt;Ctrl+C&lt;/code&gt; 를 두 번 눌러 제거 해야 합니다. :)</target>
        </trans-unit>
        <trans-unit id="46bc283c29ce2ecc43ead7d1d61cfa31cca09a7d" translate="yes" xml:space="preserve">
          <source>Now users can configure your library in their &lt;code&gt;config/config.exs&lt;/code&gt; file as follows:</source>
          <target state="translated">이제 사용자는 다음과 같이 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 라이브러리를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17fce085e9d552d0a9af3234c3cdfba2da82bb3" translate="yes" xml:space="preserve">
          <source>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</source>
          <target state="translated">프롬프트가 표시하는대로 이제 원격 노드에 연결되었으며 여기에 정의 된 정보 및 모듈에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57fd8f624da2baf5d7aba96d024c13b21b6b8eeb" translate="yes" xml:space="preserve">
          <source>Now we can start our debugger:</source>
          <target state="translated">이제 디버거를 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ff52cd0aed65a9dce91b318e1c1c0dbc4e09358d" translate="yes" xml:space="preserve">
          <source>Now we get an error because an application that &lt;code&gt;:kv&lt;/code&gt; depends on (&lt;code&gt;:logger&lt;/code&gt; in this case) isn&amp;rsquo;t started. We need to either start each application manually in the correct order or call &lt;code&gt;Application.ensure_all_started&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;:kv&lt;/code&gt; 가 의존 하는 응용 프로그램 ( 이 경우 &lt;code&gt;:logger&lt;/code&gt; )이 시작되지 않아 오류가 발생합니다. 올바른 순서로 각 응용 프로그램을 수동으로 시작하거나 다음과 같이 &lt;code&gt;Application.ensure_all_started&lt;/code&gt; 를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce58c619fafb232c624235ba4ccf102d6952d45a" translate="yes" xml:space="preserve">
          <source>Now we need to change &lt;code&gt;loop_acceptor/1&lt;/code&gt; to use &lt;code&gt;Task.Supervisor&lt;/code&gt; to serve each request:</source>
          <target state="translated">이제 각 요청을 &lt;code&gt;Task.Supervisor&lt;/code&gt; 하기 위해 Task.Supervisor 를 사용하도록 loop_acceptor &lt;code&gt;loop_acceptor/1&lt;/code&gt; 을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdeab946c4d9329d156b88e77a2ec9ecfeddcfa0" translate="yes" xml:space="preserve">
          <source>Now we only need to make &lt;code&gt;KV.RouterTest&lt;/code&gt; pass once again. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">이제 &lt;code&gt;KV.RouterTest&lt;/code&gt; 를 다시 한 번만 통과하면됩니다. 이를 위해 해당 파일의 모든 테스트 전에 실행되는 설정 블록을 작성합니다. 설정 블록은 다음과 같이 응용 프로그램 환경을 변경하고 완료되면 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="616d9118cd5824c6691d30e8ef906dec071996ec" translate="yes" xml:space="preserve">
          <source>Now with our routing system in place, let&amp;rsquo;s change &lt;code&gt;KVServer&lt;/code&gt; to use the router. Replace the &lt;code&gt;lookup/2&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt; by the following one:</source>
          <target state="translated">이제 라우팅 시스템을 설치 한 후 라우터를 사용하도록 &lt;code&gt;KVServer&lt;/code&gt; 를 변경 하겠습니다 . 바꾸기 &lt;code&gt;lookup/2&lt;/code&gt; 에서 함수 &lt;code&gt;KVServer.Command&lt;/code&gt; 을 다음 하나로 :</target>
        </trans-unit>
        <trans-unit id="473b17993b7eb7156690a660695f0604c4095a5c" translate="yes" xml:space="preserve">
          <source>Now with the protocol defined and implementations in hand, we can start using it:</source>
          <target state="translated">이제 프로토콜이 정의되고 구현되어 있으므로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac19fd0e99d45eb3bb8a29a0a874c8bc60bad1b" translate="yes" xml:space="preserve">
          <source>Now you can dynamically start supervised tasks:</source>
          <target state="translated">이제 감독 된 작업을 동적으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b14c8fa9966018b287124d6f5b635e573f91762" translate="yes" xml:space="preserve">
          <source>Now you can proceed to list this process in the &lt;code&gt;.appup&lt;/code&gt; file and hot code upgrade it. This is one of the many steps necessary to perform hot code upgrades and it must be taken into account by every process and application being upgraded in the system. The &lt;a href=&quot;http://erlang.org/doc/design_principles/appup_cookbook.html&quot;&gt;&lt;code&gt;.appup&lt;/code&gt; cookbook&lt;/a&gt; provides a good reference and more examples.</source>
          <target state="translated">이제 &lt;code&gt;.appup&lt;/code&gt; 파일 에이 프로세스를 나열 하고 핫 코드로 업그레이드 할 수 있습니다. 이는 핫 코드 업그레이드를 수행하는 데 필요한 여러 단계 중 하나이며 시스템에서 업그레이드되는 모든 프로세스와 애플리케이션에서이를 고려해야합니다. &lt;a href=&quot;http://erlang.org/doc/design_principles/appup_cookbook.html&quot;&gt; &lt;code&gt;.appup&lt;/code&gt; 의 요리 책은&lt;/a&gt; 좋은 참고 더 많은 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="32df2513a243e616c099ce25eeecd29f8971c442" translate="yes" xml:space="preserve">
          <source>Now you can run tests for both projects from the umbrella root with &lt;code&gt;mix test&lt;/code&gt;. Sweet!</source>
          <target state="translated">이제 우산 루트에서 &lt;code&gt;mix test&lt;/code&gt; 를 사용하여 두 프로젝트 모두에 대한 테스트를 실행할 수 있습니다 . 단!</target>
        </trans-unit>
        <trans-unit id="07b0131f4deaf329edfa37832794fd47dac09e81" translate="yes" xml:space="preserve">
          <source>Now you want to make the &lt;code&gt;heavy_fun()&lt;/code&gt; async:</source>
          <target state="translated">이제 &lt;code&gt;heavy_fun()&lt;/code&gt; 비동기 로 만들고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="476ae1fa4f615cd4311df04dc7c8a801b6354a43" translate="yes" xml:space="preserve">
          <source>Now, an entity interested in dispatching events for a given key may call &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of &lt;code&gt;{pid, value}&lt;/code&gt; tuples. In our example, &lt;code&gt;value&lt;/code&gt; will be the &lt;code&gt;{module, function}&lt;/code&gt; tuple in the code above:</source>
          <target state="translated">이제, 주어진 키에 대한 이벤트 디스패치에 관심이있는 엔티티 는 키와 콜백을 전달하는 &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 . 이 콜백은 요청 된 키 아래에 등록 된 모든 값 목록과 함께 각 값을 등록한 프로세스의 PID와 함께 &lt;code&gt;{pid, value}&lt;/code&gt; 튜플 의 형태로 호출됩니다 . 이 예에서 &lt;code&gt;value&lt;/code&gt; 는 위 코드에서 &lt;code&gt;{module, function}&lt;/code&gt; 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="363b2b445a852adb051cab43c32dcbd46d0ab5b3" translate="yes" xml:space="preserve">
          <source>Now, in your application, you can read this environment by using functions such as &lt;a href=&quot;#fetch_env!/2&quot;&gt;&lt;code&gt;fetch_env!/2&lt;/code&gt;&lt;/a&gt; and friends:</source>
          <target state="translated">이제 애플리케이션에서 &lt;a href=&quot;#fetch_env!/2&quot;&gt; &lt;code&gt;fetch_env!/2&lt;/code&gt; &lt;/a&gt; 및 friends와 같은 함수를 사용하여이 환경을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d99570fbe4495eecd768739b59540e2e4e121132" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s start two named nodes again, but inside the &lt;code&gt;:kv&lt;/code&gt; application:</source>
          <target state="translated">이제 두 개의 명명 된 노드를 다시 시작하지만 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 안에서 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7056385a9cb5c062d2f526a7af092bf8f6c98b17" translate="yes" xml:space="preserve">
          <source>Now, let's roll back to the first shell:</source>
          <target state="translated">이제 첫 번째 쉘로 롤백 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="8883bbf72dbea8b7c2911dc4d03827a0ab88aa71" translate="yes" xml:space="preserve">
          <source>Now, let's start another shell, giving it a name as well:</source>
          <target state="translated">이제 다른 쉘을 시작하여 이름을 지정해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b8f14e00a9ee1de5622bfa894ce44aa7673c9977" translate="yes" xml:space="preserve">
          <source>Now, try to access the &lt;code&gt;hello&lt;/code&gt; variable again:</source>
          <target state="translated">이제 &lt;code&gt;hello&lt;/code&gt; 변수에 다시 액세스 하십시오.</target>
        </trans-unit>
        <trans-unit id="f02afe5290423ebf3ed89e90bd9b4662ee206e07" translate="yes" xml:space="preserve">
          <source>Now, we will get an error if we try to use this operator &quot;out of the box&quot;:</source>
          <target state="translated">이제이 연산자를 &quot;바로&quot;사용하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a053460549010159dc2b6fda3731de548204bf3f" translate="yes" xml:space="preserve">
          <source>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</source>
          <target state="translated">히스토리에 보관할 표현 수 및 결과 값은 정수입니다. 음수이면 기록이 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="ff5e98caf48c434c6264af1a2c308ac24882bda5" translate="yes" xml:space="preserve">
          <source>OTP</source>
          <target state="translated">OTP</target>
        </trans-unit>
        <trans-unit id="fa8fe915548f0e22ce68e5cf32adf85a38cb0334" translate="yes" xml:space="preserve">
          <source>OTP exits</source>
          <target state="translated">OTP 이탈</target>
        </trans-unit>
        <trans-unit id="9ebb04f1d502294523ffc0d5654291733158f382" translate="yes" xml:space="preserve">
          <source>OWN - time spent in the function, excluding the time of called functions</source>
          <target state="translated">OWN-호출 된 함수의 시간을 제외하고 함수에서 소비 한 시간</target>
        </trans-unit>
        <trans-unit id="5170a26358c94cd0c4d86fad3a0f89ca90839e4e" translate="yes" xml:space="preserve">
          <source>Observe that we were able to considerably change the server implementation without changing any of the client API. That&amp;rsquo;s one of the benefits of explicitly segregating the server and the client.</source>
          <target state="translated">클라이언트 API를 변경하지 않고 서버 구현을 상당히 변경할 수 있음을 관찰하십시오. 이는 서버와 클라이언트를 명시 적으로 분리하면 얻을 수있는 이점 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="c85a3d54e191da03c6d7794a838fbe85cdb51bc7" translate="yes" xml:space="preserve">
          <source>Of all the approaches above, the first is definitely the most flexible. If our domain rules can be encoded with data structures, they are by far the easiest to compose and implement, as Elixir&amp;rsquo;s standard library is filled with functions for manipulating different data types.</source>
          <target state="translated">위의 모든 접근 방법 중 첫 번째 방법이 가장 유연합니다. 도메인 규칙을 데이터 구조로 인코딩 할 수 있다면 Elixir의 표준 라이브러리에는 다양한 데이터 유형을 조작하는 기능이 포함되어있어 작성 및 구현이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="902cb7ed7bd72ac12ba23366c9ffb04891ee4dcb" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming system, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">물론, Elixir는 분산 키-값 저장소보다 훨씬 더 많이 사용될 수 있습니다. 임베디드 시스템, 데이터 처리 및 데이터 처리, 웹 응용 프로그램, 스트리밍 시스템 및 기타는 Elixir가 능가하는 다양한 영역입니다. 이 안내서가 Elixir를 도입하기를 원하는 도메인 또는 향후 도메인을 탐색 할 수 있도록 준비했으면합니다.</target>
        </trans-unit>
        <trans-unit id="443083dbfa08188532e9cc376bf3569c4852013f" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming systems, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">물론 Elixir는 분산 된 키-값 저장소보다 훨씬 더 많이 사용할 수 있습니다. 임베디드 시스템, 데이터 처리 및 데이터 수집, 웹 애플리케이션, 스트리밍 시스템 등은 Elixir가 뛰어난 여러 도메인입니다. 이 가이드가 이러한 도메인 또는 Elixir를 가져올 향후 도메인을 탐색 할 수 있도록 준비 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="52497f8ab2a182c2ef6faac3953c494cb81f3fad" translate="yes" xml:space="preserve">
          <source>Of course, if you want to actually partition the tests, you can also do:</source>
          <target state="translated">물론 실제로 테스트를 분할하려면 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032c26697f2670cfce67357d79c2f377064ccf1" translate="yes" xml:space="preserve">
          <source>Of course, some operating systems and package managers can differ between versions, so if your goal is to have full compatibility between host and target, it is best to ensure the operating system and system package manager have the same versions on host and target. This may even be a requirement in some systems, especially so with package managers that try to create fully reproducible environments (Nix, Guix).</source>
          <target state="translated">물론 일부 운영 체제와 패키지 관리자는 버전마다 다를 수 있으므로 호스트와 대상간에 완전한 호환성을 유지하는 것이 목표 인 경우 운영 체제와 시스템 패키지 관리자가 호스트와 대상에서 동일한 버전을 갖도록하는 것이 가장 좋습니다. 이는 일부 시스템의 요구 사항 일 수 있습니다. 특히 완전히 재현 가능한 환경 (Nix, Guix)을 생성하려는 패키지 관리자의 경우 더욱 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="c9c303f80906a94bd84edefa290936f6df4b3704" translate="yes" xml:space="preserve">
          <source>Official #elixir-lang on freenode IRC</source>
          <target state="translated">프리 노드 IRC의 공식 # elixir-lang</target>
        </trans-unit>
        <trans-unit id="5ad3a32fb5de6c096b01951e5ee3be528054408f" translate="yes" xml:space="preserve">
          <source>Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.</source>
          <target state="translated">Elixir에서는 종종 다른 프로세스에서 또는 다른 프로세스에서 같은 시점에 액세스해야하는 상태를 공유하거나 저장해야 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="264e7ceb5e0be0af540c0e1efdf61cc8febc63a9" translate="yes" xml:space="preserve">
          <source>Often it is necessary to copy extra files to the release root after the release is assembled. This can be easily done by placing such files in the &lt;code&gt;rel/overlays&lt;/code&gt; directory. Any file in there is copied as is to the release root. For example, if you have placed a &quot;rel/overlays/Dockerfile&quot; file, the &quot;Dockerfile&quot; will be copied as is to the release root.</source>
          <target state="translated">릴리스가 어셈블 된 후 릴리스 루트에 추가 파일을 복사해야하는 경우가 많습니다. 이러한 파일을 &lt;code&gt;rel/overlays&lt;/code&gt; 디렉토리 에 배치하면 쉽게 수행 할 수 있습니다 . 거기에있는 모든 파일은있는 그대로 릴리스 루트에 복사됩니다. 예를 들어 &quot;rel / overlays / Dockerfile&quot;파일을 배치 한 경우 &quot;Dockerfile&quot;은있는 그대로 릴리스 루트에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4e555dd4a0b214fc42c4fafafd47bf3b759ac6" translate="yes" xml:space="preserve">
          <source>Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.</source>
          <target state="translated">엑시트 내부에 오류 / 예외가있는 경우가 종종 있습니다. 엑시트는 종종 호출자에 의해 랩핑되며 스택 추적도 제공합니다. 이 함수는 종료 이유, 호출자 및 스택 추적을 멋지게 표시하는 방식으로 종료를 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="9323e6675acdba059cc7528c84326fb722f7cf8a" translate="yes" xml:space="preserve">
          <source>Often they are used to express the state of an operation, by using values such as &lt;code&gt;:ok&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">종종 &lt;code&gt;:ok&lt;/code&gt; 및 &lt;code&gt;:error&lt;/code&gt; 와 같은 값을 사용하여 작업 상태를 표현하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c02ae25b9dec2dd8be94787202587f35da019d9" translate="yes" xml:space="preserve">
          <source>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the &lt;code&gt;put_in/2&lt;/code&gt;, &lt;code&gt;update_in/2&lt;/code&gt; and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</source>
          <target state="translated">종종지도 안에지도가 있거나지도 안에 키워드 목록 등이있을 수도 있습니다. Elixir는 &lt;code&gt;put_in/2&lt;/code&gt; , &lt;code&gt;update_in/2&lt;/code&gt; 및 기타 매크로를 통해 중첩 된 데이터 구조를 조작 할 수있는 편의성을 제공하며 언어의 불변 속성을 유지하면서 명령형 언어에서와 동일한 편의성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a567fc96e505fa689fb781ec6b8b66b74eefd6f8" translate="yes" xml:space="preserve">
          <source>On Unix-like / Bash:</source>
          <target state="translated">유닉스 계열 / 배쉬 :</target>
        </trans-unit>
        <trans-unit id="74b298f2360ded6dbf3b3733dbfa18ae283fccd2" translate="yes" xml:space="preserve">
          <source>On Windows 10 / PowerShell:</source>
          <target state="translated">Windows 10 / PowerShell :</target>
        </trans-unit>
        <trans-unit id="010a92ca285536db23a909835a24cc3bbd247a77" translate="yes" xml:space="preserve">
          <source>On Windows, path is split on both &quot;\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase.</source>
          <target state="translated">Windows에서는 경로가 &quot;\&quot;및 &quot;/&quot;구분 기호로 분할되고 드라이버 문자가 있으면 드라이버 문자가 항상 소문자로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ccfc5256f8269b091cc2f1bb3b3686fb247d7897" translate="yes" xml:space="preserve">
          <source>On Windows, your &lt;code&gt;env.bat&lt;/code&gt; would look like this:</source>
          <target state="translated">Windows에서 &lt;code&gt;env.bat&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="2779b0cd51a2b5987b501d655bc5be3263bd37e4" translate="yes" xml:space="preserve">
          <source>On its turn, the port will send the connected process the following messages:</source>
          <target state="translated">차례가되면 포트는 연결된 프로세스에 다음 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1c4b199ab2a5a87b093d5ef5b68e83e8d35a8454" translate="yes" xml:space="preserve">
          <source>On the language homepage, we mention that Elixir makes documentation a first-class citizen in the language. We have explored this concept many times throughout this guide, be it via &lt;code&gt;mix help&lt;/code&gt; or by typing &lt;code&gt;h Enum&lt;/code&gt; or another module in an IEx console.</source>
          <target state="translated">언어 홈페이지에서 Elixir는 문서를 언어에서 일류 시민으로 만든다고 언급합니다. 이 안내서에서이 개념을 여러 번 살펴 보았습니다. &lt;code&gt;mix help&lt;/code&gt; 통해 또는 IEx 콘솔에 &lt;code&gt;h Enum&lt;/code&gt; 또는 다른 모듈 을 입력 하여이 개념을 살펴 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="de96232518520933630bd7c423b5ed4b701f263c" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;:stdio&lt;/code&gt; and files opened with &lt;code&gt;:utf8&lt;/code&gt; encoding work with the remaining functions in the &lt;code&gt;IO&lt;/code&gt; module. Those functions expect a &lt;code&gt;char_data&lt;/code&gt; as an argument, that is, a list of characters or strings.</source>
          <target state="translated">반면, &lt;code&gt;:stdio&lt;/code&gt; &lt;code&gt;:utf8&lt;/code&gt; 인코딩으로 열린 : stdio 및 파일 은 &lt;code&gt;IO&lt;/code&gt; 모듈 의 나머지 기능과 함께 작동 합니다. 이러한 함수는 &lt;code&gt;char_data&lt;/code&gt; 를 인수, 즉 문자 또는 문자열 목록으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="df2f9b99e7ba432ec596beb6110247ffca71c5ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;Stream.unfold/2&lt;/code&gt; can be used to generate values from a given initial value:</source>
          <target state="translated">반면에 &lt;code&gt;Stream.unfold/2&lt;/code&gt; 는 주어진 초기 값에서 값을 생성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b8b9378d09ed0fb2e04b62c07969de258d132e4" translate="yes" xml:space="preserve">
          <source>On the other hand, aliases hold some properties:</source>
          <target state="translated">반면에 별명에는 몇 가지 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde8a500ad1f4f8eca18ffea106e75b93a90386b" translate="yes" xml:space="preserve">
          <source>On the other hand, function calls without parens are always indented by the function call length itself, like this:</source>
          <target state="translated">반면, parens가없는 함수 호출은 항상 다음과 같이 함수 호출 길이 자체에 의해 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="bc0c4bbb18d6918bd36e9cad44b9402719c305e1" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want partitioned tests but per-app reports, you can do:</source>
          <target state="translated">반면에 분할 된 테스트를 원하지만 앱별 보고서를 원한다면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf1909c9266c5b60bc634c9c3fd56fa5d862b1a5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">반면에 정수 값을 기반으로 문자열을 동적으로 분할 하려면 유효한 코드 포인트를 여러 바이트로 잘못 분할하지 않도록 &lt;a href=&quot;#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt; 를 사용 하는 것이 가장 좋은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="77e130342c984a0c62222639f83873c823bfc21f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;string#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">반면 정수 값을 기준으로 문자열을 동적으로 슬라이스하려면 &lt;a href=&quot;string#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt; 를 사용 하는 것이 유효한 코드 포인트를 여러 바이트로 잘못 분할하지 않도록 보장하는 가장 좋은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="96440900cf2787b3d188e44fb23cf1e92e8dffd8" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt; function in this protocol should be implemented whenever you can count the number of elements in the collection.</source>
          <target state="translated">반면, 이 프로토콜 의 &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; 함수는 컬렉션의 요소 수를 계산할 수있을 때마다 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c1c5ce2343c9ac12f7a79c1b7dce77805906dc2" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;.appup&lt;/code&gt;s are created, the next step is to create a &lt;code&gt;.relup&lt;/code&gt; file with all instructions necessary to update the release itself. Erlang documentation does provide a chapter on &lt;a href=&quot;http://erlang.org/doc/system_principles/create_target.html&quot;&gt;Creating and Upgrading a Target System&lt;/a&gt;. &lt;a href=&quot;https://learnyousomeerlang.com/relups&quot;&gt;Learn You Some Erlang has a chapter on hot code upgrades&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.appup&lt;/code&gt; 이 생성 되면 다음 단계는 릴리스 자체를 업데이트하는 데 필요한 모든 지침과 함께 &lt;code&gt;.relup&lt;/code&gt; 파일 을 생성하는 것입니다. Erlang 문서는 &lt;a href=&quot;http://erlang.org/doc/system_principles/create_target.html&quot;&gt;대상 시스템 생성 및 업그레이드&lt;/a&gt; 에 대한 장을 제공합니다 . &lt;a href=&quot;https://learnyousomeerlang.com/relups&quot;&gt;얼랭 배우기에는 핫 코드 업그레이드에 대한 장이 있습니다.&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bdbe00967c62a4c537ba3d468fbab141586df1" translate="yes" xml:space="preserve">
          <source>Once a case template is used, the regular functionality in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; plus the functionality defined in the template will become available.</source>
          <target state="translated">케이스 템플릿이 사용되면 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 의 일반 기능 과 템플릿에 정의 된 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5fb3909173c7fa57bb02b51698a4f60c66497d6" translate="yes" xml:space="preserve">
          <source>Once a configuration is written to a file, the functions in this module can be used to read and merge said configuration. The &lt;a href=&quot;#eval!/2&quot;&gt;&lt;code&gt;eval!/2&lt;/code&gt;&lt;/a&gt; function allows you to evaluate a given configuration file and the &lt;a href=&quot;#merge/2&quot;&gt;&lt;code&gt;merge/2&lt;/code&gt;&lt;/a&gt; function allows you to deep merge the results of multiple configurations. Those functions should not be invoked by users writing configurations but rather by library authors.</source>
          <target state="translated">구성이 파일에 기록되면이 모듈의 기능을 사용하여 해당 구성을 읽고 병합 할 수 있습니다. &lt;a href=&quot;#eval!/2&quot;&gt; &lt;code&gt;eval!/2&lt;/code&gt; &lt;/a&gt; 기능을 사용하면 특정 구성 파일 및 평가할 수 있습니다 &lt;a href=&quot;#merge/2&quot;&gt; &lt;code&gt;merge/2&lt;/code&gt; &lt;/a&gt; 기능은 완전 병합에 여러 구성의 결과를 할 수 있습니다. 이러한 함수는 구성을 작성하는 사용자가 아니라 라이브러리 작성자가 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="423d94dfd3979b636b7fca2ef0b1fc6c8a58898a" translate="yes" xml:space="preserve">
          <source>Once a function or a macro is marked as overridable, it will no longer be listed under &lt;a href=&quot;#definitions_in/1&quot;&gt;&lt;code&gt;definitions_in/1&lt;/code&gt;&lt;/a&gt; or return true when given to &lt;a href=&quot;#defines?/2&quot;&gt;&lt;code&gt;defines?/2&lt;/code&gt;&lt;/a&gt; until another implementation is given.</source>
          <target state="translated">함수 또는 매크로가 재정의 가능한 것으로 표시 되면 다른 구현이 제공 될 때까지 더 이상 &lt;a href=&quot;#definitions_in/1&quot;&gt; &lt;code&gt;definitions_in/1&lt;/code&gt; 에&lt;/a&gt; 나열되지 않거나 &lt;a href=&quot;#defines?/2&quot;&gt; &lt;code&gt;defines?/2&lt;/code&gt; &lt;/a&gt; 지정된 경우 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="95b80a8a26d020722b0a90ff95e49a9e574ce8e4" translate="yes" xml:space="preserve">
          <source>Once a release is assembled, it can be packaged and deployed to a target, as long as the target runs on the same operating system (OS) distribution and version as the machine running the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">릴리스가 어셈블되면 대상이 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 명령을 실행하는 시스템과 동일한 운영 체제 (OS) 배포 및 버전에서 실행되는 한 대상에 패키지화 및 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="765bea4530a733a2df7a7f9dcd62a6ce9ae623bf" translate="yes" xml:space="preserve">
          <source>Once a release is assembled, you can start it by calling &lt;code&gt;bin/RELEASE_NAME start&lt;/code&gt; inside the release. In production, you would do:</source>
          <target state="translated">릴리스가 어셈블되면 릴리스 내에서 &lt;code&gt;bin/RELEASE_NAME start&lt;/code&gt; 를 호출하여 시작할 수 있습니다 . 프로덕션에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="735a41bc25bec8dcef14df71df3ea20b9b58a5eb" translate="yes" xml:space="preserve">
          <source>Once a system is deployed, shutting down the system can be done by sending SIGINT/SIGTERM to the system, which is what most containers, platforms and tools do, or by explicitly invoking &lt;code&gt;bin/RELEASE_NAME stop&lt;/code&gt;. Once the system receives the shutdown request, each application and their respective supervision trees will stop, one by one, in the opposite order that they were started.</source>
          <target state="translated">시스템이 배포되면 대부분의 컨테이너, 플랫폼 및 도구가 수행하는 SIGINT / SIGTERM을 시스템에 전송하거나 &lt;code&gt;bin/RELEASE_NAME stop&lt;/code&gt; 을 명시 적으로 호출하여 시스템을 종료 할 수 있습니다 . 시스템이 종료 요청을 받으면 각 응용 프로그램과 해당 감시 트리가 시작된 순서와 반대로 하나씩 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="4be2f449756ad52de4a6efae2bb582fc005c9362" translate="yes" xml:space="preserve">
          <source>Once again, uncomment the last two lines by removing the leading &lt;code&gt;rem &lt;/code&gt; to enable full distribution. And that&amp;rsquo;s all!</source>
          <target state="translated">다시 한번, 전체 분배를 가능하게 하기 위해 선행 &lt;code&gt;rem &lt;/code&gt; 을 제거하여 마지막 두 줄의 주석을 해제하십시오 . 그리고 그게 전부입니다!</target>
        </trans-unit>
        <trans-unit id="cfc893eec70ab96edd7de58796885efa4ba9d8ca" translate="yes" xml:space="preserve">
          <source>Once everything was done, we closed the port.</source>
          <target state="translated">모든 것이 끝나면 포트를 닫았습니다.</target>
        </trans-unit>
        <trans-unit id="1621bce168937a18a32ac1d0bc7a6f51d70958e6" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle events in the following format:</source>
          <target state="translated">일단 초기화되면 핸들러는 다음 형식으로 이벤트를 처리하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d84e7ded08fc9663ca1a6cc34b5179a1a792130f" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle the following events:</source>
          <target state="translated">초기화되면 핸들러는 다음 이벤트를 처리하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f4d9f717239aa6329a574afa1566ba1188bc9fa" translate="yes" xml:space="preserve">
          <source>Once installed, the service must be explicitly managed via the &lt;code&gt;erlsrv&lt;/code&gt; executable, which is included in the &lt;code&gt;erts-VSN/bin&lt;/code&gt; directory. The service is not started automatically after installing.</source>
          <target state="translated">일단 설치되면 &lt;code&gt;erlsrv&lt;/code&gt; &lt;code&gt;erts-VSN/bin&lt;/code&gt; 디렉토리에 포함 된 erlsrv 실행 파일을 통해 서비스를 명시 적으로 관리해야합니다 . 설치 후 서비스가 자동으로 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea66816b8bd63ab93fda46bbd8289f6bc75e7802" translate="yes" xml:space="preserve">
          <source>Once multiple test runs are exported, this task can be used to generate an aggregated report.</source>
          <target state="translated">여러 테스트 실행을 내 보내면이 작업을 사용하여 집계 된 보고서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="290699e39f3ba4de6a466924dff98cd449d552b7" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;:logger&lt;/code&gt; application starts, it installs all event handlers listed under the &lt;code&gt;:backends&lt;/code&gt; configuration into the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; event manager. The event manager and all added event handlers are automatically supervised by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:logger&lt;/code&gt; 애플리케이션이 시작 되면 &lt;code&gt;:backends&lt;/code&gt; 구성 아래에 나열된 모든 이벤트 핸들러 가 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 이벤트 관리자에 설치됩니다. 이벤트 관리자 및 추가 된 모든 이벤트 핸들러는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 감독됩니다 .</target>
        </trans-unit>
        <trans-unit id="bba6866fbd0a67ef6097d91ded25789c9452b004" translate="yes" xml:space="preserve">
          <source>Once the agent is spawned, the given function &lt;code&gt;fun&lt;/code&gt; is invoked in the server process, and should return the initial agent state. Note that &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; does not return until the given function has returned.</source>
          <target state="translated">에이전트가 생성되면 지정된 함수 &lt;code&gt;fun&lt;/code&gt; 이 서버 프로세스에서 호출되며 초기 에이전트 상태를 반환해야합니다. 참고 것을 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 주어진 함수가 반환 될 때까지 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef9558c468b285f17bba1e7f8e7c4f2000f27cc1" translate="yes" xml:space="preserve">
          <source>Once the code above is executed inside an &lt;code&gt;iex&lt;/code&gt; session, IEx will ask if we want to pry into the current code. If accepted, we will be able to access all variables, as well as imports and aliases from the code, directly From IEx. While pry is running, the code execution stops, until &lt;code&gt;continue&lt;/code&gt; is called. Remember you can always run &lt;code&gt;iex&lt;/code&gt; in the context of a project with &lt;code&gt;iex -S mix TASK&lt;/code&gt;.</source>
          <target state="translated">위의 코드가 &lt;code&gt;iex&lt;/code&gt; 세션 내에서 실행되면 IEx는 현재 코드를 들어 올릴 것인지 묻습니다. 수락하면 모든 변수에 액세스 할 수 있으며 코드에서 가져 오기 및 별명뿐만 아니라 IEx에서 직접 액세스 할 수 있습니다. pry가 실행되는 동안 &lt;code&gt;continue&lt;/code&gt; 가 호출 될 때까지 코드 실행이 중지됩니다 . &lt;code&gt;iex -S mix TASK&lt;/code&gt; 를 사용하여 프로젝트 컨텍스트에서 항상 &lt;code&gt;iex&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="408c96ed6cd23c6d64030f673253fb9a91f2d8a7" translate="yes" xml:space="preserve">
          <source>Once the current application and its dependencies have been started, you can run a script in its context by passing a filename:</source>
          <target state="translated">현재 응용 프로그램과 해당 종속성이 시작되면 파일 이름을 전달하여 해당 컨텍스트에서 스크립트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b8a6b7ad11f7671cb5874e92543fc2ebfae2db" translate="yes" xml:space="preserve">
          <source>Once the dynamic supervisor is running, we can start children with &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;, which receives a child specification:</source>
          <target state="translated">동적 수퍼바이저가 실행되면 &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; 로&lt;/a&gt; 자식을 시작할 수 있으며 자식 사양을받습니다.</target>
        </trans-unit>
        <trans-unit id="a1cbb39ac09f145cd85ea1aba9ba9ce063b8a462" translate="yes" xml:space="preserve">
          <source>Once the monitored port process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">모니터링 된 포트 프로세스가 종료되면 다음과 같은 형태로 메시지가 모니터링 프로세스에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4f02c5f9ebc7bb88dcb63507719013ed2066f7bf" translate="yes" xml:space="preserve">
          <source>Once the monitored process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">모니터링 된 프로세스가 종료되면 다음과 같은 형태로 메시지가 모니터링 프로세스에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4605c758e24d4c33ee6d08e933b8102e776e5d52" translate="yes" xml:space="preserve">
          <source>Once the project is compiled, you can start an &lt;code&gt;iex&lt;/code&gt; session inside the project by running:</source>
          <target state="translated">프로젝트가 컴파일되면 다음 을 실행하여 프로젝트 내에서 &lt;code&gt;iex&lt;/code&gt; 세션을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e867373ffe7847f2db5130572df5f531464178dc" translate="yes" xml:space="preserve">
          <source>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</source>
          <target state="translated">프로젝트가 정의되면 명령 줄에서 여러 가지 기본 믹스 작업을 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79a17078f1ff880495dbda73a3e3a89834328f1" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 지정된 이름으로 레지스트리가 시작되면 &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; 튜플을 사용하여 명명 된 프로세스를 등록하고 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6aa7b033fd85bf146e14a8c7160118f513bc8d6" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;registry#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">&lt;a href=&quot;registry#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 지정된 이름으로 레지스트리를 시작 하면 &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; 튜플을 사용하여 명명 된 프로세스를 등록하고 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3120d183e67a369d29bc150b0338b6b8abb5d5d0" translate="yes" xml:space="preserve">
          <source>Once the server is started, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function of the given &lt;code&gt;module&lt;/code&gt; is called with &lt;code&gt;init_arg&lt;/code&gt; as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; has returned.</source>
          <target state="translated">서버가 시작되면 주어진 &lt;code&gt;module&lt;/code&gt; 의 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 함수 가 &lt;code&gt;init_arg&lt;/code&gt; 와 함께 호출되어 서버를 초기화합니다. 동기화 된 시작 절차를 보장하기 위해이 기능은 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="737b5a76c492695b1fb2a3499dcde47a6c323b7a" translate="yes" xml:space="preserve">
          <source>Once the server is started, the remaining functions in this module (&lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt;, and friends) will also accept an atom, or any &lt;code&gt;{:global, ...}&lt;/code&gt; or &lt;code&gt;{:via, ...}&lt;/code&gt; tuples. In general, the following formats are supported:</source>
          <target state="translated">서버가 시작되면이 모듈의 나머지 함수 ( &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; 및 friends)도 원자 또는 &lt;code&gt;{:global, ...}&lt;/code&gt; 또는 &lt;code&gt;{:via, ...}&lt;/code&gt; 튜플을 수락합니다 . . 일반적으로 다음 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbe4f06fe95e311cfe10127074ff0ebc20f68e2" translate="yes" xml:space="preserve">
          <source>Once the supervisor starts, it will traverse the list of children and it will invoke the &lt;code&gt;child_spec/1&lt;/code&gt; function on each module.</source>
          <target state="translated">수퍼바이저가 시작되면 하위 목록을 순회하며 각 모듈 에서 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="357e8b193ba3f628daabb2992835552bd8ea2347" translate="yes" xml:space="preserve">
          <source>Once the system specific dep is found, it loads it alongside env vars</source>
          <target state="translated">시스템 특정 dep가 발견되면 env vars와 함께로드합니다.</target>
        </trans-unit>
        <trans-unit id="1aa3fd67c8a0dadb7a1b2d1e3ee5265a0b531a76" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈이 컴파일되면이 정보는 &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 사용할 수있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1a684f0cbbb273de72ab550d4274ba6c60e61a1" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈이 컴파일되면 &lt;a href=&quot;https://hexdocs.pm/elixir/Code.html#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 함수를 통해이 정보를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddada7d31dcc026dad66a50326650a75cc9cbb38" translate="yes" xml:space="preserve">
          <source>Once we change &lt;code&gt;setup&lt;/code&gt;, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the &amp;ldquo;spawns buckets&amp;rdquo; test:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 을 변경하면 일부 테스트는 계속 실패합니다. 심지어 실행간에 테스트가 통과하고 일관성이없는 것을 확인할 수도 있습니다. 예를 들어 &quot;스폰 버킷&quot;테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb2639015e7a539ce9fee1573b15649d727fb15" translate="yes" xml:space="preserve">
          <source>Once you exit the telnet client, you will likely see an error in the IEx session:</source>
          <target state="translated">텔넷 클라이언트를 종료하면 IEx 세션에 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b9a98849835ca0ccdcfc637fc20489cc149751" translate="yes" xml:space="preserve">
          <source>Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a &lt;code&gt;main&lt;/code&gt; procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic.</source>
          <target state="translated">응용 프로그램이 컴파일되면 시스템을 실행하는 것은 현재 응용 프로그램과 해당 종속성을 시작하는 문제입니다. 다른 언어와 달리 Elixir에는 시스템 시작을 담당 하는 &lt;code&gt;main&lt;/code&gt; 절차 가 없습니다 . 대신 각각 자체 초기화 및 종료 논리를 사용하여 하나 이상의 응용 프로그램을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="42b067f2517980dc4135d671302e4a77495e8c98" translate="yes" xml:space="preserve">
          <source>Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts.</source>
          <target state="translated">라이브러리가 구성되면 라이브러리의 모든 사용자의 동작이 변경됩니다. 라이브러리가 문자열을 두 부분으로 나눌 것으로 예상 한 경우 구성이 전역이므로 이제 세 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="818ac58ed024c39752c7d32f5237a41c15a038fb" translate="yes" xml:space="preserve">
          <source>One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; has more detailed information on this approach.</source>
          <target state="translated">GenEvent의 한 가지 대안은 수퍼바이저와 여러 GenServer를 사용하여 구성된 최소 솔루션입니다. 수퍼바이저는 &quot;이벤트 관리자&quot;역할을하고 자식 GenServer는 &quot;이벤트 핸들러&quot;역할을합니다. 이 방법에는 단점이 있지만 (예를 들어 역압을 제공하지는 않지만) 낮은 프로파일 사용으로 GenEvent를 대체 할 수 있습니다. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;Jos&amp;eacute; Valim의이 블로그 게시물&lt;/a&gt; 에는이 접근 방식에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="936a273dad718f4cb0bdcd05e022e88904985504" translate="yes" xml:space="preserve">
          <source>One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt;, which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling &lt;a href=&quot;#iodata_length/1&quot;&gt;&lt;code&gt;iodata_length/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">IO 데이터의 한 가지 단점은 일반적으로 IO 데이터의 모양을 알지 못하기 때문에 바이너리와 같이 IO 데이터의 첫 부분에서 패턴 일치와 같은 작업을 수행 할 수 없다는 것입니다. 이 경우 &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 바이너리로 변환해야 할 수도 있습니다. iodata_to_binary / 1 은 C에서 기본적으로 구현되므로 상당히 효율적입니다. IO 데이터 길이 계산과 같은 다른 기능은 iodata에서 직접 호출하여 계산할 수 있습니다 &lt;a href=&quot;#iodata_length/1&quot;&gt; &lt;code&gt;iodata_length/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="959154f571cdda30a77c0e7157ebda7245e313d8" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;genserver#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir 표준 라이브러리에서 선택적 콜백의 한 예는 &lt;a href=&quot;genserver#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d674767cbf01026585b7b15f455dcf774fdcde40" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 표준 라이브러리에있는 선택적 콜백의 한 예는 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="682598a408460f45c2b269ef31f62c8ef9525a00" translate="yes" xml:space="preserve">
          <source>One flaw that shows up right away is the ordering issue. Since &lt;code&gt;KV.Registry&lt;/code&gt; invokes &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;, then the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; must be started before &lt;code&gt;KV.Registry&lt;/code&gt;. Otherwise, it may happen that the registry attempts to reach the bucket supervisor before it has started.</source>
          <target state="translated">즉시 나타나는 한 가지 결함은 주문 문제입니다. 이후 &lt;code&gt;KV.Registry&lt;/code&gt; 가 호출 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 을 다음 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 가 먼저 시작되어야 &lt;code&gt;KV.Registry&lt;/code&gt; . 그렇지 않으면 레지스트리가 시작되기 전에 레지스트리가 버킷 관리자에 도달하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4f2997cd25bc613534eada98471130bd76e1d1" translate="yes" xml:space="preserve">
          <source>One may also consider passing the &lt;code&gt;:delayed_write&lt;/code&gt; option if the stream is meant to be written to under a tight loop.</source>
          <target state="translated">스트림이 타이트한 루프 아래에 쓰여지는 경우 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션을 전달하는 것도 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfde78399ed297a92cd58c53e350baeaf0f353fe" translate="yes" xml:space="preserve">
          <source>One may be tempted to write:</source>
          <target state="translated">하나는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1781595a1670e5536e6aa5b4d9e3408ffa2c5bc3" translate="yes" xml:space="preserve">
          <source>One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above.</source>
          <target state="translated">-12.52로 중단 될 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 -12.51999999로 표시되며 위의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="243a9890c71db8191808f5cd66bd3e2313e581bb" translate="yes" xml:space="preserve">
          <source>One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above.</source>
          <target state="translated">바닥에 12.52가 될 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 12.51999999로 표시되며 위의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35c338e7afb24d2e6ec4b29eabef0038bd79d2c7" translate="yes" xml:space="preserve">
          <source>One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay.</source>
          <target state="translated">하나는 5.568로 반으로 올릴 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 5.567499999로 표시되며 위의 동작을 설명합니다. 소수점을 정확하게 반올림하려면 소수점 라이브러리를 사용해야합니다. 위의 동작은 또한 David M. Gay의 &quot;올바른 반올림 이진 십진 및 십진 이진 변환&quot;과 같은 참조 구현에 따른 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d7bc5e861299f07fac2c27f8474b114a4a1611a" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle all aspects of it as part of its core. Instead, Elixir aims to make itself extensible so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Elixir의 목표 중 하나는 확장 성입니다. 개발자는 특정 도메인에 맞게 언어를 확장 할 수 있어야합니다. 컴퓨터 과학은 언어가 핵심의 일부로 모든 측면을 다룰 수 없을 정도로 광범위한 분야가되었습니다. 대신 Elixir는 개발자, 회사 및 커뮤니티가 언어를 관련 도메인으로 확장 할 수 있도록 자체적으로 확장 가능한 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="75e244bba7b8a676a5ca57c1abcc6a33d031ea31" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle many fields as part of its core. Rather, our best bet is to make the language extensible, so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Elixir의 목표 중 하나는 확장 성입니다. 개발자는 특정 도메인에 맞게 언어를 확장 할 수 있어야합니다. 컴퓨터 과학은 광범위한 분야가되어 언어가 핵심의 일부로 많은 분야를 다루는 것이 불가능합니다. 오히려 우리의 최선의 방법은 언어를 확장 가능하게하여 개발자, 회사 및 커뮤니티가 언어를 관련 영역으로 확장 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f12014f3377101a9cac5f1547fca32045e59771c" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">작업의 일반적인 용도 중 하나는 의미 체계를 유지하면서 순차적 코드를 &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 동시 코드로 변환 하는 것입니다. 호출되면 호출자가 새 프로세스를 만들고 연결하고 모니터링합니다. 작업 작업이 완료되면 결과와 함께 메시지가 호출자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="442f0d53f86c717b454c40ddbdea4b216903b62b" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">작업의 일반적인 용도 중 하나는 의미를 유지하면서 순차적 코드를 &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 동시 코드로 변환 하는 것입니다. 호출되면 호출자가 새 프로세스를 작성, 링크 및 모니터링합니다. 작업 작업이 완료되면 결과와 함께 메시지가 발신자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="45e3c4f5c17e2b30b01adb9fc6c7523fd8a1551d" translate="yes" xml:space="preserve">
          <source>One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code:</source>
          <target state="translated">시스템 시간에 의존하는 복잡성 중 하나는 조정될 수 있다는 것입니다. 예를 들어, 일광 절약 시간을 입력 및 종료하면 시스템 시간이 조정되어 종종 1 시간을 추가하거나 제거합니다. 우리는 그러한 변화를 &quot;시간 왜곡&quot;이라고 부릅니다. 이러한 변경이 어떻게 유해 할 수 있는지 이해하려면 다음 코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="4db2b2faba0190fda13833749f4659dabf9003b6" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">감독 트리 외부에서 프로세스를 시작하는 것이 허용되는 몇 안되는 경우 중 하나는 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; 과는 반대로 &lt;code&gt;async/await&lt;/code&gt; 메커니즘은 생성 된 프로세스 수명주기에 대한 완전한 제어를 제공합니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 로 작업을 시작한 후 항상 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.html#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 를&lt;/a&gt; 호출해야합니다 . 하지만 애플리케이션이 여러 비동기 프로세스를 생성하는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 사용을 고려해야합니다. 경우 시스템을 계측하고 모니터링 할 때 더 나은 가시성을 위해 합니다.</target>
        </trans-unit>
        <trans-unit id="70db34f5d258e3970e35422bd42e5f7aa8840920" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">감독 트리 외부에서 프로세스를 시작할 수있는 몇 가지 시간 중 하나는 &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; 과는 반대로 &lt;code&gt;async/await&lt;/code&gt; 메커니즘은 생성 된 프로세스 수명주기를 완전히 제어 할 수 있도록합니다 . &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 로 작업을 시작한 후 항상 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 를&lt;/a&gt; 호출해야합니다 . 그러나 응용 프로그램이 여러 비동기 프로세스를 생성하는 경우 시스템 계측 및 모니터링시 가시성 을 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 위해 Task.Supervisor 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="50df693ec447426e4660f01fa52af9e0c7763ea8" translate="yes" xml:space="preserve">
          <source>One of the files generated by &lt;code&gt;mix new&lt;/code&gt; is the &lt;code&gt;.formatter.exs&lt;/code&gt;. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the &lt;code&gt;mix format&lt;/code&gt; task. The generated &lt;code&gt;.formatter.exs&lt;/code&gt; file configures which files should be formatted when &lt;code&gt;mix format&lt;/code&gt; runs.</source>
          <target state="translated">&lt;code&gt;mix new&lt;/code&gt; 가 생성 한 파일 중 하나는 &lt;code&gt;.formatter.exs&lt;/code&gt; 입니다. Elixir는 일관된 스타일에 따라 코드베이스를 자동으로 포맷 할 수있는 코드 포맷터와 함께 제공됩니다. 포맷터는 &lt;code&gt;mix format&lt;/code&gt; 작업 으로 트리거됩니다 . 생성 된 &lt;code&gt;.formatter.exs&lt;/code&gt; 파일은 &lt;code&gt;mix format&lt;/code&gt; 실행될 때 형식을 지정할 파일을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="23789ea13a63764ed754dab1a42ca60802bf16ed" translate="yes" xml:space="preserve">
          <source>One of the most common protocols you may encounter is the &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol: implementing its &lt;code&gt;to_string/1&lt;/code&gt; function for your custom structs will tell the Elixir kernel how to represent them as strings. We will explore all built-in protocols later. For now, let&amp;rsquo;s implement our own.</source>
          <target state="translated">가장 일반적인 프로토콜 중 하나는 &lt;a href=&quot;https://hexdocs.pm/elixir/String.Chars.html&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜입니다. 사용자 지정 구조체에 대해 &lt;code&gt;to_string/1&lt;/code&gt; 함수를 구현 하면 Elixir 커널에 문자열로 표현하는 방법을 알려줍니다. 나중에 모든 내장 프로토콜을 살펴 보겠습니다. 지금은 우리 자신을 구현합시다.</target>
        </trans-unit>
        <trans-unit id="e9bea613040d7bfb9b683e8ec5d094125d04fc14" translate="yes" xml:space="preserve">
          <source>One of the projects in the Elixir organization is &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;the &lt;code&gt;Plug&lt;/code&gt; project&lt;/a&gt;, which is meant to be a common foundation for building web libraries and frameworks in Elixir.</source>
          <target state="translated">엘릭서 조직의 프로젝트 중 하나는 &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 프로젝트 엘릭서에서 웹 라이브러리와 프레임 워크를 구축하기위한 공통의 기반이 될하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bc47161c9d9f59158e06bc671097821742b5b3c" translate="yes" xml:space="preserve">
          <source>One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as &lt;a href=&quot;#version/0&quot;&gt;&lt;code&gt;version/0&lt;/code&gt;&lt;/a&gt; to retrieve the Elixir version and &lt;a href=&quot;#otp_release/0&quot;&gt;&lt;code&gt;otp_release/0&lt;/code&gt;&lt;/a&gt; to retrieve the Erlang/OTP release.</source>
          <target state="translated">각 필드에서 반환 된 특정 형식에 의존해서는 안됩니다. 대신 &lt;a href=&quot;#version/0&quot;&gt; &lt;code&gt;version/0&lt;/code&gt; &lt;/a&gt; 과 같은 특수 기능을 사용 하여 Elixir 버전을 검색하고 &lt;a href=&quot;#otp_release/0&quot;&gt; &lt;code&gt;otp_release/0&lt;/code&gt; &lt;/a&gt; 을 사용하여 Erlang / OTP 릴리스를 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="3debe928eb1b5c8e87fe15888723579e1f0c4c11" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the &lt;code&gt;kv&lt;/code&gt; representation into the tree. That's when the &lt;code&gt;:bind_quoted&lt;/code&gt; option comes to the rescue (again!). By using &lt;code&gt;:bind_quoted&lt;/code&gt;, we can automatically disable unquoting while still injecting the desired variables into the tree:</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 매크로에서 인용 부호를 해제하는 것입니다. 그러나 이렇게하면 &lt;code&gt;kv&lt;/code&gt; 표현을 트리 에 주입 할 수 없습니다 . 그때 &lt;code&gt;:bind_quoted&lt;/code&gt; 옵션이 구출됩니다 (다시!). &lt;code&gt;:bind_quoted&lt;/code&gt; 를 사용 하면 트리에 원하는 변수를 계속 주입하면서 인용 부호를 자동으로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34436b8b519d619492a7f6d60f8ee6b7577de85" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind when using &lt;code&gt;do/end&lt;/code&gt; blocks is they are always bound to the outermost function call. For example, the following expression:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록을 사용할 때 명심해야 할 것은 항상 가장 바깥 쪽 함수 호출에 바인딩되어 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e4d62621d7dc89fa232dc83ec13aa33f3a32463" translate="yes" xml:space="preserve">
          <source>One-liner examples</source>
          <target state="translated">한 줄짜리 예</target>
        </trans-unit>
        <trans-unit id="fb233acd325ac5f63323e72a517a0c2a9f0f950a" translate="yes" xml:space="preserve">
          <source>One-off commands (eval and rpc)</source>
          <target state="translated">일회성 명령 (eval 및 rpc)</target>
        </trans-unit>
        <trans-unit id="76d560c48bdb5ca6e530c94b3e593f70eea7f4cf" translate="yes" xml:space="preserve">
          <source>Only a single break point can be set per function. So if you call &lt;code&gt;IEx.break!&lt;/code&gt; multiple times with different patterns, only the last pattern is kept.</source>
          <target state="translated">기능 당 하나의 중단 점 만 설정할 수 있습니다. 따라서 &lt;code&gt;IEx.break!&lt;/code&gt; 를 호출 하면! 다른 패턴으로 여러 번 마지막 패턴 만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="91104ae4893712c54ab7b2c242913ddbdd74161a" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;agent#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:via&lt;/code&gt; 에서는 고유 키가있는 레지스트리 만 사용할 수 있습니다 . 이름이 이미 사용 된 경우, 케이스 별 &lt;code&gt;start_link&lt;/code&gt; 함수 ( &lt;a href=&quot;agent#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt; 위의 예)를 반환 &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb293d4932d22a7b3abc1156a1928937b5c2868e" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">고유 키가있는 레지스트리 만 &lt;code&gt;:via&lt;/code&gt; 에서 사용할 수 있습니다 . 이름이 이미 사용 된 경우, 케이스 별 &lt;code&gt;start_link&lt;/code&gt; 함수 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt; 위의 예)를 반환 &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8370e504155b094c81379fca456a5fed9430a083" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b0fb72f3a11be642bad272639e9d74eca399f26a" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO 달력에있는 날짜 변환 또는 날짜가 자정에 시작되는 다른 달력 만 지원합니다. 다른 달력의 날짜를 변환하려고하면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="46f4e449cb60e2a60400c8cc32b9bd80531293a3" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9f0d1de9c28799182839cd339d3cb6bcc84675dc" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="30f7e5d05978072f24365b5caff95955f0fd6ddc" translate="yes" xml:space="preserve">
          <source>Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise.</source>
          <target state="translated">ISO 달력에있는 날짜 시간 변환 만 지원하며 다른 달력에서 날짜 시간 변환을 시도하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="22f0d29bfd1420b0788307cfc97c7fee840e6505" translate="yes" xml:space="preserve">
          <source>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</source>
          <target state="translated">ISO 달력에있는 순진 날짜 시간 변환 만 지원하며 다른 달력에서 순진 날짜 시간 변환을 시도하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d3045ee98cfbc830389c9723770392a552b836ee" translate="yes" xml:space="preserve">
          <source>Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the &lt;em&gt;output&lt;/em&gt; of the macros boils down to a combination of the constructs above.</source>
          <target state="translated">이 페이지에 나열된 구성 만 패턴 및 가드에서 허용됩니다. 그러나 매크로를 활용하여 프로그램을 단순화하거나 도메인별로 더 구체적으로 만들 수있는 사용자 지정 패턴 가드를 작성할 수 있습니다. 결국 중요한 것은 매크로 의 &lt;em&gt;출력&lt;/em&gt; 이 위의 구조 조합으로 요약된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="332d85692072489eba14a228f056afbb7b36291a" translate="yes" xml:space="preserve">
          <source>Only the result of the tried expression falls down to the &lt;code&gt;else&lt;/code&gt; clause. If the &lt;code&gt;try&lt;/code&gt; ends up in the &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; clauses, their result will not fall down to &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">시도한 표현식의 결과 만 &lt;code&gt;else&lt;/code&gt; 절로 떨어집니다 . 는 IF &lt;code&gt;try&lt;/code&gt; 에서 끝나는 &lt;code&gt;rescue&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 조항, 그 결과는 아래로 떨어지지 않을 &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6a0905b9fcc638e0a1fca8f76bccd9e9d7434ee" translate="yes" xml:space="preserve">
          <source>Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the &lt;code&gt;:{}&lt;/code&gt; special form.</source>
          <target state="translated">엘릭서에서는 2 요소 튜플 만 리터럴로 간주되며 인용시 스스로 반환합니다. 따라서 다른 모든 튜플은 AST에서 &lt;code&gt;:{}&lt;/code&gt; 특수 양식 에 대한 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="16aa064c9dc61340a6a7ced2fa58dff653a9081d" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix normally starts the whole hierarchy of applications defined in our project&amp;rsquo;s &lt;code&gt;mix.exs&lt;/code&gt; file and it does the same for all dependencies if they depend on other applications.</source>
          <target state="translated">죄송합니다. 이미 시작되었습니다. 믹스는 일반적으로 프로젝트의 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 애플리케이션의 전체 계층을 시작하며 다른 애플리케이션에 의존하는 경우 모든 종속성에 대해 동일하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5d42424300a2c91f547136c88eca4a886647949b" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix starts the current application and all of its dependencies automatically. This is also true for &lt;code&gt;mix test&lt;/code&gt; and many other Mix commands.</source>
          <target state="translated">죄송합니다. 이미 시작되었습니다. Mix는 현재 애플리케이션과 모든 종속성을 자동으로 시작합니다. 이것은 &lt;code&gt;mix test&lt;/code&gt; 및 다른 많은 믹스 명령 에도 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="b63fb954cf2f2503038e51c96f877372b330207c" translate="yes" xml:space="preserve">
          <source>Opaque types</source>
          <target state="translated">불투명 유형</target>
        </trans-unit>
        <trans-unit id="626c544948c998858d0a89d08603d35b395d1a8e" translate="yes" xml:space="preserve">
          <source>Open mechanisms</source>
          <target state="translated">개방 메커니즘</target>
        </trans-unit>
        <trans-unit id="3f9c7fb45e8ae0a5da7732a25ef64d2dd5e2f563" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and change the &lt;code&gt;application/0&lt;/code&gt; function to return the following:</source>
          <target state="translated">&lt;code&gt;apps/kv/mix.exs&lt;/code&gt; 를 열고 &lt;code&gt;application/0&lt;/code&gt; 함수를 변경 하여 다음을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="11e01c21d7ba4061c620362e2623f958eae1be36" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;iex&lt;/code&gt; and type the following expressions:</source>
          <target state="translated">&lt;code&gt;iex&lt;/code&gt; 를 열고 다음 표현식을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d7a32c8b909bef4e4cf763fd044d2d69bd11d7c1" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, and let&amp;rsquo;s change its implementation. We&amp;rsquo;ve added comments to the source code to highlight the changes we&amp;rsquo;ve made:</source>
          <target state="translated">&lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 를 열고 구현을 변경합시다. 변경 사항을 강조하기 위해 소스 코드에 주석을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d182cf46ee852ebeb083e187ed597b6979eb7f37" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; and add the dynamic supervisor as a child as follows:</source>
          <target state="translated">&lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 를 열고 다음과 같이 동적 수퍼바이저를 하위로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="27d3d6fb25a7f593cdb34dc77c7c498cc6061a34" translate="yes" xml:space="preserve">
          <source>Open up a file, replace all &lt;code&gt;#&lt;/code&gt; by &lt;code&gt;%&lt;/code&gt; and stream to another file without loading the whole file in memory:</source>
          <target state="translated">파일을 열고 모든 &lt;code&gt;#&lt;/code&gt; 을 &lt;code&gt;%&lt;/code&gt; 로 바꾸고 전체 파일을 메모리에로드하지 않고 다른 파일로 스트리밍하십시오.</target>
        </trans-unit>
        <trans-unit id="ece7b632859c06af3b4a35143bf4f0fa432ea01f" translate="yes" xml:space="preserve">
          <source>Opens a port given a tuple &lt;code&gt;name&lt;/code&gt; and a list of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 목록이 지정된 포트를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="3bf9b6c6020d1727c93ab3183dfda7cf9cd39780" translate="yes" xml:space="preserve">
          <source>Opens the current prying location.</source>
          <target state="translated">현재 프라이 위치를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7ac9350441fbbb582d3cc2a8956eb86730e74983" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;module.function/arity&lt;/code&gt;, or &lt;code&gt;{file, line}&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;module.function/arity&lt;/code&gt; 또는 &lt;code&gt;{file, line}&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5014597cdb33f83d370a77bd5b4dfd1154807086" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="11fb7a6db2170c9e59b49c5c2c758efde86398a0" translate="yes" xml:space="preserve">
          <source>Operating System environment configuration</source>
          <target state="translated">운영 체제 환경 구성</target>
        </trans-unit>
        <trans-unit id="46f4a92cf29f486cc2b970f2c56e3de24e2e02fa" translate="yes" xml:space="preserve">
          <source>Operating system process partitioning</source>
          <target state="translated">운영 체제 프로세스 파티셔닝</target>
        </trans-unit>
        <trans-unit id="56954dba5681f277cf4bb9e00fa07ee2810296a2" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">스트림 작동은 &lt;a href=&quot;#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 열 때 실패 할 수 있습니다 . 스트리밍이 시작될 때마다 파일이 자동으로 열립니다. &lt;code&gt;:read&lt;/code&gt; 및 &lt;code&gt;:write&lt;/code&gt; 모드는 Elixir에 의해 자동으로 설정되므로 전달할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="46f82301da497c0a0c802e4991b6eca2df33534d" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;file#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">&lt;a href=&quot;file#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 스트림 작동이 실패 할 수 있습니다 . 스트리밍이 시작될 때마다 파일이 자동으로 열립니다. &lt;code&gt;:read&lt;/code&gt; 및 &lt;code&gt;:write&lt;/code&gt; 모드는 Elixir에 의해 자동으로 설정되므로 통과 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0c395ef963d75a809b690d9db937d93c13ee8b98" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
          <target state="translated">연산자 우선 순위 및 연관성</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e0733d98d125d129b916b0d8e46a91b56da34c0e" translate="yes" xml:space="preserve">
          <source>Operators are also represented as such tuples:</source>
          <target state="translated">연산자는 다음과 같은 튜플로도 나타납니다.</target>
        </trans-unit>
        <trans-unit id="15dcbf2455ba217cc0f09140af8c2a19b7a3afae" translate="yes" xml:space="preserve">
          <source>Operators are treated as non-qualified calls:</source>
          <target state="translated">교환 원은 비 규격 통화로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5600ebb83847e5cb5c012f92e0a86888c5caba" translate="yes" xml:space="preserve">
          <source>Opposite of &lt;a href=&quot;#zip/2&quot;&gt;&lt;code&gt;zip/2&lt;/code&gt;&lt;/a&gt;. Extracts two-element tuples from the given &lt;code&gt;enumerable&lt;/code&gt; and groups them together.</source>
          <target state="translated">&lt;a href=&quot;#zip/2&quot;&gt; &lt;code&gt;zip/2&lt;/code&gt; 의&lt;/a&gt; 반대 . 주어진 &lt;code&gt;enumerable&lt;/code&gt; 에서 두 요소 튜플을 추출 하여 함께 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="c4b9a19c8a84c9a632d32f40f93da320901bb185" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;#log/3&quot;&gt;&lt;code&gt;log/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and friends, the arguments given to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; are always evaluated. However, you can pass anonymous functions to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; and they will only be evaluated if there is something to be logged.</source>
          <target state="translated">반대하는 &lt;a href=&quot;#log/3&quot;&gt; &lt;code&gt;log/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; , 친구, 주어진 인수 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt; 항상 평가된다. 그러나 익명 함수를 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; 에&lt;/a&gt; 전달할 수 있으며 로깅 할 항목이있는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea31b9298bd98dc4502fbe718b66df80ca6668b5" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 반대로 작업의 기본값은 &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt; 입니다. 즉, 작업이 충돌하더라도 작업이 다시 시작되지 않습니다. 성공적이지 않은 종료에 대해 태스크를 다시 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="30b26a276b20cf62a74d08b15c4bd86b1da666ec" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">반대 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; , 작업은 기본을 가지고 &lt;code&gt;:restart&lt;/code&gt; 의 &lt;code&gt;:temporary&lt;/code&gt; . 이것은 작업이 충돌하더라도 다시 시작되지 않음을 의미합니다. 성공적이지 않은 종료에 대해 작업을 다시 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9edd3623396f77bd089667c715207bed5bf71fe2" translate="yes" xml:space="preserve">
          <source>Opposite to compile, dependencies are not attempted to be automatically solved between files.</source>
          <target state="translated">컴파일과는 반대로, 파일 간 종속성을 자동으로 해결하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="193e97763df56d56d3233c109f6911eac927d080" translate="yes" xml:space="preserve">
          <source>Opposite to tuples, lists also allow matching on non-empty lists by using the &lt;code&gt;[head | tail]&lt;/code&gt; notation, which matches on the &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; of a list:</source>
          <target state="translated">튜플과 반대로, 목록은 &lt;code&gt;[head | tail]&lt;/code&gt; 표기법, 목록 의 &lt;code&gt;head&lt;/code&gt; 과 &lt;code&gt;tail&lt;/code&gt; 에서 일치 :</target>
        </trans-unit>
        <trans-unit id="e639bcdcf91aa8ac42e5d8553bb30970a11ad173" translate="yes" xml:space="preserve">
          <source>Option values used by &lt;code&gt;start_link&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 에서 사용하는 옵션 값</target>
        </trans-unit>
        <trans-unit id="e4c508aa8815a1256a35a88886de2b38e1af4a2a" translate="yes" xml:space="preserve">
          <source>Option values used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수가 사용하는 옵션 값</target>
        </trans-unit>
        <trans-unit id="9c404768d955448d9b6f90547eff35b8e6696cf8" translate="yes" xml:space="preserve">
          <source>OptionParser</source>
          <target state="translated">OptionParser</target>
        </trans-unit>
        <trans-unit id="e0257ae00caf99998e2d72ed84d9c0a4e5e38be0" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError</source>
          <target state="translated">OptionParser.ParseError</target>
        </trans-unit>
        <trans-unit id="418ba9c55c2dcefb7a2a957a84d702de99023f76" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">OptionParser.ParseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="515bcb488bbc0e14192e6cad5140e9aea8b7fd33" translate="yes" xml:space="preserve">
          <source>Optional callbacks</source>
          <target state="translated">선택적 콜백</target>
        </trans-unit>
        <trans-unit id="113505cb0d224659da22493acb19fb684482f1d3" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 콜백은 콜백 모듈이 원할 경우 구현할 수 있지만 필수 사항은 아닌 콜백입니다. 일반적으로 동작 모듈은 구성을 기반으로 해당 콜백을 호출해야하는지 또는 콜백이 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt; 로 정의되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ac614b09920ca40871efbb0a82438a90f0dbe49b" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 콜백은 필요한 경우 콜백 모듈이 구현할 수있는 콜백입니다. 일반적으로 동작 모듈은 구성에 따라 콜백을 호출해야하는지 또는 콜백이 &lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt; 로 정의되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7e5f711e91c3eb5ab6694cb992141e2b1d0f09" translate="yes" xml:space="preserve">
          <source>Optional callbacks can be defined through the &lt;code&gt;@optional_callbacks&lt;/code&gt; module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example:</source>
          <target state="translated">선택적 콜백은 &lt;code&gt;@optional_callbacks&lt;/code&gt; 모듈 속성을 통해 정의 할 수 있습니다.이 속성은 함수 또는 매크로 이름이 키이고 arity가 값인 키워드 목록이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6499468fb5a027c6923e49d62405caa882b21c9" translate="yes" xml:space="preserve">
          <source>Optional parentheses</source>
          <target state="translated">선택적 괄호</target>
        </trans-unit>
        <trans-unit id="f2868f090f8a4f2b92c94adec1efa9d97208896a" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, and so forth. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">선택적으로보다 정확한 일치를 위해 보호 조건 목록을 전달할 수 있습니다. 각 가드는 패턴의 지정된 부분에 의해 전달되어야하는 검사를 설명하는 튜플입니다. 예를 들어 &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 보호 조건은 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 튜플로 표현됩니다. 가드 조건은 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 등과 같이 할당 된 변수에 대해서만 작동 합니다. 특수 일치 변수 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; 는 예상대로 작동하지 않을 수 있으므로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1d0891bf09a71f28636a589d4b0d02b002898904" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">선택적으로보다 정확한 일치를 위해 보호 조건 목록을 전달할 수 있습니다. 각 가드는 튜플이며 지정된 패턴 부분이 통과해야하는 검사를 설명합니다. 예를 들어 &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 가드 조건은 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 튜플로 표현됩니다. 보호 조건은 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 등의 지정된 변수에 대해서만 작동합니다 . 특수 일치 변수 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; 는 예상대로 작동하지 않을 수 있으므로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="cf952a9fe5b6f3faba42bc98e0ad5176e7e0c07e" translate="yes" xml:space="preserve">
          <source>Options can also be given:</source>
          <target state="translated">옵션도 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a09f1485253101de1cd882c67ecfea3b7b67e2b" translate="yes" xml:space="preserve">
          <source>Options can be:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f27e7e03a3ca6748e6baeb02a0f8a56e6603e040" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 에&lt;/a&gt; 제공된 옵션</target>
        </trans-unit>
        <trans-unit id="efaa2b27718160760d18ba74e06c5819b7a4ab29" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 에&lt;/a&gt; 제공된 옵션</target>
        </trans-unit>
        <trans-unit id="5eae55a87aa27e83c0b98f403b07f3b4076428b4" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; 에&lt;/a&gt; 제공된 옵션</target>
        </trans-unit>
        <trans-unit id="058eb4cd0ba0f3ab247b93a59c7b6bffee0a4161" translate="yes" xml:space="preserve">
          <source>Options used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 기능에 사용되는 옵션</target>
        </trans-unit>
        <trans-unit id="6a54fa3d94cab5b1a4217c700bb98f7a74c5eeec" translate="yes" xml:space="preserve">
          <source>Options used for &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">사용 옵션 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f3f8106feac737e0576442e94ddc74fd873217" translate="yes" xml:space="preserve">
          <source>Or also on pattern matching to extract values out:</source>
          <target state="translated">또는 패턴 일치에서 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="110400c4fdb0f6e57b930554b0298f99e6f6579b" translate="yes" xml:space="preserve">
          <source>Or also via pattern matching:</source>
          <target state="translated">또는 패턴 일치를 통해 :</target>
        </trans-unit>
        <trans-unit id="2b8a5d79778b4d39ad8915654992a0b6572ea485" translate="yes" xml:space="preserve">
          <source>Or as a part of function definitions to pattern match:</source>
          <target state="translated">또는 패턴 일치를위한 함수 정의의 일부로 :</target>
        </trans-unit>
        <trans-unit id="81b6497bf8a349effd8966b9cdac67662ea19529" translate="yes" xml:space="preserve">
          <source>Or even use the async/await pattern:</source>
          <target state="translated">또는 async / await 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cbf79603a9a0d1cebbf945b6fa826e23c8db59d3" translate="yes" xml:space="preserve">
          <source>Or if you want to read a custom path inside the release:</source>
          <target state="translated">또는 릴리스 내에서 사용자 지정 경로를 읽으려는 경우 :</target>
        </trans-unit>
        <trans-unit id="379f3dfc84af41e8ced43be0f50303277e4d6e2f" translate="yes" xml:space="preserve">
          <source>Or in umbrellas:</source>
          <target state="translated">또는 우산 :</target>
        </trans-unit>
        <trans-unit id="df3698d69c7b1187df56c2f297fdade2ea595981" translate="yes" xml:space="preserve">
          <source>Or on Windows:</source>
          <target state="translated">또는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="c55b30b404c72029dc39b6c0373f88b3c2117b45" translate="yes" xml:space="preserve">
          <source>Or perhaps you want to make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">또는 &lt;code&gt;KVServer&lt;/code&gt; 포트를 구성 가능 하게하고 포트 값은 런타임에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c1ba6ffcae31c642695b4056ca652b985d821d" translate="yes" xml:space="preserve">
          <source>Or simply use pattern matching:</source>
          <target state="translated">또는 단순히 패턴 일치를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e2e0dde765341b0ca22014d3a7b90bc8ecdc978" translate="yes" xml:space="preserve">
          <source>Or to import all functions, you could write:</source>
          <target state="translated">또는 모든 기능을 가져 오려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f4e1686a5722761b70122d53c4e0b6fffa922b0" translate="yes" xml:space="preserve">
          <source>Or to import files from children in umbrella projects:</source>
          <target state="translated">또는 우산 프로젝트의 하위 파일을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="f146bf6e3a2ae8c150e0ba215da5069807c64480" translate="yes" xml:space="preserve">
          <source>Or to set a breakpoint that will stop 10 times:</source>
          <target state="translated">또는 10 번 중단되는 중단 점을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3d348d5449f71e35f5ea0982362377c8a421346b" translate="yes" xml:space="preserve">
          <source>Or to trigger it whenever the second argument is a map with more than one element:</source>
          <target state="translated">또는 두 번째 인수가 둘 이상의 요소가있는 맵일 때마다 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="e6af120ddb5b0c93752c9382e27cf7b178db5d6d" translate="yes" xml:space="preserve">
          <source>Or use &lt;code&gt;:asc&lt;/code&gt; and &lt;code&gt;:desc&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;:asc&lt;/code&gt; 및 &lt;code&gt;:desc&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="8b5320509e4f05f8ea43bb4f458da443d14575a8" translate="yes" xml:space="preserve">
          <source>Or, even better:</source>
          <target state="translated">또는 더 나은 :</target>
        </trans-unit>
        <trans-unit id="7346db833d750efbcd6fcd51d602e24a6966464d" translate="yes" xml:space="preserve">
          <source>Or, using the capture syntax:</source>
          <target state="translated">또는 캡처 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="c45740924e5d354064b64521e5aaf12582061570" translate="yes" xml:space="preserve">
          <source>Other agent actions</source>
          <target state="translated">다른 에이전트 작업</target>
        </trans-unit>
        <trans-unit id="cd6ecf7baf7f186954c254a45288721bbe3e452f" translate="yes" xml:space="preserve">
          <source>Other caveats are the impossibility to call count trace BIFs, since breakpoints can only be set on BEAM code; functions calls performed by &lt;code&gt;:cprof&lt;/code&gt; are not traced; the maximum size of a call counter is equal to the host machine's word size (for example, 2147483647 in a 32-bit host).</source>
          <target state="translated">BEAM 코드에서만 중단 점을 설정할 수 있으므로 카운트 트레이스 BIF를 호출 할 수없는 경우도 있습니다. &lt;code&gt;:cprof&lt;/code&gt; 에 의해 수행 된 함수 호출 은 추적되지 않습니다. 콜 카운터의 최대 크기는 호스트 컴퓨터의 워드 크기와 같습니다 (예 : 32 비트 호스트의 2147483647).</target>
        </trans-unit>
        <trans-unit id="dbe1399abe277751b991272fda96ac3cb3827543" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &lt;code&gt;&quot;a&quot;&lt;/code&gt; will not match &lt;code&gt;&quot;A&quot;&lt;/code&gt;.</source>
          <target state="translated">다른 문자는 자신을 나타냅니다. 같은 위치에 정확히 같은 문자가있는 경로 만 일치합니다. 일치는 대소 문자를 구분합니다. &lt;code&gt;&quot;a&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ce1008fe24127bd6a35c9e94fa13e898855bf85" translate="yes" xml:space="preserve">
          <source>Other constructs are &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;try/rescue/catch/else&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;kernel#match?/2&quot;&gt;&lt;code&gt;match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 구조는 &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;try/rescue/catch/else&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;kernel#match?/2&quot;&gt; &lt;code&gt;match?/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32b26031f2d4ec505f1490c8e029cbbddc736c20" translate="yes" xml:space="preserve">
          <source>Other errors can be raised with &lt;code&gt;raise/2&lt;/code&gt; passing the error name and a list of keyword arguments:</source>
          <target state="translated">오류 이름과 키워드 인수 목록을 전달하는 &lt;code&gt;raise/2&lt;/code&gt; 를 사용하면 다른 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6f1d0ed197e63f74804e7083d76174b0a502dfb" translate="yes" xml:space="preserve">
          <source>Other options include:</source>
          <target state="translated">기타 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd317e6d04c14a2ed23576c03ddc173b8001094a" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configure as default either via configuration:</source>
          <target state="translated">다른 표준 시간대 데이터베이스 (패키지에서 제공하는 데이터베이스 포함)는 구성을 통해 기본값으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede73ee447530b341b516cdc557113ccf7679079" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configured as default either via configuration:</source>
          <target state="translated">다른 시간대 데이터베이스 (패키지에서 제공하는 데이터베이스 포함)는 구성을 통해 기본값으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103386501b54ba75aa5753f09965431aa8e69dfa" translate="yes" xml:space="preserve">
          <source>Other time zone databases can also be configured. For example, two of the available options are:</source>
          <target state="translated">다른 시간대 데이터베이스도 구성 할 수 있습니다. 예를 들어 사용 가능한 두 가지 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cad5a00eec7472c9a3591c446721f3e6c58c845" translate="yes" xml:space="preserve">
          <source>Other tools and community</source>
          <target state="translated">다른 도구와 커뮤니티</target>
        </trans-unit>
        <trans-unit id="d9b0ed607a935499601e4fd42e28be80554ff28b" translate="yes" xml:space="preserve">
          <source>Otherwise it should return &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; and a default algorithm built on top of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; that runs in linear time will be used.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; 반환해야 하며 선형 시간으로 실행되는 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 위에 구축 된 기본 알고리즘 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c81b36166b2eaba733a51d04e61d3fe880c8923" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;nil&lt;/code&gt; in case the module exists, but it isn't a task or cannot be found.</source>
          <target state="translated">그렇지 않으면 모듈이 존재하지만 작업이 아니거나 찾을 수없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aa826b74ad8c081871b116d8c34cb3e95cd21b98" translate="yes" xml:space="preserve">
          <source>Otherwise the message is sent and &lt;code&gt;:ok&lt;/code&gt; is returned.</source>
          <target state="translated">그렇지 않으면 메시지가 전송되고 &lt;code&gt;:ok&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e1247b12cce6e0be8066f8c9a379932aa1ec5d1" translate="yes" xml:space="preserve">
          <source>Otherwise we get an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when construcing the binary:</source>
          <target state="translated">그렇지 않으면 바이너리를 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 할 때 ArgumentError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9cafb8b841614ef77e86d7299d3dbf34c38a0e86" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;KV.Registry&lt;/code&gt; process received a cast with &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; and a call with &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt;, in this sequence. &lt;code&gt;GenServer.cast&lt;/code&gt; will immediately return, as soon as the message is sent to the &lt;code&gt;registry&lt;/code&gt;. The &lt;code&gt;GenServer.call&lt;/code&gt; on the other hand, is where we would be waiting for an answer, provided by the above &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; callback.</source>
          <target state="translated">우리 &lt;code&gt;KV.Registry&lt;/code&gt; 의 과정과 주조받은 &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; 와 가진 전화 &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt; 이 순서를. 메시지가 &lt;code&gt;registry&lt;/code&gt; 전송 되 자마자 &lt;code&gt;GenServer.cast&lt;/code&gt; 가 즉시 리턴됩니다 . 반면 &lt;code&gt;GenServer.call&lt;/code&gt; 은 위의 &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; 콜백 에서 제공하는 답변을 기다리는 곳 입니다.</target>
        </trans-unit>
        <trans-unit id="32cb7dd97d5b5169235f629b257bf4b1bebebde0" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;kv&lt;/code&gt; application is complete, so it&amp;rsquo;s time to implement the server that will handle the requests we defined in the first chapter:</source>
          <target state="translated">우리의 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램이 완료되면, 우리는 첫 번째 챕터에 정의 된 요청을 처리 할 서버를 구현하는 그것의 시간이 너무 :</target>
        </trans-unit>
        <trans-unit id="fae76d2c8957b5d3f77fc1cdf6ba676bd9429aa5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;macro_unless&lt;/code&gt; macro received the following:</source>
          <target state="translated">우리 &lt;code&gt;macro_unless&lt;/code&gt; 매크로는 다음을 받았다 :</target>
        </trans-unit>
        <trans-unit id="d411cc3e34a79409af812e8a3926471d9c1101c5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;mix.exs&lt;/code&gt; defines two public functions: &lt;code&gt;project&lt;/code&gt;, which returns project configuration like the project name and version, and &lt;code&gt;application&lt;/code&gt;, which is used to generate an application file.</source>
          <target state="translated">우리 &lt;code&gt;mix.exs&lt;/code&gt; 는 두 개의 공공 기능 정의 &lt;code&gt;project&lt;/code&gt; , 반환 프로젝트 이름 및 버전과 같은 구성 프로젝트 &lt;code&gt;application&lt;/code&gt; 응용 프로그램 파일을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4263c0c28d87ce16526214a430448dce9d929e50" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;msg&lt;/code&gt; is printed and &lt;code&gt;print_multiple_times/2&lt;/code&gt; is called again, this time with the second argument set to &lt;code&gt;1&lt;/code&gt;. Because &lt;code&gt;n&lt;/code&gt; is now set to &lt;code&gt;1&lt;/code&gt;, the guard in our first definition of &lt;code&gt;print_multiple_times/2&lt;/code&gt; evaluates to true, and we execute this particular definition. The &lt;code&gt;msg&lt;/code&gt; is printed, and there is nothing left to execute.</source>
          <target state="translated">우리의 &lt;code&gt;msg&lt;/code&gt; 가 인쇄되고 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 가 다시 호출됩니다. 이번에는 두 번째 인수가 &lt;code&gt;1&lt;/code&gt; 로 설정되었습니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 로 설정 되었으므로 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 의 첫 번째 정의에서 가드 가 true로 평가 되고이 특정 정의를 실행합니다. &lt;code&gt;msg&lt;/code&gt; 인쇄 및 실행 왼쪽 아무것도 없다.</target>
        </trans-unit>
        <trans-unit id="ade0f4f0153f3ee46feb17f06f5a697e3ea8100e" translate="yes" xml:space="preserve">
          <source>Our database engine used by &lt;code&gt;:my_app&lt;/code&gt; needs to know what databases exist, and what the database configurations are. The database engine can make a call to &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; and so forth to retrieve the configuration of each one.</source>
          <target state="translated">&lt;code&gt;:my_app&lt;/code&gt; 에서 사용하는 데이터베이스 엔진 은 어떤 데이터베이스가 존재하고 어떤 데이터베이스 구성이 있는지 알아야합니다. 데이터베이스 엔진은 &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; 를 호출하여 데이터베이스 목록 (모듈 이름으로 지정 ) 을 검색 할 수 있습니다. 데이터베이스 엔진은 목록의 각 리포지토리를 탐색 한 다음 &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; 등 을 호출 하여 각 구성을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f6d0c933af7daca11ac7f7ad70a0c3c2249028" translate="yes" xml:space="preserve">
          <source>Our first distributed code</source>
          <target state="translated">첫 배포 코드</target>
        </trans-unit>
        <trans-unit id="9e84809a7c397a309ce96164f5cacbbeaf21e474" translate="yes" xml:space="preserve">
          <source>Our first distributed task retrieves the name of the node the task is running on. Notice we have given an anonymous function to &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; but, in distributed cases, it is preferable to give the module, function, and arguments explicitly:</source>
          <target state="translated">첫 번째 분산 작업은 작업이 실행되는 노드의 이름을 검색합니다. &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 에 익명 함수를 제공 했지만 분산 된 경우 모듈, 함수 및 인수를 명시 적으로 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87ced78c461b132d154e8f4cf702fd7438182b7f" translate="yes" xml:space="preserve">
          <source>Our first macro</source>
          <target state="translated">첫 번째 매크로</target>
        </trans-unit>
        <trans-unit id="a44749c5086277b1e9b2d47d74121d2d8219a432" translate="yes" xml:space="preserve">
          <source>Our first project</source>
          <target state="translated">첫 프로젝트</target>
        </trans-unit>
        <trans-unit id="b27267683384fbe26b34a46fe89e40b87ffb846e" translate="yes" xml:space="preserve">
          <source>Our first supervisor</source>
          <target state="translated">우리의 첫 감독자</target>
        </trans-unit>
        <trans-unit id="08203c924a4f2f9eb683fc56d049d3e81c8b3b3e" translate="yes" xml:space="preserve">
          <source>Our first test starts a new &lt;code&gt;KV.Bucket&lt;/code&gt; by calling the &lt;code&gt;start_link/1&lt;/code&gt; and passing an empty list of options. Then we perform some &lt;code&gt;get/2&lt;/code&gt; and &lt;code&gt;put/3&lt;/code&gt; operations on it, asserting the result.</source>
          <target state="translated">첫 번째 테스트는 &lt;code&gt;KV.Bucket&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 을 호출하고 빈 옵션 목록을 전달하여 새로운 KV.Bucket 을 시작합니다 . 그런 다음 &lt;code&gt;get/2&lt;/code&gt; 및 &lt;code&gt;put/3&lt;/code&gt; 작업을 수행하여 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="219a6c3d5bbb168da4e01962d5ac3a3beba4fafe" translate="yes" xml:space="preserve">
          <source>Our implementation splits the line on whitespace and then matches the command against a list. Using &lt;code&gt;String.split/1&lt;/code&gt; means our commands will be whitespace-insensitive. Leading and trailing whitespace won&amp;rsquo;t matter, nor will consecutive spaces between words. Let&amp;rsquo;s add some new doctests to test this behaviour along with the other commands:</source>
          <target state="translated">우리의 구현은 행을 공백으로 나누고 명령을 목록과 일치시킵니다. &lt;code&gt;String.split/1&lt;/code&gt; 을 사용하면 명령이 공백에 영향을받지 않습니다. 선행 및 후행 공백은 중요하지 않으며 단어 사이의 연속 공백도 아닙니다. 다른 명령과 함께이 동작을 테스트하기 위해 몇 가지 새로운 doctest를 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4bada33605b3d0085e74cd5e28e1db60fae2e0fd" translate="yes" xml:space="preserve">
          <source>Our integration test checks all server interaction, including unknown commands and not found errors. It is worth noting that, as with</source>
          <target state="translated">통합 테스트는 알 수없는 명령 및 찾을 수없는 오류를 포함하여 모든 서버 상호 작용을 확인합니다. 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="34a1175408d05bc3f9db3276c1dc05ef2699c1bd" translate="yes" xml:space="preserve">
          <source>Our integration test will use a TCP client that sends commands to our server and assert we are getting the desired responses.</source>
          <target state="translated">우리의 통합 테스트는 서버에 명령을 보내고 원하는 응답을받는다고 주장하는 TCP 클라이언트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95fe1b352417a55c924d64b21f5c78849cba47c1" translate="yes" xml:space="preserve">
          <source>Our requirements are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">우리의 요구 사항은 다음과 같습니다 ( &lt;code&gt;elixir -v&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="535edfb81d4d7fba2950c82c04bae85d9dfbc680" translate="yes" xml:space="preserve">
          <source>Our server functionality is almost complete. Only tests are missing. This time, we have left tests for last because there are some important considerations to be made.</source>
          <target state="translated">우리의 서버 기능은 거의 완성되었습니다. 테스트 만 누락되었습니다. 이번에는 몇 가지 중요한 고려 사항이 있기 때문에 마지막 테스트를 남겼습니다.</target>
        </trans-unit>
        <trans-unit id="0dd5b4064e68f8312097cf4592e8701596b6f591" translate="yes" xml:space="preserve">
          <source>Our supervisor has a single child so far: &lt;code&gt;KV.Registry&lt;/code&gt;. After we define a list of children, we call &lt;code&gt;Supervisor.init/2&lt;/code&gt;, passing the children and the supervision strategy.</source>
          <target state="translated">&lt;code&gt;KV.Registry&lt;/code&gt; 의 관리자는 지금까지 한 명의 자녀를 두고 있습니다. 하위 목록을 정의한 후 &lt;code&gt;Supervisor.init/2&lt;/code&gt; 를 호출 하여 하위 및 감독 전략을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="26dc3ca3dc381ac59a2d936b2680d93266f92db5" translate="yes" xml:space="preserve">
          <source>Our test case first asserts there&amp;rsquo;s no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.</source>
          <target state="translated">테스트 사례는 먼저 레지스트리에 버킷이 없다고 주장하고 명명 된 버킷을 생성 한 후 찾아보고 버킷으로 동작한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="e4223734c95ebae3d84c8793615e9933ad56a2e5" translate="yes" xml:space="preserve">
          <source>Our test uses the &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; function to retrieve the child specification out of a module and then assert its restart value is &lt;code&gt;:temporary&lt;/code&gt;. At this point, you may be wondering why use a supervisor if it never restarts its children. It happens that supervisors provide more than restarts, they are also responsible for guaranteeing proper startup and shutdown, especially in case of crashes in a supervision tree.</source>
          <target state="translated">테스트에서는 &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 함수를 사용하여 모듈에서 하위 사양을 검색 한 다음 재시작 값을 &lt;code&gt;:temporary&lt;/code&gt; 로 지정 합니다. 이 시점에서 관리자가 자식을 다시 시작하지 않으면 왜 관리자를 사용하는지 궁금 할 것입니다. 수퍼바이저는 다시 시작 이상을 제공하며 특히 감독 트리에서 충돌이 발생하는 경우 적절한 시작 및 종료를 보장 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="281569899b0bc371294904a4302b498cefdffdc9" translate="yes" xml:space="preserve">
          <source>Our tests should now (always) pass!</source>
          <target state="translated">우리의 테스트는 이제 (항상) 통과해야합니다!</target>
        </trans-unit>
        <trans-unit id="dd930034e08621d48c502a8e5b49b585b03bd10c" translate="yes" xml:space="preserve">
          <source>Our tour of our bitstrings, binaries, and strings is nearly complete, but we have one more data type to explain: the charlist.</source>
          <target state="translated">비트 문자열, 바이너리, 문자열에 대한 둘러보기가 거의 완료되었지만 설명 할 데이터 유형이 하나 더 있습니다. 바로 charlist입니다.</target>
        </trans-unit>
        <trans-unit id="9355be26c14e0bdd29f4d7a6d45fdd30c549218b" translate="yes" xml:space="preserve">
          <source>Outdated functions for building child specifications.</source>
          <target state="translated">하위 스펙을 빌드하기위한 오래된 기능.</target>
        </trans-unit>
        <trans-unit id="5df6c70d9444e37439ecf0bf6ba4e2daf5ce369f" translate="yes" xml:space="preserve">
          <source>Over the course of this section, we will explore many Elixir syntax constructs alongside their AST representations.</source>
          <target state="translated">이 섹션을 통해 AST 표현과 함께 많은 Elixir 구문 구조를 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="68809f406eda501cceb8a0a76b54d32562163e04" translate="yes" xml:space="preserve">
          <source>Over the next section, we will explore many of Elixir syntax constructs alongside their AST representation.</source>
          <target state="translated">다음 섹션에서는 AST 표현과 함께 많은 Elixir 구문 구성을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="746205fc2b470e87484b958a27628c930425ad5e" translate="yes" xml:space="preserve">
          <source>Overall, the child specification can be one of the following:</source>
          <target state="translated">전체적으로 하위 스펙은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13623c607be82141b2d26706e3445ad9261b3cc0" translate="yes" xml:space="preserve">
          <source>Overall, there are many steps, complexities and assumptions made during hot code upgrades, which is ultimately why they are not provided by Elixir out of the box. However, hot code upgrades can still be achieved by teams who desire to implement those steps on top of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; in their projects or as separate libraries.</source>
          <target state="translated">전반적으로 핫 코드 업그레이드 중에는 많은 단계, 복잡성 및 가정이 있으며, 이것이 궁극적으로 Elixir에서 즉시 제공되지 않는 이유입니다. 그러나 핫 코드 업그레이드는 프로젝트 의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 위에 이러한 단계를 구현 하거나 별도의 라이브러리 로 구현하려는 팀이 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f888d222b77006610001ff65a62036e76c8b9f" translate="yes" xml:space="preserve">
          <source>Overlays</source>
          <target state="translated">Overlays</target>
        </trans-unit>
        <trans-unit id="c2d12ad6c158fff98834c1728a418fadd8e620d7" translate="yes" xml:space="preserve">
          <source>Overlined.</source>
          <target state="translated">Overlined.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="4678bc356cc17efccf9b8f5a4945bc7564b32a23" translate="yes" xml:space="preserve">
          <source>Parens and no parens in function calls</source>
          <target state="translated">함수 호출에서 Parens 및 Parens 없음</target>
        </trans-unit>
        <trans-unit id="3e3d2061650e6bfafddfcb21f5627e4ae2f724ca" translate="yes" xml:space="preserve">
          <source>Parentheses are important to support multiple expressions. This:</source>
          <target state="translated">괄호는 여러 식을 지원하는 데 중요합니다. 이:</target>
        </trans-unit>
        <trans-unit id="67051571e99ef0293cfd4d98dce041f6d2d0079b" translate="yes" xml:space="preserve">
          <source>Parentheses for non-qualified calls are optional, except for zero-arity calls, which would then be ambiguous with variables. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;. For example, &lt;code&gt;add (1, 2)&lt;/code&gt; is a syntax error, since &lt;code&gt;(1, 2)&lt;/code&gt; is treated as an invalid block which is attempted to be given as a single argument to &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">비 호환 통화의 경우 괄호는 선택 사항이지만 제로 애널 통화는 변수가 모호합니다. 괄호를 사용하는 경우 &lt;em&gt;공백없이&lt;/em&gt; 함수 이름 바로 뒤에 와야합니다 . 예를 들어, &lt;code&gt;add (1, 2)&lt;/code&gt; 는 구문 오류입니다. &lt;code&gt;(1, 2)&lt;/code&gt; 는 &lt;code&gt;add&lt;/code&gt; 에 대한 단일 인수로 제공되는 잘못된 블록으로 취급되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="eaccd27612cf8e4c36fdcb2e213e4f30e8b614a2" translate="yes" xml:space="preserve">
          <source>Parentheses for qualified calls are optional. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;.</source>
          <target state="translated">적격 통화의 괄호는 선택 사항입니다. 괄호를 사용하는 경우 &lt;em&gt;공백없이&lt;/em&gt; 함수 이름 바로 뒤에 와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5051b701bae8cfb193958fe123047596e7c8c957" translate="yes" xml:space="preserve">
          <source>Parenthesised arguments after the anonymous function indicate that we want the function to be evaluated, not just its definition returned. Note that a dot (&lt;code&gt;.&lt;/code&gt;) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling the anonymous function matched to a variable &lt;code&gt;add&lt;/code&gt; and a named function &lt;code&gt;add/2&lt;/code&gt;. We will explore named functions when dealing with &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions&lt;/a&gt;, since named functions can only be defined within a module. For now, just remember that Elixir makes a clear distinction between anonymous functions and named functions.</source>
          <target state="translated">익명 함수 뒤의 괄호로 묶은 인수는 함수의 정의뿐만 아니라 함수가 평가되기를 원한다는 것을 나타냅니다. 익명 함수를 호출하려면 변수와 괄호 사이에 점 ( &lt;code&gt;.&lt;/code&gt; )이 필요합니다. 이 점은 변수 &lt;code&gt;add&lt;/code&gt; 와 일치하는 익명 함수와 명명 된 함수 &lt;code&gt;add/2&lt;/code&gt; 를 호출하는 것 사이에 모호함이 없도록합니다 . 명명 된 함수 는 모듈 내에서만 정의 할 수 있으므로 &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions를&lt;/a&gt; 처리 할 때 명명 된 함수를 살펴볼 것 입니다. 지금은 Elixir가 익명 함수와 명명 된 함수를 명확하게 구분하고 있음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e0c54097c1addd54979adc1a31105e2aaa679a" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;argv&lt;/code&gt; into a keyword list.</source>
          <target state="translated">&lt;code&gt;argv&lt;/code&gt; 를 키워드 목록으로 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="b2037b766a0218a36e31bca7df8250924234fc50" translate="yes" xml:space="preserve">
          <source>Parses a UTC datetime string.</source>
          <target state="translated">UTC datetime 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7a373d2047627c546c74f485fe9ab21c42c1df91" translate="yes" xml:space="preserve">
          <source>Parses a binary into a float.</source>
          <target state="translated">바이너리를 float로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="4e1561f231d7c4a89caf62da9c6db3000588afc3" translate="yes" xml:space="preserve">
          <source>Parses a date string.</source>
          <target state="translated">날짜 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6802e6f6d63cb578d3a12f5a6a70ff5a85e6ff68" translate="yes" xml:space="preserve">
          <source>Parses a naive datetime string.</source>
          <target state="translated">순진한 날짜 시간 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9e7e6f51d7020e3f9b0b2f42aa838f86dc50638c" translate="yes" xml:space="preserve">
          <source>Parses a text representation of an integer.</source>
          <target state="translated">정수의 텍스트 표현을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="22b615713c9b3099aeebc79b91026e9ad53274f2" translate="yes" xml:space="preserve">
          <source>Parses a time string.</source>
          <target state="translated">시간 문자열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="6b888a6d93a31ed5b9a23109d66831029d658dad" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.Requirement.html&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">버전 요구 사항 문자열을 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.Requirement.html&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt; 구조체 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="1305b49b9db63d6a1fa5dcb852df3de639b5f930" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;version.requirement&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">버전 요구 사항 문자열을 &lt;a href=&quot;version.requirement&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt; 구조체 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9a74770159628fab2a719bf1edd0a31ffec3a" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">버전 문자열을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 구조체 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3857b9469595509888a047a6bc4d80e1165c97" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 문자열을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 으로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="9418b6ddc34fc34c1a8273ea4a0f4abcb6241047" translate="yes" xml:space="preserve">
          <source>Parses a well-formed URI reference into its components.</source>
          <target state="translated">올바른 형식의 URI 참조를 해당 구성 요소로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="686ba7b9fd41ec3d8f6bc66004e216b5e44cf683" translate="yes" xml:space="preserve">
          <source>Parses filters out of a path.</source>
          <target state="translated">경로에서 필터를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="79bbadda560fc2696985637c3dcd5d5d75b852e1" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Date and time of day&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;날짜 및 시간&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="dea4a820a2ed56415d65f399d0de1e2f38a6464c" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Dates&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;날짜&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="0c980fd66c48ae19c95734093b045d1485842675" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Local time&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;현지 시간&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="efff6c3f2bc39a4e56110039d1eb0a786e002449" translate="yes" xml:space="preserve">
          <source>Parses the given filters, as one would receive from the command line.</source>
          <target state="translated">명령 줄에서받는 것처럼 주어진 필터를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="892eaf14a29daaf63957591cf27bb62e4caabbd0" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a date returned by &lt;a href=&quot;#c:date_to_string/3&quot;&gt;&lt;code&gt;date_to_string/3&lt;/code&gt;&lt;/a&gt; into a date-tuple.</source>
          <target state="translated">&lt;a href=&quot;#c:date_to_string/3&quot;&gt; &lt;code&gt;date_to_string/3&lt;/code&gt; 에서&lt;/a&gt; 반환 된 날짜의 문자열 표현을 date-tuple로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="4b4e3c1faebbc8667d93f77a51121878e06bc6a9" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a datetime returned by &lt;a href=&quot;#c:datetime_to_string/11&quot;&gt;&lt;code&gt;datetime_to_string/11&lt;/code&gt;&lt;/a&gt; into a datetime-tuple.</source>
          <target state="translated">&lt;a href=&quot;#c:datetime_to_string/11&quot;&gt; &lt;code&gt;datetime_to_string/11&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 datetime에 대한 문자열 표현을 datetime-tuple로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="4fab8e44f873693695decedf8d84e5501e79169f" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a naive datetime returned by &lt;a href=&quot;#c:naive_datetime_to_string/7&quot;&gt;&lt;code&gt;naive_datetime_to_string/7&lt;/code&gt;&lt;/a&gt; into a naive-datetime-tuple.</source>
          <target state="translated">&lt;a href=&quot;#c:naive_datetime_to_string/7&quot;&gt; &lt;code&gt;naive_datetime_to_string/7&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 순진한 날짜 시간에 대한 문자열 표현을 순진한 날짜 시간-튜플로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="001eefa6a8d8771c20892e67001091ddcc53e435" translate="yes" xml:space="preserve">
          <source>Parses the string representation for a time returned by &lt;a href=&quot;#c:time_to_string/4&quot;&gt;&lt;code&gt;time_to_string/4&lt;/code&gt;&lt;/a&gt; into a time-tuple.</source>
          <target state="translated">&lt;a href=&quot;#c:time_to_string/4&quot;&gt; &lt;code&gt;time_to_string/4&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 시간에 대한 문자열 표현을 time-tuple로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="4a7afa8fbef89e323ac662c4af9fe0a43a7660ee" translate="yes" xml:space="preserve">
          <source>Parsing unknown switches</source>
          <target state="translated">알 수없는 스위치 구문 분석</target>
        </trans-unit>
        <trans-unit id="058a972530d049d8d1939ad7fe7fdd2aa895b37b" translate="yes" xml:space="preserve">
          <source>Passed (also represented by &lt;code&gt;nil&lt;/code&gt;)</source>
          <target state="translated">전달됨 (또한 &lt;code&gt;nil&lt;/code&gt; 로 표시 )</target>
        </trans-unit>
        <trans-unit id="882a18ee47ec2d79a2be50dc7a03c9a397028b1f" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:insert_replaced&lt;/code&gt; 를 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; 에&lt;/a&gt; 전달</target>
        </trans-unit>
        <trans-unit id="6c66f210cd28e106c39212344286cce106c8d0d7" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;string#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">전달 &lt;code&gt;:insert_replaced&lt;/code&gt; 를 &lt;a href=&quot;string#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; 에&lt;/a&gt; 전달</target>
        </trans-unit>
        <trans-unit id="89a8204a98999b2bee00cea4fbc5d899e83daf17" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 전달하면 자동으로 날짜 정보 를 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 으로 변환 되어 표준 시간대 정보가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dcab25bbe23a69b39dd307ea8cbb6e91f311b31b" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 전달하면 자동으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 으로 변환되어 시간대 정보가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3cf5e91c7ff130bc822fb2e1808168e930f058" translate="yes" xml:space="preserve">
          <source>Passing a data type that doesn&amp;rsquo;t implement the protocol raises an error:</source>
          <target state="translated">프로토콜을 구현하지 않는 데이터 유형을 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f791e277d4e887df822880f6ea245d3e768dd518" translate="yes" xml:space="preserve">
          <source>Passing a list of strings as &lt;code&gt;padding&lt;/code&gt; will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string &lt;code&gt;padding&lt;/code&gt; is equivalent to passing the list of graphemes in it. If no &lt;code&gt;padding&lt;/code&gt; is given, it defaults to whitespace.</source>
          <target state="translated">문자열 목록을 &lt;code&gt;padding&lt;/code&gt; 으로 전달하면 누락 된 모든 항목에 대해 목록의 한 요소가 사용됩니다. 목록이 인서트 수보다 짧으면 목록 시작 부분부터 채우기가 다시 시작됩니다. 문자열 &lt;code&gt;padding&lt;/code&gt; 을 전달하는 것은 그 안에 그래프 목록을 전달하는 것과 같습니다. &lt;code&gt;padding&lt;/code&gt; 이 없으면 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="5e3fd8ecb92634cc65268b6d4476c69ed28e51d4" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">비어 있지 않은 목록을 &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; 로 전달&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32def6a06615a71c67376a3230bf64c2a28b2da1" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">비어 있지 않은 목록을 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; 에 전달&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab4dc6f7d4a4079d2fdd62825de517a50ea365e8" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에 비어 있지 않은 목록을 전달 &lt;code&gt;:into&lt;/code&gt; 에 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc442b60927fa3cedca5b49645dcda347c68d43b" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">비어 있지 않은 목록을 &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0e56540195473b76b76bc99aa7381097cd9285" translate="yes" xml:space="preserve">
          <source>Passing a string that does not represent an integer leads to an error:</source>
          <target state="translated">정수를 나타내지 않는 문자열을 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="acb63ddcebf2320404185b69bfeb6451c7f0ec89" translate="yes" xml:space="preserve">
          <source>Passing non-chardata to &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#log/2&quot;&gt;&lt;code&gt;Logger.log/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">비 chardata를 &lt;a href=&quot;https://hexdocs.pm/logger/Logger.html#log/2&quot;&gt; &lt;code&gt;Logger.log/2&lt;/code&gt; 에&lt;/a&gt; 전달</target>
        </trans-unit>
        <trans-unit id="dd3e8286d4953766dd3b3f6ceafaf9431e925e06" translate="yes" xml:space="preserve">
          <source>Pasting multiline expressions into IEx</source>
          <target state="translated">여러 줄로 된 표현식을 IEx에 붙여 넣기</target>
        </trans-unit>
        <trans-unit id="91b58c214080204a7a5e383388a515d0a4b74b02" translate="yes" xml:space="preserve">
          <source>Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise.</source>
          <target state="translated">패치 세그먼트는 영숫자 인 경우 사전 식으로, 그렇지 않으면 숫자로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c0c3abe147a53151f7b15d4fc13e0b6734b3694d" translate="yes" xml:space="preserve">
          <source>Path and in umbrella dependencies are automatically recompiled by the parent project whenever they change. While fetchable dependencies, like the ones using &lt;code&gt;:git&lt;/code&gt;, are recompiled only when fetched/updated.</source>
          <target state="translated">경로 및 우산 내부 종속성은 변경 될 때마다 상위 프로젝트에 의해 자동으로 다시 컴파일됩니다. &lt;code&gt;:git&lt;/code&gt; 를 사용하는 것과 같이 가져올 수있는 종속성은 가져 오거나 업데이트 할 때만 다시 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed7d3defaf72b508bfd8cf537c7e823fe6bd6aa" translate="yes" xml:space="preserve">
          <source>Path options (&lt;code&gt;:path&lt;/code&gt;)</source>
          <target state="translated">경로 옵션 ( &lt;code&gt;:path&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="13e7e11722f7d8309c367ea7823bd6cd32011ced" translate="yes" xml:space="preserve">
          <source>Paths</source>
          <target state="translated">Paths</target>
        </trans-unit>
        <trans-unit id="ab86e3764103c0dcee9253b7a3012684d2a9d25d" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">이 모듈의 함수에 지정된 경로는 현재 작업 디렉토리 ( &lt;a href=&quot;#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; 에서&lt;/a&gt; 반환 됨)에 상대적 이거나 절대 경로 일 수 있습니다. &lt;code&gt;~&lt;/code&gt; 와 같은 셸 규칙 은 자동으로 확장되지 않습니다. 같은 경로를 사용하려면 &lt;code&gt;~/Downloads&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; 는&lt;/a&gt; 절대 경로로 경로를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5e92258ff6b2634e28eb6ffcaf62f5681cd01e9" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;path#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">이 모듈의 함수에 제공된 경로는 현재 작업 디렉토리 ( &lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된)에 상대적인 경로이거나 절대 경로 일 수 있습니다. &lt;code&gt;~&lt;/code&gt; 와 같은 쉘 규칙 은 자동으로 확장되지 않습니다. 같은 경로를 사용하려면 &lt;code&gt;~/Downloads&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;path#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; 는&lt;/a&gt; 절대 경로로 경로를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec64f6b78a78d3e0e77305e0657675859b2e9902" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt;&lt;code&gt;_.._&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#../2&quot;&gt; &lt;code&gt;_.._&lt;/code&gt; &lt;/a&gt; (v1.0)의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="1e99640fa7e7a52ff09113ed1f71e7b10259e02c" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;code&gt;_.._&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;_.._&lt;/code&gt; (v1.0)의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">패턴 매칭</target>
        </trans-unit>
        <trans-unit id="762812440ca2ae94a95f89714b7b124251968b01" translate="yes" xml:space="preserve">
          <source>Pattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.</source>
          <target state="translated">패턴 일치를 통해 개발자는 튜플 및 목록과 같은 데이터 유형을 쉽게 재구성 할 수 있습니다. 다음 장에서 볼 수 있듯이, 이것은 Elixir의 재귀의 기초 중 하나이며 맵 및 이진과 같은 다른 유형에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdff00e56a789a8726c9da949b09dd98bd5ff2f6" translate="yes" xml:space="preserve">
          <source>Pattern matching on struct names</source>
          <target state="translated">구조체 이름의 패턴 매칭</target>
        </trans-unit>
        <trans-unit id="2a4de85389e0a217d14b9f1582fdf6651995191b" translate="yes" xml:space="preserve">
          <source>Pattern matching.</source>
          <target state="translated">패턴 매칭.</target>
        </trans-unit>
        <trans-unit id="d6028e13dbd229af93277e237b2c16fbf94be2cb" translate="yes" xml:space="preserve">
          <source>Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison.</source>
          <target state="translated">패턴은 레지스트리에 저장된 값의 구조와 일치하는 원자 또는 튜플이어야합니다. atom &lt;code&gt;:_&lt;/code&gt; 는 주어진 값이나 튜플 요소를 무시하는 데 사용될 수 있지만 atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 은 패턴의 일부를 변수에 임시로 할당하여 후속 비교를 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5137df8a74cffc5ca199358452463a9c6bfb9074" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/3&quot;&gt;&lt;code&gt;replace/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/2&quot;&gt;&lt;code&gt;split/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#replace/3&quot;&gt; &lt;code&gt;replace/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#split/2&quot;&gt; &lt;code&gt;split/2&lt;/code&gt; &lt;/a&gt; 와 같은 기능에 사용되는 패턴</target>
        </trans-unit>
        <trans-unit id="152c399b42d0887a104c4b86c4c12a82f3f47730" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/4&quot;&gt;&lt;code&gt;replace/4&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/3&quot;&gt;&lt;code&gt;split/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#replace/4&quot;&gt; &lt;code&gt;replace/4&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#split/3&quot;&gt; &lt;code&gt;split/3&lt;/code&gt; &lt;/a&gt; 과 같은 기능에 사용되는 패턴</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="7fb0897a2aed04de147811e0b885403806796d4f" translate="yes" xml:space="preserve">
          <source>Patterns and Guards</source>
          <target state="translated">패턴 및 가드</target>
        </trans-unit>
        <trans-unit id="d8f5c8436b5f5097fc1e0b09aadfb6092ac6af0f" translate="yes" xml:space="preserve">
          <source>Patterns and guards</source>
          <target state="translated">패턴과 가드</target>
        </trans-unit>
        <trans-unit id="baf8b0aa8fb4b54076ac712a4dbf108691e81606" translate="yes" xml:space="preserve">
          <source>Patterns are not bidirectional. If you have a variable &lt;code&gt;y&lt;/code&gt; that was never assigned to (often called an unbound variable) and you write &lt;code&gt;1 = y&lt;/code&gt;, an error will be raised:</source>
          <target state="translated">패턴은 양방향이 아닙니다. 할당되지 않은 변수 &lt;code&gt;y&lt;/code&gt; (종종 언 바운드 변수라고 함)가 있고 &lt;code&gt;1 = y&lt;/code&gt; 를 쓰면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b9d994ed3cc433e46c8856ab6068dddc28124e9" translate="yes" xml:space="preserve">
          <source>Patterns in Elixir are made of variables, literals, and data-structure specific syntax. One of the most used constructs to perform pattern matching is the match operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt;&lt;code&gt;=&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Elixir의 패턴은 변수, 리터럴 및 데이터 구조 별 구문으로 구성됩니다. 패턴 일치를 수행하는 데 가장 많이 사용되는 구문 중 하나는 일치 연산자 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#=/2&quot;&gt; &lt;code&gt;=&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="5c540b06ef6678db51d87771fe4d3939cf8a2687" translate="yes" xml:space="preserve">
          <source>Percent-escapes all characters that require escaping in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 이스케이프해야하는 모든 문자를 퍼센트 이스케이프 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c2d8594907eb7e308e53ec4869ee6591cd32868" translate="yes" xml:space="preserve">
          <source>Percent-unescapes a URI.</source>
          <target state="translated">URI를 이스케이프 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e179944907d404a0c32e7b8b6d4faf26105d3528" translate="yes" xml:space="preserve">
          <source>Performance &amp;amp; Optimizations</source>
          <target state="translated">성능 및 최적화</target>
        </trans-unit>
        <trans-unit id="c275fdf2e3e600505a75a54526cffcdd6b781bbb" translate="yes" xml:space="preserve">
          <source>Performs a cast (&lt;em&gt;fire and forget&lt;/em&gt;) operation on the agent state.</source>
          <target state="translated">에이전트 상태 에서 캐스트 ( &lt;em&gt;fire and forget&lt;/em&gt; ) 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="2dda6078e429a5da67f4d4b2be41fa1f081b1311" translate="yes" xml:space="preserve">
          <source>Performs a depth-first traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 깊이 우선 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4785eea6c091478238fb008cdd410304fdd8d0f0" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 심도 우선, 차수 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="32814ff09b644963df4e222c005f1c731fb50119" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions.</source>
          <target state="translated">따옴표로 묶인 표현식의 심도 우선, 차후 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7b7923e80f9004780986d78cff2f797fee5928bf" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 심도 우선 사전 순서 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="53d43f5532c10b67e765cd88c0ddb300fe2d8aba" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions.</source>
          <target state="translated">따옴표로 묶인 표현식의 심도 우선 사전 순서 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="039534a957eec2fa34791db81532382c587d8245" translate="yes" xml:space="preserve">
          <source>Performs a floored integer division.</source>
          <target state="translated">바닥 정수 나누기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="458261426d9d27cb74c83066a9b390fab831f47c" translate="yes" xml:space="preserve">
          <source>Performs an integer division.</source>
          <target state="translated">정수 나누기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d5fa7b7265385a6a4338c08984b01ec783651ffb" translate="yes" xml:space="preserve">
          <source>Performs cross reference checks between modules.</source>
          <target state="translated">모듈간에 상호 참조 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="11854d0712971b76c41b6ad9d5a606d865ee7453" translate="yes" xml:space="preserve">
          <source>Performs remote dispatch checking.</source>
          <target state="translated">원격 디스패치 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="35f1c5990cc168fdf4f91ba17d0cf4c3bd708a54" translate="yes" xml:space="preserve">
          <source>Persists the given configuration by modifying the configured applications environment.</source>
          <target state="translated">구성된 애플리케이션 환경을 수정하여 주어진 구성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="a6c6db8bc84509e69b9d23d41b0e1fc7fcdce78a" translate="yes" xml:space="preserve">
          <source>Pin operator. Accesses an already bound variable in match clauses.</source>
          <target state="translated">핀 연산자. match 절에서 이미 바인딩 된 변수에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0b7522b2ee55a89f041eb7221911aa0a0e32f37f" translate="yes" xml:space="preserve">
          <source>Pipe operator.</source>
          <target state="translated">파이프 운영자.</target>
        </trans-unit>
        <trans-unit id="3854cbad98a94ad36b9fbd34a9d7759251a83644" translate="yes" xml:space="preserve">
          <source>Pipes &lt;code&gt;expr&lt;/code&gt; into the &lt;code&gt;call_args&lt;/code&gt; at the given &lt;code&gt;position&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;position&lt;/code&gt; 에서 &lt;code&gt;expr&lt;/code&gt; 을 &lt;code&gt;call_args&lt;/code&gt; 로 파이프합니다 .</target>
        </trans-unit>
        <trans-unit id="8ef57d28e73677c96993fd2b8445c1eec249cdff" translate="yes" xml:space="preserve">
          <source>Pitfalls</source>
          <target state="translated">Pitfalls</target>
        </trans-unit>
        <trans-unit id="e5a7b226404fec963975ee16c6feacd0bed5537d" translate="yes" xml:space="preserve">
          <source>Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.</source>
          <target state="translated">다중 절 함수의 첫 번째 절 앞에 문서를 배치하십시오. 문서는 항상 기능과 특성에 따라 다르며 절마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="225a7f9c31a9e433302718633fe4e93f7a51a743" translate="yes" xml:space="preserve">
          <source>Please note that all the modules defined in the same file as &lt;code&gt;module&lt;/code&gt; are recompiled and reloaded.</source>
          <target state="translated">모듈과 동일한 파일에 정의 된 모든 &lt;code&gt;module&lt;/code&gt; 이 다시 컴파일되어 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="39c9a395b7a75f7f91d5c9d082bddd97314589a3" translate="yes" xml:space="preserve">
          <source>Please note that by doing this, we are breaking the boilerplate test case which tested the &lt;code&gt;hello&lt;/code&gt; function in &lt;code&gt;KV&lt;/code&gt;. You can simply remove that test case.</source>
          <target state="translated">이 작업을 수행하면 &lt;code&gt;KV&lt;/code&gt; 에서 &lt;code&gt;hello&lt;/code&gt; 함수 를 테스트 한 상용구 테스트 사례가 중단 됩니다. 해당 테스트 사례를 간단히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5389d292ea210e333906a47db99429702756329e" translate="yes" xml:space="preserve">
          <source>Please note that some details like version numbers may differ a bit in your session; that&amp;rsquo;s not important. From now on &lt;code&gt;iex&lt;/code&gt; sessions will be stripped down to focus on the code. To exit &lt;code&gt;iex&lt;/code&gt; press &lt;code&gt;Ctrl+C&lt;/code&gt; twice.</source>
          <target state="translated">버전 번호와 같은 일부 세부 사항은 세션에서 약간 다를 수 있습니다. 중요하지 않습니다. 이제부터는 &lt;code&gt;iex&lt;/code&gt; 세션이 코드에 집중되도록 제거됩니다. &lt;code&gt;iex&lt;/code&gt; 를 종료하려면 &lt;code&gt;Ctrl+C&lt;/code&gt; 를 두 번 누르십시오 .</target>
        </trans-unit>
        <trans-unit id="cdcdcf740b9da96cd544682ab9e49f434e891d96" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">튜플에 대한 다음 함수는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; 에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d11ad5116bd8c797fe89a4d35824e7ca4c61f131" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 다음과 같은 튜플 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3de0c7e157c52cc856a0f62d452060f6a5131f16" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;the GenServer module documentation&lt;/a&gt; for an overview if you haven&amp;rsquo;t yet. Once you do so, we are ready to proceed.</source>
          <target state="translated">아직 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer 모듈 설명서&lt;/a&gt; 를 읽지 않았다면 읽어보십시오 . 그렇게하면 진행할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="34c26932c8bdaaf11dbb3279895024633d9ddf5b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt; to read more about other ways in which one could use this function. Also, in order to find a full list of other formatting options that one can use alongside &lt;code&gt;IO.inspect/2&lt;/code&gt;, see &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt;.</source>
          <target state="translated">이 기능을 사용할 수있는 다른 방법에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect / 2&lt;/a&gt; 를 참조하십시오 . 또한, 하나는 함께 사용할 수있는 다른 서식 옵션의 전체 목록을 찾기 위해 &lt;code&gt;IO.inspect/2&lt;/code&gt; 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e45979c3d32e2c27b3aeac1606c58bb2e6186e8" translate="yes" xml:space="preserve">
          <source>Plugs into Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; (from Erlang/OTP 21) to convert terms to Elixir syntax or wraps Erlang's &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt;&lt;code&gt;:error_logger&lt;/code&gt;&lt;/a&gt; in earlier Erlang/OTP versions to prevent it from overflowing.</source>
          <target state="translated">얼랑의에 연결 &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt; (얼랑 / OTP 21) 비약 구문 용어를 변환하거나 얼랑의 랩 &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt; &lt;code&gt;:error_logger&lt;/code&gt; 를&lt;/a&gt; 오버 플로우를 방지하기 위해 이전 얼랑 / OTP 버전.</target>
        </trans-unit>
        <trans-unit id="22f9e4899d5a9f9e7d7ac5fc03923347cf0dd256" translate="yes" xml:space="preserve">
          <source>Plus a number of functions for working with binaries (bytes) in the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; &lt;/a&gt; 모듈 에서 바이너리 (바이트) 작업을위한 여러 함수</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="5b184d613e5dc77792a5b77d4c71d9a8f5805d12" translate="yes" xml:space="preserve">
          <source>Pops a key from the given nested structure.</source>
          <target state="translated">주어진 중첩 구조에서 키를 팝합니다.</target>
        </trans-unit>
        <trans-unit id="f3dbd54145fe56b947320097710efe3fb212dea0" translate="yes" xml:space="preserve">
          <source>Pops a key from the nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 중첩 구조에서 키를 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="b33456701a07c78fe5d71eef1faf59492a293d96" translate="yes" xml:space="preserve">
          <source>Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing.</source>
          <target state="translated">포트는 Erlang VM 외부에서 운영 체제 프로세스를 시작하고 메시지 전달을 통해 이들과 통신하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49af11ce7ff963467dab9d145b8d28e88fbf86cb" translate="yes" xml:space="preserve">
          <source>Possible time zone periods for a certain time zone and wall clock date and time.</source>
          <target state="translated">특정 시간대 및 벽시계 날짜 및 시간에 대해 가능한 시간대 기간.</target>
        </trans-unit>
        <trans-unit id="9af262a428ebb097a2a816a84db97bdefe0b3f35" translate="yes" xml:space="preserve">
          <source>Pre-releases are strictly less than their corresponding release versions.</source>
          <target state="translated">시험판은 해당 릴리스 버전보다 엄격히 적습니다.</target>
        </trans-unit>
        <trans-unit id="bda9c25c561aec987e1b78e68cb3669014cebe8e" translate="yes" xml:space="preserve">
          <source>Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens (&lt;code&gt;[0-9A-Za-z-]&lt;/code&gt;):</source>
          <target state="translated">시험판은 패치 버전 바로 뒤에 하이픈과 마침표로 구분 된 일련의 식별자를 선택적으로 추가하여 지원됩니다. 식별자는 ASCII 영숫자와 하이픈 ( &lt;code&gt;[0-9A-Za-z-]&lt;/code&gt; ) 으로 만 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="1d2dd642b809a9afa37c5b34ef9ccae95e253485" translate="yes" xml:space="preserve">
          <source>Precompilation</source>
          <target state="translated">Precompilation</target>
        </trans-unit>
        <trans-unit id="0b8da57c3b77645c7f2cae0807da41d055f68ad1" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;datetime#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 과 반대로 시간대 정보를 유지하므로 가능한 경우 &lt;a href=&quot;datetime#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; 을&lt;/a&gt; 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1c8b2f7521e20b88ce608e018b5a7663333ca930" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">사용 안함 &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; &lt;/a&gt; 역방향으로 가능한 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; ,이 시간대 정보를 유지한다.</target>
        </trans-unit>
        <trans-unit id="24a52cada612d997ea6ace1f1cca2bd40a581254" translate="yes" xml:space="preserve">
          <source>Preferred date (without time) representation</source>
          <target state="translated">선호하는 날짜 (시간 없음) 표시</target>
        </trans-unit>
        <trans-unit id="523d7d1c8d156006cfdc5d6b7a6759d22cf010f1" translate="yes" xml:space="preserve">
          <source>Preferred date+time representation</source>
          <target state="translated">선호하는 날짜 + 시간 표현</target>
        </trans-unit>
        <trans-unit id="efc0bf801074207be31f8c48b25bd5b7b7ac758d" translate="yes" xml:space="preserve">
          <source>Preferred time (without date) representation</source>
          <target state="translated">원하는 시간 (날짜 없음) 표시</target>
        </trans-unit>
        <trans-unit id="193093334a57781999b3ba39585e6cbf824ef0f0" translate="yes" xml:space="preserve">
          <source>Prefix (unary) operator; calculates the bitwise NOT of its argument.</source>
          <target state="translated">접두사 (단항) 연산자; 인수의 비트 NOT을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="eea84a143a5c43eba7121b69efd8599881cd4e88" translate="yes" xml:space="preserve">
          <source>Prepends a path to the beginning of the Erlang VM code path list.</source>
          <target state="translated">Erlang VM 코드 경로 목록의 시작 부분에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d43f430611481683290048b50760bd71f76a2c55" translate="yes" xml:space="preserve">
          <source>Prepends the given SCM module to the list of available SCMs.</source>
          <target state="translated">주어진 SCM 모듈을 사용 가능한 SCM 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ad7544451a00457faefe5c90802b235432b07208" translate="yes" xml:space="preserve">
          <source>Pries into the process environment.</source>
          <target state="translated">프로세스 환경으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="c650d1681f475d556e0741952be9bdbed39b594a" translate="yes" xml:space="preserve">
          <source>Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via &lt;a href=&quot;#runtime_info/1&quot;&gt;&lt;code&gt;runtime_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전, 메모리 사용량 및 통계와 같은 VM / 런타임 정보를 인쇄합니다. 추가 주제는 &lt;a href=&quot;#runtime_info/1&quot;&gt; &lt;code&gt;runtime_info/1&lt;/code&gt; 을&lt;/a&gt; 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="cd2dbcf9bebb8d76fc78e7c60efbed06c652a712" translate="yes" xml:space="preserve">
          <source>Prints a file dependency graph where an edge from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt; indicates that &lt;code&gt;A&lt;/code&gt; (source) depends on &lt;code&gt;B&lt;/code&gt; (sink).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로의 가장자리 가 &lt;code&gt;A&lt;/code&gt; (소스)가 &lt;code&gt;B&lt;/code&gt; (싱크) 에 의존 한다는 것을 나타내는 파일 종속성 그래프를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f89b78f661ed94f4f3264cf20d49cfe3b2271d25" translate="yes" xml:space="preserve">
          <source>Prints a list of all the functions and macros exported by the given module.</source>
          <target state="translated">지정된 모듈에서 내 보낸 모든 기능 및 매크로 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="21cf1dbac4d05fa2e897c927750d4ec851dfdfa6" translate="yes" xml:space="preserve">
          <source>Prints a list of the given directory's contents.</source>
          <target state="translated">주어진 디렉토리 내용의 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="816fa4a9573b3d1eade5973479c5d434df6932d3" translate="yes" xml:space="preserve">
          <source>Prints a message and asks the user if they want to proceed.</source>
          <target state="translated">메시지를 인쇄하고 사용자에게 계속 진행할 것인지 묻습니다.</target>
        </trans-unit>
        <trans-unit id="e2ec3a4dfe86c240d136373ea35a884bf200c540" translate="yes" xml:space="preserve">
          <source>Prints a message and prompts the user for input.</source>
          <target state="translated">메시지를 인쇄하고 사용자에게 입력하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ddd0491656e97dc3bcc73b8c0fac99539b89b38e" translate="yes" xml:space="preserve">
          <source>Prints all breakpoints to the terminal.</source>
          <target state="translated">모든 중단 점을 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d45ac7d4540637c6fdc232c2b99937de0319a5e3" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;CALLEE&lt;/code&gt;, which can be one of: &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Module.function&lt;/code&gt;, or &lt;code&gt;Module.function/arity&lt;/code&gt;. Examples:</source>
          <target state="translated">지정된 &lt;code&gt;CALLEE&lt;/code&gt; 의 모든 발신자를 인쇄합니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Module.function&lt;/code&gt; 또는 &lt;code&gt;Module.function/arity&lt;/code&gt; 중 하나 일 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="809386d6073ab7bf681b254f1d8ce9b7df690096" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;MODULE&lt;/code&gt;. Example:</source>
          <target state="translated">주어진 &lt;code&gt;MODULE&lt;/code&gt; 의 모든 호출자를 인쇄합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="fb7b5b8ff071f99cadfdd753b83a8dcfd047d61c" translate="yes" xml:space="preserve">
          <source>Prints all deprecated &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">더 이상 사용되지 않는 &quot;file : line : module.function / arity&quot;항목을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c1327228921868a454a53046edb632efd4b315a2" translate="yes" xml:space="preserve">
          <source>Prints all unreachable &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">도달 할 수없는 모든 &quot;file : line : module.function / arity&quot;항목을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b8f021dfa5efe59a9f253cec7d84c691f6f573bb" translate="yes" xml:space="preserve">
          <source>Prints cross reference information between modules.</source>
          <target state="translated">모듈 간의 상호 참조 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="971f6a2d9c15e227f73c83c32352ffad4dff563e" translate="yes" xml:space="preserve">
          <source>Prints information about the data type of any given term.</source>
          <target state="translated">주어진 용어의 데이터 유형에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c1fb53812afe31e50bbaad2c2a262be107aad858" translate="yes" xml:space="preserve">
          <source>Prints nothing to the shell.</source>
          <target state="translated">쉘에 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df10c0d38c5c33dd31ff77c2596b2889339e3e88" translate="yes" xml:space="preserve">
          <source>Prints the application tree.</source>
          <target state="translated">애플리케이션 트리를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3d707a33372771d97f7c17fb4637c172eed3bdd3" translate="yes" xml:space="preserve">
          <source>Prints the current application if it was not printed yet.</source>
          <target state="translated">현재 응용 프로그램이 아직 인쇄되지 않은 경우 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f8ad915e9dada2c1aa7c7f28d88b5ad48d5e62fb" translate="yes" xml:space="preserve">
          <source>Prints the current application to the shell if it was not printed yet.</source>
          <target state="translated">아직 인쇄되지 않은 경우 현재 응용 프로그램을 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b0cbd5cf2d2d3e1ca6d472dc9fce84b12f99639e" translate="yes" xml:space="preserve">
          <source>Prints the current location and stacktrace in a pry session.</source>
          <target state="translated">올림 세션에서 현재 위치 및 스택 추적을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b874478af7120eec5906930f8fa90e197ddb0f5c" translate="yes" xml:space="preserve">
          <source>Prints the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e2927c6e9ca9a7624f08be74d01a105931872b70" translate="yes" xml:space="preserve">
          <source>Prints the dependency tree.</source>
          <target state="translated">종속성 트리를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f23662b711ee1f5d4b42e4d3962ce84c2e247563" translate="yes" xml:space="preserve">
          <source>Prints the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; 의 문서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="7891ced35c9c114c80c5ffbd1f3c76e017520d37" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given callback function.</source>
          <target state="translated">주어진 콜백 함수에 대한 문서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="435df0bab4049f4242469a352be410f6392ff49a" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given module or for the given &lt;code&gt;function/arity&lt;/code&gt; pair.</source>
          <target state="translated">주어진 모듈 또는 주어진 &lt;code&gt;function/arity&lt;/code&gt; 쌍에 대한 문서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="b4e5b715823a81af2f3bf4f64cb361cb0e6cdd53" translate="yes" xml:space="preserve">
          <source>Prints the error to the shell followed by a newline.</source>
          <target state="translated">오류를 쉘에 인쇄하고 그 뒤에 개행을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="520d57f3ac5af5ff431571387cb13b8f42ac807d" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell followed by a newline.</source>
          <target state="translated">주어진 ANSI 오류를 쉘에 인쇄 한 다음 줄 바꿈을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6f73495e34df8eb42235ec69b623fa2416a182ff" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell.</source>
          <target state="translated">주어진 ANSI 오류를 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1bafbf3ef8eb7159086bd97a24eb4f293f1a5373" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell followed by a newline.</source>
          <target state="translated">주어진 ANSI 메시지를 쉘에 인쇄 한 다음 줄 바꿈을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="8369f83188dc1b52c0cc18c00adcce18fe776b89" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell.</source>
          <target state="translated">주어진 ANSI 메시지를 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="499ef41bb785f746215b5a24160f51ee0f225759" translate="yes" xml:space="preserve">
          <source>Prints the types for the given module or for the given function/arity pair.</source>
          <target state="translated">주어진 모듈 또는 주어진 기능 / arity 쌍에 대한 유형을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="05530a9faf598937d4f4978efcc1c34117c9ea75" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;https://hexdocs.pm/elixir/UndefinedFunctionError.html&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">개인 함수는 정의 된 모듈 내에서만 액세스 할 수 있습니다. 정의 된 모듈 외부에서 개인 함수에 액세스하려고하면 &lt;a href=&quot;https://hexdocs.pm/elixir/UndefinedFunctionError.html&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb2a8bb0b4b97049a59dbbb6853799ec628b02bc" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;undefinedfunctionerror&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">전용 기능은 해당 기능이 정의 된 모듈 내에서만 액세스 할 수 있습니다. 모듈 외부에서 개인 함수에 액세스하려고하면 &lt;a href=&quot;undefinedfunctionerror&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ca7456031219f8f2eeb5d52b9d37db3106da6e2" translate="yes" xml:space="preserve">
          <source>Private macros</source>
          <target state="translated">개인 매크로</target>
        </trans-unit>
        <trans-unit id="df9584791f632e79823605fbe6e78ca4839179b5" translate="yes" xml:space="preserve">
          <source>Private macros are only accessible from the same module in which they are defined.</source>
          <target state="translated">개인용 매크로는 정의 된 동일한 모듈에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46cd46eb7732031c3d6591214da75d5f59059290" translate="yes" xml:space="preserve">
          <source>Private macros must be defined before its usage.</source>
          <target state="translated">개인용 매크로는 사용하기 전에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="12f4c13a6a06f999cc56eb966c94f71ef2658a3f" translate="yes" xml:space="preserve">
          <source>Process</source>
          <target state="translated">Process</target>
        </trans-unit>
        <trans-unit id="5eaa8e263e7efadbe9297d9c15fb6812d4c60c3a" translate="yes" xml:space="preserve">
          <source>Process-based and application-centric functionality</source>
          <target state="translated">프로세스 기반 및 애플리케이션 중심 기능</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="a808861bbe2c82040e69c3e43be934abe883b545" translate="yes" xml:space="preserve">
          <source>Processes and group leaders</source>
          <target state="translated">프로세스 및 그룹 리더</target>
        </trans-unit>
        <trans-unit id="64cc2973345456132597091b2640ba2a85719adb" translate="yes" xml:space="preserve">
          <source>Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don&amp;rsquo;t share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.</source>
          <target state="translated">내결함성 시스템을 구축 할 때 프로세스와 링크가 중요한 역할을합니다. 엘릭서 프로세스는 격리되어 있으며 기본적으로 아무 것도 공유하지 않습니다. 따라서 프로세스의 실패로 인해 다른 프로세스의 상태가 충돌하거나 손상되지 않습니다. 그러나 링크를 통해 프로세스가 실패한 경우 관계를 설정할 수 있습니다. 프로세스가 종료되는시기를 감지하고 대신 새 프로세스를 시작하는 관리자와 프로세스를 종종 연결합니다.</target>
        </trans-unit>
        <trans-unit id="76f3f8bdca9664b89ee735acfb5e747a8d6c7222" translate="yes" xml:space="preserve">
          <source>Processes and raw files</source>
          <target state="translated">프로세스 및 원시 파일</target>
        </trans-unit>
        <trans-unit id="23eeb001c70f95660b354880626576dbb1964408" translate="yes" xml:space="preserve">
          <source>Processes are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let&amp;rsquo;s write a module that starts new processes that work as a key-value store in a file named &lt;code&gt;kv.exs&lt;/code&gt;:</source>
          <target state="translated">이 질문에 대한 가장 일반적인 답변은 프로세스입니다. 무한 반복되는 프로세스를 작성하고 상태를 유지하며 메시지를주고받을 수 있습니다. 예를 들어, &lt;code&gt;kv.exs&lt;/code&gt; 파일에서 키-값 저장소로 작동하는 새 프로세스를 시작하는 모듈을 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="098f80f89b609eb84c8d74bbd2be6927723c925d" translate="yes" xml:space="preserve">
          <source>Processes get much more interesting when we are able to send and receive messages.</source>
          <target state="translated">메시지를 보내고받을 수있을 때 프로세스가 훨씬 흥미로워집니다.</target>
        </trans-unit>
        <trans-unit id="1c4a0da5abc99ecc4244180ae622b35cf0c5d24f" translate="yes" xml:space="preserve">
          <source>Produces a new list by removing the value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 에서 값을 제거하여 새 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="9e60eab60abd9957404c62c1a08f6416ba3bd550" translate="yes" xml:space="preserve">
          <source>Profile output</source>
          <target state="translated">프로필 출력</target>
        </trans-unit>
        <trans-unit id="17a20ce2ecdf2e690491227f705d6a39b4f49280" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;cprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;cprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="9e9508bf92bb3b0baebd12f499bb465caddb8d1d" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;eprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;eprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="7f5a56d02582dfbf0f39138c52e7854843f56715" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;fprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;fprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="a3eb4c5dc8ed98fadb3285836002a5d71bcb1221" translate="yes" xml:space="preserve">
          <source>Project compilation</source>
          <target state="translated">프로젝트 편집</target>
        </trans-unit>
        <trans-unit id="c948166b923ec0b7f32efdb8807735735dd8fe86" translate="yes" xml:space="preserve">
          <source>Projects are often made available to other developers &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;by publishing a Hex package&lt;/a&gt;. Hex also &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;supports private packages for organizations&lt;/a&gt;. If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt;.</source>
          <target state="translated">프로젝트는 종종 &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;Hex 패키지를 게시&lt;/a&gt; 하여 다른 개발자에게 제공됩니다 . Hex는 또한 &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;조직을위한 개인 패키지를 지원합니다&lt;/a&gt; . ExDoc이 Mix 프로젝트에 대해 구성된 경우 Hex에 패키지를 게시하면 생성 된 문서도 &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs에&lt;/a&gt; 자동으로 게시됩니다 .</target>
        </trans-unit>
        <trans-unit id="928902bdb5cb34c32542be3d749f35a31372f0b9" translate="yes" xml:space="preserve">
          <source>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</source>
          <target state="translated">프로젝트는 자체 작업을 추가하여 믹스 동작을 확장 할 수 있습니다. 예를 들어, 프로젝트 내에 아래 작업을 추가하면 프로젝트를 사용하는 모든 사람이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baaca8514e96b4b82b5f18247ed0611dd75c38c5" translate="yes" xml:space="preserve">
          <source>Projects or applications?</source>
          <target state="translated">프로젝트 또는 응용 프로그램?</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="7a0dec5bd8beaf8966c20643c7460723312db52e" translate="yes" xml:space="preserve">
          <source>Prompts the user for confirmation.</source>
          <target state="translated">사용자에게 확인을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="2aca8f27d240f670b5c2dd5bad2b1c492e8b548c" translate="yes" xml:space="preserve">
          <source>Prompts the user for input.</source>
          <target state="translated">사용자에게 입력을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="7606ab4ce07f68998f8ea0ae42c453b5c637eccf" translate="yes" xml:space="preserve">
          <source>Prompts the user to overwrite the file if it exists.</source>
          <target state="translated">파일이있는 경우 사용자에게 덮어 쓸지 묻는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="c95299144f537818ea4ffc62edc9baddb79ff9f1" translate="yes" xml:space="preserve">
          <source>Protocol consolidation</source>
          <target state="translated">프로토콜 통합</target>
        </trans-unit>
        <trans-unit id="4924211f292b499a01c2e195003fc6016713268f" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs:</source>
          <target state="translated">프로토콜 통합은 기본적으로 컴파일 중에 모든 믹스 프로젝트에 적용됩니다. 테스트하는 동안 문제가 될 수 있습니다. 예를 들어, 테스트 중에 프로토콜을 구현하려는 경우 프로토콜이 이미 통합되어 있으므로 구현이 적용되지 않습니다. 가능한 해결책 중 하나는 테스트 환경에 특정한 컴파일 디렉토리를 mix.exs에 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="56899eca0f5c92aaef991d6556116246dc1628dd" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is useful in production when no dynamic code loading will happen, effectively optimizing protocol dispatches by not accounting for code loading.</source>
          <target state="translated">프로토콜 통합은 동적 코드로드가 발생하지 않을 때 프로덕션에서 유용하며 코드로드를 고려하지 않음으로써 프로토콜 디스패치를 ​​효과적으로 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="38f75fd9978f6b7ab60b40a58bd29ed87ef1c6c3" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError</source>
          <target state="translated">Protocol.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b22941c869e24046b71f5c52bd523b215a22df33" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Protocol.UndefinedError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="e4df956dc0223cfa164303e687c5a225641ae40e" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;#defprotocol/2&quot;&gt;&lt;code&gt;defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">프로토콜은 Elixir에 다형성 디스패치를 ​​추가합니다. 데이터 형식으로 구현할 수있는 계약입니다. 프로토콜에 대한 자세한 내용 은 &lt;a href=&quot;#defprotocol/2&quot;&gt; &lt;code&gt;defprotocol/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. Elixir는 표준 라이브러리에서 다음 프로토콜을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1def0a70d708cdb3bbc2385a4c6d0ac221d9e809" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">프로토콜은 Elixir에 다형성 디스패치를 ​​추가합니다. 데이터 유형별로 구현할 수있는 계약입니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Protocol.html&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; 대한 자세한 내용 은 프로토콜 을 참조하십시오 . Elixir는 표준 라이브러리에서 다음 프로토콜을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="36627e2d6127b7bd708517ebecfa2ad88acfd239" translate="yes" xml:space="preserve">
          <source>Protocols and Structs</source>
          <target state="translated">프로토콜과 구조</target>
        </trans-unit>
        <trans-unit id="bf8ab3000b321cfc5656321edcc2397588fbb0c7" translate="yes" xml:space="preserve">
          <source>Protocols and structs</source>
          <target state="translated">프로토콜과 구조체</target>
        </trans-unit>
        <trans-unit id="802592c2ba86a4f47efd17972c7a0ca39d7a2c72" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir when you want behavior to vary depending on the data type. We are already familiar with one way of solving this type of problem: via pattern matching and guard clauses. Consider a simple utility module that would tell us the type of input variable:</source>
          <target state="translated">프로토콜은 데이터 유형에 따라 동작이 달라 지길 원할 때 Elixir에서 다형성을 달성하는 메커니즘입니다. 우리는 이미 이러한 유형의 문제를 해결하는 한 가지 방법, 즉 패턴 일치 및 보호 절을 통해 잘 알고 있습니다. 입력 변수의 유형을 알려주는 간단한 유틸리티 모듈을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8ae27a72345a1064a4d3cc2a284758812ffebfda" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol. Let&amp;rsquo;s see an example.</source>
          <target state="translated">프로토콜은 Elixir에서 다형성을 달성하는 메커니즘입니다. 프로토콜에 대한 디스패치는 프로토콜을 구현하는 한 모든 데이터 유형에 사용할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="77f08665fbb2d92871b41b859bb9813256bbb73a" translate="yes" xml:space="preserve">
          <source>Protocols can also be implemented for multiple types at once:</source>
          <target state="translated">여러 유형에 대해 한 번에 프로토콜을 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a4f154e26e2407d7bcfe638361358c2a738cf2" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print a &quot;Not implemented&quot; error message. The resulting test case is also tagged with &lt;code&gt;:not_implemented&lt;/code&gt;.</source>
          <target state="translated">문자열로 테스트를 정의 할 수 있지만 아직 구현되지 않은 편리한 매크로를 제공합니다. 결과 테스트는 항상 실패하고 &quot;구현되지 않음&quot;오류 메시지를 인쇄합니다. 결과 테스트 케이스에도 &lt;code&gt;:not_implemented&lt;/code&gt; 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="28a92a1009021c22f4256b929d5eb72a49f595b7" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string. This macro automatically inserts the atom &lt;code&gt;:ok&lt;/code&gt; as the last line of the test. That said, a passing test always returns &lt;code&gt;:ok&lt;/code&gt;, but, more importantly, it forces Elixir to not tail call optimize the test and therefore avoids hiding lines from the backtrace.</source>
          <target state="translated">문자열로 테스트를 정의 할 수있는 편리한 매크로를 제공합니다. 이 매크로는 자동으로 atom &lt;code&gt;:ok&lt;/code&gt; 를 테스트의 마지막 줄로 삽입합니다 . 즉, 통과 테스트는 항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하지만, 더 중요한 것은 Elixir가 테일 콜을 통해 테스트를 최적화하지 않도록하여 역 추적에서 라인을 숨기는 것을 피합니다.</target>
        </trans-unit>
        <trans-unit id="f485c4915018382897d623e74fdf4c922f5ba9de" translate="yes" xml:space="preserve">
          <source>Provides a set of algorithms to work with enumerables.</source>
          <target state="translated">열거 형 작업에 사용할 알고리즘 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7babca163a5798352d200c29bbb4727f2713232" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">첫 번째 표현식이 정확한 값 (즉, &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )으로 평가되지 않는 경우에만 두 번째 표현식을 평가하고 리턴하는 단락 연산자를 제공합니다 . 그렇지 않으면 첫 번째 표현식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="35075f345dd0aedc6d466cfa0aae79a32f0d1a0f" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">첫 번째 표현식이 진실 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 아님)으로 평가되는 경우에만 두 번째 표현식을 평가하고 반환하는 단락 연산자를 제공합니다 . 그렇지 않으면 첫 번째 표현식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c97af16a870f773f7d8298f32114ae521e291d7" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">첫 번째 표현식이 정확한 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 아닌)으로 평가되는 경우에만 두 번째 표현식을 평가하고 리턴하는 단락 연산자를 제공합니다 . 그렇지 않으면 첫 번째 표현식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bb1c1ada41fd138777281c5c60f4b0fbeb1252f7" translate="yes" xml:space="preserve">
          <source>Provides an &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 매크로를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7d7f5e01f31db2b96487f259d6815fc4f44d1641" translate="yes" xml:space="preserve">
          <source>Provides an &lt;code&gt;unless&lt;/code&gt; macro.</source>
          <target state="translated">는 제공 &lt;code&gt;unless&lt;/code&gt; 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="45d5f5b4aef56cec5f198053345c927c66a7c8fe" translate="yes" xml:space="preserve">
          <source>Provides conveniences for creating, loading, and manipulating Mix tasks.</source>
          <target state="translated">Mix 작업을 생성,로드 및 조작하기위한 편의를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc5d7dd7b7f78c70f93425bf23e7c1767df559e1" translate="yes" xml:space="preserve">
          <source>Provides debug, info, warn, and error levels.</source>
          <target state="translated">디버그, 정보, 경고 및 오류 수준을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d218d5f6be5831e733b2aadef5482b512cca16e" translate="yes" xml:space="preserve">
          <source>Provides documentation for the current module.</source>
          <target state="translated">현재 모듈에 대한 설명서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da7b097fc28ffbab2557a5f2b082e76f4d69bde6" translate="yes" xml:space="preserve">
          <source>Provides documentation for the entity that follows the attribute. &lt;code&gt;@doc&lt;/code&gt; is to be used with a function, macro, callback, or macrocallback, while &lt;code&gt;@typedoc&lt;/code&gt; with a type (public or opaque).</source>
          <target state="translated">속성을 따르는 엔터티에 대한 설명서를 제공합니다. &lt;code&gt;@doc&lt;/code&gt; 은 함수, 매크로, 콜백 또는 매크로 콜백과 함께 사용되며 &lt;code&gt;@typedoc&lt;/code&gt; 은 유형 (공개 또는 불투명)으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdadc7bd29e445ef99b6104b5a2b2b038e10ffe9" translate="yes" xml:space="preserve">
          <source>Provides functions to deal with modules during compilation time.</source>
          <target state="translated">컴파일 시간 동안 모듈을 처리하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="df51d0334cfd857e80339917423d4fb2e1cef1c7" translate="yes" xml:space="preserve">
          <source>Provides regular expressions for Elixir.</source>
          <target state="translated">Elixir에 정규식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d02201797a586702284442194cb247908230a636" translate="yes" xml:space="preserve">
          <source>Provides runtime information about functions, macros, and other information defined by the module.</source>
          <target state="translated">함수, 매크로 및 모듈에서 정의한 기타 정보에 대한 런타임 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc9cbca5a4e02cf60536136ef9f3c6d625c70f6c" translate="yes" xml:space="preserve">
          <source>Provides the deprecation reason for a function. For example:</source>
          <target state="translated">기능에 대한 더 이상 사용되지 않는 이유를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb509e3cef4b01a2055df90985ae11c420fddff2" translate="yes" xml:space="preserve">
          <source>Providing a non-boolean will raise an exception:</source>
          <target state="translated">부울이 아닌 것을 제공하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e15e7e0c2b4f977b6843784ea894879b5494e87" translate="yes" xml:space="preserve">
          <source>Prunes invalid Unicode code points from lists and invalid UTF-8 bytes.</source>
          <target state="translated">목록 및 잘못된 UTF-8 바이트에서 잘못된 유니 코드 코드 포인트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="fdaf9976e20d314713bf8ad08c1c0453b92492e1" translate="yes" xml:space="preserve">
          <source>Prunes non-valid UTF-8 code points.</source>
          <target state="translated">유효하지 않은 UTF-8 코드 포인트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="fb5dee80e4520a5f254d6238153c6dc561e1cf68" translate="yes" xml:space="preserve">
          <source>Pry and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">프라이 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54ec660e29ebb5bec957ff2cb42e6a129ef66da9" translate="yes" xml:space="preserve">
          <source>Pry and macros</source>
          <target state="translated">올챙이와 매크로</target>
        </trans-unit>
        <trans-unit id="1c9019872a4bbfd06ad7b17c0bee064d866590d1" translate="yes" xml:space="preserve">
          <source>Prying and breakpoints</source>
          <target state="translated">엿보기 및 중단 점</target>
        </trans-unit>
        <trans-unit id="4b2535c1fee183c38427a7089cd2b388b925985a" translate="yes" xml:space="preserve">
          <source>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</source>
          <target state="translated">모듈의 공용 함수는 전 세계적으로 사용 가능하지만 매크로를 사용하려면 정의 된 모듈을 요구하여 옵트 인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8b838dadc80d5fdf978ad61a556c571858f9ea4" translate="yes" xml:space="preserve">
          <source>Public keys are by default stored in your MIX_HOME under the public_keys directory.</source>
          <target state="translated">공개 키는 기본적으로 public_keys 디렉토리 아래의 MIX_HOME에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a8c75b8cc2fd8745681c0480ca03a865e4064f2c" translate="yes" xml:space="preserve">
          <source>Public keys are used by Mix to install packages like Rebar and Hex.</source>
          <target state="translated">공개 키는 Mix에서 Rebar 및 Hex와 같은 패키지를 설치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="25d4b8eeccc56c0cd4a7d514c04c9c3ae243c619" translate="yes" xml:space="preserve">
          <source>Purge compiler modules.</source>
          <target state="translated">컴파일러 모듈을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b90fc74c10d02d502db87680f321a47d69aa7a2c" translate="yes" xml:space="preserve">
          <source>Puts &lt;code&gt;value&lt;/code&gt; at the given zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">풋은 &lt;code&gt;value&lt;/code&gt; 주어진 제로에서 &lt;code&gt;index&lt;/code&gt; 의 &lt;code&gt;tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec1e5d54e71eec9873cec8ecdadb097c2ae427d5" translate="yes" xml:space="preserve">
          <source>Puts a module attribute with &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; in the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;module&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 을 가진 모듈 속성을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="4acfce1f0b23360b26c12b5e6c7bf2a6bf918d25" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 중첩 구조에 값을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="7c0b337e86b25912f1d42a657325dc6d8a9a7246" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure.</source>
          <target state="translated">중첩 구조에 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="4865e7e25231ab9477efccfa0577bb1695cee9b1" translate="yes" xml:space="preserve">
          <source>Puts a value under &lt;code&gt;key&lt;/code&gt; only if the &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;keywords&lt;/code&gt; 이미있는 경우에만 &lt;code&gt;key&lt;/code&gt; 아래에 값을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="82ce204eaabed7443e91511f145c78e913dad9c8" translate="yes" xml:space="preserve">
          <source>Puts a value under &lt;code&gt;key&lt;/code&gt; only if the &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 이미 &lt;code&gt;map&lt;/code&gt; 에있는 경우에만 &lt;code&gt;key&lt;/code&gt; 아래에 값을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="c400abfe3b82b8ea0f8b25008c2bc562a136778b" translate="yes" xml:space="preserve">
          <source>Puts logging level for given module.</source>
          <target state="translated">주어진 모듈에 대한 로깅 수준을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="48a23971095bfbe373d39b1f1c70ac23fcde2d47" translate="yes" xml:space="preserve">
          <source>Puts the &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;app&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="97d0f1caf6e213cd26ac881b852140f4d9d23037" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a &quot;hibernation&quot; state.</source>
          <target state="translated">호출 프로세스를 &quot;최대 절전 모드&quot;상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cadfddef2accc558bb07d494514e7ca1c284d964" translate="yes" xml:space="preserve">
          <source>Puts the environment for multiple apps at the same time.</source>
          <target state="translated">여러 앱을위한 환경을 동시에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b6ea1ba815fc83f69431f0cdd76f4213b86b1a54" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;map&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="de7749bbf077f512273bf8036b7cb8fc0deef364" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;map&lt;/code&gt; 에 존재 하지 않는 한 주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="9b4d02cfb162ff8a780c85d472f56775f06bd43e" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists.</source>
          <target state="translated">입력 &lt;code&gt;key&lt;/code&gt; 없으면 &lt;code&gt;key&lt;/code&gt; 아래에 지정된 &lt;code&gt;value&lt;/code&gt; 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="801eb18f7c8ac7d16195e64a31d50b2a30aa8262" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="a87585b69b086c147f372f2e5a1d39fb50ad8a31" translate="yes" xml:space="preserve">
          <source>Qualified calls (remote calls)</source>
          <target state="translated">적격 통화 (원격 통화)</target>
        </trans-unit>
        <trans-unit id="665a6bcf289c1518f036a63e86791885bb3d1c3f" translate="yes" xml:space="preserve">
          <source>Qualified calls, such as &lt;code&gt;Math.add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscores. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">&lt;code&gt;Math.add(1, 2)&lt;/code&gt; 와 같은 정규화 된 호출 은 대문자 나 제목이 아닌 밑줄 또는 유니 코드 문자로 시작해야합니다. 일련의 유니 코드 문자, 숫자 및 밑줄을 계속 사용하여 호출 할 수 있습니다. 통화가 끝날 수 &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; . 공식 사양 은 &lt;a href=&quot;unicode-syntax&quot;&gt;유니 코드 구문&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d3830748786cef6d1d371b9b4a4083c2ec61ee9" translate="yes" xml:space="preserve">
          <source>Quarter</source>
          <target state="translated">Quarter</target>
        </trans-unit>
        <trans-unit id="d47a22f953dc2b31cf6bc6440050b0aaf55f9649" translate="yes" xml:space="preserve">
          <source>Quote and macros</source>
          <target state="translated">견적 및 매크로</target>
        </trans-unit>
        <trans-unit id="398f0ab8b840b28a0fd354d1c0d7a72c7d9d306e" translate="yes" xml:space="preserve">
          <source>Quote and unquote</source>
          <target state="translated">견적 및 견적 해제</target>
        </trans-unit>
        <trans-unit id="d94e69560e301502d99603fd94eaa70bde805275" translate="yes" xml:space="preserve">
          <source>Quote is about retrieving the inner representation of some particular chunk of code. However, sometimes it may be necessary to inject some other particular chunk of code inside the representation we want to retrieve.</source>
          <target state="translated">인용문은 특정 코드 덩어리의 내부 표현을 검색하는 것입니다. 그러나 때로는 검색하려는 표현 안에 다른 특정 코드 덩어리를 삽입해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc325775a37291e9e0f216be4d97c9b52b5046b9" translate="yes" xml:space="preserve">
          <source>Quoted and unquoted atoms with the same name are considered equivalent, so &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;:&quot;atom&quot;&lt;/code&gt;, and &lt;code&gt;:'atom'&lt;/code&gt; represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.</source>
          <target state="translated">이름이 같은 따옴표 및 따옴표없는 원자는 동등한 것으로 간주되므로 &lt;code&gt;:atom&lt;/code&gt; , &lt;code&gt;:&quot;atom&quot;&lt;/code&gt; 및 &lt;code&gt;:'atom'&lt;/code&gt; 은 동일한 원자를 나타냅니다. 인용 할 필요가없는 원자에서 인용 부호를 사용할 때 컴파일러가 경고를 표시하는 것이 유일한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="3a432aa09de3e72168ea6a4c0658a86a59f5a08d" translate="yes" xml:space="preserve">
          <source>Quoted expression</source>
          <target state="translated">인용 표현</target>
        </trans-unit>
        <trans-unit id="1d3b684c7214d0c281c4454aed5c04034ff88811" translate="yes" xml:space="preserve">
          <source>Quoted identifiers, such as strings (&lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt;) and charlists (&lt;code&gt;'ol&amp;aacute;'&lt;/code&gt;), support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.</source>
          <target state="translated">문자열 ( &lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt; ) 및 &lt;code&gt;'ol&amp;aacute;'&lt;/code&gt; ( 'ol&amp;aacute;' ) 과 같은 따옴표 붙은 식별자는 Elixir v1.0부터 유니 코드를 지원합니다. 문자열은 UTF-8로 인코딩됩니다. Charlist는 유니 코드 코드 포인트 목록입니다. 이 경우 내용은 개발자가 작성한 그대로 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60fefb29eda0237f92306cb85899330ca8b230ee" translate="yes" xml:space="preserve">
          <source>Quoting</source>
          <target state="translated">Quoting</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="db712921d6fecc09e09fab853318c381738ce114" translate="yes" xml:space="preserve">
          <source>R1. Default Identifiers</source>
          <target state="translated">R1. 기본 식별자</target>
        </trans-unit>
        <trans-unit id="26b991df92308f2a367c957c4d50b613aa415ed2" translate="yes" xml:space="preserve">
          <source>R3. Pattern_White_Space and Pattern_Syntax Characters</source>
          <target state="translated">R3. Pattern_White_Space 및 Pattern_Syntax 문자</target>
        </trans-unit>
        <trans-unit id="64f597518b8819e33beed326e0aef13663d12b03" translate="yes" xml:space="preserve">
          <source>R6. Filtered Normalized Identifiers</source>
          <target state="translated">R6. 필터링 된 정규화 된 식별자</target>
        </trans-unit>
        <trans-unit id="6f4503a9f856bd401816cf9c9537b400021fea70" translate="yes" xml:space="preserve">
          <source>Race conditions?</source>
          <target state="translated">경쟁 조건?</target>
        </trans-unit>
        <trans-unit id="9dbe56f890ac8f921853592e6d6ef65ae4769f24" translate="yes" xml:space="preserve">
          <source>Raised to signal an assertion error.</source>
          <target state="translated">주장 오류를 알리기 위해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b1ea728487504127e3f68a3942530c7d9ee6815" translate="yes" xml:space="preserve">
          <source>Raised to signal multiple errors happened in a test case.</source>
          <target state="translated">테스트 케이스에서 여러 오류가 발생했음을 알리기 위해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8fdd3d5744b14fe8df2f78525ff278b3980dcf70" translate="yes" xml:space="preserve">
          <source>Raised when a struct cannot be inspected.</source>
          <target state="translated">구조체를 검사 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa9e03b9a6f82b7dabd4d26d477bd23b2afc1a4f" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">레이즈 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 주어진 경우 &lt;code&gt;padding&lt;/code&gt; 문자열이 아닌 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af83d7d1086d026fc286f4645bae49fd7306d517" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 숫자가 아닌 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d76c0d9f487f5fbe07e874551d88d47fee0d896" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">올린다 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;right&lt;/code&gt; 으로 0 또는 0.0이다.</target>
        </trans-unit>
        <trans-unit id="3c67dbd468ad8055254ab3928808c3935464e4ce" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;enum.emptyerror&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;enum.emptyerror&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; 는&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c86ffce180eacb8b7b1576ec8952dbfa09213a" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">레이즈 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 주어진 경우 &lt;code&gt;padding&lt;/code&gt; 문자열이 아닌 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e047a30fd33f30a0b414e8517dceb291fc56ab" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 숫자가 아닌 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a33babd84ffaff3913d153392a8557d0b13380" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">올린다 &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;right&lt;/code&gt; 으로 0 또는 0.0이다.</target>
        </trans-unit>
        <trans-unit id="811cd2f761326443b2a5258f1c2a68b97e94a132" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; 는&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d343a2295f4d5274dcbfd886a84ccb41642f80" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OutOfBoundsError&lt;/code&gt; if the given &lt;code&gt;index&lt;/code&gt; is outside the range of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">올린다 &lt;code&gt;OutOfBoundsError&lt;/code&gt; 가 지정된 경우에는 &lt;code&gt;index&lt;/code&gt; 의 범위를 벗어난 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1069e7348e0650333182303ea7b7927bda6e74" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 의&lt;/a&gt; 두 주어진 버전 중 하나를 분석 할 수없는 경우 예외를. 이미 파싱 된 버전이 주어지면이 함수는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d62f9ebd9e34654105a0b6ae931724ee62a02cc0" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 의&lt;/a&gt; 두 주어진 버전 중 하나를 분석 할 수없는 경우 예외를. 이미 구문 분석 된 버전이 제공되면이 기능은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cab5e5df328b4ddb83cc91a4e5866b2d049b9bdc" translate="yes" xml:space="preserve">
          <source>Raises a Mix error that is nicely formatted.</source>
          <target state="translated">형식이 좋은 믹스 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c1c33aaefd8234c7625624d93eaccbd66022ca1e" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">제기 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 의&lt;/a&gt; 인자 중 하나가 정수가 아닌 경우, 또는 경우에 예외를 &lt;code&gt;divisor&lt;/code&gt; 이다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dae7bfdecf9ccf167222b8627b4247b673a0a98" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">제기 &lt;a href=&quot;https://hexdocs.pm/elixir/ArithmeticError.html&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 의&lt;/a&gt; 인자 중 하나가 정수가 아닌 경우, 또는 경우에 예외를 &lt;code&gt;divisor&lt;/code&gt; 이다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f054f51eef773e350ffd8e720d8ef1c2f7f1d3" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;base&lt;/code&gt; is less than 2 or more than 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 이 2보다 작거나 36보다 크면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="81fe4cb7e7c869e7a34bf872a48cb536514bff12" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;supervisor&lt;/code&gt; has reached the maximum number of children.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 가 최대 자녀 수에 도달 하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f213a5266dc7fd081628bda995fed2c1460d6ab8" translate="yes" xml:space="preserve">
          <source>Raises an error if all conditions evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. For this reason, it may be necessary to add a final always-truthy condition (anything non-&lt;code&gt;false&lt;/code&gt; and non-&lt;code&gt;nil&lt;/code&gt;), which will always match.</source>
          <target state="translated">모든 조건이 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 평가되면 오류가 발생합니다 . 이러한 이유로, 최종 항상 truthy 조건 (아무것도 아닌 추가 할 필요가있을 수있다 &lt;code&gt;false&lt;/code&gt; 과 비 &lt;code&gt;nil&lt;/code&gt; 이 항상 일치).</target>
        </trans-unit>
        <trans-unit id="6807fc8ee18e17589e66f450694ceab675bbe0db" translate="yes" xml:space="preserve">
          <source>Raises an error if retrieving or changing the current directory fails.</source>
          <target state="translated">현재 디렉토리 검색 또는 변경에 실패하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="164b30096b2ea6dfc6e8c86db79c4ab887d2f1ec" translate="yes" xml:space="preserve">
          <source>Raises an error if the module was already compiled.</source>
          <target state="translated">모듈이 이미 컴파일 된 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ba05d6b0411d4457bd3803cd3e4d8649a31a71f" translate="yes" xml:space="preserve">
          <source>Raises an exception preserving a previous stacktrace.</source>
          <target state="translated">이전 스택 추적을 유지하는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="437ea54b50fe87d412f3bb3184bcdd4a6c352ece" translate="yes" xml:space="preserve">
          <source>Raises an exception.</source>
          <target state="translated">예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a4d46f156dd7b4a5a2ee33034cfcad27d106e75f" translate="yes" xml:space="preserve">
          <source>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</source>
          <target state="translated">날짜 시간이 유효하지 않은 경우 발생합니다. 잘못된 ISO 달력 날짜를 변환하려고하면 오류 튜플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="71d1ef80cf35651a172132daf389ed313ef6e315" translate="yes" xml:space="preserve">
          <source>Raises if the format is invalid.</source>
          <target state="translated">형식이 유효하지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6519231f297c411772999cd1e8103552ac99be07" translate="yes" xml:space="preserve">
          <source>Raising exceptions</source>
          <target state="translated">예외 발생</target>
        </trans-unit>
        <trans-unit id="359e09946a5a3b259a34bf421749cd9902b56698" translate="yes" xml:space="preserve">
          <source>Raising variant of &lt;a href=&quot;#break/4&quot;&gt;&lt;code&gt;break/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#break/4&quot;&gt; &lt;code&gt;break/4&lt;/code&gt; &lt;/a&gt; 의 상승 변형 .</target>
        </trans-unit>
        <trans-unit id="6dd2c631ba3a5be13e118569eba6eb843de07c72" translate="yes" xml:space="preserve">
          <source>Raising variant of &lt;a href=&quot;#break/6&quot;&gt;&lt;code&gt;break/6&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#break/6&quot;&gt; &lt;code&gt;break/6&lt;/code&gt; &lt;/a&gt; 의 상승 변형 .</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="7831a9dadc261148b4dba32a72a2bfd0aa16960e" translate="yes" xml:space="preserve">
          <source>Range creation operator. Returns a range with the specified &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; integers.</source>
          <target state="translated">범위 생성 연산자. 지정된 &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; 정수가 있는 범위를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="72464e74832155795bb0fc97baa40a95fbc7222b" translate="yes" xml:space="preserve">
          <source>Ranges can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). Ranges are also always inclusive.</source>
          <target state="translated">범위는 증가 ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) 또는 감소 ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ) 일 수 있습니다. 범위도 항상 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd90679e7f8a9b39ae9a6c5d2cc092800f54ef9" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;date#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">범위는 &lt;a href=&quot;date#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt; 함수 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7623f13ae92ca005b307bb293cb91d086ea3ae25" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Date.html#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 범위를 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d488a3099ab1cce2c7739fdbf692916264525f0d" translate="yes" xml:space="preserve">
          <source>Ranges of dates can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). They are also always inclusive.</source>
          <target state="translated">날짜 범위는 증가 ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) 또는 감소 ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ) 일 수 있습니다. 그들은 또한 항상 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5ae0f1f0ad1824c4af633686b21c1609c50dc0c2" translate="yes" xml:space="preserve">
          <source>Ranges represent a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">범위는 하나 이상의 연속적인 오름차순 또는 내림차순 정수의 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a225b1af2c34f53e990659786a3df7dde051221" translate="yes" xml:space="preserve">
          <source>Raw files</source>
          <target state="translated">원시 파일</target>
        </trans-unit>
        <trans-unit id="43be5d1fec74173cc456fcdb989d79f3a6d61e9b" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module documentation for more information about the general usage of &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#async/3&quot;&gt;&lt;code&gt;async/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#async/3&quot;&gt; &lt;code&gt;async/3&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법에 대한 자세한 정보 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 모듈 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0788c3b600d4f3c0505743b96b49889736ec2d75" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">typespecs 및 비트 열에 대한 자세한 내용 은 &lt;code&gt;Typespec&lt;/code&gt; 페이지 및 &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; 의 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b03a7abf79ea89d9cecc8c93151a283ebf7f7fbb" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">&lt;code&gt;Typespec&lt;/code&gt; 페이지와 &lt;a href=&quot;#%3C%3C%3E%3E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; 의 문서를 읽고 각각 typespecs 및 bitstrings에 대한 자세한 내용을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3889ae6a98ae0e53caf306c3aba6c242dcedd31" translate="yes" xml:space="preserve">
          <source>Reads a line from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 라인을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ed6358cfae9ed346de26368ca0c1a237b2160331" translate="yes" xml:space="preserve">
          <source>Reads a timer created by &lt;a href=&quot;#send_after/3&quot;&gt;&lt;code&gt;send_after/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_after/3&quot;&gt; &lt;code&gt;send_after/3&lt;/code&gt; 에&lt;/a&gt; 의해 작성된 타이머를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="31e0122bb1cd5932aff410ddb26d3668b99408af" translate="yes" xml:space="preserve">
          <source>Reads and writes attributes of the current module.</source>
          <target state="translated">현재 모듈의 속성을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="e5909314d3283d89421e87193f2a66ac8fa016fa" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="812e657f5b579f0750a1f48f3ac381f21e7e7a7d" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;. The operation is Unicode unsafe.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 읽습니다 . 작업이 유니 코드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1e72b88bea14f6ca08acd272c7aa85760735eeb" translate="yes" xml:space="preserve">
          <source>Reads registry metadata given on &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; 에 제공된 레지스트리 메타 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d3a6912210c72237f3cf73a18ef9afb3a5bf363f" translate="yes" xml:space="preserve">
          <source>Reads the application environment at compilation time or raises.</source>
          <target state="translated">컴파일 시간 또는 발생시 애플리케이션 환경을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0b6a82b2378ffd360095c83ed0539589a6586d33" translate="yes" xml:space="preserve">
          <source>Reads the application environment at compilation time.</source>
          <target state="translated">Reads the application environment at compilation time.</target>
        </trans-unit>
        <trans-unit id="6e4bfe8b8059fffe67509581ca8fd8bb5863a979" translate="yes" xml:space="preserve">
          <source>Reads the client request and writes a response back</source>
          <target state="translated">클라이언트 요청을 읽고 응답을 다시 씁니다.</target>
        </trans-unit>
        <trans-unit id="d5eb24730d097e029875864fbd190d1f5f20b06f" translate="yes" xml:space="preserve">
          <source>Reads the configuration file.</source>
          <target state="translated">구성 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="dc12f308ba360c8064a3568dfa28b47e57204e51" translate="yes" xml:space="preserve">
          <source>Reads the current process metadata.</source>
          <target state="translated">현재 프로세스 메타 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c48fac6c8d1d06337a98d9b155bf84f8445d1d91" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file alongside its imports.</source>
          <target state="translated">주어진 구성 파일을 가져 오기와 함께 읽습니다.</target>
        </trans-unit>
        <trans-unit id="996f074d974ca465971e392485cd9fe090583830" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file and returns the configuration with its imports.</source>
          <target state="translated">Reads the given configuration file and returns the configuration with its imports.</target>
        </trans-unit>
        <trans-unit id="6d834acb879e83f8d42700d86e86927b636c6aea" translate="yes" xml:space="preserve">
          <source>Reads the symbolic link at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 심볼릭 링크를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9c1cdacc82e6db0a4e1b004d6bdbb8cec9ef88a1" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and deletes the first tuple where the element at &lt;code&gt;position&lt;/code&gt; matches the given &lt;code&gt;key&lt;/code&gt;. Returns the new list.</source>
          <target state="translated">수신 &lt;code&gt;list&lt;/code&gt; 튜플과 소자의 제 튜플 삭제 &lt;code&gt;position&lt;/code&gt; 지정된 일치 &lt;code&gt;key&lt;/code&gt; . 새로운리스트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5c5edba47e63948282ba7aa49263dd69fdc08f5b" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and replaces the element identified by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;list&lt;/code&gt; 을 수신하고 &lt;code&gt;position&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 식별 된 요소 를 &lt;code&gt;new_tuple&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="52a2ed027070830b2b704b10a1ab579fee6aa05a" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;, as well as the &lt;code&gt;list&lt;/code&gt; without found tuple.</source>
          <target state="translated">수신 &lt;code&gt;list&lt;/code&gt; 튜플을하고있는 요소 첫 번째 튜플 반환 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; 뿐만 아니라 &lt;code&gt;list&lt;/code&gt; 을 발견 튜플 않고 있습니다.</target>
        </trans-unit>
        <trans-unit id="53639bc3bc3a88fb72d354e316fd411a08ad54fc" translate="yes" xml:space="preserve">
          <source>Receives a key-value enumerable and converts it to &lt;a href=&quot;#t:argv/0&quot;&gt;&lt;code&gt;argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 가능한 키-값을 받아서 &lt;a href=&quot;#t:argv/0&quot;&gt; &lt;code&gt;argv/0&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a8cddc4edd4b8cb647e915685f66b6aa81c4ae" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; (workers or supervisors) to supervise and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">감독 할 &lt;code&gt;children&lt;/code&gt; (작업자 또는 감독자) 목록 과 &lt;code&gt;options&lt;/code&gt; 세트를 받습니다.</target>
        </trans-unit>
        <trans-unit id="fe2e430f09d68bd297bf576261b80cdda5635920" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; to initialize and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">초기화 할 &lt;code&gt;children&lt;/code&gt; 목록 과 &lt;code&gt;options&lt;/code&gt; 집합을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="4f56a4374996752d9c7b0d8cda70d77fc3e98719" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and if the identified element by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; exists, it is replaced with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">튜플들의 목록을 수신하여 상기 식별 소자 경우 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;position&lt;/code&gt; 존재하며, 그것으로 치환 &lt;code&gt;new_tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1535576671aa2ff6cdb67db512b203dfc4edba" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns &lt;code&gt;true&lt;/code&gt; if there is a tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">튜플 반환 목록 수신 &lt;code&gt;true&lt;/code&gt; 있는 요소 튜플이있는 경우 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f773b7b4671a15478a78104b05a8ac1289c68e25" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">튜플의리스트를 수신하고있는 요소 첫 번째 튜플 반환 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da55da43556e6c04aee3a123495216a662a853e8" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and sorts the elements at &lt;code&gt;position&lt;/code&gt; of the tuples. The sort is stable.</source>
          <target state="translated">튜플 목록을 수신하고 튜플 &lt;code&gt;position&lt;/code&gt; 에서 요소를 정렬합니다 . 정렬이 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="14e20d5c24dff9fd9fe9735cab3e8e1de2a2fe94" translate="yes" xml:space="preserve">
          <source>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">모듈, 재미 및 arity를 ​​수신하고 스택 추적에 표시된대로 형식을 지정합니다. arity는 인수 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e687df4d6dc594b8acd5822458421f8788bb8599" translate="yes" xml:space="preserve">
          <source>Receives a protocol and a list of implementations and consolidates the given protocol.</source>
          <target state="translated">프로토콜 및 구현 목록을 수신하고 지정된 프로토콜을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="22210bb4fc25b4244ff90b5d68a7d14f3ce7571b" translate="yes" xml:space="preserve">
          <source>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement.</source>
          <target state="translated">정규식, 바이너리 및 대체를 수신하고 모든 일치 항목이 대체로 대체되는 새 바이너리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b61e49df8ff67a9ca03bd1b42a8bb519e4a1c105" translate="yes" xml:space="preserve">
          <source>Receives a set of &lt;code&gt;options&lt;/code&gt; that initializes a dynamic supervisor.</source>
          <target state="translated">동적 감독자를 초기화하는 &lt;code&gt;options&lt;/code&gt; 세트를받습니다 .</target>
        </trans-unit>
        <trans-unit id="d9f6da4d53fe4ab814d14ca17ef2d1aa84915fba" translate="yes" xml:space="preserve">
          <source>Receives a stacktrace entry and formats it into a string.</source>
          <target state="translated">스택 추적 항목을 받아서 문자열로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="be2efbf787eb31d5be3cc076dff27bc518a35202" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the corresponding task module.</source>
          <target state="translated">Receives a task name and retrieves the corresponding task module.</target>
        </trans-unit>
        <trans-unit id="e7746187c8e8540596d6f16990c4f1faef1d5f41" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the task module.</source>
          <target state="translated">작업 이름을 받고 작업 모듈을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9482cbe5474f9102533e9e68071d3fd7743238f4" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the corresponding task module if one exists.</source>
          <target state="translated">Receives a task name and returns the corresponding task module if one exists.</target>
        </trans-unit>
        <trans-unit id="b879ac32fa8c2699d4481ef4abf60cb310c50593" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the task module if found.</source>
          <target state="translated">작업 이름을 받고 작업 모듈을 찾으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cac5740e1e65c9728fb7126ef3505b66eac12f3" translate="yes" xml:space="preserve">
          <source>Receives a test and formats its failure.</source>
          <target state="translated">Receives a test and formats its failure.</target>
        </trans-unit>
        <trans-unit id="0976194fd3c75699f15dd6f56c0a05b5f408d271" translate="yes" xml:space="preserve">
          <source>Receives a test module and formats its failure.</source>
          <target state="translated">Receives a test module and formats its failure.</target>
        </trans-unit>
        <trans-unit id="98d45f98af3936ac871d1b420e669aa3ba75d6f8" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it once.</source>
          <target state="translated">AST 노드를 받아서 한 번 확장합니다.</target>
        </trans-unit>
        <trans-unit id="ed69a15b3b64f165dbfcf50544a8d1db805c1151" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it until it can no longer be expanded.</source>
          <target state="translated">AST 노드를 받아서 더 이상 확장 할 수 없을 때까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="157d1b07d7f33e05788480f92dab05c717cb2225" translate="yes" xml:space="preserve">
          <source>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">익명 함수 및 arity를 ​​수신하고 stacktrace에 표시된대로 형식화합니다. arity는 인수 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="828e3869ea6e3d553f5eaefa42fd41690b88d620" translate="yes" xml:space="preserve">
          <source>Receives any argument (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if the argument is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">부울뿐만 아니라 모든 인수를 수신 하고 인수가 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 반환 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="c743fb2a47a95b2574687dfecdcb831b67c205c2" translate="yes" xml:space="preserve">
          <source>Receives any value (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Receives any value (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; ; returns &lt;code&gt;false&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="ca67f922cda85a2c22c1236201d70d4e42246095" translate="yes" xml:space="preserve">
          <source>Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.</source>
          <target state="translated">Receives command-line arguments and performs compilation. If it produces errors, warnings, or any other diagnostic information, it should return a tuple with the status and a list of diagnostics.</target>
        </trans-unit>
        <trans-unit id="43850c741265049e669da2f26b793fdc8099376d" translate="yes" xml:space="preserve">
          <source>Receives two log levels and compares the &lt;code&gt;left&lt;/code&gt; level against the &lt;code&gt;right&lt;/code&gt; level and returns:</source>
          <target state="translated">두 개의 로그 레벨을 수신하고 &lt;code&gt;left&lt;/code&gt; 레벨을 &lt;code&gt;right&lt;/code&gt; 레벨과 비교하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="db37e93aec89a6614c4173a17f53a9d6b9aaf43e" translate="yes" xml:space="preserve">
          <source>Receives two options and must return &lt;code&gt;true&lt;/code&gt; if they refer to the same repository. The options are guaranteed to belong to the same SCM.</source>
          <target state="translated">Receives two options and must return &lt;code&gt;true&lt;/code&gt; if they refer to the same repository. The options are guaranteed to belong to the same SCM.</target>
        </trans-unit>
        <trans-unit id="95c9f8acfe3b80419501346e27b07cd7c2e9cb26" translate="yes" xml:space="preserve">
          <source>Receiving &quot;regular&quot; messages</source>
          <target state="translated">&quot;정기적 인&quot;메시지 수신</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="874c8febf7705c239b56db21c6da13bb314c78a3" translate="yes" xml:space="preserve">
          <source>Recompiles and reloads the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; 다시 컴파일하고 다시로드합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fd4d9956d6c550135e0c055d986e451b87cd45" translate="yes" xml:space="preserve">
          <source>Recompiles the current Mix application.</source>
          <target state="translated">현재 믹스 애플리케이션을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="5956d214121812f6fd8d760fc2d0039205cb4995" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.CompileError.html&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">Recompiles the existing regular expression and raises &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.CompileError.html&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; in case of errors.</target>
        </trans-unit>
        <trans-unit id="2cbd52477e5a038bbc04e1ed928ac44c43841076" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;regex.compileerror&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">기존 정규식을 다시 컴파일하고 오류 발생시 &lt;a href=&quot;regex.compileerror&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9512d561ed1cc337da6646bba4a0fe0f82cc1019" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression if necessary.</source>
          <target state="translated">필요한 경우 기존 정규식을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="f92fd6b1074e6e79dfba76d8cd7647ef66632e5a" translate="yes" xml:space="preserve">
          <source>Records are simply tuples where the first element is an atom:</source>
          <target state="translated">레코드는 단순히 첫 번째 요소가 원자 인 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="8f1975a7def41720ec9c94792bc4fc65a7c012e4" translate="yes" xml:space="preserve">
          <source>Recursion</source>
          <target state="translated">Recursion</target>
        </trans-unit>
        <trans-unit id="1e9eb42c791ec696e90bc24ffe375c923de0f651" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call&lt;/a&gt; optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</source>
          <target state="translated">재귀 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;꼬리 호출&lt;/a&gt; 최적화는 Elixir의 중요한 부분이며 일반적으로 루프를 만드는 데 사용됩니다. 그러나 Elixir에서 프로그래밍 할 때 위와 같이 재귀를 사용하여 목록을 조작하는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="90e048b53959a81bc3861b57069e375346d404f4" translate="yes" xml:space="preserve">
          <source>Recursively escapes a value so it can be inserted into a syntax tree.</source>
          <target state="translated">값을 재귀 적으로 이스케이프하여 구문 트리에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aa5f460115ac32f0d34ca300a72820b95cfe5a4" translate="yes" xml:space="preserve">
          <source>Redefining existing operators</source>
          <target state="translated">기존 연산자 재정의</target>
        </trans-unit>
        <trans-unit id="7be6f3bbac5cc51e4aafe0612e17d33124d8093b" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt; ) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt;, which are optimized by the runtime.</target>
        </trans-unit>
        <trans-unit id="5ec592dbd43af61e2cbf6d03b3e9ee6ca088c0f2" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">Reduce (때때로 &lt;code&gt;fold&lt;/code&gt; 라고도 함 )는 함수형 프로그래밍의 기본 구성 요소입니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 거의 모든 기능 은 reduce 외에 구현 될 수 있습니다. 이러한 함수는 종종 런타임에 의해 최적화되는 &lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; 과 같은 다른 작업에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="95a8f2e0d9b4cee6851a4ae983d29171ececc54e" translate="yes" xml:space="preserve">
          <source>Reduce and map algorithms</source>
          <target state="translated">알고리즘 축소 및 매핑</target>
        </trans-unit>
        <trans-unit id="32ab9de27d58bcc7d4d54b8d17c7484a6d29e607" translate="yes" xml:space="preserve">
          <source>Reduce as a building block</source>
          <target state="translated">빌딩 블록으로 축소</target>
        </trans-unit>
        <trans-unit id="6b8baf4751a0c397c470aa1b489e04d78981d396" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;enumerable&lt;/code&gt; until &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, term}&lt;/code&gt;.</source>
          <target state="translated">감소 &lt;code&gt;enumerable&lt;/code&gt; 될 때까지 &lt;code&gt;fun&lt;/code&gt; 반환 &lt;code&gt;{:halt, term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3fe1324757a1c4900c6719d6fc7cfb276e4826c" translate="yes" xml:space="preserve">
          <source>Reduces the &lt;code&gt;enumerable&lt;/code&gt; into an element.</source>
          <target state="translated">절감된다 &lt;code&gt;enumerable&lt;/code&gt; 된 요소로한다.</target>
        </trans-unit>
        <trans-unit id="2dbe68b1eeba6b24ea1fba9cc612db280c6c2f67" translate="yes" xml:space="preserve">
          <source>Reenables a given task so it can be executed again down the stack.</source>
          <target state="translated">주어진 작업을 다시 활성화하여 스택에서 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b03cbaefa850378932be35a87004bee63b000cd" translate="yes" xml:space="preserve">
          <source>Reference - a unique value in the runtime system, created with &lt;a href=&quot;#make_ref/0&quot;&gt;&lt;code&gt;make_ref/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">참조-런타임 시스템에서 고유 한 값으로 &lt;a href=&quot;#make_ref/0&quot;&gt; &lt;code&gt;make_ref/0&lt;/code&gt; 으로&lt;/a&gt; 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="51ad2be02b9697cd310cca4ee9b8b7aa0b47c088" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@callback&lt;/code&gt; by prepending &lt;code&gt;c:&lt;/code&gt;, as in &lt;code&gt;`c:world/1`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`c:world/1`&lt;/code&gt; 에서처럼 &lt;code&gt;c:&lt;/code&gt; 를 앞에 &lt;code&gt;@callback&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dbfb2cc2895149d87c5f4f6bbe82a4d53911ad9" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@type&lt;/code&gt; by prepending &lt;code&gt;t:&lt;/code&gt;, as in &lt;code&gt;`t:values/0`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`t:values/0`&lt;/code&gt; 에서처럼 &lt;code&gt;t:&lt;/code&gt; 를 앞에 &lt;code&gt;@type&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59cb3fcffb3799341188ccd1da595b261b4be7ab" translate="yes" xml:space="preserve">
          <source>Reference and functions for working with protocols.</source>
          <target state="translated">프로토콜 작업을위한 참조 및 기능.</target>
        </trans-unit>
        <trans-unit id="98efd6e2a6b118bb5b50c8bbc16e0f5cd3315ce0" translate="yes" xml:space="preserve">
          <source>Reference functions by name and arity if they are local, as in &lt;code&gt;`world/1`&lt;/code&gt;, or by module, name and arity if pointing to an external module: &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`world/1`&lt;/code&gt; 에서처럼 로컬에 있으면 이름과 arity 또는 외부 모듈을 가리키는 경우 모듈, 이름과 arity에 의해 함수를 참조하십시오 : &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26fa88e9bd1e552c7f736c12a86e4b0eb3d12567" translate="yes" xml:space="preserve">
          <source>Reference modules by their full name.</source>
          <target state="translated">전체 이름으로 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="105376683ec11cee0e5b5973530213234a5fd201" translate="yes" xml:space="preserve">
          <source>Refute received with an explicit timeout:</source>
          <target state="translated">명시적인 시간 초과로받은 반품 :</target>
        </trans-unit>
        <trans-unit id="8fd8f41db359717b5f94a5befb85555200773286" translate="yes" xml:space="preserve">
          <source>Regardless of whether &lt;code&gt;=&amp;gt;&lt;/code&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 또는 키워드 구문 사용 여부에 관계없이 맵의 키-값 쌍은 항상 내부적으로 단순성을 위해 두 개의 요소 튜플 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e681935761236016678d2656c1d667f0fe6fdac" translate="yes" xml:space="preserve">
          <source>Regex</source>
          <target state="translated">Regex</target>
        </trans-unit>
        <trans-unit id="ea0563594d23ed77538002a13830e067953e4a2b" translate="yes" xml:space="preserve">
          <source>Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's &lt;code&gt;:re&lt;/code&gt; module. More information can be found in the &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt;&lt;code&gt;:re&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">정규식은 PCRE (Perl Compatible Regular Expressions)를 기반으로하며 Erlang의 &lt;code&gt;:re&lt;/code&gt; 모듈 위에 구축되었습니다 . 자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt; &lt;code&gt;:re&lt;/code&gt; 모듈 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e7ac6184c6bddf346a5bb04f8cb4bb31ff3c577" translate="yes" xml:space="preserve">
          <source>Regex supports several built in named character classes. These are used by enclosing the class name in &lt;code&gt;[: :]&lt;/code&gt; inside a group. For example:</source>
          <target state="translated">정규식은 여러 내장 된 명명 된 문자 클래스를 지원합니다. 이것들은 그룹 내부 의 클래스 이름을 &lt;code&gt;[: :]&lt;/code&gt; 로 묶어서 사용됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f4773b8001d2a236f1f42a57de7334762ef6a6f" translate="yes" xml:space="preserve">
          <source>Regex.CompileError</source>
          <target state="translated">Regex.CompileError</target>
        </trans-unit>
        <trans-unit id="2b2c167065a8849bc602af6807d29b6301a6af4e" translate="yes" xml:space="preserve">
          <source>Regex.CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Regex.CompileError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="921e80bd802450f0a54f55dc59c8a5c73048f3e4" translate="yes" xml:space="preserve">
          <source>Registering under a unique registry does not allow multiple entries:</source>
          <target state="translated">고유 한 레지스트리에 등록하면 여러 항목을 입력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b68501359664aa7e3f357030fc262fc752fa96a" translate="yes" xml:space="preserve">
          <source>Registers a &lt;code&gt;pluralization&lt;/code&gt; for &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; 대한 &lt;code&gt;pluralization&lt;/code&gt; 을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="04ed12562caa517bd68845482c54c6b549957f99" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of an Elixir script. A script is typically started via the command line via the &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; executables.</source>
          <target state="translated">Registers a function that will be invoked at the end of an Elixir script. A script is typically started via the command line via the &lt;code&gt;elixir&lt;/code&gt; and &lt;code&gt;mix&lt;/code&gt; executables.</target>
        </trans-unit>
        <trans-unit id="cfbc6d24a7a7f0d56fb406aa6036b3e12ffb8353" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of program execution. Useful for invoking a hook in &quot;script&quot; mode.</source>
          <target state="translated">프로그램 실행이 끝날 때 호출 될 함수를 등록합니다. &quot;스크립트&quot;모드에서 후크를 호출하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2177c0410d7f5895415b852d1e80afeff722f655" translate="yes" xml:space="preserve">
          <source>Registers a function to be invoked after the IEx process is spawned.</source>
          <target state="translated">IEx 프로세스가 생성 된 후 호출 할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="b7cdc0be7757e71f965b3c7ad3fb440f76e506dd" translate="yes" xml:space="preserve">
          <source>Registers a function to run as part of this case.</source>
          <target state="translated">이 경우에 실행할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="b973e327e3c021c877cc4d29399fa35fa83e3213" translate="yes" xml:space="preserve">
          <source>Registers a new attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 테스트 중에 사용할 새 속성을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="583a8d9a759b7139876cb9b18fbc6688dbc5db4b" translate="yes" xml:space="preserve">
          <source>Registers a new describe attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">Registers a new describe attribute to be used during &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; tests.</target>
        </trans-unit>
        <trans-unit id="ab70f6a8bd63201ad0973a2ca0e7972e2ffc3bc3" translate="yes" xml:space="preserve">
          <source>Registers a new module attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">Registers a new module attribute to be used during &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; tests.</target>
        </trans-unit>
        <trans-unit id="0e8cf2b4cc8729f25da603ab355783aa05318c46" translate="yes" xml:space="preserve">
          <source>Registers a program exit handler function.</source>
          <target state="translated">프로그램 종료 핸들러 기능을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="86f9550834cf29f2c28787220b59431f4c42e38c" translate="yes" xml:space="preserve">
          <source>Registers an attribute.</source>
          <target state="translated">속성을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="949e454436ebf7fa4a322e7a723b37231ac63ba1" translate="yes" xml:space="preserve">
          <source>Registers the current process under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 아래에 현재 프로세스 를 &lt;code&gt;registry&lt;/code&gt; 에 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="f5cea0af6cc948234d2b641ef218832cc68cbc8f" translate="yes" xml:space="preserve">
          <source>Registers the default &lt;code&gt;port&lt;/code&gt; for the given &lt;code&gt;scheme&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;scheme&lt;/code&gt; 의 기본 &lt;code&gt;port&lt;/code&gt; 를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="3f29bbe119d2296da4e21436992a76df3eb6cb3e" translate="yes" xml:space="preserve">
          <source>Registers the given &lt;code&gt;pid_or_port&lt;/code&gt; under the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;pid_or_port&lt;/code&gt; 를 주어진 &lt;code&gt;name&lt;/code&gt; 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="dddbe6429e016c47c4e1888ab89c26f58346135b" translate="yes" xml:space="preserve">
          <source>Registrations</source>
          <target state="translated">Registrations</target>
        </trans-unit>
        <trans-unit id="435305e548b36c7d783e828784397c394c2d994b" translate="yes" xml:space="preserve">
          <source>Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function.</source>
          <target state="translated">레지스트리는 이전 섹션과 유사하게 &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 로컬의 비 분배 확장 가능 PubSub를 구현하는 데 사용될 수 있습니다 . 주어진 모듈 기능.</target>
        </trans-unit>
        <trans-unit id="1fd6a805dae745c87a8b89f1be1a738e608a1668" translate="yes" xml:space="preserve">
          <source>Registry</source>
          <target state="translated">Registry</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="dbb5498e44eab5d71617ba625dacbfc1473d84fe" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, OS and architecture as as the target.</source>
          <target state="translated">sigil로 &lt;code&gt;.beam&lt;/code&gt; 정규식은 사전 컴파일되어 .beam 파일에 저장됩니다 . 사전 컴파일 된 정규식은 런타임에 검사되며 운영 체제와 OTP 릴리스간에 느리게 작동 할 수 있습니다. 개발 중에 공유되는 대부분의 Elixir 코드가 대상 (예 : 종속성, 아카이브 및 escript)에서 컴파일되고 프로덕션에서 실행될 때 코드가 대상에서 컴파일되어야합니다 ( &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 또는 유사). ) 또는 대상으로 일치하는 OTP, OS 및 아키텍처 를 사용하여 호스트에서 ( &lt;code&gt;mix releases&lt;/code&gt; 또는 유사 를 통해 ) 릴리스됩니다 .</target>
        </trans-unit>
        <trans-unit id="c18d56d63d8904587c2f989ef872b0c37d5a9db3" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, operating system and architecture as the target.</source>
          <target state="translated">Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, operating system and architecture as the target.</target>
        </trans-unit>
        <trans-unit id="ce246b29555944fc83b19767b567b76c5bfeb132" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Note that this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Note that this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</target>
        </trans-unit>
        <trans-unit id="75480c7e2a8cd4b557d0d4e69e47d2fba660d6e0" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Notice this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">&lt;code&gt;.beam&lt;/code&gt; 를 통해 생성 된 정규식은 사전 컴파일되어 .beam 파일에 저장 됩니다. Elixir를 사전 컴파일하는 경우 이것이 문제가 될 수 있습니다. 자세한 내용은 &quot;사전 컴파일&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e228ec906344d281422481da789e9a8c7ed3c4b" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="662de58b3e1c7961e52834df747a357eb8207007" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~r&lt;/code&gt; ( Kernel.sigil_r / 2 참조 ) 또는 &lt;code&gt;~R&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt; 참조 )을 사용하여 Elixir의 정규 표현식을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33dc63899c782dfe565d47daa688821ea2c061ac" translate="yes" xml:space="preserve">
          <source>Reigsters a test with the given environment.</source>
          <target state="translated">Reigsters a test with the given environment.</target>
        </trans-unit>
        <trans-unit id="8fa41d59c259d95cfaded10953d5a2f8e0b38bb4" translate="yes" xml:space="preserve">
          <source>Releases</source>
          <target state="translated">Releases</target>
        </trans-unit>
        <trans-unit id="da14bf586c00c0b2d6a162b461c2222bd3a8fda0" translate="yes" xml:space="preserve">
          <source>Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are:</source>
          <target state="translated">릴리스를 통해 개발자는 모든 코드와 런타임을 하나의 단위로 사전 컴파일하고 패키지 할 수 있습니다. 릴리스의 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6e22d2a45a39c91d823d515c586ebf0bbb7339d" translate="yes" xml:space="preserve">
          <source>Releases also provide built-in hooks for configuring almost every need of the production system:</source>
          <target state="translated">릴리스는 또한 거의 모든 프로덕션 시스템 요구를 구성하기위한 내장 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a98ea8e5fe18fa20e35b285b416e9080c681c806" translate="yes" xml:space="preserve">
          <source>Releases also supports custom mechanisms, called config providers, to load any sort of runtime configuration to the system while it boots. For instance, if you need to access a vault or load configuration from a JSON file, it can be achieved with config providers. The runtime configuration outlined in the previous section, which is handled by the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt;&lt;code&gt;Config.Reader&lt;/code&gt;&lt;/a&gt; provider. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Provider.html&quot;&gt;&lt;code&gt;Config.Provider&lt;/code&gt;&lt;/a&gt; module for more information and more examples.</source>
          <target state="translated">Releases also supports custom mechanisms, called config providers, to load any sort of runtime configuration to the system while it boots. For instance, if you need to access a vault or load configuration from a JSON file, it can be achieved with config providers. The runtime configuration outlined in the previous section, which is handled by the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Reader.html&quot;&gt; &lt;code&gt;Config.Reader&lt;/code&gt; &lt;/a&gt; provider. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Config.Provider.html&quot;&gt; &lt;code&gt;Config.Provider&lt;/code&gt; &lt;/a&gt; module for more information and more examples.</target>
        </trans-unit>
        <trans-unit id="4cae294f1ed142ab204367e07015be3d423fed8f" translate="yes" xml:space="preserve">
          <source>Releases are well integrated with umbrella projects, allowing you to release one or more subsets of your umbrella children. The only difference between performing a release in the umbrella project compared to a regular application is that umbrellas require you to explicitly list your release and the starting point for each release. For example, imagine this umbrella applications:</source>
          <target state="translated">Releases are well integrated with umbrella projects, allowing you to release one or more subsets of your umbrella children. The only difference between performing a release in the umbrella project compared to a regular application is that umbrellas require you to explicitly list your release and the starting point for each release. For example, imagine this umbrella applications:</target>
        </trans-unit>
        <trans-unit id="ac2e1d2cd0964546138b0360f4dc93a204d6dfac" translate="yes" xml:space="preserve">
          <source>Releases provides two mechanisms for configuring OTP applications: build-time and runtime.</source>
          <target state="translated">Releases provides two mechanisms for configuring OTP applications: build-time and runtime.</target>
        </trans-unit>
        <trans-unit id="c9ca4a52a1dd10eb55da61c20c8394066a84c979" translate="yes" xml:space="preserve">
          <source>Relevant Type(s)</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="a5e5c7fbabf94e041bedf3cf78e00e95d579c10d" translate="yes" xml:space="preserve">
          <source>Remember Elixir makes a distinction between anonymous functions and named functions, where the former must be invoked with a dot (&lt;code&gt;.&lt;/code&gt;) between the variable name and parentheses. The capture operator bridges this gap by allowing named functions to be assigned to variables and passed as arguments in the same way we assign, invoke and pass anonymous functions.</source>
          <target state="translated">Elixir는 익명 함수와 명명 된 함수를 구분합니다. 여기서 변수 이름과 괄호 사이에 점 ( &lt;code&gt;.&lt;/code&gt; )을 사용하여 전자를 호출해야합니다 . 캡처 연산자는 명명 된 함수를 변수에 할당하고 익명 함수를 할당, 호출 및 전달하는 것과 같은 방식으로 인수로 전달함으로써 이러한 격차를 해소합니다.</target>
        </trans-unit>
        <trans-unit id="943e7d08a29ef9d83c317d0436320ee8105342c6" translate="yes" xml:space="preserve">
          <source>Remember however that our &lt;code&gt;KV.Registry&lt;/code&gt; is both linking (via &lt;code&gt;start_link&lt;/code&gt;) and monitoring (via &lt;code&gt;monitor&lt;/code&gt;) bucket processes in the &lt;code&gt;handle_cast/2&lt;/code&gt; callback:</source>
          <target state="translated">우리의 것을 그러나 기억 &lt;code&gt;KV.Registry&lt;/code&gt; 을 (를 통해 연결 둘 다 &lt;code&gt;start_link&lt;/code&gt; )과 (을 통해 모니터링 &lt;code&gt;monitor&lt;/code&gt; 에) 버킷 프로세스를 &lt;code&gt;handle_cast/2&lt;/code&gt; 콜백 :</target>
        </trans-unit>
        <trans-unit id="2339016231a3f611f706a0ff8268e0aeed0a9afe" translate="yes" xml:space="preserve">
          <source>Remember lists are literals, so they are represented as themselves in the AST:</source>
          <target state="translated">리스트는 리터럴이므로 AST에서 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9201bbeed5d03751538444a9bdfa2b7a2f29888" translate="yes" xml:space="preserve">
          <source>Remember that the name of a process can be any atom. So far, we have named processes with the same name as the modules that define their implementation. For example, the process defined by &lt;code&gt;KV.Registry&lt;/code&gt; was given a process name of &lt;code&gt;KV.Registry&lt;/code&gt;. This is simply a convention: If later there is an error in your system that says, &amp;ldquo;process named KV.Registry crashed with reason&amp;rdquo;, we know exactly where to investigate.</source>
          <target state="translated">프로세스 이름은 임의의 원자가 될 수 있습니다. 지금까지 구현을 정의하는 모듈과 동일한 이름으로 프로세스의 이름을 지정했습니다. 예를 들어, &lt;code&gt;KV.Registry&lt;/code&gt; 에 의해 정의 된 프로세스에는 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스 이름이 지정 되었습니다 . 이것은 컨벤션입니다. 나중에 시스템에 &quot;KV.Registry라는 프로세스가 이유와 충돌했습니다&quot;라는 오류가 발생하면 조사 할 위치를 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23460e1d638c5436d4d647608a0c43461b2bb03" translate="yes" xml:space="preserve">
          <source>Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals).</source>
          <target state="translated">목록과 두 요소로 된 튜플은 리터럴로 인용되므로 정의에 따라 키워드도 리터럴입니다 (사실, 두 요소로 된 튜플이 리터럴로 인용되는 유일한 이유는 키워드를 리터럴로 지원하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="23ca97c0da01ca937235d0fce860a266449eb7f4" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="547521c843600e88d013eb66991d1b7a08d0987f" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 유니 코드 grapheme과 함께 작동하며 grapheme 오프셋을 나타내는 슬라이스를 고려합니다. 원시 바이트로 분할하려면 대신 &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5668edb8bbd3eda0d96d572b8d98aa2a38819f28" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Remember, comparisons in Elixir using &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%3C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; function.</target>
        </trans-unit>
        <trans-unit id="698cb20e961ee6d1a5f74b94b2a7a5aa2f31ae4b" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; 및 친구를 사용한 Elixir의 비교 는 구조적이며 DateTime 구조체 필드를 기반으로합니다. 날짜 / 시간을 올바르게 비교하려면 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3e2da127048c057fb60ede4b80ce4e8696a1366" translate="yes" xml:space="preserve">
          <source>Remember: by default, tasks will only run &lt;em&gt;once&lt;/em&gt;, even when called repeatedly! If you need to run a task multiple times, you need to re-enable it via &lt;a href=&quot;#reenable/1&quot;&gt;&lt;code&gt;reenable/1&lt;/code&gt;&lt;/a&gt; or call it using &lt;a href=&quot;#rerun/2&quot;&gt;&lt;code&gt;rerun/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Remember: by default, tasks will only run &lt;em&gt;once&lt;/em&gt;, even when called repeatedly! If you need to run a task multiple times, you need to re-enable it via &lt;a href=&quot;#reenable/1&quot;&gt; &lt;code&gt;reenable/1&lt;/code&gt; &lt;/a&gt; or call it using &lt;a href=&quot;#rerun/2&quot;&gt; &lt;code&gt;rerun/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="27bb052d1b6cca59f0d8b8e080407897e513da28" translate="yes" xml:space="preserve">
          <source>Remote shells</source>
          <target state="translated">원격 쉘</target>
        </trans-unit>
        <trans-unit id="12e6e0a5538b479310c7704c6dff0686bcae2732" translate="yes" xml:space="preserve">
          <source>Remote types</source>
          <target state="translated">원격 유형</target>
        </trans-unit>
        <trans-unit id="ad7183d89f1b9dc5b75d0fb7a74934c2fe82e722" translate="yes" xml:space="preserve">
          <source>Removes a backend.</source>
          <target state="translated">백엔드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6b3c529ef7158c6c64f36c40c48665d4b841a4dc" translate="yes" xml:space="preserve">
          <source>Removes a translator.</source>
          <target state="translated">번역기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0e523878ea75291793b504604435509973416467" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 에서 모든 중단 점 및 계측을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="6f725a049c858ae90de002f7c340c653cf53f9e1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from all modules.</source>
          <target state="translated">모든 모듈에서 모든 중단 점 및 계측을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0c59f67c00483a329a14a7b40d25018f4823a4d1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints on all modules.</source>
          <target state="translated">Removes all breakpoints on all modules.</target>
        </trans-unit>
        <trans-unit id="5cde5498611d5dd73ab4c8f8109c899ca9bbce1f" translate="yes" xml:space="preserve">
          <source>Removes an element from a tuple.</source>
          <target state="translated">튜플에서 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ca2eeb651ddbe44b65f869a519694352fefd12dc" translate="yes" xml:space="preserve">
          <source>Removes breakpoints in the given module.</source>
          <target state="translated">Removes breakpoints in the given module.</target>
        </trans-unit>
        <trans-unit id="fafc63cde6615c4f223d05bb8ce9168548859c5d" translate="yes" xml:space="preserve">
          <source>Removes build artifacts and manifests.</source>
          <target state="translated">Removes build artifacts and manifests.</target>
        </trans-unit>
        <trans-unit id="e12499048521db44dd18f757b10e57bb80774e3b" translate="yes" xml:space="preserve">
          <source>Removes files and directories recursively at the given &lt;code&gt;path&lt;/code&gt;. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 에서 파일과 디렉토리를 재귀 적으로 제거합니다 . 심볼릭 링크는 따르지 않고 단순히 제거되며 존재하지 않는 파일은 단순히 무시됩니다 (즉,이 기능이 실패하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="7baee7a478497d4737825218f8e15ac03e8c6030" translate="yes" xml:space="preserve">
          <source>Removes files from the required files list.</source>
          <target state="translated">필요한 파일 목록에서 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e097ba46638772c9b64fea773b1e61d5573174b4" translate="yes" xml:space="preserve">
          <source>Removes the entry with a given key from a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">컨테이너 ( &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 맵, 키워드 목록 또는 구조체)에서 지정된 키가있는 항목을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2ab0917eb6c0ad48d41081c9212ed112569e33de" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">오른쪽의 각 요소에 대해 왼쪽 목록에서 요소의 첫 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2610a285dc9b1c68c5713f9aeb89d588d07b8d11" translate="yes" xml:space="preserve">
          <source>Removes the link between the calling process and the given item (process or port).</source>
          <target state="translated">호출 프로세스와 주어진 항목 (프로세스 또는 포트) 사이의 링크를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f877e19fb1fb1b9f68495b6349dc80d7ef2d3e8e" translate="yes" xml:space="preserve">
          <source>Removes the registered &lt;code&gt;name&lt;/code&gt;, associated with a PID or a port identifier.</source>
          <target state="translated">PID 또는 포트 식별자와 연관된 등록 된 &lt;code&gt;name&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="e0ea432075489bb401a38e905e6c792c65da38b3" translate="yes" xml:space="preserve">
          <source>Removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and returns the value and the updated map.</source>
          <target state="translated">Removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; and returns the value and the updated map.</target>
        </trans-unit>
        <trans-unit id="e182592a215c0c2641cada9adb28ed54322e302f" translate="yes" xml:space="preserve">
          <source>Removes the variable &lt;code&gt;varname&lt;/code&gt; from the environment.</source>
          <target state="translated">환경에서 변수 &lt;code&gt;varname&lt;/code&gt; 을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1b55c9888c715281f3275cbe5053ffaabe0430" translate="yes" xml:space="preserve">
          <source>Renames the &lt;code&gt;source&lt;/code&gt; file to &lt;code&gt;destination&lt;/code&gt; file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the &lt;code&gt;destination&lt;/code&gt; filename, it is not sufficient to simply specify its directory.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 파일을 &lt;code&gt;destination&lt;/code&gt; 파일로 이름을 바꿉니다 . 디렉토리간에 파일 (및 디렉토리)을 이동하는 데 사용할 수 있습니다. 파일을 이동하는 경우 &lt;code&gt;destination&lt;/code&gt; 파일 이름을 완전히 지정해야 하며 단순히 디렉토리를 지정하는 것만으로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a91f5880024e32c1ee837d1bf3b64cc8dc6671b0" translate="yes" xml:space="preserve">
          <source>Replaced by (available since)</source>
          <target state="translated">로 대체 됨 (이후 사용 가능)</target>
        </trans-unit>
        <trans-unit id="3ae5fd3a5401d1295a4c3679a829706f16163c68" translate="yes" xml:space="preserve">
          <source>Replaces all leading occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; of &lt;code&gt;match&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">의 모든 주요 발생 대체 &lt;code&gt;match&lt;/code&gt; 에 의해 &lt;code&gt;replacement&lt;/code&gt; 의 &lt;code&gt;match&lt;/code&gt; 에서 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58f3e85bfde4f7a00e1a21674d997cd1b50094da" translate="yes" xml:space="preserve">
          <source>Replaces all trailing occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">모든 후행 발생 대체 &lt;code&gt;match&lt;/code&gt; 에 의해 &lt;code&gt;replacement&lt;/code&gt; 에 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d8aa6c1dd74b7f190708bea27805665c8cdf0e" translate="yes" xml:space="preserve">
          <source>Replaces prefix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">바꿉니다은 접두사 &lt;code&gt;string&lt;/code&gt; 로 &lt;code&gt;replacement&lt;/code&gt; 일치하는 경우 &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c08818204c69c938d93f26169b6a54dc9d5f052e" translate="yes" xml:space="preserve">
          <source>Replaces suffix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">대체합니다은에 접미사 &lt;code&gt;string&lt;/code&gt; 로 &lt;code&gt;replacement&lt;/code&gt; 일치하는 경우 &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61b72516eacbd25292524ef703f00e3b0cd63290" translate="yes" xml:space="preserve">
          <source>Replies to a client.</source>
          <target state="translated">클라이언트에게 응답합니다.</target>
        </trans-unit>
        <trans-unit id="fb22e2a0db174fb8119ed900f8cb0958c5ae7ca6" translate="yes" xml:space="preserve">
          <source>Report message (maps or keywords):</source>
          <target state="translated">Report message (maps or keywords):</target>
        </trans-unit>
        <trans-unit id="167f6ac2dbfd0e8be970571e54087bdd8130f746" translate="yes" xml:space="preserve">
          <source>Represents expressions in the AST</source>
          <target state="translated">AST의 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c6f57c3a5b6011834691a65157b80974d8047ca" translate="yes" xml:space="preserve">
          <source>Represents literals in the AST</source>
          <target state="translated">AST의 리터럴을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="e9c366b4f3c3a1bf3449c6872aaeae5a0c5ecdf4" translate="yes" xml:space="preserve">
          <source>Requirement</source>
          <target state="translated">Requirement</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="412cfb34df55659000dc3fda9977411aa50f05bf" translate="yes" xml:space="preserve">
          <source>Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; that work as one would expect, and additionally the special operator &lt;code&gt;~&amp;gt;&lt;/code&gt; described in detail further below.</source>
          <target state="translated">요구 사항을 사용하면 주어진 종속성의 버전을 지정할 수 있습니다. 요구 사항은 다음과 같은 일반적인 비교 연산자 지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; 그 일 하나를 기대하고, 추가로 특별한 연산자로 &lt;code&gt;~&amp;gt;&lt;/code&gt; 이 더 상세하게 설명한다.</target>
        </trans-unit>
        <trans-unit id="ffbcbcafa9cd3ab8fe7f3e0221d371de707c59bf" translate="yes" xml:space="preserve">
          <source>Requirements also support &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; for complex conditions:</source>
          <target state="translated">요구 사항은 또한 지원 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 복잡한 조건 :</target>
        </trans-unit>
        <trans-unit id="0a37ffbe744b3419c856886db8581bb258bdd52c" translate="yes" xml:space="preserve">
          <source>Requires a module in order to use its macros.</source>
          <target state="translated">매크로를 사용하려면 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bdc77107aca48a34c1255f765ae312ea22e9d590" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 피연산자 만 단락되므로 부울이어야합니다. 경우 &lt;code&gt;left&lt;/code&gt; 피연산자가 부울 아닌, &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3fb12553d92bde63ec6c4c1afb010869938df0d" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; exception is raised.</target>
        </trans-unit>
        <trans-unit id="3c1457fddb0ccb7c73dde9fb1360f8c49c8b2b74" translate="yes" xml:space="preserve">
          <source>Requires the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="1cda5e602ba0cf728e06b8efb2ddbc8599b5d662" translate="yes" xml:space="preserve">
          <source>Requires the given files in parallel.</source>
          <target state="translated">주어진 파일을 병렬로 요구합니다.</target>
        </trans-unit>
        <trans-unit id="652877b192a4527170621aec011fcd58f4d804ea" translate="yes" xml:space="preserve">
          <source>Reruns &lt;code&gt;task&lt;/code&gt; with the given arguments.</source>
          <target state="translated">재방송 &lt;code&gt;task&lt;/code&gt; 지정된 인수와.</target>
        </trans-unit>
        <trans-unit id="3303b4d51ecd1f3dd58871e5e01ec85056396381" translate="yes" xml:space="preserve">
          <source>Reserved module names</source>
          <target state="translated">예약 된 모듈 이름</target>
        </trans-unit>
        <trans-unit id="98d53aa320bfa9f3ee95a18c9df1aa09adb7fddb" translate="yes" xml:space="preserve">
          <source>Reserved words</source>
          <target state="translated">예약어</target>
        </trans-unit>
        <trans-unit id="97f4d7e17f03d2ddae5b33b0691e0061a8d5b3a6" translate="yes" xml:space="preserve">
          <source>Resets all attributes.</source>
          <target state="translated">모든 속성을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ace23ff1b1740ea142fd672118920a1baf0d8" translate="yes" xml:space="preserve">
          <source>Resets the breaks for the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt;.</source>
          <target state="translated">Resets the breaks for the given &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; and &lt;code&gt;arity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b232329f032cba2e9b444d62650b47ec21e40ea" translate="yes" xml:space="preserve">
          <source>Resets the breaks on a given breakpoint ID.</source>
          <target state="translated">Resets the breaks on a given breakpoint ID.</target>
        </trans-unit>
        <trans-unit id="20e3b7449f8050f7eb4cdaf37779f0265636b2bb" translate="yes" xml:space="preserve">
          <source>Resets the current process metadata to the given keyword list.</source>
          <target state="translated">현재 프로세스 메타 데이터를 지정된 키워드 목록으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="49fdd1a2b23b0085e72c09b062efd4ecb9a18ed2" translate="yes" xml:space="preserve">
          <source>Resolves a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt; to an actual path.</source>
          <target state="translated">&lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt; 을 실제 경로 로 해석 합니다.</target>
        </trans-unit>
        <trans-unit id="838ebc4a5cadbe62e4f28a82bbc20144b2308c44" translate="yes" xml:space="preserve">
          <source>Respawns the current shell by starting a new shell process.</source>
          <target state="translated">새로운 쉘 프로세스를 시작하여 현재 쉘을 다시 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d924949f461a2178615fa560be4fcb1a11adc482" translate="yes" xml:space="preserve">
          <source>Restart values (:restart)</source>
          <target state="translated">재시작 값 (: restart)</target>
        </trans-unit>
        <trans-unit id="6c1b23092774f1732bb40fd9217d2008cf95142c" translate="yes" xml:space="preserve">
          <source>Restarts a child process identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; 로 식별되는 하위 프로세스를 다시 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="cdda01d4f5a4d17bef26c81b5fb2b202c9529bae" translate="yes" xml:space="preserve">
          <source>Restarts all applications in the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템에서 모든 애플리케이션을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e9ef6fa952a1df9e86072dc44600b6f94a8e9045" translate="yes" xml:space="preserve">
          <source>Retrieves the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 레벨을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="9561c4c2ab77e3b4a8a77091d61310e40fe75523" translate="yes" xml:space="preserve">
          <source>Retrieves the current project if there is one.</source>
          <target state="translated">현재 프로젝트가있는 경우 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8108bc75c4a7082e6ac6f1000b099b62cbb5c8b6" translate="yes" xml:space="preserve">
          <source>Retrieves the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소의 수를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="bd62dedad93356267e6352b4bd2959e6c3d4a64b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6)</source>
          <target state="translated">&lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; 또는 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6) 반환</target>
        </trans-unit>
        <trans-unit id="9d42e2f739c476b4724ed40443cd1bdc8b0b0c31" translate="yes" xml:space="preserve">
          <source>Return values</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="1b92b78b25ceec1de641e02266e51c2ee955125b" translate="yes" xml:space="preserve">
          <source>Return values are the same as &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6510848f34f0555d205bfb994f51d205f3d74823" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="9450659c5d952be2b0fe455eb08ad207bd303023" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_child&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_child&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="3e9dd619fd23cd606de770ea4c2cbd74b2aa99e4" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_link&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="c27118a3f170210d140a1ccdbf570ddfe1f62448" translate="yes" xml:space="preserve">
          <source>Returned value will be the effective value used. If no value was set for given module then it will not be present in the returned list.</source>
          <target state="translated">Returned value will be the effective value used. If no value was set for given module then it will not be present in the returned list.</target>
        </trans-unit>
        <trans-unit id="ffa9d4dbc4959fcd3296aae6ba1fdaf274079262" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</target>
        </trans-unit>
        <trans-unit id="71ad9db2f452d030849e70969695a7639a712f39" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">반환 &lt;code&gt;:ignore&lt;/code&gt; 하게됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;:ignore&lt;/code&gt; 하고 프로세스가 루프를 입력하거나 호출하지 않고 정상적으로 종료됩니다 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; . 감독 트리의 일부로 사용될 때 상위 감독자가 시작하지 못하거나 즉시 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 다시 시작하려고 시도하지 않습니다 . 나머지 감시 트리가 시작되므로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 다른 프로세스에 필요하지 않습니다. 하위 스펙이 상위 감독자에 저장되므로 나중에 &lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 로 시작할 수 있습니다 . 이에 대한 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb2f30a4d8bc7038c64e5d45423d1462692bb22a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ok&lt;/code&gt; leaves the context unchanged (in &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks).</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; 를 반환 하면 컨텍스트가 변경되지 않은 상태로 유지됩니다 ( &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백에서).</target>
        </trans-unit>
        <trans-unit id="d4f04b1fc86d756470bf59ce20599e81fba3d31e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:error, reason}&lt;/code&gt; fails the code change with reason &lt;code&gt;reason&lt;/code&gt; and the state remains as the previous state.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 하면 reason &lt;code&gt;reason&lt;/code&gt; 으로 코드 변경에 실패 하고 상태는 이전 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0592eb111cc826c0b5dc41fef3d96850ddf2ed2a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except the process is hibernated before continuing the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; 반환 하는 것은 루프를 계속하기 전에 프로세스가 최대 절전 모드 인 것을 제외하고는 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="545abab29816f45f903fc69a76d6d258e74019ea" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except a timeout, hibernation or continue occurs as with a &lt;code&gt;:reply&lt;/code&gt; tuple.</source>
          <target state="translated">반환 &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; 는 타임 아웃, 최대 절전 모드 또는 계속이 &lt;code&gt;:reply&lt;/code&gt; 튜플에서 발생한다는 점을 제외하고 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0d632613338eb1516d1e171379de56d181565aa7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; 반환 하는 것은 시간 제한을 설정한다는 점을 제외하고 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0dc3e574638c9f3a3a2cb97268326892e9c0517" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환하는 &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; 과 유사합니다 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 제외하고 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 값으로 직후 호출됩니다 &lt;code&gt;continue&lt;/code&gt; 첫 번째 인수로.</target>
        </trans-unit>
        <trans-unit id="7c2e4427bf9da87b7975511fa77c0aa083a93e56" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 새로운 상태로 루프 계속 &lt;code&gt;new_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0bcdf8d79ea91a9b75d45685f07008e6bb07b7a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; does not send a response to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;. The response must be sent with &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state}&lt;/code&gt; 반환 하면 호출자에게 응답을 보내지 않고 &lt;code&gt;new_state&lt;/code&gt; 상태로 루프를 계속합니다 . 응답은 &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; 와 함께 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="4de3a02b60233fe036c0a08aa97987f8e91d073a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt;&lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;&lt;/a&gt;'s callback</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt; &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt; &lt;/a&gt; 의 콜백 에서 &lt;code&gt;{:ok, contents}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="2dc53c38e32cf54749c4b9b8b84a6ffad0f5456c" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;'s callback</source>
          <target state="translated">Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt; 's callback</target>
        </trans-unit>
        <trans-unit id="4ce39defe2e667a1d9303cd7807fa9deb1f3dff7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, new_state}&lt;/code&gt; changes the state to &lt;code&gt;new_state&lt;/code&gt; and the code change is successful.</source>
          <target state="translated">&lt;code&gt;{:ok, new_state}&lt;/code&gt; 반환 하면 상태가 &lt;code&gt;new_state&lt;/code&gt; 로 변경되고 코드 변경에 성공합니다.</target>
        </trans-unit>
        <trans-unit id="dda86c57299291383ba12cacce3b8a61cd3aca15" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except the process is hibernated before entering the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information on hibernation.</source>
          <target state="translated">&lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; 반환 하는 것은 루프에 들어가기 전에 프로세스가 최대 절전 모드 인 것을 제외하고는 &lt;code&gt;{:ok, state}&lt;/code&gt; 와 비슷합니다 . 최대 절전 모드에 대한 자세한 내용 은 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f89c1f4a5e07f563900cfccc5421ff9a8161b2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt;, except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; 과 유사하다 &lt;code&gt;{:ok, state}&lt;/code&gt; , 또한 시간 제한을 설정하는 것을 제외하고. 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="367f39392e443be5033fcc0ce46cb9c7191866d5" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; callback will be invoked with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">&lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; 반환하는 것은 {: ok, state} 와 비슷합니다 &lt;code&gt;{:ok, state}&lt;/code&gt; 루프에 들어가 자마자 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 콜백이 호출되고 값 이 first argument로 &lt;code&gt;continue&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e7d4ebacb2fe086ff03c74440ab13b1423c917e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state}&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 돌아 &lt;code&gt;{:ok, pid}&lt;/code&gt; 과 그 루프를 입력하는 과정.</target>
        </trans-unit>
        <trans-unit id="2ac7990d3774239b03711f323b97327318be9091" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except the process is hibernated and will continue the loop once a message is in its message queue. If a message is already in the message queue this will be immediately. Hibernating a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; 반환 하는 것은 프로세스가 최대 절전 모드이고 메시지가 메시지 큐에 있으면 루프를 계속한다는 점을 제외하고 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 와 비슷합니다 . 메시지가 이미 메시지 큐에있는 경우 즉시 처리됩니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 를&lt;/a&gt; 최대 절전 모드로 설정 하면 가비지 수집이 발생하고 프로세스에서 사용되는 메모리를 최소화하는 연속 힙이 남습니다.</target>
        </trans-unit>
        <trans-unit id="3664827e00957d1361f076b6c6180a5288429b1e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; 반환 하는 것은 타임 아웃을 설정한다는 점을 제외하고는 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f9c42293c17275b2da3909a5ac827406da8908f" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환 &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; 과 유사합니다 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 제외하고 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 값으로 직후 호출됩니다 &lt;code&gt;continue&lt;/code&gt; 첫 번째 인수로.</target>
        </trans-unit>
        <trans-unit id="5d5e6464f7527865bd6d8be289ffe2a3685bee24" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; sends the response &lt;code&gt;reply&lt;/code&gt; to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 반환 하면 응답 &lt;code&gt;reply&lt;/code&gt; 을 호출자 에게 보내고 &lt;code&gt;new_state&lt;/code&gt; 상태로 루프를 계속합니다 .</target>
        </trans-unit>
        <trans-unit id="534c77debf0badc9c25487b18a7948694707f4bb" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; is similar to &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; except a reply is not sent.</source>
          <target state="translated">&lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 반환 하는 것은 회신을 보내지 않는다는 점을 제외하고 &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 와 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="25233abf67489667f36f12119719f8bf3ab79f10" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with the reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. The process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 루프를 중지하고 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 이유 불려 &lt;code&gt;reason&lt;/code&gt; 와 상태 &lt;code&gt;new_state&lt;/code&gt; . 이유 &lt;code&gt;reason&lt;/code&gt; 으로 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="9446727789d28494af33768c5dd1be490cb2c928" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. Then the &lt;code&gt;reply&lt;/code&gt; is sent as the response to call and the process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 반환 하면 루프가 중지 되고 reason &lt;code&gt;reason&lt;/code&gt; 및 state &lt;code&gt;new_state&lt;/code&gt; 와 함께 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 가 호출됩니다 . 그런 다음 &lt;code&gt;reply&lt;/code&gt; 전화 응답 및 이유와 프로세스가 종료로 전송됩니다 &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b0ba5a4f231122f32567afd5046aeac5ca341b" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason}&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 반환은 &lt;code&gt;{:error, reason}&lt;/code&gt; 및 이유와 출구 과정 &lt;code&gt;reason&lt;/code&gt; 루프를 입력하거나 전화없이 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="201a82018e6ccab06f099ffcf6ad93f0589f0ac6" translate="yes" xml:space="preserve">
          <source>Returning anything else from &lt;code&gt;setup_all&lt;/code&gt; will force all tests to fail, while a bad response from &lt;code&gt;setup&lt;/code&gt; causes the current test to fail.</source>
          <target state="translated">&lt;code&gt;setup_all&lt;/code&gt; 에서 다른 항목을 반환 하면 모든 테스트가 실패하고 &lt;code&gt;setup&lt;/code&gt; 에서 잘못된 응답으로 인해 현재 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2ccc041e90cdcfa1031811c96f150b22c6b8ca9e" translate="yes" xml:space="preserve">
          <source>Returning to our &lt;code&gt;handle_cast/2&lt;/code&gt; implementation, you can see the registry is both linking and monitoring the buckets:</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 구현 으로 돌아가서 레지스트리가 버킷을 연결하고 모니터링하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3999b945835bc6b25789a6d8bdd35064f0c4e298" translate="yes" xml:space="preserve">
          <source>Returning values</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="a86c48f96d918e08b84d079d9945718a4599bc5f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:error&lt;/code&gt; when an invalid call syntax is provided.</source>
          <target state="translated">잘못된 호출 구문이 제공되면 &lt;code&gt;:error&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9ab2b4bc1a0b6cdb37b00adb4f725958544c088b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first date is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two dates are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">반환 &lt;code&gt;:gt&lt;/code&gt; 제 날짜 이후 제 및보다 경우 &lt;code&gt;:lt&lt;/code&gt; 반대 담당 대한. 두 날짜가 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="097e4060b0440fe77549d8b66e79f7bb6eb97a62" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two NaiveDateTime are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">first가 두 번째보다 늦으면 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 NaiveDateTime이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2d674dc710366cef94fba09471c28e71a138f9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first time is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two times are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 시간이 두 번째 시간보다 늦은 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 번 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="53c408a9bef219a6da93ad2df4fe55724f2cb32d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first datetime is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two datetimes are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 날짜 시간이 두 번째 날짜 시간보다 늦은 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 날짜 시간이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e433c31c34feefdf2a0b8160341592f2285d40c9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first version is greater than the second one, and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two versions are equal, &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 버전이 두 번째 버전보다 큰 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 버전이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="49f62de8f752ac017916b11e0d5b0e6dfb4ee428" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇다면 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하고, 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="511e783cd04e635de8fd03daca4897ee670c34df" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4c527276d77f46398aba41c7763a178e857f1629" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="84d6f7930e56db40dca6afbc716ff10cc17e68c7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support hard links, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다. 운영 체제가 하드 링크를 지원하지 않으면 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8a9014518965fa93cf5189e6ffe93f29bdec10a9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support symlinks, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다. 운영 체제가 심볼릭 링크를 지원하지 않으면 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b4bfe0e95851ad3e1857f64f97c1d1fb4f5d47b8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8084f7f8c4483c73958f54a0f48dadd5344d6c20" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs. It returns &lt;code&gt;{:error, :eexist}&lt;/code&gt; if the directory is not empty.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다. 디렉토리가 비어 있지 않으면 &lt;code&gt;{:error, :eexist}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ab0c374d46ad2b15399e120024adf6936c21f68c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if there is such breakpoint ID. &lt;code&gt;:not_found&lt;/code&gt; otherwise.</source>
          <target state="translated">중단 점 ID가 있으면 &lt;code&gt;:ok&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 &lt;code&gt;:not_found&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e6eac431d9ebe34612817b0b267721c1695b386" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;:ok&lt;/code&gt; 에 성공하는 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="fccad904de868f3ee196d9c9da31a4d3a418edcf" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 &lt;code&gt;:ok&lt;/code&gt; 또는 실패시 &lt;code&gt;{:error, reason}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4edb5e74e876c5531ce730345abbd7fb3d428f67" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; or an &lt;code&gt;{:error, reason}&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; 또는 &lt;code&gt;{:error, reason}&lt;/code&gt; 튜플을 리턴 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
