<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="1ac07c5c5d769c317e4ee149161ad79dd547886a" translate="yes" xml:space="preserve">
          <source>Function specifications</source>
          <target state="translated">기능 사양</target>
        </trans-unit>
        <trans-unit id="b1d1d233c6e9151086e11b68520f3c88ddfbfd71" translate="yes" xml:space="preserve">
          <source>FunctionClauseError</source>
          <target state="translated">FunctionClauseError</target>
        </trans-unit>
        <trans-unit id="59d46903ce38ffaa562b785d06c23f1fe1bd7e8e" translate="yes" xml:space="preserve">
          <source>FunctionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">FunctionClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="92264e6f77844330da044c87077edfa8088c62f8" translate="yes" xml:space="preserve">
          <source>Functionality to capture IO for testing.</source>
          <target state="translated">Functionality to capture IO for testing.</target>
        </trans-unit>
        <trans-unit id="cd8664fa33698f4f620c47642dfd3e7413d9d1ec" translate="yes" xml:space="preserve">
          <source>Functionality to capture logs for testing.</source>
          <target state="translated">Functionality to capture logs for testing.</target>
        </trans-unit>
        <trans-unit id="981f29fc45464a2117ff8d90e767ed44d91b4bb6" translate="yes" xml:space="preserve">
          <source>Functionality to render ANSI escape sequences.</source>
          <target state="translated">ANSI 이스케이프 시퀀스를 렌더링하는 기능.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="e331cf0e4275fe631ca417060a2f8f10e15a256d" translate="yes" xml:space="preserve">
          <source>Functions as keys</source>
          <target state="translated">키 기능</target>
        </trans-unit>
        <trans-unit id="89eb4f89d38ca8beda2b5a23ae39ddc79a7e20dc" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; to shorten the module name or use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; to be able to invoke the function without the module name altogether.</target>
        </trans-unit>
        <trans-unit id="5b08dda4461297f97d2d935f4b6c312c57879282" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="translated">&lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; 로 정의 된 함수 는 공용이며 마치 &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 정의 된 것처럼 정의 된 모듈 외부에서 호출 할 수 있습니다 . 따라서 &lt;a href=&quot;#defdelegate/2&quot;&gt; &lt;code&gt;defdelegate/2&lt;/code&gt; &lt;/a&gt; 는 현재 모듈의 퍼블릭 API를 확장하는 것입니다. 전체 모듈 이름을 사용하지 않고 다른 모듈에 정의 된 함수를 호출하려는 경우 &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 를 사용하여 모듈 이름을 줄이거 나 &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 모듈 이름없이 함수를 모두 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5339f05867719070151c5f9212ec9691343c3dfd" translate="yes" xml:space="preserve">
          <source>Functions for creating and composing streams.</source>
          <target state="translated">스트림을 작성하고 작성하는 기능.</target>
        </trans-unit>
        <trans-unit id="a92a126ef94a3c0fc6addeadb2500f9ae863a5be" translate="yes" xml:space="preserve">
          <source>Functions for interacting with the external world through ports.</source>
          <target state="translated">포트를 통해 외부 세계와 상호 작용하는 기능.</target>
        </trans-unit>
        <trans-unit id="595e959d0a21e0d09abbd2c4fba3e39601ca613b" translate="yes" xml:space="preserve">
          <source>Functions for parsing and matching versions against requirements.</source>
          <target state="translated">요구 사항에 따라 버전을 구문 분석하고 일치시키는 기능.</target>
        </trans-unit>
        <trans-unit id="3f33806c59ce33f63b6d6eac23d2c5c308d0f02e" translate="yes" xml:space="preserve">
          <source>Functions for parsing command line arguments.</source>
          <target state="translated">명령 줄 인수를 구문 분석하는 함수</target>
        </trans-unit>
        <trans-unit id="be344dfaebcc716a7113914fb8d65d65aad9cdfb" translate="yes" xml:space="preserve">
          <source>Functions for working with floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자로 작업하기위한 함수.</target>
        </trans-unit>
        <trans-unit id="4581129055260f253b0f9a10ce8940c3ae082007" translate="yes" xml:space="preserve">
          <source>Functions for working with integers.</source>
          <target state="translated">정수 작업을위한 함수.</target>
        </trans-unit>
        <trans-unit id="ac038c429b16ac4da6a1c54de055fde121e86832" translate="yes" xml:space="preserve">
          <source>Functions for working with tuples.</source>
          <target state="translated">튜플 작업을위한 기능.</target>
        </trans-unit>
        <trans-unit id="b012c35607b405f40246b484e5594c562e5fd7b1" translate="yes" xml:space="preserve">
          <source>Functions handling input/output (IO).</source>
          <target state="translated">입 / 출력 (IO) 처리 기능.</target>
        </trans-unit>
        <trans-unit id="120d9dcde7287a0528aec2f3d5f7e2e3f5cd376a" translate="yes" xml:space="preserve">
          <source>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. &lt;code&gt;round/1&lt;/code&gt; identifies the function which is named &lt;code&gt;round&lt;/code&gt; and takes &lt;code&gt;1&lt;/code&gt; argument, whereas &lt;code&gt;round/2&lt;/code&gt; identifies a different (nonexistent) function with the same name but with an arity of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">엘릭서의 기능은 이름과 특성으로 식별됩니다. 함수의 arity는 함수가 취하는 인수의 수를 나타냅니다. 이 시점부터 함수 이름과 그 특성을 사용하여 문서 전체에서 함수를 설명합니다. &lt;code&gt;round/1&lt;/code&gt; 은 이름이 &lt;code&gt;round&lt;/code&gt; 인 함수를 식별하고 &lt;code&gt;1&lt;/code&gt; 개의 인수를 취하는 반면 &lt;code&gt;round/2&lt;/code&gt; 는 이름은 같지만 arity는 &lt;code&gt;2&lt;/code&gt; 인 다른 (존재하지 않는) 함수를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="25a36a956214e3716b0faa690578d88a7316d2d1" translate="yes" xml:space="preserve">
          <source>Functions may be called when defining a module attribute, e.g.</source>
          <target state="translated">Functions may be called when defining a module attribute, e.g.</target>
        </trans-unit>
        <trans-unit id="18780274d7513230569a4133845253288a279bc6" translate="yes" xml:space="preserve">
          <source>Functions related to VM nodes.</source>
          <target state="translated">VM 노드와 관련된 기능.</target>
        </trans-unit>
        <trans-unit id="2ecc259041cce0328acd0d9abf2a78e6d378235f" translate="yes" xml:space="preserve">
          <source>Functions that return a boolean are named with a trailing question mark.</source>
          <target state="translated">부울을 리턴하는 함수는 후행 물음표로 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3abac8dc3938de4ae338c2914b66903b6d6216cf" translate="yes" xml:space="preserve">
          <source>Functions that work on (linked) lists.</source>
          <target state="translated">(연결된) 목록에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="d6d5cb54b94547b27cdb53ea8f156b69b0e891a7" translate="yes" xml:space="preserve">
          <source>Functions that work on sets.</source>
          <target state="translated">세트에서 작동하는 함수.</target>
        </trans-unit>
        <trans-unit id="c2171b2fcb9b756c41905c9675c92ab582aa67f4" translate="yes" xml:space="preserve">
          <source>Functions to format throw/catch/exit and exceptions.</source>
          <target state="translated">throw / catch / exit 및 예외 형식을 지정하는 함수</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="5d853e3f857a73da9a233be532bd545c49917d50" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">Furthermore, &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; may fail with one of the POSIX reasons detailed below:</target>
        </trans-unit>
        <trans-unit id="287db3c111ae0a4e9243da5209d0af176dba1c2f" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Furthermore, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; APIs. Check &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Translator.html&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="6d6208ba2074c10f21b8ca78cfba95b5238a4367" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;logger.translator&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">또한, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 를&lt;/a&gt; 사용하면 Erlang이 보낸 메시지를 번역기를 통해 Elixir 형식으로 변환 할 수 있습니다. &lt;a href=&quot;#add_translator/1&quot;&gt; &lt;code&gt;add_translator/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#remove_translator/1&quot;&gt; &lt;code&gt;remove_translator/1&lt;/code&gt; &lt;/a&gt; API를 사용하여 언제든지 번역기를 추가 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;logger.translator&quot;&gt; &lt;code&gt;Logger.Translator&lt;/code&gt; &lt;/a&gt; 를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="f484c5ceae64ae91667e53e8fabec77fcc0eab91" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="translated">또한 &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; 는 아래에 자세하게 설명 된 POSIX 이유 중 하나로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186edc3e57a9d838cd0ada8549562af323cf60a5" translate="yes" xml:space="preserve">
          <source>Furthermore, a &lt;code&gt;:suspend&lt;/code&gt; call must always be followed by another call, eventually halting or continuing until the end.</source>
          <target state="translated">또한 &lt;code&gt;:suspend&lt;/code&gt; 통화 뒤에는 항상 다른 통화가 와야하며 결국에는 끝까지 중지되거나 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c260bcd5ae1bdde9983d663eb92d5fcd82188b68" translate="yes" xml:space="preserve">
          <source>Furthermore, all applications listed in the &lt;code&gt;:applications&lt;/code&gt; key must be explicitly started before this application is. If not, &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; is returned, where &lt;code&gt;app&lt;/code&gt; is the name of the missing application.</source>
          <target state="translated">또한 &lt;code&gt;:applications&lt;/code&gt; 키에 나열된 모든 응용 프로그램은이 응용 프로그램을 시작하기 전에 명시 적으로 시작해야합니다. 그렇지 않은 경우 &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; 이 반환됩니다. 여기서 &lt;code&gt;app&lt;/code&gt; 은 누락 된 응용 프로그램의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="26e72ab288d2e99c66734f21d67d33280ac839df" translate="yes" xml:space="preserve">
          <source>Furthermore, backends can be configured via the &lt;a href=&quot;#configure_backend/2&quot;&gt;&lt;code&gt;configure_backend/2&lt;/code&gt;&lt;/a&gt; function which requires event handlers to handle calls of the following format:</source>
          <target state="translated">또한 이벤트 핸들러가 다음 형식의 호출을 처리해야하는 &lt;a href=&quot;#configure_backend/2&quot;&gt; &lt;code&gt;configure_backend/2&lt;/code&gt; &lt;/a&gt; 함수를 통해 백엔드를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03045b903b2a4efd2fad95378e0e7416cbdc8700" translate="yes" xml:space="preserve">
          <source>Furthermore, because the state returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.</source>
          <target state="translated">또한 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된 상태는 텍스트 기반 구성 파일에 기록 될 수 있으므로 정수, 문자열, 원자, 튜플, 맵 및 목록과 같은 간단한 데이터 유형으로 만 제한되어야합니다. PID, 참조 및 기능과 같은 항목은 직렬화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e12a025bc34e52444d91865482fafd1b4bcb1476" translate="yes" xml:space="preserve">
          <source>Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors:</source>
          <target state="translated">또한 디스패치에 실패한 경우 등록이 잘못되어 디스패치가 항상 실패하고 등록 된 프로세스에 알리지 않습니다. 따라서 최소한 이러한 오류를 줄 바꿈하고보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="3528255d6bac578fd573ffc86dde48159bf06389" translate="yes" xml:space="preserve">
          <source>Furthermore, metadata can be set per process with &lt;a href=&quot;#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Furthermore, metadata can be set per process with &lt;a href=&quot;#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="42529d32de08bd15f27eb4312be9cc48b68c13b2" translate="yes" xml:space="preserve">
          <source>Furthermore, they are composable because we can pipe many stream operations:</source>
          <target state="translated">또한 많은 스트림 작업을 파이프 할 수 있기 때문에 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3381a6c76f92b142faec11ca6cffe41f63f7d1f2" translate="yes" xml:space="preserve">
          <source>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;&amp;eacute;&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points):</source>
          <target state="translated">또한이 모듈은 grapheme 클러스터의 개념을 제시합니다 (지금부터 graphemes로 참조). 그래 핀은 독자가 단일 문자로 인식 할 수있는 여러 코드 포인트로 구성 될 수 있습니다. 예를 들어, &quot;&amp;eacute;&quot;는 &quot;ecute&quot;코드 포인트가있는 단일 &quot;e&quot;또는 &quot;e&quot;문자 다음에 &quot;combining acute accent&quot;(두 개의 코드 포인트)로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25c00dc3897c6883dc4fe0f27096add3cc899e4" translate="yes" xml:space="preserve">
          <source>Furthermore, while &lt;code&gt;vm.args&lt;/code&gt; is static, you can use &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to dynamically set VM options. For example, if you want to make sure the Erlang Distribution listens only on a given port known at runtime, you can set the following:</source>
          <target state="translated">Furthermore, while &lt;code&gt;vm.args&lt;/code&gt; is static, you can use &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; to dynamically set VM options. For example, if you want to make sure the Erlang Distribution listens only on a given port known at runtime, you can set the following:</target>
        </trans-unit>
        <trans-unit id="5c727a56b05e846df29f24d1daf2419df88964fa" translate="yes" xml:space="preserve">
          <source>Furthermore, with &lt;code&gt;@impl&lt;/code&gt; you can also make sure that you are implementing the &lt;strong&gt;correct&lt;/strong&gt; callbacks from the given behaviour in an explicit manner. For example, the following parser implements both &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt;, however thanks to a typo, &lt;code&gt;BADParser&lt;/code&gt; is implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;@impl&lt;/code&gt; 을 사용 하면 지정된 동작에서 명시적인 방식으로 &lt;strong&gt;올바른&lt;/strong&gt; 콜백을 구현할 수 있습니다 . 예를 들어, 다음 구문 분석기는 &lt;code&gt;parse&lt;/code&gt; 및 &lt;code&gt;extensions&lt;/code&gt; 모두 구현 하지만 오타로 &lt;code&gt;BADParser&lt;/code&gt; 는 &lt;code&gt;parse/1&lt;/code&gt; 대신 &lt;code&gt;parse/0&lt;/code&gt; 을 구현하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae57bdba0f435d58b5575a45dc3b5fb6eb566cf8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let&amp;rsquo;s make the test fail on purpose and see what happens.</source>
          <target state="translated">또한 ExUnit은 성공한 각 테스트마다 점을 인쇄하고 테스트도 자동으로 무작위 화합니다. 테스트가 의도적으로 실패하도록하고 어떤 일이 발생하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="26e2a4f823a98eca42ddcd53fd08f4fc5631d231" translate="yes" xml:space="preserve">
          <source>GenEvent</source>
          <target state="translated">GenEvent</target>
        </trans-unit>
        <trans-unit id="52f5451d0a005c032b5bd9e0f39e525431bee3e4" translate="yes" xml:space="preserve">
          <source>GenEvent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenEvent &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f1f7460d4b0df6c99ec51f3b8a78fab0ab241364" translate="yes" xml:space="preserve">
          <source>GenServer</source>
          <target state="translated">GenServer</target>
        </trans-unit>
        <trans-unit id="c41a8053324929c4122055404c6f497f28026d3e" translate="yes" xml:space="preserve">
          <source>GenServer - Elixir's Getting Started Guide</source>
          <target state="translated">GenServer-Elixir 시작 안내서</target>
        </trans-unit>
        <trans-unit id="eca82733cdfcb3649b72cda06a30a922552032d8" translate="yes" xml:space="preserve">
          <source>GenServer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">GenServer &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="6b938fbce44ec15ef7cf28460d3d3a0b7b6e45c7" translate="yes" xml:space="preserve">
          <source>GenServer callbacks</source>
          <target state="translated">GenServer 콜백</target>
        </trans-unit>
        <trans-unit id="60a02fde0f842f29309800909cd00e720e3567d0" translate="yes" xml:space="preserve">
          <source>GenServers, as &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;special processes&lt;/a&gt;, can be debugged using the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt;. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;특수 프로세스&lt;/a&gt; 인 GenServer 는 &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 모듈을&lt;/a&gt; 사용하여 디버깅 할 수 있습니다 . 다양한 후크를 통해이 모듈을 통해 개발자는 프로세스 상태를 검사하고 메시지 수신, 보낸 응답 및 상태 변경과 같이 프로세스 중에 발생하는 시스템 이벤트를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2323fdcd5a3410a0abfe44a2176b41a6905683" translate="yes" xml:space="preserve">
          <source>GenStage</source>
          <target state="translated">GenStage</target>
        </trans-unit>
        <trans-unit id="92fde6e5cdcf695869dd7ece8642757211b43eff" translate="yes" xml:space="preserve">
          <source>General operators</source>
          <target state="translated">General operators</target>
        </trans-unit>
        <trans-unit id="26811be9b4758ef85d12185318d245ac23863706" translate="yes" xml:space="preserve">
          <source>Generally speaking, filenames follow the &lt;code&gt;snake_case&lt;/code&gt; convention of the module they define. For example, &lt;code&gt;MyApp&lt;/code&gt; should be defined inside the &lt;code&gt;my_app.ex&lt;/code&gt; file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.</source>
          <target state="translated">일반적으로 파일 이름은 정의한 모듈 의 &lt;code&gt;snake_case&lt;/code&gt; 규칙을 따릅니다 . 예를 들어, &lt;code&gt;MyApp&lt;/code&gt; 은 &lt;code&gt;my_app.ex&lt;/code&gt; 파일 내에 정의되어야 합니다. 그러나 이것은 컨벤션 일뿐입니다. 하루가 끝나면 컴파일 된 코드에 아무런 영향을 미치지 않으므로 모든 파일 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4e59b7746a9b324c29c497d15613e18d32b2ec0" translate="yes" xml:space="preserve">
          <source>Generally speaking, the VM provides three time measurements:</source>
          <target state="translated">일반적으로 VM은 세 가지 시간 측정을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ca8af8a9659e59f74154d217723284164924d905" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following files are available for customizing and configuring the running system:</source>
          <target state="translated">Generally speaking, the following files are available for customizing and configuring the running system:</target>
        </trans-unit>
        <trans-unit id="3853e87a8cfcd1a2826b60877e31dac6ddc354ee" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following module:</source>
          <target state="translated">일반적으로 다음 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="061ef8a9ec07ec601a5d20eb32a7f1c44a8e42be" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bc78aa7ca2c1bb33572b17a7f6a38317ada6e607" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;macro#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;macro#var/2&quot;&gt; &lt;code&gt;Macro.var/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 지정된 수의 필수 인수 변수에 대한 AST 노드를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7914afeb7e94d7ae59d1fa355821ee7cf902a612" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the file contents.</source>
          <target state="translated">파일 내용에서 함수 정의를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6f28a47721aec6c56f1e4f3f4b046459fb2d421f" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the string.</source>
          <target state="translated">문자열에서 함수 정의를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3ed0a940ace5bee6a5a44c402162f201a0b4df48" translate="yes" xml:space="preserve">
          <source>Generates a macro suitable for use in guard expressions.</source>
          <target state="translated">가드 표현식에 사용하기에 적합한 매크로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f89a805aedce9f9ff7961406995dc39283b2ba6f" translate="yes" xml:space="preserve">
          <source>Generates a private macro suitable for use in guard expressions.</source>
          <target state="translated">가드 표현식에 사용하기에 적합한 개인용 매크로를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d022a23ab156502d4cd22511016df2db248a08d8" translate="yes" xml:space="preserve">
          <source>Generates an AST node representing the variable given by the atoms &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">원자 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;context&lt;/code&gt; 로 지정된 변수를 나타내는 AST 노드를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="39399ecc6eafac75945962b0e75d0ddca1662821" translate="yes" xml:space="preserve">
          <source>Generates and returns an integer that is unique in the current runtime instance.</source>
          <target state="translated">현재 런타임 인스턴스에서 고유 한 정수를 생성하고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1ad2ad1cc4377f21a03bdbb978029bcfeb4b2be2" translate="yes" xml:space="preserve">
          <source>Generates sample files for releases.</source>
          <target state="translated">Generates sample files for releases.</target>
        </trans-unit>
        <trans-unit id="5539e5b1ece965094ab6defc81d9ab18e23afa6b" translate="yes" xml:space="preserve">
          <source>Generator expressions also support pattern matching on their left-hand side; all non-matching patterns are &lt;em&gt;ignored&lt;/em&gt;. Imagine that, instead of a range, we have a keyword list where the key is the atom &lt;code&gt;:good&lt;/code&gt; or &lt;code&gt;:bad&lt;/code&gt; and we only want to compute the square of the &lt;code&gt;:good&lt;/code&gt; values:</source>
          <target state="translated">생성기 표현식은 또한 왼쪽에서 패턴 일치를 지원합니다. 일치하지 않는 모든 패턴은 &lt;em&gt;무시&lt;/em&gt; 됩니다. 범위 대신 키가 원자 &lt;code&gt;:good&lt;/code&gt; 또는 &lt;code&gt;:bad&lt;/code&gt; 인 키워드 목록 이 있고 &lt;code&gt;:good&lt;/code&gt; 값 의 제곱 만 계산하려고 한다고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="191fe63ca19d74852f4f8e0438c53a7c9f2fad58" translate="yes" xml:space="preserve">
          <source>Generators and filters</source>
          <target state="translated">발전기 및 필터</target>
        </trans-unit>
        <trans-unit id="b0f6dc9f4ecd590c4554fad6675925837bd4c03b" translate="yes" xml:space="preserve">
          <source>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;-&lt;/code&gt; 의 왼쪽에있는 패턴과 일치하지 않는 값을 제거하므로 생성기를 사용하여 필터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a24751485eed378e568d03e0c111b00b1ca2106" translate="yes" xml:space="preserve">
          <source>Generic API for dictionaries.</source>
          <target state="translated">사전을위한 일반 API.</target>
        </trans-unit>
        <trans-unit id="f74ee225a82269c197985a3a933abeea994529f8" translate="yes" xml:space="preserve">
          <source>Generic API for sets.</source>
          <target state="translated">세트의 일반 API.</target>
        </trans-unit>
        <trans-unit id="342a929853c668da7bea5b8678d33654ddad6c44" translate="yes" xml:space="preserve">
          <source>Get all keys in the registry.</source>
          <target state="translated">레지스트리의 모든 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="15d4328951079f5b0c0d666980c03b21bfcda99d" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 가져 오고 &lt;code&gt;bindings&lt;/code&gt; 사용하여 값을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e09423213d70047599b0fbcfb55a1d216ed0bceb" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 가져 오고 Elixir에서 평가하거나 함수로 컴파일 할 수있는 따옴표 붙은 표현식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="11ce297c5b4ae23b4a6d01356ff4f29ad16e92ef" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from IO device &lt;code&gt;:stdio&lt;/code&gt;.</source>
          <target state="translated">IO 장치 &lt;code&gt;:stdio&lt;/code&gt; 에서 여러 바이트를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="aef78a3cc35c0eec4a213bb06eb18783344f5a30" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 여러 바이트를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="464c10475e938f50f88715c59eebddca575584e5" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;source&lt;/code&gt; 가져 오고 &lt;code&gt;bindings&lt;/code&gt; 사용하여 값을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="dce9c015f4c3caacfed76da20580dc567b349125" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="translated">문자열 &lt;code&gt;source&lt;/code&gt; 를 가져와 Elixir에서 평가하거나 함수로 컴파일 할 수있는 따옴표 붙은 표현식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77a47a00f7c2dc7431f1fd26f1f6a07c0721fc92" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested data structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 값을 가져오고 중첩 된 데이터 구조를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="197bee8d14aabe7ecd2c0b8cae48772622a49701" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested structure.</source>
          <target state="translated">값을 가져오고 중첩 구조를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="24fc43c308b364700a4a6b0c3e1ab5a6e0a34321" translate="yes" xml:space="preserve">
          <source>Gets a value from a nested structure.</source>
          <target state="translated">중첩 구조에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d58fdd9b7ac3d94d847bf7aa9396d3dd171627fa" translate="yes" xml:space="preserve">
          <source>Gets all compilation options from the code server.</source>
          <target state="translated">Gets all compilation options from the code server.</target>
        </trans-unit>
        <trans-unit id="9024c31b7473f5071a19da2642c254ca64dc5dcc" translate="yes" xml:space="preserve">
          <source>Gets all out of date dependencies, i.e. dependencies that are not available or have an invalid lock.</source>
          <target state="translated">Gets all out of date dependencies, i.e. dependencies that are not available or have an invalid lock.</target>
        </trans-unit>
        <trans-unit id="234783729be10591273a98e34996adf814d0af2b" translate="yes" xml:space="preserve">
          <source>Gets all values for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 모든 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="337ee14d7455079870c96913a5344151625e3a44" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given anonymous function.</source>
          <target state="translated">주어진 익명 함수를 통해 에이전트 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cc4728d1ab03bf9e6b17772b1edd930d1db3e60f" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given function.</source>
          <target state="translated">주어진 함수를 통해 에이전트 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7ccc56cd7cf9a38cdbce42e3b62827d91b072aca" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given anonymous function.</source>
          <target state="translated">주어진 익명 함수를 통해 한 번의 작업으로 에이전트 상태를 가져오고 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="8e2c80c38d6dbae8b378d7ea7441399c6dccc722" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given function.</source>
          <target state="translated">주어진 함수를 통해 한 번의 작업으로 에이전트 상태를 가져오고 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="096ecee5005ebff9401bca63004bd1e4271d321f" translate="yes" xml:space="preserve">
          <source>Gets and updates the given key in a &lt;code&gt;container&lt;/code&gt; (a map, a keyword list, a struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt; (지도, 키워드 목록, &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 구조체) 에서 지정된 키를 가져오고 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="3045c9e659f40b430ef7ec7c9aeaf689166b9794" translate="yes" xml:space="preserve">
          <source>Gets logging level for given module.</source>
          <target state="translated">Gets logging level for given module.</target>
        </trans-unit>
        <trans-unit id="87f10d7ccf1593e9cf40f6046fb73ed64260d10f" translate="yes" xml:space="preserve">
          <source>Gets preferred CLI environment for the task.</source>
          <target state="translated">작업에 대한 선호 CLI 환경을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7ae776c4b4f195b1f36b2be173094733049a81b3" translate="yes" xml:space="preserve">
          <source>Gets the application for the given module.</source>
          <target state="translated">주어진 모듈에 대한 응용 프로그램을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a3186207a243a3a8619e9edb98a5c2ef194e1cbc" translate="yes" xml:space="preserve">
          <source>Gets the compilation options from the code server.</source>
          <target state="translated">코드 서버에서 컴파일 옵션을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="224e4a732cfad5d058a4b2c327797e2a8a3c70d9" translate="yes" xml:space="preserve">
          <source>Gets the current time zone database.</source>
          <target state="translated">현재 시간대 데이터베이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1f02096a4a7d41ef362ad56dd8a049be60b3048f" translate="yes" xml:space="preserve">
          <source>Gets the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8890fe17865bc33bcf4596b3f99ac374608009ec" translate="yes" xml:space="preserve">
          <source>Gets the directory for app.</source>
          <target state="translated">앱의 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a0d384aa0e95a00ba787ac060a94eb0ed4d124ec" translate="yes" xml:space="preserve">
          <source>Gets the element at the zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">제로로부터의 요소 취득 &lt;code&gt;index&lt;/code&gt; 에서 &lt;code&gt;tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff598d3e96b472f599f3428af98b3592d274ed04" translate="yes" xml:space="preserve">
          <source>Gets the given attribute from a module.</source>
          <target state="translated">모듈에서 지정된 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c8c63585e58950af32a8c183dc234c637dbaf32b" translate="yes" xml:space="preserve">
          <source>Gets the list of requirements for the given task.</source>
          <target state="translated">Gets the list of requirements for the given task.</target>
        </trans-unit>
        <trans-unit id="d86f7fa0e05aedae7d11fde1051d7047e16a9a64" translate="yes" xml:space="preserve">
          <source>Gets the message for an &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exception&lt;/code&gt; 메시지를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d01b62b32cf43c3c1a84005842e75a1a8e58e56a" translate="yes" xml:space="preserve">
          <source>Gets the moduledoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">주어진 작업 &lt;code&gt;module&lt;/code&gt; 대한 moduledoc를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b0dee9f2cb9d3796fb7a48d547b0b2fb9dd7e266" translate="yes" xml:space="preserve">
          <source>Gets the representation of any expression.</source>
          <target state="translated">식 표현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="aacf11051abfff1af3276a82387ff290a1040ef2" translate="yes" xml:space="preserve">
          <source>Gets the shortdoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">주어진 작업 &lt;code&gt;module&lt;/code&gt; 대한 shortdoc을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="985fa8a31c64d1abf929750e6b62fcffb66d5d21" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">특정의 값을 가져옵니다 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2670bc6c3a1d135ba35e9b1dd103fad35687d05" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 의 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cd6a6dd9113df059c87999c56f37603a31759691" translate="yes" xml:space="preserve">
          <source>Gets the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">컨테이너에서 지정된 키의 값을 가져옵니다 (맵, 키워드 목록 또는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 구조체 ).</target>
        </trans-unit>
        <trans-unit id="8bbd7b83737713a8cdf97c7e1c36926c053390c6" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 값을 가져와 한 번에 모두 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="fb3ccba9209e0ea1faa8f2431f64136954cd5182" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass. Raises if there is no &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0a567720e720098dfad63e9f3f00ec9b4e381f" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 값을 가져 와서 업데이트합니다. &lt;code&gt;key&lt;/code&gt; 가 없으면 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="efe79cf11081ba631fe2c7b862ea12b5382475d7" translate="yes" xml:space="preserve">
          <source>Getting started guide</source>
          <target state="translated">시작 안내서</target>
        </trans-unit>
        <trans-unit id="621916a4cc49b2e7a0bda3364f0574a16aa3088a" translate="yes" xml:space="preserve">
          <source>Getting the head or the tail of an empty list throws an error:</source>
          <target state="translated">빈 목록의 머리 나 꼬리를 가져 오면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8fbc4cd9319e626e1ccf7f2fcd4c822c8a5bcbe" translate="yes" xml:space="preserve">
          <source>Git options (&lt;code&gt;:git&lt;/code&gt;)</source>
          <target state="translated">힘내 옵션 ( &lt;code&gt;:git&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="37a8f2d730b24d981ab8fef7024613f2ad9ff494" translate="yes" xml:space="preserve">
          <source>Given a query string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt;, this function inserts each key-value pair in the query string as one entry in the given &lt;code&gt;map&lt;/code&gt;. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</source>
          <target state="translated">&lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt; 형식의 쿼리 문자열이 주어지면 이 함수는 쿼리 문자열의 각 키-값 쌍을 주어진 &lt;code&gt;map&lt;/code&gt; 에서 하나의 항목으로 삽입합니다 . 결과 맵의 키와 값은 이진입니다. 키와 값은 이스케이프 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="681fb9c4d5bed925cb73d7a24ad5b09e42d58e91" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements right before element &lt;code&gt;start_index&lt;/code&gt;, then takes &lt;code&gt;amount&lt;/code&gt; of elements, returning as many elements as possible if there are not enough elements.</source>
          <target state="translated">주어 &lt;code&gt;enumerable&lt;/code&gt; , 그것은 바로 요소 전에 요소를 떨어 &lt;code&gt;start_index&lt;/code&gt; 후 소요 &lt;code&gt;amount&lt;/code&gt; 충분한 요소가없는 경우 가능한 한 많은 요소로 반환 요소를.</target>
        </trans-unit>
        <trans-unit id="9abc0837abc465b4295e2cadea49184fb4cb4c6a" translate="yes" xml:space="preserve">
          <source>Given an enumerable of enumerables, concatenates the &lt;code&gt;enumerables&lt;/code&gt; into a single list.</source>
          <target state="translated">열거 가능한 열거 가능 항목이 주어지면 &lt;code&gt;enumerables&lt;/code&gt; 을 단일 목록으로 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="bae6dae6fe4dd518a111019522e41b9338d8da6a" translate="yes" xml:space="preserve">
          <source>Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt;&lt;code&gt;++&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator (&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#++/2&quot;&gt; &lt;code&gt;++&lt;/code&gt; &lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="318c3f40bcb691337e3daedb3433d603c4f8eada" translate="yes" xml:space="preserve">
          <source>Given items in an async stream are processed concurrently, doing &lt;code&gt;async_stream&lt;/code&gt; followed by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt;&lt;code&gt;Enum.take/2&lt;/code&gt;&lt;/a&gt; may cause more items than requested to be processed. Let's see an example:</source>
          <target state="translated">Given items in an async stream are processed concurrently, doing &lt;code&gt;async_stream&lt;/code&gt; followed by &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html#take/2&quot;&gt; &lt;code&gt;Enum.take/2&lt;/code&gt; &lt;/a&gt; may cause more items than requested to be processed. Let's see an example:</target>
        </trans-unit>
        <trans-unit id="6c7afd283b9c25ebdc6e3a55a4b68a33a103e346" translate="yes" xml:space="preserve">
          <source>Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</source>
          <target state="translated">Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</target>
        </trans-unit>
        <trans-unit id="b078a81a2e280f99fedc2be9c6836b96581c1c0d" translate="yes" xml:space="preserve">
          <source>Given that strings are binaries, we can also pattern match on strings:</source>
          <target state="translated">Given that strings are binaries, we can also pattern match on strings:</target>
        </trans-unit>
        <trans-unit id="f3677630682772650b101e7db35f800ba5311f07" translate="yes" xml:space="preserve">
          <source>Given the anonymous function:</source>
          <target state="translated">익명의 기능이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="36db5dd9f19115507b73ab3e8430b31b4965279c" translate="yes" xml:space="preserve">
          <source>Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not.</source>
          <target state="translated">Given this function halts compilation, use it carefully. In particular, avoid using it to guess which modules are in the system. Overuse of this function can also lead to deadlocks, where two modules check at the same time if the other is compiled. This returns a specific unavailable error code, where we cannot successfully verify a module is available or not.</target>
        </trans-unit>
        <trans-unit id="41535529b54e3895b904cb50fa535652b69f1b5f" translate="yes" xml:space="preserve">
          <source>Given this is the default calendar used by Elixir, it has one difference compared to the ISO8601 specification in that it allows a whitespace instead of &lt;code&gt;T&lt;/code&gt; as a seperator between date and times both when parsing and formatting. Strict formatting can be done by using the &lt;code&gt;to_iso8601&lt;/code&gt; found in &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Given this is the default calendar used by Elixir, it has one difference compared to the ISO8601 specification in that it allows a whitespace instead of &lt;code&gt;T&lt;/code&gt; as a seperator between date and times both when parsing and formatting. Strict formatting can be done by using the &lt;code&gt;to_iso8601&lt;/code&gt; found in &lt;a href=&quot;https://hexdocs.pm/elixir/NaiveDateTime.html&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cd1d5229cdbf0e79ed32d47a41c7e0424cb85df8" translate="yes" xml:space="preserve">
          <source>Given three vertices, find the shortest path from the first to the last.</source>
          <target state="translated">정점이 세 개인 경우 첫 번째에서 마지막까지 가장 짧은 경로를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6e14f8c349b7ea44c21dc9a2bb0f69f3be68850a" translate="yes" xml:space="preserve">
          <source>Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.</source>
          <target state="translated">Giving a path is useful to let Elixir know that only certain paths in a large configuration are compile time dependent.</target>
        </trans-unit>
        <trans-unit id="eb698f945d96926994811a109269c63fcc2c2588" translate="yes" xml:space="preserve">
          <source>Giving an argument that does not match any of the clauses raises an error.</source>
          <target state="translated">절과 일치하지 않는 인수를 제공하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6962fecddec56252c7eb488f5a99ecedf3c0d3ff" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting a &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; given by &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">두 개의 문서 ( &lt;code&gt;doc1&lt;/code&gt; 및 &lt;code&gt;doc2&lt;/code&gt; ) 에 &lt;code&gt;break_string&lt;/code&gt; 으로 주어진 &lt;a href=&quot;#flex_break/1&quot;&gt; &lt;code&gt;flex_break/1&lt;/code&gt; 을&lt;/a&gt; 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="5a76459e82605f9a2f2ab9a4295c080bd4d42cf0" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting the given break &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="translated">두 개의 문서 ( &lt;code&gt;doc1&lt;/code&gt; 및 &lt;code&gt;doc2&lt;/code&gt; )를 &lt;code&gt;break_string&lt;/code&gt; 주어진 break break_string을 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="c91ff6d61d31b9a76a19683905991f494f51c9d2" translate="yes" xml:space="preserve">
          <source>Good! Now &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests are all routed to the approriate node. Let&amp;rsquo;s also make sure that when a new bucket is created it ends up on the correct node. Replace the &lt;code&gt;run/1&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt;, the one that matches the &lt;code&gt;:create&lt;/code&gt; command, with the following:</source>
          <target state="translated">Good! Now &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; requests are all routed to the approriate node. Let&amp;rsquo;s also make sure that when a new bucket is created it ends up on the correct node. Replace the &lt;code&gt;run/1&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt; , the one that matches the &lt;code&gt;:create&lt;/code&gt; command, with the following:</target>
        </trans-unit>
        <trans-unit id="8bb7c805f7de70037ed1803ff9f5f16721be43e5" translate="yes" xml:space="preserve">
          <source>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module.</source>
          <target state="translated">Grapheme은 일부 언어에서 하나로 해석되는 두 문자 일 수도 있습니다. 예를 들어, 일부 언어는 &quot;ch&quot;를 단일 문자로 간주 할 수 있습니다. 그러나이 정보는 로케일에 따라 다르므로이 모듈에서 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e786d50d22654cd173f8d3b62a2460772b2e8c56" translate="yes" xml:space="preserve">
          <source>Greater-than operator.</source>
          <target state="translated">Greater-than operator.</target>
        </trans-unit>
        <trans-unit id="7dae2a91a27873b3eab21af62f86fd6dd15e3eeb" translate="yes" xml:space="preserve">
          <source>Greater-than or equal to operator.</source>
          <target state="translated">Greater-than or equal to operator.</target>
        </trans-unit>
        <trans-unit id="d6bc40a0f5a48e1cfea2b0fd464f5f6f31570bd2" translate="yes" xml:space="preserve">
          <source>Guard clauses can also be given to the match:</source>
          <target state="translated">경기에 가드 조항을 줄 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="142ddd2f53edae494acde2b741cff19a0327b789" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.</source>
          <target state="translated">Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.</target>
        </trans-unit>
        <trans-unit id="cd32950893cbba732683c916fdaa3f7721bfbc75" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed.</source>
          <target state="translated">가드는보다 복잡한 검사로 패턴 일치를 향상시키는 방법입니다. 패턴 일치가 허용되는 사전 정의 된 구성 세트에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f51e7c885b3316cf13c1a89511ab0220e376f9ff" translate="yes" xml:space="preserve">
          <source>Guards can be used in patterns as well:</source>
          <target state="translated">가드는 패턴에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2c059bdbc9e50988efa18e14c41ef3278c8017" translate="yes" xml:space="preserve">
          <source>Guards can be used to restrict type variables given as arguments to the function.</source>
          <target state="translated">가드는 함수에 인수로 주어진 유형 변수를 제한하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4e06fce5066ed597d68206744c09c068cc26cf" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; keyword, which is followed by a boolean expression (we will define the grammar of guards more formally later on).</source>
          <target state="translated">가드는 &lt;code&gt;when&lt;/code&gt; 키워드로 시작하고 그 뒤에 부울식이옵니다 (가드의 문법은 나중에 공식적으로 정의 할 것입니다).</target>
        </trans-unit>
        <trans-unit id="00d836e676cdbf32c1fff6bdfc1dd47899a371d2" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns &lt;code&gt;true&lt;/code&gt;. Multiple boolean conditions can be combined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt; operators.</source>
          <target state="translated">Guards start with the &lt;code&gt;when&lt;/code&gt; operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns &lt;code&gt;true&lt;/code&gt; . Multiple boolean conditions can be combined with the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#and/2&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#or/2&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; operators.</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="d645d6ef806b49668fa2c86b98204a1d0cbd439f" translate="yes" xml:space="preserve">
          <source>Guide: Metaprogramming</source>
          <target state="translated">가이드 : 메타 프로그래밍</target>
        </trans-unit>
        <trans-unit id="fc6d12560c986e5d173ff3f215b4fdc7dd78c449" translate="yes" xml:space="preserve">
          <source>Guide: Mix &amp;amp; OTP</source>
          <target state="translated">가이드 : 믹스 및 OTP</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="1e562d47149e19ed5cad18f5c03b2789d427f02b" translate="yes" xml:space="preserve">
          <source>Handles assigns in quoted expressions.</source>
          <target state="translated">따옴표로 묶은 표현식에서 할당을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ddf833f3c5194a503cfbad70c99e1db7094771aa" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~C&lt;/code&gt; for charlists.</source>
          <target state="translated">charlists에 대한 sigil &lt;code&gt;~C&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="fb3ba3c1a95dbc32cd091a7bf8625e909b666103" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~D&lt;/code&gt; for dates.</source>
          <target state="translated">날짜 의시길 &lt;code&gt;~D&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="982325391ef0142622780269edf1546f73b262a3" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~N&lt;/code&gt; for naive date times.</source>
          <target state="translated">순진한 날짜 시간 동안 시길 &lt;code&gt;~N&lt;/code&gt; 을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="61bcb2084c564ad8723451ec89fc1bbe6d5b39d6" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~R&lt;/code&gt; for regular expressions.</source>
          <target state="translated">정규식에 대한 sigil &lt;code&gt;~R&lt;/code&gt; 을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="ee65de02481e36f7795050fdcbac43c76b0097f0" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~S&lt;/code&gt; for strings.</source>
          <target state="translated">문자열 의시길 &lt;code&gt;~S&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="021700491c061be385dd02126ab31483e68097c1" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~T&lt;/code&gt; for times.</source>
          <target state="translated">시길 &lt;code&gt;~T&lt;/code&gt; 를 여러 번 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="2b0a2c1b8e946dd36ec07ae3f98021a22faab492" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시길 &lt;code&gt;~U&lt;/code&gt; 를 처리하여 UTC &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="edea9c3c145eb520a4b09a9b6e8ef37e6cb7464e" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;https://hexdocs.pm/elixir/DateTime.html&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3f52b59decaffdf3dbd50c018dec832cff60ddfc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~W&lt;/code&gt; for list of words.</source>
          <target state="translated">단어 목록에 대한 시길 &lt;code&gt;~W&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="3f9e6bb6b9375b71e2dd3e6c31781d8b7de4f2bc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~c&lt;/code&gt; for charlists.</source>
          <target state="translated">charlists에 대한 sigil &lt;code&gt;~c&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="e93b408b9addb240b0d8fec06f1cc6fd6483cad8" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~r&lt;/code&gt; for regular expressions.</source>
          <target state="translated">정규식에 대한 sigil &lt;code&gt;~r&lt;/code&gt; 을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8529f6bd35c204f46a458ef8fe33f88fe57b75" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~s&lt;/code&gt; for strings.</source>
          <target state="translated">처리시길 &lt;code&gt;~s&lt;/code&gt; 문자열.</target>
        </trans-unit>
        <trans-unit id="812d965b782f5a4cdb2aa6ca4e03193e8426a888" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~w&lt;/code&gt; for list of words.</source>
          <target state="translated">단어 목록에 대한 시길 &lt;code&gt;~w&lt;/code&gt; 를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="7849ebf167a97ce455aff4c671cafc34086c2adc" translate="yes" xml:space="preserve">
          <source>Happy coding!</source>
          <target state="translated">행복한 코딩!</target>
        </trans-unit>
        <trans-unit id="e74fbc6484fa15dc5415ec3ea61b85c17ae16042" translate="yes" xml:space="preserve">
          <source>HashDict</source>
          <target state="translated">HashDict</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b4f9c2553efc8e434d9a14c06152b8e6c5d5f2d5" translate="yes" xml:space="preserve">
          <source>Help for all of those functions can be consulted directly from the command line using the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; helper itself. Try:</source>
          <target state="translated">이러한 모든 기능에 대한 도움말은 &lt;a href=&quot;#h/1&quot;&gt; &lt;code&gt;h/1&lt;/code&gt; &lt;/a&gt; 헬퍼 자체를 사용하여 명령 행에서 직접 참조 할 수 있습니다 . 시험:</target>
        </trans-unit>
        <trans-unit id="3dc137e03814f2f8c65320b0dffc705dd74522ae" translate="yes" xml:space="preserve">
          <source>Helper functions for formatting and the formatting protocols.</source>
          <target state="translated">Helper functions for formatting and the formatting protocols.</target>
        </trans-unit>
        <trans-unit id="6807f0882791439924cfe88b4665c74673dc2b7c" translate="yes" xml:space="preserve">
          <source>Helper module</source>
          <target state="translated">Helper module</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="c42a25368aea44b1d8b6e2caeca032b5ca554730" translate="yes" xml:space="preserve">
          <source>Helpers for defining test cases.</source>
          <target state="translated">테스트 사례를 정의하는 도우미</target>
        </trans-unit>
        <trans-unit id="d5c884b844c2ebd809f20b51b9edc72b238135da" translate="yes" xml:space="preserve">
          <source>Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated.</source>
          <target state="translated">따라서 이름은 &quot;flex&quot;입니다. 문서 피팅과 관련하여 더 유연합니다. 반면, 각 휴식 시간을 다시 평가해야하므로 비용이 더 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="b1aef6d0ceaad34efbe32b0b7338abfa12a31756" translate="yes" xml:space="preserve">
          <source>Here are some examples of working with different types and modifiers:</source>
          <target state="translated">다른 유형 및 수정 자 작업에 대한 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42db1d3d86baee9f18579aec4c71f6475b37d168" translate="yes" xml:space="preserve">
          <source>Here are some invalid ones:</source>
          <target state="translated">다음은 유효하지 않은 것들입니다 :</target>
        </trans-unit>
        <trans-unit id="11442cf4a8b2c1cb2e42c80414e3bc9baaa0cb80" translate="yes" xml:space="preserve">
          <source>Here are some valid paths:</source>
          <target state="translated">유효한 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="352db02f68b7960ade3f7f5b302deb2325291825" translate="yes" xml:space="preserve">
          <source>Here is a better implementation of our Stack module:</source>
          <target state="translated">다음은 스택 모듈을 더 잘 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3dfbcd6177f2eeaaed92da7d1fa4ce5d577524c" translate="yes" xml:space="preserve">
          <source>Here is a rundown of the life-cycle of the test process:</source>
          <target state="translated">테스트 프로세스 수명주기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b69e6d654ffc481049b79c6ad68ac13e993788a" translate="yes" xml:space="preserve">
          <source>Here is an example of a &lt;code&gt;.formatter.exs&lt;/code&gt; file that works as a starting point:</source>
          <target state="translated">Here is an example of a &lt;code&gt;.formatter.exs&lt;/code&gt; file that works as a starting point:</target>
        </trans-unit>
        <trans-unit id="b7fa9405686c3918f67bf3e27b8a6096e14cbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="translated">다음은 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 &lt;code&gt;:console&lt;/code&gt; 백엔드 를 구성하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b3a43eba555f0c13a34172cd9439caffcb152633" translate="yes" xml:space="preserve">
          <source>Here is an example on how we mimic an echo server from the command line:</source>
          <target state="translated">다음은 명령 행에서 에코 서버를 모방하는 방법에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="3edae206369380098d80617af169ddbd0abfffd5" translate="yes" xml:space="preserve">
          <source>Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2:</source>
          <target state="translated">다음은 짝수를 삭제하고 홀수에 2를 곱한 목록을 순회하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="719c74f661d33fc8656d2bb7f5d2aed1ea13f147" translate="yes" xml:space="preserve">
          <source>Here is an example where all keys match:</source>
          <target state="translated">Here is an example where all keys match:</target>
        </trans-unit>
        <trans-unit id="050a27ec30c2a26d404808ec75322f708750e58e" translate="yes" xml:space="preserve">
          <source>Here is the full echo server implementation:</source>
          <target state="translated">전체 에코 서버 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f777b3d9caee14d91c8f30553a83cea3e2dc561" translate="yes" xml:space="preserve">
          <source>Here is the updated code for the &lt;code&gt;TestCase&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;TestCase&lt;/code&gt; 모듈에 대한 업데이트 된 코드는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a22b63cc9c9e1b1cf8079d3829c10b45935571fc" translate="yes" xml:space="preserve">
          <source>Here is when a subset of the keys match:</source>
          <target state="translated">Here is when a subset of the keys match:</target>
        </trans-unit>
        <trans-unit id="84bb9c9b475cb5ae8d6aa130c97b79761a44437b" translate="yes" xml:space="preserve">
          <source>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and &lt;em&gt;mapping&lt;/em&gt; over it is known as a &lt;em&gt;map algorithm&lt;/em&gt;.</source>
          <target state="translated">여기서 우리는 재귀를 사용하여 목록을 탐색하고 각 요소를 두 배로 늘리고 새 목록을 반환했습니다. 목록을 복용하는 과정 &lt;em&gt;매핑&lt;/em&gt; 그것이로 알려져을 통해 &lt;em&gt;지도 알고리즘&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5c22f5f67bc89de4473d36dd5d40a24915681d3c" translate="yes" xml:space="preserve">
          <source>Here we will use Agents, and create a module named &lt;code&gt;KV.Bucket&lt;/code&gt;, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.</source>
          <target state="translated">여기서 에이전트를 사용하고 &lt;code&gt;KV.Bucket&lt;/code&gt; 이라는 모듈을 작성하여 키-값 항목을 다른 프로세스에서 읽고 수정할 수있는 방식으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3e5a3bc41bc733073ea1b7c356d6fc16ff9a31eb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we could write the same &lt;code&gt;Utility.type/1&lt;/code&gt; functionality as a protocol:</source>
          <target state="translated">Here&amp;rsquo;s how we could write the same &lt;code&gt;Utility.type/1&lt;/code&gt; functionality as a protocol:</target>
        </trans-unit>
        <trans-unit id="4a4f491539740358c0862f6ed0caff8dd3eb4c91" translate="yes" xml:space="preserve">
          <source>Here, 257 in base 2 would be represented as &lt;code&gt;100000001&lt;/code&gt;, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to &lt;code&gt;00000001&lt;/code&gt;, or simply &lt;code&gt;1&lt;/code&gt; in decimal.</source>
          <target state="translated">Here, 257 in base 2 would be represented as &lt;code&gt;100000001&lt;/code&gt; , but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to &lt;code&gt;00000001&lt;/code&gt; , or simply &lt;code&gt;1&lt;/code&gt; in decimal.</target>
        </trans-unit>
        <trans-unit id="bbd25c9ac39901e5a89af9e9cc14cd5e96101d55" translate="yes" xml:space="preserve">
          <source>Here, the arrow (&lt;code&gt;&amp;lt;--&lt;/code&gt;) indicates the &lt;strong&gt;marked&lt;/strong&gt; function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below).</source>
          <target state="translated">여기에서 화살표 ( &lt;code&gt;&amp;lt;--&lt;/code&gt; )는 &lt;strong&gt;표시된&lt;/strong&gt; 기능-이 단락에서 설명하는 기능을 나타냅니다 . 또한 직접 호출자 (위)와 호출 된 함수 (아래)를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f90a2dd87f0e0e5b3fc18bbdd374ab3f255b75b6" translate="yes" xml:space="preserve">
          <source>Hex options (&lt;code&gt;:hex&lt;/code&gt;)</source>
          <target state="translated">16 진 옵션 ( &lt;code&gt;:hex&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="778ad2f9bcae03814f9abdf00cda4d6b0dd5b58c" translate="yes" xml:space="preserve">
          <source>Hexadecimals and Unicode code points will be escaped if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?x&lt;/code&gt;. Unicode code points if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?u&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;?x&lt;/code&gt; 대해 map 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 16 진 및 유니 코드 코드 포인트가 이스케이프됩니다 . 맵 함수가 &lt;code&gt;?u&lt;/code&gt; 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 유니 코드 코드 포인트 .</target>
        </trans-unit>
        <trans-unit id="26e85f63826bec68a04b03d81896950af6108f8b" translate="yes" xml:space="preserve">
          <source>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</source>
          <target state="translated">가비지 수집에 너무 많은 시간이 소비 될 수 있으므로 최대 절전 모드를 적극적으로 사용해서는 안됩니다. 일반적으로 메시지가 곧 예상되지 않고 프로세스 메모리를 최소화하는 것이 유리한 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86c45c0195b718d67c0a438292af56b71a044d2f" translate="yes" xml:space="preserve">
          <source>Hiding Internal Modules and Functions</source>
          <target state="translated">내부 모듈 및 기능 숨기기</target>
        </trans-unit>
        <trans-unit id="0ea7288fabe36d1374b87e85268bd81849d9bced" translate="yes" xml:space="preserve">
          <source>History size</source>
          <target state="translated">역사 크기</target>
        </trans-unit>
        <trans-unit id="d5f481ffbf704bd71ae3b341524ffae254c4f8b3" translate="yes" xml:space="preserve">
          <source>Hot Code Upgrades</source>
          <target state="translated">Hot Code Upgrades</target>
        </trans-unit>
        <trans-unit id="fc314201ff6cdd49c00bb54c2d3a38dc7360de1d" translate="yes" xml:space="preserve">
          <source>Hot code swapping</source>
          <target state="translated">핫 코드 스와핑</target>
        </trans-unit>
        <trans-unit id="5a2b9c570ab736a0a992067e06ddc44051493496" translate="yes" xml:space="preserve">
          <source>Hour using a 12-hour clock</source>
          <target state="translated">Hour using a 12-hour clock</target>
        </trans-unit>
        <trans-unit id="0b231acab966b52e86353b589bad7d81125cc30e" translate="yes" xml:space="preserve">
          <source>Hour using a 24-hour clock</source>
          <target state="translated">Hour using a 24-hour clock</target>
        </trans-unit>
        <trans-unit id="3935f3cf215c2daeec7c25cef51c0a03f6190f58" translate="yes" xml:space="preserve">
          <source>How can this line fail if we just created the bucket in the previous line?</source>
          <target state="translated">이전 라인에서 버킷을 생성 한 경우이 라인이 어떻게 실패 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="04ccc44e58210facfedf9edfba2604fce3cfc2e4" translate="yes" xml:space="preserve">
          <source>How to supervise</source>
          <target state="translated">감독하는 방법</target>
        </trans-unit>
        <trans-unit id="7cdfd34c64026a6f64366847c32473d397480980" translate="yes" xml:space="preserve">
          <source>However Elixir introduces a syntax sugar where the keywords above may be written as follows:</source>
          <target state="translated">그러나 Elixir는 위의 키워드가 다음과 같이 작성 될 수있는 구문 설탕을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="7d4e3b65932901a80bd0c8daa5e66bd16aedca07" translate="yes" xml:space="preserve">
          <source>However, a quoted variable is represented as:</source>
          <target state="translated">그러나 인용 변수는 다음과 같이 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="057b67626d2f5f52a384b7c48714343f2812737b" translate="yes" xml:space="preserve">
          <source>However, after our project is compiled using a tool like Mix, we know all modules that have been defined, including protocols and their implementations. This way, the protocol can be consolidated into a very simple and fast dispatch module.</source>
          <target state="translated">그러나 프로젝트를 Mix와 같은 도구를 사용하여 컴파일 한 후에는 프로토콜 및 구현을 포함하여 정의 된 모든 모듈을 알고 있습니다. 이런 식으로 프로토콜을 매우 간단하고 빠른 디스패치 모듈로 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b8c9087b77b2def4f60524eab486ec77b7882f" translate="yes" xml:space="preserve">
          <source>However, do not provide &lt;code&gt;__using__/1&lt;/code&gt; if all it does is to import, alias or require the module itself. For example, avoid this:</source>
          <target state="translated">그러나 모듈 자체를 가져 오기, 별명 지정 또는 요구하는 &lt;code&gt;__using__/1&lt;/code&gt; 제공하지 마십시오 . 예를 들어, 이것을 피하십시오 :</target>
        </trans-unit>
        <trans-unit id="ca0de7a0e18a5854d7abeb96c012e778937c81fc" translate="yes" xml:space="preserve">
          <source>However, for the tests in &lt;code&gt;KV.RouterTest&lt;/code&gt;, we effectively need two nodes in our routing table. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">However, for the tests in &lt;code&gt;KV.RouterTest&lt;/code&gt; , we effectively need two nodes in our routing table. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</target>
        </trans-unit>
        <trans-unit id="82776ff5a87946e16cbe8e021db6c7eca6df82eb" translate="yes" xml:space="preserve">
          <source>However, functions that return booleans and are valid in guards follow another convention, described next.</source>
          <target state="translated">그러나 부울을 반환하고 가드에서 유효한 함수는 다음에 설명 된 다른 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e2f8333bf85aa3e6557d871123f4e54aa89129c2" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">그러나 &quot;&amp;eacute;&quot;가 단일 문자 &quot;e with acute&quot;악센트로 표시되면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2dea6b01d6679272ba037abafc94d5ec1f3a1e91" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part:</source>
          <target state="translated">그러나 &quot;&amp;eacute;&quot;가 단일 문자 &quot;e with acute&quot;악센트로 표시되면 문자열을 한 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="43d541b3bc1e148da1c64ef9ffa0bbfd2e7364f7" translate="yes" xml:space="preserve">
          <source>However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as:</source>
          <target state="translated">그러나 플렉스 브레이크를 사용하면 렌더링 할 때 각 브레이크가 다시 평가되므로 문서를 다음과 같이 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e59920d8100c9a8114a12d93422f9d86a0ab473f" translate="yes" xml:space="preserve">
          <source>However, if there is a need to access the user variable, nil can be given:</source>
          <target state="translated">그러나 사용자 변수에 액세스해야하는 경우 nil을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebac26b5b96f39c6c425c9f7338b33aa11d33d44" translate="yes" xml:space="preserve">
          <source>However, if we use &lt;code&gt;string&lt;/code&gt;, then the string length is used, instead of byte size, correctly fitting:</source>
          <target state="translated">그러나 &lt;code&gt;string&lt;/code&gt; 을 사용하면 바이트 크기 대신 문자열 길이가 올바르게 맞춰집니다.</target>
        </trans-unit>
        <trans-unit id="163ec0dc8d44d05de91c4d5e307d82258afc33ad" translate="yes" xml:space="preserve">
          <source>However, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:</source>
          <target state="translated">그러나 파일이있을 것으로 예상되는 경우 의미있는 오류 메시지가 표시되므로 강타 변형이 더 유용합니다. 쓰기를 피하십시오 :</target>
        </trans-unit>
        <trans-unit id="b26ef74513acb14878e64cf7d06f11768d520400" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (e.g. if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">그러나 결과가 항상 성공할 것으로 예상하는 경우 (예 : 파일이 항상 존재한다고 예상하는 경우) 변동이 더 편리 할 수 ​​있으며 실패시 패턴 일치 실패보다 더 유용한 오류 메시지가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f76bd9d28fa6001b9c29fd594f3da25de0125efb" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="translated">However, if you expect the outcome to always to be successful (for instance, if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</target>
        </trans-unit>
        <trans-unit id="12f2ae0ce38b2739810767448aba2df24da58505" translate="yes" xml:space="preserve">
          <source>However, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.</source>
          <target state="translated">그러나 모든 응용 프로그램을 별도의 프로젝트로 Git 리포지토리에 푸시하면 코드를 작성하는 대신 Git 리포지토리를 관리하는 데 많은 시간을 소비하므로 프로젝트를 유지 관리하기가 매우 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4db01e79b2e5a22ecea1d3f50d5983cb25a53b4" translate="yes" xml:space="preserve">
          <source>However, if you want to invoke a specific module, function and arguments, or give the task process a name, you need to define the task in its own module:</source>
          <target state="translated">그러나 특정 모듈, 함수 및 인수를 호출하거나 태스크 프로세스에 이름을 지정하려면 고유 한 모듈로 태스크를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d300780723b1e1d9cb8cf90e34f684379371fda8" translate="yes" xml:space="preserve">
          <source>However, if you want to re-use the sigil character itself on the string, you need to escape it:</source>
          <target state="translated">However, if you want to re-use the sigil character itself on the string, you need to escape it:</target>
        </trans-unit>
        <trans-unit id="9832e5845d5128f4155ac9809559b224c95909bd" translate="yes" xml:space="preserve">
          <source>However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt;&lt;code&gt;is_tuple/1&lt;/code&gt;&lt;/a&gt; before &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt;, otherwise the whole guard will fail if a tuple is not given. Alternatively your function clause can use multiple guards as shown in the following section.</source>
          <target state="translated">However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#is_tuple/1&quot;&gt; &lt;code&gt;is_tuple/1&lt;/code&gt; &lt;/a&gt; before &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt;, otherwise the whole guard will fail if a tuple is not given. Alternatively your function clause can use multiple guards as shown in the following section.</target>
        </trans-unit>
        <trans-unit id="bbb15fb0156049fcce5c409f89352f9b00a36988" translate="yes" xml:space="preserve">
          <source>However, implementation-wise, they have the following differences:</source>
          <target state="translated">However, implementation-wise, they have the following differences:</target>
        </trans-unit>
        <trans-unit id="ab714719ee8f889dd923393f22c68b77c2b16ffe" translate="yes" xml:space="preserve">
          <source>However, in some cases it may be desired to associate a value to the process using the alternate &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; tuple:</source>
          <target state="translated">그러나 경우에 따라 대체 &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; 튜플을 사용하여 프로세스에 값을 연결해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4761ed59b0d1afa93377c7f7b363dfb8fb4fda3" translate="yes" xml:space="preserve">
          <source>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the &lt;code&gt;^&lt;/code&gt; special form, colloquially known as the pin operator:</source>
          <target state="translated">그러나 일부 상황에서는 리 바인딩 대신 기존 값과 일치시키는 것이 유용합니다. 이것은 핀 연산자로 구어체로 알려진 &lt;code&gt;^&lt;/code&gt; 특수 형식 으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96e149dd0b884d4a6fa96fb42e3515395245b191" translate="yes" xml:space="preserve">
          <source>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</source>
          <target state="translated">그러나 대부분의 경우 작업 관리자를 감독 트리에 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="dba0c307e5ca681865cce6227a859a96ae9a11f3" translate="yes" xml:space="preserve">
          <source>However, instead of adding more code to the &lt;code&gt;kv&lt;/code&gt; application, we are going to build the TCP server as another application that is a client of the &lt;code&gt;kv&lt;/code&gt; application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.</source>
          <target state="translated">그러나 대신에 더 많은 코드를 추가하는 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램, 우리의 클라이언트 인 다른 응용 프로그램으로 TCP 서버를 구축하려고 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램입니다. 전체 런타임 및 Elixir 에코 시스템은 애플리케이션에 맞춰져 있기 때문에 프로젝트를 크고 모 놀리 식 앱을 구축하는 대신 함께 작동하는 더 작은 애플리케이션으로 나누는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0b1ff55d618bd8bbea3c57925ed60e856baa189" translate="yes" xml:space="preserve">
          <source>However, instead of modifying those files after the release is built, the simplest way to customize those files is by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt;&lt;code&gt;mix release.init&lt;/code&gt;&lt;/a&gt;. The Mix task will copy custom &lt;code&gt;rel/vm.args.eex&lt;/code&gt;, &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; files to your project root. You can modify those files and they will be evaluated every time you perform a new release. Those files are regular EEx templates and they have a single assign, called &lt;code&gt;@release&lt;/code&gt;, with the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt;&lt;code&gt;Mix.Release&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">However, instead of modifying those files after the release is built, the simplest way to customize those files is by running &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.Init.html&quot;&gt; &lt;code&gt;mix release.init&lt;/code&gt; &lt;/a&gt;. The Mix task will copy custom &lt;code&gt;rel/vm.args.eex&lt;/code&gt; , &lt;code&gt;rel/env.sh.eex&lt;/code&gt; , and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; files to your project root. You can modify those files and they will be evaluated every time you perform a new release. Those files are regular EEx templates and they have a single assign, called &lt;code&gt;@release&lt;/code&gt; , with the &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Release.html&quot;&gt; &lt;code&gt;Mix.Release&lt;/code&gt; &lt;/a&gt; struct.</target>
        </trans-unit>
        <trans-unit id="1f2acb719b57d971a999b6feb20a4c47ae5bfcf5" translate="yes" xml:space="preserve">
          <source>However, keep in mind that adding &lt;code&gt;@doc false&lt;/code&gt; does not make the function private. The function above can still be invoked as &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt;. Not only that, if &lt;code&gt;MyApp.Sample&lt;/code&gt; is imported, the &lt;code&gt;add/2&lt;/code&gt; function will also be imported into the caller. For those reasons, be cautious when adding &lt;code&gt;@doc false&lt;/code&gt; to functions, instead use one of these two options:</source>
          <target state="translated">그러나 &lt;code&gt;@doc false&lt;/code&gt; 를 추가 해도이 함수는 개인용이 아닙니다. 위 함수는 여전히 &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt; 로 호출 할 수 있습니다 . 뿐만 아니라 &lt;code&gt;MyApp.Sample&lt;/code&gt; 을 가져 오면 &lt;code&gt;add/2&lt;/code&gt; 함수도 호출자로 가져옵니다. 이러한 이유로 함수에 &lt;code&gt;@doc false&lt;/code&gt; 를 추가 할 때는주의해야 합니다. 대신 다음 두 옵션 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce1e4503150dc2f3049f826f979cbe9905825d87" translate="yes" xml:space="preserve">
          <source>However, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run.</source>
          <target state="translated">그러나 테스트를 배포하면 모든 테스트 실행에 대해 분산 설정을 수행하지 않을 수 있으므로 테스트를 자주 수행하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3693f464a1590f76c7a514020cc3b6b0e554bf8d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt; which acts as a no-op for dead processes.</target>
        </trans-unit>
        <trans-unit id="f5ae69f63821cec3eb4f2016854327b6c5df477d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="translated">그러나 이러한 경우는 일반적으로 문제가되지 않습니다. 결국, PID가 참조하는 프로세스는 레지스트리에서 값을 가져오고 메시지를 보내는 것 사이를 포함하여 언제든지 충돌 할 수 있습니다. 표준 라이브러리의 많은 부분은 &lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; 과 같이 모니터 된 프로세스가 이미 종료 된 경우 즉시 &lt;code&gt;:DOWN&lt;/code&gt; 메시지를 전달 하고 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt; 는 죽은 상태 로 작동하지 않는 역할을합니다. 프로세스.</target>
        </trans-unit>
        <trans-unit id="ea02d735a03ee13559ceb754eeca6008810c2c76" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">However, many other enumerables exist in the language, such as &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt;s and the data type returned by &lt;a href=&quot;https://hexdocs.pm/elixir/File.html#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</target>
        </trans-unit>
        <trans-unit id="9a395466f1651904a7d0044a0e96b1a814183371" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="translated">그러나 많은 다른 enumerables 같은 언어에 존재하는 &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 에&lt;/a&gt; 의에 의해 반환되는 데이터 형식 &lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; &lt;/a&gt; 그것이 열거 인 것처럼 파일이 이송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b496aae43041f07a94c194092a1ee0cf80d4eec" translate="yes" xml:space="preserve">
          <source>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and &lt;strong&gt;we should never convert user input to atoms&lt;/strong&gt;. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</source>
          <target state="translated">그러나 원자로 동적 프로세스를 명명하는 것은 끔찍한 생각입니다! 원자를 사용하는 경우 버킷 이름 (종종 외부 클라이언트로부터 수신)을 원자로 &lt;strong&gt;변환해야하며 사용자 입력을 atoms로 변환해서는 안됩니다&lt;/strong&gt; . 원자가 가비지 수집되지 않기 때문입니다. 원자가 생성되면 절대 재생되지 않습니다. 사용자 입력에서 원자를 생성하면 사용자가 시스템 메모리를 소진하기에 충분한 다른 이름을 주입 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="df3b6ab895dd3f7bd985857fc1933851a28e562b" translate="yes" xml:space="preserve">
          <source>However, remember that binary pattern matching works on &lt;em&gt;bytes&lt;/em&gt;, so matching on the string like &amp;ldquo;&amp;uuml;ber&amp;rdquo; with multibyte characters won&amp;rsquo;t match on the &lt;em&gt;character&lt;/em&gt;, it will match on the &lt;em&gt;first byte of that character&lt;/em&gt;:</source>
          <target state="translated">However, remember that binary pattern matching works on &lt;em&gt;bytes&lt;/em&gt;, so matching on the string like &amp;ldquo;&amp;uuml;ber&amp;rdquo; with multibyte characters won&amp;rsquo;t match on the &lt;em&gt;character&lt;/em&gt;, it will match on the &lt;em&gt;first byte of that character&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="77afe59f2cf778e4ba45a1656955754632ba1dec" translate="yes" xml:space="preserve">
          <source>However, should we be fine with the implementation for &lt;code&gt;Any&lt;/code&gt;, in order to use such implementation we would need to tell our struct to explicitly derive the &lt;code&gt;Size&lt;/code&gt; protocol:</source>
          <target state="translated">그러나 &lt;code&gt;Any&lt;/code&gt; 구현에 문제가 없다면 그러한 구현을 사용하려면 구조체에 명시 적으로 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 도출하도록 지시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1f35366701d4be066fddfcbe4789ab0e44ff649f" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;KV.Registry.create/2&lt;/code&gt; is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</source>
          <target state="translated">그러나 &lt;code&gt;KV.Registry.create/2&lt;/code&gt; 는 캐스트 조작이므로 실제로 테이블에 쓰기 전에 명령이 리턴됩니다! 다시 말해, 이것은 일어나고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b607bf41eed0b7acedbf1d601f4e6081a4cb7cfb" translate="yes" xml:space="preserve">
          <source>However, since structs are just maps, they work with the functions from the &lt;code&gt;Map&lt;/code&gt; module:</source>
          <target state="translated">그러나 구조체는 맵일 뿐이므로 &lt;code&gt;Map&lt;/code&gt; 모듈 의 함수와 함께 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e7b768f9063dad4bbd7d785c035b8dad45c243ae" translate="yes" xml:space="preserve">
          <source>However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the &lt;code&gt;start_link&lt;/code&gt; argument instead of the specification:</source>
          <target state="translated">그러나 각 자식에 대한 자식 사양을지도로 지정하면 스택 구현을 변경하고 사양을 업데이트하는 것을 잊을 수 있으므로 오류가 발생하기 쉽습니다. 이것이 Elixir 가 스펙 대신 모듈 이름과 &lt;code&gt;start_link&lt;/code&gt; 인수 로 튜플을 전달할 수있게하는 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="496f233e2f16ce1ec282e5a3228096d9e60212a4" translate="yes" xml:space="preserve">
          <source>However, strings are just part of the story. If a string is a binary, and we have used the &lt;code&gt;is_binary/1&lt;/code&gt; function, Elixir must have an underlying type empowering strings. And it does! Let&amp;rsquo;s talk about binaries.</source>
          <target state="translated">그러나 현은 이야기의 일부일뿐입니다. 문자열이 이진이고 &lt;code&gt;is_binary/1&lt;/code&gt; 함수를 사용한 경우 Elixir는 기본 유형 권한 부여 문자열을 가져야합니다. 그리고 그렇습니다! 바이너리에 대해 이야기합시다.</target>
        </trans-unit>
        <trans-unit id="dd71889ec3595479588d8ca1a2ca3333e184a132" translate="yes" xml:space="preserve">
          <source>However, the capturing of any other named device, such as &lt;code&gt;:stderr&lt;/code&gt;, happens globally and persists until the function has ended. While this means it is safe to run your tests with &lt;code&gt;async: true&lt;/code&gt; in many cases, captured output may include output from a different test and care must be taken when using &lt;code&gt;capture_io&lt;/code&gt; with a named process asynchronously.</source>
          <target state="translated">However, the capturing of any other named device, such as &lt;code&gt;:stderr&lt;/code&gt; , happens globally and persists until the function has ended. While this means it is safe to run your tests with &lt;code&gt;async: true&lt;/code&gt; in many cases, captured output may include output from a different test and care must be taken when using &lt;code&gt;capture_io&lt;/code&gt; with a named process asynchronously.</target>
        </trans-unit>
        <trans-unit id="82b09700b9bf9936f190f1106abb6ccb1f220f41" translate="yes" xml:space="preserve">
          <source>However, the code below would work as long as &lt;code&gt;:option_parser_example&lt;/code&gt; atom is used at some point later (or earlier) &lt;strong&gt;in the same module&lt;/strong&gt;. For example:</source>
          <target state="translated">그러나 아래의 코드는 &lt;code&gt;:option_parser_example&lt;/code&gt; atom이 &lt;strong&gt;같은 모듈&lt;/strong&gt; 에서 어느 시점에서 (또는 이전에) 사용 &lt;strong&gt;되는 한 작동합니다&lt;/strong&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b357c81b8f132fc24fbf479211e75b269f8fae9b" translate="yes" xml:space="preserve">
          <source>However, the size cannot be defined in the match outside the binary/bitstring match:</source>
          <target state="translated">그러나 이진 / 비트 열 일치 이외의 일치에서는 크기를 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0f50242052626c017e46fce09925693cd1c9dd3" translate="yes" xml:space="preserve">
          <source>However, there are times when we don&amp;rsquo;t want variables to be rebound.</source>
          <target state="translated">However, there are times when we don&amp;rsquo;t want variables to be rebound.</target>
        </trans-unit>
        <trans-unit id="88399305a4f17930e312791fc1d3a07b6c89a0a2" translate="yes" xml:space="preserve">
          <source>However, there is a bug in our stack server. If we call &lt;code&gt;:pop&lt;/code&gt; and the stack is empty, it is going to crash because no clause matches:</source>
          <target state="translated">그러나 스택 서버에 버그가 있습니다. &lt;code&gt;:pop&lt;/code&gt; 을 호출 하고 스택이 비어 있으면 일치하는 절이 없기 때문에 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b30a9e6e90f8ae42f6ce5f8d5d4ee4d68edc7af" translate="yes" xml:space="preserve">
          <source>However, there is still one concern left, which are the restart strategies. Tasks, by default, have the &lt;code&gt;:restart&lt;/code&gt; value set to &lt;code&gt;:temporary&lt;/code&gt;, which means they are not restarted. This is an excellent default for the connections started via the &lt;code&gt;Task.Supervisor&lt;/code&gt;, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.</source>
          <target state="translated">그러나 여전히 하나의 우려가 남아 있는데, 이는 다시 시작 전략입니다. 기본적으로 작업에는 &lt;code&gt;:restart&lt;/code&gt; 값이 &lt;code&gt;:temporary&lt;/code&gt; 로 설정되어 있어 다시 시작되지 않습니다. 실패한 연결을 다시 시작하는 것은 의미가 없지만 수락 자에게는 좋지 않은 선택 &lt;code&gt;Task.Supervisor&lt;/code&gt; 를 통해 시작된 연결의 탁월한 기본값입니다 . 억 셉터가 충돌하면, 억 셉터를 다시 가동 시키려고합니다.</target>
        </trans-unit>
        <trans-unit id="2654066a02c149d51e371eeaac885d94072a55a8" translate="yes" xml:space="preserve">
          <source>However, this module returns the proper length:</source>
          <target state="translated">그러나이 모듈은 적절한 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0458a5b82cdaf306b947332bf064e36f033492d1" translate="yes" xml:space="preserve">
          <source>However, this option can be expensive if you have multiple production nodes or if the release assembling process is a long one, as each node needs to individually assemble the release.</source>
          <target state="translated">However, this option can be expensive if you have multiple production nodes or if the release assembling process is a long one, as each node needs to individually assemble the release.</target>
        </trans-unit>
        <trans-unit id="41d8fdc77d8f21adeb6b27918df1a329fe13ff18" translate="yes" xml:space="preserve">
          <source>However, using lists in IO operations requires some attention. A list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the &lt;code&gt;IO&lt;/code&gt; module starting with &lt;code&gt;bin*&lt;/code&gt; must be used. Those functions expect an &lt;code&gt;iodata&lt;/code&gt; as an argument; i.e., they expect a list of integers representing bytes or binaries to be given.</source>
          <target state="translated">그러나 IO 작업에서 목록을 사용하려면 약간의주의가 필요합니다. 목록은 많은 바이트 또는 여러 개의 문자를 나타낼 수 있으며 사용할 장치는 IO 장치의 인코딩에 따라 다릅니다. 인코딩없이 파일을 열면 파일은 원시 모드에있을 것으로 예상 되며 &lt;code&gt;bin*&lt;/code&gt; 시작 하는 &lt;code&gt;IO&lt;/code&gt; 모듈 의 기능을 사용해야합니다. 이러한 함수는 &lt;code&gt;iodata&lt;/code&gt; 를 인수로 예상합니다 . 즉, 바이트 또는 이진을 나타내는 정수 목록이 제공 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="b77af23f35c905af8889b972cb68357936576822" translate="yes" xml:space="preserve">
          <source>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the &lt;code&gt;=&lt;/code&gt; operator):</source>
          <target state="translated">그러나 일치에 할당 된 변수는 함수 호출 외부에서 사용할 수 없습니다 ( &lt;code&gt;=&lt;/code&gt; 연산자 와의 정규 패턴 일치와 달리 ).</target>
        </trans-unit>
        <trans-unit id="5c24fd6169426183241dcc9a0bdf50f1c21b8290" translate="yes" xml:space="preserve">
          <source>However, variables explicitly bound in the clause &quot;body&quot; are accessible from the outer context:</source>
          <target state="translated">그러나 &quot;body&quot;절에 명시 적으로 바인딩 된 변수는 외부 컨텍스트에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b5a965ef9a419fe17594f66438c5b71c746d05" translate="yes" xml:space="preserve">
          <source>However, we can connect to the other shell remotely. Open up the &lt;code&gt;User switch command&lt;/code&gt; prompt (Ctrl+G) and type:</source>
          <target state="translated">그러나 다른 쉘에 원격으로 연결할 수 있습니다. &lt;code&gt;User switch command&lt;/code&gt; 프롬프트 (Ctrl + G)를 열고 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="b76f1491e39a30e4f05d47d9af534982461917de" translate="yes" xml:space="preserve">
          <source>However, we can spawn a new process on &lt;code&gt;foo@computer-name&lt;/code&gt; from &lt;code&gt;bar@computer-name&lt;/code&gt;! Let&amp;rsquo;s give it a try (where &lt;code&gt;@computer-name&lt;/code&gt; is the one you see locally):</source>
          <target state="translated">그러나 &lt;code&gt;foo@computer-name&lt;/code&gt; 에서 &lt;code&gt;bar@computer-name&lt;/code&gt; 으로 새로운 프로세스를 생성 할 수 있습니다 ! 시도해 봅시다 (여기서 &lt;code&gt;@computer-name&lt;/code&gt; 은 로컬에서 볼 수있는 이름 입니다) :</target>
        </trans-unit>
        <trans-unit id="f37bd2760f0cfed52b63715c0c0ee324352998b9" translate="yes" xml:space="preserve">
          <source>However, we can't invoke it as follows:</source>
          <target state="translated">그러나 다음과 같이 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="693f31cc1e3b5ed02531511f77198af8ecfd7ceb" translate="yes" xml:space="preserve">
          <source>However, when an &lt;code&gt;else&lt;/code&gt; clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;rescue&lt;/code&gt; in the same &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;else&lt;/code&gt; 절이 있지만 표현식의 결과가 패턴과 일치하지 않으면 예외가 발생합니다. 이 예외는 같은 &lt;code&gt;try&lt;/code&gt; 에서 &lt;code&gt;catch&lt;/code&gt; 또는 &lt;code&gt;rescue&lt;/code&gt; 로 잡히지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4c77097fa9973bf214463e34dd009d5f8b620b4e" translate="yes" xml:space="preserve">
          <source>However, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.</source>
          <target state="translated">그러나 수퍼바이저가 새 버킷을 다시 시작하면 레지스트리에서 해당 버킷을 알 수 없습니다. 따라서 관리자는 아무도 액세스 할 수없는 빈 버킷을 갖게됩니다! 이를 해결하기 위해 버킷이 실제로 임시적이라고 말하고 싶습니다. 이유와 상관없이 충돌이 발생하면 재시작하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="aaa0ec2494f85dbc09c2cf136ebd0615520b8aec" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause simply fails to match:</source>
          <target state="translated">그러나 가드에서 사용될 때 해당 절이 단순히 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="194ca3b5d1e99777f19c355cce6d59f573e1d740" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause will fail to match instead of raising an error:</source>
          <target state="translated">However, when used in guards, the corresponding clause will fail to match instead of raising an error:</target>
        </trans-unit>
        <trans-unit id="659be2322a62899199e6224a02bca5b99ed29e51" translate="yes" xml:space="preserve">
          <source>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in &lt;code&gt;:raw&lt;/code&gt; mode. The options &lt;code&gt;:read_ahead&lt;/code&gt; and &lt;code&gt;:delayed_write&lt;/code&gt; are also useful when operating on large files or working with files in tight loops.</source>
          <target state="translated">그러나이 추상화에 대한 가격을 항상 지불하고 싶지는 않을 수 있습니다. 이러한 경우 파일을 &lt;code&gt;:raw&lt;/code&gt; 모드 에서 열 수 있습니다 . &lt;code&gt;:read_ahead&lt;/code&gt; 및 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션 은 큰 파일에서 작업하거나 타이트한 루프로 파일을 작업 할 때도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f893640c0df5ffde8dd2c6fee00f09a1846f23f1" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could do:</source>
          <target state="translated">그러나 프로덕션 환경에는 특정 요구 사항이있을 수 있습니다. 예를 들어 지금 당장은 라우팅 테이블을 하드 코딩하고 있지만 프로덕션 환경에서는 디스크, 다른 서비스 또는 라우팅 도구 (예 : Kubernetes)에서 라우팅 테이블을 읽어야 할 수도 있습니다. &lt;code&gt;config/releases.exs&lt;/code&gt; 를 추가하면 됩니다 . 이름에서 알 수 있듯이이 파일은 릴리스가 시작될 때마다 실행됩니다. 예를 들어 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edea2ca00218d63cdd854e8d487aa95dfd59b53c" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt; . As the name says, this file runs every time the release starts. For instance, you could make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</target>
        </trans-unit>
        <trans-unit id="5ff8ae7f9913820c4cc328c8f087e28f17634493" translate="yes" xml:space="preserve">
          <source>Hygiene in aliases</source>
          <target state="translated">별칭의 위생</target>
        </trans-unit>
        <trans-unit id="93c4bc3fa55a161e49f6a7b16214db78fe9e8cb2" translate="yes" xml:space="preserve">
          <source>Hygiene in imports</source>
          <target state="translated">수입 위생</target>
        </trans-unit>
        <trans-unit id="2569893e8a4ee578273b8aabe0ac087b41daa61c" translate="yes" xml:space="preserve">
          <source>Hygiene in variables</source>
          <target state="translated">변수의 위생</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="a8882cab0a9a900efc9a6181ff8e693783509bb4" translate="yes" xml:space="preserve">
          <source>IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.</source>
          <target state="translated">IANA는 시간대에 대한 다양한 UTC 오프셋 및 표준 오프셋에 대한 데이터를 포함하는 시간대 데이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c31397c072d7bdb4a10bd53b1d1d02f67a9c1ce2" translate="yes" xml:space="preserve">
          <source>ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus &lt;code&gt;Other_ID_Continue&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points.</source>
          <target state="translated">ID_Start 문자와 유니 코드 일반 비 간격 표시 범주, 간격 결합 표시, 10 진수, 커넥터 구두점 및 &lt;code&gt;Other_ID_Continue&lt;/code&gt; , 빼기 &lt;code&gt;Pattern_Syntax&lt;/code&gt; 및 &lt;code&gt;Pattern_White_Space&lt;/code&gt; 코드 포인트가있는 문자</target>
        </trans-unit>
        <trans-unit id="c2ad7abf6ecd35c09ec969d6e5c5f626d2f547e0" translate="yes" xml:space="preserve">
          <source>IEx</source>
          <target state="translated">IEx</target>
        </trans-unit>
        <trans-unit id="bfd7d496a0b2c2b60b82d2300407f3ae22ad37d7" translate="yes" xml:space="preserve">
          <source>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</source>
          <target state="translated">IEx를 사용하면 두 가지 방식으로 다른 노드에 연결할 수 있습니다. 우선, 현재 쉘과 연결하고자하는 쉘 모두에 이름을 부여한 경우에만 쉘에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4f60e469c0e609dec1269dbd88a28be0de6f53" translate="yes" xml:space="preserve">
          <source>IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function.</source>
          <target state="translated">IEx는 또한 Elixir 코드에 중단 점을 설정하고 실행중인 프로세스에 &quot;들어 올리&quot;는 기능을 가지고 있습니다. 이를 통해 개발자는 주어진 기능 내에서 IEx 세션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2b6b57cb35a438bfce75b9ed0826e918fad577" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx는 입력을 한 줄씩 열렬하게 평가합니다. 즉, 줄 끝에서 지금까지 본 코드가 완전한 식이면 IEx가 해당 지점에서이를 평가합니다. 이 동작은 여러 줄에 걸쳐 서식이 지정된 표현식에 오류가 발생할 수 있으며 종종 파이프 표현식의 경우에 해당됩니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 다음 표현식을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ef030b61ea454aec0cec73bb460dee37b9c1bf" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt; &lt;code&gt;|&amp;gt;/2&lt;/code&gt; &lt;/a&gt; operator:</target>
        </trans-unit>
        <trans-unit id="54729610ac51af0b9971d9467c379b62a1eb9d65" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</target>
        </trans-unit>
        <trans-unit id="64c5dfd453f493f03e877d65639ce61fedbb37bc" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="translated">IEx 도우미에는 중단 점과 관련된 많은 편의가 포함되어 있습니다. 아래에는 &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt; &lt;/a&gt; 과 같은 전체 모듈과 함께 나열되어 있지만 IEx 내에서 &lt;code&gt;breaks()&lt;/code&gt; 로 직접 호출 할 수 있습니다 . 그들은:</target>
        </trans-unit>
        <trans-unit id="8f54609a357af7036d3341f02f1a23c3b68eda40" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;https://hexdocs.pm/iex/IEx.Helpers.html&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; module.</target>
        </trans-unit>
        <trans-unit id="0c364f03a852b53d4a7a502b57654a110b1cce03" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;iex.helpers&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">IEx는 많은 도우미를 제공합니다. 쉘에 &lt;code&gt;h()&lt;/code&gt; 를 입력 하거나 &lt;a href=&quot;iex.helpers&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; 모듈 의 문서로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fbe836e228d1004a30dd6875de1a22111586f81" translate="yes" xml:space="preserve">
          <source>IEx will also color inspected expressions using the &lt;code&gt;:syntax_colors&lt;/code&gt; option. Such can be disabled with:</source>
          <target state="translated">IEx는 &lt;code&gt;:syntax_colors&lt;/code&gt; 옵션을 사용하여 색상 검사 된 표현식을 표시합니다 . 다음과 같이 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04ddcbeb347ea8a966dd445a3b79f8b70364e41" translate="yes" xml:space="preserve">
          <source>IEx.Helpers</source>
          <target state="translated">IEx.Helpers</target>
        </trans-unit>
        <trans-unit id="c73133afe4ab05b736cba2f1d5c857bb84e93876" translate="yes" xml:space="preserve">
          <source>IEx.Info</source>
          <target state="translated">IEx.Info</target>
        </trans-unit>
        <trans-unit id="569138c9005aad9a2a791088d7d0e2cc45e36512" translate="yes" xml:space="preserve">
          <source>IEx.Info &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">IEx.Info &lt;small&gt;protocol&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="40b4a890c64ba73558ed867016246c3ef597f257" translate="yes" xml:space="preserve">
          <source>IEx.Info.info (1)</source>
          <target state="translated">IEx.Info.info (1)</target>
        </trans-unit>
        <trans-unit id="5cbc0090e36bb601365004561eedb21e95b78b48" translate="yes" xml:space="preserve">
          <source>IEx.Info.t (0)</source>
          <target state="translated">IEx.Info.t (0)</target>
        </trans-unit>
        <trans-unit id="17bd8ed5133e3af7e767eaf3cc19dbec1b565da7" translate="yes" xml:space="preserve">
          <source>IEx.Pry</source>
          <target state="translated">IEx.Pry</target>
        </trans-unit>
        <trans-unit id="785a031a616ad88bcb1b2cd5dbbc60681be53958" translate="yes" xml:space="preserve">
          <source>IEx.Server</source>
          <target state="translated">IEx.Server</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="5b2f49f5a657a5ef736fa25eed6851c434d0dac3" translate="yes" xml:space="preserve">
          <source>IO and the file system</source>
          <target state="translated">IO와 파일 시스템</target>
        </trans-unit>
        <trans-unit id="bbc4e8881ad6a75f10bb6ea9bff4b74783ee6ecc" translate="yes" xml:space="preserve">
          <source>IO data</source>
          <target state="translated">IO 데이터</target>
        </trans-unit>
        <trans-unit id="ec099c7a428e418929af391ebb305d925a77dc9c" translate="yes" xml:space="preserve">
          <source>IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.</source>
          <target state="translated">더 큰 이진을 만들려면 더 작은 이진 청크에 대해 많은 추가 작업을 수행해야하기 때문에 IO 데이터가 존재합니다. 그러나 Erlang 및 Elixir에서 연결 바이너리는 연결된 바이너리를 새 바이너리로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="9d9b6408eac92df9305226b9c32fd45d1762d634" translate="yes" xml:space="preserve">
          <source>IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.</source>
          <target state="translated">IO 데이터는 특정 상황에서 바이너리에 대한보다 효율적인 대안으로 사용될 수있는 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="370428fc749a05dd70935487b7d4064e7d83c3fb" translate="yes" xml:space="preserve">
          <source>IO devices</source>
          <target state="translated">IO 장치</target>
        </trans-unit>
        <trans-unit id="d2ef1a7a2a7b43d0fc955e96e915a7dad9160987" translate="yes" xml:space="preserve">
          <source>IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt;&lt;code&gt;:file.position/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">IO 장치는 위치를 유지합니다. 즉, 읽기 또는 쓰기 기능에 대한 후속 호출은 장치에 마지막으로 액세스 한 위치에서 시작됩니다. 파일 위치는 &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt; &lt;code&gt;:file.position/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5cbeaffeb75ad57a2191d67bc818e573faa6d01" translate="yes" xml:space="preserve">
          <source>IO.ANSI</source>
          <target state="translated">IO.ANSI</target>
        </trans-unit>
        <trans-unit id="0089fd381dd7dfd8d488c15134d255be01885915" translate="yes" xml:space="preserve">
          <source>IO.Stream</source>
          <target state="translated">IO.Stream</target>
        </trans-unit>
        <trans-unit id="8139a358a2645d3cf610141a9bce4c7312be5781" translate="yes" xml:space="preserve">
          <source>IO.StreamError</source>
          <target state="translated">IO.StreamError</target>
        </trans-unit>
        <trans-unit id="3d7d3441a8eff66aaa0f0faa36a8a05b3a785de8" translate="yes" xml:space="preserve">
          <source>IO.StreamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">IO.StreamError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="77802d65267b1d073f6e93dafd03f4d02d064153" translate="yes" xml:space="preserve">
          <source>IO.inspect/2</source>
          <target state="translated">IO.inspect/2</target>
        </trans-unit>
        <trans-unit id="c1f9284c3367b68f5c96129104a3a9d0f4c9d187" translate="yes" xml:space="preserve">
          <source>Identifiers in Elixir are case sensitive.</source>
          <target state="translated">Elixir의 식별자는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="057deff008e9d8f83cd686c8b17c3d4c02169546" translate="yes" xml:space="preserve">
          <source>Identifying functions and documentation</source>
          <target state="translated">기능 및 문서 식별</target>
        </trans-unit>
        <trans-unit id="537a4055c25749aea0df46647a3ecdd449be90bb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.</source>
          <target state="translated">경우 &lt;a href=&quot;#after_suite/1&quot;&gt; &lt;code&gt;after_suite/1&lt;/code&gt; &lt;/a&gt; 여러 번 호출, 콜백은 역순으로 호출됩니다. 즉, 마지막 콜백 세트가 가장 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c2d101d3a59aa29536cff11d9f78612ab949d729" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:code_change/3&quot;&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/a&gt; raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:code_change/3&quot;&gt; &lt;code&gt;code_change/3&lt;/code&gt; 가&lt;/a&gt; 제기 코드 변경이 실패하고 루프는 이전 상태로 계속합니다. 따라서이 콜백에는 일반적으로 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="50441c2fc5e3f35b8a96fa96c6320ab57738cfc1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; is invoked and there are no names, a release using the application name and default values is assembled.</source>
          <target state="translated">If &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; is invoked and there are no names, a release using the application name and default values is assembled.</target>
        </trans-unit>
        <trans-unit id="eea2e17ca11f5963667c13624c09484704b91de8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, without a name, is invoked and there are multiple names, an error will be raised unless you set &lt;code&gt;default_release: NAME&lt;/code&gt; at the root of your project configuration.</source>
          <target state="translated">If &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt;, without a name, is invoked and there are multiple names, an error will be raised unless you set &lt;code&gt;default_release: NAME&lt;/code&gt; at the root of your project configuration.</target>
        </trans-unit>
        <trans-unit id="1f1a0f874c702790d228021c47f6f58e4a98062d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt; is called before the application is loaded, the application environment values specified in the &lt;code&gt;.app&lt;/code&gt; file will override the ones previously set.</source>
          <target state="translated">경우 &lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt; 응용 프로그램이로드되기 전에 호출됩니다에 지정된 응용 프로그램 환경 값 &lt;code&gt;.app&lt;/code&gt; 파일은 이전에 설정 한 것보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9f537d260ef97992e561be1422ea408f4c00b527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:abort&lt;/code&gt;, the runtime system aborts producing a core dump, if that is enabled in the operating system.</source>
          <target state="translated">만약 &lt;code&gt;:abort&lt;/code&gt; , 그가 운영 체제에 사용하는 경우, 코어 덤프를 생성하는 런타임 시스템 중단합니다.</target>
        </trans-unit>
        <trans-unit id="e351673ad711ca575120b265bcb522e29ffb1ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:all&lt;/code&gt; is given, &lt;code&gt;:eof&lt;/code&gt; is never returned, but an empty string in case the device has reached EOF.</source>
          <target state="translated">경우 &lt;code&gt;:all&lt;/code&gt; 주어집니다 &lt;code&gt;:eof&lt;/code&gt; 반환되지 않습니다,하지만 빈 문자열은 경우 장치가 EOF에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="664fc2657c2121b52010aad0e4fd4b13a3191a1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:build_per_environment&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it will create a new build per environment:</source>
          <target state="translated">&lt;code&gt;:build_per_environment&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 환경 당 새 빌드가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1cd0a5e0adcba1255cdaf72cd16d9cb0159c0426" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:discard&lt;/code&gt; is given in &lt;code&gt;leftover&lt;/code&gt;, the last chunk is discarded unless it has exactly &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">경우 &lt;code&gt;:discard&lt;/code&gt; 주어진다 &lt;code&gt;leftover&lt;/code&gt; 정확히하지 않는 한, 마지막 덩어리가 삭제됩니다 &lt;code&gt;count&lt;/code&gt; 요소를.</target>
        </trans-unit>
        <trans-unit id="4ad666f68aa0c1c3e9b90d4547788465ffe950b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:stdio&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">경우 &lt;code&gt;:stdio&lt;/code&gt; 유니 코드 장치 인, &lt;code&gt;count&lt;/code&gt; 유니 코드 코드 포인트의 수를 검색 할 의미한다. 그렇지 않으면 &lt;code&gt;count&lt;/code&gt; 는 검색 할 원시 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="1c37a0fde2ecc757cae6c2a1e1d8b99469865d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@behaviour&lt;/code&gt; has been defined, &lt;code&gt;defoverridable&lt;/code&gt; can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to &lt;code&gt;defoverridable&lt;/code&gt; will be marked as overridable.</source>
          <target state="translated">&lt;code&gt;@behaviour&lt;/code&gt; 가 정의 된 경우 모듈로 인수로 &lt;code&gt;defoverridable&lt;/code&gt; 을 호출 할 수도 있습니다. &lt;code&gt;defoverridable&lt;/code&gt; 호출 위의 동작에서 구현 된 모든 콜백은 재정의 가능한 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0535dd7868286893881566e917783949810a614d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is a negative number, it starts counting from the back to the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 음의 번호입니다, 그것은 시작에 뒤쪽에서 계산을 시작 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128e0031d4c1374c0210ba717199fde5a91caf98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is greater than the size of the rest of the &lt;code&gt;enumerable&lt;/code&gt;, then this function will reverse the rest of the enumerable.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 의 나머지의 사이즈보다 큰 &lt;code&gt;enumerable&lt;/code&gt; ,이 함수는 열거의 나머지 부분을 반전합니다.</target>
        </trans-unit>
        <trans-unit id="64a4a2dc00ee57596c01d8e55272d16ee1731764" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is not provided, &lt;code&gt;nil&lt;/code&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;default&lt;/code&gt; 제공되지 &lt;code&gt;nil&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4804fe88251de4efebed7a3b7f7ec9b900a0c7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is a PID, it must be the PID of a local process, dead or alive. If &lt;code&gt;dest&lt;/code&gt; is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</source>
          <target state="translated">경우 &lt;code&gt;dest&lt;/code&gt; PID를, 그것은 죽은이나 살아 로컬 프로세스의 PID해야합니다. 경우 &lt;code&gt;dest&lt;/code&gt; 원자이고, 이는 전송시에 조회하는 등록 프로세스의 이름이어야한다. 이름이 프로세스를 참조하지 않으면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2650eb70496be023811483cdbe9dcf267336d48b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="translated">경우 &lt;code&gt;flag&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 모니터링이 켜집니다. 경우 &lt;code&gt;flag&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; , 모니터가 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="f1c832ccf95731edf1d63b91b33e2d1fe522cd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, acc}&lt;/code&gt; the reduction is halted and the function returns &lt;code&gt;acc&lt;/code&gt;. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;fun&lt;/code&gt; 반환 &lt;code&gt;{:halt, acc}&lt;/code&gt; 감소가 정지되고 함수가 반환 된 &lt;code&gt;acc&lt;/code&gt; . 그렇지 않으면 열거 가능 항목이 소진되면이 함수는 마지막 &lt;code&gt;{:cont, acc}&lt;/code&gt; 의 누산기를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="448b014151f38127b8e5f6db3c5223d75cfbeb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index_range.last&lt;/code&gt; is out of bounds, then it is assigned as the index of the last element.</source>
          <target state="translated">경우 &lt;code&gt;index_range.last&lt;/code&gt; 가 범위 외에, 다음은 마지막 요소의 인덱스로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f65e2abd74ff7207f89b8e63ffae32b6537b7ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty string.</source>
          <target state="translated">If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty string.</target>
        </trans-unit>
        <trans-unit id="44dafce589cc2560c530b258260863b84a7ad4e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to the empty binary.</source>
          <target state="translated">경우 &lt;code&gt;joiner&lt;/code&gt; 전혀 전달되지, 빈 이진 기본값.</target>
        </trans-unit>
        <trans-unit id="3055a00c41cda5c6ac1a36cb205d2baa4d5b0fc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; is raised.</target>
        </trans-unit>
        <trans-unit id="a91338d96953ddc227939bd5311d00c34a7770ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는하는 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e25538be406057a69443efa5940b2d432b4b6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, lazily evaluates &lt;code&gt;fun&lt;/code&gt; and returns its result.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 게으르게 평가 &lt;code&gt;fun&lt;/code&gt; 하고 그 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a81a69a6fcff94ffbea2c950485431c58d11511" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, return the default value (&lt;code&gt;nil&lt;/code&gt; if no default value).</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다 (기본 값을 반환 &lt;code&gt;nil&lt;/code&gt; 을 기본값이없는 경우).</target>
        </trans-unit>
        <trans-unit id="670e493657f6e1800d6af7018ec7631dafc42777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt; , a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; exception is raised.</target>
        </trans-unit>
        <trans-unit id="ab5d096dab446f6e25ac353134ecfc0c4cc20f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;keywords&lt;/code&gt; 하는 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0aa66d148b2ac7a0571085f5d2ee7a7853bca2a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt; , a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; exception is raised.</target>
        </trans-unit>
        <trans-unit id="b02bea90648629b86487eddfaee7cd58979250c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; 하는 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ec4f9859acc852c12bc2e32bac9f65f8ba4fa9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="c0f7c37563cdb97d23ddfed9427894d235eabfd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then its value &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</target>
        </trans-unit>
        <trans-unit id="fb8ab7d4cb46594f50af6648151d0e98d320b934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The default value will not be passed through the update function.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;map&lt;/code&gt; 있으면 기존 값이 &lt;code&gt;fun&lt;/code&gt; 에 전달 되고 그 결과가 &lt;code&gt;key&lt;/code&gt; 의 업데이트 된 값으로 사용 됩니다 . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; 의 값으로 삽입 &lt;code&gt;key&lt;/code&gt; . 기본값은 업데이트 기능을 통해 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d36aa454c42946e2c34ba9f399b287cb43ac6ce3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; then the existing value is passed to &lt;code&gt;fun&lt;/code&gt; and its result is used as the updated value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;map&lt;/code&gt; 있으면 기존 값이 &lt;code&gt;fun&lt;/code&gt; 에 전달 되고 그 결과가 &lt;code&gt;key&lt;/code&gt; 의 업데이트 된 값으로 사용 됩니다 . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; 하는 &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d4150f660167317dcaba9e8183ce3412c0294207" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The initial value will not be passed through the update function.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 가치와 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;fun&lt;/code&gt; 인수로 호출 &lt;code&gt;value&lt;/code&gt; 과 그 결과의 새 값으로 사용됩니다 &lt;code&gt;key&lt;/code&gt; . 경우에 &lt;code&gt;key&lt;/code&gt; 존재하지 않는다 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;initial&lt;/code&gt; 값으로 삽입 &lt;code&gt;key&lt;/code&gt; . 초기 값은 업데이트 기능을 통해 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75a038e3ca604bf73652a1d5909bc26acc1aa307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 가치와 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;fun&lt;/code&gt; 인수로 호출 &lt;code&gt;value&lt;/code&gt; 과 그 결과의 새 값으로 사용됩니다 &lt;code&gt;key&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; 하는 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15c9a821a2b57a999e05676dbebd003979e0547e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 값과 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;{value, new_map}&lt;/code&gt; 여기서 반환 &lt;code&gt;new_map&lt;/code&gt; 이 제거의 결과 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{default, map}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0d4a917aec182ae2652ab6e3733862784d7df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 값과 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;{value, new_map}&lt;/code&gt; 여기서 반환 &lt;code&gt;new_map&lt;/code&gt; 이 제거의 결과 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{fun_result, map}&lt;/code&gt; 경우, 반환되는 &lt;code&gt;fun_result&lt;/code&gt; 을 적용한 결과이다 &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be3edc2b3eeca76a785d6024f2cdb09fb2dfde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 가치와 &lt;code&gt;value&lt;/code&gt; , 다음 &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;default&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="57db7be79a09b897065af1bdf410edac419b10e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; 가치와 &lt;code&gt;value&lt;/code&gt; , 다음 &lt;code&gt;value&lt;/code&gt; 반환됩니다. 그렇지 않으면 &lt;code&gt;fun&lt;/code&gt; 이 평가되고 결과가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bd7fdb0ce9bd64671ab1efe4609aaa8d9539ced9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; , 그 반환 &lt;code&gt;{value, new_map}&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 키와 값이다 &lt;code&gt;new_map&lt;/code&gt; 이 제거의 결과 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{default, map}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6833696c36f33582651db81f8d535239158d24e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt;, it returns &lt;code&gt;{value, new_map}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value of the key and &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 에 존재하는 &lt;code&gt;map&lt;/code&gt; , 그 반환 &lt;code&gt;{value, new_map}&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 키와 값이다 &lt;code&gt;new_map&lt;/code&gt; 이 제거의 결과 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;{fun_result, map}&lt;/code&gt; 경우, 반환되는 &lt;code&gt;fun_result&lt;/code&gt; 을 적용한 결과이다 &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="022b1446733b2fda7810ec19631252125e1aa84b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keys&lt;/code&gt; contains keys that are not in &lt;code&gt;map&lt;/code&gt;, they're simply ignored.</source>
          <target state="translated">&lt;code&gt;keys&lt;/code&gt; 에 &lt;code&gt;map&lt;/code&gt; 이 아닌 키 가 포함되어 있으면 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec06751513a7783f95f06711b8c297f9eb8290a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keywords2&lt;/code&gt; has duplicate keys, the given function will be invoked for each matching pair in &lt;code&gt;keywords1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;keywords2&lt;/code&gt; 가 중복 키를 가지며, 주어진 함수에 일치하는 각 쌍에 대해 호출된다 &lt;code&gt;keywords1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cda0fc7deb1f2ca2778dbdfbc7cd47a0b34753a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;{:EXIT, pid}&lt;/code&gt;, it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.</source>
          <target state="translated">경우 &lt;code&gt;kind&lt;/code&gt; 입니다 &lt;code&gt;{:EXIT, pid}&lt;/code&gt; 등의 종료는 스택 추적하지 않고 메시지로 검색됩니다, 그것은는 스택 트레이스를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfc34d2fd024a4826aee6c45876a01c2984997a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;left&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 를 반환 &lt;code&gt;false&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;right&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4bbd966d4ee1229ab0c4a3f43a8067bf69d0b551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;left&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;right&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e10ea7dbc53bb25e7807935c07de908ca7820b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is an integer, that's the indentation appended to line breaks whenever they occur. If the level is &lt;code&gt;:cursor&lt;/code&gt;, the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is &lt;code&gt;:reset&lt;/code&gt;, it is set back to 0.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 이 정수인 경우 줄 바꿈이 발생할 때마다 추가되는 들여 쓰기입니다. 레벨이 &lt;code&gt;:cursor&lt;/code&gt; 인 경우 문서에서 &quot;cursor&quot;의 현재 위치는 중첩이됩니다. 레벨이 &lt;code&gt;:reset&lt;/code&gt; 이면 다시 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b432fb4f2fd1db528a9d6842cc318272507dcd19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 가 포함되어 있으면 해당 값이 반환됩니다. 경우 &lt;code&gt;map&lt;/code&gt; 포함되지 않은 &lt;code&gt;key&lt;/code&gt; 하는 &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bef2ee214360ef957032a298b1eb3e6a4177ceb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; then its value is returned in the shape of &lt;code&gt;{:ok, value}&lt;/code&gt;. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 주어진 &lt;code&gt;key&lt;/code&gt; 가 포함되어 있으면 해당 값이 &lt;code&gt;{:ok, value}&lt;/code&gt; 형태로 반환됩니다 . 경우 &lt;code&gt;map&lt;/code&gt; 포함되지 않은 &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;:error&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="167313c87cdf050139328eaa55e0c8e46388fa2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;map&lt;/code&gt; 주어진 포함 &lt;code&gt;key&lt;/code&gt; 값으로 &lt;code&gt;value&lt;/code&gt; 다음 &lt;code&gt;{:ok, value}&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;map&lt;/code&gt; 포함되지 않은 &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;:error&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c6733d65c27213cccbcddb83b9fc95fccaae0b10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 주어진 &lt;code&gt;key&lt;/code&gt; 가 포함되어 있으면 해당 값이 반환됩니다. 경우 &lt;code&gt;map&lt;/code&gt; 포함되지 않은 &lt;code&gt;key&lt;/code&gt; 하는 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="35d7fd154ea4c9faf69570f99b8c5aa4a3ac9ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;match&lt;/code&gt; 이다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 기능은 제기 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; :이 기능을 대체하기 때문에 이런 예외를 &lt;strong&gt;모두&lt;/strong&gt; 의 발생 &lt;code&gt;match&lt;/code&gt; 의 시작 부분에 &lt;code&gt;string&lt;/code&gt; 복수 &quot;의 발생을, 그리고 그것을 대체하는 것은 불가능하다&quot; &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b141a234955b46f94cdff6fb97f75b39d6831d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;match&lt;/code&gt; 이다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 기능은 제기 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; :이 기능을 대체하기 때문에 이런 예외를 &lt;strong&gt;모두&lt;/strong&gt; 의 발생 &lt;code&gt;match&lt;/code&gt; 의 끝에 &lt;code&gt;string&lt;/code&gt; 복수 &quot;의 발생을, 그리고 그것을 대체하는 것은 불가능하다&quot; &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb0185f097241d680d296e419b968e47a3c5201c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;match&lt;/code&gt; 이다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 기능은 제기 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; :이 기능을 대체하기 때문에 이런 예외를 &lt;strong&gt;모두&lt;/strong&gt; 의 발생 &lt;code&gt;match&lt;/code&gt; 의 시작 부분에 &lt;code&gt;string&lt;/code&gt; 복수 &quot;의 발생을, 그리고 그것을 대체하는 것은 불가능하다&quot; &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e72270cb672e9e4c9f071af85be8440eb64c674" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;match&lt;/code&gt; 이다 &lt;code&gt;&quot;&quot;&lt;/code&gt; 이 기능은 제기 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; :이 기능을 대체하기 때문에 이런 예외를 &lt;strong&gt;모두&lt;/strong&gt; 의 발생 &lt;code&gt;match&lt;/code&gt; 의 끝에 &lt;code&gt;string&lt;/code&gt; 복수 &quot;의 발생을, 그리고 그것을 대체하는 것은 불가능하다&quot; &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9bdc0c8aedc4a0581ea9ca9cb9ad9a4fe54a0d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modifiers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</source>
          <target state="translated">경우 &lt;code&gt;modifiers&lt;/code&gt; 이다 &lt;code&gt;[]&lt;/code&gt; 다음에 고유 정수 리턴한다 (즉, 양 또는 음이 될 수있다). 반환 된 정수의 속성을 변경하기 위해 다른 수정자를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad9eab2323c428de698fefc4bfc22b40c45681ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is an Erlang module (as opposed to an Elixir module), this function always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;module&lt;/code&gt; (같은 비약 모듈에 반대)을 얼랑 모듈은,이 함수는 항상 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0de03926a3208aa38b1bdc68fa4dd867a9992c7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;monitor_ref&lt;/code&gt; is a reference which the calling process obtained by calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;monitor/1&lt;/code&gt;&lt;/a&gt;, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">경우 &lt;code&gt;monitor_ref&lt;/code&gt; 가 호출 프로세스를 호출하여 얻은 기준 인 &lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;monitor/1&lt;/code&gt; &lt;/a&gt; , 그 모니터는 턴 오프된다. 모니터링이 이미 꺼져 있으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a32f1f48118a9d4a2686cda59499e6684c476f2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an atom, it just calls &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; with the atom as the first argument and &lt;code&gt;[]&lt;/code&gt; as the second argument.</source>
          <target state="translated">경우 &lt;code&gt;msg&lt;/code&gt; 원자이고, 단지 호출 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; 상기 제 인수 원자와 함께 &lt;code&gt;[]&lt;/code&gt; 번째 인수.</target>
        </trans-unit>
        <trans-unit id="e2591f3e8296742e9e675974bb3bfcb35d27b411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an exception struct, it is raised as is.</source>
          <target state="translated">경우 &lt;code&gt;msg&lt;/code&gt; 예외 구조체, 그대로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cefdb1ca1740aca5f5451a4dad984640e42d15f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 가 다른 것이라면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외 와 함께 &lt;code&gt;raise&lt;/code&gt; 가 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="2f440776b416dcca31a3b5404a0ec8e4143798ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">경우 &lt;code&gt;msg&lt;/code&gt; 어떤 사람이며, &lt;code&gt;raise&lt;/code&gt; 에 실패 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외 합니다.</target>
        </trans-unit>
        <trans-unit id="737a631e71f8710e641fef02c56115e74ed17ea3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, an empty list is returned.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 은 입니다 &lt;code&gt;0&lt;/code&gt; , 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc62758814a2f1d1d281641eed97d732d6ff6ae5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned.</source>
          <target state="translated">경우 &lt;code&gt;node&lt;/code&gt; 존재하지 않는, 쓸모없는 PID가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63d9a61082e21b3845e40428cb3a08f3ea73ce2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;enumerable&lt;/code&gt; is directly converted to a list, without &lt;code&gt;fun&lt;/code&gt; being ever applied.</source>
          <target state="translated">경우 &lt;code&gt;nth&lt;/code&gt; 것입니다 &lt;code&gt;0&lt;/code&gt; , 다음 &lt;code&gt;enumerable&lt;/code&gt; 직접하지 않고, 목록으로 변환됩니다 &lt;code&gt;fun&lt;/code&gt; 지금까지 적용되고.</target>
        </trans-unit>
        <trans-unit id="2840ae873ffd42facf8e147450543acef64559c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; exists and is a symlink, returns &lt;code&gt;{:ok, target}&lt;/code&gt;, otherwise returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 존재하고 심볼릭 링크, 반환 &lt;code&gt;{:ok, target}&lt;/code&gt; , 그렇지 않으면 반환 &lt;code&gt;{:error, reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f340b85ba7c5a6e0ec3e07ae4245f7c6097e6db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 문자열이고,이어서,이를 내부 경로로 사용될 &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;path&lt;/code&gt; 가 문자열 목록 이면 결합되고 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt; 참조 ) 결과는 &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; 내부의 경로로 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="6c154c595d1b4a01fb083386caa6ace778641f9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;path#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 문자열이고,이어서,이를 내부 경로로 사용될 &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; . 경우 &lt;code&gt;path&lt;/code&gt; 문자열리스트는, 그것이 (볼 접합한다 &lt;a href=&quot;path#join/1&quot;&gt; &lt;code&gt;Path.join/1&lt;/code&gt; &lt;/a&gt; ) 그 결과를 내부 경로로 사용될 &lt;a href=&quot;#app_dir/1&quot;&gt; &lt;code&gt;app_dir/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30981afdf653766b4f2d8e17a8e76f8900fd6c71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored. See also &lt;a href=&quot;#relative_to/2&quot;&gt;&lt;code&gt;relative_to/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; 이미 절대 경로, &lt;code&gt;relative_to&lt;/code&gt; 에이 무시됩니다. &lt;a href=&quot;#relative_to/2&quot;&gt; &lt;code&gt;relative_to/2&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4964bfcbfec35a641632c64af60eb6aaa93a561b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; points to a file, prints its full path.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 파일을 가리키는 경우 전체 경로를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4b1a93e9b2e0e773dda7a088ec139c68425c9cc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_wildcard&lt;/code&gt; is a wildcard, then all the files matching that wildcard will be imported; if no file matches the wildcard, no errors are raised. If &lt;code&gt;path_or_wildcard&lt;/code&gt; is not a wildcard but a path to a single file, then that file is imported; in case the file doesn't exist, an error is raised.</source>
          <target state="translated">경우 &lt;code&gt;path_or_wildcard&lt;/code&gt; 은 와일드 카드이며, 그 와일드 카드와 일치하는 모든 파일을 가져옵니다; 와일드 카드와 일치하는 파일이 없으면 오류가 발생하지 않습니다. 경우 &lt;code&gt;path_or_wildcard&lt;/code&gt; 는 와일드 카드이지만 하나의 파일에 대한 경로가 아닌, 그 파일을 가져옵니다; 파일이없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ed36549216e7c96c0405d66d46c768efd40ee4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is not trapping exits, &lt;code&gt;pid&lt;/code&gt; will exit with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pid&lt;/code&gt; 종료 트래핑되지, &lt;code&gt;pid&lt;/code&gt; 주어진으로 종료됩니다 &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="633950331a76abae7c27012953c6b5ce717504f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 가 종료를 트래핑하는 경우 종료 신호는 &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; 메시지로 변환되어 &lt;code&gt;pid&lt;/code&gt; 메시지 큐로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="edb5e8ad174fd02444bbcb56b3f2079cf73580c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix&lt;/code&gt; is an empty list, it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;prefix&lt;/code&gt; 빈리스트이며, 그것을 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26bd0886bea64b0650f1573c9fd139f06c9e5d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is neither &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, nor &lt;code&gt;{:shutdown, term}&lt;/code&gt; an error is logged.</source>
          <target state="translated">경우 &lt;code&gt;reason&lt;/code&gt; 도있다 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; ,도 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 오류가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5c120fe241858b080c2215e59c9d1dfe3c97d43f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:kill&lt;/code&gt;, that is if &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;pid&lt;/code&gt; which will unconditionally exit with reason &lt;code&gt;:killed&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;reason&lt;/code&gt; 원자이다 &lt;code&gt;:kill&lt;/code&gt; 경우입니다 &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; 라고하며, untrappable 종료 신호가 전송됩니다 &lt;code&gt;pid&lt;/code&gt; 하는 것이다 무조건 이유 종료 &lt;code&gt;:killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72ae981d0ae09b809a5b5a5aa46cd4ec885a9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;pid&lt;/code&gt; will not exit (unless &lt;code&gt;pid&lt;/code&gt; is the calling process, in which case it will exit with the reason &lt;code&gt;:normal&lt;/code&gt;). If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">경우 &lt;code&gt;reason&lt;/code&gt; 원자입니다 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;pid&lt;/code&gt; 종료하지 않습니다 (하지 않는 한 &lt;code&gt;pid&lt;/code&gt; 그 이유와 함께 종료되는 경우에 호출 프로세스입니다 &lt;code&gt;:normal&lt;/code&gt; ). 엑시트를 트래핑하는 중이면 엑시트 신호가 &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; 메시지로 변환되어 해당 메시지 큐로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0983db92616650bea49a21e4bb3960c0964601e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a regular expression, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; matches right.</source>
          <target state="translated">경우 &lt;code&gt;right&lt;/code&gt; 정규 표현식이며, 반환 &lt;code&gt;true&lt;/code&gt; 경우, &lt;code&gt;left&lt;/code&gt; 오른쪽으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d39df5af32cb5fb2bbe1045964270d68e1f1f5a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;right&lt;/code&gt; is a string, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; contains &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;right&lt;/code&gt; 문자열이 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;left&lt;/code&gt; 포함 &lt;code&gt;right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def9dbc5ab56f1b825b6729ff4b5f2b1cf2751f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or &lt;code&gt;{:ok, keywords | map}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">경우 &lt;code&gt;setup_all&lt;/code&gt; 또는 &lt;code&gt;setup&lt;/code&gt; 키워드 목록,지도, 또는 반환 &lt;code&gt;{:ok, keywords | map}&lt;/code&gt; 을 선택하면 키워드 목록 또는 맵이 현재 컨텍스트에 병합되며 이후의 모든 &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;test&lt;/code&gt; 자체 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427abb795faa00170a2a73c64fef9d4e09adf4d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or a tuple in the shape of &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="translated">경우 &lt;code&gt;setup_all&lt;/code&gt; 또는 &lt;code&gt;setup&lt;/code&gt; 키워드 목록,지도, 또는 모양의 튜플 반환 &lt;code&gt;{:ok, keyword() | map()}&lt;/code&gt; , 키워드 목록 또는 맵이 현재 컨텍스트에 병합되고 모든 후속 &lt;code&gt;setup_all&lt;/code&gt; , &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;test&lt;/code&gt; 자체 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e9939903f7075b75909cc132a74bc274c1bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a directory, or a symbolic link to it, then &lt;code&gt;destination&lt;/code&gt; must be an existent &lt;code&gt;directory&lt;/code&gt; or a symbolic link to one, or a path to a non-existent directory.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 디렉토리, 또는에 대한 심볼릭 링크는 다음 &lt;code&gt;destination&lt;/code&gt; 기설해야합니다 &lt;code&gt;directory&lt;/code&gt; 또는 1에 대한 심볼릭 링크, 또는 존재하지 않는 디렉토리 경로.</target>
        </trans-unit>
        <trans-unit id="1031bcdd561dcecee641f002ce883c7af7e61139" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a file or a symbolic link to it, &lt;code&gt;destination&lt;/code&gt; must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 파일이나 심볼릭 링크이며, &lt;code&gt;destination&lt;/code&gt; 기설 파일의 경로, 일에 대한 심볼릭 링크, 또는 존재하지 않는 파일에 대한 경로 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e57c5ea9358fe4a917bdf2d9fa6f002a7ca491dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;length&lt;/code&gt; 이진 밖에 어떤 방법에 참고가 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="fc6be87bc2a88ec11feb6fb3046cd38c5b7a4a35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;length&lt;/code&gt; 이진 밖에 어떤 방법에 참고가 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="148baaf20a5501cf402aa842127aa44f861d748c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;string&lt;/code&gt; 유효하지 않은 요구 사항입니다하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidRequirementError.html&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd707d6ea9c236adf3d2d26891903697d910f532" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;string&lt;/code&gt; 유효하지 않은 요구 사항입니다하는 &lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8f525d0b692b55f071ed6b31ea8e88fb78dc738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;string&lt;/code&gt; 잘못된 버전하는 것입니다 &lt;a href=&quot;https://hexdocs.pm/elixir/Version.InvalidVersionError.html&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 은&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b6f9f03b1dcc9dbff5dcc7644074dd977a2959ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;string&lt;/code&gt; 잘못된 버전하는 &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a1f85d96ca473515ee41dccc4b5c470d6806e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">경우 &lt;code&gt;target&lt;/code&gt; 이미 존재와 내용이 동일하지 않습니다, 그것은 사용자 확인을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="ae363da5635ac26a38468a274fa68594bffd7223" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is already a list, it returns the list. If &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns an empty list.</source>
          <target state="translated">경우 &lt;code&gt;term&lt;/code&gt; 목록이 이미, 그것은 목록을 반환합니다. 경우 &lt;code&gt;term&lt;/code&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 그것은 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c189d5b72f733627440a207910c642f9ff77e60b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;%URI{}&lt;/code&gt; struct is given to this function, this function returns it unmodified.</source>
          <target state="translated">경우 &lt;code&gt;%URI{}&lt;/code&gt; 구조체이이 기능으로 제공되며,이 함수가 반환 그것은 수정되지 않은.</target>
        </trans-unit>
        <trans-unit id="abcc9ba322766c6ecd47929cf37e2de456cad2b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;:skip&lt;/code&gt; tag is found in &lt;code&gt;tags&lt;/code&gt;, &lt;code&gt;{:skipped, message}&lt;/code&gt; is returned if the test has been left after the &lt;code&gt;exclude&lt;/code&gt; and &lt;code&gt;include&lt;/code&gt; filters. Otherwise &lt;code&gt;{:exclude, message}&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;:skip&lt;/code&gt; 태그에서 발견되는 &lt;code&gt;tags&lt;/code&gt; , &lt;code&gt;{:skipped, message}&lt;/code&gt; (가) 한 후 테스트가 왼쪽 된 경우 반환 &lt;code&gt;exclude&lt;/code&gt; 및 &lt;code&gt;include&lt;/code&gt; 필터를. 그렇지 않으면 &lt;code&gt;{:exclude, message}&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ae7e1652eb18779b4dcf4919c203ef71000bcfb9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;config/runtime.exs&lt;/code&gt; exists, it will be copied to your release and executed early in the boot process, when only Elixir and Erlang's main applications have been started. Once the configuration is loaded, the Erlang system will be restarted (within the same Operating System process) and the new configuration will take place.</source>
          <target state="translated">하면 &lt;code&gt;config/runtime.exs&lt;/code&gt; 존재, 그것은 당신의 릴리스에 복사 초 만 엘릭서와 얼랑의 주요 응용 프로그램이 시작된 부팅 과정에서 실행됩니다. 구성이로드되면 Erlang 시스템이 다시 시작되고 (동일한 운영 체제 프로세스 내에서) 새 구성이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb5769774bfa8aa4c65da1e51375f078f53a47d" translate="yes" xml:space="preserve">
          <source>If a byte has 8 bits, what happens if we pass a size of 1 bit?</source>
          <target state="translated">바이트에 8 비트가 있으면 1 비트 크기를 전달하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="0ac581e270299e95270be44edc11d5d78635bdbb" translate="yes" xml:space="preserve">
          <source>If a callback is given, it is invoked for each received message.</source>
          <target state="translated">콜백이 제공되면 수신 된 각 메시지에 대해 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9510d4ce0d205517cf9f92994b15bfbfe1510aa1" translate="yes" xml:space="preserve">
          <source>If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen).</source>
          <target state="translated">지정된 동작을 구현하는 콜백 모듈이 해당 동작으로 정의 된 모든 함수와 매크로를 내 보내지 않는 경우 컴파일 과정에서 경고를 통해 사용자에게 알림이 표시됩니다 (오류가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="69b52804cd17d7f8a0689854f3222713a2e4c149" translate="yes" xml:space="preserve">
          <source>If a child specification with the specified ID already exists, &lt;code&gt;child_spec&lt;/code&gt; is discarded and this function returns an error with &lt;code&gt;:already_started&lt;/code&gt; or &lt;code&gt;:already_present&lt;/code&gt; if the corresponding child process is running or not, respectively.</source>
          <target state="translated">지정된 ID를 가진 하위 스펙이 이미 존재하는 경우, &lt;code&gt;child_spec&lt;/code&gt; 은 삭제되고 해당 하위 프로세스가 각각 실행 중인지 여부에 따라 &lt;code&gt;:already_started&lt;/code&gt; 또는 &lt;code&gt;:already_present&lt;/code&gt; 와 함께 오류를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="624738a0046889600ef5bfdcc03d5da8090ab0e9" translate="yes" xml:space="preserve">
          <source>If a cookie option was given, we compare it with the contents of the file (if any), and ask the user if they want to override.</source>
          <target state="translated">쿠키 옵션이 제공된 경우이를 파일의 내용 (있는 경우)과 비교하고 사용자에게 재정의 할 것인지 묻습니다.</target>
        </trans-unit>
        <trans-unit id="4e2890f26410463009016ad753f613992362cbef" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes &lt;code&gt;callback&lt;/code&gt;. &lt;code&gt;callback&lt;/code&gt; must be a function that takes two arguments: &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;. The callback should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">대상에 파일이 이미 있으면 &lt;code&gt;callback&lt;/code&gt; 을 호출합니다 . &lt;code&gt;callback&lt;/code&gt; 은 &lt;code&gt;source&lt;/code&gt; 와 &lt;code&gt;destination&lt;/code&gt; 의 두 가지 인수를 취하는 함수 여야 합니다 . 기존 파일을 덮어 써야하는 경우 콜백은 &lt;code&gt;true&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cabdc7b8c3d548d6762d990a45e3c0db4093b48f" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes a callback which should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten, &lt;code&gt;false&lt;/code&gt; otherwise. The callback defaults to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">대상에 파일이 이미 존재 하면 기존 파일을 덮어 써야 할 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환해야하는 콜백을 호출합니다 . 콜백의 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f5282b08680f8cf98b1cf98c1763e902d8a8cf1" translate="yes" xml:space="preserve">
          <source>If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="translated">기능이 제공되면 장치가 생성되어 기능으로 전송됩니다. 함수가 반환되면 장치가 닫힙니다. 최종 결과는 &lt;code&gt;:ok&lt;/code&gt; 와 함수 결과가 포함 된 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="d38f06a2f29af4b9a58ad54b574b4b65c78e3313" translate="yes" xml:space="preserve">
          <source>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</source>
          <target state="translated">기본값을 가진 함수에 여러 절이있는 경우 기본값을 선언하기 위해 함수 본문 (실제 본문없이)을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="000c898cfeca7c250248fbd1fa1ca561171bdc1f" translate="yes" xml:space="preserve">
          <source>If a given line starts a &lt;code&gt;describe&lt;/code&gt; block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number.</source>
          <target state="translated">주어진 라인이 &lt;code&gt;describe&lt;/code&gt; 블록을 시작하면 해당 라인 필터는 그 안에있는 모든 테스트를 실행합니다. 그렇지 않으면 주어진 줄 번호 또는 그 전에 가장 가까운 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d537fdd4d0b14a07a0a04df5203e5b0b7c078fd6" translate="yes" xml:space="preserve">
          <source>If a key in the pattern is not available in the map, then they won't match:</source>
          <target state="translated">패턴의 키를 맵에서 사용할 수없는 경우 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79925800db01e377c0a45bd22e7acc683fbfbe07" translate="yes" xml:space="preserve">
          <source>If a key is a function, the function will be invoked passing three arguments:</source>
          <target state="translated">키가 함수 인 경우 함수는 세 개의 인수를 전달하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="29fd70a945f925cf23cc7e6f8035b1a44027a7d0" translate="yes" xml:space="preserve">
          <source>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</source>
          <target state="translated">목록이 음이 아닌 정수로 구성되면 각 정수가 유니 코드 코드 포인트를 나타내며이 목록을 문자 목록이라고도합니다. 이 정수는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="459ad8c7d2d4dfeac7cad82c1512116c71e69047" translate="yes" xml:space="preserve">
          <source>If a list of dependencies is given, Mix will attempt to compile them as is. For example, if project &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt;, calling &lt;code&gt;mix deps.compile a&lt;/code&gt; will compile &lt;code&gt;a&lt;/code&gt; even if &lt;code&gt;b&lt;/code&gt; is out of date. This is to allow parts of the dependency tree to be recompiled without propagating those changes upstream. To ensure &lt;code&gt;b&lt;/code&gt; is included in the compilation step, pass &lt;code&gt;--include-children&lt;/code&gt;.</source>
          <target state="translated">종속성 목록이 제공되면 Mix는 그대로 컴파일을 시도합니다. 예를 들어, 프로젝트의 경우 &lt;code&gt;a&lt;/code&gt; 는 에 따라 &lt;code&gt;b&lt;/code&gt; 전화, &lt;code&gt;mix deps.compile a&lt;/code&gt; 컴파일 경우에도 &lt;code&gt;b&lt;/code&gt; 최신이 아닙니다. 이는 이러한 변경 사항을 업스트림으로 전파하지 않고 종속성 트리의 일부를 다시 컴파일 할 수 있도록하기위한 것입니다. &lt;code&gt;b&lt;/code&gt; 가 컴파일 단계에 포함 되도록하려면 &lt;code&gt;--include-children&lt;/code&gt; 을 전달 합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b421abd37694bae36c7d25d86ffa518fdbbea4dd" translate="yes" xml:space="preserve">
          <source>If a module adopting a given behaviour doesn&amp;rsquo;t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</source>
          <target state="translated">주어진 동작을 채택한 모듈이 해당 동작에 필요한 콜백 중 하나를 구현하지 않으면 컴파일 타임 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="883d15353620b14cbb9c9d5a06e95f6b6c4d20b6" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of elements will be taken from the end. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">음의 &lt;code&gt;amount&lt;/code&gt; 이 주어지면 요소 의 &lt;code&gt;amount&lt;/code&gt; 끝에서 가져옵니다. &lt;code&gt;enumerable&lt;/code&gt; 적절한 인덱스를 검색 한번 열거되고, 나머지 계산은 끝에서 수행된다.</target>
        </trans-unit>
        <trans-unit id="6cc671d5a37ef968ded5582cc81fb0522d873170" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of last values will be dropped. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="translated">음의 경우 &lt;code&gt;amount&lt;/code&gt; 주어진다는 &lt;code&gt;amount&lt;/code&gt; 마지막 값이 삭제됩니다. &lt;code&gt;enumerable&lt;/code&gt; 적절한 인덱스를 검색 한번 열거되고, 나머지 계산은 끝에서 수행된다.</target>
        </trans-unit>
        <trans-unit id="59caaee16729c3dbee5fe847e2d7d4842c9c683a" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;count&lt;/code&gt; is given, the last &lt;code&gt;count&lt;/code&gt; values will be taken. For such, the collection is fully enumerated keeping up to &lt;code&gt;2 * count&lt;/code&gt; elements in memory. Once the end of the collection is reached, the last &lt;code&gt;count&lt;/code&gt; elements will be executed. Therefore, using a negative &lt;code&gt;count&lt;/code&gt; on an infinite collection will never return.</source>
          <target state="translated">음의 경우 &lt;code&gt;count&lt;/code&gt; 주어 마지막 &lt;code&gt;count&lt;/code&gt; 값을 이동합니다. 이를 위해 컬렉션은 메모리에 최대 &lt;code&gt;2 * count&lt;/code&gt; 요소 를 유지하면서 완전히 열거 됩니다. 컬렉션의 끝에 도달하면 마지막 &lt;code&gt;count&lt;/code&gt; 요소가 실행됩니다. 따라서, 부정 사용 &lt;code&gt;count&lt;/code&gt; 무한 컬렉션은 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f69e4dbe00c1ada199c059c775f25efeb8310586" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;n&lt;/code&gt; is given, it will drop the last &lt;code&gt;n&lt;/code&gt; elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until &lt;code&gt;n&lt;/code&gt; additional elements have been emitted by the enum.</source>
          <target state="translated">음수 &lt;code&gt;n&lt;/code&gt; 이 제공되면 컬렉션에서 마지막 &lt;code&gt;n&lt;/code&gt; 개 요소를 삭제합니다 . 이것이 구현되는 메커니즘은 &lt;code&gt;n&lt;/code&gt; 개의 추가 요소가 열거 형에 의해 방출 될 때까지 임의의 요소의 방출을 지연시킬 것이다 .</target>
        </trans-unit>
        <trans-unit id="1945f4f47fb811a9fdec36bceacc04e13f4b23dd" translate="yes" xml:space="preserve">
          <source>If a non-unique registry is given, an error is raised.</source>
          <target state="translated">고유하지 않은 레지스트리가 제공되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fe100a04f7f3c2228565ba1dad4a516ece48f3e" translate="yes" xml:space="preserve">
          <source>If a positive &lt;code&gt;amount&lt;/code&gt; is given, it takes the &lt;code&gt;amount&lt;/code&gt; elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">양 경우 &lt;code&gt;amount&lt;/code&gt; 주어, 상기 소요 &lt;code&gt;amount&lt;/code&gt; 의 시작 부분에서 요소 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="273c42e7694ef6f6a0ae619fbbe7e5dc6c7edfb5" translate="yes" xml:space="preserve">
          <source>If a previous value is already stored, all entries are removed and the value is overridden.</source>
          <target state="translated">이전 값이 이미 저장된 경우 모든 항목이 제거되고 값이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="44015a59f9f7a33ffc75deedd1425577f41943be" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">주어진 유형에 대한 프로토콜 구현을 찾을 수없는 경우 &lt;code&gt;Any&lt;/code&gt; 로 폴백하도록 구성되지 않은 경우 프로토콜 호출이 발생합니다 . 기존 구현 위에 구현을 구축하기위한 편리함도 사용할 수 있습니다 . 프로토콜 파생에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="43fc3383844fcfe72ece54d10710bd0bd9f25337" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="translated">지정된 유형에 대해 프로토콜 구현을 찾을 수없는 경우 프로토콜을 호출하면 &lt;code&gt;Any&lt;/code&gt; 로 폴백하도록 구성되지 않은 경우 프로토콜이 호출됩니다 . 기존 구현 위에 구현을 빌드 할 때의 편의도 사용할 수 있습니다 . 프로토콜 파생에 대한 자세한 정보 는 &lt;a href=&quot;kernel#defstruct/1&quot;&gt; &lt;code&gt;defstruct/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a016d1410ce73603f7d41b32703713ab6681b5cb" translate="yes" xml:space="preserve">
          <source>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</source>
          <target state="translated">범위가 함수에 전달되면이 함수는 전체 범위를 통과하지 않고 범위 제한 사이에서 임의의 값을 선택합니다 (따라서 일정한 시간과 일정한 메모리에서 실행).</target>
        </trans-unit>
        <trans-unit id="4e6fe5e08b24cf20a9c0798353e64ac83dfa14b4" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">레코드가 기본값에서 익명 함수를 정의하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 익명의 함수를 기본값으로 사용하는 Erlang 라이브러리에서 레코드를 추출한 후 레코드를 정의 할 때 의도하지 않게 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d5db183ff92e0f2a4bace49c1074a0f1a8e87bc" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="translated">레코드가 기본값으로 익명 함수를 정의하면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 기본값으로 익명 함수를 사용하는 Erlang 라이브러리에서 레코드를 추출한 후 레코드를 정의 할 때 실수로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6abb6313f6cc1303f397ef517fbdc8da84732e6" translate="yes" xml:space="preserve">
          <source>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1.</source>
          <target state="translated">문자열 인 경우 상태가 슬로건 인 Erlang 크래시 덤프가 생성 된 후 런타임 시스템이 상태 코드 1로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="126afd1abf58596ead958f3fd3541d1004b086cc" translate="yes" xml:space="preserve">
          <source>If a switch can't be parsed according to the given type, it is returned in the invalid options list.</source>
          <target state="translated">주어진 유형에 따라 스위치를 구문 분석 할 수 없으면 유효하지 않은 옵션 목록으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2b1173f30bab1103a16e4d18afe172d1cf1918aa" translate="yes" xml:space="preserve">
          <source>If a tag is given more than once, the last value wins.</source>
          <target state="translated">태그가 두 번 이상 주어지면 마지막 값이 이깁니다.</target>
        </trans-unit>
        <trans-unit id="25bcdf5eebbd3c58586886d967dc6654eabd51f6" translate="yes" xml:space="preserve">
          <source>If a task crashes, the callers field is included as part of the log message metadata under the &lt;code&gt;:callers&lt;/code&gt; key.</source>
          <target state="translated">작업이 충돌하면 callers 필드가 &lt;code&gt;:callers&lt;/code&gt; 키 아래에 로그 메시지 메타 데이터의 일부로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="83f25a0e999e5079ecb734e6ae102d4bb2431a7f" translate="yes" xml:space="preserve">
          <source>If a task has requirements, they can be listed using the &lt;code&gt;@requirements&lt;/code&gt; attribute. For example:</source>
          <target state="translated">작업에 요구 사항이있는 경우 &lt;code&gt;@requirements&lt;/code&gt; 속성을 사용하여 나열 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="05107c81774e13529708289068c52809a60e340f" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">작업에서 프로젝트를 정의해야하거나 프로젝트 내의 특수 기능에 액세스해야하는 경우 작업은 &lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있으며 프로젝트가 정의되지 않은 경우 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.NoProjectError.html&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="30a9473b0d912205c959737a706b0e7ee4a0ec9d" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;mix.project#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="translated">작업에 프로젝트를 정의해야하거나 프로젝트 내 특수 기능에 액세스 &lt;a href=&quot;mix.noprojecterror&quot;&gt; &lt;code&gt;Mix.NoProjectError&lt;/code&gt; &lt;/a&gt; 경우 작업이 프로젝트가 정의되지 않은 경우 Mix.NoProjectError 와 함께 실패하는 &lt;a href=&quot;mix.project#get!/0&quot;&gt; &lt;code&gt;Mix.Project.get!/0&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c67bc32edf1527e959986e52e98d4224edd81679" translate="yes" xml:space="preserve">
          <source>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return &lt;code&gt;{:exit, :noproc}&lt;/code&gt; as the result or exit reason can not be determined.</source>
          <target state="translated">태스크 모니터가 이미 모니터 해제되었거나 수신되었고 메시지 큐에 응답 대기가없는 경우 , 결과 또는 종료 이유를 판별 할 수 &lt;code&gt;{:exit, :noproc}&lt;/code&gt; 함수는 {: exit, : noproc} 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="1a77a9db2807ea258346d1c8035a43bea2a0103f" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same pattern:</source>
          <target state="translated">패턴에서 변수가 두 번 이상 언급되면 모든 참조는 동일한 패턴에 바인딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8341a6ce2bd527f498f269d473191d8c74061cd6" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same value:</source>
          <target state="translated">패턴에서 변수가 두 번 이상 언급되는 경우 모든 참조는 동일한 값에 바인딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d5176a6bc70715553073a28b4fe06e7f78373b7" translate="yes" xml:space="preserve">
          <source>If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</source>
          <target state="translated">모든 절이 일치하면 &lt;code&gt;do&lt;/code&gt; 블록이 실행되고 결과가 반환됩니다. 그렇지 않으면 체인이 중단되고 일치하지 않는 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c4638272580cddbbaefbc10d002d4b066670b8" translate="yes" xml:space="preserve">
          <source>If all of the conditions return &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, an error (&lt;code&gt;CondClauseError&lt;/code&gt;) is raised. For this reason, it may be necessary to add a final condition, equal to &lt;code&gt;true&lt;/code&gt;, which will always match:</source>
          <target state="translated">모든 조건이 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 오류 ( &lt;code&gt;CondClauseError&lt;/code&gt; )가 발생합니다. 이러한 이유로 항상 일치하는 &lt;code&gt;true&lt;/code&gt; 조건과 같은 최종 조건을 추가해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ce3955a535274dbe7df8b09ce910f413bd1bd52" translate="yes" xml:space="preserve">
          <source>If amount is &lt;code&gt;0&lt;/code&gt;, it returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">amount가 &lt;code&gt;0&lt;/code&gt; 이면 &lt;code&gt;[]&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="195d921f30b7ca6822ad57816fd9a2da342da9c2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is present, it will match on the results of the &lt;code&gt;try&lt;/code&gt; block whenever the &lt;code&gt;try&lt;/code&gt; block finishes without a throw or an error.</source>
          <target state="translated">경우 &lt;code&gt;else&lt;/code&gt; 블록이 존재하고,이 결과에 일치 &lt;code&gt;try&lt;/code&gt; 때마다 블록 &lt;code&gt;try&lt;/code&gt; 블록이 던져 또는 오류없이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="678b2cde87bb40ee90e01daea6daabd5a152129d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">는 IF &lt;code&gt;else&lt;/code&gt; 블록이 사용되며, 일치하는 조항이없는하는 &lt;a href=&quot;https://hexdocs.pm/elixir/WithClauseError.html&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="570f497970d66b8882cf83a80169ce5e7a3f4622" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;withclauseerror&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">는 IF &lt;code&gt;else&lt;/code&gt; 블록이 사용되며, 일치하는 조항이없는하는 &lt;a href=&quot;withclauseerror&quot;&gt; &lt;code&gt;WithClauseError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="de3cca2420a70cac7a0a92d8ce5ec9857a32f5c0" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; clause is not present and no exceptions are raised, the result of the expression will be returned:</source>
          <target state="translated">경우 &lt;code&gt;else&lt;/code&gt; 절에 표시되지 않으며 예외가 발생되지 않으며, 식의 결과가 반환됩니다 :</target>
        </trans-unit>
        <trans-unit id="e2d3671c086be455d33d12466d3540943c7f121c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;offset&lt;/code&gt; is given, we will index from the given offset instead of from zero.</source>
          <target state="translated">이 경우 &lt;code&gt;offset&lt;/code&gt; 주어, 우리는 것이 0에서 대신 지정된 오프셋 (offset)로부터 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="0a648b7fb5579eaba477422e6520374ab96f3bbc" translate="yes" xml:space="preserve">
          <source>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</source>
          <target state="translated">응용 프로그램에 응용 프로그램이 포함되어 있으면 응용 프로그램도로드됩니다. 그리고 응용 프로그램이 차례로 포함 된 경우 절차가 반복됩니다. 포함 된 응용 프로그램은 Mix umbrella 프로젝트의 응용 프로그램과 관련이 없으며, 공동 시작과 관련이있는 Erlang / OTP 개념입니다.</target>
        </trans-unit>
        <trans-unit id="c19cd9003fb6605f04e0b314c975e08d6865c82c" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt archive, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">인수가 제공되면 사전 빌드 된 아카이브, Git 리포지토리, GitHub 리포지토리 또는 Hex 패키지에 대한 로컬 경로 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8777f1d4410c11fe781472a9996f7abc7e9d0ee1" translate="yes" xml:space="preserve">
          <source>If an argument is provided, it should be a local path to a prebuilt escript, a Git repository, a GitHub repository, or a Hex package.</source>
          <target state="translated">인수가 제공되는 경우 사전 빌드 된 escript, Git 저장소, GitHub 저장소 또는 Hex 패키지의 로컬 경로 여야합니다.</target>
        </trans-unit>
        <trans-unit id="346e510adb982fcdef487692a01e3558f4f43dd0" translate="yes" xml:space="preserve">
          <source>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</source>
          <target state="translated">원자가 주어지면, 그것은 엘릭서 모듈로 가정되므로 바이너리로 변환 된 다음 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1dd9c12e4c69c00fd419e79703f50c2f1eb25bbf" translate="yes" xml:space="preserve">
          <source>If an empty string is given, returns an empty list.</source>
          <target state="translated">빈 문자열이 제공되면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8c7e22d59114292a3302ce7be80d94101c6ff48" translate="yes" xml:space="preserve">
          <source>If an integer, the runtime system exits with the integer value which is returned to the operating system.</source>
          <target state="translated">정수인 경우 런타임 시스템은 운영 체제로 리턴되는 정수 값으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3f5440412ded7562694390034be201abb74a66" translate="yes" xml:space="preserve">
          <source>If an umbrella project reenables a task, it is reenabled for all child projects.</source>
          <target state="translated">우산 프로젝트가 작업을 다시 활성화하면 모든 하위 프로젝트에 대해 다시 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a96ebc73b0c26a7d76054b4183ec0b8df86f83ca" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;--check-*&lt;/code&gt; options are given and a check fails, the formatted contents won't be written to disk nor printed to standard output.</source>
          <target state="translated">의 어떤 경우 &lt;code&gt;--check-*&lt;/code&gt; 의 옵션을 부여하고 검사가 실패하는, 포맷 된 내용을 디스크에 기록하거나 표준 출력에 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="642cb4f6ac7d478befb880a0aa0031be148b3d13" translate="yes" xml:space="preserve">
          <source>If any of the files is &lt;code&gt;-&lt;/code&gt;, then the output is read from stdin and written to stdout.</source>
          <target state="translated">파일 중 하나라도 &lt;code&gt;-&lt;/code&gt; 인 경우 출력은 stdin에서 읽고 stdout에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f55410e6ca8aea2aa1012bcfa7157dec87ff1c3f" translate="yes" xml:space="preserve">
          <source>If any of the task processes dies, the current process will exit with the same reason as that task.</source>
          <target state="translated">작업 프로세스 중 하나가 죽으면 현재 프로세스가 해당 작업과 같은 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea3148cc3562102872f247d7ecd3f95cbb26a611" translate="yes" xml:space="preserve">
          <source>If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="translated">값 중 하나라도 &lt;code&gt;nil&lt;/code&gt; 이면 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="033137dbcc6d7e358cdff1f234f1f034d23cee4d" translate="yes" xml:space="preserve">
          <source>If anything had to be compiled, you see some informative text, and get the &lt;code&gt;:ok&lt;/code&gt; atom back, otherwise the function is silent, and returns &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">무언가를 컴파일해야한다면, 유익한 텍스트를보고 &lt;code&gt;:ok&lt;/code&gt; 원자를 되찾아 주십시오 . 그렇지 않으면 함수는 침묵하고 &lt;code&gt;:noop&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f9330902fc087c329eff5fc5f2a0eba15cfef47c" translate="yes" xml:space="preserve">
          <source>If both options are set, &lt;code&gt;--force&lt;/code&gt; takes precedence.</source>
          <target state="translated">두 옵션이 모두 설정된 경우 &lt;code&gt;--force&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7b4dc8078aeab160f01342b984c42012d0bb7fb7" translate="yes" xml:space="preserve">
          <source>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</source>
          <target state="translated">UTF-8로 변환 할 수없는 형식으로 데이터를 파일로 보내거나 데이터의 문자 범위를 처리 할 수없는 형식으로 데이터를 리턴하는 함수에서 데이터를 읽는 경우 오류가 발생하고 파일 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="9cb11ee612f8a6fa1dc16b1180f3c60b5d1e6218" translate="yes" xml:space="preserve">
          <source>If desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as &lt;code&gt;Enumerable&lt;/code&gt; and possibly &lt;code&gt;Size&lt;/code&gt;, for this data type.</source>
          <target state="translated">원하는 경우 구조체의 크기에 대한 자체 의미를 생각해 낼 수 있습니다. 뿐만 아니라 구조체를 사용하여 대기열과 같은보다 강력한 데이터 형식을 구축 하고이 데이터 형식에 대해 &lt;code&gt;Enumerable&lt;/code&gt; 및 &lt;code&gt;Size&lt;/code&gt; 와 같은 모든 관련 프로토콜을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea1cd1f61403fdf9495800bfd2ea11cb562ca0b5" translate="yes" xml:space="preserve">
          <source>If duplicated entries exist, the first one is returned. Use &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; to retrieve all entries.</source>
          <target state="translated">중복 된 항목이 있으면 첫 번째 항목이 반환됩니다. &lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 모든 항목을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="0b592a69d9d8fd53bf0bd9cbfc055db4e81ec7c8" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. So this function will not detect empty tuples:</source>
          <target state="translated">각 가드식이 항상 부울을 반환하면 두 형식이 동일합니다. 그러나 가드에서 함수 호출로 예외가 발생하면 전체 가드가 실패한다는 것을 기억하십시오. 따라서이 함수는 빈 튜플을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c3eed1e3cb4bd53836b71d67f974f0d1ba37310" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples:</source>
          <target state="translated">각 가드식이 항상 부울을 반환하는 경우 두 형식은 동일합니다. 그러나 가드의 함수 호출이 예외를 발생 시키면 전체 가드가 실패한다는 것을 기억하십시오. 이를 설명하기 위해 다음 함수는 빈 튜플을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbe27cd775ccec3c6324b3d4efb95e206746dc7f" translate="yes" xml:space="preserve">
          <source>If file &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten by the contents in &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;destination&lt;/code&gt; 이미 있으면 &lt;code&gt;source&lt;/code&gt; 의 내용으로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fdc28a9b8dcfe0a11c8bac1e062e822f6767ef47" translate="yes" xml:space="preserve">
          <source>If file is a relative, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">파일이 상대 파일이면 현재 구성 파일이있는 디렉토리로 상대적으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="42ddc2f0c1e4117e2bba8be8a09c43a0ea2ed1bd" translate="yes" xml:space="preserve">
          <source>If for some reason the application needs to be configured before it is started, the &lt;code&gt;--no-start&lt;/code&gt; option can be used and you are then responsible for starting all applications by using functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. For more information about the application life-cycle and dynamically configuring applications, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">어떤 이유로 응용 프로그램을 시작하기 전에 구성해야하는 경우 &lt;code&gt;--no-start&lt;/code&gt; 옵션을 사용할 수 있으며 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt; &lt;code&gt;Application.ensure_all_started/1&lt;/code&gt; &lt;/a&gt; 과 같은 기능을 사용하여 모든 응용 프로그램을 시작해야합니다 . 응용 프로그램 수명주기 및 응용 프로그램 동적 구성에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52856e4d7670b4aabed44c6b796ec0f3b6c2451e" translate="yes" xml:space="preserve">
          <source>If for some reason you cannot take the elements before hand, you can use &lt;code&gt;:max_concurrency&lt;/code&gt; to limit how many elements may be over processed at the cost of reducing concurrency.</source>
          <target state="translated">어떤 이유로 요소를 미리 가져올 수없는 경우 &lt;code&gt;:max_concurrency&lt;/code&gt; 를 사용 하여 동시성을 줄이는 대신 초과 처리 될 수있는 요소 수를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe39f85acaae7d9c0b9ede161359eb45dcac7a2" translate="yes" xml:space="preserve">
          <source>If injection is suddenly interrupted, &lt;code&gt;:halt&lt;/code&gt; is passed and the function can return any value as it won't be used.</source>
          <target state="translated">주입이 갑자기 중단되면 &lt;code&gt;:halt&lt;/code&gt; 가 전달되고 함수는 사용되지 않는 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2208d456a668339c9192b6d6af5ff93f1cbc3d73" translate="yes" xml:space="preserve">
          <source>If installing a precompiled Hex does not work, you can compile and install Hex directly with this command:</source>
          <target state="translated">사전 컴파일 된 Hex 설치가 작동하지 않으면 다음 명령을 사용하여 직접 Hex를 컴파일하고 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e605c80e2a0c34a8e797284924c7ad11db4e6147" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">대신 다른 시간대의 동일한 시점에 대한 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 원한다면 코펜하겐에서 2018-08-24 10:00:00을 2018-08-24 08:00:00으로 변환 하는 &lt;a href=&quot;#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오. UTC로.</target>
        </trans-unit>
        <trans-unit id="6ef0c2aa8f05db2c984cf1df62ac6db58c68621a" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;datetime#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="translated">당신이 찾는 대신하는 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 다른 시간대에 같은 지점 시간을 참조하십시오 &lt;a href=&quot;datetime#shift_zone/3&quot;&gt; &lt;code&gt;DateTime.shift_zone/3&lt;/code&gt; &lt;/a&gt; 2018년 8월 24일 8시 0분 0초 코펜하겐에서 2018년 8월 24일 10시 0분 0초 변환 할 기능을 UTC로.</target>
        </trans-unit>
        <trans-unit id="d54c8e6a4382ff70ea26a411e39ab67c3f015ec3" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">유효하지 않은 인수가 제공되면 &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; 에&lt;/a&gt; 의해 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; 는 또한 엄격한 옵션 세트를 예상하며 알 수 없거나 유효하지 않은 옵션이 제공 될 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f63070ccfff8927ca91b04ed194217d21f1511af" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="translated">잘못된 인수가 제공되면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; 에&lt;/a&gt; 의해 발생합니다 . &lt;a href=&quot;#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; 는 또한 엄격한 옵션 세트를 예상하며 알 수 없거나 잘못된 옵션이 제공되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d184a96a7452ebbaa15d901cdfcd5646962e673b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">달력간에 명확하게 변환 할 수없는 경우 ( &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; 참조 ) &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bf2413d6f2f1077cec728a8783f14bba8e944a5b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">달력간에 명확하게 변환 할 수없는 경우 ( &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; 참조 ) ArgumentError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ecfddb3c801b4fad8012305968cb8bcbecf6fa13" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="translated">캘린더간에 명확하게 변환 할 수없는 경우 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; 참조 ) &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="87471401848a097556118fe83e0d5466a1656985" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="translated">캘린더간에 명확하게 변환 할 수없는 경우 ( &lt;a href=&quot;https://hexdocs.pm/elixir/Calendar.html#compatible_calendars?/2&quot;&gt; &lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt; &lt;/a&gt; 참조 ) ArgumentError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b73ba22cd3093f832e74a316d5262bd0f987e0a" translate="yes" xml:space="preserve">
          <source>If it succeeds in loading the module, it returns &lt;code&gt;{:module, module}&lt;/code&gt;. If not, returns &lt;code&gt;{:error, reason}&lt;/code&gt; with the error reason.</source>
          <target state="translated">모듈을 성공적으로로드하면 &lt;code&gt;{:module, module}&lt;/code&gt; 반환합니다 . 그렇지 않으면 오류 이유와 함께 &lt;code&gt;{:error, reason}&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="375e4e6baa78eec72e85f76cd1b054d6bf11d173" translate="yes" xml:space="preserve">
          <source>If it succeeds opening the file, it returns the &lt;code&gt;function&lt;/code&gt; result on the IO device.</source>
          <target state="translated">파일을 성공적으로 열면 IO 장치 의 &lt;code&gt;function&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f34822921b36640bca1582de43cfc049c94f2bdc" translate="yes" xml:space="preserve">
          <source>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</source>
          <target state="translated">마지막이 첫 번째보다 크면 범위가 처음부터 끝까지 증가합니다. first가 last보다 크면 범위가 처음부터 끝까지 감소합니다. first가 last와 같으면 범위에는 하나의 요소 (숫자 자체)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="235b771916ee54b0bdf0b8ac1f7f9a8b762d39f4" translate="yes" xml:space="preserve">
          <source>If module has &lt;code&gt;@compile {:autoload, false}&lt;/code&gt;, &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; will not be used.</source>
          <target state="translated">모듈에 &lt;code&gt;@compile {:autoload, false}&lt;/code&gt; 가 &lt;code&gt;__mix_recompile__?/0&lt;/code&gt; 이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73ef68acbf89df4484fb1238776c874300f89fd7" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal or minimal, the first one that was found is returned.</source>
          <target state="translated">여러 요소가 최대 또는 최소로 간주되면 발견 된 첫 번째 요소가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1368a6e71ce1bea12a85b30b7509f054b5bc170d" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal, the first one that was found is returned.</source>
          <target state="translated">여러 요소가 최대로 간주되면 발견 된 첫 번째 요소가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c6a9685a98347f5efadc0b8611df565d7f389d71" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered minimal, the first one that was found is returned.</source>
          <target state="translated">여러 요소가 최소로 간주되면 발견 된 첫 번째 요소가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="24628e265ef0842d90b32f3fc25fbf2867904597" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;rebar&lt;/code&gt; or &lt;code&gt;rebar3&lt;/code&gt; are specified, both versions will be fetched.</source>
          <target state="translated">&lt;code&gt;rebar&lt;/code&gt; 또는 &lt;code&gt;rebar3&lt;/code&gt; 을 지정 하지 않으면 두 버전이 모두 페치됩니다.</target>
        </trans-unit>
        <trans-unit id="3bba7183a7cbe4b26185332d90ef3cedae8fff5f" translate="yes" xml:space="preserve">
          <source>If nil is returned, it means no lock information is available.</source>
          <target state="translated">nil이 반환되면 사용 가능한 잠금 정보가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="038bfba61cc7a83ddd7d63b5a01873632ce42b48" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; exists, returns the keyword list unchanged.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이있는 &lt;code&gt;key&lt;/code&gt; 가 없으면 키워드 목록을 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f84d674ad0c66434da7d8901f73f91feb00f3a76" translate="yes" xml:space="preserve">
          <source>If no application is given, it uses the current application defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">애플리케이션이 지정되지 않은 경우 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 현재 애플리케이션을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7c893bf9fd681a7f7a6fb13527c0cc5dfde15e8a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the value of the previous expression is used.</source>
          <target state="translated">인수가 제공되지 않으면 이전 표현식의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44e1f09935bd0cbe5978c5fb2f1f11d782328422" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an archive in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix archive.build&lt;/code&gt;&lt;/a&gt;), then the archive will be installed locally. For example:</source>
          <target state="translated">인수가 제공되지 않지만 프로젝트의 루트 디렉토리 에 아카이브가있는 경우 ( &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt; &lt;code&gt;mix archive.build&lt;/code&gt; 로&lt;/a&gt; 생성됨 ) 아카이브가 로컬로 설치됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1e6b21b04e9206b421a7dd9fd273e8d10651e36e" translate="yes" xml:space="preserve">
          <source>If no argument is supplied but there is an escript in the project's root directory (created with &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;), then the escript will be installed locally. For example:</source>
          <target state="translated">인수가 제공되지 않지만 프로젝트의 루트 디렉토리 ( &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; 로 생성됨&lt;/a&gt; )에 escript가있는 경우 escript가 로컬로 설치됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1b6cea41585ef2678e551c971ce31fe417d9dd88" translate="yes" xml:space="preserve">
          <source>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like &lt;code&gt;_&lt;/code&gt;) which will always match.</source>
          <target state="translated">일치하는 절이 없으면 오류가 발생합니다. 이러한 이유로 항상 일치 하는 최종 catch-all 절 ( &lt;code&gt;_&lt;/code&gt; 등 ) 을 추가해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc7cd6fb4c53519f3c55037a05bd9ecc868e4492" translate="yes" xml:space="preserve">
          <source>If no configuration file is given, it loads the project's configuration file, &quot;config/config.exs&quot;, if it exists. Keep in mind that the &quot;config/config.exs&quot; file is always loaded by the CLI and invoking it is only required in cases you are starting Mix manually.</source>
          <target state="translated">구성 파일이 제공되지 않으면 프로젝트의 구성 파일 인 &quot;config / config.exs&quot;(있는 경우)를로드합니다. &quot;config / config.exs&quot;파일은 항상 CLI에 의해로드되며 Mix를 수동으로 시작하는 경우에만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7eed02542b79da944224ca91fcc920777715fa8" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project is used.</source>
          <target state="translated">구성이 제공되지 않으면 현재 프로젝트에 대한 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87546bcf9e4f94845bd9b4719319d8f898876f32" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project will be used.</source>
          <target state="translated">구성이 제공되지 않으면 현재 프로젝트에 대한 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7b738bcb5763933041a695931c6cb78b2d2ed70e" translate="yes" xml:space="preserve">
          <source>If no dependency is given, it uses the tree defined in the &lt;code&gt;mix.exs&lt;/code&gt; file.</source>
          <target state="translated">종속성이 제공되지 않으면 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 트리를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="8420e9f0ced4b5e2305fa85af7c948aac181698b" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">함수가 제공되지 않으면 반복하는 동안 각 요소의 진실성을 확인합니다. 요소에 &lt;code&gt;false&lt;/code&gt; 값 ( false 또는 &lt;code&gt;nil&lt;/code&gt; )이 있으면 반복이 즉시 중지되고 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다. 다른 모든 경우에 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="af73d9c2f1028c805fc39df68dad67f7b564dd8d" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">함수가 제공되지 않으면 반복하는 동안 각 요소의 진실성을 확인합니다. 요소가 참 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 아님)을 갖는 경우 반복이 즉시 중지되고 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 다른 모든 경우에는 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99cc65b0a766a1d7c750735c04a6ce040c2ecd5f" translate="yes" xml:space="preserve">
          <source>If no matching tuple is found, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="translated">일치하는 튜플이 없으면 &lt;code&gt;default&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db86456e3e6a45125baab8b1b669e7d382cc2ad8" translate="yes" xml:space="preserve">
          <source>If none of the clauses match, an error is raised:</source>
          <target state="translated">일치하는 절이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2a4d7b7ce6ed34ac382f69616d43a496e285e59" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">존재하지 않는 경우, 쉘 프로세스 입력이 없으므로 중단됩니다. &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b534d3078a1eaf21555f5ec72f4135c6d9a40dd" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be a string.</source>
          <target state="translated">존재하지 않는 경우, 쉘 프로세스 입력이 없으므로 중단됩니다. &lt;code&gt;value&lt;/code&gt; 은 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bccd76edbf5bdad5646dc98c00f42c25e3b6a1a0" translate="yes" xml:space="preserve">
          <source>If one is already registered, it is replaced.</source>
          <target state="translated">이미 등록 된 경우 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="6d6821d80cd7273e1c9f60ea9b9bf87af913648b" translate="yes" xml:space="preserve">
          <source>If one is not registered, returns the word appended with an &quot;s&quot;.</source>
          <target state="translated">등록되지 않은 경우 &quot;s&quot;가 추가 된 단어를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a2ad82fe5366a9ffae6d450da5ae29fe95a85f3" translate="yes" xml:space="preserve">
          <source>If options are provided, the result will be &lt;code&gt;{:ok, pid}&lt;/code&gt;, returning the IO device created. The option &lt;code&gt;:capture_prompt&lt;/code&gt;, when set to &lt;code&gt;true&lt;/code&gt;, causes prompts (which are specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) to be included in the device's output.</source>
          <target state="translated">옵션이 제공되면 결과는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 생성 된 IO 장치를 반환합니다. &lt;code&gt;:capture_prompt&lt;/code&gt; 옵션 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 프롬프트 ( &lt;code&gt;IO.get*&lt;/code&gt; 함수에 대한 인수로 지정됨 )가 장치의 출력에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3b66a164bf9c0ed9cfb3107b0900a5b27ed87c86" translate="yes" xml:space="preserve">
          <source>If part of a supervision tree, a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</source>
          <target state="translated">감시 트리의 일부인 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 는 트리가 종료 될 때 종료 신호를 수신합니다. 종료 신호는 하위 스펙의 종료 전략을 기반으로하며이 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9b86f1b45462784068301d1b6133eb9cbdf0f18" translate="yes" xml:space="preserve">
          <source>If partitioning is enabled and &lt;code&gt;--cover&lt;/code&gt; is used, no cover reports are generated, as they only contain a subset of the coverage data. Instead, the coverage data is exported to files such as &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt;. Once you have the results of all partitions inside &lt;code&gt;cover/&lt;/code&gt;, you can run &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; to get the unified report.</source>
          <target state="translated">분할이 활성화되고 &lt;code&gt;--cover&lt;/code&gt; 가 사용되는 경우 커버리지 데이터의 하위 집합 만 포함하므로 커버 보고서가 생성되지 않습니다. 대신 커버리지 데이터는 &lt;code&gt;cover/MIX_TEST_PARTITION.coverdata&lt;/code&gt; 와 같은 파일로 내보내집니다 . &lt;code&gt;cover/&lt;/code&gt; 안에 모든 파티션의 결과가 있으면 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.Coverage.html&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; &lt;/a&gt; 를 실행 하여 통합 보고서를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee772fad171fd1b86c1fbf91441e33291245e16b" translate="yes" xml:space="preserve">
          <source>If path/wildcard is a relative path/wildcard, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="translated">경로 / 와일드 카드가 상대 경로 / 와일드 카드 인 경우 현재 구성 파일이있는 디렉토리에 상대적으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="2c9a282865b6fe4119e199b1b0847cbb6040e103" translate="yes" xml:space="preserve">
          <source>If present, invoke the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">존재하는 경우 선택적 콜백 &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; 을&lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f857961c6609ab2fd7dcb4f431f75616d71eb634" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt;; when the binary cannot be coerced into a valid float, the atom &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">성공하면 &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt; 형식으로 튜플을 반환합니다 . 바이너리를 유효한 float로 강제 변환 할 수 없으면 atom &lt;code&gt;:error&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b120927e219fe332092528639b692b8090eba7eb" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt;. Otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt; 형식으로 튜플을 반환합니다 . 그렇지 않으면 &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b18774208db640d57cda0a230752786cd8f12b4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no child specification for the given child ID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 지정된 자식 ID에 대한 자식 사양이 없으면이 함수는 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b3f06ad98d27407a8302c766c4bf1a51ac8c90c4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no process with the given PID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 주어진 PID로 프로세스가 없으면이 함수는 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b49684fdd544a95c54cc6ece8ce5787754e9bca3" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 이 함수는 &lt;code&gt;child_id&lt;/code&gt; 를 찾을 수 없거나 현재 프로세스가 실행 중이거나 재시작중인 경우 적절한 오류 튜플과 함께 오류를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94de3ea42072866e8652cd6fca38378bad81898f" translate="yes" xml:space="preserve">
          <source>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</source>
          <target state="translated">이러한 링크가 이미 존재하는 경우, 주어진 두 프로세스간에 하나의 링크 만있을 수 있으므로이 함수는 아무 작업도 수행하지 않습니다. 프로세스가 자신에 대한 링크를 만들려고하면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82ad4a438a65f14d6cc2e31d27dc219d76d8743c" translate="yes" xml:space="preserve">
          <source>If such a tuple is not found, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">이러한 튜플을 찾지 못하면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="481e39df28a67eb2b33dd5d88bf3b6bd30ab02a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback fails with &lt;code&gt;reason&lt;/code&gt;, this function returns &lt;code&gt;{:error, reason}&lt;/code&gt;. Otherwise, if it returns &lt;code&gt;{:stop, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;{:error, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백이 실패 &lt;code&gt;reason&lt;/code&gt; ,이 함수가 반환 &lt;code&gt;{:error, reason}&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;{:stop, reason}&lt;/code&gt; 또는 &lt;code&gt;:ignore&lt;/code&gt; 를 리턴하면 프로세스가 종료되고이 함수는 각각 &lt;code&gt;{:error, reason}&lt;/code&gt; 또는 &lt;code&gt;:ignore&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="dbcf489afc8a98baffdf14a35b5948b139352b97" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback returns &lt;code&gt;:ignore&lt;/code&gt;, this function returns &lt;code&gt;:ignore&lt;/code&gt; as well and the supervisor terminates with reason &lt;code&gt;:normal&lt;/code&gt;. If it fails or returns an incorrect value, this function returns &lt;code&gt;{:error, term}&lt;/code&gt; where &lt;code&gt;term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 반환 &lt;code&gt;:ignore&lt;/code&gt; ,이 함수의 반환 &lt;code&gt;:ignore&lt;/code&gt; 뿐만 아니라 이성과 수퍼바이저 종료 &lt;code&gt;:normal&lt;/code&gt; . 실패하거나 잘못된 값을 반환하면이 함수는 &lt;code&gt;{:error, term}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;term&lt;/code&gt; 은 오류에 대한 정보가 포함 된 용어이며 감독자는 reason &lt;code&gt;term&lt;/code&gt; 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="71d6d6b5b64b37312988e1b6e5df55a665e7fb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; receives an exit signal (that is not &lt;code&gt;:normal&lt;/code&gt;) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. Note that a process does &lt;em&gt;NOT&lt;/em&gt; trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</source>
          <target state="translated">경우] &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; (아니다 종료 신호를 수신하여 &lt;code&gt;:normal&lt;/code&gt; )가 이탈 포착되지 않은 경우 모든 프로세스에서이 동일한 이유로 갑자기 종료 등 호출되지 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; . 주 프로세스는 않는다는 것을 &lt;em&gt;하지&lt;/em&gt; 기본적으로 트랩 출구와 연결된 프로세스가 종료 또는 노드가 분리 될 때 종료 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9052b50ac29d05b6aa3acc2ac9400b5beedce0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--label compile&lt;/code&gt; flag is given with &lt;code&gt;--sink&lt;/code&gt;, then &lt;code&gt;lib/c.ex&lt;/code&gt; won't be shown, because no module has a compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; but &lt;code&gt;lib/a.ex&lt;/code&gt; still has an indirect compile time dependency on &lt;code&gt;lib/c.ex&lt;/code&gt; via &lt;code&gt;lib/b.ex&lt;/code&gt;:</source>
          <target state="translated">는 IF &lt;code&gt;--label compile&lt;/code&gt; 플래그가 함께 제공됩니다 &lt;code&gt;--sink&lt;/code&gt; , 다음 &lt;code&gt;lib/c.ex&lt;/code&gt; 어떤 모듈에 컴파일 시간 의존성이 없기 때문에, 표시되지 않습니다 &lt;code&gt;lib/c.ex&lt;/code&gt; 하지만 &lt;code&gt;lib/a.ex&lt;/code&gt; 여전히 간접적있다 &lt;code&gt;lib/c.ex&lt;/code&gt; 를 통해 &lt;code&gt;lib/b.ex&lt;/code&gt; 에 대한 컴파일 시간 종속성 :</target>
        </trans-unit>
        <trans-unit id="f3eabf6d5616bb794992bd7e46ea46c1c3f02463" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:capture_prompt&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, prompts (specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) are captured in the output.</source>
          <target state="translated">는 IF &lt;code&gt;:capture_prompt&lt;/code&gt; 의 옵션이 설정되어 &lt;code&gt;true&lt;/code&gt; , (에 대한 인수로 지정된 메시지 &lt;code&gt;IO.get*&lt;/code&gt; 기능) 출력에 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="e863cbc73eabe13e90d2206b9738ad4d5bc8e2e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:debug&lt;/code&gt; option is present, the corresponding function in the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; will be invoked.</source>
          <target state="translated">경우 &lt;code&gt;:debug&lt;/code&gt; 옵션이 존재의의 해당 기능 &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 모듈이&lt;/a&gt; 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="20dea358c75a21f536924752c1d8661c6611e5a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;:spawn_opt&lt;/code&gt; 옵션이 존재하고, 그 값은에서와 같이 기본 과정에 옵션으로 전달됩니다 &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc9742b5fac276e3c5db68eba998892b5d16666" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;:spawn_opt&lt;/code&gt; 옵션이 존재하고, 그 값은에서와 같이 기본 과정에 옵션으로 전달됩니다 &lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a17a9b3957177b112bf526bb40068d405551156b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:timeout&lt;/code&gt; option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;:timeout&lt;/code&gt; 옵션이 존재하는 에이전트는 초기에 대부분에 주어진 밀리 초 수를 보내고 허용 또는 종료되며 시작 기능이 반환됩니다 &lt;code&gt;{:error, :timeout}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb098adf69499ff7a9f9cec625ec93553830b541" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Foo.Bar&lt;/code&gt; 의 모듈이 다른 곳으로 이동,에 대한 참조 &lt;code&gt;Bar&lt;/code&gt; 에서 &lt;code&gt;Foo&lt;/code&gt; 모듈이 필요 완전한 이름 (로 업데이트 할 &lt;code&gt;Foo.Bar&lt;/code&gt; ) 또는 별칭을 명시 적으로 설정해야합니다 &lt;code&gt;Foo&lt;/code&gt; 의 도움으로 모듈 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14ac11fca560d2d149b007098ce38791dba90a1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;Foo.Bar&lt;/code&gt; 의 모듈이 다른 곳으로 이동,에 대한 참조 &lt;code&gt;Bar&lt;/code&gt; 에서 &lt;code&gt;Foo&lt;/code&gt; 모듈이 필요 완전한 이름 (로 업데이트 할 &lt;code&gt;Foo.Bar&lt;/code&gt; ) 또는 별칭을 명시 적으로 설정해야합니다 &lt;code&gt;Foo&lt;/code&gt; 의 도움으로 모듈 &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a6368961da467df03a853267f8beaa74f1276b2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; is not loaded, the application will first be loaded using &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt;. Any included application, defined in the &lt;code&gt;:included_applications&lt;/code&gt; key of the &lt;code&gt;.app&lt;/code&gt; file will also be loaded, but they won't be started.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 이로드되지 않은 경우 먼저 &lt;a href=&quot;#load/1&quot;&gt; &lt;code&gt;load/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 애플리케이션이로드됩니다 . &lt;code&gt;.app&lt;/code&gt; 파일 의 &lt;code&gt;:included_applications&lt;/code&gt; 키에 정의 된 모든 포함 된 응용 프로그램 도로드되지만 시작되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c322faf190500e641ef7c48d9a94611219b9f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;debugger&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package.</source>
          <target state="translated">경우 &lt;code&gt;debugger&lt;/code&gt; 시작되지 않습니다, 여기 일어날 수 있습니다 무엇 : 일부 패키지 관리자는 GUI 지원을위한 WX 바인딩없이 최소화 된 얼랑을 설치하기 기본. 일부 패키지 관리자에서는 헤드리스 Erlang을보다 완전한 패키지로 교체 할 수 있습니다 ( Debian / Ubuntu / Arch에서 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 라는 패키지를 찾으십시오 ). 다른 관리자의 경우 별도의 &lt;code&gt;erlang-wx&lt;/code&gt; (또는 비슷한 이름의) 패키지 를 설치해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbb1dfcd54340620db2a4b1be8a4677dcef95965" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;element&lt;/code&gt; occurs more than once in the &lt;code&gt;list&lt;/code&gt;, just the first occurrence is removed.</source>
          <target state="translated">상기 중간 &lt;code&gt;element&lt;/code&gt; 이상에서 한번 이상 발생 &lt;code&gt;list&lt;/code&gt; 단지 첫 번째 발생을 제거한다.</target>
        </trans-unit>
        <trans-unit id="c08aca5a16d9dc35535dd8000df0a013cccceba1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, inserts the given &lt;code&gt;initial&lt;/code&gt; value.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 주어진 삽입 &lt;code&gt;initial&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="51a63ed6ff743b76fcc933f16622e3ae8d826e4a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, it inserts the given &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 주어진 삽입 &lt;code&gt;default&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="8ce0dac723ef05f760f8c9731a754923353ba4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 제기 &lt;a href=&quot;https://hexdocs.pm/elixir/KeyError.html&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b90b4077be865683040b57e9dd5a794351c1f57" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 제기 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bce3fad01881435afa04eb9438e26f3f17ad50a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 않습니다, 수익을 존재하지 &lt;code&gt;:error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dbc4c11a6c23bf2afb4e21b6579dc04b19c27e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;map&lt;/code&gt; unchanged.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 반환 &lt;code&gt;map&lt;/code&gt; 변경.</target>
        </trans-unit>
        <trans-unit id="f3debd0c004b80e32f0db2e8ec25052d54f08cfa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 키워드 목록이 변경되지 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62f2f316a709eec98605c56cf7264dcfb2bde687" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged. Use &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; to delete just the first entry in case of duplicated keys.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 키워드 목록이 변경되지 반환합니다. 키가 중복 된 경우 첫 번째 항목 만 삭제 하려면 &lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0667a096bf26c8f0e621f049599d4e22e6ac8ad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;module&lt;/code&gt; is not instrumented or if the given &lt;code&gt;function&lt;/code&gt; does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;module&lt;/code&gt; 계측되지 않았거나 주어진 경우 &lt;code&gt;function&lt;/code&gt; 중단 점을 가지고 있지 않습니다, 그것은 어떤 조합입니다 그것은 반환 &lt;code&gt;:not_found&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="03691d0408ebea241da0941314a2772b60f2370b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;right&lt;/code&gt; 피연산자가 적절한 목록이 아닌, 그것은 부적절한 목록을 반환합니다. 경우 &lt;code&gt;left&lt;/code&gt; 피연산자가 적절한 목록이 아닌, 그것을 제기 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6016e2f55c427f96fc5e301fda4f933dcb7f84cb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;right&lt;/code&gt; 피연산자가 적절한 목록이 아닌, 그것은 부적절한 목록을 반환합니다. 경우 &lt;code&gt;left&lt;/code&gt; 피연산자가 적절한 목록이 아닌, 그것을 제기 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37bfbc1115f3a777b2fb554294a534e238eccc25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unescape_map/1&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt;, the char is not escaped and the backslash is kept in the string.</source>
          <target state="translated">는 IF &lt;code&gt;unescape_map/1&lt;/code&gt; 함수가 반환의 &lt;code&gt;false&lt;/code&gt; 의 문자 이스케이프되지 않고 백 슬래시는 문자열에 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="001e53accbd81c0682a50b72be746960fd2af2c9" translate="yes" xml:space="preserve">
          <source>If the IO &lt;code&gt;device&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 가 유니 코드 장치 인 경우 &lt;code&gt;count&lt;/code&gt; 는 검색 할 유니 코드 코드 포인트 수를 나타 냅니다. 그렇지 않으면 &lt;code&gt;count&lt;/code&gt; 는 검색 할 원시 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="8bc76fe61e905f5e8cd97c93427f5f8a0776bded" translate="yes" xml:space="preserve">
          <source>If the VM terminates programmatically, via &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;System.stop/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;System.halt/1&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#at_exit/1&quot;&gt;&lt;code&gt;at_exit/1&lt;/code&gt;&lt;/a&gt; callbacks are not executed.</source>
          <target state="translated">VM을 통해, 프로그램 종료되면 &lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;System.stop/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;System.halt/1&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#at_exit/1&quot;&gt; &lt;code&gt;at_exit/1&lt;/code&gt; &lt;/a&gt; 콜백이 실행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="00f4455df1d117303f7b4dec1a8e7c59907ae6e0" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">별명이 아직 참조되지 않은 경우 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 . charlists, 바이너리 및 원자를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="75f023f5a8fb5579a176722fb1ddcce792e96e4e" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="translated">별칭이 아직 참조되지 않은 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 로&lt;/a&gt; 실패합니다 . 문자 목록, 바이너리 및 원자를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="066a1698eac217d09441d2b5fb8b66f936f99de7" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">애플리케이션에 콜백 모듈이 구성되어 있지 않으면이 시점에서 시작이 수행됩니다. 그렇지 않으면, 호출 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백. 이 함수가 반환 한 최상위 수퍼바이저의 PID는 나중에 사용하기 위해 런타임에 저장되며 반환 된 응용 프로그램 상태도 저장됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="e0a3a0af1299b136f054ee1bd9b8c1968e181e7d" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback is invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="translated">애플리케이션에 콜백 모듈이 구성되어 있지 않으면이 시점에서 시작됩니다. 그렇지 않으면 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백이 호출됩니다. 이 함수에 의해 반환 된 최상위 수퍼바이저의 PID는 나중에 사용할 수 있도록 런타임에 저장되며 반환 된 응용 프로그램 상태도 저장됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="562962b2b4cc24713b05513158139365a944c86f" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">인수 &lt;code&gt;msg&lt;/code&gt; 가 바이너리이면 주어진 인수를 메시지로 사용하여 &lt;a href=&quot;https://hexdocs.pm/elixir/RuntimeError.html&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="df94a702176ed26ed614862093d3a9baa0557531" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="translated">인수 &lt;code&gt;msg&lt;/code&gt; 가 2 진이면 주어진 인수를 메시지로 사용하여 &lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fd89e207521cfe8f1ffff76704430fa5d151c3b" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">속성이 표시된 경우 &lt;code&gt;accumulate&lt;/code&gt; 과 &lt;a href=&quot;#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; , 목록이 항상 반환됩니다. 속성이 &lt;code&gt;accumulate&lt;/code&gt; 로 표시 되지 않았고 어떤 값으로도 설정되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="71a4ad2c3571e6dc0648a7ce18db0a118f1fca6f" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="translated">속성이 표시된 경우 &lt;code&gt;accumulate&lt;/code&gt; 과 &lt;a href=&quot;module#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; , 목록이 항상 반환됩니다. 속성이 &lt;code&gt;accumulate&lt;/code&gt; 으로 표시 되지 않았으며 값으로 설정되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="adaf0c8947d55853c9d373e226af8475042db2c9" translate="yes" xml:space="preserve">
          <source>If the behaviour changes or &lt;code&gt;URI.HTTP&lt;/code&gt; does not implement one of the callbacks, a warning will be raised.</source>
          <target state="translated">동작이 변경되거나 &lt;code&gt;URI.HTTP&lt;/code&gt; 가 콜백 중 하나를 구현하지 않으면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99a1391ef43bb72cc7d48f8ee9698b12d1d27ff4" translate="yes" xml:space="preserve">
          <source>If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the &lt;code&gt;terminate&lt;/code&gt; callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor.</source>
          <target state="translated">하위 프로세스가 종료를 트래핑하지 않으면 첫 번째 종료 신호를 수신하면 즉시 종료됩니다. 하위 프로세스가 종료를 트래핑 하는 중이 면 &lt;code&gt;terminate&lt;/code&gt; 콜백이 호출되고 하위 프로세스는 감독자에 의해 갑자기 종료되기 전에 적절한 시간 간격으로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="05268b70bba2052aa1ccd1488036cae6ea1aa300" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the PID remains set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;:ignore&lt;/code&gt; 를 리턴 하면 PID는 &lt;code&gt;:undefined&lt;/code&gt; 로 설정되어 있고이 함수는 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e5c9cb2d2a33379f64c647839b2a1ab4dbc13e8f" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the child specification is added to the supervisor, the PID is set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;:ignore&lt;/code&gt; 를 리턴 하면 하위 스펙이 수퍼바이저에 추가되고 PID가 &lt;code&gt;:undefined&lt;/code&gt; 로 설정 되고이 함수는 &lt;code&gt;{:ok, :undefined}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ef45b4e1f4c05bc44ee03bd5bad1f5e5a9ba93ef" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, then no child is added to the supervision tree and this function returns &lt;code&gt;:ignore&lt;/code&gt; too.</source>
          <target state="translated">자식 프로세스 시작 함수가 &lt;code&gt;:ignore&lt;/code&gt; 를 반환하면 자식 이 감독 트리에 추가되지 않고이 함수 도 &lt;code&gt;:ignore&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="93487fcca765523c971b5da517cfe6d46d7ca27a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, the PID is added to the supervisor and this function returns the same value.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;{:ok, child}&lt;/code&gt; 또는 &lt;code&gt;{:ok, child, info}&lt;/code&gt; 리턴하면 PID가 수퍼바이저에 추가되고이 함수는 동일한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="92f41de707f645e7e03c7c77ffbddced905df221" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, then child specification and PID are added to the supervisor and this function returns the same value.</source>
          <target state="translated">하위 프로세스 시작 함수가 &lt;code&gt;{:ok, child}&lt;/code&gt; 또는 &lt;code&gt;{:ok, child, info}&lt;/code&gt; 리턴하면 하위 스펙 및 PID가 수퍼바이저에 추가되고이 함수는 동일한 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8a7852d163c87ef12689fc28578feaecfcacfb9c" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="translated">하위 프로세스 시작 함수가 오류 튜플 또는 잘못된 값을 리턴하거나 실패하면 하위 스펙이 삭제되고이 함수는 &lt;code&gt;{:error, error}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;error&lt;/code&gt; 는 오류 및 하위 스펙에 대한 정보를 포함하는 용어입니다.</target>
        </trans-unit>
        <trans-unit id="971c2677787cebeaf5076ea02ea7abe46523d9e1" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is the error or erroneous value returned from child process start function, or failure reason if it fails.</source>
          <target state="translated">하위 프로세스 시작 함수가 오류 튜플 또는 오류 값을 리턴하거나 실패하면 하위 스펙이 삭제되고이 함수는 &lt;code&gt;{:error, error}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;error&lt;/code&gt; 는 하위 프로세스 시작 함수에서 리턴 된 오류 또는 오류 값입니다. 실패하면 실패 이유.</target>
        </trans-unit>
        <trans-unit id="4ed3068726af85a0584fbeb7b657ccca120db122" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns &lt;code&gt;{:error, error}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 시작 함수가 오류 튜플 또는 잘못된 값을 리턴하거나 실패하면이 함수는 &lt;code&gt;{:error, error}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3e556a251ad20ce02002d9e36048516e94aeb978" translate="yes" xml:space="preserve">
          <source>If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as &lt;code&gt;:'🌢 Elixir'&lt;/code&gt;, &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt;, and &lt;code&gt;:&quot;123&quot;&lt;/code&gt;.</source>
          <target state="translated">콜론 바로 뒤에 원자 이름을 둘러싼 한 쌍의 큰 따옴표 또는 작은 따옴표가 오는 경우, 원자는 인용 된 것으로 간주됩니다. 인용되지 않은 원자와 달리, 이것은 &lt;code&gt;:'🌢 Elixir'&lt;/code&gt; , &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;123&quot;&lt;/code&gt; 과 같은 모든 유니 코드 문자 (문자뿐만 아니라)로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8941e9716f24149ae17a893ee971b4de7ba5c0c1" translate="yes" xml:space="preserve">
          <source>If the compiler uses manifest files to track stale sources, it should define &lt;code&gt;manifests/0&lt;/code&gt;, and if it writes any output to disk it should also define &lt;code&gt;clean/0&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 매니페스트 파일을 사용하여 오래된 소스를 추적하는 경우 &lt;code&gt;manifests/0&lt;/code&gt; 을 정의해야하며 디스크에 출력을 기록하는 경우 &lt;code&gt;clean/0&lt;/code&gt; 도 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56beff3afd9994ddacaef88c1f904aa35af05474" translate="yes" xml:space="preserve">
          <source>If the condition given to &lt;code&gt;if/2&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, the body given between &lt;code&gt;do/end&lt;/code&gt; is not executed and instead it returns &lt;code&gt;nil&lt;/code&gt;. The opposite happens with &lt;code&gt;unless/2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if/2&lt;/code&gt; 에 주어진 조건이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 &lt;code&gt;do/end&lt;/code&gt; 사이에 주어진 본문 이 실행되지 않고 대신 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 그렇지 &lt;code&gt;unless/2&lt;/code&gt; 반대의 경우 / 2 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="99b59e29ecc1dff1755220f8555df92bd2b4fe3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 매개 변수가 없으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="90ee89304a582019b79109925a1ae106da1b349f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 매개 변수가없는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="8b800c2816d5b5f752096a4e8e30fb37f2f59391" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">구성 매개 변수가 없으면 함수는 &lt;code&gt;:error&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a592ffaee07d8c5f17b9ba6b9f33ed8e98c54d6f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns the &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="translated">구성 매개 변수가 없으면 함수는 &lt;code&gt;default&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6759e47fd880f62f176d9957b609a75b5cf78194" translate="yes" xml:space="preserve">
          <source>If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">요일이 이미주의 첫 번째 요일이면 요일 자체를 반환합니다. 기본 제공 ISO 달력의 경우 주가 월요일에 시작됩니다. &lt;code&gt;:default&lt;/code&gt; 대신 평일 을 &lt;code&gt;starting_on&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7fc25fab05e3574194267d1e7b17bc5554868b2" translate="yes" xml:space="preserve">
          <source>If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than &lt;code&gt;:default&lt;/code&gt; can be given as &lt;code&gt;starting_on&lt;/code&gt;.</source>
          <target state="translated">해당 요일이 이미 마지막 요일이면 요일 자체를 반환합니다. 내장 ISO 달력의 경우 주가 일요일에 끝납니다. &lt;code&gt;:default&lt;/code&gt; 대신 평일 을 &lt;code&gt;starting_on&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3cb9f3017a3cd59ff39001a965e946f4fe46ba2" translate="yes" xml:space="preserve">
          <source>If the dependency is locked, a lock is received in &lt;code&gt;opts&lt;/code&gt; and the repository must be check out at the lock. Otherwise, no lock is given and the repository can be checked out to the latest version.</source>
          <target state="translated">종속성이 잠겨 있으면 &lt;code&gt;opts&lt;/code&gt; 에서 잠금이 수신되고 저장소는 잠금에서 체크 아웃되어야합니다. 그렇지 않으면 잠금이 제공되지 않으며 저장소를 최신 버전으로 체크 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7a6151093f7c2a971f2852905fc785857fff18" translate="yes" xml:space="preserve">
          <source>If the element does not exist, it is added to the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">요소가 존재하지 않으면 &lt;code&gt;list&lt;/code&gt; 끝에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3834eb098b76c8c7be976a57156c5a8c5b9abc11" translate="yes" xml:space="preserve">
          <source>If the enumerable is empty, the provided &lt;code&gt;empty_fallback&lt;/code&gt; is called. The default &lt;code&gt;empty_fallback&lt;/code&gt; raises &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 형이 비어 있으면 제공된 &lt;code&gt;empty_fallback&lt;/code&gt; 이 호출됩니다. 기본 &lt;code&gt;empty_fallback&lt;/code&gt; 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.EmptyError.html&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1b44730d66c61b1f7aa74b49b7cfff54912615" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;varname&lt;/code&gt; is set, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned where &lt;code&gt;value&lt;/code&gt; is a string. If &lt;code&gt;varname&lt;/code&gt; is not set, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="translated">환경 변수 &lt;code&gt;varname&lt;/code&gt; 이 설정되면 &lt;code&gt;{:ok, value}&lt;/code&gt; 가 리턴되며 여기서 &lt;code&gt;value&lt;/code&gt; 는 문자열입니다. 경우 &lt;code&gt;varname&lt;/code&gt; 에이 설정되지 않은 &lt;code&gt;:error&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea743105c28535da020399869c10ba09ded50b63" translate="yes" xml:space="preserve">
          <source>If the exception module implements the optional &lt;a href=&quot;#c:blame/2&quot;&gt;&lt;code&gt;blame/2&lt;/code&gt;&lt;/a&gt; callback, it will be invoked to perform the computation.</source>
          <target state="translated">예외 모듈이 선택적 &lt;a href=&quot;#c:blame/2&quot;&gt; &lt;code&gt;blame/2&lt;/code&gt; &lt;/a&gt; 콜백을 구현 하면 계산을 수행하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba3395fcc44d77deb4fad259828439fe83f301c" translate="yes" xml:space="preserve">
          <source>If the exit reason is not &lt;code&gt;:normal&lt;/code&gt;, all the processes linked to the process that exited will crash (unless they are trapping exits).</source>
          <target state="translated">종료 이유가 &lt;code&gt;:normal&lt;/code&gt; 이 아닌 경우, 종료 된 프로세스에 링크 된 모든 프로세스가 종료됩니다 (종료를 트래핑하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="69bc5d1890437acbe1c535fa849ec2779651267d" translate="yes" xml:space="preserve">
          <source>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">식을 확장 할 수 없으면 식 자체를 반환합니다. 이 기능은 AST를 통과하지 않으며 루트 노드 만 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5138f099eddbd71facd7cd878f3e30168acb4c" translate="yes" xml:space="preserve">
          <source>If the external resource does not exist, the module still has a dependency on it, causing the module be recompiled as soon as the file is added.</source>
          <target state="translated">외부 리소스가 존재하지 않으면 모듈에 여전히 종속성이 있으므로 파일이 추가되는 즉시 모듈이 다시 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="9daaa1fc9c23e088e0d8755d3c8c12ee8baa78ff" translate="yes" xml:space="preserve">
          <source>If the file already exists and the contents are not the same, it asks for user confirmation.</source>
          <target state="translated">파일이 이미 존재하고 내용이 동일하지 않은 경우 사용자 확인을 요청합니다.</target>
        </trans-unit>
        <trans-unit id="dd469ee5a62e6b5a80b7c5e501b5ee43bbcd856c" translate="yes" xml:space="preserve">
          <source>If the file does exists, and if write is not combined with read, the file will be truncated.</source>
          <target state="translated">파일이 존재하고 쓰기가 읽기와 결합되지 않으면 파일이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4a926f33aaf552a1fcd49d45cc93ae59488a7d3e" translate="yes" xml:space="preserve">
          <source>If the file has been required, it returns &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">파일이 필요한 경우 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d5c19fb123316598a0d9b3638a762db6e8c9b35b" translate="yes" xml:space="preserve">
          <source>If the file has not been required, it returns the list of modules:</source>
          <target state="translated">파일이 필요하지 않은 경우 모듈 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f8fd33f5966315da13c7c5967bb4b7033821bc3d" translate="yes" xml:space="preserve">
          <source>If the function does not return &lt;code&gt;true&lt;/code&gt; for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</source>
          <target state="translated">동일한 값에 대해 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환하지 않으면 정렬이 안정적이지 않고 동일한 항의 순서가 섞일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46872c4f6b3b3d53e570bd775f9872272859aad0" translate="yes" xml:space="preserve">
          <source>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</source>
          <target state="translated">정의중인 함수 / 매크로에 여러 개의 절이있는 경우 각 절마다 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="49c229dbf0034a08eae6f9a0c1010fd39f336907" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;context&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (by default it is), the binding for the current context is returned.</source>
          <target state="translated">주어진 &lt;code&gt;context&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; (기본)이면 현재 컨텍스트에 대한 바인딩이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6978259d37eaf03d5b3cc55b25024a1b3148e5a5" translate="yes" xml:space="preserve">
          <source>If the given function callback fails, the function returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="translated">주어진 함수 콜백이 실패하면 함수는 &lt;code&gt;{:error, reason}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f6ebfab2382584c9b3958f6f2fa9de700377fed5" translate="yes" xml:space="preserve">
          <source>If the given name does not exist, an error is raised.</source>
          <target state="translated">주어진 이름이 존재하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3af8970b7302792aa5fbcf15bf7d3816a9358c60" translate="yes" xml:space="preserve">
          <source>If the given project configuration does not identify an umbrella project, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">주어진 프로젝트 구성이 우산 프로젝트를 식별하지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="46533ec867c9435d899cb6828abb727c8f1630e2" translate="yes" xml:space="preserve">
          <source>If the given project configuration identifies an umbrella project, the return value is a map of &lt;code&gt;app =&amp;gt; path&lt;/code&gt; where &lt;code&gt;app&lt;/code&gt; is a child app of the umbrella and &lt;code&gt;path&lt;/code&gt; is its path relative to the root of the umbrella project.</source>
          <target state="translated">주어진 프로젝트 구성이 우산 프로젝트를 식별하는 경우 반환 값은 &lt;code&gt;app =&amp;gt; path&lt;/code&gt; 의 맵입니다. 여기서 &lt;code&gt;app&lt;/code&gt; 은 우산의 하위 앱이고 &lt;code&gt;path&lt;/code&gt; 는 우산 프로젝트의 루트에 상대적인 경로 입니다.</target>
        </trans-unit>
        <trans-unit id="1a1e4f0e379f9bd60165b52c832ccce09165194e" translate="yes" xml:space="preserve">
          <source>If the given string is empty, an empty list is returned.</source>
          <target state="translated">주어진 문자열이 비어 있으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5fa7671aa9ac1c4f631b6b91cdd66f8be6d72c5" translate="yes" xml:space="preserve">
          <source>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</source>
          <target state="translated">마지막 인수가 맵 및 목록과 같은 데이터 구조이고 데이터 구조의 시작이 함수 호출과 동일한 행에 맞는 경우 들여 쓰기가 발생하지 않으면 다음과 같은 코드가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="78f6031137384aa25684e5873b8f78717fddd500" translate="yes" xml:space="preserve">
          <source>If the last chunk does not have &lt;code&gt;count&lt;/code&gt; elements to fill the chunk, elements are taken from &lt;code&gt;leftover&lt;/code&gt; to fill in the chunk. If &lt;code&gt;leftover&lt;/code&gt; does not have enough elements to fill the chunk, then a partial chunk is returned with less than &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">마지막 청크에 청크 를 채울 &lt;code&gt;count&lt;/code&gt; 있는 개수 요소 가없는 경우 &lt;code&gt;leftover&lt;/code&gt; 부분에서 청크를 채 웁니다. 경우 &lt;code&gt;leftover&lt;/code&gt; 청크를 채우기에 충분한 요소를 가지고 있지 않습니다, 다음 부분 덩어리 미만으로 반환되는 &lt;code&gt;count&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="6d2f647fee30ac3b21a14f06f704594c6fc607f3" translate="yes" xml:space="preserve">
          <source>If the matching entry points to the node evaluating the request, then we&amp;rsquo;ve finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we&amp;rsquo;ll pass the request to this node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.</source>
          <target state="translated">일치하는 항목이 요청을 평가하는 노드를 가리키는 경우 라우팅이 완료되고이 노드는 요청 된 작업을 수행합니다. 일치하는 항목이 다른 노드를 가리키는 경우이 노드로 요청을 전달합니다.이 노드는 자체 라우팅 테이블 (첫 번째 노드의 테이블과 다를 수 있음)을보고 그에 따라 작동합니다. 일치하는 항목이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e8da94808be345264b3caf7126393ed8c8b9f07" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this function returns &lt;code&gt;{:error, :unavailable}&lt;/code&gt;. Unavailable doesn't necessarily mean the module doesn't exist, just that it is not currently available, but it (or may not) become available in the future.</source>
          <target state="translated">검사중인 모듈이 현재 컴파일러 교착 상태에있는 경우이 함수는 &lt;code&gt;{:error, :unavailable}&lt;/code&gt; 반환합니다 . 사용할 수 없다고해서 반드시 모듈이 존재하지 않는다는 것을 의미하는 것은 아니며, 현재 사용할 수 없다는 의미 일뿐 아니라 향후 사용할 수있게 될 수도 있습니다 (또는 그렇지 않을 수도 있음).</target>
        </trans-unit>
        <trans-unit id="52158ebe3b1b3c65fb9901ffb1a952d081b6bc67" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this functions returns &lt;code&gt;{:error, :nofile}&lt;/code&gt;.</source>
          <target state="translated">검사중인 모듈이 현재 컴파일러 교착 상태 인 경우이 함수는 &lt;code&gt;{:error, :nofile}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6d2912dbde0fc1cf3c15e41a6a7b770a6ace8e7a" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not compiled yet, &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; halts the compilation of the caller until the module given to &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</source>
          <target state="translated">모듈이 이미로드 된 경우 no-op으로 작동합니다. 모듈이 아직 컴파일되지 않은 경우, &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; 에&lt;/a&gt; 주어진 모듈 이 사용 가능해 지거나 현재 프로젝트의 모든 파일이 컴파일 될 때까지 호출자의 컴파일을 중지합니다 . 컴파일이 완료되고 모듈을 사용할 수없는 경우 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4057f0905e6629307a032b9c000b6e956f9d35d4" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</source>
          <target state="translated">모듈이 이미로드 된 경우 no-op로 작동합니다. 모듈이 아직로드되지 않은 경우 먼저 컴파일해야하는지 확인한 다음로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="e5e8ed6a3a6371fcd484a0f8c9f4271b4ee45925" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</source>
          <target state="translated">모듈이 이미로드되어 있으면 작동하지 않는 것으로 작동합니다. 모듈이 아직로드되지 않은 경우로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a53b9d6b0418ab1b2e4ace2c2f0d58e6dbe324b3" translate="yes" xml:space="preserve">
          <source>If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">모듈이 계측되지 않거나 지정된 함수에 중단 점이 없으면 모듈은 작동하지 않으며 &lt;code&gt;:not_found&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b54c97a0a75e51befdfd85bfe55c94a87325400a" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">함수를 호출하려는 모듈에 &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; 와 같이 긴 이름이 있고 자세한 이름이있는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 특수 형식을 활용 하고 여전히 모듈을 &lt;code&gt;MyLib&lt;/code&gt; 로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3287b87c75de3c7f69ccf215597988b7b4d5d83" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="translated">함수를 호출하려는 모듈의 이름이 &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt; 와 같이 긴 이름을 갖고 있고 자세한 정보를 발견 한 경우 &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 특수 양식을 활용 하고 모듈을 &lt;code&gt;MyLib&lt;/code&gt; 로 계속 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80bfedd28d224208419788d64b48145856d28f2e" translate="yes" xml:space="preserve">
          <source>If the normalized &lt;code&gt;index_range.first&lt;/code&gt; is out of bounds of the given &lt;code&gt;enumerable&lt;/code&gt;, or this one is greater than the normalized &lt;code&gt;index_range.last&lt;/code&gt;, then &lt;code&gt;[]&lt;/code&gt; is returned.</source>
          <target state="translated">정규화 된 경우 &lt;code&gt;index_range.first&lt;/code&gt; 소정의 범위 외에 &lt;code&gt;enumerable&lt;/code&gt; 나이 하나 정규화보다 큰 &lt;code&gt;index_range.last&lt;/code&gt; 다음 &lt;code&gt;[]&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="08e33554a9805c7015a58e968e41eb7b15679006" translate="yes" xml:space="preserve">
          <source>If the number is equidistant to the two nearest integers, rounds away from zero.</source>
          <target state="translated">숫자가 가장 가까운 두 정수와 같은 거리에 있으면 0에서 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="1ada57e8ed2825b579416e3a51bc87db286561fd" translate="yes" xml:space="preserve">
          <source>If the offset is greater than string length, then it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">오프셋이 문자열 길이보다 큰 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;:pop&lt;/code&gt; 을 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{value, new_data}&lt;/code&gt; 여야합니다. 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래 값 이거나 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; 이고 &lt;code&gt;new_data&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 없는 &lt;code&gt;data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="translated">전달 된 함수가 &lt;code&gt;{get_value, update_value}&lt;/code&gt; 를 리턴하면이 콜백의 리턴 값은 &lt;code&gt;{get_value, new_data}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3dea051cec0438020d90f4862f83ccd43c6add8" translate="yes" xml:space="preserve">
          <source>If the path given to &lt;code&gt;File.read/1&lt;/code&gt; exists, it returns a tuple with the atom &lt;code&gt;:ok&lt;/code&gt; as the first element and the file contents as the second. Otherwise, it returns a tuple with &lt;code&gt;:error&lt;/code&gt; and the error description.</source>
          <target state="translated">&lt;code&gt;File.read/1&lt;/code&gt; 에 지정된 경로 가 존재하면 atom &lt;code&gt;:ok&lt;/code&gt; 를 첫 번째 요소로, 파일 내용을 두 번째 요소로 튜플을 반환합니다 . 그렇지 않으면 &lt;code&gt;:error&lt;/code&gt; 및 오류 설명과 함께 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="53bd7b87b61d322c4fd45f7642221fa6272a8869" translate="yes" xml:space="preserve">
          <source>If the path is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored.</source>
          <target state="translated">경로가 이미 절대 경로 인 경우 &lt;code&gt;relative_to&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4146f9776d17822883d0a24f1d05b48694b8cdc9" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly (be it by failing or providing a sane default).</source>
          <target state="translated">함수를 호출하기 전에 이전의 값인 경우 &lt;code&gt;nil&lt;/code&gt; , 함수 &lt;em&gt;것이다&lt;/em&gt; 수신 &lt;code&gt;nil&lt;/code&gt; 값으로하고 이에 따라 그것을 처리 (고장 또는 온전한 기본 제공하여 일)한다.</target>
        </trans-unit>
        <trans-unit id="4dbd652e27d03f3eda58f1454adbcc277b1cf2a2" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly.</source>
          <target state="translated">함수를 호출하기 전의 이전 값이 &lt;code&gt;nil&lt;/code&gt; 이면 함수 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;nil&lt;/code&gt; 을 값으로 받고 이에 따라 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="c374c88228928cded93b273d043b81d7a9e4db50" translate="yes" xml:space="preserve">
          <source>If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then &lt;code&gt;handle_info/2&lt;/code&gt; will be called with &lt;code&gt;:timeout&lt;/code&gt; as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout.</source>
          <target state="translated">시간 초과가 설정 될 때 프로세스에 대기중인 메시지가없고 메시지가 도착하지 않고 지정된 밀리 초 수가 지나면 첫 번째 인수로 &lt;code&gt;:timeout&lt;/code&gt; 을 사용하여 &lt;code&gt;handle_info/2&lt;/code&gt; 가 호출됩니다 . 메시지가 대기 중이거나 지정된 시간 초과 전에 도착하면 시간 초과가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="029b68fe64722c4e17e93dd0458f45ae756acd0b" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;pid&lt;/code&gt; is alive (that is, it's not exiting and has not exited yet) than this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 로 식별 된 프로세스가 활성 상태 인 경우 (즉, 종료되지 않고 아직 종료되지 않은 경우)이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4f04e984ddcea311ccb003e5103d4ca1f57a069c" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">호출 할 때 프로세스가 이미 죽은 경우 &lt;a href=&quot;#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; 하는을 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 즉시 전달된다.</target>
        </trans-unit>
        <trans-unit id="69f0fc29573a8d218a644c814446337651d8b2a1" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="translated">호출 할 때 프로세스가 이미 죽은 경우 &lt;a href=&quot;process#monitor/1&quot;&gt; &lt;code&gt;Process.monitor/1&lt;/code&gt; &lt;/a&gt; 하는을 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 즉시 전달된다.</target>
        </trans-unit>
        <trans-unit id="25b64d8d09022ae8fa6be42d0e689d9f55f93a0d" translate="yes" xml:space="preserve">
          <source>If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed.</source>
          <target state="translated">레지스트리에 중복 키가 있으면 동일한 키 아래의 현재 프로세스에서 여러 번 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296325dc97cde1334962459eb9c5ec5273a16093" translate="yes" xml:space="preserve">
          <source>If the registry has unique keys, it will return &lt;code&gt;{:ok, owner}&lt;/code&gt; unless the key is already associated to a PID, in which case it returns &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt;.</source>
          <target state="translated">레지스트리에 고유 키가있는 경우 키가 이미 PID에 연결되어 있지 않으면 &lt;code&gt;{:ok, owner}&lt;/code&gt; 반환합니다.이 경우 &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt; 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="86406b94fdf6d0355c113c51cd4e50d8ab966009" translate="yes" xml:space="preserve">
          <source>If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and &lt;code&gt;parallel: true&lt;/code&gt; is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition.</source>
          <target state="translated">레지스트리가 파티션 된 경우 파티션 당 콜백이 여러 번 호출됩니다. 레지스트리가 분할되고 &lt;code&gt;parallel: true&lt;/code&gt; 옵션으로 true 가 전달되면 디스패치가 병렬로 수행됩니다. 두 경우 모두 해당 파티션에 대한 항목이있는 경우에만 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4f792d4247d36f7519cbe4df3f7c9194b0d6d3" translate="yes" xml:space="preserve">
          <source>If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry.</source>
          <target state="translated">레지스트리가 고유 한 경우 키가 고유합니다. 그렇지 않으면 프로세스가 동일한 키에 여러 번 등록 된 경우 중복이 포함될 수 있습니다. 프로세스가 종료되었거나이 레지스트리에 키가없는 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc9c622905709241fd4a039cba6efcb68b163916" translate="yes" xml:space="preserve">
          <source>If the repository is private though, you may need to specify the private URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt;. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.</source>
          <target state="translated">저장소가 개인용 인 경우 개인용 URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt; 을 지정해야합니다 . 어쨌든, 적절한 자격 증명이있는 한 Mix는이를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f88ca4263ab5c36582e4eb171ede7757f5a8977" translate="yes" xml:space="preserve">
          <source>If the running process terminates, a new IEx session is started.</source>
          <target state="translated">실행중인 프로세스가 종료되면 새 IEx 세션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="85e3fc96a9666ea6c8e81e1cf2be2da940abf807" translate="yes" xml:space="preserve">
          <source>If the same key is set via &lt;code&gt;@tag&lt;/code&gt;, the &lt;code&gt;@tag&lt;/code&gt; value has higher precedence.</source>
          <target state="translated">&lt;code&gt;@tag&lt;/code&gt; 를 통해 동일한 키를 설정 하면 &lt;code&gt;@tag&lt;/code&gt; 값이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bba8e4c316db50e3c886fad2f7191375910352b7" translate="yes" xml:space="preserve">
          <source>If the same variable appears twice in the same pattern, then they must be bound to the same value:</source>
          <target state="translated">동일한 변수가 동일한 패턴에 두 번 나타나면 동일한 값에 바인딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c381bd34f0f516da0adf5a6559d1022816298c76" translate="yes" xml:space="preserve">
          <source>If the scheme is unknown to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module, this function returns &lt;code&gt;nil&lt;/code&gt;. The default port for any scheme can be configured globally via &lt;a href=&quot;#default_port/2&quot;&gt;&lt;code&gt;default_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">체계가 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 모듈에 알려지지 않은 경우 ,이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 . 모든 체계의 기본 포트는 &lt;a href=&quot;#default_port/2&quot;&gt; &lt;code&gt;default_port/2&lt;/code&gt; &lt;/a&gt; 를 통해 전역 적으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cf20abb00a9c7eb91eeec27cb0a3c2044ccf845" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, the function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If an agent with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">서버가 성공적으로 작성되고 초기화되면이 함수는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;pid&lt;/code&gt; 는 서버의 PID입니다. 지정된 이름의 에이전트가 이미 존재하면 함수는 해당 프로세스의 PID와 함께 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6ae18b173fd4f257f191d68374b82b3609576f9a" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If a process with the specified server name already exists, this function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="translated">서버가 성공적으로 작성 및 초기화 된 경우이 함수는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;pid&lt;/code&gt; 는 서버의 PID입니다. 지정된 서버 이름을 가진 프로세스가 이미 존재하면이 함수는 해당 프로세스의 PID와 함께 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9c79dacc73fa9835dcb970cb3bd153402ac7a2c0" translate="yes" xml:space="preserve">
          <source>If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:</source>
          <target state="translated">시길 문자가 대문자이면,시길에서 보간이 허용되지 않습니다. 그렇지 않으면 내용이 동적 일 수 있습니다. 자세한 내용은 아래시길의 결과를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="f0d8fa47818ba024a0ca6635125390659b191c06" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">float 크기가 최대 크기 &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; 을 초과 하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afe9e25d91e6b6ca076f9ab983498ce202d449f4" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">float의 크기가 최대 크기 인 &lt;code&gt;1.7976931348623157e+308&lt;/code&gt; 을 초과 하면 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f18c5146917295cd360116e64980d6814f74742" translate="yes" xml:space="preserve">
          <source>If the source is a file, it copies &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;. If the &lt;code&gt;source&lt;/code&gt; is a directory, it copies the contents inside source into the &lt;code&gt;destination&lt;/code&gt; directory.</source>
          <target state="translated">소스가 파일 인 경우 &lt;code&gt;source&lt;/code&gt; 를 &lt;code&gt;destination&lt;/code&gt; 에 복사 합니다 . 경우 &lt;code&gt;source&lt;/code&gt; 디렉토리, 그것을 복사에 소스 안에있는 내용입니다 &lt;code&gt;destination&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="d79c1221466668c8f2fb37f46a9b0c4eff50c912" translate="yes" xml:space="preserve">
          <source>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason &lt;code&gt;:shutdown&lt;/code&gt; all the child processes that have already been started, and then terminates itself and returns &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt;.</source>
          <target state="translated">하위 프로세스 중 하나의 시작 기능이 실패하거나 오류 튜플 또는 잘못된 값을 리턴하는 경우, 수퍼바이저는 먼저 reason &lt;code&gt;:shutdown&lt;/code&gt; 로 시작된 모든 하위 프로세스를 종료 한 후 자체 종료하고 &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95311d242d980eca3e042ab39a6d275172dd2491" translate="yes" xml:space="preserve">
          <source>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">범위의 시작이 주어진 문자열에 대해 유효한 오프셋이 아니거나 범위가 역순이면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fdd805e8128eab933d8276c52b9cb625ab5fad9b" translate="yes" xml:space="preserve">
          <source>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</source>
          <target state="translated">범위의 시작 또는 끝이 음수이면 음수 인덱스를 양수로 변환하기 위해 전체 문자열이 먼저 순회됩니다.</target>
        </trans-unit>
        <trans-unit id="fa648af6a9f14eed70d03b7bbaf8c1091284802b" translate="yes" xml:space="preserve">
          <source>If the supervisor already has N children in a way that N exceeds the amount of &lt;code&gt;:max_children&lt;/code&gt; set on the supervisor initialization (see &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;), then this function returns &lt;code&gt;{:error, :max_children}&lt;/code&gt;.</source>
          <target state="translated">N이 수퍼바이저 초기화에 설정된 &lt;code&gt;:max_children&lt;/code&gt; 의 양을 초과하는 방식으로 수퍼바이저에 이미 N 개의 하위가있는 경우 ( &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 참조 )이 함수는 &lt;code&gt;{:error, :max_children}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab3a50abd31e0fe599ff965258406372848105a0" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully spawned (if the start function of each child process returns &lt;code&gt;{:ok, child}&lt;/code&gt;, &lt;code&gt;{:ok, child, info}&lt;/code&gt;, or &lt;code&gt;:ignore&lt;/code&gt;) this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">수퍼바이저와 자식 프로세스가 성공적으로 양산하는 경우 (각 자식 프로세스 반환의 스타트 기능 경우 &lt;code&gt;{:ok, child}&lt;/code&gt; , &lt;code&gt;{:ok, child, info}&lt;/code&gt; , 또는 &lt;code&gt;:ignore&lt;/code&gt; 이 함수가 반환) &lt;code&gt;{:ok, pid}&lt;/code&gt; , 여기서 &lt;code&gt;pid&lt;/code&gt; 는 수퍼바이저의 PID입니다. 수퍼바이저에 이름이 지정되고 지정된 이름의 프로세스가 이미 존재하면이 함수는 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;pid&lt;/code&gt; 는 해당 프로세스의 PID입니다.</target>
        </trans-unit>
        <trans-unit id="ba930cdc55e703dfc4d9bcd1944d94e721ba5186" translate="yes" xml:space="preserve">
          <source>If the supervisor is successfully spawned, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="translated">수퍼바이저가 성공적으로 생성되면이 함수는 &lt;code&gt;{:ok, pid}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;pid&lt;/code&gt; 는 수퍼바이저의 PID입니다. 수퍼바이저에 이름이 지정되고 지정된 이름의 프로세스가 이미 존재하면이 함수는 &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; 반환합니다 . 여기서 &lt;code&gt;pid&lt;/code&gt; 는 해당 프로세스의 PID입니다.</target>
        </trans-unit>
        <trans-unit id="a58325ece0282e34604d2c42efce1f2775632579" translate="yes" xml:space="preserve">
          <source>If the task or alias has already been invoked, subsequent calls to &lt;a href=&quot;#run/2&quot;&gt;&lt;code&gt;run/2&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;abort&lt;/em&gt; without executing and return &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">작업 또는 별칭이 이미 호출 된 경우, 후속 호출하기 &lt;a href=&quot;#run/2&quot;&gt; &lt;code&gt;run/2&lt;/code&gt; &lt;/a&gt; 합니다 &lt;em&gt;중단&lt;/em&gt; 실행하고 반환하지 않고 &lt;code&gt;:noop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e53af2f1716d98281bb0f2f71d348e2e0b0ca4dd" translate="yes" xml:space="preserve">
          <source>If the task or alias were already invoked, it does not run them again and simply aborts with &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="translated">작업 또는 별칭이 이미 호출 된 경우 다시 실행되지 않고 단순히 &lt;code&gt;:noop&lt;/code&gt; 로 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="bdd5aaa87ae18322d70f284e647adedce16eae03" translate="yes" xml:space="preserve">
          <source>If the task was not yet invoked, it runs the task and returns the result.</source>
          <target state="translated">작업이 아직 호출되지 않은 경우 작업을 실행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ffe14eba0b86eb2256ef62d3f747347750fc072" translate="yes" xml:space="preserve">
          <source>If the terms compare equal, the first one is returned.</source>
          <target state="translated">항이 동일하게 비교되면 첫 번째 항이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="76f5c2bf2f306f61b2cf3e6037db4001b825a0db" translate="yes" xml:space="preserve">
          <source>If the use case where you were using GenEvent requires more complex logic, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage documentation&lt;/a&gt; for more information.</source>
          <target state="translated">당신이 GenEvent을 사용하고 유스 케이스가 더 복잡한 로직을 필요로하는 경우, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage는&lt;/a&gt; 훌륭한 대안을 제공합니다. GenStage는 Elixir 팀이 관리하는 외부 Elixir 라이브러리입니다. 이 시스템은 배압을 기본적으로 지원하여 수요 중심 방식으로 이벤트를 교환하는 시스템을 구현하는 도구를 제공합니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dea741f0a7bd15d40b84d96d22a4ee172da3fb54" translate="yes" xml:space="preserve">
          <source>If the use of this module were confined to your own project, you would be able to keep defining new &lt;code&gt;type/1&lt;/code&gt; functions for each new data type. However, this code could be problematic if it were shared as a dependency by multiple apps because there would be no easy way to extend its functionality.</source>
          <target state="translated">이 모듈의 사용이 자신의 프로젝트에 국한된 경우 각 새 데이터 유형에 대해 새 &lt;code&gt;type/1&lt;/code&gt; 함수 를 계속 정의 할 수 있습니다 . 그러나이 코드는 기능을 쉽게 확장 할 수있는 방법이 없기 때문에 여러 앱에서 종속성으로 공유하는 경우 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a623a53d8f71f4bfc3e91a4b2fa820b73e9de973" translate="yes" xml:space="preserve">
          <source>If there are config providers, then a value is injected into the &lt;code&gt;:elixir&lt;/code&gt; application configuration in &lt;code&gt;sys_config&lt;/code&gt; to be read during boot and trigger the providers.</source>
          <target state="translated">구성 공급자가있는 경우 &lt;code&gt;sys_config&lt;/code&gt; 의 &lt;code&gt;:elixir&lt;/code&gt; 응용 프로그램 구성에 값이 주입되어 부팅 중에 읽고 공급자를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="0f3ba34b6884281919234bd65a5c27e05d943121" translate="yes" xml:space="preserve">
          <source>If there are duplicated keys, they are all removed and only the first one is updated.</source>
          <target state="translated">중복 된 키가 있으면 모두 제거되고 첫 번째 키만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc5164cbf429134f06fc3a42dc1c775490799c5" translate="yes" xml:space="preserve">
          <source>If there are no errors, returns a &lt;code&gt;{parsed, rest}&lt;/code&gt; tuple where:</source>
          <target state="translated">오류가 없으면 &lt;code&gt;{parsed, rest}&lt;/code&gt; 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5f562d79d2233001e164c67b307f491a4295de9f" translate="yes" xml:space="preserve">
          <source>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</source>
          <target state="translated">대괄호 주위에 줄 바꿈이 없으면 포맷터는 아래의 발췌 문장과 같이 모든 것을 한 줄에 맞추려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec750b5e724607eb9b83c43fb0d225987965cd76" translate="yes" xml:space="preserve">
          <source>If there exists a task matching the given task name and it has not yet been invoked, this will run the task with the given &lt;code&gt;args&lt;/code&gt; and return the result.</source>
          <target state="translated">주어진 작업 이름과 일치하는 작업이 있고 아직 호출되지 않은 경우 지정된 &lt;code&gt;args&lt;/code&gt; 작업을 실행 하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21bb1c823fd135c98a6434a0ecb8b17912934fc2" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;alias&lt;/a&gt; defined for the given task name, the alias will be invoked instead of the original task.</source>
          <target state="translated">이 생길 경우 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#module-aliases&quot;&gt;별칭&lt;/a&gt; 주어진 작업의 이름에 대한 정의는, 별명 대신 원래 작업의 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8e379b9421d0be8405c193a1a3a55eda70ffe92a" translate="yes" xml:space="preserve">
          <source>If there is an alias with the same name, the alias will be invoked instead of the original task.</source>
          <target state="translated">이름이 같은 별명이 있으면 원래 작업 대신 별명이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c630c661fb48b6b67b3b3185448712f080b96d" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">동적 이름을 로컬로 등록하는 데 관심이있는 경우 원자를 사용하지 마십시오. 원자는 절대 가비지 수집되지 않으므로 동적으로 생성 된 원자는 가비지 수집되지 않습니다. 이러한 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하여 고유 한 로컬 레지스트리를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="742d780da366c9749e094a3e2601e05af9f19b1c" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">동적 이름을 로컬로 등록하려는 경우 원자는 가비지 수집되지 않으므로 동적으로 생성 된 원자는 가비지 수집되지 않으므로 원자를 사용하지 마십시오. 이러한 경우 &lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하여 자체 로컬 레지스트리를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09ae9d40e8862f6952cd3759209cd2022fc6c81a" translate="yes" xml:space="preserve">
          <source>If there is an invalid dependency, its status is printed before aborting.</source>
          <target state="translated">유효하지 않은 종속성이있는 경우 중단하기 전에 해당 상태가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0688b7a0e6bd6041bf3e04042b749415e0032c" translate="yes" xml:space="preserve">
          <source>If there is no current project, &lt;code&gt;nil&lt;/code&gt; is returned. This may happen in cases there is no &lt;code&gt;mix.exs&lt;/code&gt; in the current directory.</source>
          <target state="translated">현재 프로젝트가 없으면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다. 현재 디렉토리에 &lt;code&gt;mix.exs&lt;/code&gt; 가없는 경우에 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c639ca5dfec4193385c0f9daeb2b1d4be710cc52" translate="yes" xml:space="preserve">
          <source>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</source>
          <target state="translated">사서함에 패턴과 일치하는 메시지가 없으면 일치하는 메시지가 도착할 때까지 현재 프로세스가 대기합니다. 제한 시간을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cbcac0d0378ca0df3e990fb1469a678a45c89ea" translate="yes" xml:space="preserve">
          <source>If there is no option, we generate a random one the first time.</source>
          <target state="translated">옵션이 없으면 처음에 임의의 옵션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8408450afd5b2f3e9042d1b8c13e9f58240f928f" translate="yes" xml:space="preserve">
          <source>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</source>
          <target state="translated">정의 된 프로젝트가 없으면 여전히 기본값을 가진 키워드 목록을 반환합니다. 이를 통해 기본 프로젝트없이 많은 믹스 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4a62bcf57109f5efa07a74f29988033109640c" translate="yes" xml:space="preserve">
          <source>If there is no such link, this function does nothing. If &lt;code&gt;pid_or_port&lt;/code&gt; does not exist, this function does not produce any errors and simply does nothing.</source>
          <target state="translated">이러한 링크가 없으면이 함수는 아무 작업도 수행하지 않습니다. 경우 &lt;code&gt;pid_or_port&lt;/code&gt; 이 존재하지 않는,이 기능은 오류를 생산하고 단순히 아무것도하지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="690bb679a1fa855e4e7e99b242998643c82b454f" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, the a tuple with &lt;code&gt;:single&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">제공된 &lt;code&gt;datetime&lt;/code&gt; 에 가능한 단일 기간 만있는 경우 &lt;code&gt;:single&lt;/code&gt; 및 &lt;code&gt;time_zone_period&lt;/code&gt; 가 있는 튜플 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="517af2219a54d5ffad122594bfbc6b466e49d962" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, then a tuple with &lt;code&gt;:ok&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="translated">제공된 &lt;code&gt;datetime&lt;/code&gt; 에 대해 가능한 기간이 하나 뿐인 경우 &lt;code&gt;:ok&lt;/code&gt; 및 &lt;code&gt;time_zone_period&lt;/code&gt; 가 있는 튜플 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f87cf65c1843c87f5a9fb595853f1c2faf34fb20" translate="yes" xml:space="preserve">
          <source>If this function receives a binary, the same binary is returned.</source>
          <target state="translated">이 함수가 이진을 수신하면 동일한 이진이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec445d356d6135c24d3babce972b050d1a27a32" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">이렇게하지 않으려면 사용 &lt;a href=&quot;#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt; 또는 아래 작업을 시작 생각 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 를&lt;/a&gt; 사용하여 &lt;code&gt;async_nolink&lt;/code&gt; 또는 &lt;code&gt;start_child&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="722410509d91a2ea35d8481e8dcb2edd1a9471e8" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;task#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="translated">이렇게하지 않으려면 사용 &lt;a href=&quot;task#start/1&quot;&gt; &lt;code&gt;Task.start/1&lt;/code&gt; &lt;/a&gt; 또는 아래 작업을 시작 생각 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 를&lt;/a&gt; 사용하여 &lt;code&gt;async_nolink&lt;/code&gt; 또는 &lt;code&gt;start_child&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="885b568a39d2f2144bcbdbe9f088220630bb0f55" translate="yes" xml:space="preserve">
          <source>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</source>
          <target state="translated">이러한 조건이 충족되지 않으면 동작이 정의되지 않았거나 (Erlang / OTP 21 이하) 또는 발생합니다 (Erlang / OTP 22 이상).</target>
        </trans-unit>
        <trans-unit id="c532c9eeb04daa8871cfe8c245158904c23d03c5" translate="yes" xml:space="preserve">
          <source>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="translated">두 캘린더가 호환되지 않는 경우 날짜와 시간 만 변환 할 수 있습니다. 호환되는 경우 날짜와 날짜 사이의 순진한 날짜 시간도 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6230d8e63d2f6528e6ac7ed7bd4bbeed089d2da9" translate="yes" xml:space="preserve">
          <source>If two modules &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are imported and they both contain a &lt;code&gt;foo&lt;/code&gt; function with an arity of &lt;code&gt;1&lt;/code&gt;, an error is only emitted if an ambiguous call to &lt;code&gt;foo/1&lt;/code&gt; is actually made; that is, the errors are emitted lazily, not eagerly.</source>
          <target state="translated">두 개의 모듈 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 를 가져오고 둘 다 arity가 &lt;code&gt;1&lt;/code&gt; 인 &lt;code&gt;foo&lt;/code&gt; 함수를 포함하는 경우 &lt;code&gt;foo/1&lt;/code&gt; 에 대한 모호한 호출 이 실제로 수행 된 경우에만 오류가 발생합니다 . 즉, 오류가 간절히 방출되지 않고 느리게 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="55cdfd10bc87ea7561c4ad8cc479f9faf3b27132" translate="yes" xml:space="preserve">
          <source>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</source>
          <target state="translated">대문자가 있으면 약어를 보존하는 메커니즘으로 어떤 식 으로든 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1343958b023308460ee2f6f5daf43ba1fb660edd" translate="yes" xml:space="preserve">
          <source>If we save the code above in a file named &amp;ldquo;concat.ex&amp;rdquo; and compile it, Elixir will emit the following warning:</source>
          <target state="translated">위의 코드를 &quot;concat.ex&quot;라는 파일에 저장하고 컴파일하면 Elixir는 다음과 같은 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8fc6b97491613a1b35780efb44cacd0f0d9099d1" translate="yes" xml:space="preserve">
          <source>If we start our server, we can now send commands to it. For now, we will get two different responses: &amp;ldquo;OK&amp;rdquo; when the command is known and &amp;ldquo;UNKNOWN COMMAND&amp;rdquo; otherwise:</source>
          <target state="translated">서버를 시작하면 명령을 보낼 수 있습니다. 지금은 명령이 알려진 경우&amp;ldquo;OK&amp;rdquo;, 그렇지 않은 경우&amp;ldquo;UNKNOWN COMMAND&amp;rdquo;의 두 가지 응답이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="74591893e85cc364e81b230bedab46ae114fe665" translate="yes" xml:space="preserve">
          <source>If we try to dispatch to &lt;code&gt;Hello.world&lt;/code&gt;, it won't be available as it was defined only in the other shell:</source>
          <target state="translated">&lt;code&gt;Hello.world&lt;/code&gt; 에 디스패치를 ​​시도 하면 다른 쉘에서만 정의 된대로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51c60bac3d7f07a69c2caf5416fb9b2fa0580339" translate="yes" xml:space="preserve">
          <source>If we use chardata instead, it will work as expected:</source>
          <target state="translated">chardata를 대신 사용하면 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5c38beec4d9e8627a3718fd3acf1efdd27ca154a" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;code&gt;:into&lt;/code&gt;, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 를 사용하려면 보유하고있는 각 요소의 빈도를 계산하는 데이터 유형이 필요합니다. Elixir에는 이러한 데이터 유형이 없지만 직접 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">모듈 별명을 지정하고 별명을 사용하지 않으면 Elixir는 별명을 사용하지 않는다는 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">원격 셸에 연결된 경우 연결을 끊은 후에도 활성 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6de1badf3f486dd7b08674c46aeede1396ae7af3" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이벤트 관리자 구현에 관심이있는 경우 아래의 &quot;대안&quot;섹션을 읽어보십시오. Elixir의 Logger와 같은 기존 시스템과 통합하기 위해 이벤트 핸들러를 구현 &lt;a href=&quot;https://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; 대신 : gen_event 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">이벤트 관리자 구현에 관심이있는 경우 아래의 &quot;대체&quot;섹션을 읽으십시오. Elixir 's Logger와 같은 기존 시스템과 통합하기 위해 이벤트 핸들러를 구현 &lt;code&gt;:gen_event&lt;/code&gt; 경우 : gen_event를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">프로덕션에 사용할 분산 키-값 저장소를 찾고 있다면 Erlang에서도 실행되는 &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak을&lt;/a&gt; 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">Windows를 사용하는 경우 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; 를 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">다른 개발자가 사용할 수 있도록 첫 번째 라이브러리를 작성하려는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;라이브러리 가이드 라인&lt;/a&gt; 을 반드시 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f27d0db77231a9a9fe1e42f70173831ee041fc6d" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; attribute, you must set them after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">&lt;code&gt;@moduletag&lt;/code&gt; 또는 &lt;code&gt;@describetag&lt;/code&gt; 특성을 설정하는 경우 ExUnit.Case 를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 호출 한 후에 설정해야 합니다. 그렇지 않으면 컴파일 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">&lt;code&gt;@moduletag&lt;/code&gt; 를 설정하는 경우 ExUnit.Case 를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 호출 한 후에 설정해야 합니다. 그렇지 않으면 컴파일 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5362f8df1641dd054f73093e43438bbe86931ff4" translate="yes" xml:space="preserve">
          <source>If you are setting this option manually, we recommend the cookie option to be a long and randomly generated string, such as: &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt;. We also recommend to restrict the characters in the cookie to the subset returned by &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt;&lt;code&gt;Base.url_encode64/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 수동으로 설정하는 경우 쿠키 옵션은 &lt;code&gt;Base.url_encode64(:crypto.strong_rand_bytes(40))&lt;/code&gt; 와 같이 길고 임의로 생성 된 문자열 인 것이 좋습니다 . 또한 쿠키의 문자를 &lt;a href=&quot;https://hexdocs.pm/elixir/Base.html#url_encode64/1&quot;&gt; &lt;code&gt;Base.url_encode64/1&lt;/code&gt; 이&lt;/a&gt; 반환하는 하위 집합으로 제한하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="84977d9680ddbf5de974cbe18e56c1d8e5ed315c" translate="yes" xml:space="preserve">
          <source>If you are using alternative calendars, any representation can be used as long as you follow the representation by a single space and the calendar name:</source>
          <target state="translated">대체 달력을 사용하는 경우 단일 공백과 달력 이름으로 표현을 따르는 한 모든 표현을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fff90eb4ac49dc35b69d8799d504d16e31937d0" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">비동기 작업을 사용하는 경우 &lt;em&gt;항상&lt;/em&gt; 전송 되므로 응답을 &lt;strong&gt;기다려야&lt;/strong&gt; 합니다 . 응답을 기대하지 않는 경우 아래에 설명 된 &lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">비동기 작업을 사용하는 경우 &lt;em&gt;항상&lt;/em&gt; 전송 되므로 회신을 &lt;strong&gt;기다려야&lt;/strong&gt; 합니다 . 응답이 없을 경우 아래에 설명 된 &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용해 보십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">릴리스를 사용하는 경우 &lt;code&gt;config/releases.exs&lt;/code&gt; 라는 다른 구성 파일 인 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 동안 &lt;code&gt;config/config.exs&lt;/code&gt; 당신이 릴리스를 조립 할 때, 혼합 명령을 포함하여 실행할 때마다 이전 절에서 언급 한 친구가 실행 &lt;code&gt;config/releases.exs&lt;/code&gt; 때마다 당신의 생산 시스템이 부팅을 실행합니다. 프로덕션 시스템에서는 Mix를 사용할 수 없으므로 &lt;code&gt;config/releases.exs&lt;/code&gt; 는 Mix의 기능을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">주어진 모듈에서 여러 함수를 사용하는 경우 해당 함수를 가져 와서 로컬 함수로 참조 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">이미 존재하는 모듈을 정의하려고하면 모듈이 재정의되었다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">localhost에 다시 연결하고 다른 요청을 수행하면 라우팅 테이블에 올바른 노드 이름이 포함되어 있으면 모든 것이 작동합니다. 훌륭해!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">당신이 사용하여 작업을 만들 경우 &lt;code&gt;async_nolink&lt;/code&gt; 을 같은 OTP 동작 내부 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 을&lt;/a&gt; , 당신은 당신의 내부 작업에서 오는 메시지에 일치해야합니다 &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="7afc1a9d68fb426d62d00d555f8cf086c3ea70ff" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">당신이 사용하여 작업을 만들 경우 &lt;code&gt;async_nolink&lt;/code&gt; 을 같은 OTP 동작 내부 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 을&lt;/a&gt; , 당신은 당신의 내부 작업에서 오는 메시지에 일치해야합니다 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파이프, 리디렉션 등을 사용하여 셸 내에서 신뢰할 수있는 명령을 실행하려면 &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c4ee42b2a872c035a26a259f3f919efaaede387" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">계산 결과에 신경 쓰지 않는다면 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; 로&lt;/a&gt; 스트림을 실행할 수 있습니다 . 또한 결과의 순서도 신경 쓰지 않으므로 &lt;code&gt;ordered: false&lt;/code&gt; 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">계산 결과에 신경 쓰지 않으면 &lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; 로&lt;/a&gt; 스트림을 실행할 수 있습니다 . 또한 &lt;code&gt;ordered: false&lt;/code&gt; 설정 하십시오. 결과의 순서에 신경 쓰지 않기 때문에 :</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">알 수없는 스위치를 구문 분석하려면 Elixir가 스위치를 원자로 변환한다는 것을 기억하십시오. 원자는 가비지 수집되지 않으므로 OptionParser는 원자 누출을 피하기 위해 런타임에서 사용하는 원자로 변환되는 스위치 만 구문 분석합니다. 예를 들어, 아래의 코드 는 &lt;code&gt;:option_parser_example&lt;/code&gt; 아톰이 어디에도 사용되지 않기 때문에 &lt;code&gt;--option-parser-example&lt;/code&gt; 스위치를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">오류를 전혀 사용하지 않으면 오류를 제공하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">구조체를 정의 할 때 기본 키 값을 지정하지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">프로세스가 필요하지 않은 경우 프로세스가 필요하지 않습니다. 코드 구성에는 절대 변하지 않는 상태, 동시성 및 실패와 같은 런타임 속성을 모델링하는 데만 프로세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e7f3f6aaa70bf2b4b5317311d23bff5dd41301" translate="yes" xml:space="preserve">
          <source>If you don't want to assert for every result in a doctest, you can omit the result. You can do so between expressions:</source>
          <target state="translated">doctest의 모든 결과에 대해 단언하지 않으려면 결과를 생략 할 수 있습니다. 표현식 사이에서 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">당신이에서 함수 또는 매크로 가져 오지 않을 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 의를 사용 &lt;code&gt;:except&lt;/code&gt; 옵션 다음 인수에 대응하여 기능 / 매크로 목록 :</target>
        </trans-unit>
        <trans-unit id="b4113a290da07af08fe359b9ce4d7fc5b55806b8" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출자를 작업에 연결하지 않으려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 와 함께 감독 된 작업을 사용하고 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; 를&lt;/a&gt; 호출 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">발신자를 작업에 연결하지 않으려면 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 와 함께 감독 작업을 사용하고 &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; 를&lt;/a&gt; 호출 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">대신 &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt; 와 관련된 모든 항목을 제거하지 않으려면 해당 기능이 첫 번째 항목 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">프로젝트가 정의 될 것으로 예상되는 경우, 즉 현재 작업의 요구 사항 인 경우 대신 &lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; 을&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">튜토리얼이나 웹 사이트에서 오류를 발견 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;하면 버그를보고하거나 이슈 추적기에 풀 요청을 보내십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">동일한 종속성에 대해 각 응용 프로그램에서 서로 다른 구성을 사용하거나 다른 종속성 버전을 사용하려는 경우 코드베이스가 제공 할 수있는 것 이상으로 확장되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">비동기 스트림 내에서 엑시트를 처리하기 위해 엑시트를 트래핑하는 것이 발견되면 &lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt; 을 사용 하여 호출 프로세스에 링크되지 않은 태스크를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">이스케이프를 잊어 버리면 코드를 컴파일 할 때 Elixir에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">다른 모듈을 병렬로 컴파일해야하는 파일이 있으면 생성 된 프로세스가 컴파일러 환경을 인식해야합니다. 이 기능을 통해 개발자는 해당 환경을 인식하는 작업을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5adbe460020f7a732f72beadb2bbe1b2658c06f" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조체가 있고 키 집합을 구조체에 병합하려는 경우 키가 구조체의 일부가 아니더라도 오른쪽에있는 모든 키를 구조체에 병합하므로이 함수를 사용하지 마십시오. 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조체가 있고 키 세트를 구조체에 병합하려는 경우 키가 구조체의 일부가 아니더라도 오른쪽의 모든 키를 구조체에 병합하므로이 기능을 사용하지 마십시오. 대신 &lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">내부 종속성이있는 경우 Mix는 두 가지 방법으로 작업 할 수 있습니다. Git 리포지토리 또는 우산 프로젝트.</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Erlang과 Elixir가 모두 설치된 동일한 네트워크에 다른 컴퓨터가있는 경우 다른 쉘을 시작할 수 있습니다. 그렇지 않으면 다른 터미널에서 다른 IEx 세션을 시작할 수 있습니다. 두 경우 모두 &lt;code&gt;bar&lt;/code&gt; 의 짧은 이름을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">가이드에 대한 질문이나 개선 사항이 있으면 &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir 포럼&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;이슈 트래커&lt;/a&gt; 와 같은 토론 채널을 방문하십시오 . 귀하의 의견은 가이드가 액세스 가능하고 최신 상태로 유지되도록 보장하는 데 매우 중요합니다!</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">사전 프로그래밍 경험이 있다면&amp;ldquo;처음에 버킷이 충돌하지 않도록 보장 할 수 있습니까?&amp;rdquo;라고 궁금 할 것입니다. 앞으로 살펴 보 겠지만, Elixir 개발자는 이러한 관행을 &quot;방어 프로그래밍&quot;이라고합니다. 라이브 프로덕션 시스템에는 무언가 잘못 될 수있는 수십 가지 이유가 있기 때문입니다. 디스크가 고장 나거나, 메모리가 손상되거나, 버그가 발생하거나, 네트워크가 1 초 동안 작동을 멈출 수 있습니다. 이러한 오류를 모두 방지하거나 회피하려는 소프트웨어를 작성하는 경우, 오류를 처리하는 것보다 오류 처리에 더 많은 시간을 할애합니다 자신의 소프트웨어!</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">시작 안내서를 건너 뛰거나 오래 전에 읽은 경우 &lt;a href=&quot;../processes&quot;&gt;프로세스&lt;/a&gt; 장 을 다시 읽으십시오 . 시작점으로 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">필요한 경우 Java와 같은 객체 지향 언어의 인터페이스와 같은 동작 (모듈이 구현해야하는 함수 시그너처 세트)을 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">Elixir를 아직 설치하지 않았다면 &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;설치 페이지를&lt;/a&gt; 방문 하십시오 . 완료되면 &lt;code&gt;elixir --version&lt;/code&gt; 을 실행 하여 현재 Elixir 버전을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">모듈을 가져오고이 모듈에서 가져온 함수 나 매크로를 사용하지 않으면 Elixir는 가져 오기가 사용되지 않는다는 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 밀리 초) 내에 응답하지 않은 경우 작업을 종료하려면 다음과 같이 &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; 과 함께 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d30e514f11705943605d282b2e9e021b246888e0" translate="yes" xml:space="preserve">
          <source>If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.</source>
          <target state="translated">AST 메타 데이터에 사용자 지정 키를 도입하는 경우 나중에 컴파일러에서 도입 할 수있는 키와 충돌하지 않도록 라이브러리 또는 애플리케이션의 이름을 접두사로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="35ca2c3b656fa7f282e972b00616f04b656b2e75" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system than the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">현재 시스템과 다른 시스템에서 실행 중이고 정규식과 여러 번 일치하는 것을 알고 있다면 &lt;a href=&quot;#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt; 을 수동으로 호출 하여 런타임 버전 검사를 수행하고 정규식을 다시 컴파일 할 수 있습니다. 필요하다면.</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">현재 시스템과 다른 시스템에서 실행 중이고 정규식과 여러 번 일치하는 것을 알고 있다면 &lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt; 을 수동으로 호출 하여 런타임 버전 확인을 수행하고 정규식을 다시 컴파일 할 수 있습니다 필요하다면.</target>
        </trans-unit>
        <trans-unit id="5923e8f45f692122d1145ed7532ef3732f1c075a" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 사전이 필요한 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 . 당신이 키워드 목록을 조작해야하는 경우, 사용 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 사전이 필요한 경우 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 . 당신이 키워드 목록을 조작해야하는 경우, 사용 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="681b1d87291217ee1d95dbf7ef258360d3658bf7" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">튜플 또는 모듈 하위 사양을 맵으로 변환하거나 하위 사양을 수정해야하는 경우 &lt;a href=&quot;#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 . 예를 들어 다른 &lt;code&gt;:id&lt;/code&gt; 및 &lt;code&gt;:shutdown&lt;/code&gt; 값 10 초 (10_000 밀리 초)로 스택을 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">튜플 또는 모듈 하위 스펙을 맵으로 변환하거나 하위 스펙을 수정해야하는 경우 &lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 . 예를 들어, 다른 &lt;code&gt;:id&lt;/code&gt; 및 10 초 (10_000 밀리 초) 의 &lt;code&gt;:shutdown&lt;/code&gt; 값으로 스택을 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 을 사용하는 동시에 옵션을 Elixir 실행 파일로 전달해야하는 경우 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 를 열면 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="54dbe001cacf2c5ab7935d57b0759fa2b1d3fbe5" translate="yes" xml:space="preserve">
          <source>If you partition your tests across multiple runs, you can unify the report as shown below:</source>
          <target state="translated">테스트를 여러 실행으로 분할하는 경우 아래와 같이 보고서를 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">modes 매개 변수에서 &lt;code&gt;:trim_bom&lt;/code&gt; 을 전달 하면 파일에서 읽을 때 스트림에서 UTF-8, UTF-16 및 UTF-32 바이트 순서 표시를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="ca5840e930e22f09ee97165c990a4a919232564f" translate="yes" xml:space="preserve">
          <source>If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</source>
          <target state="translated">여러 문자열을 연속으로 여러 번 비교하려는 경우 미리 정규화하고 여러 정규화 통과를 피하기 위해 직접 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">연산자 만 사용하거나 건너 뛰려면 다음 옵션을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced663b6bbb3741a07875a23a42c76c24864c77e" translate="yes" xml:space="preserve">
          <source>If you prefer, you can also compile the release to a separate directory, so you can erase all source after the release is assembled:</source>
          <target state="translated">원하는 경우 릴리스를 별도의 디렉토리로 컴파일 할 수도 있으므로 릴리스가 어셈블 된 후 모든 소스를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">&lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 구현 을 다시 방문 하면 옵션을 GenServer에 전달한다는 것을 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5a45f99d559f9a09020a743643928ce3b42a8da" translate="yes" xml:space="preserve">
          <source>If you run &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix test.coverage&lt;/code&gt;&lt;/a&gt; inside an umbrella, it will automatically gather exported cover results from all umbrella children - as long as the coverage results have been exported, like this:</source>
          <target state="translated">우산 내부에서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix test.coverage&lt;/code&gt; &lt;/a&gt; 를 실행하면 다음 과 같이 커버리지 결과를 내 보낸 경우 모든 우산 하위에서 내 보낸 커버 결과를 자동으로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; 를 실행 하면 릴리스 이름과 동일한 짧은 이름 ( &lt;code&gt;--sname&lt;/code&gt; )을 사용하여 시스템이 시작됩니다 ( 이 경우 &lt;code&gt;foo&lt;/code&gt; ) . 다음 단계는 &lt;code&gt;bar&lt;/code&gt; 라는 시스템을 시작하는 것이므로 이전 장에서했던 것처럼 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;bar&lt;/code&gt; 를 함께 연결할 수 있습니다 . 그러나 이것을 달성하기 전에 릴리스의 이점에 대해 조금 이야기 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">당신이 시작하면 &lt;code&gt;bar&lt;/code&gt; 하면서 &lt;code&gt;foo&lt;/code&gt; 아직 실행 오류가 아래의 응용 프로그램 마지막으로 닫힌다 다운 전에 5 번 일이 같은 오류가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">당신이 제공하는 경우 &lt;code&gt;message&lt;/code&gt; , 값에 대한 정보가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f285809f1a4da78d4627f76c40391bd1d6265ba1" translate="yes" xml:space="preserve">
          <source>If you try to match on such an expression, &lt;code&gt;doctest&lt;/code&gt; will fail to compile. There are two ways to resolve this.</source>
          <target state="translated">이러한 표현식에 일치 시키려고하면 &lt;code&gt;doctest&lt;/code&gt; 가 컴파일되지 않습니다. 이 문제를 해결하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">새 매크로를 실행하려고하면 변수 &lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 가 존재하지 않는다고 불평하는 컴파일조차 하지 않습니다. 이 때문에 모호하다 &lt;code&gt;unquote(k)&lt;/code&gt; 이전과 같이, 어느 쪽 맺다 단편이거나, 마찬가지로 정규 맺다 &lt;code&gt;unquote(kv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19c103426cd0a9b9cd1e418473a1f010bac3593" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a code point that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; 을 사용하려고 하면 인수 오류가 발생합니다. 예를 들어, &lt;code&gt;?&amp;pi;&lt;/code&gt; 와 같이 1 바이트로 표현할 수없는 코드 포인트를 IO 데이터 내부 에 넣어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; 을 사용하려고 하면 인수 오류가 발생합니다. 예를 들어, IO 데이터 내에 &lt;code&gt;?&amp;pi;&lt;/code&gt; 와 같이 1 바이트로 표현할 수없는 코드 포인트를 넣으려고합니다 .</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">작업을 항상 다시 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">모듈에서 함수를 캡처하려면 &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6595a62e94b4f38dca60f0418e3d52b457c3e382" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; to use for fetching &lt;code&gt;rebar&lt;/code&gt; please set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;rebar&lt;/code&gt; 을 가져 오는 데 사용할 &lt;a href=&quot;https://repo.hex.pm&quot;&gt;기본 미러&lt;/a&gt; 를 변경 하려면 &lt;code&gt;HEX_MIRROR&lt;/code&gt; 환경 변수 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a8e46bf39b1daac7b96bda2ca9dc8fc521a77c9" translate="yes" xml:space="preserve">
          <source>If you want to change the &lt;a href=&quot;https://repo.hex.pm&quot;&gt;default mirror&lt;/a&gt; used for fetching Hex, set the &lt;code&gt;HEX_MIRROR&lt;/code&gt; environment variable.</source>
          <target state="translated">Hex를 가져 오는 데 사용되는 &lt;a href=&quot;https://repo.hex.pm&quot;&gt;기본 미러&lt;/a&gt; 를 변경 하려면 &lt;code&gt;HEX_MIRROR&lt;/code&gt; 환경 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2cc4b639048c80880ba05a591eea3c58b3d29d6" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 부동 소수점을 직접 부동 소수점으로 변환하려면 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 부동 소수점을 부동 소수점으로 직접 변환하려면 대신 &lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08564e879edc0764f4906097067da72ec6372ab3" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 정수를 정수로 직접 변환하려면 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 정수를 직접 정수로 변환하려면 대신 &lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">보존하지 않고 IO 장치에서 다른 장치로 내용을 복사하거나 소스에서 대상으로 직접 복사하려면 &lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt; 대신 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 포맷터를 통해 형식을 사용자 정의하려는 경우 &lt;code&gt;{module, function}&lt;/code&gt; 튜플을 &lt;code&gt;pattern&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">맵에서 이전에 정의되지 않은 키가 허용됨을 표시하려면 &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; 로 맵 유형을 종료하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="bc7ce43a44c457f071e6a594b6c6aad38b49f886" translate="yes" xml:space="preserve">
          <source>If you want to get the current time in Unix seconds, do not do &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt;. Simply call &lt;code&gt;System.os_time(:second)&lt;/code&gt; instead.</source>
          <target state="translated">현재 시간을 Unix 초 단위로 얻으려면 &lt;code&gt;DateTime.utc_now() |&amp;gt; DateTime.to_unix()&lt;/code&gt; 하지 마십시오 . 대신 &lt;code&gt;System.os_time(:second)&lt;/code&gt; 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffb28d4834a320bc72469ce99b22a133a75bf2e" translate="yes" xml:space="preserve">
          <source>If you want to invoke specific modules and functions in your release, you can do so in two ways: using &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;rpc&lt;/code&gt;.</source>
          <target state="translated">릴리스에서 특정 모듈과 함수를 호출하려면 &lt;code&gt;eval&lt;/code&gt; 또는 &lt;code&gt;rpc&lt;/code&gt; 사용의 두 가지 방법으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5f2868ad75122ea25c9841323d0bc939ec4c117" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; attribute instead of &lt;code&gt;@type&lt;/code&gt;. The visibility also affects whether or not documentation will be generated by tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc&lt;/a&gt;, Elixir&amp;rsquo;s documentation generator.</source>
          <target state="translated">사용자 정의 유형을 비공개로 유지하려면 &lt;code&gt;@type&lt;/code&gt; 대신 &lt;code&gt;@typep&lt;/code&gt; 속성을 사용할 수 있습니다 . 가시성은 또한 Elixir의 문서 생성기 인 &lt;a href=&quot;https://hexdocs.pm/ex_doc/readme.html&quot;&gt;ExDoc&lt;/a&gt; 과 같은 도구로 문서를 생성할지 여부에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 유형을 비공개로 유지하려면 &lt;code&gt;@type&lt;/code&gt; 대신 &lt;code&gt;@typep&lt;/code&gt; 지시문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcbbba3c1ea50cbcd365e262b9d60f2feb2c65ed" translate="yes" xml:space="preserve">
          <source>If you want to keep any two tests separate, add an empty line between them:</source>
          <target state="translated">두 테스트를 별도로 유지하려면 두 테스트 사이에 빈 줄을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">기존 변수와 패턴 일치를하려면 &lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c8e1b5f66c0b107ff181c4a336661c05c7509728" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%5E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">기존 변수에 대해 패턴 일치를 수행하려면 &lt;a href=&quot;#%5E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">기존 변수와 패턴 일치를하려면 &lt;code&gt;^&lt;/code&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수점 이하 자리에서 ceil 작업을 수행하려면 &lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="006d429609c2e4b18605e6317262f44f76104754" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수 자리에서 ceil 연산을 수행하려면 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수 자릿수에서 바닥 작업을 수행하려면 &lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="da1610c8254e7b523adf724249920d8824d70e09" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수 자릿수에 대해 바닥 연산을 수행하려면 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Float.html#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6176e9f771080616be12747b7598ac40675af864" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">내림 된 정수 나누기를 수행하려면 (음의 무한대로 반올림) 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Integer.html#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">바닥 정수 나누기를 수행하려면 (음의 무한대로 반올림) 대신 &lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ea950ebad1bc7656ae137230492317baa7c6a6f0" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">잘린 정수 나누기를 수행하려면 (0으로 반올림) 대신 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">잘린 정수 나누기 (0으로 반올림)를 수행하려면 대신 &lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">&lt;code&gt;:foo&lt;/code&gt; 라는 응용 프로그램에서 모든 로그 호출을 제거하고 &lt;code&gt;Bar.foo/3&lt;/code&gt; 에서만 오류를 유지 하려면 두 가지 다른 일치 항목을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">기존 모듈을 다시 컴파일하려면 &lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; 을&lt;/a&gt; 대신 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">단일 모듈을 다시로드하려면 &lt;code&gt;r(ModuleName)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순서에 관계없이 모든 중복 요소를 제거하려면 &lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">테스트를 수동으로 실행하려면 &lt;code&gt;:autorun&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하고 &lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt; 을 사용 하여 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">&lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.app&lt;/code&gt; 파일 을 모두 검색 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e842c7452c7ee7f8cc32ceae58854550ca1826ee" translate="yes" xml:space="preserve">
          <source>If you want to specify extra overlay directories, you can do so with the &lt;code&gt;:overlays&lt;/code&gt; option. If you need to copy files dynamically, see the &quot;Steps&quot; section.</source>
          <target state="translated">추가 오버레이 디렉토리를 지정하려면 &lt;code&gt;:overlays&lt;/code&gt; 옵션을 사용하면됩니다. 파일을 동적으로 복사해야하는 경우 &quot;단계&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">둘 이상의 변수를 지정하려면 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="982a9cb228f92f03ac85417af3f281e259a660c2" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">맵과 같이 따옴표로 묶인 표현식이 아닌 값의 따옴표를 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; 다음 전에 Macro.escape / 1 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">따옴표로 묶은식이 아닌 값 (예 :지도)을 인용하지 않으 &lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; 먼저 Macro.escape / 1 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc958b979665c9c17d7950e0854fbc66f8ee61bb" translate="yes" xml:space="preserve">
          <source>If you were to perform a hot code upgrade in such an application, it would crash, because in the initial version the state was just a counter but in the new version the state is a tuple. Furthermore, you changed the format of the &lt;code&gt;call&lt;/code&gt; message from &lt;code&gt;:bump&lt;/code&gt; to &lt;code&gt;{:bump, by}&lt;/code&gt; and the process may have both old and new messages temporarily mixed, so we need to handle both. The final version would be:</source>
          <target state="translated">이러한 애플리케이션에서 핫 코드 업그레이드를 수행하면 초기 버전에서는 상태가 카운터 일 뿐이지 만 새 버전에서는 상태가 튜플이기 때문에 충돌이 발생합니다. 또한 &lt;code&gt;call&lt;/code&gt; 메시지 의 형식을 &lt;code&gt;:bump&lt;/code&gt; 에서 &lt;code&gt;{:bump, by}&lt;/code&gt; 로 변경했으며 프로세스에 이전 메시지와 새 메시지가 일시적으로 혼합되어있을 수 있으므로 둘 다 처리해야합니다. 최종 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">GenServer에 대한 자세한 내용을 보려면 Elixir 시작 안내서에서 자습서와 같은 소개를 제공합니다. Erlang의 문서와 링크는 추가적인 통찰력을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b974f9968697c318d27fe1bd482bc9d5a128ec60" translate="yes" xml:space="preserve">
          <source>If you wish to inspect the code points in a single-quoted literal, you can force this by passing the &lt;code&gt;charlists&lt;/code&gt; option to &lt;code&gt;IO.inspect/2&lt;/code&gt;:</source>
          <target state="translated">작은 따옴표로 묶인 리터럴의 코드 포인트를 검사하려면 &lt;code&gt;charlists&lt;/code&gt; 옵션을 &lt;code&gt;IO.inspect/2&lt;/code&gt; 에 전달하여이를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="416d7a121c99b25e16e84560ead7cb67296777e6" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기에 다른 값을 사용하려면 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기에 다른 값을 사용하려면 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일에 정의 된 모듈이 아닌 파일을 평가 한 결과를 얻으려면 &lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">시스템에서 전체적으로 사용 가능하게하려면 &lt;code&gt;ERL_AFLAGS&lt;/code&gt; 환경 변수를 사용하여 터미널 / 쉘 구성에 따라 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">Git 리포지토리에 URL을 통한 기본 username : password HTTP 인증과 같은 인증이 필요한 경우 Git 구성을 통해 달성 할 수 있으며 액세스 규칙은 소스 제어 외부에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">응용 프로그램에 감독 트리가없는 경우 &lt;code&gt;mix.exs&lt;/code&gt; 내에서 &lt;code&gt;def application&lt;/code&gt; 을 변경 하여 응용 프로그램 콜백 이름과 함께 &lt;code&gt;:mod&lt;/code&gt; 키 를 포함 시켜 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">구현이 옵션을 전달하거나 구조체를 기반으로 사용자 정의 코드를 생성하는 경우 전달 된 옵션 을 가져 오려면 &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; 로 정의 된 매크로를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">사용 사례에 GenEvent가 제공 한 것이 정확히 필요하거나 기존 &lt;code&gt;:gen_event&lt;/code&gt; 기반 시스템 과 통합 해야하는 경우 에도 여전히 &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlang 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 현재 작업 디렉토리를 검색 할 수없는 경우이 함수는 주어진 &lt;code&gt;path&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b3de6ae0bb7f57a373dcca73d61975801fe3edfc" translate="yes" xml:space="preserve">
          <source>If, for some reason, you must read the application environment at compile time, use &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt;&lt;code&gt;Application.compile_env/2&lt;/code&gt;&lt;/a&gt;. Read &lt;a href=&quot;application#module-compile-time-environment&quot;&gt;the &quot;Compile-time environment&quot; section of the Application docs&lt;/a&gt; for more information.</source>
          <target state="translated">어떤 이유로 컴파일 타임에 애플리케이션 환경을 읽어야한다면 &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#compile_env/2&quot;&gt; &lt;code&gt;Application.compile_env/2&lt;/code&gt; 를 사용하십시오&lt;/a&gt; . 자세한 정보 &lt;a href=&quot;application#module-compile-time-environment&quot;&gt;는 애플리케이션 문서의 &quot;컴파일 시간 환경&quot;섹션을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">캘린더에서 새 날이 자정에 시작되면 {0, 1}을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">캘린더에서 새 날이 정오에 시작되면 {1, 2}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">캘린더에서 일출에 새로운 날이 시작되면 {1, 4}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">캘린더에서 새 날이 일몰에 시작되면 {3, 4}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">나중에 &lt;code&gt;Bar&lt;/code&gt; 모듈이 &lt;code&gt;Foo&lt;/code&gt; 모듈 정의 외부로 이동 된 경우 전체 이름 ( &lt;code&gt;Foo.Bar&lt;/code&gt; ) 으로 참조 되거나 위에서 설명한 &lt;code&gt;alias&lt;/code&gt; 지시문을 사용하여 별명을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5aadcd56db1850d0771fc6771663e100003c9ea8" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">코드가 실행되는 동안 시스템 시계가 변경되면 1 초 안에 실행 된 일부 코드는 1 시간 이상 걸린다고보고 될 수 있습니다! 이러한 문제를 해결하기 위해 VM은 &lt;a href=&quot;#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt; 을 통해 감소하지 않고 도약하지 않는 단조로운 시간을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">코드가 실행되는 동안 시스템 시계가 변경되면 1 초 동안 실행 된 일부 코드가 1 시간 이상 걸린 것으로보고 될 수 있습니다! 이러한 문제를 해결하기 위해 VM은 &lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt; 을 통해 단조로운 시간을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">이미지 : 부정적. 전경과 배경을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">이미지 : 긍정적. 정상적인 전경과 배경.</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">모듈이 &lt;code&gt;Math.List&lt;/code&gt; 에서 구현 된 특수 목록을 사용한다고 상상해보십시오 . &lt;code&gt;alias&lt;/code&gt; 지시어를 참조 허용 &lt;code&gt;Math.List&lt;/code&gt; 것처럼 &lt;code&gt;List&lt;/code&gt; 모듈 정의 내에서 :</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">누군가 가 현재 그레고리력 연도에 정확히 10,000 년을 추가하는 그레고리력 기반 &lt;code&gt;Calendar.Holocene&lt;/code&gt; 인 Calendar.Holocene을 구현한다고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">주어진 &quot;이전&quot;코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">당신이 인용 된 표현을 가지고 있고 그것을 인용문 안에 넣기를 원한다고 상상해보십시오. 첫 번째 시도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">당신이라는 디렉토리가 상상 &lt;code&gt;projects&lt;/code&gt; : 그 안에 3 개 개의 엘릭서 프로젝트와 &lt;code&gt;elixir&lt;/code&gt; , &lt;code&gt;ex_doc&lt;/code&gt; 및 &lt;code&gt;plug&lt;/code&gt; . 다음과 같이 각 프로젝트 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에서 모든 &lt;code&gt;.beam&lt;/code&gt; 파일을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbd38c599b5ec1ff1edb2d327d81cfb6d57d0ae9" translate="yes" xml:space="preserve">
          <source>Imagine you have a map that contains a MapSet and is printed as:</source>
          <target state="translated">MapSet을 포함하고 다음과 같이 인쇄되는 맵이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">다음과 같은 구조를 가지고 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템을 즉시 정지시킵니다.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">행동 구현</target>
        </trans-unit>
        <trans-unit id="4d98cf2da4c3ebd35020a6022935dad49c5720d8" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt; 등과 같은 함수를 구현 하는 것은 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 이면의 힘을 이해하는 좋은 연습입니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 함수로 작업을 표현할 수없는 경우 개발자는 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; 에&lt;/a&gt; 의지 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt; 등의 기능을 구현 하는 것은 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 의 힘을 이해하기위한 좋은 연습입니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 함수로 연산을 표현할 수없는 경우 개발자는 대부분 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 를 줄이려고 합니다.</target>
        </trans-unit>
        <trans-unit id="ad3e95d8cf32f54c45a81b4f1a57f15494498570" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; (v1.0) 을 호출하지 않고 명시 적으로 동작 구현</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; (v1.0) 을 호출하지 않고 명시 적으로 동작 구현</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">중요 사항 : 유니 코드 모드의 IO 장치에서는이 기능을 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; . 잘못된 데이터가 기록 될 수 있습니다. 특히 표준 IO 장치는 기본적으로 유니 코드로 설정되므로이 기능을 사용하여 stdio에 쓰면 잘못된 데이터가 유선으로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdee98dcb44004b1533b9be7b352b94b0439a6f5" translate="yes" xml:space="preserve">
          <source>Importing dependencies configuration</source>
          <target state="translated">종속성 구성 가져 오기</target>
        </trans-unit>
        <trans-unit id="3e99e591c470385409fd87d84f7ea0fdc9e8826b" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file or files.</source>
          <target state="translated">주어진 파일에서 구성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">주어진 파일에서 구성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">다른 모듈에서 함수와 매크로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bb0b9afcb24ddc9f67176eeec399cead058aa4a9" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">가져 오기 : 새 기능 이 자동으로 가져 오는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈에 추가 될 수 있습니다 . 모듈에 정의 된 로컬 함수와 충돌 할 수 있습니다. 충돌을 사용하여 이전 버전과 호환되는 방식으로 해결 될 수 &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 당신이에서 수입하지 않으려는 모든 기능의 목록 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; . 우리는 그러한 추가를 할 권리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">가져 오기 : 새로운 기능이 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈에 추가 될 수 있으며 , 자동으로 가져 옵니다 . 모듈에 정의 된 로컬 기능과 충돌 할 수 있습니다. &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 사용하여 충돌을 이전 버전과 호환되는 방식으로 해결할 수 있습니다 . [...] 은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 임포트하지 않으려는 모든 기능 목록을 포함합니다 . 우리는 그러한 추가를 할 권리를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">부적절한 목록은 절대 문자 목록으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">ASCII 문자만으로도 잘못된 목록을 인쇄 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1651a35afb019627c0965d85cc4992b58cfbc54d" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned a little bit about strings and we used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">&amp;ldquo;Basic types&amp;rdquo;에서 문자열에 대해 약간 배웠고 검사를 위해 &lt;code&gt;is_binary/1&lt;/code&gt; 함수를 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">&amp;ldquo;기본 유형&amp;rdquo;에서 문자열에 대해 배웠고 &lt;code&gt;is_binary/1&lt;/code&gt; 함수를 검사에 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">에서 &lt;a href=&quot;keywords-and-maps&quot;&gt;7 장&lt;/a&gt; 우리는지도에 대해 배웠습니다 :</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Elixir에서는 여러 기능을 모듈로 그룹화합니다. 이전 장 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;에서 &lt;code&gt;String&lt;/code&gt; 모듈&lt;/a&gt; 과 같은 다양한 모듈을 이미 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="f34428000982ff1805aac800f0ebed47748f3ab4" translate="yes" xml:space="preserve">
          <source>In Elixir you can use a &lt;code&gt;?&lt;/code&gt; in front of a character literal to reveal its code point:</source>
          <target state="translated">Elixir에서는 &lt;code&gt;?&lt;/code&gt; 문자 리터럴 앞에 코드 포인트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">Elixir에서 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 은 매크로로 정의되어 가드로 사용될 수 있습니다. 즉, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 을 호출 하려면 먼저 &lt;code&gt;Integer&lt;/code&gt; 모듈이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">엘릭서에서는 값을 던져 나중에 잡을 수 있습니다. &lt;code&gt;throw&lt;/code&gt; 와 &lt;code&gt;catch&lt;/code&gt; 는하지 않는 한 사용하여 값을 검색 할 수 없습니다 상황을 위해 예약되어 &lt;code&gt;throw&lt;/code&gt; 와 &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">Elixir에서는 모든 코드가 프로세스 내에서 실행됩니다. 프로세스는 서로 분리되어 서로 동시에 실행되며 메시지 전달을 통해 통신합니다. 프로세스는 Elixir의 동시성에 대한 기초 일뿐만 아니라 분산 및 내결함성 프로그램을 구축하기위한 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">엘릭시르에 열거 가능한 임의 데이터 유형을 구현 그이다 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜. &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; ), &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ) 및 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;1..3&lt;/code&gt; )은 열거 형으로 사용되는 일반적인 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a207968d5a8dba5d6352c7b46008a0e1ddc8ec1d" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">Elixir에서 enumerable은 &lt;a href=&quot;https://hexdocs.pm/elixir/Enumerable.html&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 모든 데이터 유형입니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/List.html&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; ), &lt;a href=&quot;https://hexdocs.pm/elixir/Map.html&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ) 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Range.html&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;1..3&lt;/code&gt; )는 열거 형으로 사용되는 일반적인 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Elixir에서 코드 구성은 모듈과 기능에 의해 수행되며 프로세스는 필요하지 않습니다. 예를 들어 계산기를 구현하고 모든 계산기 작업을 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 뒤에 배치하기로 결정 했다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="7900ac30a1169c9e2266c3344cde6f7b66b7bf2b" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Elixir에서 코드 구성은 모듈과 기능으로 이루어지며 프로세스는 필요하지 않습니다. 예를 들어 계산기를 구현하고 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 뒤에 모든 계산기 작업을 배치하기로 결정 했다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">Elixir에서 코드 구성은 모듈과 기능에 의해 수행되며 프로세스는 필요하지 않습니다. 예를 들어, 계산기를 구현하고 모든 계산기 작업을 GenServer 뒤에 배치하기로 결정했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">Elixir에서는 비교 연산자를 사용하여 다른 데이터 유형을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">Elixir에서는 Enumerable을 반복하여 종종 일부 결과를 필터링하고 값을 다른 목록에 매핑하는 것이 일반적입니다. 이해는 그러한 구성에 대한 구문 설탕입니다. 그들은 이러한 공통 작업 &lt;code&gt;for&lt;/code&gt; 특수 형식 으로 그룹화 합니다.</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">Elixir에서 레코드는 주로 두 가지 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">Elixir에서 &lt;code&gt;=&lt;/code&gt; 연산자는 실제로 &lt;em&gt;match operator&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 이유를 보자 :</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">Elixir에서는 관리자가이를 수행합니다. 감독자는 다른 프로세스를 감독하고 충돌 할 때마다 다시 시작하는 프로세스입니다. 이를 위해 Supervisors는 시작 및 종료를 포함한 모든 감독 프로세스의 전체 수명주기를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">엘릭서, 우리는 사용하지 않는 &lt;code&gt;try/rescue&lt;/code&gt; 하기 때문에 &lt;strong&gt;우리가 제어 흐름에 대한 오류를 사용하지 마십시오&lt;/strong&gt; . 문자 그대로 오류가 발생합니다. 예기치 않은 상황 및 / 또는 예외적 인 상황을 위해 예약되어 있습니다. 실제로 흐름 제어 구문이 필요한 경우에는 &lt;em&gt;던지기를&lt;/em&gt; 사용해야합니다. 그것이 우리가 다음에 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">Elixir에서는 두 가지 데이터 유형을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">Elixir에는 데이터 구조에 몇 개의 항목 ( &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 이 있는지 확인하기위한 두 가지 관용구가 있습니다 . &lt;code&gt;length&lt;/code&gt; 는 정보를 계산해야 함을 의미합니다. 예를 들어 &lt;code&gt;length(list)&lt;/code&gt; 는 전체 목록을 가로 질러 길이를 계산해야합니다. 반면에 &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 및 &lt;code&gt;byte_size(binary)&lt;/code&gt; 는 크기 정보가 데이터 구조에서 사전 계산되므로 tuple 및 binary 크기에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">Elixir에는 키워드 목록과 맵이라는 두 가지 주요 연관 데이터 구조가 있습니다. 그들에 대해 더 많이 배울 때입니다!</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">Elixir에는 데이터 구조에 몇 개의 항목 ( &lt;code&gt;length&lt;/code&gt; 와 &lt;code&gt;size&lt;/code&gt; 이 있는지 확인하기위한 두 개의 동사가 있습니다 . &lt;code&gt;length&lt;/code&gt; 는 정보를 계산해야 함을 의미합니다. 예를 들어 &lt;code&gt;length(list)&lt;/code&gt; 는 전체 목록을 가로 질러 길이를 계산해야합니다. 반면, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 및 &lt;code&gt;byte_size(binary)&lt;/code&gt; 는 크기 정보가 데이터 구조에서 사전 계산되므로 tuple 및 binary 크기에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Elixir에서는 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 사용하여 바이너리를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">Erlang에서이 구조체는 &lt;code&gt;:file_info&lt;/code&gt; 레코드로 표시됩니다 . 따라서이 모듈은 Erlang 레코드와 Elixir 구조체 사이를 변환하는 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19ae95f1d5cbc8f9036da514524bab95b3e8521e" translate="yes" xml:space="preserve">
          <source>In Mix projects this function returns the environment this configuration file is executed on. In releases, the environment when &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt; ran.</source>
          <target state="translated">Mix 프로젝트에서이 함수는이 구성 파일이 실행되는 환경을 반환합니다. 릴리스에서 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 실행 된 환경 .</target>
        </trans-unit>
        <trans-unit id="e341b5436849e02ad44c7ab5cb526b1b7ab5e415" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. For example, someone using your application can override its &lt;code&gt;:db_host&lt;/code&gt; environment variable as follows:</source>
          <target state="translated">Mix 프로젝트에서는 &lt;code&gt;config/config.exs&lt;/code&gt; 파일을 통해 애플리케이션의 환경과 해당 종속성을 재정의 할 수 있습니다 . 예를 들어, 애플리케이션을 사용하는 누군가 는 다음과 같이 해당 &lt;code&gt;:db_host&lt;/code&gt; 환경 변수를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">Mix 프로젝트에서 &lt;code&gt;config/config.exs&lt;/code&gt; 파일을 통해 애플리케이션 환경 및 해당 종속성을 재정의 할 수 있습니다 . Mix로 응용 프로그램을 시작하면 컴파일시 및 런타임에서도 해당 구성을 사용할 수 있지만 생성 된 응용 프로그램 자원 파일에 포함되지 않으며 Mix없이 응용 프로그램을 시작하면 해당 구성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">유닉스 계열 시스템에서 수정 시간을 변경 하려면 파일의 &lt;code&gt;root&lt;/code&gt; 또는 소유자 여야 합니다. 쓰기 권한이 충분하지 않을 수 있습니다. 이러한 경우 파일을 처음으로 터치하면 (만들기) 성공하지만 &lt;code&gt;{:error, :eperm}&lt;/code&gt; 기존 파일을 터치하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">GenServer에서 위의 코드는 대략 다음과 같은 두 가지 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">다중 노드가있는 분산 설정에서 익명 기능을 허용하는 API는 호출자 (클라이언트)와 에이전트가 동일한 버전의 호출자 모듈을 가지고있는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0fe49527fc564fb18ae1d9b47c99a05222fe3f97" translate="yes" xml:space="preserve">
          <source>In a hot code upgrade, you want to update a node from version A to version B. To do so, the first step is to write recipes for every application that changed between those two releases, telling exactly how the application changed between versions, those recipes are called &lt;code&gt;.appup&lt;/code&gt; files. While some of the steps in building &lt;code&gt;.appup&lt;/code&gt; files can be automated, not all of them can. Furthermore, each process in the application needs to be explicitly coded with hot code upgrades in mind. Let's see an example. Imagine your application has a counter process as a GenServer:</source>
          <target state="translated">핫 코드 업그레이드에서 노드를 버전 A에서 버전 B로 업데이트하려고합니다. 이렇게하려면 첫 번째 단계는 두 릴리스간에 변경된 모든 애플리케이션에 대한 레시피를 작성하여 버전간에 애플리케이션이 어떻게 변경되었는지 정확히 알려주는 것입니다. 레시피를 &lt;code&gt;.appup&lt;/code&gt; 파일 이라고 합니다. &lt;code&gt;.appup&lt;/code&gt; 파일 을 빌드하는 단계 중 일부는 자동화 할 수 있지만 일부는 자동화 할 수 없습니다. 또한 애플리케이션의 각 프로세스는 핫 코드 업그레이드를 염두에두고 명시 적으로 코딩되어야합니다. 예를 봅시다. 애플리케이션에 GenServer와 같은 카운터 프로세스가 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">간단히 말해 버전은 세 가지 숫자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">간단히 말해서, 응용 프로그램은에 정의 된 모든 모듈로 구성되어 &lt;code&gt;.app&lt;/code&gt; 포함한 파일 내용, &lt;code&gt;.app&lt;/code&gt; 파일 자체. : 응용 프로그램은 일반적으로 단지 두 개의 디렉토리가 &lt;code&gt;ebin&lt;/code&gt; 같은 비약 유물에 대한 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;priv&lt;/code&gt; 에 , 당신은 당신의 응용 프로그램에 필요한 수있는 다른 인공물이나 자산과 함께합니다.</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">간단히 말해서, 동일한 파일이 여러 번 컴파일되지 않도록 시스템이 처리하는 파일을 추적하려는 경우 첫 번째 파일을 사용해야합니다. 이것은 스크립트에서 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">일반 프로젝트에서는 &lt;code&gt;mix release&lt;/code&gt; 를 실행하여 릴리스를 조립할 수 있습니다 . 그러나 우리는 엄브렐러 프로젝트를 진행하고 있으며이 경우 Elixir는 추가적인 정보를 필요로합니다. 무엇이 필요한지 보자 :</target>
        </trans-unit>
        <trans-unit id="2066279752953073a6aab2adcefe389056d45238" translate="yes" xml:space="preserve">
          <source>In addition to matching the target triple, it is also important that the target has all of the system packages that your application will need at runtime. A common one is the need for OpenSSL when building an application that uses &lt;code&gt;:crypto&lt;/code&gt; or &lt;code&gt;:ssl&lt;/code&gt;, which is dynamically linked to ERTS. The other common source for native dependencies like this comes from dependencies containing NIFs (natively-implemented functions) which may expect to dynamically link to libraries they use.</source>
          <target state="translated">대상 트리플을 일치시키는 것 외에도 대상이 런타임에 애플리케이션에 필요한 모든 시스템 패키지를 포함하는 것도 중요합니다. 일반적인 것은 ERTS에 동적으로 링크 된 &lt;code&gt;:crypto&lt;/code&gt; 또는 &lt;code&gt;:ssl&lt;/code&gt; 을 사용하는 애플리케이션을 빌드 할 때 OpenSSL이 필요하다는 것입니다 . 이와 같은 기본 종속성의 다른 일반적인 소스는 사용하는 라이브러리에 동적으로 링크 될 것으로 예상되는 NIF (기본적으로 구현 된 함수)를 포함하는 종속성에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">Elixir 파일 확장자 &lt;code&gt;.ex&lt;/code&gt; 외에도 Elixir는 스크립팅을 위해 &lt;code&gt;.exs&lt;/code&gt; 파일 도 지원합니다 . Elixir는 두 파일을 모두 같은 방식으로 취급하지만, 유일한 차이점은 의도입니다. &lt;code&gt;.ex&lt;/code&gt; 파일은 컴파일하는 동안 &lt;code&gt;.exs&lt;/code&gt; 파일은 스크립팅에 사용됩니다. &lt;code&gt;.ex&lt;/code&gt; 파일 만 바이트 코드를 &lt;code&gt;.beam&lt;/code&gt; 파일 형식으로 디스크에 기록 하지만 두 확장 모두 모듈을 컴파일하여 메모리에로드 합니다.</target>
        </trans-unit>
        <trans-unit id="11490d624ce7faa621bf11120bfb3fc20a3be0c2" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">위에 설명 된 기본 제공 속성 외에도 사용자 지정 속성을 추가 할 수 있습니다. 사용자 정의 속성은 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt; 연산자와 유효한 변수 이름을 사용하여 표현됩니다 . 사용자 정의 속성에 제공된 값은 유효한 Elixir 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">위에서 설명한 내장 속성 외에도 사용자 정의 속성이 추가 될 수 있습니다. 사용자 정의 속성은 &lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt; 연산자와 유효한 변수 이름을 사용하여 표현됩니다 . 커스텀 속성에 주어진 값은 유효한 Elixir 값이어야합니다 :</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; 을&lt;/a&gt; 통해 사용자가 제공 한 키 외에 다음과 같은 추가 키를 &lt;code&gt;:metadata&lt;/code&gt; 목록에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">그 외에도, 큰 따옴표로 묶인 문자열 안의 큰 따옴표는 &lt;code&gt;\&quot;&lt;/code&gt; 로 이스케이프해야하고 , 마찬가지로 작은 따옴표로 묶인 char 목록 안의 작은 따옴표는 &lt;code&gt;\'&lt;/code&gt; 로 이스케이프해야합니다 . 그럼에도 불구하고 더 나은 스타일입니다. 이스케이프를 벗어나는 것보다 위의 구분자를 변경하는 것.</target>
        </trans-unit>
        <trans-unit id="2b2826ef1e2ef7d4eb0ba033cc662710c67d0f81" translate="yes" xml:space="preserve">
          <source>In addition, every protocol implementation module contains the &lt;code&gt;__impl__/1&lt;/code&gt; function. The function takes one of the following atoms:</source>
          <target state="translated">또한 모든 프로토콜 구현 모듈에는 &lt;code&gt;__impl__/1&lt;/code&gt; 함수 가 포함되어 있습니다 . 이 함수는 다음 원자 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">위의 모든 예제에서 파일에 쓸 때 바이너리를 사용했습니다. &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;이진, 문자열 및 charlists&amp;rdquo;&lt;/a&gt; 장에서는 문자열이 바이트로 구성되는 반면 charlist는 유니 코드 코드 포인트가있는 목록에 대해 언급했습니다.</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">어쨌든 다음 중 하나를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;Stack.start_link/1&lt;/code&gt; 이 항상 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 경우 모두 스크립트 또는 표현식에 대한 명령 행 인수는 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91806a81fe43b48626fc4b371025096ff818c577" translate="yes" xml:space="preserve">
          <source>In case ANSI is disabled, the ANSI escape sequences are simply discarded.</source>
          <target state="translated">ANSI가 비활성화 된 경우 ANSI 이스케이프 시퀀스는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">경우에, &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수가 반환 &lt;code&gt;:suspend&lt;/code&gt; 축적을, 그것을 명시 적으로 호출 처리 및 누설하지해야합니다.</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">경우에, &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수가 반환 &lt;code&gt;:suspend&lt;/code&gt; 어큐뮬레이터는 &lt;code&gt;:suspended&lt;/code&gt; 튜플은 명시 적으로 호출 처리 및 누설하지해야합니다. 실제로 이것은 정규 열거 함수가 &lt;code&gt;:done&lt;/code&gt; 및 &lt;code&gt;:halted&lt;/code&gt; 결과에 관심을 가져야한다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">직접 상대 경로를 찾을 수없는 경우 원래 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">단일 파일을 테스트하는 경우 하나 이상의 특정 줄 번호를 전달하여 지정된 테스트 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8071ad6cb618eac03347482224d3c6ae15920db" translate="yes" xml:space="preserve">
          <source>In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">문자열 자체에 큰 따옴표가 있어야하는 경우 큰 따옴표를 백 슬래시로 이스케이프해야합니다 (예 : &lt;code&gt;&quot;this is a string with \&quot;double quotes\&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">스위치 &lt;code&gt;SWITCH&lt;/code&gt; 가 유형 &lt;code&gt;:boolean&lt;/code&gt; 을 갖도록 지정된 경우 , 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하는 &lt;code&gt;--no-SWITCH&lt;/code&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">항목이 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 해당 키가 제거되고 삭제가 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">경우 중간 수익률의 항목 중 하나는 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; 당으로 반환됩니다 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈 :</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">중간에있는 항목 중 하나가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 다음에 액세스하려고 할 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="14f58659a0439f1a109167c635ebf2ecb21a5dc3" translate="yes" xml:space="preserve">
          <source>In case any of the keys returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned:</source>
          <target state="translated">경우 반환 키의 &lt;code&gt;nil&lt;/code&gt; 을은 , &lt;code&gt;nil&lt;/code&gt; 반환됩니다 :</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">그것이 존재하는 경우, 그것은 no-op입니다. 그렇지 않으면 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="75a8464fb2113eaca41fdf083e397d6efb34f66b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">원본 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 에 액세스하려는 경우 &lt;code&gt;Elixir&lt;/code&gt; 에 액세스하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">원본 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 에 액세스하려는 경우 &lt;code&gt;Elixir&lt;/code&gt; 에 액세스하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">문제 가 발생하면 다른 이유로 &lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">별칭이 매크로에 의해 자동으로 생성되는 경우, 별칭이 명시 적으로 정의되지 않았으므로 Elixir는 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b98ade5811cd318aeee5332f266a7b7225f7348" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">변환이 실패하면 &lt;a href=&quot;https://hexdocs.pm/elixir/UnicodeConversionError.html&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 문자열이 주어지면 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">변환이 실패하면 &lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. 문자열이 제공되면 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">파일이 존재하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">매크로에 의해 가져 오기가 자동으로 생성되는 경우, Elixir는 가져 오기가 명시 적으로 정의되지 않았으므로 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">작업 프로세스가 종료되면 현재 프로세스는 작업과 같은 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">테스트가 충돌하는 경우 다음과 같은 보고서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="899b34a899719bbd8b066e45019119b52779572b" translate="yes" xml:space="preserve">
          <source>In case the value you want to interpolate cannot be converted to a string, because it doesn't have an human textual representation, a protocol error will be raised.</source>
          <target state="translated">보간하려는 값이 사람의 텍스트 표현이 없어서 문자열로 변환 할 수없는 경우 프로토콜 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94805569146261c99e1aba00cef7b14d9f604927" translate="yes" xml:space="preserve">
          <source>In case there are no config providers, it doesn't change &lt;code&gt;sys_config&lt;/code&gt;.</source>
          <target state="translated">구성 공급자가없는 경우 &lt;code&gt;sys_config&lt;/code&gt; 를 변경하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">구조를 검사하는 동안 오류가 발생하면 Elixir는 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 오류를 발생시키고 자동으로 구조를 인쇄하기위한 원시 표현으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fd386531e2486b3f99bcfc36b0d8da5b224c20a5" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">구조를 검사하는 동안 오류가 발생하는 경우 Elixir는 &lt;a href=&quot;https://hexdocs.pm/elixir/ArgumentError.html&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 오류를 발생시키고 구조를 인쇄하기 위해 자동으로 원시 표현으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">그러한 메시지가없는 경우 현재 프로세스는 메시지가 도착할 때까지 또는 지정된 시간 종료 값이 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">예상대로 작동하지 않는 경우 보고서에 최대한 많은 정보를 포함하십시오 (예 : Elixir 버전, 코드 스 니펫 및 오류 스택 추적과 함께 오류 메시지). 이 정보를 붙여 넣으려면 &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; 와 같은 사이트를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="2d3cb03ba7258afff951799e09542865bc33c540" translate="yes" xml:space="preserve">
          <source>In case you are manually compiling protocols or building releases, you need to take the generated protocols into account. This can be done with:</source>
          <target state="translated">수동으로 프로토콜을 컴파일하거나 릴리스를 빌드하는 경우 생성 된 프로토콜을 고려해야합니다. 이것은 다음으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">프로세스를 구성해야하는 경우 해당 프로세스를 시작할 때 옵션을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">바이트로 작업해야 할 경우 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 모듈을&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 의 모든 종속성 을 자동으로로드 &lt;strong&gt;하고 시작&lt;/strong&gt; 하려면 &lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">사용자 모듈에 기존 기능을 제공하려는 경우 그에 따라 가져올 모듈에서 해당 기능을 정의하십시오. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 는 ExUnit.Case를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 하는 모듈에서 &lt;code&gt;test/3&lt;/code&gt; 매크로를 정의하지 않지만 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; 를&lt;/a&gt; 정의 하고 사용될 때이를 호출자로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8e67d2f3d283f6f03fc8ad3aba714edbb893d393" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 에서 더 이상 사용되지 않는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 전략을 사용하는 경우 몇 단계로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 로 마이그레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 에서 더 이상 사용되지 않는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 전략을 사용하는 경우 몇 단계만으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 로 마이그레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aec959cd2637331d18fa672f762e0b85e128fa1c" translate="yes" xml:space="preserve">
          <source>In code, function specs are written with the &lt;code&gt;@spec&lt;/code&gt; attribute, typically placed immediately before the function definition. Specs can describe both public and private functions. The function name and the number of arguments used in the &lt;code&gt;@spec&lt;/code&gt; attribute must match the function it describes.</source>
          <target state="translated">코드에서 함수 사양은 일반적으로 함수 정의 바로 앞에있는 &lt;code&gt;@spec&lt;/code&gt; 속성으로 작성 됩니다. 사양은 공개 및 비공개 기능을 모두 설명 할 수 있습니다. &lt;code&gt;@spec&lt;/code&gt; 속성에 사용 된 함수 이름과 인수의 수는 설명하는 함수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">키워드 목록과 달리지도는 패턴 일치에 매우 유용합니다. 맵이 패턴에 사용되면 주어진 값의 서브 세트에서 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">반대로, 호출 된 함수의 값은 해당 함수를 설명하지만 표시된 함수와 관련하여 설명합니다. 예를 들어, 그 마지막 행 수단 &lt;code&gt;Mod.called2/0&lt;/code&gt; 한번 불렸다 &lt;code&gt;Mod.some_function/0&lt;/code&gt; , 그 경우 함수에 소요되는 총 시간은 50ms이다.</target>
        </trans-unit>
        <trans-unit id="1bd204212246b87557a18b94547a4a49f3e0882e" translate="yes" xml:space="preserve">
          <source>In daemon mode, the system is started on the background via &lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl&lt;/a&gt;. You may also want to enable &lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;heart&lt;/a&gt; in daemon mode so it automatically restarts the system in case of crashes. See the generated &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; file.</source>
          <target state="translated">데몬 모드에서 시스템은 &lt;a href=&quot;http://erlang.org/doc/man/run_erl.html&quot;&gt;run_erl을&lt;/a&gt; 통해 백그라운드에서 시작됩니다 . 데몬 모드에서 &lt;a href=&quot;http://erlang.org/doc/man/heart.html&quot;&gt;heart&lt;/a&gt; 를 활성화 하여 충돌시 시스템을 자동으로 다시 시작할 수도 있습니다. 생성 된 &lt;code&gt;releases/RELEASE_VSN/env.sh&lt;/code&gt; 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">실제로 &lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; 를 사용하여 적절한 Elixir 오류가 아닌 오류를 복구 할 수 있습니다. 예를 들어, 변환하기 전에 이전 &lt;code&gt;:badarg&lt;/code&gt; 오류 를 구조하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc62d3ceab839ba2b910c33a7d8e5bd0aaee7f5" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">사실 &lt;a href=&quot;https://hexdocs.pm/elixir/ErlangError.html&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; 는 적절한 Elixir 오류가 아닌 오류를 복구하는 데 사용할 수 있습니다. 예를 들어, 변환 전에 이전 &lt;code&gt;:badarg&lt;/code&gt; 오류 를 구 하는데도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">실제로 원격 셸에 연결하는 것이 일반적이므로 명령 줄을 통해 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">실제로 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; 를 열어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">실제로 &lt;code&gt;:bind_quoted&lt;/code&gt; 옵션은 따옴표에 값을 삽입하려고 할 때마다 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">실제로,이 패턴은 매우 일반적이므로 &lt;code&gt;bind_quoted&lt;/code&gt; &lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; 2quoted 옵션을 quote / 2 와 함께 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;underscore&lt;/code&gt; 은 &lt;code&gt;camelize&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">일반적으로 개발자는 파일이 존재하지 않는 경우 반응하려는 경우 전자를 사용해야합니다. 후자는 파일을 읽을 수없는 경우 (즉 문자 그대로 예외) 개발자가 소프트웨어의 실패를 예상 할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">일반적으로 개발자는 테스트에 일반 &lt;code&gt;assert&lt;/code&gt; 매크로 를 사용하려고합니다 . 이 매크로는 코드를 검사하고 실패가있을 때마다 좋은보고 기능을 제공합니다. 예를 들어 &lt;code&gt;assert some_fun() == 10&lt;/code&gt; 이 실패 한다고 주장합니다 ( &lt;code&gt;some_fun()&lt;/code&gt; 이 &lt;code&gt;13&lt;/code&gt; 을 가정하면 ).</target>
        </trans-unit>
        <trans-unit id="9be20cb8cf2a5e21e25e5b415ec975c67912ed9d" translate="yes" xml:space="preserve">
          <source>In general, doctests are not recommended when your code examples contain side effects. For example, if a doctest prints to standard output, doctest will not try to capture the output.</source>
          <target state="translated">일반적으로 코드 예제에 부작용이 포함 된 경우 doctest는 권장되지 않습니다. 예를 들어 doctest가 표준 출력으로 인쇄되는 경우 doctest는 출력을 캡처하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">일반적으로이 모듈의 기능은 유니 코드 표준에 의존하지만 로케일 특정 동작은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b51681509b0cc1251035f9253bdae711f905e3e" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour. More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 모듈의 함수는 유니 코드 표준에 의존하지만 로케일 특정 동작을 포함하지 않습니다. 문자 소에 대한 자세한 정보는 &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex # 29&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">일반적으로 위의 튜플은 다음 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">일반적으로 키워드 목록이 함수의 마지막 인수 인 경우 대괄호는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="aa567762586986c74d465d0aa8d43a9b014b6cd4" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead.</source>
          <target state="translated">가드에서 함수가 일반적으로 예외를 발생 시키면 가드가 대신 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">가드에서 함수가 일반적으로 예외를 발생 시키면 가드가 대신 실패합니다. 예를 들어 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 함수는 목록에서만 작동합니다. 다른 용도로 사용하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">이러한 관찰에 비추어 우리는 다른 감독 전략으로의 전환을 고려해야합니다. 다른 두 후보는 &lt;code&gt;:one_for_all&lt;/code&gt; 및 &lt;code&gt;:rest_for_one&lt;/code&gt; 입니다. &lt;code&gt;:rest_for_one&lt;/code&gt; 전략을 사용하는 감독자 는 충돌 한 자식 &lt;em&gt;이후&lt;/em&gt; 에 시작된 자식 프로세스를 종료하고 다시 시작 합니다. 이 경우 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 가 종료되면 &lt;code&gt;KV.Registry&lt;/code&gt; 종료 되기를 원합니다 . 이를 위해서는 버킷 관리자가 위의 두 단락을 설정 한 순서 제약 조건을 위반하는 레지스트리 뒤에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="505de6a8a3338b2af34fda74ec05eeff90a625d9" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">매크로 코드에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt; 에 대한 강타 는 &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macro-hygiene&quot;&gt;매크로 위생&lt;/a&gt; 이 제쳐 졌음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">매크로 코드에서 &lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;매크로 위생&lt;/a&gt; 이 따로 설정되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">많은 경우 예상 값을 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; 로 전달 하고 &lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 메시지를 생성하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="b6d866c1d491de63fc794b51b1fe651b6b2cf7a2" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; 에&lt;/a&gt; 예상 값을 전달 하고 &lt;a href=&quot;https://hexdocs.pm/elixir/Exception.html#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 메시지를 생성하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="19dc1fd7cd1d8b39b9ff5dace65dcd36cc88f10b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt;&lt;code&gt;tuple_size/1&lt;/code&gt;&lt;/a&gt; to both check that the given value is a tuple &lt;em&gt;and&lt;/em&gt; check its size (instead of using &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt;).</source>
          <target state="translated">많은 경우에 우리는 이것을 활용할 수 있습니다. 위 코드에서 사용 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#tuple_size/1&quot;&gt; &lt;code&gt;tuple_size/1&lt;/code&gt; &lt;/a&gt; 주어진 값 터플 것을 모두에 체크 &lt;em&gt;하고&lt;/em&gt; (사용하는 대신 그 크기를 확인 &lt;code&gt;is_tuple(something) and tuple_size(something) == 2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">많은 경우에, 우리는 이것을 이용할 수 있습니다. 위의 코드에서 우리는 사용 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 주어진 것은 목록입니다 것을 모두 체크를 &lt;em&gt;하고&lt;/em&gt; (대신 사용하는 길이의 몇 가지 속성을 확인 &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">많은 기능적 프로그래밍 언어에서 키-값 데이터 구조의 표현으로 2- 항목 튜플 목록을 사용하는 것이 일반적입니다. Elixir에서 튜플 목록이 있고 튜플의 첫 번째 항목 (예 : 키)이 원자 인 경우 키워드 목록이라고합니다.</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 이면 충분합니다. 일반적으로 콜백 정보를 위해 모듈을 호출해야하는 매크로와 관련된 경우가 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">캐시 메커니즘이 작동하려면 작성된 ETS 테이블에 access &lt;code&gt;:protected&lt;/code&gt; (기본값)가 있어야하므로 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스 만 테이블에 쓰는 동안 모든 클라이언트가이를 읽을 수 있습니다 . 또한 테이블을 시작할 때 &lt;code&gt;read_concurrency: true&lt;/code&gt; 설정 하여 동시 읽기 작업의 일반적인 시나리오에 맞게 테이블을 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">로드하려면 &lt;code&gt;.app&lt;/code&gt; 파일이로드 경로에 있어야합니다. 모든 &lt;code&gt;:included_applications&lt;/code&gt; 도로드됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">위해 매크로가 작동하는 방법을 더 잘 이해하기 위해, 우리가 구현하려고하는 새 모듈 생성 할 수 &lt;code&gt;unless&lt;/code&gt; 반대 수행하는 &lt;code&gt;if&lt;/code&gt; 매크로로와 함수로를 :</target>
        </trans-unit>
        <trans-unit id="167262643fd2c56cb15474799a3fefbbc20d320a" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">변수를 작성하려면 컨텍스트가 필요합니다. 대부분의 경우 위생을 유지하기 위해 컨텍스트는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">변수를 만들기 위해서는 컨텍스트가 필요합니다. 대부분의 경우, 위생을 유지하려면 컨텍스트가 &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">키-값 애플리케이션을 구축하기 위해 다음 세 가지 주요 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a8e911427746c64d6627a4cd13981382e8cbad5" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">두 개 이상의 절을 비교하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt; 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">두 개 이상의 절을 비교하려면 &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt; 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">Mix를 구성 &lt;code&gt;use&lt;/code&gt; s &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 를 사용 하는 모듈이 &lt;code&gt;project/0&lt;/code&gt; 구성을 나타내는 키워드 목록을 반환하는 project / 0 함수를 내 보내야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">변경 사항을 변경하지 않고 언어를 계속 발전시키기 위해 Elixir는 더 이상 사용되지 않아 특정 관행을 강등하고 새로운 관행을 홍보합니다. Google의 지원 중단 정책은 &lt;a href=&quot;#deprecations&quot;&gt;&quot;사용 중단&quot;섹션에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">개발시 코드 로딩에 대처하기 위해 Elixir의 프로토콜은 개발에 특화된 프로토콜 디스패치의 느린 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">Elixir에서 자체 모듈을 만들기 위해 &lt;code&gt;defmodule&lt;/code&gt; 매크로를 사용합니다 . &lt;code&gt;def&lt;/code&gt; 매크로를 사용하여 해당 모듈에서 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2db428412e028f480fb253824aa4dbe3e8772fd9" translate="yes" xml:space="preserve">
          <source>In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The &lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;Unicode Standard&lt;/a&gt; acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.</source>
          <target state="translated">여러 언어로 컴퓨터 간의 의미있는 통신을 용이하게하려면 한 컴퓨터의 1과 0이 다른 컴퓨터로 전송 될 때 동일한 의미를 갖도록 표준이 필요합니다. &lt;a href=&quot;https://unicode.org/standard/standard.html&quot;&gt;유니 코드 표준은&lt;/a&gt; 우리가 알고있는 거의 모든 문자의 공식 레지스트리의 역할이 고전과 역사 텍스트, 이모티콘, 서식 및 제어 문자뿐 아니라 문자를 포함하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">소프트웨어 재사용을 용이하게하기 위해 Elixir는 3 가지 지시어 ( &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; )와 아래에 요약 된 &lt;code&gt;use&lt;/code&gt; 라는 매크로를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">&lt;code&gt;TestCase&lt;/code&gt; 구현 을 마치 려면 정의 된 모든 테스트 사례에 액세스 할 수 있어야합니다. 이를 수행하는 한 가지 방법은 &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; 를 통해 런타임에 테스트를 검색하여 지정된 모듈의 모든 함수 목록을 리턴하는 것입니다. 그러나 테스트 이름 외에 각 테스트에 대한 추가 정보를 저장하려는 경우보다 유연한 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">실패한 테스트를 해결하기 위해 &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; 에 아래 내용 으로 파일을 생성 해 봅시다 . 아래 구현에서 엿보기 전에 에이전트를 사용하여 &lt;code&gt;KV.Bucket&lt;/code&gt; 모듈을 직접 구현해보십시오 .</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">이 버그를 해결하려면, 생성되는 모든 버킷을 모니터링하는 레지스트리가 필요합니다. 모니터를 설정하면 버킷 프로세스가 종료 될 때마다 레지스트리가 알림을 수신하여 레지스트리를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62bd04dae1b62f0c9a990b148f9408c4a2843b61" translate="yes" xml:space="preserve">
          <source>In order to generate the &lt;code&gt;.app&lt;/code&gt; file, Mix expects your project to have both &lt;code&gt;:app&lt;/code&gt; and &lt;code&gt;:version&lt;/code&gt; keys. Furthermore, you can configure the generated application by defining an &lt;code&gt;application/0&lt;/code&gt; function in your &lt;code&gt;mix.exs&lt;/code&gt; that returns a keyword list.</source>
          <target state="translated">&lt;code&gt;.app&lt;/code&gt; 파일 을 생성하기 위해 Mix는 프로젝트에 &lt;code&gt;:app&lt;/code&gt; 및 &lt;code&gt;:version&lt;/code&gt; 키 가 모두있을 것으로 예상합니다 . 또한 키워드 목록을 반환하는 &lt;code&gt;mix.exs&lt;/code&gt; 에서 &lt;code&gt;application/0&lt;/code&gt; 함수를 정의하여 생성 된 애플리케이션을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">첫 번째 프로젝트를 시작하기 위해 Elixir는 Mix라는 빌드 도구를 제공합니다. 다음을 실행하여 새 프로젝트를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">식이 여러 줄로 구성되어 있음을 IEx가 이해하도록 돕기 위해 식을 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a43dffd10b2bfa3f19eb38d062aa6b636e0e88" translate="yes" xml:space="preserve">
          <source>In order to import configuration, &lt;code&gt;my_app&lt;/code&gt;'s &lt;code&gt;.formatter.exs&lt;/code&gt; would look like this:</source>
          <target state="translated">구성을 가져 오려면 &lt;code&gt;my_app&lt;/code&gt; 의 &lt;code&gt;.formatter.exs&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">위의 콜백을 호출하려면 해당 &lt;code&gt;GenServer&lt;/code&gt; 함수를 거쳐야 합니다. 레지스트리를 시작하고 명명 된 버킷을 만든 다음 찾아 보자.</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">서버가 동시 연결을 처리하도록하려면 요청을 처리하기 위해 다른 프로세스를 생성하는 수락 자로 작동하는 하나의 프로세스가 있어야합니다. 한 가지 해결책은 다음과 같이 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">키워드 목록을 조작하기 위해 Elixir는 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 모듈을 제공 합니다 . 그러나 키워드 목록은 단순한 목록이므로 목록과 동일한 선형 성능 특성을 제공합니다. 목록이 길수록 키를 찾고 항목 수를 계산하는 데 시간이 오래 걸립니다. 이러한 이유로 키워드 목록은 Elixir에서 주로 선택적 값을 전달하는 데 사용됩니다. 많은 항목을 저장하거나 하나의 키 연결을 최대 하나의 값으로 보장해야하는 경우 대신 맵을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">분산 코드를 실행하려면</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">첫 번째 테스트를 실행하려면 두 개의 노드를 실행해야합니다. &lt;code&gt;apps/kv&lt;/code&gt; 로 이동하여 테스트에 사용될 &lt;code&gt;bar&lt;/code&gt; 라는 노드를 다시 시작해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="e8a55d2f768aa9a90c3e47bbc22675a61941f5a4" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called &lt;em&gt;protocol consolidation&lt;/em&gt;. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">모든 구현이 미리 알려진 프로덕션 환경에서 디스패치 속도를 높이기 위해 Elixir는 &lt;em&gt;프로토콜 통합&lt;/em&gt; 이라는 기능을 제공합니다 . 통합은 통합 프로토콜에서 함수를 호출하는 것이 두 개의 원격 함수를 호출하는 것과 동일한 방식으로 프로토콜을 해당 구현에 직접 연결합니다.</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">모든 구현이 사전에 알려진 프로덕션 환경에서 디스패치 속도를 높이기 위해 Elixir는 프로토콜 통합이라는 기능을 제공합니다. 통합은 통합 프로토콜에서 함수를 호출하는 것이 두 개의 원격 함수를 호출하는 것과 같은 방식으로 프로토콜을 구현에 직접 연결합니다.</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">감독자를 시작하려면 먼저 감독 할 자식 프로세스를 정의해야합니다. 예를 들어 스택을 나타내는 GenServer를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0dc599f69280e0654d0ad9b6739bad7864211d7c" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide and learn how to use module attributes as storage to allow developers to create DSLs.</source>
          <target state="translated">기본 코드를 이해하려면 매크로가 필요하므로 메타 프로그래밍 가이드에서이 패턴을 다시 살펴보고 개발자가 DSL을 만들 수 있도록 모듈 속성을 저장소로 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">기본 코드를 이해하려면 매크로가 필요하므로 메타 프로그래밍 가이드에서이 패턴을 다시 살펴 보겠습니다. 그러나 여기서는 스토리지로 모듈 속성을 사용하여 개발자가 DSL을 작성할 수있는 방법에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">종속성을 사용하려면 프로젝트 구성에 &lt;code&gt;:deps&lt;/code&gt; 키를 추가해야 합니다. 우리는 종종 의존성 목록을 자체 기능으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">코드에서 응용 프로그램 환경을 사용하려면 &lt;code&gt;KV.Router.table/0&lt;/code&gt; 을 아래 정의 로 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="0e357d261c32f760a30d8b31568d4778e3817d29" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">파일을 쓰고 읽으려면 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 &lt;code&gt;:binary&lt;/code&gt; 모드로 열리 며, 파일과 상호 작용 하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 함수가 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달할 수 있으며 유니 코드 데이터로 직접 작업하기 때문에 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 의&lt;/a&gt; 다른 모든 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="579dc3768627dbc4d67a1e0757b95afdfeb30685" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">파일을 쓰고 읽으려면 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 바이너리 모드로 열리 며, 파일과 상호 작용 하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 함수가 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달할 수 있습니다 . 그러면 더 느린 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt; 함수는 적절한 변환을 수행하고 적절한 데이터 보장을 제공하기 때문에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">파일을 읽고 읽으려면 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 &lt;code&gt;:binary&lt;/code&gt; 모드로 열리 므로 파일과 상호 작용 하려면 &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 기능이 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달한 다음 유니 코드 데이터와 직접 작동하므로 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 의&lt;/a&gt; 다른 모든 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">파일을 읽고 읽으려면 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 이진 모드로 열리 므로 파일과 상호 작용 하려면 &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 기능이 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달할 수 있으며, 적절한 변환을 수행하고 적절한 데이터 보증을 제공하기 위해 느린 &lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt; 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="545dafe5c1ee7a1449e5b9b98c6c6db53caaf9f3" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">즉, &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; 는 &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">즉, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; 는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">다시 말해, &lt;strong&gt;하지 마십시오&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c7679a9328277147beb719edbd3a5a83c335113c" translate="yes" xml:space="preserve">
          <source>In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (&lt;code&gt;^&lt;/code&gt;):</source>
          <target state="translated">즉, Elixir는 리 바인딩을 지원합니다. 변수 값을 변경하지 않으려면 핀 연산자 ( &lt;code&gt;^&lt;/code&gt; )를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">즉, Elixir는 다른 모든 것을 무시하고 런타임에 사용되는 옵션 만 구문 분석합니다. 존재 여부에 관계없이 모든 스위치를 구문 분석하려면 &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; 를 옵션 으로 전달하여 원자를 강제로 만들 수 있습니다 . 이 옵션은주의해서 사용하십시오. 동적으로 이름이 지정된 인수를 수신하고 장기 실행 시스템에서 피해야하는 명령 행 응용 프로그램을 빌드 할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">다시 말해, 이름에 &quot;size&quot;라는 단어를 사용하는 함수는 데이터 구조가 크든 작든 같은 시간이 걸립니다. 반대로, 이름에 &quot;길이&quot;가있는 함수는 데이터 구조의 크기가 커질수록 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">다시 말해, 애플리케이션 또는 감독 트리가 종료 될 때 프로세스가 자체적으로 정리되어야하는 경우이 프로세스는 종료를 트랩해야하며 해당 하위 스펙은 적절한 &lt;code&gt;:shutdown&lt;/code&gt; 값을 지정하여 적절한 간격 내에 종료되도록해야합니다. .</target>
        </trans-unit>
        <trans-unit id="62c93298d745ed7ef2d4717535ac947d098645b2" translate="yes" xml:space="preserve">
          <source>In other words, if your configuration does something like:</source>
          <target state="translated">즉, 구성이 다음과 같은 작업을 수행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">즉, 일반 Elixir 값 (예 : 목록, 맵, 프로세스, 참조 등)과 인용 된 표현식을 구별하는 것이 중요합니다. 정수, 원자 및 문자열과 같은 일부 값에는 값 자체와 동일한 인용 부호가 있습니다. 지도와 같은 다른 값은 명시 적으로 변환해야합니다. 마지막으로 함수 및 참조와 같은 값은 인용 식으로 전혀 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ea1895411f30c25b0c4e8a493357838af36b14b" translate="yes" xml:space="preserve">
          <source>In other words, patterns are allowed only on the left side of &lt;code&gt;=&lt;/code&gt;. The right side of &lt;code&gt;=&lt;/code&gt; follows the regular evaluation semantics of the language.</source>
          <target state="translated">즉, 패턴은 &lt;code&gt;=&lt;/code&gt; 의 왼쪽에만 허용됩니다 . &lt;code&gt;=&lt;/code&gt; 의 오른쪽 은 언어의 정규 평가 의미를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">즉, atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; 는 코드 포인트 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 로만 작성할 수 있습니다. 다른 정규화 양식을 사용하면 토크 나이저 오류가 발생합니다. 한편, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; 는 인용 부호 사이에 쓰여 있으므로 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 또는 &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; 로 쓰여질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f854e2205df45f6200d8840717b4a209cfb3ea" translate="yes" xml:space="preserve">
          <source>In other words, the environment key &lt;code&gt;:db_host&lt;/code&gt; for application &lt;code&gt;:my_app&lt;/code&gt; will only be read when &lt;code&gt;MyApp.DBClient&lt;/code&gt; effectively starts. While reading the application environment at runtime is the preferred approach, in some rare occasions you may want to use the application environment to configure the compilation of a certain project. This is often done by calling &lt;a href=&quot;#get_env/3&quot;&gt;&lt;code&gt;get_env/3&lt;/code&gt;&lt;/a&gt; outside of a function:</source>
          <target state="translated">즉, 응용 프로그램 &lt;code&gt;:my_app&lt;/code&gt; 에 대한 환경 키 &lt;code&gt;:db_host&lt;/code&gt; 는 &lt;code&gt;MyApp.DBClient&lt;/code&gt; 가 효과적으로 시작될 때만 읽 힙니다 . 런타임에 애플리케이션 환경을 읽는 것이 선호되는 접근 방식이지만 드물게 특정 프로젝트의 컴파일을 구성하기 위해 애플리케이션 환경을 사용할 수 있습니다. 이것은 종종 함수 외부에서 &lt;a href=&quot;#get_env/3&quot;&gt; &lt;code&gt;get_env/3&lt;/code&gt; &lt;/a&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">즉, 위의 표현은 단순히 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="39fc76a1a41dfb78eff4ab58bbe78f4df61a48df" translate="yes" xml:space="preserve">
          <source>In other words, there are multiple ways systems can be deployed and releases can be automated and incorporated into all of them as long as you remember to build the system in the same target triple.</source>
          <target state="translated">즉, 동일한 타겟 트리플에서 시스템을 구축하는 것을 기억하는 한 시스템을 배포하고 릴리스를 자동화하고 모든 시스템에 통합 할 수있는 여러 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">즉,이 함수는 &lt;code&gt;from&lt;/code&gt; 접두사를 &lt;code&gt;path&lt;/code&gt; 에서 제거하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="44dd0ca7035bd0b6e8100243c91751e16aa983c2" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">즉,이 모듈은 일반적으로 외부 소스에서 데이터를 검색 할 때 잘못된 데이터가 다른 곳에서 감지 될 것으로 예상합니다. 예를 들어, 데이터베이스에서 문자열을 읽는 드라이버는 인코딩의 유효성을 확인해야합니다. &lt;a href=&quot;#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt; 는 문자열을 유효하고 유효하지 않은 부분으로 나누는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">즉,이 모듈은 일반적으로 외부 소스에서 데이터를 검색 할 때 유효하지 않은 데이터가 다른 곳에서 감지 될 것으로 예상합니다. 예를 들어, 데이터베이스에서 문자열을 읽는 드라이버는 인코딩의 유효성을 검사해야합니다. &lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt; 는 문자열을 유효하고 유효하지 않은 부분으로 나누는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">즉, 우리는 주어진 각 식 변환 &lt;code&gt;case/2&lt;/code&gt; 하는 단계로 &lt;code&gt;with&lt;/code&gt; . 즉시 단계 중 하나라도 일치하지 않는 것을 돌려로 &lt;code&gt;{:ok, x}&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; 중단한다, 및 반환 일치하지 않는 값입니다.</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">다시 말해 버킷이 충돌하더라도 레지스트리가 계속 실행되기를 원합니다. 새로운 레지스트리 테스트를 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="eae49db7d30fd64b6cfb19732b20c2216ea90d4c" translate="yes" xml:space="preserve">
          <source>In other words, what we would expect to be a single character, such as &lt;code&gt;&amp;eacute;&lt;/code&gt; or &lt;code&gt;ł&lt;/code&gt;, can in practice be multiple characters, each represented by potentially multiple bytes. Consider the following:</source>
          <target state="translated">즉, &lt;code&gt;&amp;eacute;&lt;/code&gt; 또는 &lt;code&gt;ł&lt;/code&gt; 과 같이 단일 문자가 될 것으로 예상되는 것은 실제로 여러 문자가 될 수 있으며 각각은 잠재적으로 여러 바이트로 표시됩니다. 다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">즉, 다음과 같이 호출 될 때</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">다시 말해:</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">특히, 인쇄 가능한 ASCII 문자 만 포함하는 경우 문자 목록은 기본적으로 작은 따옴표로 다시 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">실제로, charlists는 Erlang, 특히 바이너리를 인수로 받아들이지 않는 오래된 라이브러리와 인터페이스 할 때 주로 사용됩니다. &lt;code&gt;to_string/1&lt;/code&gt; 및 &lt;code&gt;to_charlist/1&lt;/code&gt; 함수 를 사용하여 charlist를 문자열로 변환하고 다시 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">그러나 실제로 Elixir 개발자는 &lt;code&gt;try/rescue&lt;/code&gt; 구문을 거의 사용하지 않습니다 . 예를 들어, 많은 언어는 파일을 성공적으로 열 수 없을 때 오류를 구조하도록합니다. Elixir는 대신 파일이 성공적으로 열렸는지에 대한 정보가 포함 된 튜플을 반환 하는 &lt;code&gt;File.read/1&lt;/code&gt; 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">실제로 동적 프로세스를위한 프로세스 레지스트리가 필요한 위치에있는 경우 Elixir의 일부로 제공된 &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야 합니다 . GenServer + &lt;code&gt;:ets&lt;/code&gt; 를 사용하여 구축 한 것과 유사한 기능을 제공 하는 동시에 쓰기와 읽기를 동시에 수행 할 수 있습니다. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;코어가 40 개인 머신에서도 모든 코어에 걸쳐 확장되도록 벤치마킹되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">실제로 서버와 클라이언트 기능을 동일한 모듈에 두는 것이 일반적입니다. 서버 및 / 또는 클라이언트 구현이 복잡해지고있는 경우 다른 모듈로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">실제로, 당신이 Erlang에 도달 할 가능성이 더 높습니다</target>
        </trans-unit>
        <trans-unit id="cafbb493cd44c8e665619ace61e6011a8cdce243" translate="yes" xml:space="preserve">
          <source>In practice, our tools always start our applications for us, but there is an API available if you need fine-grained control.</source>
          <target state="translated">실제로 우리의 도구는 항상 우리를 위해 응용 프로그램을 시작하지만 세분화 된 제어가 필요한 경우 사용할 수있는 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">실제로 버킷으로 작동하는 프로세스가 실패 할 것으로 예상하지 않습니다. 그러나 어떤 이유로 든 시스템이 의도 한대로 계속 작동 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">실제로는 다음과 같이 시작 프로세스의 일부이므로 응용 프로그램을 직접로드하는 경우가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="719d5c0677afb6db6737335d9338844042ab8998" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix-like systems. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">드물지만이 기능은 Unix 계열 시스템에서 실패 할 수 있습니다. 현재 디렉토리의 상위 디렉토리에 대한 읽기 권한이없는 경우 발생할 수 있습니다. 이러한 이유로 성공하면 &lt;code&gt;{:error, reason}&lt;/code&gt; &lt;code&gt;{:ok, cwd}&lt;/code&gt; 를 , 그렇지 않으면 {: error, reason}을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">드문 경우이지만이 기능은 Unix에서 실패 할 수 있습니다. 현재 디렉토리의 상위 디렉토리에 대한 읽기 권한이없는 경우 발생할 수 있습니다. 이러한 이유로 성공하면 &lt;code&gt;{:error, reason}&lt;/code&gt; &lt;code&gt;{:ok, cwd}&lt;/code&gt; 를 , 그렇지 않으면 {: error, reason}을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">집합 표기법 : &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">집합 표기법 : &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">경우에 따라 모든 유형에 기본 구현을 제공하는 것이 편리 할 수 ​​있습니다. 프로토콜 정의에서 &lt;code&gt;@fallback_to_any&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">경우에 따라 목록 안에 많은 값을 삽입해야 할 수도 있습니다. 예를 들어, 포함하는 목록이 상상 &lt;code&gt;[1, 2, 6]&lt;/code&gt; 우리는 주입 할 &lt;code&gt;[3, 4, 5]&lt;/code&gt; 그것으로. &lt;code&gt;unquote&lt;/code&gt; 를 사용 하면 원하는 결과가 나오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">경우에 따라 원하지 않는 서식이 발생할 수 있습니다. 따라서 &lt;strong&gt;포맷터에서 생성 된 일부 코드는 미적으로 만족스럽지 않으며 개발자의 명시 적 개입이 필요할 수 있습니다&lt;/strong&gt; . 따라서 기존 코드베이스에서 포맷터를 맹목적으로 실행하지 않는 것이 좋습니다. 대신 형식이 지정된 각 파일을 형식화하고 완전성 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">경우에 따라 패턴의 특정 값에 신경 쓰지 않습니다. 이러한 값을 밑줄 &lt;code&gt;_&lt;/code&gt; 에 바인딩하는 것이 일반적 입니다. 예를 들어,리스트의 헤드 만 중요하다면 테일을 밑줄에 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">경우에 따라 이러한 &lt;em&gt;값&lt;/em&gt; 을 &lt;em&gt;따옴표&lt;/em&gt; 로 &lt;em&gt;묶어야&lt;/em&gt; 할 수도 있습니다 . 그러기 위해서는 먼저 &lt;code&gt;Macro.escape/1&lt;/code&gt; 의 도움으로 해당 값을 따옴표로 묶어 표현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">경우에 따라 호출자에 정의 된 별명 또는 모듈에 액세스하려고합니다. 이를 위해 &lt;code&gt;alias!&lt;/code&gt; 사용할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">경우에 따라 포맷터가 리팩토링을위한 힌트로 우아한 코드를 생성하지 않는다는 사실을 사용할 수 있습니다. 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 개발자는 대신 모듈을 직접 가져 오거나 별명을 지정하여 &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; 의 간접적 인 지시없이 원하는대로 원하는대로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="459d38c03bf669f90bbbe671db50188607d62696" translate="yes" xml:space="preserve">
          <source>In such cases, using the capture operator is no different than using &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">이러한 경우 캡처 연산자를 사용하는 것은 &lt;code&gt;fn&lt;/code&gt; 을 사용하는 것과 다르지 않습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
