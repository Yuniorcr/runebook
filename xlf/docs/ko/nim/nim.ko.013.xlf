<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="01727ad8d0bbaeeea62faa6f12c71312bf1ae451" translate="yes" xml:space="preserve">
          <source>Nim has these floating point types built-in: &lt;code&gt;float float32 float64&lt;/code&gt;.</source>
          <target state="translated">Nim에는 다음 부동 소수점 유형이 내장되어 있습니다. &lt;code&gt;float float32 float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3deb8348e9e32056d74290a50d876e63851d29" translate="yes" xml:space="preserve">
          <source>Nim has these integer types built-in: &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt;.</source>
          <target state="translated">Nim에는 다음 정수 유형이 내장되어 있습니다. &lt;code&gt;int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54c4f95676cbff4f6b732c078d876ae2ad27f446" translate="yes" xml:space="preserve">
          <source>Nim has two flavors of parallelism:</source>
          <target state="translated">Nim에는 두 가지 병렬 처리 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc5bf296e3c41484c147bfc3cd569c0d2a605bfb" translate="yes" xml:space="preserve">
          <source>Nim idetools integration</source>
          <target state="translated">Nim idetools 통합</target>
        </trans-unit>
        <trans-unit id="fde430a55fc171aea53e7cacfbb81ff6931bd1b5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from C</source>
          <target state="translated">C의 Nim 호출 예제</target>
        </trans-unit>
        <trans-unit id="a9b0c283f30ebbd8bbc505d567707e20b58f9be5" translate="yes" xml:space="preserve">
          <source>Nim invocation example from JavaScript</source>
          <target state="translated">JavaScript의 Nim 호출 예제</target>
        </trans-unit>
        <trans-unit id="bdd28046b42c51d6419a24b949f2e431ad33feda" translate="yes" xml:space="preserve">
          <source>Nim is free software; it is licensed under the &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT License&lt;/a&gt;.</source>
          <target state="translated">님은 자유 소프트웨어입니다. &lt;a href=&quot;http://www.opensource.org/licenses/mit-license.php&quot;&gt;MIT 라이센스에&lt;/a&gt; 따라 라이센스가 부여됩니다 .</target>
        </trans-unit>
        <trans-unit id="92c7393409ca98f35a585605ecd27b0ce04bc6dc" translate="yes" xml:space="preserve">
          <source>Nim lock, re-entrant</source>
          <target state="translated">님 잠금, 재진입</target>
        </trans-unit>
        <trans-unit id="af2f77b6798efd1fe7af2c6d48238ea2e59af4d3" translate="yes" xml:space="preserve">
          <source>Nim lock; whether this is re-entrant or not is unspecified!</source>
          <target state="translated">님 잠금; 재진입 여부는 불특정입니다!</target>
        </trans-unit>
        <trans-unit id="396c55174c1748ab5bec4b1cb866abf79d300e48" translate="yes" xml:space="preserve">
          <source>Nim maintenance script</source>
          <target state="translated">님 유지 보수 스크립트</target>
        </trans-unit>
        <trans-unit id="200b4437aaf50df9807fc02a8b32574618effddb" translate="yes" xml:space="preserve">
          <source>Nim offers a special family of dot operators that can be used to intercept and rewrite proc call and field access attempts, referring to previously undeclared symbol names. They can be used to provide a fluent interface to objects lying outside the static confines of the type system such as values from dynamic scripting languages or dynamic file formats such as JSON or XML.</source>
          <target state="translated">Nim은 이전에 선언되지 않은 기호 이름을 참조하여 프로세스 호출 및 필드 액세스 시도를 가로 채서 다시 쓰는 데 사용할 수있는 특수 도트 연산자 제품군을 제공합니다. 동적 스크립팅 언어의 값 또는 JSON 또는 XML과 같은 동적 파일 형식과 같은 유형 시스템의 정적 경계 외부에있는 객체에 유창한 인터페이스를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e6a58d0659f4167e32702de63a078a70b84e7d" translate="yes" xml:space="preserve">
          <source>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</source>
          <target state="translated">Nim은 대상 백엔드와 양방향 인터페이스를 제공합니다. 즉, Nim에서 백엔드 코드를 호출 할 수 있으며 백엔드 코드로 Nim 코드를 호출 할 수 있습니다. 일반적으로 소프트웨어 아키텍처에 따라 어떤 호출 방향 (Nim이 기본 프로그램입니까 아니면 Nim이 구성 요소를 제공하고 있습니까?)</target>
        </trans-unit>
        <trans-unit id="893f066137f8187ed8a07f2272b19d0871bbc768" translate="yes" xml:space="preserve">
          <source>Nim produces a warning for symbols that are not exported and not used either. The &lt;code&gt;used&lt;/code&gt; pragma can be attached to a symbol to suppress this warning. This is particularly useful when the symbol was generated by a macro:</source>
          <target state="translated">Nim은 내 보내지 않고 사용되지 않은 기호에 대해 경고를 생성합니다. &lt;code&gt;used&lt;/code&gt; 프라 그마는이 경고를 억제하는 기호에 부착 될 수있다. 이는 매크로가 심볼을 생성 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6150bb7b7dad74d65ce46c3a55145c510735a725" translate="yes" xml:space="preserve">
          <source>Nim provides language integration with external IDEs through the idetools command. See the documentation of &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; for further information.</source>
          <target state="translated">Nim은 idetools 명령을 통해 외부 IDE와의 언어 통합을 제공합니다. 자세한 내용은 &lt;a href=&quot;idetools&quot;&gt;idetools&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6864a9277154b157b94a761e493fbd79ef8b809c" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; and &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; commands to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;docgen&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim은 &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; 및 &lt;span id=&quot;doc2_1&quot;&gt;doc2&lt;/span&gt; 명령을 제공하여 &lt;code&gt;.nim&lt;/code&gt; 소스 파일 에서 HTML 문서를 생성 합니다. 내 보낸 심볼 만 출력에 나타납니다. 자세한 내용 &lt;a href=&quot;docgen&quot;&gt;은 docgen 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7008b8e9d9cc2fbb71ad07b4590df2b146b1ff" translate="yes" xml:space="preserve">
          <source>Nim provides the &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; command to generate HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files. Only exported symbols will appear in the output. For more details &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;see the docgen documentation&lt;/a&gt;.</source>
          <target state="translated">Nim은 &lt;code&gt;.nim&lt;/code&gt; 소스 파일 에서 HTML 문서를 생성 하는 &lt;span id=&quot;doc_1&quot;&gt;doc&lt;/span&gt; 명령을 제공 합니다. 내 보낸 기호 만 출력에 나타납니다. 자세한 내용 &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;은 docgen 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d0f9e0827a8dbea31dc2fbe4ce37db63cfa840c" translate="yes" xml:space="preserve">
          <source>Nim provides the ability to overload procedures similar to C++:</source>
          <target state="translated">Nim은 C ++과 유사한 프로 시저를 오버로드하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="082cc471f7e487d0e261d56375fe2f285b9ead9d" translate="yes" xml:space="preserve">
          <source>Nim provides the pragmas &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; and &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; to control whether the IEEE exceptions are ignored or trap a Nim exception:</source>
          <target state="translated">Nim은 pragma &lt;span id=&quot;nanchecks_1&quot;&gt;nanChecks&lt;/span&gt; 및 &lt;span id=&quot;infchecks_1&quot;&gt;infChecks&lt;/span&gt; 를 제공하여 IEEE 예외가 무시되는지 또는 Nim 예외를 트랩할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="508417c4e97e2bf7456d14ecac591b4f6356c08f" translate="yes" xml:space="preserve">
          <source>Nim runs on a wide variety of platforms. Support on amd64 and i386 is tested regularly, while less popular platforms are tested by the community.</source>
          <target state="translated">Nim은 다양한 플랫폼에서 실행됩니다. amd64 및 i386에 대한 지원은 정기적으로 테스트되며 덜 인기있는 플랫폼은 커뮤니티에서 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="86a99b555e8d5a547fbd7a8b6c3c5be83dc59b13" translate="yes" xml:space="preserve">
          <source>Nim search and replace utility.</source>
          <target state="translated">Nim 검색 및 교체 유틸리티.</target>
        </trans-unit>
        <trans-unit id="cea72c6813825983207ed89ef6d7563250a6be64" translate="yes" xml:space="preserve">
          <source>Nim significantly improves on the safety of these features via additional pragmas:</source>
          <target state="translated">Nim은 추가 pragma를 통해 이러한 기능의 안전성을 크게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="13adb76d4a44fc6d0ed9557643b94613f8b29151" translate="yes" xml:space="preserve">
          <source>Nim support for &lt;span id=&quot;substitution-expressions_1&quot;&gt;substitution expressions&lt;/span&gt; (&lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt;).</source>
          <target state="translated">&lt;span id=&quot;substitution-expressions_1&quot;&gt;대체 표현식에&lt;/span&gt; 대한 Nim 지원 ( &lt;span id=&quot;subex_1&quot;&gt;subex&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="f308ae3443ec85df73ede4f78102be2e349b672c" translate="yes" xml:space="preserve">
          <source>Nim supports exception tracking. The &lt;span id=&quot;raises_1&quot;&gt;raises&lt;/span&gt; pragma can be used to explicitly define which exceptions a proc/iterator/method/converter is allowed to raise. The compiler verifies this:</source>
          <target state="translated">Nim은 예외 추적을 지원합니다. 이 &lt;span id=&quot;raises_1&quot;&gt;제기&lt;/span&gt; 프라그 명시 적 PROC / 반복기 / 방법 / 컨버터 올리 허용되는 예외를 정의하는데 사용될 수있다. 컴파일러는 이것을 검증합니다 :</target>
        </trans-unit>
        <trans-unit id="3f7af30571e6dd9a4e1318813044e95e94a257fb" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces by a module concept. Each module needs to be in its own file and has its own &lt;span id=&quot;namespace_1&quot;&gt;namespace&lt;/span&gt;. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to symbols of another module by the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;Recursive module dependencies&lt;/span&gt; are allowed, but slightly subtle. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported. A valid module name can only be a valid Nim identifier (and thus its filename is &lt;code&gt;identifier.nim&lt;/code&gt;).</source>
          <target state="translated">Nim은 모듈 개념으로 프로그램을 조각으로 분할하는 것을 지원합니다. 각 모듈은 자체 파일에 있어야하며 자체 &lt;span id=&quot;namespace_1&quot;&gt;네임 스페이스가&lt;/span&gt; 있습니다. 모듈은 &lt;span id=&quot;information-hiding_1&quot;&gt;정보 숨기기&lt;/span&gt; 및 &lt;span id=&quot;separate-compilation_1&quot;&gt;별도의 컴파일을&lt;/span&gt; 가능하게 &lt;span id=&quot;information-hiding_1&quot;&gt;합니다&lt;/span&gt; . 모듈은 &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; 문 을 통해 다른 모듈의 심볼에 액세스 할 수 있습니다 . &lt;span id=&quot;recursive-module-dependencies_1&quot;&gt;재귀 모듈 종속성&lt;/span&gt; 은 허용되지만 약간 미묘합니다. 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 표시된 최상위 심볼 만 내 보냅니다. 유효한 모듈 이름은 유효한 Nim 식별자 만 가능하므로 파일 이름은 &lt;code&gt;identifier.nim&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e44eef4a789fd3c119666d4ed23cb9494cb3bbf7" translate="yes" xml:space="preserve">
          <source>Nim supports splitting a program into pieces with a module concept. Each module is in its own file. Modules enable &lt;span id=&quot;information-hiding_1&quot;&gt;information hiding&lt;/span&gt; and &lt;span id=&quot;separate-compilation_1&quot;&gt;separate compilation&lt;/span&gt;. A module may gain access to the symbols of another module by using the &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; statement. Only top-level symbols that are marked with an asterisk (&lt;code&gt;*&lt;/code&gt;) are exported:</source>
          <target state="translated">Nim은 모듈 개념으로 프로그램을 조각으로 분할하는 것을 지원합니다. 각 모듈은 자체 파일에 있습니다. 모듈은 &lt;span id=&quot;information-hiding_1&quot;&gt;정보 숨기기&lt;/span&gt; 및 &lt;span id=&quot;separate-compilation_1&quot;&gt;별도의 컴파일을&lt;/span&gt; 가능하게 &lt;span id=&quot;information-hiding_1&quot;&gt;합니다&lt;/span&gt; . 모듈은 &lt;span id=&quot;import_1&quot;&gt;import&lt;/span&gt; 문 을 사용하여 다른 모듈의 심볼에 액세스 할 수 있습니다 . 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 표시된 최상위 심볼 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="46fdd12ce5e87d8ce22525d0fc7e670179c0d9e1" translate="yes" xml:space="preserve">
          <source>Nim supports the generation of DLLs. However, there must be only one instance of the GC per process/address space. This instance is contained in &lt;code&gt;nimrtl.dll&lt;/code&gt;. This means that every generated Nim DLL depends on &lt;code&gt;nimrtl.dll&lt;/code&gt;. To generate the &quot;nimrtl.dll&quot; file, use the command:</source>
          <target state="translated">Nim은 DLL 생성을 지원합니다. 그러나 프로세스 / 주소 공간 당 GC 인스턴스는 하나만 있어야합니다. 이 인스턴스는 &lt;code&gt;nimrtl.dll&lt;/code&gt; 에 포함되어 있습니다 . 이것은 생성 된 모든 Nim DLL이 &lt;code&gt;nimrtl.dll&lt;/code&gt; 에 의존한다는 것을 의미합니다 . &quot;nimrtl.dll&quot;파일을 생성하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9716569bd8c70a883cc816b4d661c7ea0ac3b2d4" translate="yes" xml:space="preserve">
          <source>Nim supports these &lt;span id=&quot;calling-conventions_1&quot;&gt;calling conventions&lt;/span&gt;:</source>
          <target state="translated">Nim은 다음과 같은 &lt;span id=&quot;calling-conventions_1&quot;&gt;호출 규칙을&lt;/span&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="abcf9d9cfc4c5456a80f226fb54d7c37497efa51" translate="yes" xml:space="preserve">
          <source>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Nim은 널리 사용되는 모든 브라우저에서 지원되는 JavaScript 1.5를 대상으로합니다. JavaScript에는 다른 모듈을 포함 할 수있는 이식 가능한 수단이 없으므로 Nim은 긴 &lt;code&gt;.js&lt;/code&gt; 파일 만 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d6334ba658939fb66c6d2eb5152d5c5e1ed6cc5c" translate="yes" xml:space="preserve">
          <source>Nim type</source>
          <target state="translated">님 타입</target>
        </trans-unit>
        <trans-unit id="12a335b577d343cb196e9cbe8abf689f02aa0bd4" translate="yes" xml:space="preserve">
          <source>Nim uses structural type equivalence for most types. Only for objects, enumerations and distinct types name equivalence is used. The following algorithm, &lt;em&gt;in pseudo-code&lt;/em&gt;, determines type equality:</source>
          <target state="translated">Nim은 대부분의 유형에 구조적 유형 동등성을 사용합니다. 객체, 열거 및 구별 유형 이름 동등성에 대해서만 사용됩니다. &lt;em&gt;pseudo-code&lt;/em&gt; 의 다음 알고리즘 &lt;em&gt;은&lt;/em&gt; 유형 평등을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1870e8d051fa7bd2733b9612e24fa28e4e1bd585" translate="yes" xml:space="preserve">
          <source>Nim uses the classic compiler architecture: A lexer/scanner feds tokens to a parser. The parser builds a syntax tree that is used by the code generator. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</source>
          <target state="translated">Nim은 클래식 컴파일러 아키텍처를 사용합니다. lexer / scanner는 토큰을 파서에 공급합니다. 파서는 코드 생성기에서 사용하는 구문 트리를 작성합니다. 이 구문 트리는 파서와 코드 생성기 간의 인터페이스입니다. 대부분의 컴파일러 코드를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="322b8b83d95b2969c2c0f758d4cccd2596086dda" translate="yes" xml:space="preserve">
          <source>Nim uses the common statement/expression paradigm: Statements do not produce a value in contrast to expressions. However, some expressions are statements.</source>
          <target state="translated">Nim은 일반적인 문장 / 표현 패러다임을 사용합니다. 문장은 표현식과 달리 값을 생성하지 않습니다. 그러나 일부 표현은 진술입니다.</target>
        </trans-unit>
        <trans-unit id="89ee9afb771e64a1e7ce2a930130a658c6ca2c85" translate="yes" xml:space="preserve">
          <source>Nim versions before 0.20 used the wrong spelling (&quot;demon&quot;). Now &lt;code&gt;ProcessOption&lt;/code&gt; uses the correct spelling (&quot;daemon&quot;), and this is needed just for backward compatibility.</source>
          <target state="translated">0.20 이전의 Nim 버전은 잘못된 철자를 사용했습니다 ( &quot;demon&quot;). 이제 &lt;code&gt;ProcessOption&lt;/code&gt; 은 올바른 철자 ( &quot;데몬&quot;)를 사용하며 이는 이전 버전과의 호환성을 위해서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16bf12211c3e06c6eb9e50a3ff54ca759ba185c1" translate="yes" xml:space="preserve">
          <source>Nim&amp;#x27;s Garbage Collector</source>
          <target state="translated">님의 가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="9e747b8df254ba8adeea93bf65d5d26fc1f7c029" translate="yes" xml:space="preserve">
          <source>Nim's &lt;code&gt;import&lt;/code&gt; statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</source>
          <target state="translated">Nim의 &lt;code&gt;import&lt;/code&gt; 문은 실제로 어떤 키워드가 있는지에 따라 다르게 변형됩니다. 가장 간단한 양식부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="576ef403ca389194e42a3457f0afbf3573e97c72" translate="yes" xml:space="preserve">
          <source>Nim's &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface) is extensive and only the parts that scale to other future backends (like the LLVM/JavaScript backends) are documented here.</source>
          <target state="translated">Nim의 &lt;span id=&quot;ffi_1&quot;&gt;FFI&lt;/span&gt; (foreign function interface)는 광범위하며 다른 미래 백엔드 (LLVM / JavaScript 백엔드와 같은)로 확장되는 부분 만 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0001d3798571e3724667eff0ac34ad8cc342d30f" translate="yes" xml:space="preserve">
          <source>Nim's FFI (foreign function interface) is not available in NimScript. This means that any stdlib module which relies on &lt;code&gt;importc&lt;/code&gt; can not be used in the VM.</source>
          <target state="translated">Nim의 FFI (외부 함수 인터페이스)는 NimScript에서 사용할 수 없습니다. 즉, &lt;code&gt;importc&lt;/code&gt; 에 의존하는 stdlib 모듈 은 VM에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3a2a3b0146362c9c774e923c0df1b46db23ed52" translate="yes" xml:space="preserve">
          <source>Nim's Garbage Collector</source>
          <target state="translated">님의 가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="9c63ed798cb14ea75cd44449159244ef1e6fa151" translate="yes" xml:space="preserve">
          <source>Nim's Memory Management</source>
          <target state="translated">님의 메모리 관리</target>
        </trans-unit>
        <trans-unit id="a41682260d59280a2b3b6483204da1644fe3e4a8" translate="yes" xml:space="preserve">
          <source>Nim's boolean type is called &lt;code&gt;bool&lt;/code&gt; and consists of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in while, if, elif, and when statements must be of type bool.</source>
          <target state="translated">님의 부울 유형이라고 &lt;code&gt;bool&lt;/code&gt; 두 미리 정의 된 값으로 구성 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; . while, if, elif 및 when 문의 조건은 bool 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f9bb646d70cb0b289c9556100113fa715dd573b" translate="yes" xml:space="preserve">
          <source>Nim's library is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt;, and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="translated">Nim의 라이브러리는 &lt;em&gt;순수 라이브러리&lt;/em&gt; , &lt;em&gt;불순 라이브러리&lt;/em&gt; 및 &lt;em&gt;래퍼&lt;/em&gt; 로 나뉩니다 .</target>
        </trans-unit>
        <trans-unit id="13ee675d367062e6a639dae94168d9a9c1a41f44" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different from other common programming languages (C, Pascal): Each thread has its own (garbage collected) heap and sharing of memory is restricted. This helps to prevent race conditions and improves efficiency. See &lt;a href=&quot;manual#threads&quot;&gt;the manual for details of this memory model&lt;/a&gt;.</source>
          <target state="translated">스레드에 대한 Nim의 메모리 모델은 다른 일반적인 프로그래밍 언어 (C, Pascal)와는 매우 다릅니다. 각 스레드에는 자체 (가비지 수집) 힙이 있으며 메모리 공유가 제한됩니다. 이것은 경쟁 조건을 예방하고 효율성을 향상시킵니다. &lt;a href=&quot;manual#threads&quot;&gt;이 메모리 모델에 대한 자세한&lt;/a&gt; 내용 은 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e98391c7155144865c0c684166fb6f91c4167fcb" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference. Memory allocation requires no lock at all! This design easily scales to massive multicore processors that are becoming the norm.</source>
          <target state="translated">스레드에 대한 Nim의 메모리 모델은 다른 일반적인 프로그래밍 언어 (C, Pascal, Java)의 메모리 모델과는 상당히 다릅니다. 각 스레드에는 자체 (가비지 수집) 힙이 있으며 메모리 공유는 전역 변수로 제한됩니다. 이것은 경쟁 조건을 방지하는 데 도움이됩니다. GC는 다른 스레드를 중지하고 참조하는 것을 볼 필요가 없기 때문에 GC 효율성이 상당히 향상되었습니다. 메모리 할당에는 전혀 잠금이 필요하지 않습니다! 이 디자인은 표준이되는 대규모 멀티 코어 프로세서로 쉽게 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e16beba5be23dbf120604d9eac2a0b9733124873" translate="yes" xml:space="preserve">
          <source>Nim's memory model for threads is quite different than that of other common programming languages (C, Pascal, Java): Each thread has its own (garbage collected) heap, and sharing of memory is restricted to global variables. This helps to prevent race conditions. GC efficiency is improved quite a lot, because the GC never has to stop other threads and see what they reference.</source>
          <target state="translated">스레드에 대한 Nim의 메모리 모델은 다른 일반적인 프로그래밍 언어 (C, Pascal, Java)와는 상당히 다릅니다. 각 스레드에는 자체 (가비지 수집) 힙이 있으며 메모리 공유는 전역 변수로 제한됩니다. 이것은 경쟁 조건을 방지하는 데 도움이됩니다. GC가 다른 스레드를 중지하고 참조하는 내용을 볼 필요가 없기 때문에 GC 효율성이 상당히 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="9bd526290438cb61dffae2d2e60576f140904aaf" translate="yes" xml:space="preserve">
          <source>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</source>
          <target state="translated">님의 객체 구문은 풍부합니다. 복잡성의 일부를보기 위해 전체적으로 관련된 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d1938981c78468bfa1d2da1e306dcbcb6376cdd" translate="yes" xml:space="preserve">
          <source>Nim's parser</source>
          <target state="translated">님의 파서</target>
        </trans-unit>
        <trans-unit id="acf2817c0d9f0b146da2d625488e15fe41115e79" translate="yes" xml:space="preserve">
          <source>Nim's standard grammar describes an &lt;span id=&quot;indentation-sensitive_1&quot;&gt;indentation sensitive&lt;/span&gt; language. This means that all the control structures are recognized by indentation. Indentation consists only of spaces; tabulators are not allowed.</source>
          <target state="translated">님의 표준 문법은 &lt;span id=&quot;indentation-sensitive_1&quot;&gt;들여 쓰기에 민감한&lt;/span&gt; 언어를 설명합니다 . 이는 모든 제어 구조가 들여 쓰기로 인식됨을 의미합니다. 들여 쓰기는 공백으로 만 구성됩니다. tabulators는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb3af97ac3591e9d4487efae331e1cc3fe9eed9d" translate="yes" xml:space="preserve">
          <source>Nim's standard library only covers the basics, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; for a list of 3rd party packages.</source>
          <target state="translated">Nim의 표준 라이브러리는 기본 사항 만 다룹니다 . 타사 패키지 목록은 &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; 에서 확인 하세요 .</target>
        </trans-unit>
        <trans-unit id="77393f218a5f26531de32e76d9d12df341c291fa" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator.</source>
          <target state="translated">Nim의 표준 난수 생성기.</target>
        </trans-unit>
        <trans-unit id="1452a3d3fd11615a428ccdddc1e755ffef521766" translate="yes" xml:space="preserve">
          <source>Nim's standard random number generator. Based on the &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor/rotate/shift/rotate) library.</source>
          <target state="translated">님의 표준 난수 생성기. &lt;code&gt;xoroshiro128+&lt;/code&gt; (xor / rotate / shift / rotate) 라이브러리를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="e87220288cb1bb4d3284ac229d8e724411f9156a" translate="yes" xml:space="preserve">
          <source>NimCompilerApiVersion:</source>
          <target state="translated">NimCompilerApiVersion:</target>
        </trans-unit>
        <trans-unit id="035abfdda9b03c8237ac0a7feb0ced2c808a87c6" translate="yes" xml:space="preserve">
          <source>NimExt:</source>
          <target state="translated">NimExt:</target>
        </trans-unit>
        <trans-unit id="25a35361f773f4c4dde724d3ece4cf111ba2929b" translate="yes" xml:space="preserve">
          <source>NimProg:</source>
          <target state="translated">NimProg:</target>
        </trans-unit>
        <trans-unit id="8ab4b86e0c9b72c06707898687dc558effda2630" translate="yes" xml:space="preserve">
          <source>NimScript</source>
          <target state="translated">NimScript</target>
        </trans-unit>
        <trans-unit id="1060f5fe59141088954b97650581009ff437f63d" translate="yes" xml:space="preserve">
          <source>NimScript as a build tool</source>
          <target state="translated">빌드 도구로서의 NimScript</target>
        </trans-unit>
        <trans-unit id="7fe85fa4503fd856c0b2c5b8e006bfb56700547e" translate="yes" xml:space="preserve">
          <source>NimScript as a configuration file</source>
          <target state="translated">구성 파일로서의 NimScript</target>
        </trans-unit>
        <trans-unit id="56fb69363bbec3d3e7f963ac64cc9108bb1eb062" translate="yes" xml:space="preserve">
          <source>NimScript can also be used directly as a portable replacement for Bash and Batch files. Use &lt;code&gt;nim myscript.nims&lt;/code&gt; to run &lt;code&gt;myscript.nims&lt;/code&gt;. For example, installation of Nimble could be accomplished with this simple script:</source>
          <target state="translated">NimScript는 Bash 및 Batch 파일의 휴대용 대체품으로 직접 사용할 수도 있습니다. 사용 &lt;code&gt;nim myscript.nims&lt;/code&gt; 실행 &lt;code&gt;myscript.nims&lt;/code&gt; 을 . 예를 들어 다음과 같은 간단한 스크립트를 사용하여 Nimble을 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad8119aecbfac41940b08449972bffe26657feb9" translate="yes" xml:space="preserve">
          <source>NimScript can detect on which platform, operating system, architecture, and even which Linux distribution is running on, allowing the same script to support a lot of systems.</source>
          <target state="translated">NimScript는 플랫폼, 운영 체제, 아키텍처 및 Linux 배포판이 실행중인 것을 감지하여 동일한 스크립트가 많은 시스템을 지원할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="81f85d9adec2a4efa1b9102c81dbf387a3fb5e9d" translate="yes" xml:space="preserve">
          <source>NimScript can use Nim's templates, macros, types, concepts, effect tracking system, and more, you can create modules that work on compiled Nim and also on interpreted NimScript.</source>
          <target state="translated">NimScript는 Nim의 템플릿, 매크로, 유형, 개념, 효과 추적 시스템 등을 사용할 수 있으며 컴파일 된 Nim 및 해석 된 NimScript에서 작동하는 모듈을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c0d9ddce680baee1ba932a503b5444c9efc6dfe" translate="yes" xml:space="preserve">
          <source>NimScript evolves together with Nim, &lt;a href=&quot;https://github.com/nim-lang/Nim/pulls?utf8=%E2%9C%93&amp;amp;q=nimscript&quot;&gt;occasionally new features might become available on NimScript&lt;/a&gt; , adapted from compiled Nim or added as new features on both.</source>
          <target state="translated">NimScript는 Nim과 함께 발전합니다. &lt;a href=&quot;https://github.com/nim-lang/Nim/pulls?utf8=%E2%9C%93&amp;amp;q=nimscript&quot;&gt;때때로 새로운 기능이 NimScript&lt;/a&gt; 에서 사용 가능 하거나 컴파일 된 Nim에서 조정되거나 둘 다에 새로운 기능으로 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="402bcf2eebcea027b3675344e83beef6d49421ab" translate="yes" xml:space="preserve">
          <source>NimScript is subject to some limitations caused by the implementation of the VM (virtual machine):</source>
          <target state="translated">NimScript에는 VM (가상 머신) 구현으로 인해 발생하는 몇 가지 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0aa0a28931e2602b2a448ffe81a4e242e7826335" translate="yes" xml:space="preserve">
          <source>NimScripts also support &lt;code&gt;--&lt;/code&gt; templates for convenience, which look like command-line switches written as-is in the NimScript file. So the above example can be rewritten as:</source>
          <target state="translated">NimScripts도 지원 &lt;code&gt;--&lt;/code&gt; NimScript 파일에 그대로 기록 된 명령 줄 스위치처럼 편의를 위해 템플릿을. 따라서 위의 예는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6b14412133ed2489b730e9fc4f06291eb4e8ce" translate="yes" xml:space="preserve">
          <source>Nimble</source>
          <target state="translated">Nimble</target>
        </trans-unit>
        <trans-unit id="26c03ddba53d901b234feb6fb87a68295b59cd08" translate="yes" xml:space="preserve">
          <source>Nimble integration</source>
          <target state="translated">민첩한 통합</target>
        </trans-unit>
        <trans-unit id="5e3bca65182fa05bd8858bec9a6e6900f87e2adf" translate="yes" xml:space="preserve">
          <source>Nimble is a package manager for the Nim programming language. For instructions on how to install Nimble packages see &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;its README&lt;/a&gt;.</source>
          <target state="translated">Nimble은 Nim 프로그래밍 언어의 패키지 관리자입니다. Nimble 패키지 설치 방법에 대한 지침은 &lt;a href=&quot;https://github.com/nim-lang/nimble#readme&quot;&gt;해당 README를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5013a2b58d23844e1296b43b0dea97d39a7cb11" translate="yes" xml:space="preserve">
          <source>Nimble metadata.</source>
          <target state="translated">민첩한 메타 데이터.</target>
        </trans-unit>
        <trans-unit id="0b2ec20dbc771a65435e830fecd7f56d930e7e15" translate="yes" xml:space="preserve">
          <source>Nimble support: Call this to set the list of requirements of your Nimble package.</source>
          <target state="translated">Nimble 지원 : Nimble 패키지의 요구 사항 목록을 설정하려면 이것을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b9b2694a8c57bd7aa2c631729dbba47d2a27cc62" translate="yes" xml:space="preserve">
          <source>Nimble support: Set this to the package name. It is usually not required to do that, nims' filename is the default.</source>
          <target state="translated">Nimble 지원 : 이것을 패키지 이름으로 설정합니다. 일반적으로 그렇게 할 필요는 없으며 nims의 파일 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fed05e42072d36de3ae6f98f3a205cb1e71d91ba" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's author.</source>
          <target state="translated">민첩한 지원 : 패키지 작성자.</target>
        </trans-unit>
        <trans-unit id="f0d931b828c900211ecdbb0924f07616c6d6f1c2" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's backend.</source>
          <target state="translated">민첩한 지원 : 패키지의 백엔드.</target>
        </trans-unit>
        <trans-unit id="67d6064cefa030bc1c619c0d11551a8571e5d1cc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's binary directory.</source>
          <target state="translated">Nimble 지원 : 패키지의 바이너리 디렉토리.</target>
        </trans-unit>
        <trans-unit id="03d30b4bc6cc39b452f5dc2c3f197ab1449217fe" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's description.</source>
          <target state="translated">민첩한 지원 : 패키지의 설명입니다.</target>
        </trans-unit>
        <trans-unit id="513e69b6157a08403fb5d2ef1ef15bb2da0988fc" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's license.</source>
          <target state="translated">민첩한 지원 : 패키지의 라이선스.</target>
        </trans-unit>
        <trans-unit id="f72740a9f91b96fbde6c9a0fcaa67f6da285a52a" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's source directory.</source>
          <target state="translated">Nimble 지원 : 패키지의 소스 디렉토리.</target>
        </trans-unit>
        <trans-unit id="8a3cd36df69ddf669e773a85de7a62c85b77a507" translate="yes" xml:space="preserve">
          <source>Nimble support: The package's version.</source>
          <target state="translated">민첩한 지원 : 패키지 버전.</target>
        </trans-unit>
        <trans-unit id="5af01d1d4ff2ceea4a8135b93a3b16c4bb879507" translate="yes" xml:space="preserve">
          <source>Nimcache and C like targets</source>
          <target state="translated">Nimcache 및 C 유사 대상</target>
        </trans-unit>
        <trans-unit id="d63113aa6032c199ac973f9c41b92f6b86bc69c5" translate="yes" xml:space="preserve">
          <source>Nimcache and the Javascript target</source>
          <target state="translated">Nimcache와 자바 스크립트 대상</target>
        </trans-unit>
        <trans-unit id="7a7b1200d84cdfcc90e4068e405d16fe626da360" translate="yes" xml:space="preserve">
          <source>Nimcache naming logic</source>
          <target state="translated">Nimcache 이름 지정 논리</target>
        </trans-unit>
        <trans-unit id="71db390f7498c8607ecf76f70925348383f07f46" translate="yes" xml:space="preserve">
          <source>Nimgrep has particularly good support for Nim's eccentric &lt;em&gt;style insensitivity&lt;/em&gt;. Apart from that it is a generic text manipulation tool.</source>
          <target state="translated">Nimgrep은 특히 Nim의 편심 &lt;em&gt;스타일 무감도&lt;/em&gt; 를 잘 지원합니다 . 그 외에도 일반적인 텍스트 조작 도구입니다.</target>
        </trans-unit>
        <trans-unit id="23ef2cadfc8ec56820149ad08675af48b8c2a012" translate="yes" xml:space="preserve">
          <source>Nimgrep is a command line tool for search&amp;amp;replace tasks. It can search for regex or peg patterns and can search whole directories at once. User confirmation for every single replace operation can be requested.</source>
          <target state="translated">Nimgrep은 검색 및 교체 작업을위한 명령 줄 도구입니다. 정규식 또는 페그 패턴을 검색하고 전체 디렉토리를 한 번에 검색 할 수 있습니다. 모든 단일 교체 작업에 대한 사용자 확인을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cf2ee07bf536474f8a79eec9ae5297ea46f5b0" translate="yes" xml:space="preserve">
          <source>Nimsuggest for IDE support</source>
          <target state="translated">IDE 지원에 가장 적합한</target>
        </trans-unit>
        <trans-unit id="74dadd5fc671c88eec7c8cc084b2f4492ce2f149" translate="yes" xml:space="preserve">
          <source>Nimsuggest invocation</source>
          <target state="translated">가장 가까운 호출</target>
        </trans-unit>
        <trans-unit id="5621d2e904ec7f4a1fa59a63968518771b43d445" translate="yes" xml:space="preserve">
          <source>Nimsuggest is part of Nim's core. Build it via:</source>
          <target state="translated">님 무스 트는 님의 핵심의 일부입니다. 다음을 통해 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="b9338b400871e7a753e81682f58f03a8156017e7" translate="yes" xml:space="preserve">
          <source>Nimsuggest output is always returned on single lines separated by tab characters (&lt;code&gt;\t&lt;/code&gt;). The values of each column are:</source>
          <target state="translated">Nimuggest 출력은 항상 탭 문자 ( &lt;code&gt;\t&lt;/code&gt; )로 구분 된 한 줄로 반환됩니다 . 각 열의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5372c202a30284da7742441a108b564cdbdf5739" translate="yes" xml:space="preserve">
          <source>Nimsuggest than waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">쿼리가 처리되기를 기다리는 것보다 가장 까다 롭습니다. 질의는 암호로 된 3 문자 &quot;command&quot; &lt;code&gt;def&lt;/code&gt; 또는 &lt;code&gt;con&lt;/code&gt; 또는 &lt;code&gt;sug&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 와 위치로 구성됩니다. 쿼리 위치는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8bffa4d8fa15634e3c256a4cb41638cf0bbf6c32" translate="yes" xml:space="preserve">
          <source>Nimsuggest then waits for queries to process. A query consists of a cryptic 3 letter &quot;command&quot; &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;con&lt;/code&gt; or &lt;code&gt;sug&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt; followed by a location. A query location consists of:</source>
          <target state="translated">그런 다음 Nimsuggest는 쿼리가 처리 될 때까지 기다립니다. 쿼리는 암호 3 자 &quot;command&quot; &lt;code&gt;def&lt;/code&gt; 또는 &lt;code&gt;con&lt;/code&gt; 또는 &lt;code&gt;sug&lt;/code&gt; 또는 &lt;code&gt;use&lt;/code&gt; 뒤에 위치로 구성됩니다. 쿼리 위치는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="95165223d15af7cefab907c1e06b8b4044d588d9" translate="yes" xml:space="preserve">
          <source>Nimsuggest will always answer with a single definition or none if it can't find any valid symbol matching the position of the query.</source>
          <target state="translated">Nimsuggest는 항상 단일 정의로 응답하거나 쿼리 위치와 일치하는 유효한 기호를 찾을 수 없으면 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd6ee0acaba1530dda97aa7b3382ff72ed9f8236" translate="yes" xml:space="preserve">
          <source>Nimterlingua</source>
          <target state="translated">Nimterlingua</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5edb935fde1ba56536daaa6b349f01597bc5f8c0" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;&amp;lt;$xml ...$&amp;gt;&lt;/code&gt; declaration is produced, so that the produced XML fragments are composable.</source>
          <target state="translated">없음 &lt;code&gt;&amp;lt;$xml ...$&amp;gt;&lt;/code&gt; 선언이 생산되기 때문에 생산 된 XML 조각이 작성 가능 있음.하지</target>
        </trans-unit>
        <trans-unit id="fb05c02eb40dd8659b5825634b0887e886c359fc" translate="yes" xml:space="preserve">
          <source>No longer actually used</source>
          <target state="translated">더 이상 실제로 사용되지 않음</target>
        </trans-unit>
        <trans-unit id="62642b3249a520b5e9ec7c96e547e3faa1827969" translate="yes" xml:space="preserve">
          <source>No traffic is sent.</source>
          <target state="translated">트래픽이 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75b9c1b54338d8b9332efccba32605f983f91029" translate="yes" xml:space="preserve">
          <source>NoDecl pragma</source>
          <target state="translated">NoDecl pragma</target>
        </trans-unit>
        <trans-unit id="4170d71a9c1c5f8428ffdc4348b9e7f9ec2ac4c6" translate="yes" xml:space="preserve">
          <source>Noalias annotation</source>
          <target state="translated">Noalias 주석</target>
        </trans-unit>
        <trans-unit id="889f402d84c133d41a3ffb2515b25c4ff5b1ea38" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;code&gt;delim&lt;/code&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">기본이 아닌 구분 기호를 전달하여 다른 종류의 &quot;선형&quot;가변 길이 레코드에 대한 반복을 허용 할 수 있습니다. = 먹고 '\ 0'를 엄격히로 전달 &lt;code&gt;delim&lt;/code&gt; -delimited. ( '\ 0'과 같은 선택적 접두사를 먹는 것은 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="83c63e0618d33e20ddbbc5fcacaa83b0217e5a9a" translate="yes" xml:space="preserve">
          <source>Non-default delimiters can be passed to allow iteration over other sorts of &quot;line-like&quot; variable length records. Pass eat='\0' to be strictly &lt;em&gt;delim&lt;/em&gt;-delimited. (Eating an optional prefix equal to '\0' is not supported.)</source>
          <target state="translated">기본이 아닌 분리 문자를 전달하여 다른 종류의 &quot;라인 유사&quot;가변 길이 레코드를 반복 할 수 있습니다. = 먹고 '\ 0'를 엄격히로 전달 &lt;em&gt;DELIM&lt;/em&gt; -delimited. ( '\ 0'과 같은 선택적 접두사를 먹는 것은 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="51982015db8c39d38da4e016c910ad96f798d0ca" translate="yes" xml:space="preserve">
          <source>Non-printing characters</source>
          <target state="translated">비 인쇄 문자</target>
        </trans-unit>
        <trans-unit id="418bd9eb8597b90fb89b70c50e626f53d89d17ca" translate="yes" xml:space="preserve">
          <source>Non-pure enum values should use camelCase whereas pure enum values should use PascalCase.</source>
          <target state="translated">순수하지 않은 열거 형 값은 camelCase를 사용해야하지만 순수한 열거 형 값은 PascalCase를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d7bfd0d37a23478caf5e01ccd5869426102765" translate="yes" xml:space="preserve">
          <source>Non-terminals start with a lowercase letter, abstract terminal symbols are in UPPERCASE. Verbatim terminal symbols (including keywords) are quoted with &lt;code&gt;'&lt;/code&gt;. An example:</source>
          <target state="translated">비 터미널은 소문자로 시작하며 추상 터미널 기호는 대문자입니다. 축약어 터미널 기호 (키워드 포함)는 &lt;code&gt;'&lt;/code&gt; 로 인용됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="2da5842ba2d454a52f2d4148a700d65ec1d538fd" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;code&gt;boundChecks&lt;/code&gt; option, those procs will raise an &lt;code&gt;IndexDefect&lt;/code&gt; on such access. This should not be relied upon, as &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--checks:off&lt;/code&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">deque에서 개별 값을 가져 오는 procs는 빈 deque에서 사용할 수 없습니다. &lt;code&gt;boundChecks&lt;/code&gt; 옵션으로 컴파일 된 경우 해당 procs는 이러한 액세스에 대해 &lt;code&gt;IndexDefect&lt;/code&gt; 를 발생시킵니다. &lt;code&gt;-d:danger&lt;/code&gt; 또는 &lt;code&gt;--checks:off&lt;/code&gt; 는 이러한 검사를 비활성화하고 가비지를 반환하거나 프로그램을 중단시킬 수 있으므로 이것은 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="461551ab6e0521d38c563c8b4f15319bef024ec5" translate="yes" xml:space="preserve">
          <source>None of the procs that get an individual value from the deque can be used on an empty deque. If compiled with &lt;em&gt;boundChecks&lt;/em&gt; option, those procs will raise an &lt;em&gt;IndexError&lt;/em&gt; on such access. This should not be relied upon, as &lt;em&gt;-d:release&lt;/em&gt; will disable those checks and may return garbage or crash the program.</source>
          <target state="translated">deque에서 개별 값을 얻는 procs는 빈 deque에서 사용할 수 없습니다. &lt;em&gt;boundChecks&lt;/em&gt; 옵션으로 컴파일하면 해당 &lt;em&gt;프로세스&lt;/em&gt; 에서 해당 액세스에 대해 &lt;em&gt;IndexError&lt;/em&gt; 가 발생합니다. &lt;em&gt;-d : release&lt;/em&gt; 는 이러한 검사를 비활성화하고 가비지를 반환하거나 프로그램을 중단시킬 수 있으므로이를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1f993e0a0dd08ee915cc3e9cf167ebefdec7aa0" translate="yes" xml:space="preserve">
          <source>None:</source>
          <target state="translated">None:</target>
        </trans-unit>
        <trans-unit id="e62990a968e72898ad2b534a5d5ef0b2768deeb2" translate="yes" xml:space="preserve">
          <source>NoneLike:</source>
          <target state="translated">NoneLike:</target>
        </trans-unit>
        <trans-unit id="eb4fc459eedc650eb7092ee10047a19689f0d4cd" translate="yes" xml:space="preserve">
          <source>Nonoverloadable builtins</source>
          <target state="translated">과부하 불가능한 내장</target>
        </trans-unit>
        <trans-unit id="a209e6fa751d79c5e7c6b6c0069fb20b224a488a" translate="yes" xml:space="preserve">
          <source>Normal Android apps are written in Java, to use Nim inside an Android app you need a small Java stub that calls out to a native library written in Nim using the &lt;a href=&quot;https://developer.android.com/ndk&quot;&gt;NDK&lt;/a&gt;. You can also use &lt;a href=&quot;https://developer.android.com/ndk/samples/sample_na&quot;&gt;native-activity&lt;/a&gt; to have the Java stub be auto-generated for you.</source>
          <target state="translated">일반 Android 앱은 Java로 작성되므로 Android 앱 내에서 Nim을 사용하려면 &lt;a href=&quot;https://developer.android.com/ndk&quot;&gt;NDK를&lt;/a&gt; 사용하여 Nim으로 작성된 네이티브 라이브러리를 호출하는 작은 Java 스텁이 필요합니다 . 또한 &lt;a href=&quot;https://developer.android.com/ndk/samples/sample_na&quot;&gt;기본 활동&lt;/a&gt; 을 사용하여 Java 스텁이 자동 생성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb66dc661861f381636ef80a030d6e4f15642186" translate="yes" xml:space="preserve">
          <source>Normal symbols are added to the index with surrounding whitespaces removed. An exception to this are table of content (TOC) entries. TOC entries are added to the index file with their third column having as much prefix spaces as their level is in the TOC (at least 1 character). The prefix whitespace helps to filter TOC entries from API or text symbols. This is important because the amount of spaces is used to replicate the hiearchy for document TOCs in the final index, and TOC entries found in &lt;code&gt;.nim&lt;/code&gt; files are discarded.</source>
          <target state="translated">주변 공백이 제거 된 일반 기호가 색인에 추가됩니다. 이에 대한 예외는 목차 (TOC) 항목입니다. 목차가 TOC에있는 수만큼의 접두사 공간이있는 세 번째 열과 함께 TOC 항목이 색인 파일에 추가됩니다 (최소 1 자). 접두사 공백은 API 또는 텍스트 기호에서 TOC 항목을 필터링하는 데 도움이됩니다. 공간의 양이 최종 색인의 문서 TOC에 대한 &lt;code&gt;.nim&lt;/code&gt; 를 복제하는 데 사용되며 .nim 파일에있는 TOC 항목 이 삭제 되기 때문에 이는 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="b2311ed7d695294572b2e47ef09cbf7395d919cc" translate="yes" xml:space="preserve">
          <source>Normalize a path.</source>
          <target state="translated">경로를 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="88b967ed3ef7a6725101f93ac01771eb39040fe8" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt; as a Nim identifier.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 를 Nim 식별자로 정규화합니다 .</target>
        </trans-unit>
        <trans-unit id="f23b19ce6bd569b872dfb26317c2ba486b398fed" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 를 정규화합니다 .</target>
        </trans-unit>
        <trans-unit id="cc401dc387c902dea14776d7f9bdd3484fd7eecd" translate="yes" xml:space="preserve">
          <source>Normalizes the string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 정규화 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="189e5cbc3b2e9402b7839197455dd96543d0d4ac" translate="yes" xml:space="preserve">
          <source>Not available for JS backend.</source>
          <target state="translated">JS 백엔드에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b4111577c9d69153a097caeb5d59cb7772b3248" translate="yes" xml:space="preserve">
          <source>Not equals</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="2b87a9d966e87007d02f8daaa4c946c260411a9b" translate="yes" xml:space="preserve">
          <source>Not nil annotation</source>
          <target state="translated">주석이 아님</target>
        </trans-unit>
        <trans-unit id="8e5e6194b87f5a890650f1c4bfbf0e220197df8e" translate="yes" xml:space="preserve">
          <source>Not nil annotations are not supported.</source>
          <target state="translated">nil이 아닌 주석은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8674a1a5764153c229b94ca832a584559616dd" translate="yes" xml:space="preserve">
          <source>Not predicate</source>
          <target state="translated">술어 아님</target>
        </trans-unit>
        <trans-unit id="3d01d18bf9a6daa3fb19ea60a23f7dd70f8af43a" translate="yes" xml:space="preserve">
          <source>Not predicate: Indicate failure if expression E matches the text ahead; otherwise indicate success. Do not consume any text.</source>
          <target state="translated">술어 아님 : 식 E가 앞의 텍스트와 일치하면 실패를 나타냅니다. 그렇지 않으면 성공을 나타냅니다. 텍스트를 소비하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="372ee3c9236cc0455481f60f3b86be209faab779" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreCase%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreCase&lt;/a&gt; instead.</source>
          <target state="translated">JS 백엔드에는 지원되지 &lt;a href=&quot;strutils#cmpIgnoreCase%2Cstring%2Cstring&quot;&gt;않으므로&lt;/a&gt; 대신 strutils.cmpIgnoreCase를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10c6219b3ee58abf2bacef53dd21d8b78344d8d7" translate="yes" xml:space="preserve">
          <source>Not supported for JS backend, use &lt;a href=&quot;strutils#cmpIgnoreStyle%2Cstring%2Cstring&quot;&gt;strutils.cmpIgnoreStyle&lt;/a&gt; instead.</source>
          <target state="translated">JS 백엔드에는 지원되지 &lt;a href=&quot;strutils#cmpIgnoreStyle%2Cstring%2Cstring&quot;&gt;않으므로&lt;/a&gt; 대신 strutils.cmpIgnoreStyle을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb537afc8ef61289c5a65dac8f48c5cd88026a7d" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,Natural,int&quot;&gt;find proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">그 자체로는 그다지 유용하지 않습니다.이를 사용하여 &lt;em&gt;반전 된&lt;/em&gt; 집합을 만들어 &lt;a href=&quot;#find,string,set%5Bchar%5D,Natural,int&quot;&gt;find proc&lt;/a&gt; 이 문자열에서 &lt;strong&gt;유효하지 않은&lt;/strong&gt; 문자를 찾 도록 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="542c73c0783f6a29758964ce1947b79cd5d16744" translate="yes" xml:space="preserve">
          <source>Not very useful by its own, you can use it to create &lt;em&gt;inverted&lt;/em&gt; sets to make the &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find() proc&lt;/a&gt; find &lt;strong&gt;invalid&lt;/strong&gt; characters in strings. Example:</source>
          <target state="translated">그 자체로는 그다지 유용하지는 않지만,이를 사용 하여 &lt;a href=&quot;#find,string,set%5Bchar%5D,int&quot;&gt;find () 프로 시저&lt;/a&gt; 가 문자열에서 &lt;strong&gt;유효하지 않은&lt;/strong&gt; 문자를 찾 도록 &lt;em&gt;반전 된&lt;/em&gt; 세트를 작성할 수 있습니다 . 예:&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="04228ae1050018eb31f9f0fcb6a78ef941137a15" translate="yes" xml:space="preserve">
          <source>Note how the built-in &lt;code&gt;len&lt;/code&gt; proc returns only the array's first dimension length. Another way of defining the &lt;code&gt;LightTower&lt;/code&gt; to better illustrate its nested nature would be to omit the previous definition of the &lt;code&gt;LevelSetting&lt;/code&gt; type and instead write it embedded directly as the type of the first dimension:</source>
          <target state="translated">내장 &lt;code&gt;len&lt;/code&gt; proc이 어떻게 배열의 첫 번째 차원 길이 만 반환 하는지 주목하십시오 . 중첩 특성을 더 잘 설명하기 위해 &lt;code&gt;LightTower&lt;/code&gt; 를 정의하는 또 다른 방법은 &lt;code&gt;LevelSetting&lt;/code&gt; 유형 의 이전 정의를 생략 하고 대신 첫 번째 차원의 유형으로 직접 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd3704db1df15da0eb18abb96f396dc8315f28b4" translate="yes" xml:space="preserve">
          <source>Note how the example contains extra C code to declare the &lt;code&gt;iupdll&lt;/code&gt; symbol in the generated Nim code.</source>
          <target state="translated">예제 에 생성 된 Nim 코드에서 &lt;code&gt;iupdll&lt;/code&gt; 기호 를 선언하는 추가 C 코드가 어떻게 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e40503f2c45525bd696a9b1577019e4a6a54a7" translate="yes" xml:space="preserve">
          <source>Note how the set turns enum values into powers of 2.</source>
          <target state="translated">집합이 열거 형 값을 2의 거듭 제곱으로 바꾸는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9897f075d01f2091487e98593989f12def2c9e19" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$app&lt;/code&gt;, &lt;code&gt;$appname&lt;/code&gt;, and &lt;code&gt;$appdir&lt;/code&gt; are not supported when using the JavaScript backend.</source>
          <target state="translated">참고 &lt;code&gt;$app&lt;/code&gt; , &lt;code&gt;$appname&lt;/code&gt; , 및 &lt;code&gt;$appdir&lt;/code&gt; 자바 스크립트 백엔드를 사용하는 경우 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9a791309560be143e9e6f64f7aa9877ff5cada7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt; doesn't represent a fixed duration of time, since the duration of some units depend on the context (e.g a year can be either 365 or 366 days long). The non-fixed time units are years, months, days and week.</source>
          <target state="translated">일부 단위의 기간은 컨텍스트에 따라 &lt;code&gt;TimeInterval&lt;/code&gt; 때문에 TimeInterval 은 고정 된 기간을 나타내지 않습니다 (예 : 1 년 길이는 365 일 또는 366 일일 수 있음). 고정되지 않은 시간 단위는 년, 월, 일 및 주입니다.</target>
        </trans-unit>
        <trans-unit id="d94766cead949b3e8ea24b0db0a77a97e426ab4e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TimeInterval&lt;/code&gt;'s returned from the &lt;code&gt;times&lt;/code&gt; module are never normalized. If you want to normalize a time unit, &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; should be used instead.</source>
          <target state="translated">참고 &lt;code&gt;TimeInterval&lt;/code&gt; 이 의으로부터 반환 &lt;code&gt;times&lt;/code&gt; 정상화되지 않습니다 모듈입니다. 시간 단위를 정규화하려면 대신 &lt;a href=&quot;#Duration&quot;&gt;Duration을&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="adf4a48e6d5642c56029b0227b694330e642ab42" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ashr&lt;/code&gt; is not an operator so use the normal function call syntax for it.</source>
          <target state="translated">참고 &lt;code&gt;ashr&lt;/code&gt; 는 오퍼레이터 아니다 그래서 그것을 정규 함수 호출 구문을 사용한다.</target>
        </trans-unit>
        <trans-unit id="ce6b9b4ceabc50bdb117bfb8df4ea521f2a5d675" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getCurrentException&lt;/code&gt; always returns a &lt;code&gt;ref Exception&lt;/code&gt; type. If a variable of the proper type is needed (in the example above, &lt;code&gt;IOError&lt;/code&gt;), one must convert it explicitly:</source>
          <target state="translated">참고 &lt;code&gt;getCurrentException&lt;/code&gt; 는 항상 반환 &lt;code&gt;ref Exception&lt;/code&gt; 유형입니다. 적절한 유형의 변수가 필요한 경우 (위의 예에서 &lt;code&gt;IOError&lt;/code&gt; ) 명시 적으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15f8bf07037666cd628faf3d8b1289a1ebbe6888" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import math as m&lt;/code&gt; does not use a different node; rather, we use &lt;code&gt;nnkImportStmt&lt;/code&gt; with &lt;code&gt;as&lt;/code&gt; as an infix operator.</source>
          <target state="translated">참고 &lt;code&gt;import math as m&lt;/code&gt; 다른 노드를 사용하지 않습니다; 오히려, 우리는 사용 &lt;code&gt;nnkImportStmt&lt;/code&gt; 을 과 &lt;code&gt;as&lt;/code&gt; 중위 연산자로.</target>
        </trans-unit>
        <trans-unit id="3850a394097e20f4e139b6c553e491a35ada914b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">주의 &lt;code&gt;s&lt;/code&gt; A와 선언해야 &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b5663a783c31085b10a438aaa39d48ac8ef1674" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;system.finished&lt;/code&gt; is error prone to use because it only returns &lt;code&gt;true&lt;/code&gt; one iteration after the iterator has finished:</source>
          <target state="translated">참고 &lt;code&gt;system.finished&lt;/code&gt; 는 단지 반환하기 때문에 사용하기 쉬운 오류가 &lt;code&gt;true&lt;/code&gt; 반복자가 완료되면 하나의 반복 :</target>
        </trans-unit>
        <trans-unit id="bc55a86bc2176f00ed0cc4a2ced7592a3287c04a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since the untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;using&lt;/code&gt; 적용되지 &lt;code&gt;template&lt;/code&gt; 유형에 유형이 지정되지 않은 템플릿 매개 변수의 기본부터 &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65e48edf1a92ed7ba69b341dc76ceb955ed905a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;using&lt;/code&gt; is not applied for &lt;code&gt;template&lt;/code&gt; since untyped template parameters default to the type &lt;code&gt;system.untyped&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;using&lt;/code&gt; 적용되지 &lt;code&gt;template&lt;/code&gt; 유형에 지정되지 않은 템플릿 매개 변수의 기본부터 &lt;code&gt;system.untyped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eaa79a5d51a878bd30d77cb48d9cf5f64b35ea7" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;.</source>
          <target state="translated">Nim의 확장 원시 문자열 리터럴은 &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; 구문 을 &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; 의 짧은 형식으로 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="541571b7bbe9cf9e61fcadf529c49d38c395b8d1" translate="yes" xml:space="preserve">
          <source>Note that Nim's extended raw string literals support the syntax &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; as a short form for &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt;. Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)</source>
          <target state="translated">Nim의 확장 원시 문자열 리터럴 은 &lt;code&gt;re(r&quot;[abc]&quot;)&lt;/code&gt; 의 약식으로 &lt;code&gt;re&quot;[abc]&quot;&lt;/code&gt; 구문을 지원합니다 . 또한 이것은 비용이 많이 드는 정규식을 컴파일하기 때문에 성능을 크게 저하시킬 수 있으므로 아래 예제와 같은 함수의 인수에 직접 넣는 것을 피해야합니다. (예 : 루프 외부, ...)</target>
        </trans-unit>
        <trans-unit id="66958a893582569a32abe154668c902b04b269b9" translate="yes" xml:space="preserve">
          <source>Note that a duration can be negative, so even if &lt;code&gt;a &amp;lt; b&lt;/code&gt; is true &lt;code&gt;a&lt;/code&gt; might represent a larger absolute duration. Use &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; to compare the absolute duration.</source>
          <target state="translated">기간이 없더라도 제외 될 수 있음을 유의 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 참 큰 절대 시간을 나타내는 수는. 절대 기간을 비교 하려면 &lt;code&gt;abs(a) &amp;lt; abs(b)&lt;/code&gt; 를 사용하십시오. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11d04164bd578d4758910d31096e77690bec376a" translate="yes" xml:space="preserve">
          <source>Note that a message's level is still checked against each handler's &lt;code&gt;levelThreshold&lt;/code&gt; and the global log filter.</source>
          <target state="translated">메시지의 레벨은 여전히 ​​각 핸들러의 &lt;code&gt;levelThreshold&lt;/code&gt; 및 글로벌 로그 필터 에 대해 확인 됩니다.</target>
        </trans-unit>
        <trans-unit id="31a61e95866e9147c08e9c2d0fd1b10e87385ea4" translate="yes" xml:space="preserve">
          <source>Note that an explicit array constructor passed to a &lt;code&gt;varargs&lt;/code&gt; parameter is not wrapped in another implicit array construction:</source>
          <target state="translated">&lt;code&gt;varargs&lt;/code&gt; 매개 변수에 전달 된 명시 적 배열 생성자 는 다른 암시 적 배열 구성으로 래핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="580208a43972b50356da5b1da0797b119e251075" translate="yes" xml:space="preserve">
          <source>Note that at the moment the word &lt;code&gt;proc&lt;/code&gt; is returned for the signature of the found method instead of the expected &lt;code&gt;method&lt;/code&gt;. This may change in the future.</source>
          <target state="translated">현재 예상 &lt;code&gt;method&lt;/code&gt; 대신 발견 된 메소드의 서명에 대해 &lt;code&gt;proc&lt;/code&gt; 단어 가 리턴됩니다 . 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24c487cedc7c752e18df39ebc5ba3ec45556047e" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">컨테이너주의 &lt;code&gt;s&lt;/code&gt; A와 선언해야 &lt;code&gt;var&lt;/code&gt; 및 이후는, 동일하게 사용자의 입력 및 출력 유형의 필요 &lt;code&gt;s&lt;/code&gt; 에 적절한 수정됩니다. 매개 변수 함수는 &lt;code&gt;var T&lt;/code&gt; 유형 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93a1d492f470ea3d6702b7d65ba7a1f02a7ad547" translate="yes" xml:space="preserve">
          <source>Note that container &lt;code&gt;s&lt;/code&gt; must be declared as a &lt;code&gt;var&lt;/code&gt; and it is required for your input and output types to be the same, since &lt;code&gt;s&lt;/code&gt; is modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">컨테이너주의 &lt;code&gt;s&lt;/code&gt; A와 선언해야 &lt;code&gt;var&lt;/code&gt; 및 이후는, 동일하게 사용자의 입력 및 출력 유형의 필요 &lt;code&gt;s&lt;/code&gt; 에 적절한 수정됩니다. 매개 변수 함수는 &lt;code&gt;T&lt;/code&gt; 유형 변수를 가져와 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fe89c735f73e47df7589d2ce0f730288a5b272a5" translate="yes" xml:space="preserve">
          <source>Note that declaring multiple variables with a single assignment which calls a procedure can have unexpected results: the compiler will &lt;em&gt;unroll&lt;/em&gt; the assignments and end up calling the procedure several times. If the result of the procedure depends on side effects, your variables may end up having different values! For safety use side-effect free procedures if making multiple assignments.</source>
          <target state="translated">프로 시저를 호출하는 단일 할당으로 여러 변수를 선언하면 예기치 않은 결과가 발생할 수 있습니다. 컴파일러는 할당 을 &lt;em&gt;풀고&lt;/em&gt; 프로 시저를 여러 번 호출하게됩니다. 절차의 결과가 부작용에 의존하는 경우 변수의 값이 다를 수 있습니다! 안전을 위해 여러 번 할당 할 경우 부작용이없는 절차를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c80f0b7fe87a1023b9ef2a3f07090c0f9848e853" translate="yes" xml:space="preserve">
          <source>Note that due to Nim's parameter passing semantics this means that &lt;code&gt;T&lt;/code&gt; doesn't need to be copied so &lt;code&gt;awaitAndThen&lt;/code&gt; can sometimes be more efficient than &lt;a href=&quot;#%5E,FlowVar%5BT%5D&quot;&gt;^ proc&lt;/a&gt;.</source>
          <target state="translated">Nim의 매개 변수 전달 의미로 인해 &lt;code&gt;T&lt;/code&gt; 를 복사 할 필요가 없으므로 &lt;code&gt;awaitAndThen&lt;/code&gt; 이 때때로 &lt;a href=&quot;#%5E,FlowVar%5BT%5D&quot;&gt;^ proc&lt;/a&gt; 보다 더 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0fc07cec95ec5e1fead7b4c0cc4bdbd5f963690" translate="yes" xml:space="preserve">
          <source>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</source>
          <target state="translated">컴파일러는 어떤 식 으로든 (지정된 할당에서 유추 할 수있는) 유형을 알아야하기 때문에 위의 두 번째 또는 세 번째 (또는 둘 다) 매개 변수가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="315d31332dc9316e7f3826cb4f065e4db97ff67a" translate="yes" xml:space="preserve">
          <source>Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe! Also, Nim's runtime type information will evolve and may eventually be deprecated. As an alternative approach to programmatically understanding and manipulating types, consider using the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; package to work with the types' AST representation at compile time. See, for example, the &lt;a href=&quot;macros#getTypeImpl,NimNode&quot;&gt;getTypeImpl proc&lt;/a&gt;. As an alternative approach to storing arbitrary types at runtime, consider using generics.</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 와 그 작업이 클라이언트로부터 불쾌한 낮은 수준의 세부 사항을 숨기 더라도 본질적으로 안전하지 않습니다! 또한 Nim의 런타임 유형 정보는 발전 할 것이며 결국 더 이상 사용되지 않을 수 있습니다. 프로그래밍 방식으로 유형을 이해하고 조작하기위한 대안으로, &lt;a href=&quot;macros&quot;&gt;매크로&lt;/a&gt; 패키지를 사용하여 컴파일 타임에 유형의 AST 표현으로 작업하는 것이 좋습니다. 예를 들어 &lt;a href=&quot;macros#getTypeImpl,NimNode&quot;&gt;getTypeImpl proc&lt;/a&gt; 을 참조하십시오 . 런타임에 임의의 유형을 저장하는 대안으로 제네릭을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7fa4224474e4b6c80954422260464c3b4a8019a5" translate="yes" xml:space="preserve">
          <source>Note that for floats, the result cannot always be interpreted as &quot;greatest decimal &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; where N and M are positive integers.&quot;</source>
          <target state="translated">수레, 결과는 반드시 해석 될 수 없습니다 &quot;큰 소수 &lt;code&gt;z&lt;/code&gt; 되도록 &lt;code&gt;z*N == x and z*M == y&lt;/code&gt; N, m은 양의 정수이다 어디.&quot;</target>
        </trans-unit>
        <trans-unit id="3974a69d8025c1886c72445a8fb4b0c0716b4564" translate="yes" xml:space="preserve">
          <source>Note that for systems with a continuous stack (which most systems have) the check whether the ref is on the stack is very cheap (only two comparisons).</source>
          <target state="translated">연속 스택이있는 시스템 (대부분의 시스템에 있음)의 경우 참조가 스택에 있는지 확인하는 것이 매우 저렴합니다 (두 개의 비교 만).</target>
        </trans-unit>
        <trans-unit id="9d1f8d76ba4bd5c129c2a18a24e1dab11a14ed65" translate="yes" xml:space="preserve">
          <source>Note that in most circumstances one should only disable the mark and sweep phase with &lt;a href=&quot;#GC_disableMarkAndSweep&quot;&gt;GC_disableMarkAndSweep&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#GC_disableMarkAndSweep&quot;&gt;GC_disableMarkAndSweep으로&lt;/a&gt; 만 표시 및 스윕 단계를 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e095193050971ff047ad4d5c8afbbc2efec37383" translate="yes" xml:space="preserve">
          <source>Note that in the example the constructors &lt;code&gt;newLit&lt;/code&gt; and &lt;code&gt;newPlus&lt;/code&gt; are procs because it makes more sense for them to use static binding, but &lt;code&gt;eval&lt;/code&gt; is a method because it requires dynamic binding.</source>
          <target state="translated">예제에서 생성자 &lt;code&gt;newLit&lt;/code&gt; 및 &lt;code&gt;newPlus&lt;/code&gt; 는 정적 바인딩을 사용하는 것이 더 의미가 있기 때문에 procs이지만, &lt;code&gt;eval&lt;/code&gt; 은 동적 바인딩이 필요하기 때문에 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="ba700b00e3387a40d1683b4c05ca6858e147eb43" translate="yes" xml:space="preserve">
          <source>Note that it is space sensitive:</source>
          <target state="translated">공간에 민감합니다.</target>
        </trans-unit>
        <trans-unit id="95ad541deafb8f63a37e09491c7556544b9d95b3" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">모든 &lt;code&gt;nnkTypeDef&lt;/code&gt; 가 &lt;code&gt;nnkIdent&lt;/code&gt; 를 매개 변수로 사용 하는 것은 아닙니다 . 유형 선언의 가장 일반적인 용도 중 하나는 객체 작업입니다.</target>
        </trans-unit>
        <trans-unit id="11be0dfde35904fa7f02afe90c20970ebac48dfb" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;nnkTypeDef&lt;/code&gt; utilize &lt;code&gt;nnkIdent&lt;/code&gt; as their their parameter. One of the most common uses of type declarations is to work with objects.</source>
          <target state="translated">모든 &lt;code&gt;nnkTypeDef&lt;/code&gt; 가 &lt;code&gt;nnkIdent&lt;/code&gt; 를 매개 변수로 사용 하는 것은 아닙니다 . 타입 선언의 가장 일반적인 용도 중 하나는 객체를 다루는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0224a1f68a8585cd4a55cb358bf685741b3afb31" translate="yes" xml:space="preserve">
          <source>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</source>
          <target state="translated">3 개 이하의 8 진 숫자는 읽지 않기 때문에 100 이상의 8 진 값은 앞에 오는 0으로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="359593d58b85b30432eb40cd29b67c1829ffd3da" translate="yes" xml:space="preserve">
          <source>Note that one can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command that will be executed during semantic analysis:</source>
          <target state="translated">&lt;a href=&quot;system&quot;&gt;시스템 모듈의 &lt;/a&gt; &lt;code&gt;gorge&lt;/code&gt; 를 사용 하여 의미 분석 중에 실행될 외부 명령의 매개 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb0c14568cc44b3aa6b93616a9638e1e67aa608b" translate="yes" xml:space="preserve">
          <source>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</source>
          <target state="translated">이것은 반복자이므로 반복하는 문자열을 수정해서는 안됩니다. 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6ff8ba25ceb642b409cfabb3508e2a2e6d8e4b" translate="yes" xml:space="preserve">
          <source>Note that some floating point numbers (e.g. infinity or even 1e19) cannot be accurately converted.</source>
          <target state="translated">일부 부동 소수점 숫자 (예 : 무한대 또는 1e19)는 정확하게 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e26b1561a3f022726ef326aaca35071eca0d805" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Time&lt;/code&gt; argument does not represent a point in time, it represent a local time! E.g if &lt;code&gt;adjTime&lt;/code&gt; is &lt;code&gt;fromUnix(0)&lt;/code&gt;, it should be interpreted as 1970-01-01T00:00:00 in the &lt;code&gt;zone&lt;/code&gt; timezone, not in UTC.</source>
          <target state="translated">참고는 것을 &lt;code&gt;Time&lt;/code&gt; 인수 시점을 나타내지 않는, 그것은 현지 시간을 나타냅니다! 예를 들어 &lt;code&gt;adjTime&lt;/code&gt; 이 &lt;code&gt;fromUnix(0)&lt;/code&gt; 이면 UTC가 아닌 &lt;code&gt;zone&lt;/code&gt; 시간대 에서 1970-01-01T00 : 00 : 00으로 해석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3153be7f62193c7a012288373ef96e64821a33" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;importcpp&lt;/code&gt; variant for procs uses a somewhat cryptic pattern language for maximum flexibility:</source>
          <target state="translated">procs에 대한 &lt;code&gt;importcpp&lt;/code&gt; 변형은 최대한의 유연성을 위해 다소 암호화 된 패턴 언어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f79f9b3f84579ddfcfc49f356b7732e51770554f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;jsondoc&lt;/code&gt; command outputs it's JSON without pretty-printing it, while &lt;code&gt;jsondoc0&lt;/code&gt; outputs pretty-printed JSON.</source>
          <target state="translated">&lt;code&gt;jsondoc&lt;/code&gt; 명령 은 예쁘게 인쇄하지 않고 JSON을 출력하는 반면 &lt;code&gt;jsondoc0&lt;/code&gt; 은 예쁘게 인쇄 된 JSON을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="e1b7da4962a08c6b2249b0042ce79badfd4c9b0e" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_1&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="translated">컴파일러 는 &lt;span id=&quot;openmp_1&quot;&gt;OpenMP&lt;/span&gt; 구성을 &lt;code&gt;#pragma omp parallel for&lt;/code&gt; 매핑하므로 코드의 병렬 처리를 인식하지 못합니다! 조심해! 최신 버전 &lt;code&gt;||&lt;/code&gt; Nim의 코드 생성기와 GC에서 적절한 지원을받을 것입니다.&lt;span id=&quot;openmp_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="12a40c5d3a6d57a617cae578c4709a1aa7f56b0c" translate="yes" xml:space="preserve">
          <source>Note that the compiler maps that to the &lt;code&gt;#pragma omp parallel for&lt;/code&gt; construct of &lt;span id=&quot;openmp_2&quot;&gt;OpenMP&lt;/span&gt; and as such isn't aware of the parallelism in your code! Be careful! Later versions of &lt;code&gt;||&lt;/code&gt; will get proper support by Nim's code generator and GC.</source>
          <target state="translated">컴파일러 는 &lt;span id=&quot;openmp_2&quot;&gt;OpenMP&lt;/span&gt; 구성을 &lt;code&gt;#pragma omp parallel for&lt;/code&gt; 매핑하므로 코드의 병렬 처리를 인식하지 못합니다! 조심해! 최신 버전 &lt;code&gt;||&lt;/code&gt; Nim의 코드 생성기와 GC에서 적절한 지원을받을 것입니다.&lt;span id=&quot;openmp_2&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="42ac3d817acc6699555135aadc50a22472888948" translate="yes" xml:space="preserve">
          <source>Note that the default generator always starts in the same state. The &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be called to initialize the default generator with a seed based on the current time, and it only needs to be called once before the first usage of procs from this module. If &lt;code&gt;randomize&lt;/code&gt; is not called, then the default generator will always produce the same results.</source>
          <target state="translated">기본 생성기는 항상 동일한 상태에서 시작됩니다. &lt;a href=&quot;#randomize&quot;&gt;RANDOMIZE proc 디렉토리는&lt;/a&gt; 현재 시간을 기준으로 시드와 기본 생성기를 초기화하기 위해 호출, 그리고 그것은 단지이 모듈에서 발동의 첫 번째 사용하기 전에 한 번 호출 할 필요가있다 할 수 있습니다. 경우 &lt;code&gt;randomize&lt;/code&gt; 호출되지 않습니다, 디폴트 발생기는 항상 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0657a4b90e474cfb90775d71e0fec2c9d65f4786" translate="yes" xml:space="preserve">
          <source>Note that the encoding cannot be changed once it's been set. According to SQLite3 documentation, any attempt to change the encoding after the database is created will be silently ignored.</source>
          <target state="translated">인코딩을 설정 한 후에는 변경할 수 없습니다. SQLite3 문서에 따르면 데이터베이스가 작성된 후 인코딩을 변경하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb042b8b29c59f41b3cd0e948e779e25db65a35" translate="yes" xml:space="preserve">
          <source>Note that the module name is still &lt;code&gt;strutils&lt;/code&gt; and not &lt;code&gt;lib/pure/strutils&lt;/code&gt; and so one &lt;strong&gt;cannot&lt;/strong&gt; do:</source>
          <target state="translated">참고 모듈 이름은 여전히 것을 &lt;code&gt;strutils&lt;/code&gt; 하지 &lt;code&gt;lib/pure/strutils&lt;/code&gt; 하나 그렇게 &lt;strong&gt;할 수없는&lt;/strong&gt; 수행</target>
        </trans-unit>
        <trans-unit id="343c37cc8e2a037df9dff1a349a478f071828d8b" translate="yes" xml:space="preserve">
          <source>Note that the pattern language naturally also covers C++'s operator overloading capabilities:</source>
          <target state="translated">패턴 언어는 자연스럽게 C ++의 연산자 오버로드 기능도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8cde912a6f95d6bc0c0ad134a4919451e220d036" translate="yes" xml:space="preserve">
          <source>Note that the regular expression does not behave as intended either: in the example &lt;code&gt;*&lt;/code&gt; should not be greedy, so &lt;code&gt;\[.*?\]&lt;/code&gt; should be used instead.</source>
          <target state="translated">정규 표현식은 의도 한대로 작동하지 않습니다. 예제에서 &lt;code&gt;*&lt;/code&gt; 는 욕심이 없어야하므로 대신 &lt;code&gt;\[.*?\]&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f120496e6d813c76cb6c4055f029e22950f8809c" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be &lt;code&gt;nil&lt;/code&gt;. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">시퀀스는 0으로 된 항목으로 채워지며 문자열을 포함하는 시퀀스의 값은 &lt;code&gt;nil&lt;/code&gt; 이기 때문에 문제가 될 수 있습니다 . 시퀀스를 생성 한 후 추가하는 대신 시퀀스에 항목을 할당해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="de5af658288d60206e55385523786da7d39f926a" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="translated">시퀀스는 0으로 채워진 항목으로 채워집니다. 시퀀스 생성 후에는 항목을 추가하는 대신 시퀀스에 항목을 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="2997a3fd7a7a4785860a47b62d4eebe1a899d888" translate="yes" xml:space="preserve">
          <source>Note that the sequence will be filled with zeroed entries. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</source>
          <target state="translated">시퀀스는 0으로 채워진 항목으로 채워집니다. 시퀀스 생성 후에는 항목을 추가하는 대신 시퀀스에 항목을 할당해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="0f32cf721122a35c0f4af8b0ef39f1b57a1cde09" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;a href=&quot;#degToRad,T&quot;&gt;degToRad&lt;/a&gt; and &lt;a href=&quot;#radToDeg,T&quot;&gt;radToDeg&lt;/a&gt; provide conversion between radians and degrees.</source>
          <target state="translated">삼각 함수는 자연스럽게 라디안에서 작동합니다. 도우미 함수 &lt;a href=&quot;#degToRad,T&quot;&gt;degToRad&lt;/a&gt; 및 &lt;a href=&quot;#radToDeg,T&quot;&gt;radToDeg&lt;/a&gt; 는 라디안과 각도 간의 변환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1afc5e4454ca57a472753d975721911248348abc" translate="yes" xml:space="preserve">
          <source>Note that the trigonometric functions naturally operate on radians. The helper functions &lt;em&gt;degToRad&lt;/em&gt; and &lt;em&gt;radToDeg&lt;/em&gt; provide conversion between radians and degrees.</source>
          <target state="translated">삼각 함수는 자연스럽게 라디안에서 작동합니다. 도우미 함수 &lt;em&gt;degToRad&lt;/em&gt; 및 &lt;em&gt;radToDeg&lt;/em&gt; 는 라디안과도 사이의 변환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b39e62dfdcac76acc3788b0504467d241681c022" translate="yes" xml:space="preserve">
          <source>Note that there can be exceptions to these rules. Nim being as flexible as it is, there will be parts of this style guide that don't make sense in certain contexts. Furthermore, just as &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;Python's style guide&lt;/a&gt; changes over time, this style guide will too.</source>
          <target state="translated">이 규칙에는 예외가있을 수 있습니다. Nim은 그처럼 유연하기 때문에 특정 상황에서는 이해가되지 않는이 스타일 가이드의 일부가있을 것입니다. 또한 &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;파이썬의 스타일 가이드&lt;/a&gt; 가 시간이 지남에 따라 변경 되는 것처럼 이 스타일 가이드도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0fed77603f9454dbdef2e75534af23ed17061d9e" translate="yes" xml:space="preserve">
          <source>Note that this is a &lt;em&gt;runtime&lt;/em&gt; call and using &lt;code&gt;quit&lt;/code&gt; inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;error&lt;/a&gt; or &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;fatal&lt;/a&gt; pragmas.</source>
          <target state="translated">이것은 &lt;em&gt;런타임&lt;/em&gt; 호출이며 매크로 내에서 &lt;code&gt;quit&lt;/code&gt; 을 사용 하면 컴파일 시간 효과가 없습니다. 매크로 내에서 컴파일러를 중지해야하는 경우 &lt;a href=&quot;manual#pragmas-error-pragma&quot;&gt;오류&lt;/a&gt; 또는 &lt;a href=&quot;manual#pragmas-fatal-pragma&quot;&gt;치명적인&lt;/a&gt; pragma를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04eea85d84506e2be9f7ff640da1764e6c3b0050" translate="yes" xml:space="preserve">
          <source>Note that this is basically the only form of type inference that exists in Nim: it is a good compromise between brevity and readability.</source>
          <target state="translated">이것은 기본적으로 Nim에 존재하는 유일한 형식 추론 형식입니다. 간결성과 가독성 사이의 좋은 절충안입니다.</target>
        </trans-unit>
        <trans-unit id="58d880698f829e5e05f8d05a0d0ab0bc71e4e33a" translate="yes" xml:space="preserve">
          <source>Note that this pragma has been abused in the past to also work in the js backend for js objects and functions. : Other backends do provide the same feature under the same name. Also, when the target language is not set to C, other pragmas are available:</source>
          <target state="translated">이 pragma는 과거에 js 객체 및 함수에 대한 js 백엔드에서도 작동하도록 남용되었습니다. : 다른 백엔드는 동일한 이름으로 동일한 기능을 제공합니다. 또한 대상 언어가 C로 설정되지 않은 경우 다른 pragma를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca57587cd09e4fd62d9d47bd97a7a8675351ea8c" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name.</source>
          <target state="translated">이 pragma는 다소 잘못된 것입니다. 다른 백엔드는 동일한 이름으로 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6aa0aaed3cc81e0439834c7c529aa1845e5383d7" translate="yes" xml:space="preserve">
          <source>Note that this pragma is somewhat of a misnomer: Other backends do provide the same feature under the same name. Also, if one is interfacing with C++ the &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; and interfacing with Objective-C the &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;ImportObjC pragma&lt;/a&gt; can be used.</source>
          <target state="translated">이 pragma는 다소 잘못된 것입니다. 다른 백엔드는 동일한 이름으로 동일한 기능을 제공합니다. 또한 C ++ 과 인터페이스 하고 &lt;a href=&quot;manual#implementation-specific-pragmas-importcpp-pragma&quot;&gt;ImportCpp pragma&lt;/a&gt; 와 Objective-C와 인터페이스하고 &lt;a href=&quot;manual#implementation-specific-pragmas-importobjc-pragma&quot;&gt;있으면 ImportObjC pragma를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5d063d7e7c89bcb1be31e9838c1418c3a823324" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes a &lt;code&gt;var T&lt;/code&gt; type parameter.</source>
          <target state="translated">이를 위해서는 입력 및 출력 유형이 동일해야합니다 (제자리에서 수정되므로). 매개 변수 함수는 &lt;code&gt;var T&lt;/code&gt; 유형 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cfd22634c739d8b9963ba6240e6f789a4901df14" translate="yes" xml:space="preserve">
          <source>Note that this requires your input and output types to be the same, since they are modified in-place. The parameter function takes and returns a &lt;code&gt;T&lt;/code&gt; type variable.</source>
          <target state="translated">이를 위해서는 입력 및 출력 유형이 동일해야합니다 (제자리에서 수정되므로). 매개 변수 함수는 &lt;code&gt;T&lt;/code&gt; 유형 변수를 가져오고 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="e0ca87ec29ac7228de79e4d262997ceff6fd5ce6" translate="yes" xml:space="preserve">
          <source>Note that this rule also applies to keywords, meaning that &lt;code&gt;notin&lt;/code&gt; is the same as &lt;code&gt;notIn&lt;/code&gt; and &lt;code&gt;not_in&lt;/code&gt; (all-lowercase version (&lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt;) is the preferred way of writing keywords).</source>
          <target state="translated">이 규칙은 또한 의미 키워드에 적용됩니다 &lt;code&gt;notin&lt;/code&gt; 은 동일하다 &lt;code&gt;notIn&lt;/code&gt; 및 &lt;code&gt;not_in&lt;/code&gt; (모두 소문자 버전 ( &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; ) 키워드를 작성하는 좋은 방법이다).</target>
        </trans-unit>
        <trans-unit id="74e73723c67698a4db4dbcdaa04c4f3387732c63" translate="yes" xml:space="preserve">
          <source>Note that this version of &lt;code&gt;map&lt;/code&gt; requires your input and output types to be the same, since they are modified in-place.</source>
          <target state="translated">이 버전의 &lt;code&gt;map&lt;/code&gt; 에서는 입력 및 출력 유형이 동일하게 수정되어야합니다 (제자리에서 수정되므로).</target>
        </trans-unit>
        <trans-unit id="35a43adebbe7d9517e28187d2c67478e70dbaf9e" translate="yes" xml:space="preserve">
          <source>Note that type inference works for parameters with default values; there is no need to write &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt;, for example.</source>
          <target state="translated">형식 유추는 기본값이있는 매개 변수에 적용됩니다. 예를 들어 &lt;code&gt;title: string = &quot;unknown&quot;&lt;/code&gt; 을 쓸 필요가 없습니다 : string = &quot;unknown&quot; .</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 데이터와 동일한 크기이므로 정렬 옵션은이 경우 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4f6df5cd8b79acdb0c70f5d30510d6e8cdfa162" translate="yes" xml:space="preserve">
          <source>Note that unordered or ordered choice operators (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) are not implemented.</source>
          <target state="translated">정렬되지 않은 또는 정렬 된 선택 연산자 ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; )는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21df650805f0f9da23f06c6e6caddf7af086fddf" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;code&gt;31 October&lt;/code&gt; will result in &lt;code&gt;31 November&lt;/code&gt;, which will overflow and result in &lt;code&gt;1 December&lt;/code&gt;.</source>
          <target state="translated">월을 추가 할 때 월일 오버플로가 허용됩니다. 즉, 결과 월에 일수가 충분하지 않으면 월이 증가하고 월일이 오버플로 된 일 수로 설정됩니다. 1 개월을 추가 그래서 &lt;code&gt;31 October&lt;/code&gt; 에 발생합니다 &lt;code&gt;31 November&lt;/code&gt; 오버 플로우와 초래할 것이다, &lt;code&gt;1 December&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f37b4c7971dff9f25702efc2db169764ea60985" translate="yes" xml:space="preserve">
          <source>Note that when adding months, monthday overflow is allowed. This means that if the resulting month doesn't have enough days it, the month will be incremented and the monthday will be set to the number of days overflowed. So adding one month to &lt;em&gt;31 October&lt;/em&gt; will result in &lt;em&gt;31 November&lt;/em&gt;, which will overflow and result in &lt;em&gt;1 December&lt;/em&gt;.</source>
          <target state="translated">월을 추가 할 때 월요일 오버플로가 허용됩니다. 즉, 결과 월에 일 수가 충분하지 않으면 월이 증가하고 월일이 오버플로 된 일 수로 설정됩니다. 1 개월을 추가 그래서 &lt;em&gt;(31) 10 월&lt;/em&gt; 에 발생합니다 &lt;em&gt;11월 31일&lt;/em&gt; 오버 플로우와 초래할 것이다, &lt;em&gt;12 월 1&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="768312a6255dc501e7c26889c546bd253fd2aec8" translate="yes" xml:space="preserve">
          <source>Note that when passing objects to procedures on another thread by pointer (for example through a thread's argument), objects created using the default allocator will use thread-local, GC-managed memory. Thus it is generally safer to store channel objects in global variables (as in the above example), in which case they will use a process-wide (thread-safe) shared heap.</source>
          <target state="translated">포인터로 다른 스레드의 프로 시저에 개체를 전달할 때 (예 : 스레드의 인수를 통해) 기본 할당자를 사용하여 생성 된 개체는 스레드 로컬, GC 관리 메모리를 사용합니다. 따라서 일반적으로 채널 개체를 전역 변수에 저장하는 것이 더 안전합니다 (위의 예에서와 같이).이 경우 프로세스 전체 (스레드 안전) 공유 힙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d4120fed8da8d3978e684516d5bde06baadb627e" translate="yes" xml:space="preserve">
          <source>Note that while the value returned is of type &lt;code&gt;var B&lt;/code&gt;, it is easy to accidentally create an copy of the value at &lt;code&gt;t[key]&lt;/code&gt;. Remember that seqs and strings are value types, and therefore cannot be copied into a separate variable for modification. See the example below.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;var B&lt;/code&gt; 유형 이지만 &lt;code&gt;t[key]&lt;/code&gt; 값의 복사본을 실수로 생성하기 쉽습니다 . 시퀀스와 문자열은 값 유형이므로 수정을 위해 별도의 변수에 복사 할 수 없습니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93f7073771e81c9dae2114aa3af0598ed46cf0ad" translate="yes" xml:space="preserve">
          <source>Note that with multiple infix operators, the command is parsed by operator precedence.</source>
          <target state="translated">여러 개의 삽입 연산자를 사용하면 명령이 연산자 우선 순위에 따라 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="c76fa1132c9049877899fb2dd217fb4f9fb94f6c" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;em&gt;*&lt;/em&gt; following the name of the type, the documentation for this type would not be generated. Documentation will only be generated for &lt;em&gt;exported&lt;/em&gt; types/procedures/etc.</source>
          <target state="translated">를 빼고 있습니다 &lt;em&gt;*&lt;/em&gt; 유형의 이름 다음에이 유형의 문서가 생성되지 않습니다. &lt;em&gt;내 보낸&lt;/em&gt; 유형 / 프로 시저 등의 문서 만 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="83dc7e0556afc26215f0f05cbb05794c79af8e39" translate="yes" xml:space="preserve">
          <source>Note that you can use &lt;code&gt;gorge&lt;/code&gt; from the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt; to embed parameters from an external command at compile time:</source>
          <target state="translated">당신이 사용할 수있는 참고 &lt;code&gt;gorge&lt;/code&gt; 으로부터 &lt;a href=&quot;system&quot;&gt;시스템 모듈&lt;/a&gt; 컴파일시에 외부 명령에서 포함 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="03602da7fc5f3527dab2cb6a5e9fa3d6f417f9f6" translate="yes" xml:space="preserve">
          <source>Note that you can use this proc inside a pragma like &lt;a href=&quot;manual#implementation-specific-pragmas-passc-pragma&quot;&gt;passc&lt;/a&gt; or &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;passl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;manual#implementation-specific-pragmas-passc-pragma&quot;&gt;passc&lt;/a&gt; 또는 &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;passl&lt;/a&gt; 과 같은 pragma 내에서이 proc을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a75dacd50fe5a788cdf642a67310a4f0cc7d7c77" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;code&gt;args&lt;/code&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;code&gt;command&lt;/code&gt;. In this situation you have to concatenate manually the contents of &lt;code&gt;args&lt;/code&gt; to &lt;code&gt;command&lt;/code&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="translated">&lt;code&gt;poEvalCommand&lt;/code&gt; 옵션을 사용 하면 지정된 &lt;code&gt;command&lt;/code&gt; 을 실행하기 위해 시스템 셸을 호출하는 &lt;code&gt;args&lt;/code&gt; 전달할 수 없습니다 . 이 상황에서 수동의 내용을 연결하는이 &lt;code&gt;args&lt;/code&gt; 하는 &lt;code&gt;command&lt;/code&gt; 이 전달되기 때문에,주의 깊게 특수 문자 / 탈출 인용 &lt;em&gt;같이&lt;/em&gt; 시스템 쉘. 각 시스템 / 쉘은 다른 이스케이프 규칙을 특징으로 할 수 있으므로 이식 불가능한 소프트웨어로 이어 지므로 가능하면 이러한 종류의 쉘 호출을 피하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a8772d3554a687071842e284d2ee1e51238d62e" translate="yes" xml:space="preserve">
          <source>Note that you can't pass any &lt;em&gt;args&lt;/em&gt; if you use the option &lt;code&gt;poEvalCommand&lt;/code&gt;, which invokes the system shell to run the specified &lt;em&gt;command&lt;/em&gt;. In this situation you have to concatenate manually the contents of &lt;em&gt;args&lt;/em&gt; to &lt;em&gt;command&lt;/em&gt; carefully escaping/quoting any special characters, since it will be passed &lt;em&gt;as is&lt;/em&gt; to the system shell. Each system/shell may feature different escaping rules, so try to avoid this kind of shell invocation if possible as it leads to non portable software.</source>
          <target state="translated">&lt;code&gt;poEvalCommand&lt;/code&gt; 옵션을 사용 하면 시스템 쉘을 호출하여 지정된 &lt;em&gt;명령&lt;/em&gt; 을 실행하는 경우 &lt;em&gt;인수를&lt;/em&gt; 전달할 수 없습니다 . 이 상황에서 수동의 내용을 연결하는이 &lt;em&gt;인수를&lt;/em&gt; 하는 &lt;em&gt;명령&lt;/em&gt; 이 전달되기 때문에,주의 깊게 특수 문자 / 탈출 인용 &lt;em&gt;같이&lt;/em&gt; 시스템 쉘. 각 시스템 / 쉘에는 다른 이스케이프 규칙이있을 수 있으므로 휴대용 소프트웨어가 아닌 경우이 유형의 쉘 호출을 피하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d40b1f043c53ab114d44579b20fed14c54f78029" translate="yes" xml:space="preserve">
          <source>Note that you cannot compare a floating point value to this value and expect a reasonable result - use the &lt;code&gt;classify&lt;/code&gt; procedure in the &lt;a href=&quot;math&quot;&gt;math module&lt;/a&gt; for checking for NaN.</source>
          <target state="translated">부동 소수점 값을이 값과 비교할 수 없으며 합리적인 결과를 기대할 수 없습니다 . NaN 확인을 위해 &lt;a href=&quot;math&quot;&gt;math 모듈&lt;/a&gt; 의 &lt;code&gt;classify&lt;/code&gt; 절차를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c5592912b54a15cb049ee1308dc422e794cf8b0" translate="yes" xml:space="preserve">
          <source>Note that, unlike tuples, objects require the field names along with their values. For a &lt;code&gt;ref object&lt;/code&gt; type &lt;code&gt;system.new&lt;/code&gt; is invoked implicitly.</source>
          <target state="translated">튜플과 달리 객체에는 값과 함께 필드 이름이 필요합니다. A에 대한 &lt;code&gt;ref object&lt;/code&gt; 타입 &lt;code&gt;system.new&lt;/code&gt; 암시 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe2a6b6231ef8afd037c1399752e71468fb5fa7" translate="yes" xml:space="preserve">
          <source>Note, single letter options that take an argument require a colon. E.g. -p:PATH.</source>
          <target state="translated">인수를 사용하는 단일 문자 옵션에는 콜론이 필요합니다. 예 : -p : PATH</target>
        </trans-unit>
        <trans-unit id="1a7f5bb7cac3eb28fa52efeaad9afaa0e45fe5ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;a&lt;/code&gt; can only be part of &lt;code&gt;b&lt;/code&gt;, if &lt;code&gt;a&lt;/code&gt;'s type can be part of &lt;code&gt;b&lt;/code&gt;'s type. Since however type analysis is more expensive, we perform it only if necessary.</source>
          <target state="translated">참고 : &lt;code&gt;a&lt;/code&gt; 단지의 일부가 될 수 &lt;code&gt;b&lt;/code&gt; 경우, 의 유형의 일부가 될 수 있습니다 &lt;code&gt;b&lt;/code&gt; 의 유형 '. 그러나 유형 분석은 더 비싸기 때문에 필요한 경우에만 수행합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41b4d4771d7ff34d7e5d420650862df593a32f84" translate="yes" xml:space="preserve">
          <source>Note: Ensure the original #define is not seen by c2nim (notice the #ifndef C2NIM).</source>
          <target state="translated">참고 : c2nim에서 원래 #define을 볼 수 없도록하십시오 (#ifndef C2NIM에 유의).</target>
        </trans-unit>
        <trans-unit id="589daca808645da8bffbebba1f4a3d7ffd0724bc" translate="yes" xml:space="preserve">
          <source>Note: For inter thread communication use a &lt;a href=&quot;channels&quot;&gt;Channel&lt;/a&gt; instead.</source>
          <target state="translated">참고 : 스레드 간 통신의 경우 &lt;a href=&quot;channels&quot;&gt;채널을&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3c98c05550ca8db8ba1bb08e3e1cdb582a3c0958" translate="yes" xml:space="preserve">
          <source>Note: Import &lt;code&gt;std/sha1&lt;/code&gt; to use this module</source>
          <target state="translated">참고 : 이 모듈을 사용하려면 &lt;code&gt;std/sha1&lt;/code&gt; 을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="a3380d8cd20bf5139372befec400003e462558ff" translate="yes" xml:space="preserve">
          <source>Note: In general, auto-converting from int to float loses information, which is why these operators live in a separate module. Use with care.</source>
          <target state="translated">참고 : 일반적으로 int에서 float로 자동 변환하면 정보가 손실되므로 이러한 연산자는 별도의 모듈에 있습니다. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb6ec3757cbbdd1dd0301b680ca419e74971fb18" translate="yes" xml:space="preserve">
          <source>Note: Not available for JS backend.</source>
          <target state="translated">참고 : JS 백엔드에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a4cd3c3e2d987ccf3e1ad62f1c44f6201bc3f26" translate="yes" xml:space="preserve">
          <source>Note: The data types declared here have &lt;em&gt;value semantics&lt;/em&gt;: This means that &lt;code&gt;=&lt;/code&gt; performs a copy of the set.</source>
          <target state="translated">참고 : 여기에 선언 된 데이터 유형에는 &lt;em&gt;값 의미가 있습니다&lt;/em&gt; . 이는 &lt;code&gt;=&lt;/code&gt; 집합의 복사를 수행함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b0b65c5d5f2ba33aefbd25c3c5eb32dd838fe065" translate="yes" xml:space="preserve">
          <source>Note: The pattern refers to the original C identifiers, not to the resulting identifiers after mangling!</source>
          <target state="translated">참고 :이 패턴은 원본 C 식별자를 나타내며, 조작 후 결과 식별자가 아닙니다!</target>
        </trans-unit>
        <trans-unit id="5207456ac36fc3f9063842f9bda281784379b2c6" translate="yes" xml:space="preserve">
          <source>Note: This template may not work in some cases, use &lt;a href=&quot;sugar#capture.m,openArray%5Btyped%5D,untyped&quot;&gt;capture&lt;/a&gt; instead.</source>
          <target state="translated">참고 :이 템플릿은 경우에 따라 작동하지 않을 수 있으므로 대신 &lt;a href=&quot;sugar#capture.m,openArray%5Btyped%5D,untyped&quot;&gt;캡처를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b257114cf6fc959d8954b5a66399cfa481aa015" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;a href=&quot;options#Option&quot;&gt;Option&lt;/a&gt; for keys sometimes missing in json responses, and backticks around keys with a reserved keyword as name.</source>
          <target state="translated">참고 : 가끔 json 응답에서 누락 된 키에 &lt;a href=&quot;options#Option&quot;&gt;Option&lt;/a&gt; 을 사용 하고 예약 된 키워드를 이름으로 사용하는 키 주위에 백틱을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b85936911cd46420f06b600d6cad5d51acfe276f" translate="yes" xml:space="preserve">
          <source>Note: While the rules outlined below are the &lt;em&gt;current&lt;/em&gt; naming conventions, these conventions have not always been in place. Previously, the naming conventions for identifiers followed the Pascal tradition of prefixes which indicated the base type of the identifier - PFoo for pointer and reference types, TFoo for value types, EFoo for exceptions, etc. Though this has since changed, there are many places in the standard library which still use this convention. Such style remains in place purely for legacy reasons, and will be changed in the future.</source>
          <target state="translated">참고 : 아래에 설명 된 규칙은 &lt;em&gt;현재&lt;/em&gt; 명명 규칙이지만 이러한 규칙이 항상 적용되는 것은 아닙니다. 이전에는 식별자의 이름 지정 규칙에 따라 포인터의 기본 유형 인 포인터 및 참조 유형의 경우 PFoo, 값 유형의 경우 TFoo, 예외의 경우 EFoo 등 식별자의 기본 유형을 나타내는 파스칼 전통이 뒤따 랐습니다. 이 규칙을 여전히 사용하는 표준 라이브러리에서. 이러한 스타일은 기존의 이유로 순수하게 유지되며 향후 변경 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="9778d746b0391d7bd7fd0ece0b5cbc7f2a1e15d9" translate="yes" xml:space="preserve">
          <source>Note: XCode's &quot;make clean&quot; gets confused about the generated nim.c files, so you need to clean those files manually to do a clean build.</source>
          <target state="translated">참고 : XCode의 &quot;make clean&quot;은 생성 된 nim.c 파일에 대해 혼란스러워하므로 클린 빌드를 수행하려면 해당 파일을 수동으로 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="34fecedf4653bc748c9340a21b565062d449db86" translate="yes" xml:space="preserve">
          <source>Note: alternate ways of writing this are &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; or as &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt;.</source>
          <target state="translated">참고 : 이것을 쓰는 다른 방법은 &lt;code&gt;b[^8..^2] = &quot;useful&quot;&lt;/code&gt; 또는 &lt;code&gt;b[11..b.len-2] = &quot;useful&quot;&lt;/code&gt; 또는 &lt;code&gt;b[11..&amp;lt;b.len-1] = &quot;useful&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d2a8fe03f1e52e70d949a49deffb7beaa9697e" translate="yes" xml:space="preserve">
          <source>Note: there is a speed improvement if the matches do not need to be captured.</source>
          <target state="translated">참고 : 경기를 캡처 할 필요가없는 경우 속도가 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="b66ebf38768e7530c8d492ade747b6e73d402946" translate="yes" xml:space="preserve">
          <source>Note: this could block if &lt;code&gt;input.len&lt;/code&gt; is greater than your OS's maximum pipe buffer size.</source>
          <target state="translated">참고 : &lt;code&gt;input.len&lt;/code&gt; 이 OS의 최대 파이프 버퍼 크기보다 크면 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e46cb88cb285ad050ff48c315bfe537707654bcc" translate="yes" xml:space="preserve">
          <source>Note: this is mostly outdated, see instead &lt;a href=&quot;nimsuggest&quot;&gt;nimsuggest&lt;/a&gt;</source>
          <target state="translated">참고 : 이것은 대부분 구식입니다. 대신 &lt;a href=&quot;nimsuggest&quot;&gt;nimsuggest를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9e84c20ada2d36c53605b5b42bec5ecb1edbb93" translate="yes" xml:space="preserve">
          <source>Note: to serialize &lt;em&gt;x&lt;/em&gt; to JSON use $(%x) from the &lt;code&gt;json&lt;/code&gt; module</source>
          <target state="translated">참고 : &lt;em&gt;x&lt;/em&gt; 를 JSON 으로 직렬화 하려면 &lt;code&gt;json&lt;/code&gt; 모듈 에서 $ (% x)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="fedfa1aa98f87579b26f162395ec81ac6f49897e" translate="yes" xml:space="preserve">
          <source>Notes when using multiple threads</source>
          <target state="translated">여러 스레드를 사용할 때의 참고 사항</target>
        </trans-unit>
        <trans-unit id="0d40b7a681541c6f19f485d3cc6b34540337a107" translate="yes" xml:space="preserve">
          <source>NotesVerbosity:</source>
          <target state="translated">NotesVerbosity:</target>
        </trans-unit>
        <trans-unit id="a4a2ebf22ba0a60faeb2fdc809dafca8b36c3083" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must be of the same type.</source>
          <target state="translated">그주의 &lt;code&gt;src&lt;/code&gt; 하고 &lt;code&gt;dest&lt;/code&gt; 같은 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5815dccaa90c765a4f2404d7d1dd5b55be738f8c" translate="yes" xml:space="preserve">
          <source>Notice that when exporting, one needs to specify only the module name:</source>
          <target state="translated">내보낼 때 모듈 이름 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb925a84b12636058c161c78db99469a750858b" translate="yes" xml:space="preserve">
          <source>Notices are semantically very similar to info messages, but they are meant to be messages that the user should be actively notified about, depending on the application.</source>
          <target state="translated">알림은 의미 상 정보 메시지와 매우 유사하지만 애플리케이션에 따라 사용자가 적극적으로 알림을 받아야하는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="c599056dda568258fe7a8884f67e29669997a74a" translate="yes" xml:space="preserve">
          <source>Now that we covered the basic control flow statements, let's return to Nim indentation rules.</source>
          <target state="translated">기본 제어 흐름 설명을 다루었으므로 이제 Nim 들여 쓰기 규칙으로 돌아가겠습니다.</target>
        </trans-unit>
        <trans-unit id="359cc1b4d4e1198e58400a2f6178f9956362e79d" translate="yes" xml:space="preserve">
          <source>Now that we use named arguments to call &lt;code&gt;createWindow&lt;/code&gt; the argument order does not matter anymore. Mixing named arguments with ordered arguments is also possible, but not very readable:</source>
          <target state="translated">이제 이름 지정된 인수를 사용하여 &lt;code&gt;createWindow&lt;/code&gt; 를 호출 하므로 인수 순서는 더 이상 중요하지 않습니다. 명명 된 인수와 정렬 된 인수를 혼합하는 것도 가능하지만 읽기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de073aaec09d9a82c0b5660d7283e643aafc1ad4" translate="yes" xml:space="preserve">
          <source>Now the call to &lt;code&gt;createWindow&lt;/code&gt; only needs to set the values that differ from the defaults.</source>
          <target state="translated">이제 &lt;code&gt;createWindow&lt;/code&gt; 를 호출 하면 기본값과 다른 값만 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="37e192255f51d8e35fa4d8c800cc0c72921cf379" translate="yes" xml:space="preserve">
          <source>Now the following holds:</source>
          <target state="translated">이제 다음 내용이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="87081d18a9fcb6da770d34e0fe4d26d7acf23a4c" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_common#SqlQuery&quot;&gt;SqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="translated">이제 SQL 주입 공격에 대한 컴파일 타임 검사가 있습니다. &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; 로 변환 되었기 때문에 멋진 &lt;code&gt;SQL&lt;/code&gt; 문자열 리터럴을 위해 새로운 구문이 필요하지 않습니다 . 가상의 &lt;code&gt;SQL&lt;/code&gt; 의 유형은 실제로 같은 라이브러리에있는 &lt;a href=&quot;db_common#SqlQuery&quot;&gt;은 SQLQuery 유형&lt;/a&gt; 과 같은 모듈의 &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f1e7ee1876e3e297d1a65cb42dae5bbd812f819" translate="yes" xml:space="preserve">
          <source>Now we have compile-time checking against SQL injection attacks. Since &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; is transformed to &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; no new syntax is needed for nice looking &lt;code&gt;SQL&lt;/code&gt; string literals. The hypothetical &lt;code&gt;SQL&lt;/code&gt; type actually exists in the library as the &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;TSqlQuery type&lt;/a&gt; of modules like &lt;a href=&quot;db_sqlite&quot;&gt;db_sqlite&lt;/a&gt;.</source>
          <target state="translated">이제 우리는 SQL 주입 공격에 대해 컴파일 타임을 점검했습니다. &lt;code&gt;&quot;&quot;.SQL&lt;/code&gt; &lt;code&gt;SQL(&quot;&quot;)&lt;/code&gt; 은 SQL ( &quot;&quot;) 로 변환 되므로 멋진 &lt;code&gt;SQL&lt;/code&gt; 문자열 리터럴에 새로운 구문이 필요하지 않습니다 . 가상 &lt;code&gt;SQL&lt;/code&gt; 유형은 실제로 &lt;a href=&quot;db_sqlite#TSqlQuery&quot;&gt;db_sqlite&lt;/a&gt; 와 같은 &lt;a href=&quot;db_sqlite&quot;&gt;TSqlQuery &lt;/a&gt;유형 의 모듈 로 라이브러리에 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2111c104cca92314b6843b4983145b5795a78c" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;bar.nim&lt;/code&gt; is compiled directly, the &lt;code&gt;getProjectPath&lt;/code&gt; will now return the &lt;code&gt;dir2/&lt;/code&gt; path, and the &lt;code&gt;currentSourcePath&lt;/code&gt; will still return the same path, the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="translated">이제 &lt;code&gt;bar.nim&lt;/code&gt; 이 직접 컴파일 될 때 &lt;code&gt;getProjectPath&lt;/code&gt; 는 이제 &lt;code&gt;dir2/&lt;/code&gt; 경로를 반환하고 &lt;code&gt;currentSourcePath&lt;/code&gt; 는 여전히 동일한 경로, 즉 &lt;code&gt;bar.nim&lt;/code&gt; 소스 파일 의 경로를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="08f6d46c0b2b46a621f9252b5aed254ec60a3b55" translate="yes" xml:space="preserve">
          <source>Now when &lt;code&gt;foo.nim&lt;/code&gt; is compiled, the &lt;code&gt;getProjectPath&lt;/code&gt; from &lt;code&gt;bar.nim&lt;/code&gt; will return the &lt;code&gt;dir1/&lt;/code&gt; path, while the &lt;code&gt;currentSourcePath&lt;/code&gt; will return the path to the &lt;code&gt;bar.nim&lt;/code&gt; source file.</source>
          <target state="translated">때 이제 &lt;code&gt;foo.nim&lt;/code&gt; 가 컴파일되면, &lt;code&gt;getProjectPath&lt;/code&gt; 에서 &lt;code&gt;bar.nim&lt;/code&gt; 가 반환됩니다 &lt;code&gt;dir1/&lt;/code&gt; 그동안, 경로를 &lt;code&gt;currentSourcePath&lt;/code&gt; 가 받는 경로를 반환합니다 &lt;code&gt;bar.nim&lt;/code&gt; 소스 파일.</target>
        </trans-unit>
        <trans-unit id="756f1995808a7a657065d45ecdba62e1e4422db8" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources form the Nim code, then link them into a static binary along your main C program:</source>
          <target state="translated">이제 다음과 같은 Unix와 같은 명령을 실행하여 먼저 Nim 코드에서 C 소스를 생성 한 다음 기본 C 프로그램을 따라 정적 바이너리에 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b395673dbacaa4ff7221cdcfe84290edc07b8bb9" translate="yes" xml:space="preserve">
          <source>Now you can run the following Unix like commands to first generate C sources from the Nim code, then link them into a static binary along your main C program:</source>
          <target state="translated">이제 다음 Unix 유사 명령을 실행하여 먼저 Nim 코드에서 C 소스를 생성 한 다음 기본 C 프로그램을 따라 정적 바이너리에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3cf1586c107e2ad157be6c3699e618619c6124a" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 32-bit floating-point type without losing precision.</source>
          <target state="translated">정밀도를 잃지 않고 32 비트 부동 소수점 유형으로 표시 할 수있는 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="f2a4cda872ca90910ea60e675f66d013e1c1c5d2" translate="yes" xml:space="preserve">
          <source>Number of decimal digits that can be represented in a 64-bit floating-point type without losing precision.</source>
          <target state="translated">정밀도를 잃지 않고 64 비트 부동 소수점 유형으로 표현할 수있는 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="1e93ac306e3ccaf06ddd125b223d48515fd601ae" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 32-bit floating-point numbers.</source>
          <target state="translated">32 비트 부동 소수점 숫자의 가수 에서 자릿수 (기본 &lt;code&gt;floatingPointRadix&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="8d111fafd83c57aff8321d904d1159c139884ca1" translate="yes" xml:space="preserve">
          <source>Number of digits (in base &lt;code&gt;floatingPointRadix&lt;/code&gt;) in the mantissa of 64-bit floating-point numbers.</source>
          <target state="translated">64 비트 부동 소수점 숫자의 가수 에서 자릿수 (기본 &lt;code&gt;floatingPointRadix&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="6d57434884838acf9fbf6aa87bb099375ffa68a7" translate="yes" xml:space="preserve">
          <source>Number of whole days represented by the duration.</source>
          <target state="translated">기간으로 표시되는 전체 일수입니다.</target>
        </trans-unit>
        <trans-unit id="bbbf1dbfdd00220f8dc094d6ec5b5e3a5b7eec35" translate="yes" xml:space="preserve">
          <source>Number of whole hours represented by the duration.</source>
          <target state="translated">지속 시간으로 표시되는 전체 시간 수</target>
        </trans-unit>
        <trans-unit id="b3416e7091156db48c9ee6ff7ce55182de3f7f47" translate="yes" xml:space="preserve">
          <source>Number of whole microseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">지속 시간 의 &lt;strong&gt;소수&lt;/strong&gt; 부분으로 표시되는 전체 마이크로 초 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e7efa45f297295912fd59ed47a00f3af6bfa2ef2" translate="yes" xml:space="preserve">
          <source>Number of whole milliseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">지속 시간 의 &lt;strong&gt;소수&lt;/strong&gt; 부분으로 표시되는 전체 밀리 초 수입니다 .</target>
        </trans-unit>
        <trans-unit id="76ab1f8aba37163bdf200dab23553396a7d3e689" translate="yes" xml:space="preserve">
          <source>Number of whole minutes represented by the duration.</source>
          <target state="translated">지속 시간으로 표시되는 전체 분 수입니다.</target>
        </trans-unit>
        <trans-unit id="18290aaf8138cc68a7cb85c476b2a4618ec23b5c" translate="yes" xml:space="preserve">
          <source>Number of whole nanoseconds represented by the &lt;strong&gt;fractional&lt;/strong&gt; part of the duration.</source>
          <target state="translated">지속 시간 의 &lt;strong&gt;분수&lt;/strong&gt; 부분으로 표시되는 전체 나노초 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a01af1e768fd4e093861831d977f5d94b80aa9f9" translate="yes" xml:space="preserve">
          <source>Number of whole seconds represented by the duration.</source>
          <target state="translated">지속 시간으로 표시되는 전체 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="5019b0366e2a30d163a49d5eb75e70470ba3899e" translate="yes" xml:space="preserve">
          <source>Number of whole weeks represented by the duration.</source>
          <target state="translated">기간으로 표시되는 전체 주 수</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="6d872a21aa9a7b7fea7d5fe31a5c2025c54405e4" translate="yes" xml:space="preserve">
          <source>Numbers in of the range -1000.0&amp;lt;f&amp;lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&amp;lt;f&amp;lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, &amp;mu;, n, p etc for numbers with an absolute value less than 1.</source>
          <target state="translated">-1000.0 &amp;lt;f &amp;lt;1000.0 범위의 숫자는 지수없이 형식화됩니다. 이 범위를 벗어난 숫자는 -1000.0 &amp;lt;f &amp;lt;1000.0 범위의 부호로 형식이 지정되고 지수는 SI 접두어 스케일 k, M, G, T 등에 해당하는 항상 3의 정수 배수입니다. 1보다 큰 절대 값과 1보다 작은 절대 값을 가진 숫자의 경우 m, &amp;mu;, n, p 등</target>
        </trans-unit>
        <trans-unit id="76046e581003f2b0494ba6b4f5311bb28033bd96" translate="yes" xml:space="preserve">
          <source>Numeric value representing the day of the month, it will be either one or two digits long.</source>
          <target state="translated">월의 일을 나타내는 숫자 값으로 길이는 1 ~ 2 자리입니다.</target>
        </trans-unit>
        <trans-unit id="de117b3e0329ec2102122ec4b014ce37f5a796cb" translate="yes" xml:space="preserve">
          <source>Numerical constants</source>
          <target state="translated">수치 상수</target>
        </trans-unit>
        <trans-unit id="1e9d4ed2757d3ae1dd279289b3d36043bcba7966" translate="yes" xml:space="preserve">
          <source>Numerical constants are of a single type and have the form:</source>
          <target state="translated">숫자 상수는 단일 유형이며 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14f53cb15d3a159e9414701d05c0d3d0e93ec666" translate="yes" xml:space="preserve">
          <source>Numerical literals are written as in most other languages. As a special twist, underscores are allowed for better readability: &lt;code&gt;1_000_000&lt;/code&gt; (one million). A number that contains a dot (or 'e' or 'E') is a floating point literal: &lt;code&gt;1.0e9&lt;/code&gt; (one billion). Hexadecimal literals are prefixed with &lt;code&gt;0x&lt;/code&gt;, binary literals with &lt;code&gt;0b&lt;/code&gt; and octal literals with &lt;code&gt;0o&lt;/code&gt;. A leading zero alone does not produce an octal.</source>
          <target state="translated">숫자 리터럴은 대부분의 다른 언어로 작성됩니다. 특별한 트위스트로서 더 나은 가독성을 위해 밑줄이 허용됩니다 : &lt;code&gt;1_000_000&lt;/code&gt; (백만). 점 (또는 'e'또는 'E')을 포함하는 숫자는 부동 소수점 리터럴입니다 ( &lt;code&gt;1.0e9&lt;/code&gt; (10 억)). 16 진 리터럴은 &lt;code&gt;0x&lt;/code&gt; 접두사 , &lt;code&gt;0b&lt;/code&gt; 는 2 진 리터럴, &lt;code&gt;0o&lt;/code&gt; 는 8 진 리터럴로 시작 됩니다. 선행 0만으로는 8 진을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c5c7f8404256e0a35e506cca1a7981e7daef170" translate="yes" xml:space="preserve">
          <source>NumericalBase.base10</source>
          <target state="translated">NumericalBase.base10</target>
        </trans-unit>
        <trans-unit id="ccf3ca1a1bb490e927ea05b6581028198ac69592" translate="yes" xml:space="preserve">
          <source>NumericalBase.base16</source>
          <target state="translated">NumericalBase.base16</target>
        </trans-unit>
        <trans-unit id="ee9048563b2785fc2b606907b0087c584930c9f9" translate="yes" xml:space="preserve">
          <source>NumericalBase.base2</source>
          <target state="translated">NumericalBase.base2</target>
        </trans-unit>
        <trans-unit id="ae0213167f6a92377ed9aad1ca56953301053e5c" translate="yes" xml:space="preserve">
          <source>NumericalBase.base8</source>
          <target state="translated">NumericalBase.base8</target>
        </trans-unit>
        <trans-unit id="3d2ccad0a41ad474c931c455f0da38d9969feacd" translate="yes" xml:space="preserve">
          <source>NumericalBase:</source>
          <target state="translated">NumericalBase:</target>
        </trans-unit>
        <trans-unit id="f49726ee7d810f57a9139d6d7df541fd9f684eaf" translate="yes" xml:space="preserve">
          <source>O(n) complexity.</source>
          <target state="translated">O (n) 복잡성.</target>
        </trans-unit>
        <trans-unit id="c04cb3eb98c641516855449fcdbb36cf3f897d21" translate="yes" xml:space="preserve">
          <source>OP0</source>
          <target state="translated">OP0</target>
        </trans-unit>
        <trans-unit id="e04bcfb1ab304010d11e5f6c998c2482bd0d4128" translate="yes" xml:space="preserve">
          <source>OP1</source>
          <target state="translated">OP1</target>
        </trans-unit>
        <trans-unit id="a0f424f70ed0dceb9a4df1bcbbb44ba5f55142ae" translate="yes" xml:space="preserve">
          <source>OP10</source>
          <target state="translated">OP10</target>
        </trans-unit>
        <trans-unit id="c7235db666ae5752cda05330ea4cb5178dc33cc7" translate="yes" xml:space="preserve">
          <source>OP2</source>
          <target state="translated">OP2</target>
        </trans-unit>
        <trans-unit id="0269d7bdbba9ed5972892d3d356a1a3fac87612d" translate="yes" xml:space="preserve">
          <source>OP3</source>
          <target state="translated">OP3</target>
        </trans-unit>
        <trans-unit id="edc0331fa7efd5f99c8d4978274902462f4a77f2" translate="yes" xml:space="preserve">
          <source>OP4</source>
          <target state="translated">OP4</target>
        </trans-unit>
        <trans-unit id="1076f805e66d9538ab3ed3922addefb1313d6fee" translate="yes" xml:space="preserve">
          <source>OP5</source>
          <target state="translated">OP5</target>
        </trans-unit>
        <trans-unit id="ff32e5028e5ac9dd0850a491b15bab66a3070884" translate="yes" xml:space="preserve">
          <source>OP6</source>
          <target state="translated">OP6</target>
        </trans-unit>
        <trans-unit id="c5255cf0231d866ba6a47dd27b61007d7803323f" translate="yes" xml:space="preserve">
          <source>OP7</source>
          <target state="translated">OP7</target>
        </trans-unit>
        <trans-unit id="94fa4343a5ec0348b7ea746f38cbd00d2482ae4f" translate="yes" xml:space="preserve">
          <source>OP8</source>
          <target state="translated">OP8</target>
        </trans-unit>
        <trans-unit id="f373944b57d55ca9eddf4252a4349141943f321e" translate="yes" xml:space="preserve">
          <source>OP9</source>
          <target state="translated">OP9</target>
        </trans-unit>
        <trans-unit id="bea1b7a7bcd9663ab56444c7d74124c17a8fbbfc" translate="yes" xml:space="preserve">
          <source>ORC</source>
          <target state="translated">ORC</target>
        </trans-unit>
        <trans-unit id="99bb1a1563f4d5f5cc3004055e8ee1b82817117f" translate="yes" xml:space="preserve">
          <source>OS-Path normalization. Used by &lt;code&gt;os.nim&lt;/code&gt; but also generally useful for dealing with paths.</source>
          <target state="translated">OS-Path 정규화. 에서 사용 &lt;code&gt;os.nim&lt;/code&gt; 뿐만 아니라 경로를 다루는 일반적으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="380a5dcbfa19547ee9ef2a45f62b8b54d658bbde" translate="yes" xml:space="preserve">
          <source>OS-specific operations</source>
          <target state="translated">OS 별 작업</target>
        </trans-unit>
        <trans-unit id="6b289714645dc080e6d028dce9288aaf44c582e6" translate="yes" xml:space="preserve">
          <source>OS:</source>
          <target state="translated">OS:</target>
        </trans-unit>
        <trans-unit id="e2e3a80c4bd8a468bcd99583c85e67abc6426be7" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming</source>
          <target state="translated">객체 지향 프로그래밍</target>
        </trans-unit>
        <trans-unit id="228b119ddf88904b9df1033a323f6ac211450b69" translate="yes" xml:space="preserve">
          <source>Object access operator &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">객체 접근 연산자 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589a18f6b8265d03c5f8516a6f333a007673bfce" translate="yes" xml:space="preserve">
          <source>Object and array construction</source>
          <target state="translated">개체 및 배열 구성</target>
        </trans-unit>
        <trans-unit id="5558dc9f8bd66c6e283c97f8881f22188449327a" translate="yes" xml:space="preserve">
          <source>Object and array construction is treated as a function call where the function has &lt;code&gt;sink&lt;/code&gt; parameters.</source>
          <target state="translated">객체 및 배열 구성은 함수에 &lt;code&gt;sink&lt;/code&gt; 매개 변수 가있는 함수 호출로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="91ca8083a285ad1c3815b36f3d7992ca6b703603" translate="yes" xml:space="preserve">
          <source>Object construction</source>
          <target state="translated">객체 구성</target>
        </trans-unit>
        <trans-unit id="28b132088e585ec3607bc5ee13d1d17885737336" translate="yes" xml:space="preserve">
          <source>Object field access &lt;code&gt;e.field&lt;/code&gt; is a path expression.</source>
          <target state="translated">개체 필드 액세스 &lt;code&gt;e.field&lt;/code&gt; 는 경로 식입니다.</target>
        </trans-unit>
        <trans-unit id="233bb7b76158a54f9e255a510cc28ac7b239b2dc" translate="yes" xml:space="preserve">
          <source>Object fields and global variables can be annotated via a &lt;code&gt;guard&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt; pragma 를 통해 객체 필드와 전역 변수에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97f4ffdb6041c29c1c6a9a1c4566f9fc24ba1904" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. New object types can only be defined within a type section.</source>
          <target state="translated">정의 모듈 외부에서 볼 수있는 객체 필드는 &lt;code&gt;*&lt;/code&gt; 로 표시해야합니다 . 튜플과 달리 서로 다른 객체 유형은 절대 &lt;em&gt;동일&lt;/em&gt; 하지 않습니다 . 새로운 객체 유형은 유형 섹션 내에서만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5aae1485cba1ac004bf1c390547daf6751e0fcb" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;, they are nominal types whereas tuples are structural. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type information. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="translated">정의 모듈 외부에서 볼 수 있어야하는 개체 필드는 &lt;code&gt;*&lt;/code&gt; 로 표시해야합니다 . 튜플과 달리 다른 객체 유형은 결코 &lt;em&gt;동등&lt;/em&gt; 하지 않으며 명목 유형 인 반면 튜플은 구조적입니다. 조상이없는 객체는 암시 적으로 &lt;code&gt;final&lt;/code&gt; 이므로 숨겨진 유형 정보가 없습니다. &lt;code&gt;inheritable&lt;/code&gt; pragma를 사용하여 &lt;code&gt;system.RootObj&lt;/code&gt; 와는 별도로 새 객체 루트를 도입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0d5262dff32615f0940c3ad8ba0ac64dcad73ed" translate="yes" xml:space="preserve">
          <source>Object fields that should be visible from outside the defining module, have to be marked by &lt;code&gt;*&lt;/code&gt;. In contrast to tuples, different object types are never &lt;em&gt;equivalent&lt;/em&gt;. Objects that have no ancestor are implicitly &lt;code&gt;final&lt;/code&gt; and thus have no hidden type field. One can use the &lt;code&gt;inheritable&lt;/code&gt; pragma to introduce new object roots apart from &lt;code&gt;system.RootObj&lt;/code&gt;.</source>
          <target state="translated">정의 모듈 외부에서 볼 수있는 객체 필드는 &lt;code&gt;*&lt;/code&gt; 로 표시해야합니다 . 튜플과 달리 서로 다른 객체 유형은 절대 &lt;em&gt;동일&lt;/em&gt; 하지 않습니다 . 조상이없는 객체는 암시 적으로 &lt;code&gt;final&lt;/code&gt; 이므로 숨겨진 유형 필드가 없습니다. &lt;code&gt;inheritable&lt;/code&gt; pragma를 사용하여 &lt;code&gt;system.RootObj&lt;/code&gt; 와는 별도로 새로운 객체 루트를 도입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0978d14ec54e6881dd2800cbf0b00efa45a72d10" translate="yes" xml:space="preserve">
          <source>Object variants</source>
          <target state="translated">객체 변형</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="d2c0e1be93b0738e53ee9b0896c747691dcee381" translate="yes" xml:space="preserve">
          <source>Objects can also be created with an &lt;span id=&quot;object-construction-expression_1&quot;&gt;object construction expression&lt;/span&gt; that has the syntax &lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is an &lt;code&gt;object&lt;/code&gt; type or a &lt;code&gt;ref object&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;T(fieldA: valueA, fieldB: valueB, ...)&lt;/code&gt; 구문을 가진 &lt;span id=&quot;object-construction-expression_1&quot;&gt;객체 생성 표현식&lt;/span&gt; 으로 &lt;span id=&quot;object-construction-expression_1&quot;&gt;객체를&lt;/span&gt; 만들 수도 있습니다 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;object&lt;/code&gt; 유형 또는 &lt;code&gt;ref object&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ec43891abad4c5f51b9f1f5052e07c492132c2c3" translate="yes" xml:space="preserve">
          <source>Objects have access to their type at runtime. There is an &lt;code&gt;of&lt;/code&gt; operator that can be used to check the object's type:</source>
          <target state="translated">객체는 런타임에 해당 유형에 액세스 할 수 있습니다. 이 &lt;code&gt;of&lt;/code&gt; 객체 유형을 확인하는 데 사용할 수 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4834206117cd45bf703010b173f8d2ab8b0e8785" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and information hiding. Objects have access to their type at runtime, so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="translated">객체는 튜플이 제공하지 않는 많은 기능을 제공합니다. 개체는 상속과 정보 숨기기를 제공합니다. 객체는 런타임에 해당 유형에 액세스 할 수 있으므로 &lt;code&gt;of&lt;/code&gt; 연산자를 사용하여 객체 유형을 결정할 수 있습니다. &lt;code&gt;of&lt;/code&gt; 운영자는 유사하다 &lt;code&gt;instanceof&lt;/code&gt; 를의 자바 연산자.</target>
        </trans-unit>
        <trans-unit id="50fbd3a1625c6e8ac6633b1b59a260ad1ef17f1e" translate="yes" xml:space="preserve">
          <source>Objects provide many features that tuples do not. Object provide inheritance and the ability to hide fields from other modules. Objects with inheritance enabled have information about their type at runtime so that the &lt;code&gt;of&lt;/code&gt; operator can be used to determine the object's type. The &lt;code&gt;of&lt;/code&gt; operator is similar to the &lt;code&gt;instanceof&lt;/code&gt; operator in Java.</source>
          <target state="translated">객체는 튜플이 제공하지 않는 많은 기능을 제공합니다. 객체는 상속과 다른 모듈에서 필드를 숨기는 기능을 제공합니다. 상속이 활성화 된 객체는 런타임에 해당 유형에 대한 정보를 가지므로 &lt;code&gt;of&lt;/code&gt; 연산자를 사용하여 객체의 유형을 결정할 수 있습니다. &lt;code&gt;of&lt;/code&gt; 운영자는 유사하다 &lt;code&gt;instanceof&lt;/code&gt; 를의 자바 연산자.</target>
        </trans-unit>
        <trans-unit id="d3b16e087c768e899a86532c722c83d0cf81e74b" translate="yes" xml:space="preserve">
          <source>Objects should inherit from &lt;code&gt;RootObj&lt;/code&gt; or one of its descendants. However, objects that have no ancestor are also allowed.</source>
          <target state="translated">객체는 &lt;code&gt;RootObj&lt;/code&gt; 또는 그 하위 항목 중 하나 에서 상속해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 그러나 조상이없는 개체도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0553672f5b32a90c8aef874a5102dc22e01f71a7" translate="yes" xml:space="preserve">
          <source>Objects that contain pointers that point to the same object are not supported by Nim's model. Otherwise swapped objects would end up in an inconsistent state.</source>
          <target state="translated">동일한 객체를 가리키는 포인터를 포함하는 객체는 Nim의 모델에서 지원되지 않습니다. 그렇지 않으면 스왑 된 개체는 일관성없는 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="3c57f97f14e60597fdfd797182b06e968256db96" translate="yes" xml:space="preserve">
          <source>Objects, tuples and references can model quite complex data structures which depend on each other; they are &lt;em&gt;mutually recursive&lt;/em&gt;. In Nim these types can only be declared within a single type section. (Anything else would require arbitrary symbol lookahead which slows down compilation.)</source>
          <target state="translated">객체, 튜플 및 참조는 서로 의존하는 매우 복잡한 데이터 구조를 모델링 할 수 있습니다. 그들은 &lt;em&gt;상호 재귀 적입니다.&lt;/em&gt; 입니다. Nim에서 이러한 유형은 단일 유형 섹션 내에서만 선언 할 수 있습니다. (다른 어떤 것도 컴파일 속도를 늦추는 임의의 기호 미리보기가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="71f640b46a5645b45934608435a884aa861a4b91" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">얻는 순서의 룬 함유 &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d03f5fe1c384210c6971da7941ee56452fb961" translate="yes" xml:space="preserve">
          <source>Obtains a sequence containing the Runes in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 룬이 포함 된 시퀀스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="46ad7ba4d959a6de6e644561408cd88962c2b6f5" translate="yes" xml:space="preserve">
          <source>Obtains the AST nodes returned from a macro or template invocation. Example:</source>
          <target state="translated">매크로 또는 템플릿 호출에서 반환 된 AST 노드를 가져옵니다. 예:</target>
        </trans-unit>
        <trans-unit id="e48a55708577c922dfe1c8727c5015fe59dcd19c" translate="yes" xml:space="preserve">
          <source>Octal format. Outputs the number in base 8.</source>
          <target state="translated">8 진 형식. 기수 8의 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1168d0c029a48fe3aea275c0858b8d7c66a53429" translate="yes" xml:space="preserve">
          <source>OctalEscape</source>
          <target state="translated">OctalEscape</target>
        </trans-unit>
        <trans-unit id="848ceaf7c8a295c627cb93a73ac754f0130154b6" translate="yes" xml:space="preserve">
          <source>Often C and C++ code contains something like the following, where the return value is frequently ignored and so the Nim wrapper should contain a &lt;code&gt;.discardable&lt;/code&gt; pragma:</source>
          <target state="translated">종종 C 및 C ++ 코드에는 다음과 같은 것이 포함됩니다. 반환 값은 자주 무시되므로 Nim 래퍼에는 &lt;code&gt;.discardable&lt;/code&gt; pragma 가 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c85c11c4b42c93c3e7a04193ab3c113033320a61" translate="yes" xml:space="preserve">
          <source>Often C code contains special macros that affect the declaration of a function prototype but confuse c2nim's parser:</source>
          <target state="translated">종종 C 코드에는 함수 프로토 타입의 선언에 영향을 주지만 c2nim의 파서는 혼동되는 특수 매크로가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a8f42ebc1976b2a5351c29b1673e9099dfdbaca1" translate="yes" xml:space="preserve">
          <source>Often a procedure has many parameters and it is not clear in which order the parameters appear. This is especially true for procedures that construct a complex data type. Therefore the arguments to a procedure can be named, so that it is clear which argument belongs to which parameter:</source>
          <target state="translated">프로 시저에는 많은 매개 변수가 있으며 매개 변수가 표시되는 순서가 명확하지 않은 경우가 많습니다. 복잡한 데이터 형식을 구성하는 프로 시저의 경우 특히 그렇습니다. 따라서 프로 시저에 대한 인수의 이름을 지정할 수 있으므로 어떤 인수가 어떤 매개 변수에 속하는지 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a5f3199753bf25f09a786142eab4d142c315045" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is an overkill in certain situations where simple variant types are needed. Object variants are tagged unions discriminated via an enumerated type used for runtime type flexibility, mirroring the concepts of &lt;em&gt;sum types&lt;/em&gt; and &lt;em&gt;algebraic data types (ADTs)&lt;/em&gt; as found in other languages.</source>
          <target state="translated">단순한 변형 유형이 필요한 특정 상황에서는 개체 계층 구조가 과도하게 사용되는 경우가 많습니다. 객체 변형은 런타임 유형 유연성을 위해 사용되는 열거 유형을 통해 구별되는 태그가 지정된 공용체 로, 다른 언어에서 볼 수있는 &lt;em&gt;합계 유형&lt;/em&gt; 및 &lt;em&gt;대수 데이터 유형 (ADT)&lt;/em&gt; 의 개념을 미러링합니다 .</target>
        </trans-unit>
        <trans-unit id="f6395b4ee4a71999d586e3acbee700ed5ca4da87" translate="yes" xml:space="preserve">
          <source>Often an object hierarchy is overkill in certain situations where simple variant types are needed.</source>
          <target state="translated">간단한 변형 유형이 필요한 특정 상황에서는 종종 객체 계층 구조가 과도하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06ebd19cc8bc8c7150cf93f1a6c3d3c1726b3741" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt;, &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; and &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter.</source>
          <target state="translated">종종 고정 크기 배열은 너무 융통성이없는 것으로 판명됩니다. 프로시 저는 다양한 크기의 배열을 처리 할 수 ​​있어야합니다. &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; 유형이 있습니다. Openarray는 항상 0 위치에서 시작 하여 &lt;code&gt;int&lt;/code&gt; 로 색인 됩니다. &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; , &lt;a href=&quot;system#low&quot;&gt;low&lt;/a&gt; 및 &lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; 작업은 개방형 배열에서도 사용할 수 있습니다. 호환되는 기본 유형을 가진 모든 배열은 openarray 매개 변수로 전달 될 수 있으며 인덱스 유형은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b72b9d6119b4da4f2df6e174e7eebce8ade809c0" translate="yes" xml:space="preserve">
          <source>Often fixed size arrays turn out to be too inflexible; procedures should be able to deal with arrays of different sizes. The &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; type allows this; it can only be used for parameters. Openarrays are always indexed with an &lt;code&gt;int&lt;/code&gt; starting at position 0. The &lt;code&gt;len&lt;/code&gt;, &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; operations are available for open arrays too. Any array with a compatible base type can be passed to an openarray parameter, the index type does not matter. In addition to arrays sequences can also be passed to an open array parameter.</source>
          <target state="translated">종종 고정 크기 배열은 너무 융통성이없는 것으로 판명됩니다. 프로시 저는 다양한 크기의 배열을 처리 할 수 ​​있어야합니다. &lt;span id=&quot;openarray_1&quot;&gt;openarray&lt;/span&gt; 유형이 있습니다; 매개 변수에만 사용할 수 있습니다. Openarray는 항상 0 위치에서 시작 하는 &lt;code&gt;int&lt;/code&gt; 로 색인 됩니다. &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;low&lt;/code&gt; 및 &lt;code&gt;high&lt;/code&gt; 작업은 개방형 배열에서도 사용할 수 있습니다. 호환되는 기본 유형을 가진 모든 배열은 openarray 매개 변수로 전달 될 수 있으며 인덱스 유형은 중요하지 않습니다. 어레이 외에도 시퀀스를 개방형 어레이 매개 변수로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="653db7bf1a8cfcc325e38da27b77e167f0e8e1e1" translate="yes" xml:space="preserve">
          <source>Often it is unclear where the method should belong to: is &lt;code&gt;join&lt;/code&gt; a string method or an array method?</source>
          <target state="translated">메소드가 어디에 속해야하는지 불분명하다 : is &lt;code&gt;join&lt;/code&gt; 문자열 방법 또는 배열 방법을?</target>
        </trans-unit>
        <trans-unit id="c448be5e6f2f721a095ce66e4d5d6809129d6a5f" translate="yes" xml:space="preserve">
          <source>Often, you might work with callback-based API-s. You can wrap them with asynchronous procedures using promises and &lt;code&gt;newPromise&lt;/code&gt;:</source>
          <target state="translated">종종 콜백 기반 API로 작업 할 수 있습니다. promise와 &lt;code&gt;newPromise&lt;/code&gt; 를 사용하여 비동기 프로 시저로 랩핑 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="13c64dac54bbedb5367bd67136157fa1cbeaf400" translate="yes" xml:space="preserve">
          <source>Old HTML contains tags that have no end tag: &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; for example.</source>
          <target state="translated">이전 HTML에는 종료 태그가없는 태그가 포함되어 있습니다 ( 예 : &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="6d9b2255ea4766e38b37a3d1d6acbcd79adbbee9" translate="yes" xml:space="preserve">
          <source>Oldest clients supported by this list:</source>
          <target state="translated">이 목록에서 지원하는 가장 오래된 클라이언트 :</target>
        </trans-unit>
        <trans-unit id="4ce7e4551854af6b06b12d4a9f13070d5030d272" translate="yes" xml:space="preserve">
          <source>On OpenSSL &amp;gt;= 1.1.0 this is on by default and cannot be disabled.</source>
          <target state="translated">OpenSSL&amp;gt; = 1.1.0에서는 기본적으로 켜져 있으며 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0ab671e39fd99eba628d677c2b659305d9cd016" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="translated">POSIX에서는 &lt;span id=&quot;glob_1&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 . &lt;code&gt;pattern&lt;/code&gt; 은 OS에 따라 다르지만 최소한 &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; 표기법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7d06d53900d18c0c4d19f86691434ca346457cf3" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="translated">POSIX에서는 &lt;span id=&quot;glob_2&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 . &lt;code&gt;pattern&lt;/code&gt; 은 OS에 따라 다르지만 최소한 &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; 표기법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="58b962bd1576f47b7fbea68a4ac589aea607292c" translate="yes" xml:space="preserve">
          <source>On POSIX this uses the &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; call. &lt;code&gt;pattern&lt;/code&gt; is OS dependent, but at least the &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; notation is supported.</source>
          <target state="translated">POSIX에서는 &lt;span id=&quot;glob_3&quot;&gt;glob&lt;/span&gt; 호출을 사용합니다 . &lt;code&gt;pattern&lt;/code&gt; 은 OS에 따라 다르지만 최소한 &lt;code&gt;&quot;*.ext&quot;&lt;/code&gt; 표기법이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a5aa2ca373f45676714b04347619568162e21bdb" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGKILL&lt;/code&gt; to the process. On Windows &lt;code&gt;kill&lt;/code&gt; is simply an alias for &lt;a href=&quot;#terminate,Process&quot;&gt;terminate()&lt;/a&gt;.</source>
          <target state="translated">Posix OS에서 프로시 저는 &lt;code&gt;SIGKILL&lt;/code&gt; 을 프로세스로 보냅니다 . Windows에서 &lt;code&gt;kill&lt;/code&gt; 은 단순히 &lt;a href=&quot;#terminate,Process&quot;&gt;terminate ()&lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="636bb30d2edfe13bddf1cfddf99dc97b65eee8d3" translate="yes" xml:space="preserve">
          <source>On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="translated">Posix OS에서 프로시 저는 &lt;code&gt;SIGTERM&lt;/code&gt; 을 프로세스로 보냅니다 . Windows에서 Win32 API 함수 &lt;code&gt;TerminateProcess()&lt;/code&gt; 가 호출되어 프로세스를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="b33123903f02b8bf587a5568b29d3def5ad6cd5c" translate="yes" xml:space="preserve">
          <source>On Posix systems, it uses the following parsing rules: Components are separated by whitespace unless the whitespace occurs within &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; quotes.</source>
          <target state="translated">Posix 시스템에서는 다음과 같은 구문 분석 규칙을 사용합니다. 공백이 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 따옴표 로 묶이지 않으면 구성 요소는 공백으로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="834cc319d31095e6fc7d78e7d1c9b23d8c20037d" translate="yes" xml:space="preserve">
          <source>On Unix, you can also use the shebang &lt;code&gt;#!/usr/bin/env nim&lt;/code&gt;, as long as your filename ends with &lt;code&gt;.nims&lt;/code&gt;:</source>
          <target state="translated">Unix에서는 파일 이름이 &lt;code&gt;.nims&lt;/code&gt; 로 끝나는 한 shebang &lt;code&gt;#!/usr/bin/env nim&lt;/code&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca375d55e90a2ca9b205b82e74384bf3a49097b" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.dll&quot; to &lt;code&gt;filename&lt;/code&gt;, on Posix produces &quot;lib$filename.so&quot;.</source>
          <target state="translated">Windows에서는 &quot;.dll&quot;을 &lt;code&gt;filename&lt;/code&gt; 에 추가 하고 Posix에서는 &quot;lib $ filename.so&quot;를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ffbafa0f673264a750ef0cf50fe66c11c098cd82" translate="yes" xml:space="preserve">
          <source>On Windows adds &quot;.exe&quot; to &lt;code&gt;filename&lt;/code&gt;, else returns &lt;code&gt;filename&lt;/code&gt; unmodified.</source>
          <target state="translated">Windows에서는 &quot;.exe&quot;를 &lt;code&gt;filename&lt;/code&gt; 추가 하고 그렇지 않으면 수정되지 않은 &lt;code&gt;filename&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="131615a38d5f682e627f291b00695b764612c48b" translate="yes" xml:space="preserve">
          <source>On Windows this is a noop, &lt;code&gt;symlinkPath&lt;/code&gt; is simply returned.</source>
          <target state="translated">Windows에서 이것은 noop이며 &lt;code&gt;symlinkPath&lt;/code&gt; 가 단순히 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="05672aecf27340137fd58647ae2456a227fa831f" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Windows에서이 proc은 이미 속성을 복사하기 때문에 &lt;a href=&quot;#copyDir,string,string&quot;&gt;copyDir proc&lt;/a&gt; 의 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="d5fa250d69a315e525601b1f7e96a5b8019564e1" translate="yes" xml:space="preserve">
          <source>On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile proc&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">Windows에서이 proc은 이미 속성을 복사하기 때문에 &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile proc&lt;/a&gt; 의 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="70ce96c0b5b17afe1bacf0b1747928e53aaa71eb" translate="yes" xml:space="preserve">
          <source>On Windows, a file is hidden if the file's 'hidden' attribute is set. On Unix-like systems, a file is hidden if it starts with a '.' (period) and is not &lt;em&gt;just&lt;/em&gt; '.' or '..' ' .&quot;</source>
          <target state="translated">Windows에서 파일의 'hidden'속성이 설정되면 파일이 숨겨집니다. 유닉스 계열 시스템에서 파일은 '.'로 시작하면 숨겨집니다. (기간) 및 아닌 &lt;em&gt;단지&lt;/em&gt; '.' 또는 '..' '. &quot;</target>
        </trans-unit>
        <trans-unit id="be2b5ddfadb7e844935b3f58931b5fdf015b4ffa" translate="yes" xml:space="preserve">
          <source>On Windows, ignores the read-only attribute.</source>
          <target state="translated">Windows에서는 읽기 전용 속성을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d219ef8a6a1662c16fa1ad9a9fb14a71aa03b00f" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;following parsing rules&lt;/a&gt;:</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;다음 구문 분석 규칙을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b49455f655e6af02510b37b400ad079bda32fcf9" translate="yes" xml:space="preserve">
          <source>On Windows, it uses the following parsing rules (see &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; ):</source>
          <target state="translated">Windows에서는 다음 구문 분석 규칙을 사용합니다 ( &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="2d9112d9c390a489d1abe81e704b96328351c744" translate="yes" xml:space="preserve">
          <source>On Windows, network paths are considered absolute too.</source>
          <target state="translated">Windows에서는 네트워크 경로도 절대적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ac5b0f8c13e69a83282367b11b7a62a054b16852" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;-d:useWinAnsi&lt;/code&gt; compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</source>
          <target state="translated">Windows에서는 &lt;code&gt;-d:useWinAnsi&lt;/code&gt; 컴파일 플래그를 사용하여이 프로 시저가 비 유니 코드 Win API 호출을 사용하여 메시지를 검색하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4001f01f1a00f62db5ba5d2ddb394bcb0fbc5ede" translate="yes" xml:space="preserve">
          <source>On Windows: returns true if it exists and its &quot;hidden&quot; attribute is set.</source>
          <target state="translated">Windows : 존재하고 &quot;hidden&quot;속성이 설정된 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7fd69f94a373ae6ea79b01a75e59c435ad639d26" translate="yes" xml:space="preserve">
          <source>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</source>
          <target state="translated">대소 문자를 구분하는 파일 시스템에서는 대소 문자를 구분하지 않고 대소 문자를 구분합니다. 보고:</target>
        </trans-unit>
        <trans-unit id="c8469f270e6308a5204d808346468ba7e32ce5ba" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</source>
          <target state="translated">UNIX 시스템에서는 아무 것도 수행하지 않습니다. 그렇지 않으면 '/', '.', '..'을 적절한 것으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ce6e6ab795a177a2429d9448acf045ddddf42374" translate="yes" xml:space="preserve">
          <source>On an UNIX system this does nothing. Else it converts &lt;code&gt;'/'&lt;/code&gt;, &lt;code&gt;'.'&lt;/code&gt;, &lt;code&gt;'..'&lt;/code&gt; to the appropriate things.</source>
          <target state="translated">UNIX 시스템에서는 아무 작업도 수행하지 않습니다. 그렇지 않으면 &lt;code&gt;'/'&lt;/code&gt; , &lt;code&gt;'.'&lt;/code&gt; 를 변환 합니다. , &lt;code&gt;'..'&lt;/code&gt; 적절한 것들에.</target>
        </trans-unit>
        <trans-unit id="410676d7292fbbcf827b204fd9a0c07b3ffe5980" translate="yes" xml:space="preserve">
          <source>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</source>
          <target state="translated">분기 예측이없는 백엔드 (JS 및 nimscript VM)에서이 템플릿은 코드 실행에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71349d230261d02d2bc3058f2f163656370a285c" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">Windows 이외의 시스템에서는 파일 자체가 복사 된 후 권한이 복사되며, 이는 원자 적으로 발생하지 않으며 경쟁 조건을 유발할 수 있습니다. &lt;em&gt;ignorePermissionErrors&lt;/em&gt; 가 true 인 경우 파일 속성을 읽거나 설정하는 동안 발생하는 오류는 무시되고 그렇지 않으면 &lt;em&gt;OSError가 발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b26734ed023d711198160409aa5df1de55e088f2" translate="yes" xml:space="preserve">
          <source>On non Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;em&gt;ignorePermissionErrors&lt;/em&gt; is true, errors while reading/setting file attributes will be ignored, otherwise will raise &lt;em&gt;OSError&lt;/em&gt;.</source>
          <target state="translated">Windows 이외의 시스템에서는 파일 또는 디렉토리 자체가 복사 된 후 권한이 복사되며, 이는 원자 적으로 발생하지 않으며 경쟁 조건을 유발할 수 있습니다. &lt;em&gt;ignorePermissionErrors&lt;/em&gt; 가 true 인 경우 파일 속성을 읽거나 설정하는 동안 발생하는 오류는 무시되고 그렇지 않으면 &lt;em&gt;OSError가 발생합니다.&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9214590a8005bcbc988e94c2ff34b8e0671fd615" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable if it is set, otherwise it returns the default configuration directory (&quot;~/.config/&quot;).</source>
          <target state="translated">Windows가 아닌 OS에서이 proc은 XDG 기본 디렉토리 사양을 따릅니다. 따라서이 proc 은 설정된 경우 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수 의 값을 반환하고 , 그렇지 않으면 기본 구성 디렉터리 ( &quot;~ / .config /&quot;)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd5345a8b53344aaa0863f04f717114c18227851" translate="yes" xml:space="preserve">
          <source>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_CONFIG_HOME environment variable if it is set, and returns the default configuration directory, &quot;~/.config/&quot;, otherwise.</source>
          <target state="translated">Windows 이외의 OS에서이 절차는 XDG 기본 디렉토리 사양을 따릅니다. 따라서이 proc은 설정된 경우 XDG_CONFIG_HOME 환경 변수의 값을 리턴하고 기본 구성 디렉토리 인 &quot;~ / .config /&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1ef1878800148722a52d11621bb2995a19e795fa" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="translated">Windows가 아닌 시스템에서는 파일 자체가 복사 된 후에 권한이 복사되며, 이는 원자 적으로 발생하지 않으며 경쟁 조건으로 이어질 수 있습니다. 경우 &lt;code&gt;ignorePermissionErrors&lt;/code&gt; 이 (기본값)에 해당하는 읽기 / 설정 파일 특성이 무시됩니다 반면, 오류, 그렇지 않으면 올릴 것이다 &lt;code&gt;OSError&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7826bbb956520ceecb8ab7c01c0eac14d107b3b2" translate="yes" xml:space="preserve">
          <source>On non-Windows systems permissions are copied after the file or directory itself has been copied, which won't happen atomically and could lead to a race condition. If &lt;code&gt;ignorePermissionErrors&lt;/code&gt; is true (default), errors while reading/setting file attributes will be ignored, otherwise will raise &lt;code&gt;OSError&lt;/code&gt;.</source>
          <target state="translated">Windows가 아닌 시스템에서는 파일 또는 디렉토리 자체가 복사 된 후에 권한이 복사되며, 이는 원자 적으로 발생하지 않으며 경쟁 조건으로 이어질 수 있습니다. 경우 &lt;code&gt;ignorePermissionErrors&lt;/code&gt; 이 (기본값)에 해당하는 읽기 / 설정 파일 특성이 무시됩니다 반면, 오류, 그렇지 않으면 올릴 것이다 &lt;code&gt;OSError&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d198733f6e75c57f15a08ce67d688e4a62009004" translate="yes" xml:space="preserve">
          <source>On other platforms created files and directories will inherit the default permissions of a newly created file/directory for the user. Use &lt;a href=&quot;#copyDirWithPermissions,string,string&quot;&gt;copyDirWithPermissions proc&lt;/a&gt; to preserve attributes recursively on these platforms.</source>
          <target state="translated">다른 플랫폼에서 생성 된 파일 및 디렉토리는 사용자를 위해 새로 생성 된 파일 / 디렉토리의 기본 권한을 상속합니다. 이러한 플랫폼에서 속성을 재귀 적으로 보존 하려면 &lt;a href=&quot;#copyDirWithPermissions,string,string&quot;&gt;copyDirWithPermissions proc&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bb66bc173e5cea45d224b1d00e5c254cf51c117" translate="yes" xml:space="preserve">
          <source>On other platforms you need to use &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs to copy them by hand (or use the convenience &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions proc&lt;/a&gt;), otherwise &lt;code&gt;dest&lt;/code&gt; will inherit the default permissions of a newly created file for the user.</source>
          <target state="translated">다른 플랫폼에서는 &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; 및 &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs를 사용하여 수동으로 복사해야합니다 (또는 편리한 &lt;a href=&quot;#copyFileWithPermissions,string,string&quot;&gt;copyFileWithPermissions proc 사용&lt;/a&gt; ). 그렇지 않으면 &lt;code&gt;dest&lt;/code&gt; 가 사용자를 위해 새로 생성 된 파일의 기본 권한을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="898bf4553278bc34226081a98acca7cca2299308" translate="yes" xml:space="preserve">
          <source>On posix this will search through the &lt;code&gt;/etc/services&lt;/code&gt; file.</source>
          <target state="translated">posix에서는 &lt;code&gt;/etc/services&lt;/code&gt; 를 통해 검색 합니다 파일을 합니다.</target>
        </trans-unit>
        <trans-unit id="c51ed0629b09b2b1d09d42b4681c845de22a12d3" translate="yes" xml:space="preserve">
          <source>On posix, if the process has exited because of a signal, 128 + signal number will be returned.</source>
          <target state="translated">posix에서 신호로 인해 프로세스가 종료되면 128 + 신호 번호가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="db8215b423ef9bc86e0c61cb1eee5873cfe33f7d" translate="yes" xml:space="preserve">
          <source>On posix: returns true if &lt;code&gt;lastPathPart(path)&lt;/code&gt; starts with &lt;code&gt;.&lt;/code&gt; and is not &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">posix에서 : &lt;code&gt;lastPathPart(path)&lt;/code&gt; 가 &lt;code&gt;.&lt;/code&gt; 및 아닙니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3c38d17d46151c5d354197efeee10f8d783f2b" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (..) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="translated">상대 경로에서 가능한 경우 이중 도트 (..) 시퀀스가 ​​축소됩니다. 절대 경로에서는 항상 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3d50c97cdc169f61ed97cda00a458b0a518724" translate="yes" xml:space="preserve">
          <source>On relative paths, double dot (&lt;code&gt;..&lt;/code&gt;) sequences are collapsed if possible. On absolute paths they are always collapsed.</source>
          <target state="translated">상대 경로에서 이중 점 ( &lt;code&gt;..&lt;/code&gt; ) 시퀀스는 가능한 경우 축소됩니다. 절대 경로에서는 항상 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="0cd0de97e21f18a70dc40d4ea02d3e032d1e6822" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;code&gt;drive&lt;/code&gt; is used to determine which drive label to use during absolute path conversion. &lt;code&gt;drive&lt;/code&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="translated">&quot;드라이브&quot;개념이있는 시스템에서 &lt;code&gt;drive&lt;/code&gt; 는 절대 경로 변환 중에 사용할 드라이브 레이블을 결정하는 데 사용됩니다. &lt;code&gt;drive&lt;/code&gt; 기본값은 현재 작업 디렉토리의 드라이브이며 &quot;드라이브&quot;개념이없는 시스템에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d20fce5143547ae9c280f86e85a7f988d0055a8f" translate="yes" xml:space="preserve">
          <source>On systems with a concept of &quot;drives&quot;, &lt;em&gt;drive&lt;/em&gt; is used to determine which drive label to use during absolute path conversion. &lt;em&gt;drive&lt;/em&gt; defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of &quot;drives&quot;.</source>
          <target state="translated">&quot;드라이브&quot;라는 개념을 가진 시스템에서 &lt;em&gt;드라이브&lt;/em&gt; 는 절대 경로 변환 중에 사용할 드라이브 레이블을 결정하는 데 사용됩니다. &lt;em&gt;drive&lt;/em&gt; 는 현재 작업 디렉토리의 &lt;em&gt;드라이브로&lt;/em&gt; 기본 설정되며 &quot;드라이브&quot;개념이없는 시스템에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="919f238a50bd9c8a0b4c8aebc53de677589c1bbb" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the attributes from &lt;code&gt;source&lt;/code&gt; into &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">Windows 플랫폼에서이 proc은 &lt;code&gt;source&lt;/code&gt; 에서 &lt;code&gt;dest&lt;/code&gt; 로 속성을 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="632c6c96343e057ab2f11cb26fae25368444d555" translate="yes" xml:space="preserve">
          <source>On the Windows platform this proc will copy the source file's attributes into dest.</source>
          <target state="translated">Windows 플랫폼에서이 proc은 소스 파일의 속성을 dest에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e3e27ced0560e6c76c802fe94e33423bf08b2b55" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;code&gt;spread&lt;/code&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="translated">반면에 &lt;code&gt;spread&lt;/code&gt; 가 참이면 proc은 모든 시퀀스에 걸쳐 나머지 분할을 균등하게 분배하므로 동일한 크기의 작업 단위를 스레드 풀로 전달하고 코어 사용을 최대화하려는 멀티 스레딩에 결과가 더 적합합니다. .</target>
        </trans-unit>
        <trans-unit id="4b3066034f3e12801386284630d4449cf120d021" translate="yes" xml:space="preserve">
          <source>On the other hand, if &lt;em&gt;spread&lt;/em&gt; is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage.</source>
          <target state="translated">반면에, &lt;em&gt;산포&lt;/em&gt; 가 사실이면, proc은 모든 시퀀스에 걸쳐 나머지 디비전을 균등하게 분배하므로 동일한 크기의 작업 단위를 스레드 풀에 전달하고 코어 사용을 최대화하려는 멀티 스레딩에 더 적합합니다. .</target>
        </trans-unit>
        <trans-unit id="317e86312cac8e36e1b7e5107ff34ed5cc4b1895" translate="yes" xml:space="preserve">
          <source>On the other hand, in Nim's future I would like to replace the VM by native code. A diff algorithm wouldn't work for that. Instead the native code would work with an API like &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">반면 Nim의 미래에는 VM을 기본 코드로 교체하고 싶습니다. diff 알고리즘은 작동하지 않습니다. 대신 네이티브 코드가 같은 API와 함께 일하는 것이 &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="15cc13f1907198262a48b2f1247b799d1650a03d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;code&gt;RingBuffer&lt;/code&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="translated">반면에 위 의 &lt;code&gt;RingBuffer&lt;/code&gt; 예제에서 지정된 제네릭 매개 변수는 포인터가 아닌 &lt;code&gt;seq&lt;/code&gt; 유형 을 인스턴스화하는 데 사용됩니다. 즉, 결과 제네릭 유형은 배열 또는 시퀀스를 모방하는 공분산을 갖게됩니다 (즉, &lt;code&gt;ptr&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 유형으로 인스턴스화 됨 ) :</target>
        </trans-unit>
        <trans-unit id="c25df01f5e813eafaaa5663850dd783a4040697d" translate="yes" xml:space="preserve">
          <source>On the other hand, in the &lt;em&gt;RingBuffer&lt;/em&gt; example above, the designated generic param is used to instantiate the non-pointer &lt;code&gt;seq&lt;/code&gt; type, which means that the resulting generic type will have covariance that mimics an array or sequence (i.e. it will be covariant only when instantiated with &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt; types):</source>
          <target state="translated">반면, 위 의 &lt;em&gt;RingBuffer&lt;/em&gt; 예제에서 지정된 제네릭 매개 변수는 포인터가 아닌 &lt;code&gt;seq&lt;/code&gt; 유형 을 인스턴스화하는 데 사용됩니다. 즉, 결과 제네릭 유형은 배열 또는 시퀀스를 모방하는 공분산을 갖게됩니다 (즉, &lt;code&gt;ptr&lt;/code&gt; 및 &lt;code&gt;ref&lt;/code&gt; 유형으로 인스턴스화 됨 ) :</target>
        </trans-unit>
        <trans-unit id="9c4aef9144f0f23eb3dbf979b7ad1a6367db8432" translate="yes" xml:space="preserve">
          <source>On the other hand, using &lt;code&gt;bind once&lt;/code&gt; types allows you to test for equivalent types used in multiple signatures, without actually requiring any concrete types, thus allowing you to encode implementation-defined types:</source>
          <target state="translated">반면에 &lt;code&gt;bind once&lt;/code&gt; 사용 하면 유형을 사용하면 실제로 구체적인 유형을 요구하지 않고 여러 서명에 사용 된 동등한 유형을 테스트 할 수 있으므로 구현 정의 유형을 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba138949d4841696388d7021ef9a2601c30eef7" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;TableRef&lt;/code&gt; instead, then changes to &lt;code&gt;b&lt;/code&gt; also affect &lt;code&gt;a&lt;/code&gt;. Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;&lt;strong&gt;ref&lt;/strong&gt; the same data structure:</source>
          <target state="translated">때 다른 한편으로는, &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;TableRef&lt;/code&gt; 를 대신 다음의 변경 &lt;code&gt;b&lt;/code&gt; 영향도 &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 동일한 데이터 구조를 &lt;strong&gt;참조&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d13d679112fedc32342b16f2848339011424e35e" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;em&gt;a&lt;/em&gt; is a TableRef instead, then changes to &lt;em&gt;b&lt;/em&gt; also affect &lt;em&gt;a&lt;/em&gt;. Both &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; reference the same data structure:</source>
          <target state="translated">때 다른 한편으로는, &lt;em&gt;A가&lt;/em&gt; 대신 TableRef이다, 다음의 변경 &lt;em&gt;ㄱ&lt;/em&gt; 영향도 &lt;em&gt;을&lt;/em&gt; . &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b &lt;/em&gt;&lt;em&gt;는&lt;/em&gt; 모두 동일한 데이터 구조를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="37d18afb7f631d26e467ad1c5e79cc58b688edd5" translate="yes" xml:space="preserve">
          <source>On top of generating libraries or standalone applications, Nim offers bidirectional interfacing with the backend targets through generic and specific pragmas.</source>
          <target state="translated">라이브러리 또는 독립형 응용 프로그램 생성 외에도 Nim은 일반 및 특정 pragma를 통해 백엔드 대상과 양방향 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c81da6451dca2da62ae25f6caf1eff5bac5311d0" translate="yes" xml:space="preserve">
          <source>On top of that, there is also the &lt;code&gt;typ&lt;/code&gt; field for the type. It the kind of the &lt;code&gt;typ&lt;/code&gt; field can be one of the following ones, and it should be matching the literal kind:</source>
          <target state="translated">그 위에 유형에 대한 &lt;code&gt;typ&lt;/code&gt; 필드 도 있습니다 . 그것은의 종류 &lt;code&gt;typ&lt;/code&gt; 필드는 다음과 같은 것들 중 하나가 될 수 있고, 문자 그대로의 종류와 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="77c2d48642cb046e2bbc4639d90dcf6445b4e94f" translate="yes" xml:space="preserve">
          <source>On windows, if a root of &lt;code&gt;path&lt;/code&gt; and a root of &lt;code&gt;base&lt;/code&gt; are different, returns &lt;code&gt;path&lt;/code&gt; as is because it is impossible to make a relative path. That means an absolute path can be returned.</source>
          <target state="translated">윈도우에서 &lt;code&gt;path&lt;/code&gt; 의 루트와 &lt;code&gt;base&lt;/code&gt; 의 루트 가 다르면 상대 경로를 만들 수 없기 때문에 &lt;code&gt;path&lt;/code&gt; 그대로 반환 합니다. 즉, 절대 경로를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bab18c0b5501aadd3a3af3f1ceb793c3f49cf6f2" translate="yes" xml:space="preserve">
          <source>OnHeap:</source>
          <target state="translated">OnHeap:</target>
        </trans-unit>
        <trans-unit id="568f54818fab1d16943bd423920f09da70e89138" translate="yes" xml:space="preserve">
          <source>OnStack:</source>
          <target state="translated">OnStack:</target>
        </trans-unit>
        <trans-unit id="db6805e8c7cfbc2552a2ae4ead1110380c4f8151" translate="yes" xml:space="preserve">
          <source>OnStatic:</source>
          <target state="translated">OnStatic:</target>
        </trans-unit>
        <trans-unit id="15222cc1cfca09f665b5c4bd79a604c8a5fda245" translate="yes" xml:space="preserve">
          <source>OnUnknown:</source>
          <target state="translated">OnUnknown:</target>
        </trans-unit>
        <trans-unit id="b55aab0a049cabc5b434393773f26e77af86b5f9" translate="yes" xml:space="preserve">
          <source>Once a logger has been created, call its &lt;a href=&quot;#log.e,ConsoleLogger,Level,varargs%5Bstring,%5D&quot;&gt;log proc&lt;/a&gt; to log a message:</source>
          <target state="translated">로거가 생성되면 &lt;a href=&quot;#log.e,ConsoleLogger,Level,varargs%5Bstring,%5D&quot;&gt;log proc&lt;/a&gt; 을 호출 하여 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e8edce91442634d7387fe386cb073a4a709ecff8" translate="yes" xml:space="preserve">
          <source>Once bound, type params can appear in the rest of the proc signature:</source>
          <target state="translated">바인드되면, 유형 매개 변수가 나머지 proc 서명에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609040b49e0851c8e7801cc6b5b773d38bc4bba4" translate="yes" xml:space="preserve">
          <source>Once declared, a constant's symbol can be used as a constant expression.</source>
          <target state="translated">일단 선언되면 상수의 기호를 상수 표현식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b47a60e99f1394d99a1c045b8c28b67a9fc8f6a" translate="yes" xml:space="preserve">
          <source>Once everything is registered in a dispatcher, you need to call the &lt;code&gt;poll&lt;/code&gt; function in a while loop.</source>
          <target state="translated">디스패처에 모든 것이 등록되면 while 루프에서 &lt;code&gt;poll&lt;/code&gt; 함수 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5654d82c2a3884c2cbc3f1c679468b9597dacae" translate="yes" xml:space="preserve">
          <source>Once index files have been generated for one or more modules, the Nim compiler command &lt;code&gt;buildIndex directory&lt;/code&gt; can be run to go over all the index files in the specified directory to generate a &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; file.</source>
          <target state="translated">인덱스 파일이 하나 개 이상의 모듈에 대해 생성 된 후에는 님 컴파일러 명령 &lt;code&gt;buildIndex directory&lt;/code&gt; 를 생성하기 위해 지정된 디렉토리에있는 모든 인덱스 파일을 통해 갈 실행할 수 있습니다 &lt;a href=&quot;https://nim-lang.org/docs/theindex.html&quot;&gt;theindex.html&lt;/a&gt; 파일 있습니다.</target>
        </trans-unit>
        <trans-unit id="9093fbfa7147de35adc3e237969b8a5f741293d8" translate="yes" xml:space="preserve">
          <source>Once the current log file being written to contains &lt;code&gt;maxLines&lt;/code&gt; lines, a new log file will be created, and the old log file will be renamed.</source>
          <target state="translated">기록중인 현재 로그 파일에 &lt;code&gt;maxLines&lt;/code&gt; 행 이 포함 되면 새 로그 파일이 생성되고 이전 로그 파일의 이름이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="e60efbade01d07951321fcb62a711c7c0a4d46ba" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;code&gt;JsonNode&lt;/code&gt;, retrieving the values can then be achieved by using one of the helper procedures, which include:</source>
          <target state="translated">당신은 일단 &lt;code&gt;JsonNode&lt;/code&gt; 를 , 값을 검색하는 것은 다음을 포함 도우미 절차 중 하나를 사용하여 달성 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="ba237fb6a97d475a345fe56549779371d65c0b14" translate="yes" xml:space="preserve">
          <source>Once you have code like this in place, if the list of raised exception changes the compiler will stop with an error specifying the line of the proc which stopped validating the pragma and the raised exception not being caught, along with the file and line where the uncaught exception is being raised, which may help you locate the offending code which has changed.</source>
          <target state="translated">이와 같은 코드가 작성되면, 발생한 예외 목록이 변경되면 컴파일러는 pragma 유효성 검사를 중지 한 proc의 행을 지정하고 발생한 예외 및 파일 및 행과 함께 발생하지 않는 예외를 지정하는 오류와 함께 중지됩니다. 잡히지 않은 예외가 발생하여 변경된 문제 코드를 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e837030f84dd416a1763c3313ad3b60179285a22" translate="yes" xml:space="preserve">
          <source>Once your code is compiled for hot reloading, you can use a framework such as &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; or &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;&lt;/em&gt; to implement the actual reloading behavior in your project.</source>
          <target state="translated">핫 리로딩을 위해 코드가 컴파일되면 &lt;em&gt;LiveReload &amp;lt;http://livereload.com/&amp;gt;&lt;/em&gt; 또는 &lt;em&gt;BrowserSync &amp;lt;https://browsersync.io/&amp;gt;&lt;/em&gt; 와 같은 프레임 워크를 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt; 하여 프로젝트에서 실제 리로딩 동작을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d92002386ccab2c66af44a60e6f00bc53d2d7b" translate="yes" xml:space="preserve">
          <source>Once your macro is finished, there are two ways to invoke it:</source>
          <target state="translated">매크로가 완료되면 두 가지 방법으로 매크로를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95e6032530fcbf63e3fb9d935e3a4900b15a008" translate="yes" xml:space="preserve">
          <source>One can force an expression to be evaluated at compile time as a constant expression by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="translated">컴파일 타임에 표현식을 해당 &lt;code&gt;static&lt;/code&gt; 유형 으로 강제 변환하여 상수 표현식으로 평가하도록 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c83e207267fa148c2a0ca5ddf816169f22ace210" translate="yes" xml:space="preserve">
          <source>One can obtain the type of a given expression by constructing a &lt;code&gt;typeof&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 값을 구성하여 주어진 표현식의 유형을 얻을 수 있습니다 (다른 많은 언어에서는 &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; 연산자 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="fe69f9cd71b11c831e91b58e239cae9c34d55dc8" translate="yes" xml:space="preserve">
          <source>One can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="translated">special &lt;code&gt;:&lt;/code&gt; 구문을 따르는 템플릿에 마지막 인수로 문장 블록을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e2e14b82a6a078671a4c4d9c4519514eb953104" translate="yes" xml:space="preserve">
          <source>One can tell the compiler about the convention that a parameter of name &lt;code&gt;c&lt;/code&gt; should default to type &lt;code&gt;Context&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; should default to &lt;code&gt;Node&lt;/code&gt; etc.:</source>
          <target state="translated">컴파일러에 이름 &lt;code&gt;c&lt;/code&gt; 의 매개 변수 는 기본적으로 &lt;code&gt;Context&lt;/code&gt; 유형으로 , &lt;code&gt;n&lt;/code&gt; 은 기본적으로 &lt;code&gt;Node&lt;/code&gt; 등 으로 설정해야한다는 규칙에 대해 알려줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b441a31745d56840471825f544c92905083aa43a" translate="yes" xml:space="preserve">
          <source>One can use &lt;span id=&quot;tuple-unpacking_1&quot;&gt;tuple unpacking&lt;/span&gt; to access the tuple's fields:</source>
          <target state="translated">&lt;span id=&quot;tuple-unpacking_1&quot;&gt;튜플 포장 풀기&lt;/span&gt; 를 사용하여 튜플의 필드에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0aae6e8e4a31c5c278e8ef5e9e83aa14fc870267" translate="yes" xml:space="preserve">
          <source>One can use a temporary helper variable, for example instead of &lt;code&gt;x = p(8)&lt;/code&gt; use &lt;code&gt;let tmp = p(8); x = tmp&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;x = p(8)&lt;/code&gt; 대신 임시 도우미 변수를 사용할 수 있습니다. use &lt;code&gt;let tmp = p(8); x = tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6393931ab1901888c2c40493d5e9e26b0c1998b" translate="yes" xml:space="preserve">
          <source>One of Nim's cool features is pragmas, which allow fine-tuning of various aspects of the language. They come in all types, such as adorning procs and objects, but the standalone &lt;code&gt;emit&lt;/code&gt; pragma shows the basics with the AST.</source>
          <target state="translated">님의 멋진 기능 중 하나는 언어의 다양한 측면을 미세 조정할 수있는 프라 그마입니다. 그것들은 장식적인 물건들과 물건들과 같은 모든 유형으로 제공되지만, 독립형 &lt;code&gt;emit&lt;/code&gt; pragma는 AST의 기본 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">하나 이상</target>
        </trans-unit>
        <trans-unit id="2e948a81e04389675a5a97047baf132370163826" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;code&gt;E&lt;/code&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="translated">하나 이상 : 성공하는 한 앞의 텍스트와 일치하도록 표현식 &lt;code&gt;E&lt;/code&gt; 를 반복적으로 적용 합니다. 일치하는 텍스트 (있는 경우)를 사용하고 일치하는 항목이 하나 이상 있으면 성공을 표시합니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2207e76c212f3f40ba5c67c82dea4cf30adfcd7c" translate="yes" xml:space="preserve">
          <source>One or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any) and indicate success if there was at least one match. Otherwise indicate failure.</source>
          <target state="translated">하나 이상 : 텍스트 &lt;em&gt;E&lt;/em&gt; 가 성공하기 만하면 앞의 텍스트와 일치하도록 식 &lt;em&gt;E를&lt;/em&gt; 반복해서 적용 합니다. 일치하는 텍스트 (있는 경우)를 사용하고 하나 이상 일치하면 성공을 나타냅니다. 그렇지 않으면 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7580ae8512abee0f0777a780954b22b310c552f2" translate="yes" xml:space="preserve">
          <source>One problem with rules 3 and 4 is that they affect specific global or thread local variables, but Nim's effect tracking only tracks &quot;uses no global variable&quot; via &lt;code&gt;.noSideEffect&lt;/code&gt;. The rules 3 and 4 can also be approximated by a different rule:</source>
          <target state="translated">규칙 3과 4의 한 가지 문제점은 특정 전역 또는 스레드 지역 변수에 영향을 미치지 만 Nim의 효과 추적은 &lt;code&gt;.noSideEffect&lt;/code&gt; 를 통해 &quot;전역 변수를 사용하지 않음&quot;만 추적 한다는 것 입니다. 규칙 3과 4는 다른 규칙으로 근사화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc4680ad8f0f14c282d731ada768ace3aaf946a2" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 연산자 를 오버로드하려면이 프로 시저를 오버로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fcabe66eb85b400f8ef4fa596004eac08e1527ca" translate="yes" xml:space="preserve">
          <source>One should overload this proc if one wants to overload the &lt;code&gt;in&lt;/code&gt; operator. The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 연산자 에 과부하를가하려면이 proc을 과부하해야합니다 . 매개 변수는 역순입니다! &lt;code&gt;a in b&lt;/code&gt; 는 &lt;code&gt;contains(b, a)&lt;/code&gt; 의 템플릿입니다 . 이는 Nim이 과부하 해결에 사용하는 통합 알고리즘이 왼쪽에서 오른쪽으로 작동하기 때문입니다. 그러나 &lt;code&gt;in&lt;/code&gt; 연산자의 경우이 코드 조각에 대한 잘못된 방향입니다.</target>
        </trans-unit>
        <trans-unit id="b3ed0c36ef143962232eea5026e9f624f11115c4" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely matches optional tokens without any result binding.</source>
          <target state="translated">정규식에 비해 매우 좋은 장점 중 하나는 &lt;code&gt;scanf&lt;/code&gt; 가 일반 Nim procs로 확장 가능 하다는 것 입니다. proc은 &lt;code&gt;${}&lt;/code&gt; 또는 &lt;code&gt;$[]&lt;/code&gt; 있습니다. &lt;code&gt;${}&lt;/code&gt; 는 결과를 변수 ( &lt;code&gt;scanf&lt;/code&gt; 매크로 에 전달됨)에 일치시키고 바인딩하는 반면 &lt;code&gt;$[]&lt;/code&gt; 결과 바인딩없이 선택적 토큰 만 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="43e4679df7a5cffe918b1e69c86872ec6282c2aa" translate="yes" xml:space="preserve">
          <source>One very nice advantage over regular expressions is that &lt;code&gt;scanf&lt;/code&gt; is extensible with ordinary Nim procs. The proc is either enclosed in &lt;code&gt;${}&lt;/code&gt; or in &lt;code&gt;$[]&lt;/code&gt;. &lt;code&gt;${}&lt;/code&gt; matches and binds the result to a variable (that was passed to the &lt;code&gt;scanf&lt;/code&gt; macro) while &lt;code&gt;$[]&lt;/code&gt; merely optional tokens.</source>
          <target state="translated">정규 표현식에 비해 매우 좋은 장점 중 하나는 &lt;code&gt;scanf&lt;/code&gt; 가 일반 Nim 프로세서로 확장 가능 하다는 것 입니다. proc은 &lt;code&gt;${}&lt;/code&gt; 또는 &lt;code&gt;$[]&lt;/code&gt; 있습니다. &lt;code&gt;${}&lt;/code&gt; 은 결과를 변수 ( &lt;code&gt;scanf&lt;/code&gt; 매크로 에 전달 된)와 일치시키고 바인딩 하며 &lt;code&gt;$[]&lt;/code&gt; 는 옵션 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="488e4498e568d4ebdd0ca2157ae6748d000ab688" translate="yes" xml:space="preserve">
          <source>One:</source>
          <target state="translated">One:</target>
        </trans-unit>
        <trans-unit id="7aa20e42e9fac36bab86ec5c3c5c9673fd5be3ee" translate="yes" xml:space="preserve">
          <source>Only available for numbers types. Note that the sequence will be uninitialized. After the creation of the sequence you should assign entries to the sequence instead of adding them.</source>
          <target state="translated">숫자 유형에만 사용할 수 있습니다. 시퀀스는 초기화되지 않습니다. 시퀀스를 생성 한 후 추가하는 대신 시퀀스에 항목을 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="7532cddc260a1527eb39bd5975f976f61cc3dd83" translate="yes" xml:space="preserve">
          <source>Only error and fatal messages will cause the output buffer to be flushed immediately. Use the &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; to flush the buffer manually if needed.</source>
          <target state="translated">오류 및 치명적 메시지 만 출력 버퍼를 즉시 플러시합니다. 필요한 경우 &lt;a href=&quot;io#flushFile,File&quot;&gt;flushFile proc&lt;/a&gt; 을 사용하여 버퍼를 수동으로 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="fbc370c46bbbf0bf1dd85847affcf8aaa6e750bc" translate="yes" xml:space="preserve">
          <source>Only used in PSK ciphersuites.</source>
          <target state="translated">PSK 암호 모음에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ceea6a715ca43640a59d2dcdf7b7681ea3882443" translate="yes" xml:space="preserve">
          <source>Only useful if set server-side.</source>
          <target state="translated">서버 측으로 설정된 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="00bd3d75d2161188ac0381f01f684cf113e3579e" translate="yes" xml:space="preserve">
          <source>OpChars:</source>
          <target state="translated">OpChars:</target>
        </trans-unit>
        <trans-unit id="061313292428912182098de432d58a7d8e9cc1bb" translate="yes" xml:space="preserve">
          <source>Open a parser, using the given arguments to set up its internal state.</source>
          <target state="translated">내부 상태를 설정하기 위해 주어진 인수를 사용하여 파서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="8eef2b7e3d6c43c01d59bb1d06ba5236003b6a81" translate="yes" xml:space="preserve">
          <source>Open and Closed symbols</source>
          <target state="translated">열림 및 닫힘 기호</target>
        </trans-unit>
        <trans-unit id="cc4d804a9a52970f4e0eefea5bf1b6f54e9967fb" translate="yes" xml:space="preserve">
          <source>Open arrays</source>
          <target state="translated">개방형 배열</target>
        </trans-unit>
        <trans-unit id="3e4447a76d334227b53f87594f9577969a26e881" translate="yes" xml:space="preserve">
          <source>Open database connection</source>
          <target state="translated">데이터베이스 연결 열기</target>
        </trans-unit>
        <trans-unit id="0714f9844e88b33e62cf52d5b0d001860502d901" translate="yes" xml:space="preserve">
          <source>Open input stream</source>
          <target state="translated">입력 스트림 열기</target>
        </trans-unit>
        <trans-unit id="9ab2517dbed2bed693f918f911730ef79e6d5360" translate="yes" xml:space="preserve">
          <source>Open symbols are looked up in two different contexts: Both the context at definition and the context at instantiation are considered:</source>
          <target state="translated">열린 기호는 두 가지 다른 컨텍스트에서 조회됩니다. 정의의 컨텍스트와 인스턴스화의 컨텍스트가 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="6dc1a7bf5dd1013cab3f801ec28857dece149460" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator with stepping. Same as &lt;code&gt;countup&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="translated">스테핑이있는 OpenMP 병렬 루프 반복기. &lt;code&gt;countup&lt;/code&gt; 동일 하지만 루프는 병렬로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67376ee07cbce917e8219510219ec5b620099129" translate="yes" xml:space="preserve">
          <source>OpenMP parallel loop iterator. Same as &lt;code&gt;..&lt;/code&gt; but the loop may run in parallel.</source>
          <target state="translated">OpenMP 병렬 루프 반복기. 과 동일 &lt;code&gt;..&lt;/code&gt; 하지만 루프를 병렬로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b366a2a3d0445fcc6195c7e8bf9aa2ec87d29a" translate="yes" xml:space="preserve">
          <source>OpenSSL 0.9.8</source>
          <target state="translated">OpenSSL 0.9.8</target>
        </trans-unit>
        <trans-unit id="b1948a8835e811d7bb8fe3dc8f03cdae689640cb" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.0.1</source>
          <target state="translated">OpenSSL 1.0.1</target>
        </trans-unit>
        <trans-unit id="d3c6ce40f6dd891b1898209548f158bde2dc23bc" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.1</source>
          <target state="translated">OpenSSL 1.1.1</target>
        </trans-unit>
        <trans-unit id="6d77bab6bef6033d1033ca864d642fde957a56f8" translate="yes" xml:space="preserve">
          <source>OpenSSL can also be statically linked using &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; for OpenSSL &amp;gt;= 1.1.0. If you want to statically link against OpenSSL 1.0.x, you now have to define the &lt;code&gt;openssl10&lt;/code&gt; symbol via &lt;code&gt;-d:openssl10&lt;/code&gt;.</source>
          <target state="translated">OpenSSL &amp;gt; = 1.1.0의 경우 &lt;code&gt;--dynlibOverride:ssl&lt;/code&gt; 을 사용하여 OpenSSL을 정적으로 연결할 수도 있습니다 . OpenSSL 1.0.x에 정적으로 링크하려면 &lt;code&gt;openssl10&lt;/code&gt; 을 정의해야 합니다. &lt;code&gt;-d:openssl10&lt;/code&gt; 을 통해 기호를 .</target>
        </trans-unit>
        <trans-unit id="f0576b64464ad64eb4c53eaa5c4ef2696b5bb4d5" translate="yes" xml:space="preserve">
          <source>OpenSSL support</source>
          <target state="translated">OpenSSL 지원</target>
        </trans-unit>
        <trans-unit id="41785aa4105d96f7aa2063837bbf62b9d0c42838" translate="yes" xml:space="preserve">
          <source>Opening a connection to a database</source>
          <target state="translated">데이터베이스에 대한 연결 열기</target>
        </trans-unit>
        <trans-unit id="075f451d6a093e7fdd7b9ad18b76dcfe972397a7" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;url&lt;/code&gt; with the user's default browser. This does not block. The URL must not be empty string, to open on a blank page see &lt;code&gt;openDefaultBrowser()&lt;/code&gt;.</source>
          <target state="translated">사용자의 기본 브라우저로 &lt;code&gt;url&lt;/code&gt; 을 엽니 다 . 이것은 차단되지 않습니다. URL은 빈 문자열이 아니어야합니다. 빈 페이지에서 열려면 &lt;code&gt;openDefaultBrowser()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d145821f017af9ef3f638af874e9b10829b0995" translate="yes" xml:space="preserve">
          <source>Opens a channel &lt;code&gt;c&lt;/code&gt; for inter thread communication.</source>
          <target state="translated">스레드 간 통신을 위해 채널 &lt;code&gt;c&lt;/code&gt; 를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="28b5a32312a9dd72c3dba0d99cdc13009520ada4" translate="yes" xml:space="preserve">
          <source>Opens a database connection.</source>
          <target state="translated">데이터베이스 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="6341a3385125d358f254687a1cf9ec666ef3ba23" translate="yes" xml:space="preserve">
          <source>Opens a database connection. Raises a &lt;code&gt;DbError&lt;/code&gt; exception if the connection could not be established.</source>
          <target state="translated">데이터베이스 연결을 엽니 다. 발생시킵니다 &lt;code&gt;DbError&lt;/code&gt; 의 연결이 할 수없는 경우 예외를.</target>
        </trans-unit>
        <trans-unit id="ffc6b3e2b4c985f7646af8662c40813a043d8273" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for reading, calls &lt;a href=&quot;#readAll,File&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;system#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">읽기 위해 &lt;code&gt;filename&lt;/code&gt; 이라는 파일 을 &lt;a href=&quot;#readAll,File&quot;&gt;열고 readAll을&lt;/a&gt; 호출 한 다음 파일을 닫습니다. 문자열을 반환합니다. 오류가 발생한 경우 IO 예외를 발생시킵니다. 컴파일 타임 매크로 내에서 이것을 호출해야하는 경우 &lt;a href=&quot;system#staticRead,string&quot;&gt;staticRead&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b5bedf756c39d16773af1a78426390def78e208" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; for writing. Then writes the &lt;code&gt;content&lt;/code&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="translated">쓰기 위해 &lt;code&gt;filename&lt;/code&gt; 이라는 파일 을 엽니 다 . 그런 다음 &lt;code&gt;content&lt;/code&gt; 을 파일에 완전히 쓰고 나중에 파일을 닫습니다. 오류가 발생한 경우 IO 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e38b309e7cb64778d65091ba8fb43d41a2afd811" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;code&gt;filename&lt;/code&gt; with given &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;filename&lt;/code&gt; 이라는 파일 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="6d89b0ce8e9218e6fea12851e9b880be1e4997d4" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for reading.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일을&lt;/em&gt; 엽니 다&lt;em&gt;&lt;/em&gt;읽을 을 .</target>
        </trans-unit>
        <trans-unit id="a04bc38a4be5b20cb1f277438e98d1933fa9e233" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; for writing. Then writes the &lt;em&gt;content&lt;/em&gt; completely to the file and closes the file afterwards. Raises an IO exception in case of an error.</source>
          <target state="translated">쓰기 위해 &lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 을 엽니 다 . 그런 다음 &lt;em&gt;내용을&lt;/em&gt; 씁니다.&lt;em&gt;&lt;/em&gt; 을 파일에 완전히 나중에 파일을 닫습니다. 오류가 발생하면 IO 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eaf81cf94eccf62abfb731ae2352ef1f7afad678" translate="yes" xml:space="preserve">
          <source>Opens a file named &lt;em&gt;filename&lt;/em&gt; with given &lt;em&gt;mode&lt;/em&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;모드로 &lt;/em&gt;&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 을 엽니 다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14f607a4816b562ae72f4697df3c9b5d1e94db71" translate="yes" xml:space="preserve">
          <source>Opens a file specified by the path in &lt;code&gt;filename&lt;/code&gt; using the specified FileMode &lt;code&gt;mode&lt;/code&gt; asynchronously.</source>
          <target state="translated">지정된 FileMode &lt;code&gt;mode&lt;/code&gt; 비동기 적으로 사용하여 &lt;code&gt;filename&lt;/code&gt; 에서 경로로 지정된 파일을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="d0bbee2462ecfc98727ddc0ff7d24ba7bbb75c45" translate="yes" xml:space="preserve">
          <source>Opens the user's default browser without any &lt;code&gt;url&lt;/code&gt; (blank page). This does not block. Implements IETF RFC-6694 Section 3, &quot;about:blank&quot; must be reserved for a blank page.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; 없이 사용자의 기본 브라우저를 엽니 다 (빈 페이지). 이것은 차단되지 않습니다. IETF RFC-6694 구현 섹션 3, &quot;about : blank&quot;는 빈 페이지 용으로 예약해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c1668ac138ae92ffacd3116296d3548db776f14" translate="yes" xml:space="preserve">
          <source>Opera 20</source>
          <target state="translated">오페라 20</target>
        </trans-unit>
        <trans-unit id="41b0fc59d7aad8bc81ae95e641aa3418061b2802" translate="yes" xml:space="preserve">
          <source>Opera 5</source>
          <target state="translated">오페라 5</target>
        </trans-unit>
        <trans-unit id="fad0a017eb9f00073f41816df228a99ee3a83534" translate="yes" xml:space="preserve">
          <source>Opera 57</source>
          <target state="translated">오페라 57</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="27fea8d4a592d2ef15188641818c4f50cf213496" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;mitems&lt;/code&gt; or &lt;code&gt;mpairs&lt;/code&gt; (or the now deprecated &lt;code&gt;mget&lt;/code&gt;) that allow a &lt;em&gt;mutating view&lt;/em&gt; into some data structure should start with an &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">동일한 조작 &lt;code&gt;mitems&lt;/code&gt; 또는 &lt;code&gt;mpairs&lt;/code&gt; (또는 현재 사용되지 &lt;code&gt;mget&lt;/code&gt; 허용 및) &lt;em&gt;돌연변이 뷰&lt;/em&gt; 일부 데이터 구조로는 시작해야 &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="2eb04c37cf98ac30d71ff1b2f86ff1286db3a060" translate="yes" xml:space="preserve">
          <source>Operators ending in either &lt;code&gt;-&amp;gt;&lt;/code&gt;, &lt;code&gt;~&amp;gt;&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt; are called &lt;span id=&quot;arrow-like_1&quot;&gt;arrow like&lt;/span&gt;, and have the lowest precedence of all operators.</source>
          <target state="translated">&lt;code&gt;-&amp;gt;&lt;/code&gt; , &lt;code&gt;~&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 로 끝나는 연산자를 &lt;span id=&quot;arrow-like_1&quot;&gt;arrow like&lt;/span&gt; 라고 하며 모든 연산자 중 우선 순위가 가장 낮습니다.</target>
        </trans-unit>
        <trans-unit id="b9fb7505b70ebf5d6a9bf27d2cc12bbd40ee6af9" translate="yes" xml:space="preserve">
          <source>Operators with one parameter are prefix operators, operators with two parameters are infix operators. (However, the parser distinguishes these from the operator's position within an expression.) There is no way to declare postfix operators: all postfix operators are built-in and handled by the grammar explicitly.</source>
          <target state="translated">하나의 매개 변수를 가진 연산자는 접두사 연산자이고, 두 개의 매개 변수를 가진 연산자는 접두사 연산자입니다. 그러나 구문 분석기는이를 표현식 내에서 연산자 위치와 구별합니다. 접미사 연산자를 선언 할 수있는 방법은 없습니다. 모든 접미사 연산자는 문법에 의해 기본적으로 제공되고 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff265181afd92a333026e2c5d5e199dc5da7ef8" translate="yes" xml:space="preserve">
          <source>Operators:</source>
          <target state="translated">Operators:</target>
        </trans-unit>
        <trans-unit id="4cad12b6f389d483084d0d553643ba732946936d" translate="yes" xml:space="preserve">
          <source>Optimize the code for speed or size, or disable optimization.</source>
          <target state="translated">속도 나 크기에 맞게 코드를 최적화하거나 최적화를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc67490a69e2f143ae9471a30d11d13f1cf0a23" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="translated">문자 &lt;a href=&quot;#replace,string,string&quot;&gt;대체&lt;/a&gt; 최적화 버전 .</target>
        </trans-unit>
        <trans-unit id="5a8298c3a957647aef96f07b3da793f45200cac3" translate="yes" xml:space="preserve">
          <source>Optimized version of &lt;a href=&quot;#replace,string,string,string&quot;&gt;replace&lt;/a&gt; for characters.</source>
          <target state="translated">문자 &lt;a href=&quot;#replace,string,string,string&quot;&gt;교체의&lt;/a&gt; 최적화 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="13225c7d848cc0d6dfe6ef6391b22b19c1fefb1b" translate="yes" xml:space="preserve">
          <source>Optimizer:</source>
          <target state="translated">Optimizer:</target>
        </trans-unit>
        <trans-unit id="eeaab884d147b712e7cd622a4a60b4a88154310b" translate="yes" xml:space="preserve">
          <source>Optimizing for Nim</source>
          <target state="translated">님에 대한 최적화</target>
        </trans-unit>
        <trans-unit id="b48db209b043766c1b5804d5e27bcd73790ad927" translate="yes" xml:space="preserve">
          <source>Optimizing string handling</source>
          <target state="translated">문자열 처리 최적화</target>
        </trans-unit>
        <trans-unit id="74b1e148d5f6b3cc16368babcbaee255c62422d6" translate="yes" xml:space="preserve">
          <source>Optional human readable string to display as hyper link. If the value is not present or is the empty string, the hyper link will be rendered using the term. Prefix whitespace indicates that this entry is not for an API symbol but for a TOC entry.</source>
          <target state="translated">하이퍼 링크로 표시 할 사람이 읽을 수있는 문자열 (선택 사항). 값이 없거나 빈 문자열 인 경우 용어를 사용하여 하이퍼 링크가 렌더링됩니다. 접두사 공백은이 항목이 API 기호가 아니라 TOC 항목임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d39225d11f759a6f965920f1aaea6c3af2e9f0dd" translate="yes" xml:space="preserve">
          <source>Optional title or description of the hyper link. Browsers usually display this as a tooltip after hovering a moment over the hyper link.</source>
          <target state="translated">하이퍼 링크의 선택적 제목 또는 설명 브라우저는 일반적으로 하이퍼 링크 위에 잠시 마우스를 올려 놓으면이를 툴팁으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c193b422d4cdb46518f62b1308dcbb7e534adc1e" translate="yes" xml:space="preserve">
          <source>Optionally, the initial capacity can be reserved via &lt;code&gt;initialSize&lt;/code&gt; as a performance optimization. The length of a newly created deque will still be 0.</source>
          <target state="translated">선택적 으로 성능 최적화를 위해 &lt;code&gt;initialSize&lt;/code&gt; 를 통해 초기 용량을 예약 할 수 있습니다 . 새로 생성 된 데크의 길이는 여전히 0입니다.</target>
        </trans-unit>
        <trans-unit id="1957a08c23244cb7c73a47bb45230876010740d3" translate="yes" xml:space="preserve">
          <source>Optionally: manpages, documentation, shell completion</source>
          <target state="translated">선택 사항 : 맨 페이지, 설명서, 셸 완성</target>
        </trans-unit>
        <trans-unit id="7a81599fb16f88a774e6e6dde5e5c88bf3a24004" translate="yes" xml:space="preserve">
          <source>Options that can be passed to &lt;a href=&quot;#startProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;startProcess proc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#startProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;startProcess proc에&lt;/a&gt; 전달할 수있는 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="bdd0b506837a990803d8edf137f2934329835748" translate="yes" xml:space="preserve">
          <source>Options:</source>
          <target state="translated">Options:</target>
        </trans-unit>
        <trans-unit id="81de498479269f7efcd2ce9f7789819338e86fcf" translate="yes" xml:space="preserve">
          <source>Or if we directly use a ref object:</source>
          <target state="translated">또는 ref 객체를 직접 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="21ab442b56e6693d449e1b3316a7c72b27f04270" translate="yes" xml:space="preserve">
          <source>Order of evaluation</source>
          <target state="translated">평가 순서</target>
        </trans-unit>
        <trans-unit id="6fddf2edd42bb52326d95d7ad197008a3ad3c62b" translate="yes" xml:space="preserve">
          <source>Order of evaluation is strictly left-to-right, inside-out as it is typical for most others imperative programming languages:</source>
          <target state="translated">대부분의 다른 명령형 프로그래밍 언어에서 일반적으로 사용되므로 평가 순서는 왼쪽에서 오른쪽으로 엄격하게 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="45f68e3d201980b2ce2fa3c6e8912431c529664b" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;code&gt;A&lt;/code&gt;, ..., &lt;code&gt;Z&lt;/code&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="translated">순서있는 선택 : &lt;code&gt;A&lt;/code&gt; , ..., &lt;code&gt;Z&lt;/code&gt; 표현식 을이 순서로 적용하여 그중 하나가 성공하여 일부 텍스트를 소비 할 때까지 앞의 텍스트에 적용합니다. 표현식 중 하나가 성공하면 성공을 나타냅니다. 그렇지 않으면 텍스트를 사용하지 않고 실패를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ab66e435888dccd3c76f559e634b263fcd8938b5" translate="yes" xml:space="preserve">
          <source>Ordered choice: Apply expressions &lt;em&gt;A&lt;/em&gt;, ..., &lt;em&gt;Z&lt;/em&gt;, in this order, to the text ahead, until one of them succeeds and possibly consumes some text. Indicate success if one of expressions succeeded. Otherwise do not consume any text and indicate failure.</source>
          <target state="translated">정렬 식 선택 : 표현식 &lt;em&gt;A&lt;/em&gt; , ..., &lt;em&gt;Z&lt;/em&gt; 를 순서대로 텍스트에 적용하고 그 중 하나가 성공하고 텍스트를 사용할 수있을 때까지 텍스트에 적용합니다. 식 중 하나가 성공하면 성공을 나타냅니다. 그렇지 않으면 텍스트를 사용하지 않고 실패를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52eba0e6519807164baca0d6b1158a8ecd7de4c9" translate="yes" xml:space="preserve">
          <source>OrderedTable</source>
          <target state="translated">OrderedTable</target>
        </trans-unit>
        <trans-unit id="bca57d661a7ac85cef723a55cd585566c9d3f621" translate="yes" xml:space="preserve">
          <source>Ordinal types</source>
          <target state="translated">서수 유형</target>
        </trans-unit>
        <trans-unit id="3119a2318ed75057b08b3960866241e029fabd75" translate="yes" xml:space="preserve">
          <source>Ordinal types are countable and ordered. This property allows the operation of functions as &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;dec&lt;/code&gt; on ordinal types to be defined.</source>
          <target state="translated">서수 유형은 셀 수 있고 순서가 있습니다. 이 속성을 사용하면 &lt;code&gt;inc&lt;/code&gt; , &lt;code&gt;ord&lt;/code&gt; , &lt;code&gt;dec&lt;/code&gt; 로 함수를 작동 할 수 있습니다 서수 유형에 대해 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="872a8c3d6d59041261f393e2e15158de859ea0da" translate="yes" xml:space="preserve">
          <source>Ordinal types have the following characteristics:</source>
          <target state="translated">서수 유형에는 다음과 같은 특징이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e629aac27b5777617cee72722956d8b340e2199c" translate="yes" xml:space="preserve">
          <source>Ordinal values have a largest possible value. Trying to count further than the largest value gives a checked runtime or static error.</source>
          <target state="translated">서수 값은 가능한 가장 큰 값을 갖습니다. 가장 큰 값보다 더 세려고하면 검사 된 런타임 또는 정적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="36acb83b7e99f490d0435fdeb44f36127e91db65" translate="yes" xml:space="preserve">
          <source>Ordinal values have a smallest possible value. Trying to count further down than the smallest value gives a checked runtime or static error.</source>
          <target state="translated">서수 값은 가능한 가장 작은 값을 갖습니다. 가장 작은 값보다 카운트 다운을 시도하면 확인 된 런타임 또는 정적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3273ae720a4e64dcca9795fe755e4b9213bc669" translate="yes" xml:space="preserve">
          <source>Ordinal values have the largest possible value. Trying to count further than the largest value produces a panic or a static error.</source>
          <target state="translated">서수 값은 가능한 가장 큰 값을 갖습니다. 가장 큰 값보다 더 많이 계산하려고하면 패닉 또는 정적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="563bb5bf58644ad6723e724e397712047e75b6e7" translate="yes" xml:space="preserve">
          <source>Ordinal values have the smallest possible value. Trying to count further down than the smallest value produces a panic or a static error.</source>
          <target state="translated">서수 값은 가능한 가장 작은 값을 갖습니다. 가장 작은 값보다 더 카운트 다운하려고하면 패닉 또는 정적 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eaa953406f4d182ae08a38375892d6aff714ff91" translate="yes" xml:space="preserve">
          <source>OrdinalType.FloatLike</source>
          <target state="translated">OrdinalType.FloatLike</target>
        </trans-unit>
        <trans-unit id="88dcff2ae87c9e99ad5c60ac3538a976e2816c25" translate="yes" xml:space="preserve">
          <source>OrdinalType.IntLike</source>
          <target state="translated">OrdinalType.IntLike</target>
        </trans-unit>
        <trans-unit id="f88d1629d2c6e62128639c388362a7be4a950f39" translate="yes" xml:space="preserve">
          <source>OrdinalType.NoneLike</source>
          <target state="translated">OrdinalType.NoneLike</target>
        </trans-unit>
        <trans-unit id="a47cfd3d99cec2694c9dbb5322d0b724efa09a94" translate="yes" xml:space="preserve">
          <source>OrdinalType:</source>
          <target state="translated">OrdinalType:</target>
        </trans-unit>
        <trans-unit id="3ed1f6c1083d3683b1c12d25ec50e612d1123f42" translate="yes" xml:space="preserve">
          <source>Ordinals</source>
          <target state="translated">Ordinals</target>
        </trans-unit>
        <trans-unit id="aa2feef9929fb50eb0970ed959dead68aeaa3fc1" translate="yes" xml:space="preserve">
          <source>Ordinary code should not use this, but the &lt;a href=&quot;typeinfo&quot;&gt;typeinfo module&lt;/a&gt; instead.</source>
          <target state="translated">일반 코드는 이것을 사용해서는 &lt;a href=&quot;typeinfo&quot;&gt;안되지만&lt;/a&gt; 대신 typeinfo 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d640a1890d09eeb8ca875d238db12f1e6d3c3e8" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating point to integer or vice versa.</source>
          <target state="translated">일반적인 프로세스는 종종 Nim에서 유형 변환보다 선호됩니다. 예를 들어 &lt;code&gt;$&lt;/code&gt; 는 규칙 및 &lt;code&gt;toFloat&lt;/code&gt; 및 &lt;code&gt;toInt&lt;/code&gt; 에 의한 &lt;code&gt;toString&lt;/code&gt; 연산자입니다. 를 사용하여 부동 소수점에서 정수로 또는 그 반대로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5421d5a04b330a5d5f07445ff5c33b2ee43c5" translate="yes" xml:space="preserve">
          <source>Ordinary procs are often preferred over type conversions in Nim: For instance, &lt;code&gt;$&lt;/code&gt; is the &lt;code&gt;toString&lt;/code&gt; operator by convention and &lt;code&gt;toFloat&lt;/code&gt; and &lt;code&gt;toInt&lt;/code&gt; can be used to convert from floating-point to integer or vice versa.</source>
          <target state="translated">일반 발동은 종종 님의 유형 변환보다 선호된다 : 예를 들어, &lt;code&gt;$&lt;/code&gt; 은 는 IS &lt;code&gt;toString&lt;/code&gt; 규칙 및 회사 별 &lt;code&gt;toFloat&lt;/code&gt; 및 &lt;code&gt;toInt&lt;/code&gt; 는 반대의 정수 또는 그 부동 소수점에서 변환 할 수 있습니다가.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="2ff9f42e32037de9fa807030da493664b568f9f2" translate="yes" xml:space="preserve">
          <source>Other Input Formats</source>
          <target state="translated">다른 입력 형식</target>
        </trans-unit>
        <trans-unit id="43a5e3b913b70aa6bbf66b3f9a94594af1d85d6e" translate="yes" xml:space="preserve">
          <source>Other features that are &lt;em&gt;implicitly&lt;/em&gt; triggered cause problems for modularity too. Type converters fall into this category:</source>
          <target state="translated">&lt;em&gt;암시 적으로&lt;/em&gt; 트리거되는 다른 기능 도 모듈성에 문제를 일으 킵니다. 타입 변환기는이 범주에 속합니다.</target>
        </trans-unit>
        <trans-unit id="13f7dea1ee4b7cb7f096198dcfd885624c0eca95" translate="yes" xml:space="preserve">
          <source>Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="translated">다른 언어는 이러한 &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt; 과 같은 유형의 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="8702ae2aa93e41c74ae80da30c44c3106f145472" translate="yes" xml:space="preserve">
          <source>Other literal types, such as &lt;code&gt;uint literal(123)&lt;/code&gt; that would automatically convert to other integer types, but prefers to become a &lt;code&gt;uint&lt;/code&gt; are not part of the Nim language.</source>
          <target state="translated">다른 정수 유형으로 자동 변환되지만 &lt;code&gt;uint&lt;/code&gt; 가되는 것을 선호하는 &lt;code&gt;uint literal(123)&lt;/code&gt; 과 같은 다른 리터럴 유형 은 Nim 언어의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bb62f4ab5d15274940b6aca44c5aaa8ba4f5ebac" translate="yes" xml:space="preserve">
          <source>Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">다른 모듈은이 표준 스트림 인터페이스에 대한 다른 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaade51f8bd7dc897edf07f1c61fcd7a86afa793" translate="yes" xml:space="preserve">
          <source>Other parts of Nim - like scoping rules or runtime semantics are only described in the, more easily comprehensible, informal manner for now.</source>
          <target state="translated">범위 지정 규칙 또는 런타임 의미와 같은 Nim의 다른 부분은 현재보다 이해하기 쉽고 비공식적 인 방식으로 만 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="cd81b04823d8d098b759de332e3f37424b167edb" translate="yes" xml:space="preserve">
          <source>Other parts of Nim, like scoping rules or runtime semantics, are described informally.</source>
          <target state="translated">범위 지정 규칙 또는 런타임 의미 체계와 같은 Nim의 다른 부분은 비공식적으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="13760399786dc4b7c7d0f4b3dbf3b00e5ee44753" translate="yes" xml:space="preserve">
          <source>Other strings can be inserted by putting them in &lt;code&gt;''&lt;/code&gt;. For example &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; will give &lt;code&gt;01-&amp;gt;56&lt;/code&gt;. The following characters can be inserted without quoting them: &lt;code&gt;:&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;. A literal &lt;code&gt;'&lt;/code&gt; can be specified with &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="translated">다른 문자열은 &lt;code&gt;''&lt;/code&gt; 에 넣어서 삽입 할 수 있습니다 . 예를 들어 &lt;code&gt;hh'-&amp;gt;'mm&lt;/code&gt; 은 &lt;code&gt;01-&amp;gt;56&lt;/code&gt; 을 제공 합니다. 다음 문자를 인용하지 않고 삽입 할 수 있습니다 &lt;code&gt;:&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; . 리터럴 &lt;code&gt;'&lt;/code&gt; 은 &lt;code&gt;''&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8db18f7107204fed8fe24c5d3014de56d0af6c5d" translate="yes" xml:space="preserve">
          <source>Other tokens</source>
          <target state="translated">다른 토큰</target>
        </trans-unit>
        <trans-unit id="d65b86f3209b622242b01d2656aba539a4c22285" translate="yes" xml:space="preserve">
          <source>Other useful iterators for collections (like arrays and sequences) are</source>
          <target state="translated">컬렉션에 유용한 다른 반복자 (예 : 배열 및 시퀀스)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1ab7515d2fc3d1784934bda518727e08f8359e6" translate="yes" xml:space="preserve">
          <source>Other value-based compound types like &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;array&lt;/code&gt; are handled correspondingly. For &lt;code&gt;object&lt;/code&gt; however, the compiler-generated hooks can be overridden. This can also be important to use an alternative traversal of the involved data structure that is more efficient or in order to avoid deep recursions.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 및 &lt;code&gt;array&lt;/code&gt; 과 같은 다른 값 기반 복합 유형 은 그에 따라 처리됩니다. 들어 &lt;code&gt;object&lt;/code&gt; 그러나, 컴파일러가 생성 한 후크 오버라이드 (override) 할 수 있습니다. 더 효율적이거나 깊은 재귀를 피하기 위해 관련 데이터 구조의 대체 순회를 사용하는 것도 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2d7e0a58dc8427e382ddd731db370ec009572b" translate="yes" xml:space="preserve">
          <source>Otherwise precedence is determined by the first character.</source>
          <target state="translated">그렇지 않으면 우선 순위는 첫 번째 문자에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="21bc9e76f2a8c2a0eaf537c08d3d36f6d8085e56" translate="yes" xml:space="preserve">
          <source>Otherwise returns an empty string.</source>
          <target state="translated">그렇지 않으면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c72b5f977bcddbc511f75e162bc5876c1a3aead" translate="yes" xml:space="preserve">
          <source>Otherwise, precedence is determined by the first character.</source>
          <target state="translated">그렇지 않으면 우선 순위는 첫 번째 문자에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0bdd4c9ffbb5fd3025e9485c4feb564db99a1d5f" translate="yes" xml:space="preserve">
          <source>Our first attempt will start by modifying the program to generate a compile time string with the &lt;em&gt;generated source code&lt;/em&gt;, which we then pass to the &lt;code&gt;parseStmt&lt;/code&gt; proc from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;. Here is the modified source code implementing the macro:</source>
          <target state="translated">첫 번째 시도는 프로그램을 수정하여 &lt;em&gt;생성 된 소스 코드&lt;/em&gt; 로 컴파일 타임 문자열을 생성하는 것부터 시작합니다. 그런 다음 &lt;a href=&quot;macros&quot;&gt;매크로 모듈&lt;/a&gt; 에서 &lt;code&gt;parseStmt&lt;/code&gt; proc에 전달합니다. . 다음은 매크로를 구현 한 수정 된 소스 코드입니다.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="1458e0711b267bc74f8fee698a4064944483ced7" translate="yes" xml:space="preserve">
          <source>Overflow: operation produces a result that exceeds the range of the exponent, for example MAXDOUBLE+0.0000000000001e308.</source>
          <target state="translated">오버 플로우 : 연산은 지수 범위 (예 : MAXDOUBLE + 0.0000000000001e308)를 초과하는 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e1b7bd0afdc5a65df37f4970df5c8e08d3dd78f" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param. This works in practice by attaching attributes to types via templates. The constraint can be a concrete type or a type class.</source>
          <target state="translated">과부하 해결은 유형 매개 변수와 일치하는 유형 세트를 제한하여 추가로 영향을받을 수 있습니다. 이것은 템플릿을 통해 유형에 속성을 첨부하여 실제로 작동합니다. 제약 조건은 구체적인 유형 또는 유형 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754c102f9b75ce776185c568a14f1c8a51acdc8a" translate="yes" xml:space="preserve">
          <source>Overload resolution can be further influenced by constraining the set of types that will match the type param:</source>
          <target state="translated">형식 매개 변수와 일치하는 형식 집합을 제한하면 과부하 해결에 더 많은 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa7936a516e9b4405cfaaa07e91ba994298a243" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;f&lt;/code&gt; at compile time.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 를 검증하는 과부하컴파일시 .</target>
        </trans-unit>
        <trans-unit id="9c00e2ea8b8b406447c26bdcb6148e11ef275602" translate="yes" xml:space="preserve">
          <source>Overload that validates &lt;code&gt;format&lt;/code&gt; at compile time.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 을 확인하는 과부하컴파일 타임에 .</target>
        </trans-unit>
        <trans-unit id="4640027ad29996563c1a87a8afddf3069ba5a1e7" translate="yes" xml:space="preserve">
          <source>OverloadableSyms:</source>
          <target state="translated">OverloadableSyms:</target>
        </trans-unit>
        <trans-unit id="084d89d78f9253e5971aa14b7a1c146ed66021d5" translate="yes" xml:space="preserve">
          <source>Overloaded procedures</source>
          <target state="translated">과부하 절차</target>
        </trans-unit>
        <trans-unit id="52682dea26ce453286dbc5b5476302bf2f155d52" translate="yes" xml:space="preserve">
          <source>Overloading based on &amp;#x27;var T&amp;#x27;</source>
          <target state="translated">'var T'에 따른 과부하</target>
        </trans-unit>
        <trans-unit id="fdfc3d44da0fc76ce20708147d4fa0f06487870d" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T'</source>
          <target state="translated">'var T'에 따른 과부하</target>
        </trans-unit>
        <trans-unit id="3fa8556506ad2f2650ad5f0ace5f70fac3fe501b" translate="yes" xml:space="preserve">
          <source>Overloading based on 'var T' / 'out T'</source>
          <target state="translated">'var T'/ 'out T'를 기반으로 한 오버로딩</target>
        </trans-unit>
        <trans-unit id="376919dad96314f113fa2e51189fad0ab6b8a289" translate="yes" xml:space="preserve">
          <source>Overloading of the subscript operator</source>
          <target state="translated">아래 첨자 연산자의 오버로드</target>
        </trans-unit>
        <trans-unit id="856f6c8643871a65621d9a78bd00b337b84e3743" translate="yes" xml:space="preserve">
          <source>Overloading resolution</source>
          <target state="translated">과부하 해상도</target>
        </trans-unit>
        <trans-unit id="59d786986f63a664027eb772a26d80c3f7a0abe9" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. Default implementation does nothing.</source>
          <target state="translated">사용자 정의 로거에서이 메소드를 대체하십시오. 기본 구현은 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e1ae1a7c1ebfbcd4f7e403da7e822ba08800911" translate="yes" xml:space="preserve">
          <source>Override this method in custom loggers. The default implementation does nothing.</source>
          <target state="translated">사용자 지정 로거에서이 메서드를 재정의합니다. 기본 구현은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9a660e603ccfc886dc9821594693be1bc0353fd" translate="yes" xml:space="preserve">
          <source>Overrides the location of a given file belonging to the passed package. If the &lt;code&gt;replacement&lt;/code&gt; is not an absolute path, the path is interpreted to be local to the Nimscript file that contains the call to &lt;code&gt;patchFile&lt;/code&gt;, Nim's &lt;code&gt;--path&lt;/code&gt; is not used at all to resolve the filename!</source>
          <target state="translated">전달 된 패키지에 속하는 주어진 파일의 위치를 ​​재정의합니다. 경우 &lt;code&gt;replacement&lt;/code&gt; 절대 경로가 아닌 경로는 호출이 포함 된 Nimscript 파일을 로컬로 해석됩니다 &lt;code&gt;patchFile&lt;/code&gt; , 님의 &lt;code&gt;--path&lt;/code&gt; 이 파일 이름을 해결하는 데 전혀 사용되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="b6d3fab9b4983c0a7fac72ed7d8df78bdcbf862d" translate="yes" xml:space="preserve">
          <source>Overwrites the contents of the memory at &lt;code&gt;p&lt;/code&gt; with the value 0.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 메모리 내용을 값 0으로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a7bf096f89a1c09f22a68174532321948a126b7a" translate="yes" xml:space="preserve">
          <source>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</source>
          <target state="translated">PCRE는 구문과 의미가 Perl 5 언어의 구문 및 의미와 가능한 정규식을 지원하는 함수 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="dbd40bd5aaef4dbeb16b94e187805c444acafbdf" translate="yes" xml:space="preserve">
          <source>PContext:</source>
          <target state="translated">PContext:</target>
        </trans-unit>
        <trans-unit id="7cacbbd17d87f4550a6720e9ec18284a7061410d" translate="yes" xml:space="preserve">
          <source>PCtx:</source>
          <target state="translated">PCtx:</target>
        </trans-unit>
        <trans-unit id="cc9a0f474ef35d5f0eb8a004093952e55059eb5c" translate="yes" xml:space="preserve">
          <source>PDoc:</source>
          <target state="translated">PDoc:</target>
        </trans-unit>
        <trans-unit id="595a895491f3a0cc703f76860a5a4b9d42a6ea7f" translate="yes" xml:space="preserve">
          <source>PEG construction</source>
          <target state="translated">PEG 구성</target>
        </trans-unit>
        <trans-unit id="118ee2de963e33508b97b815b8c557728d365a9c" translate="yes" xml:space="preserve">
          <source>PEG syntax and semantics</source>
          <target state="translated">PEG 구문 및 의미</target>
        </trans-unit>
        <trans-unit id="9bde7e84a708b95057b420b93ae5d95c394c2f01" translate="yes" xml:space="preserve">
          <source>PEG vs regular expression</source>
          <target state="translated">PEG 대 정규식</target>
        </trans-unit>
        <trans-unit id="9a88b7a4b3c1cc84a7c0e7df861d95ea546a29f6" translate="yes" xml:space="preserve">
          <source>PEvalContext:</source>
          <target state="translated">PEvalContext:</target>
        </trans-unit>
        <trans-unit id="d9feff605b042a276d71f7511edd02d350b336f6" translate="yes" xml:space="preserve">
          <source>PIdObj:</source>
          <target state="translated">PIdObj:</target>
        </trans-unit>
        <trans-unit id="ffab2525091289dbd9d41123e41aff716b05e503" translate="yes" xml:space="preserve">
          <source>PIdent:</source>
          <target state="translated">PIdent:</target>
        </trans-unit>
        <trans-unit id="fd7dba84795498ad0e65cc4af895fd7d829b3c54" translate="yes" xml:space="preserve">
          <source>PInstantiation:</source>
          <target state="translated">PInstantiation:</target>
        </trans-unit>
        <trans-unit id="accfd6dd76c6b8689524f104b98bddaef54a702a" translate="yes" xml:space="preserve">
          <source>PLLStream:</source>
          <target state="translated">PLLStream:</target>
        </trans-unit>
        <trans-unit id="cbeaa1d5e4e194941a961e776953a09573177112" translate="yes" xml:space="preserve">
          <source>PLib:</source>
          <target state="translated">PLib:</target>
        </trans-unit>
        <trans-unit id="fc242215607474d0c7b7da3f12b4b91f6f303f9d" translate="yes" xml:space="preserve">
          <source>PNode:</source>
          <target state="translated">PNode:</target>
        </trans-unit>
        <trans-unit id="567edf4105fe83ec09be7bbd5ad833d065991b7e" translate="yes" xml:space="preserve">
          <source>POSIX character class (only if followed by POSIX syntax)</source>
          <target state="translated">POSIX 문자 클래스 (POSIX 구문이 뒤에 오는 경우에만)</target>
        </trans-unit>
        <trans-unit id="e3896dc47c849389aad6b68320cef38af4776a63" translate="yes" xml:space="preserve">
          <source>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to &lt;code&gt;platform&lt;/code&gt; (if it is not already listed there), check that the OS, System modules work and recompile Nim.</source>
          <target state="translated">기존 하드웨어의 POSIX 호환 시스템은 일반적으로 포팅이 매우 쉽습니다. 플랫폼을 &lt;code&gt;platform&lt;/code&gt; 추가하고 (아직 목록에없는 경우) OS, 시스템 모듈이 작동하는지 확인하고 Nim을 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="12142e28cc69313a619ae99c351fba5fe84b0a4b" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to &lt;code&gt;url&lt;/code&gt; and returns the response's body as a string</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 을 &lt;code&gt;url&lt;/code&gt; POST 하고 응답 본문을 문자열로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2dbc1dded6bee0ca902ff7658892851595e373f2" translate="yes" xml:space="preserve">
          <source>POSTs &lt;code&gt;body&lt;/code&gt; to the &lt;code&gt;url&lt;/code&gt; and returns a &lt;code&gt;Response&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; &lt;code&gt;body&lt;/code&gt; 을 게시 하고 &lt;code&gt;Response&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ab6aee922e510d7ec57148a12114d5593e2b06f9" translate="yes" xml:space="preserve">
          <source>POptionEntry:</source>
          <target state="translated">POptionEntry:</target>
        </trans-unit>
        <trans-unit id="671f7474c264cec8bd98b6bc369716f871230c32" translate="yes" xml:space="preserve">
          <source>PPassContext:</source>
          <target state="translated">PPassContext:</target>
        </trans-unit>
        <trans-unit id="fae5eded41aca0b332d2db1f43cc65305199884d" translate="yes" xml:space="preserve">
          <source>PProc:</source>
          <target state="translated">PProc:</target>
        </trans-unit>
        <trans-unit id="11901d272bf1a502817be89a6f84525164cfa2da" translate="yes" xml:space="preserve">
          <source>PProcCon:</source>
          <target state="translated">PProcCon:</target>
        </trans-unit>
        <trans-unit id="b4e6954da93815488c9a364b8a508b656e9a52c2" translate="yes" xml:space="preserve">
          <source>PScope:</source>
          <target state="translated">PScope:</target>
        </trans-unit>
        <trans-unit id="db62fc930ef7c90144194475b3b082dfe8559291" translate="yes" xml:space="preserve">
          <source>PStackFrame:</source>
          <target state="translated">PStackFrame:</target>
        </trans-unit>
        <trans-unit id="4500d5cdba9ccdd561ec42d814fc3287a68d4171" translate="yes" xml:space="preserve">
          <source>PSym:</source>
          <target state="translated">PSym:</target>
        </trans-unit>
        <trans-unit id="f952a66c2e11ba6f3956bcda3c808ff7a43df019" translate="yes" xml:space="preserve">
          <source>PType:</source>
          <target state="translated">PType:</target>
        </trans-unit>
        <trans-unit id="332b04a11e1cc3787447391399cd62fd1868e0c6" translate="yes" xml:space="preserve">
          <source>Package level objects</source>
          <target state="translated">패키지 레벨 객체</target>
        </trans-unit>
        <trans-unit id="77adf05ce915bafb1957104035a50844753d37c0" translate="yes" xml:space="preserve">
          <source>Packaging Nim</source>
          <target state="translated">Nim 포장</target>
        </trans-unit>
        <trans-unit id="95b83e85b6cee3a941fc9661251d4bdffffa5249" translate="yes" xml:space="preserve">
          <source>Packaging for Linux</source>
          <target state="translated">Linux 용 패키징</target>
        </trans-unit>
        <trans-unit id="55fd3d981957b0d91d11e46f1e01dfd840b2014b" translate="yes" xml:space="preserve">
          <source>Packed pragma</source>
          <target state="translated">포장 된 pragma</target>
        </trans-unit>
        <trans-unit id="eea669f22aa5d4a29c38a6b10887b380fe6f283b" translate="yes" xml:space="preserve">
          <source>Pairwise (cascade) summation of &lt;code&gt;x[i0:i0+n-1]&lt;/code&gt;, with O(log n) error growth (vs O(n) for a simple loop) with negligible performance cost if the base case is large enough.</source>
          <target state="translated">&lt;code&gt;x[i0:i0+n-1]&lt;/code&gt; 쌍별 (계단식) 합계 , 기본 사례가 충분히 큰 경우 성능 비용이 무시할 수있는 O (log n) 오류 증가 (단순 루프의 경우 O (n) 대).</target>
        </trans-unit>
        <trans-unit id="5510a92cb951dc073e6190edad274f134f704fb8" translate="yes" xml:space="preserve">
          <source>Parallel &amp;amp; Spawn</source>
          <target state="translated">병렬 및 스폰</target>
        </trans-unit>
        <trans-unit id="3b1299c53c7f5cf485c6482e9c854f429e16cdd6" translate="yes" xml:space="preserve">
          <source>Parallel statement</source>
          <target state="translated">병렬 진술</target>
        </trans-unit>
        <trans-unit id="eec7d291b5a6446b7643c94e8e46ada61a750299" translate="yes" xml:space="preserve">
          <source>Parameter constraints</source>
          <target state="translated">파라미터 제약</target>
        </trans-unit>
        <trans-unit id="6edec2e5d0a7a5dbb4aae5b4adaf9693a07b89ea" translate="yes" xml:space="preserve">
          <source>Parameter constraints can also be used for ordinary routine parameters; these constraints affect ordinary overloading resolution then:</source>
          <target state="translated">매개 변수 제한 조건은 일반 루틴 매개 변수에도 사용할 수 있습니다. 이러한 제약은 일반적인 오버로드 해상도에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f1a6890392c7940ddb0108d029ad337fb538b0dc" translate="yes" xml:space="preserve">
          <source>Parameter substitution</source>
          <target state="translated">매개 변수 대체</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="248b028facc0fd21c2e902405b8d5a47c01d6c40" translate="yes" xml:space="preserve">
          <source>Parameters and their defaults:</source>
          <target state="translated">매개 변수 및 기본값 :</target>
        </trans-unit>
        <trans-unit id="0f206e21ffd2fb787832ab9df479679c8199f0e6" translate="yes" xml:space="preserve">
          <source>Parameters are immutable in the procedure body. By default, their value cannot be changed because this allows the compiler to implement parameter passing in the most efficient way. If a mutable variable is needed inside the procedure, it has to be declared with &lt;code&gt;var&lt;/code&gt; in the procedure body. Shadowing the parameter name is possible, and actually an idiom:</source>
          <target state="translated">프로 시저 본문에서 매개 변수를 변경할 수 없습니다. 컴파일러는 가장 효율적인 방식으로 매개 변수 전달을 구현할 수 있으므로 기본적으로 값을 변경할 수 없습니다. 프로 시저 내부에 가변 변수가 필요한 경우 프로 시저 본문에서 &lt;code&gt;var&lt;/code&gt; 로 선언 해야합니다. 매개 변수 이름을 섀도 잉하는 것은 가능하며 실제로는 관용구입니다.</target>
        </trans-unit>
        <trans-unit id="8e2f8631ccf741645c248093e0a2a666f3997d29" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 변경 가능하게 선언 될 수 있으므로 proc이 유형 수정 자 &lt;code&gt;var&lt;/code&gt; 를 사용하여 해당 인수를 수정할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="0fa46df5cd24d9e242819c5e1aa5a6733dc8ec59" translate="yes" xml:space="preserve">
          <source>Parameters can be declared mutable and so allow the proc to modify those arguments, by using the type modifier &lt;em&gt;var&lt;/em&gt;.</source>
          <target state="translated">매개 변수는 변경 가능으로 선언 될 수 있으므로 type 수정 자 &lt;em&gt;var를&lt;/em&gt; 사용하여 proc가 해당 인수를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1a33ba432c2fafb1613ca7e699e06e64431463" translate="yes" xml:space="preserve">
          <source>Parameters in a pattern are type checked in the matching process. If a parameter is of the type &lt;code&gt;varargs&lt;/code&gt; it is treated specially and it can match 0 or more arguments in the AST to be matched against:</source>
          <target state="translated">패턴의 매개 변수는 일치 프로세스에서 유형 확인됩니다. 매개 변수가 &lt;code&gt;varargs&lt;/code&gt; 유형 인 경우 특수하게 처리되며 AST에서 0 개 이상의 인수와 일치하여 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="f9627107a88876f4aaf6d7e0b0c19984c3a631ae" translate="yes" xml:space="preserve">
          <source>Parentheses</source>
          <target state="translated">Parentheses</target>
        </trans-unit>
        <trans-unit id="127effbb71ba19570ab235baa525f232fbd22004" translate="yes" xml:space="preserve">
          <source>Parentheses for affecting operator precedence or tuple construction are built with the &lt;code&gt;nnkPar&lt;/code&gt; node.</source>
          <target state="translated">연산자 우선 순위 또는 튜플 구성에 영향을주는 괄호는 &lt;code&gt;nnkPar&lt;/code&gt; 노드로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d9b125022b9ee7ebf69c8a04fd096637510b142" translate="yes" xml:space="preserve">
          <source>Parse from string to &lt;code&gt;Document&lt;/code&gt;.</source>
          <target state="translated">문자열에서 &lt;code&gt;Document&lt;/code&gt; 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed227c288a07222d3d51a4595d3b79f52c8d03e" translate="yes" xml:space="preserve">
          <source>Parser:</source>
          <target state="translated">Parser:</target>
        </trans-unit>
        <trans-unit id="efdb99a054fb37fae9696b10ed15efeeb9f36b28" translate="yes" xml:space="preserve">
          <source>Parsers</source>
          <target state="translated">Parsers</target>
        </trans-unit>
        <trans-unit id="fdc5c8bf9de8fe50660fbecb95450298ca04c420" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;file&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. If &lt;code&gt;file&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 을 &lt;code&gt;JsonNode&lt;/code&gt; 로 구문 분석 합니다 . &lt;code&gt;file&lt;/code&gt; 에 추가 데이터가 포함되어 있으면 &lt;code&gt;JsonParsingError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="92c8de0d487854ee3be6455d253f7500550cee2d" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt; using the format specified by &lt;code&gt;f&lt;/code&gt;. If no UTC offset was parsed, then &lt;code&gt;input&lt;/code&gt; is assumed to be specified in the &lt;code&gt;zone&lt;/code&gt; timezone. If a UTC offset was parsed, the result will be converted to the &lt;code&gt;zone&lt;/code&gt; timezone.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 로 지정된 형식을 사용하여 &lt;code&gt;input&lt;/code&gt; 을 &lt;code&gt;DateTime&lt;/code&gt; 으로 구문 분석 합니다 . UTC 오프셋이 구문 분석되지 않은 경우 &lt;code&gt;zone&lt;/code&gt; 시간대 에 &lt;code&gt;input&lt;/code&gt; 이 지정된 것으로 가정 합니다. UTC 오프셋이 구문 분석 된 경우 결과는 &lt;code&gt;zone&lt;/code&gt; 시간대 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7918d77f526af521fc86e403546e7b0e219d1d4c" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;name&lt;/code&gt; to a color value.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 을 색상 값으로 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="7ca7a029bb84bff8ec1168a8bf88514632d40ff1" translate="yes" xml:space="preserve">
          <source>Parses &lt;em&gt;file&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. If &lt;em&gt;file&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 을 &lt;em&gt;JsonNode&lt;/em&gt; 로 구문 분석 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;파일&lt;/em&gt; 에 추가 데이터가 포함되어 있으면 &lt;em&gt;JsonParsingError가 발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fafedced417174aa4da9f6c5355a4f97842e0273" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;code&gt;buffer&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 에서 JSON을 구문 분석 합니다 . &lt;code&gt;buffer&lt;/code&gt; 에 추가 데이터가 포함되어 있으면 &lt;code&gt;JsonParsingError&lt;/code&gt; 가 발생 합니다. 경우 &lt;code&gt;rawIntegers&lt;/code&gt; 는 사실, 정수 리터럴은 변환되지 않습니다 &lt;code&gt;JInt&lt;/code&gt; 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; . 경우 &lt;code&gt;rawFloats&lt;/code&gt; 는 사실이다, 부동 소수점 리터럴은 변환되지 않습니다 &lt;code&gt;JFloat&lt;/code&gt; 의 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31988daf224c3e5481844d9affd370b85ab0c4b" translate="yes" xml:space="preserve">
          <source>Parses JSON from &lt;em&gt;buffer&lt;/em&gt;. If &lt;em&gt;buffer&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;buffer&lt;/em&gt; 에서 JSON을 구문 분석 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;버퍼&lt;/em&gt; 에 추가 데이터가 포함되어 있으면 &lt;em&gt;JsonParsingError가 발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c83d8c3603707a9ecc2dd84a9a6037c204951a36" translate="yes" xml:space="preserve">
          <source>Parses Sexp from &lt;em&gt;buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 에서 Sexp를 구문 분석 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7b270c2a1c4209369629ad62e2046102416eaf" translate="yes" xml:space="preserve">
          <source>Parses a URI and returns it.</source>
          <target state="translated">URI를 구문 분석하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad45644f553663f9d257789c054572a54266f47c" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;code&gt;result&lt;/code&gt; variable will be cleared before.</source>
          <target state="translated">URI를 구문 분석합니다. &lt;code&gt;result&lt;/code&gt; 변수는 이전에 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="fec7d8bb1b5440dcea9f8d95176ab435560994e3" translate="yes" xml:space="preserve">
          <source>Parses a URI. The &lt;em&gt;result&lt;/em&gt; variable will be cleared before.</source>
          <target state="translated">URI를 구문 분석합니다. &lt;em&gt;결과&lt;/em&gt; 변수는 이전에 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="47c6be8783069edfdf34c74b669c16a0475feedb" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 이진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="d18146fc030fe2a6ab8885a719a469a90008e5f4" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">에 포함 된 진 정수 값 구문 분석 &lt;em&gt;들&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb2463cc2ccaef503186bd51ebe5185565cfeb8" translate="yes" xml:space="preserve">
          <source>Parses a binary integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 에서 이진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="1930245a174e6900c3d7fb820106a1eb91eb1732" translate="yes" xml:space="preserve">
          <source>Parses a binary number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">이진수를 구문 분석하고 그 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="092905e90e391bd9b854c24a81b158dbbe52809b" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 10 진수 부동 소수점 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="835e144c44ca9aa9a0c3bc52fffba2a23a756070" translate="yes" xml:space="preserve">
          <source>Parses a decimal floating point value contained in &lt;em&gt;s&lt;/em&gt;. If &lt;em&gt;s&lt;/em&gt; is not a valid floating point number, &lt;em&gt;ValueError&lt;/em&gt; is raised. &lt;code&gt;NAN&lt;/code&gt;, &lt;code&gt;INF&lt;/code&gt;, &lt;code&gt;-INF&lt;/code&gt; are also supported (case insensitive comparison).</source>
          <target state="translated">부동 소수점 값에 포함 된 소수 해석해 &lt;em&gt;들&lt;/em&gt; . &lt;em&gt;s&lt;/em&gt; 가 유효한 부동 소수점 숫자가 아닌 경우 &lt;em&gt;ValueError&lt;/em&gt; 가 발생합니다. &lt;code&gt;NAN&lt;/code&gt; , &lt;code&gt;INF&lt;/code&gt; , &lt;code&gt;-INF&lt;/code&gt; 도 지원됩니다 (대소 문자를 구분하지 않음).</target>
        </trans-unit>
        <trans-unit id="426b331688624b96220a72237b41278b8789b32f" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 10 진수 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="95acbbe3645191c11345e3af876888af39d5fe0a" translate="yes" xml:space="preserve">
          <source>Parses a decimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">구문 분석에 포함 된 진수 정수 값 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="50fee93e276e7a265a8ffb848b200df570c8c778" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 부호없는 10 진수 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="ed0e8f3670947e2eebff34e6614bd7b5cc662d7c" translate="yes" xml:space="preserve">
          <source>Parses a decimal unsigned integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;s에&lt;/em&gt; 포함 된 10 진수 부호없는 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="bd85b664c039d20903a1b3a0d045b4bbde454585" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if a parsing error occurred.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 에서 시작 하는 float를 구문 분석 하고 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 . 결과는 처리 된 문자 수이거나 구문 분석 오류가 발생한 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="685445d7be6759190f48fa0f51a191e497d2eba9" translate="yes" xml:space="preserve">
          <source>Parses a float starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there occurred a parsing error.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 에서 시작 하는 float를 구문 분석 하고 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 . 결과는 처리 된 문자 수 또는 구문 분석 오류가 발생한 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="3db44b06c6474e1abe579f57d2b9fb8d598fb0d1" translate="yes" xml:space="preserve">
          <source>Parses a hex integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 에서 16 진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="27840da795a5763a32afb1c0666c8f210e80f391" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 16 진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="2552cef1d7b2fd79db3dae66bea932dea01f7f48" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;s에&lt;/em&gt; 포함 된 16 진수 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="fc2488ed821276fa08bab01cec3a67e70fc3f6f8" translate="yes" xml:space="preserve">
          <source>Parses a hexadecimal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">16 진수를 구문 분석하고 그 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="cb54921c8152e46b53bfa74a90daf66afa228f80" translate="yes" xml:space="preserve">
          <source>Parses a natural number into &lt;code&gt;b&lt;/code&gt;. This cannot raise an overflow error. &lt;code&gt;high(int)&lt;/code&gt; is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of &lt;span id=&quot;parseint_1&quot;&gt;parseInt&lt;/span&gt;.</source>
          <target state="translated">자연수를 &lt;code&gt;b&lt;/code&gt; 로 구문 분석합니다 . 이로 인해 오버플로 오류가 발생할 수 없습니다. 오버플로에 대해 &lt;code&gt;high(int)&lt;/code&gt; 가 반환됩니다. 처리 된 문자 수를 반환합니다. 이것은 일반적으로 &lt;span id=&quot;parseint_1&quot;&gt;parseInt&lt;/span&gt; 대신 실제로 사용하려는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="52772096a4233cc51e1600d105de8977b1778a95" translate="yes" xml:space="preserve">
          <source>Parses a single raw header HTTP line into key value pairs.</source>
          <target state="translated">단일 원시 헤더 HTTP 행을 키 값 쌍으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="95b650c6035e72c967c98b41c7ebcc9dd65e6d54" translate="yes" xml:space="preserve">
          <source>Parses a string into an AST, returning the top node. &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;, although optional, provide info so that the compiler can generate correct error messages referring to the original source.</source>
          <target state="translated">문자열을 AST로 구문 분석하여 최상위 노드를 반환합니다. &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 은 선택 사항이지만 컴파일러가 원래 소스를 참조하는 올바른 오류 메시지를 생성 할 수 있도록 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9c701c28b798a044aaf1117a96e54a0c2d5f2da3" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the &lt;code&gt;until&lt;/code&gt; token.</source>
          <target state="translated">거기에 토큰 저장 구문 분석 &lt;code&gt;token&lt;/code&gt; . 구문 분석 된 문자의 수를 반환하거나 오류가 발생한 경우 0을 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 토큰은 &lt;code&gt;until&lt;/code&gt; 토큰 앞에 오는 모든 문자로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b36b9f501444b04abc01044f2ebfde091271a4b2" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the &lt;code&gt;until&lt;/code&gt; character.</source>
          <target state="translated">거기에 토큰 저장 구문 분석 &lt;code&gt;token&lt;/code&gt; . 구문 분석 된 문자의 수를 반환하거나 오류가 발생한 경우 0을 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 토큰은 &lt;code&gt;until&lt;/code&gt; 문자 가 아닌 모든 문자로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0d3eec3b6b0406b84be0d5701498cd7d574a854" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in &lt;code&gt;validChars&lt;/code&gt;.</source>
          <target state="translated">거기에 토큰 저장 구문 분석 &lt;code&gt;token&lt;/code&gt; . 구문 분석 된 문자의 수를 반환하거나 오류가 발생한 경우 0을 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 토큰은 &lt;code&gt;validChars&lt;/code&gt; 의 문자로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e97d02f27717f5551aacbc5a29f3102a29c8b007" translate="yes" xml:space="preserve">
          <source>Parses a token and stores it in &lt;code&gt;token&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin &lt;code&gt;until&lt;/code&gt;.</source>
          <target state="translated">거기에 토큰 저장 구문 분석 &lt;code&gt;token&lt;/code&gt; . 구문 분석 된 문자의 수를 반환하거나 오류가 발생한 경우 0을 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 토큰은 &lt;code&gt;until&lt;/code&gt; 의 문자로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e6a8d0899321496ee5b4707a4985a56d004222b" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">값을 &lt;code&gt;bool&lt;/code&gt; 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="42c29907580552c41f83b6dee8503b24b04303ca" translate="yes" xml:space="preserve">
          <source>Parses a value into a &lt;em&gt;bool&lt;/em&gt;.</source>
          <target state="translated">값을 &lt;em&gt;bool&lt;/em&gt; 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="410e8b23cd46010b49b0dd0e3914dc4ecc9e1ca5" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises EInvalidValue on error</source>
          <target state="translated">IP 주소 구문 분석 오류 발생시 EInvalidValue가 발생합니다</target>
        </trans-unit>
        <trans-unit id="3868d092804175ec95080b3c3f82ec8e767af1ea" translate="yes" xml:space="preserve">
          <source>Parses an IP address Raises ValueError on error</source>
          <target state="translated">IP 주소를 구문 분석하여 오류 발생시 ValueError 발생</target>
        </trans-unit>
        <trans-unit id="2a6850ab1bcfc38172914099c85e87137a9e1a8e" translate="yes" xml:space="preserve">
          <source>Parses an binary number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">이진수를 구문 분석하고 그 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 . 파싱 ​​된 문자 수를 반환하거나 오류가 발생한 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52ecab5e0e696e851dd2d8e05a4efb7aef630d77" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">열거 형 &lt;code&gt;T&lt;/code&gt; 를 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="ed985855211a09c313ddd3d2ad1eecc68c677350" translate="yes" xml:space="preserve">
          <source>Parses an enum &lt;code&gt;T&lt;/code&gt;. This errors at compile time, if the given enum type contains multiple fields with the same string value.</source>
          <target state="translated">열거 형 &lt;code&gt;T&lt;/code&gt; 를 구문 분석합니다 . 주어진 열거 형 유형에 동일한 문자열 값을 가진 여러 필드가 포함 된 경우 컴파일 타임에이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d7b43b85907d5ddc55c4b3714b6a9769b28c6493" translate="yes" xml:space="preserve">
          <source>Parses an identifier and returns it or an empty string in case of an error.</source>
          <target state="translated">식별자를 구문 분석하고 오류가 발생한 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9ec9442ce0c86283d4a625d404705eba967848b" translate="yes" xml:space="preserve">
          <source>Parses an identifier and stores it in &lt;code&gt;ident&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">식별자를 구문 분석하고 &lt;code&gt;ident&lt;/code&gt; 에 저장합니다 . 구문 분석 된 문자의 수를 반환하거나 오류가 발생한 경우 0을 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="2e77e0c344edc805c7867507e4487f62806f9022" translate="yes" xml:space="preserve">
          <source>Parses an integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. Result is the number of processed chars or 0 if there is no integer. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="translated">시작에서 &lt;code&gt;start&lt;/code&gt; 하는 정수를 구문 분석 하고 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 . 결과는 처리 된 문자 수 또는 정수가없는 경우 0입니다. 구문 분석 된 정수가 유효한 범위를 벗어나면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db59fe378bf2dcbcb71f7d850662780bf0b1cbaf" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 에 포함 된 8 진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="1300628673257382b63897d5a63358653f3d654e" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value contained in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">에 포함 된 진수 정수 값 구문 분석 &lt;em&gt;들&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8728b9534afce3f642e4b3aebeb7678eb66fd67f" translate="yes" xml:space="preserve">
          <source>Parses an octal integer value from a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 에서 8 진 정수 값을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="7401e15eeba63dc0b50156bc802bc4478ad2f731" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">8 진수를 구문 분석하고 그 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="77b4c05a71f0a355fc50b443e92107cc745a1c8a" translate="yes" xml:space="preserve">
          <source>Parses an octal number and stores its value in &lt;code&gt;number&lt;/code&gt;. Returns the number of the parsed characters or 0 in case of an error.</source>
          <target state="translated">8 진수를 구문 분석하고 그 값을 &lt;code&gt;number&lt;/code&gt; 에 저장합니다 . 파싱 ​​된 문자 수를 반환하거나 오류가 발생한 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13fd10e0aeee81890876e811b26e03b135d51ed9" translate="yes" xml:space="preserve">
          <source>Parses an unsigned integer starting at &lt;code&gt;start&lt;/code&gt; and stores the value into &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if the parsed integer is out of the valid range.</source>
          <target state="translated">시작 부호없는 정수 구문 분석 &lt;code&gt;start&lt;/code&gt; 및 저장에 값 &lt;code&gt;number&lt;/code&gt; . 구문 분석 된 정수가 유효한 범위를 벗어나면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="541ca66d4dbc79404bc942d6bfb6c2be8439048d" translate="yes" xml:space="preserve">
          <source>Parses from a buffer &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;SexpNode&lt;/em&gt;.</source>
          <target state="translated">버퍼로부터의 파스 &lt;em&gt;S&lt;/em&gt; (A) 내로 &lt;em&gt;SexpNode&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ce15ddb51f7707db52e2ae68e86add81e03689ed" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;JsonNodes&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. The JSON fragments are separated by whitespace. This can be substantially faster than the comparable loop &lt;code&gt;for x in splitWhitespace(s): yield parseJson(x)&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="translated">스트림에서 해석하고는 &lt;code&gt;s&lt;/code&gt; 로 &lt;code&gt;JsonNodes&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; 은 멋진 오류 메시지에만 필요합니다. JSON 조각은 공백으로 구분됩니다. 이것은 &lt;code&gt;for x in splitWhitespace(s): yield parseJson(x)&lt;/code&gt; 유사한 루프보다 훨씬 빠를 수 있습니다 . 이 스트림이 닫 &lt;code&gt;s&lt;/code&gt; 가 이루어집니다 후에. 경우 &lt;code&gt;rawIntegers&lt;/code&gt; 는 사실, 정수 리터럴은 변환되지 않습니다 &lt;code&gt;JInt&lt;/code&gt; 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; . 경우 &lt;code&gt;rawFloats&lt;/code&gt; 는 사실이다, 부동 소수점 리터럴은 변환되지 않습니다 &lt;code&gt;JFloat&lt;/code&gt; 의 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14a309dc0181d3f0cb9ac7df4853c24a9cc3a1bc" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;code&gt;s&lt;/code&gt; into a &lt;code&gt;JsonNode&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; is only needed for nice error messages. If &lt;code&gt;s&lt;/code&gt; contains extra data, it will raise &lt;code&gt;JsonParsingError&lt;/code&gt;. This closes the stream &lt;code&gt;s&lt;/code&gt; after it's done. If &lt;code&gt;rawIntegers&lt;/code&gt; is true, integer literals will not be converted to a &lt;code&gt;JInt&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;. If &lt;code&gt;rawFloats&lt;/code&gt; is true, floating point literals will not be converted to a &lt;code&gt;JFloat&lt;/code&gt; field but kept as raw numbers via &lt;code&gt;JString&lt;/code&gt;.</source>
          <target state="translated">스트림에서 구문 분석 &lt;code&gt;s&lt;/code&gt; 에 &lt;code&gt;JsonNode&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; 은 멋진 오류 메시지에만 필요합니다. &lt;code&gt;s&lt;/code&gt; 에 추가 데이터가 포함되어 있으면 &lt;code&gt;JsonParsingError&lt;/code&gt; 가 발생 합니다. 이 스트림이 닫 &lt;code&gt;s&lt;/code&gt; 가 이루어집니다 후에. 경우 &lt;code&gt;rawIntegers&lt;/code&gt; 는 사실, 정수 리터럴은 변환되지 않습니다 &lt;code&gt;JInt&lt;/code&gt; 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; . 경우 &lt;code&gt;rawFloats&lt;/code&gt; 는 사실이다, 부동 소수점 리터럴은 변환되지 않습니다 &lt;code&gt;JFloat&lt;/code&gt; 의 필드하지만 통해 원시 숫자로 유지 &lt;code&gt;JString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8f09fb29abff457c84ba95e0bc8011331d06c2a" translate="yes" xml:space="preserve">
          <source>Parses from a stream &lt;em&gt;s&lt;/em&gt; into a &lt;em&gt;JsonNode&lt;/em&gt;. &lt;em&gt;filename&lt;/em&gt; is only needed for nice error messages. If &lt;em&gt;s&lt;/em&gt; contains extra data, it will raise &lt;em&gt;JsonParsingError&lt;/em&gt;.</source>
          <target state="translated">스트림에서 구문 분석 &lt;em&gt;의&lt;/em&gt; 에 &lt;em&gt;JsonNode&lt;/em&gt; . &lt;em&gt;filename&lt;/em&gt; 은 멋진 오류 메시지에만 필요합니다. &lt;em&gt;s&lt;/em&gt; 에 추가 데이터가 포함되어 있으면 &lt;em&gt;JsonParsingError가 발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c205fbee41ffe389bcaa089240a73bbb6a3cbbdc" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">스트림에서 HTML 구문 분석 &lt;code&gt;s&lt;/code&gt; 과 반환 &lt;code&gt;XmlNode&lt;/code&gt; . 모든 구문 분석 오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7392bd1dfd3616a852a08b90df502af326331916" translate="yes" xml:space="preserve">
          <source>Parses the HTML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">스트림에서 HTML 구문 분석 &lt;em&gt;들&lt;/em&gt; 과 반환 &lt;code&gt;XmlNode&lt;/code&gt; . 모든 구문 분석 오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d6b6e4325404bd4282ae6db6786d3c6cdde20d0" translate="yes" xml:space="preserve">
          <source>Parses the HTML from string &lt;code&gt;html&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are ignored.</source>
          <target state="translated">문자열 &lt;code&gt;html&lt;/code&gt; 에서 HTML을 구문 분석하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 모든 구문 분석 오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b291cc50ee23e8b1901cb7970d7d44a0a902e25" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">스트림에서 XML 파싱 &lt;code&gt;s&lt;/code&gt; 과 반환 &lt;code&gt;XmlNode&lt;/code&gt; . 모든 구문 분석 오류는 &lt;code&gt;XmlError&lt;/code&gt; 예외 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="377e589d2efc7bd7f0d783557a0305ff1980a8dc" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;code&gt;s&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;code&gt;errors&lt;/code&gt; sequence.</source>
          <target state="translated">스트림에서 XML 파싱 &lt;code&gt;s&lt;/code&gt; 과 반환 &lt;code&gt;XmlNode&lt;/code&gt; . 발생한 모든 구문 분석 오류가 &lt;code&gt;errors&lt;/code&gt; 순서에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="693b35a301ba4a3e77a1617dfcdfe0c2eea41014" translate="yes" xml:space="preserve">
          <source>Parses the XML from stream &lt;em&gt;s&lt;/em&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. Every occurred parsing error is added to the &lt;em&gt;errors&lt;/em&gt; sequence.</source>
          <target state="translated">스트림에서 XML 파싱 &lt;em&gt;들&lt;/em&gt; 과 반환 &lt;code&gt;XmlNode&lt;/code&gt; . 발생한 모든 구문 분석 오류가 &lt;em&gt;오류&lt;/em&gt; 순서에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="000730be1a0f93678cf7000c57f6c22e66d7b0b4" translate="yes" xml:space="preserve">
          <source>Parses the XML from string &lt;code&gt;str&lt;/code&gt; and returns a &lt;code&gt;XmlNode&lt;/code&gt;. All parsing errors are turned into an &lt;code&gt;XmlError&lt;/code&gt; exception.</source>
          <target state="translated">문자열 &lt;code&gt;str&lt;/code&gt; 에서 XML을 구문 분석하고 &lt;code&gt;XmlNode&lt;/code&gt; 를 반환합니다 . 모든 구문 분석 오류는 &lt;code&gt;XmlError&lt;/code&gt; 예외 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="6e94cd8428f25354a33870cff6f77b016ec0d7c9" translate="yes" xml:space="preserve">
          <source>Parses the next token.</source>
          <target state="translated">다음 토큰을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="15086c718d34668e53394d9f878ee54b1f9d49b1" translate="yes" xml:space="preserve">
          <source>Parses the rest of the input stream held by the parser into a PNode.</source>
          <target state="translated">파서가 보유한 나머지 입력 스트림을 PNode로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="e5e5e69e286e3687e8e65c82c15218f29cdccbe5" translate="yes" xml:space="preserve">
          <source>Parsing JSON</source>
          <target state="translated">JSON 구문 분석</target>
        </trans-unit>
        <trans-unit id="a8f8861222174c27dc6101721594edce57bf1ada" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;code&gt;Peg&lt;/code&gt; nodes with the &lt;code&gt;peg&lt;/code&gt; proc.</source>
          <target state="translated">&lt;code&gt;peg&lt;/code&gt; proc을 사용하여 &lt;code&gt;Peg&lt;/code&gt; 노드 로 구성된 AST로 문자열을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="0d46a080325775ed12fd3ffd5aa0a8d40db7175c" translate="yes" xml:space="preserve">
          <source>Parsing a string into an AST which consists of &lt;em&gt;Peg&lt;/em&gt; nodes with the &lt;em&gt;peg&lt;/em&gt; proc.</source>
          <target state="translated">&lt;em&gt;peg&lt;/em&gt; proc 이있는 &lt;em&gt;Peg&lt;/em&gt; 노드 로 구성된 AST로 문자열을 구문 분석합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d1213aa0c980986abc9cfe893f564f800d35d51" translate="yes" xml:space="preserve">
          <source>Parsing and Formatting Dates</source>
          <target state="translated">날짜 구문 분석 및 형식화</target>
        </trans-unit>
        <trans-unit id="e8de9b67e60bfc9e5a53216bb30c98671e868ddb" translate="yes" xml:space="preserve">
          <source>Parsing idetools output</source>
          <target state="translated">idetools 출력 구문 분석</target>
        </trans-unit>
        <trans-unit id="1800737251d65799e8ed6a97afb24d8a2b9918ef" translate="yes" xml:space="preserve">
          <source>Parsing nimsuggest output</source>
          <target state="translated">가장 큰 출력 구문 분석</target>
        </trans-unit>
        <trans-unit id="5a01db6f2d606f2a701b77fbab0924cc899be0e3" translate="yes" xml:space="preserve">
          <source>Part 2</source>
          <target state="translated">2 부</target>
        </trans-unit>
        <trans-unit id="859cfaaaeaf6a8ced2a1b65b58557fb95d875c48" translate="yes" xml:space="preserve">
          <source>Part of a pattern that is in square brackets is called a &quot;character class&quot;. In a character class the only metacharacters are:</source>
          <target state="translated">대괄호 안에있는 패턴의 일부를 &quot;문자 클래스&quot;라고합니다. 문자 클래스에서 유일한 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9269695463c8a5faa720fae720afebc9f6ef9e73" translate="yes" xml:space="preserve">
          <source>Partial Output:</source>
          <target state="translated">부분 출력 :</target>
        </trans-unit>
        <trans-unit id="d9152c0a90009a287d69e549232b96c390e66d7e" translate="yes" xml:space="preserve">
          <source>Partial:</source>
          <target state="translated">Partial:</target>
        </trans-unit>
        <trans-unit id="d2ed3ad5db69194cd3d8766327afd474a9733e0f" translate="yes" xml:space="preserve">
          <source>Partially supported OS: Windows (only sockets and user events), Solaris (files, sockets, handles and user events). Android (files, sockets, handles and user events).</source>
          <target state="translated">부분적으로 지원되는 OS : Windows (소켓 및 사용자 이벤트 만), Solaris (파일, 소켓, 핸들 및 사용자 이벤트) Android (파일, 소켓, 핸들 및 사용자 이벤트)</target>
        </trans-unit>
        <trans-unit id="f8b3b0ce73b2c887fc04e170a70ba3e345ca3ea2" translate="yes" xml:space="preserve">
          <source>Partition variables into different graphs. Used for Nim's write tracking, borrow checking and also for the cursor inference. The algorithm is a reinvention / variation of Steensgaard's algorithm. The used data structure is &quot;union find&quot; with path compression.We perform two passes over the AST:</source>
          <target state="translated">변수를 다른 그래프로 분할합니다. Nim의 쓰기 추적, 차용 확인 및 커서 추론에 사용됩니다. 알고리즘은 Steensgaard 알고리즘의 재발 명 / 변형입니다. 사용되는 데이터 구조는 경로 압축을 사용하는 &quot;union find&quot;입니다. AST를 통해 두 번의 패스를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="447a6d9d5a5bea5594901fb1228ca57d5eb5c3aa" translate="yes" xml:space="preserve">
          <source>Partitions:</source>
          <target state="translated">Partitions:</target>
        </trans-unit>
        <trans-unit id="8a171b6aa4025579258fcd2c8b48f01cfb4c51c1" translate="yes" xml:space="preserve">
          <source>Parts of the string that are enclosed in the curly braces are interpreted as Nim code, to escape an &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;}&lt;/code&gt; double it.</source>
          <target state="translated">중괄호로 묶인 문자열 부분은 Nim 코드로 해석되어 &lt;code&gt;{&lt;/code&gt; 또는 &lt;code&gt;}&lt;/code&gt; 를 이스케이프 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="ae5e4613a5a66f977a85dd0954ce24e4cb776f3b" translate="yes" xml:space="preserve">
          <source>Pass one (&lt;code&gt;computeLiveRanges&lt;/code&gt;): collect livetimes of local variables and whether they are potentially re-assigned.</source>
          <target state="translated">하나 전달 ( &lt;code&gt;computeLiveRanges&lt;/code&gt; ) : 지역 변수의 실시간 시간과 잠재적으로 재 할당되는지 여부를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="8aca8fe67e97585de445057c4943ea7782cef87e" translate="yes" xml:space="preserve">
          <source>Pass the filename and an array of times to set the access and modification times respectively. If you pass nil as the array both attributes will be set to the current time.</source>
          <target state="translated">파일 이름과 시간 배열을 전달하여 액세스 및 수정 시간을 각각 설정하십시오. 배열로 nil을 전달하면 두 속성이 모두 현재 시간으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ce3232a33ee700938d89f8cd85b81c950620aef7" translate="yes" xml:space="preserve">
          <source>Pass two (&lt;code&gt;traverse&lt;/code&gt;): combine local variables to abstract &quot;graphs&quot;. Strict func checking: Ensure that graphs that are connected to const parameters are not mutated.</source>
          <target state="translated">2 개 전달 ( &lt;code&gt;traverse&lt;/code&gt; ) : 지역 변수를 결합하여 &quot;그래프&quot;를 추상화합니다. 엄격한 기능 검사 : const 매개 변수에 연결된 그래프가 변경되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c6c5b9444c85f22cfca7c6842fd1c77d3d446d19" translate="yes" xml:space="preserve">
          <source>PassC pragma</source>
          <target state="translated">PassC pragma</target>
        </trans-unit>
        <trans-unit id="27478f48296583129eac069e5087f2d2b0da482f" translate="yes" xml:space="preserve">
          <source>PassL pragma</source>
          <target state="translated">PassL 프라 그마</target>
        </trans-unit>
        <trans-unit id="63887463770a134a992bce27e42d7f2d2c85fd99" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;typedesc&lt;/code&gt; almost identical, just with the differences that the macro is not instantiated generically. The type expression is simply passed as a &lt;code&gt;NimNode&lt;/code&gt; to the macro, like everything else.</source>
          <target state="translated">매크로가 일반적으로 인스턴스화되지 않는다는 차이점 만 &lt;code&gt;typedesc&lt;/code&gt; 하면 typedesc를 거의 동일하게 전달 합니다. 유형 표현식은 다른 모든 것과 마찬가지로 &lt;code&gt;NimNode&lt;/code&gt; 로 매크로에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f9f364778543f2d3d56cfb6fbfab613d11d558c" translate="yes" xml:space="preserve">
          <source>Passing Channels Safely</source>
          <target state="translated">안전하게 채널 전달</target>
        </trans-unit>
        <trans-unit id="c1f8c2a994a126eaf7103a7c43409efdd75a983d" translate="yes" xml:space="preserve">
          <source>Passing a code block to a template</source>
          <target state="translated">코드 블록을 템플릿으로 전달</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c05a7dde4e8ae01915e872a2ecdbb5cd167032f4" translate="yes" xml:space="preserve">
          <source>Path expressions</source>
          <target state="translated">경로 표현식</target>
        </trans-unit>
        <trans-unit id="27560fcddb5cfbfe7af93f89dd7a53c8deb37a54" translate="yes" xml:space="preserve">
          <source>Path handling utilities for Nim. Strictly typed code in order to avoid the never ending time sink in getting path handling right.</source>
          <target state="translated">Nim 용 경로 처리 유틸리티. 경로 처리를 올바르게 수행하는 데 끝이없는 시간 낭비를 방지하기 위해 엄격하게 형식화 된 코드입니다.</target>
        </trans-unit>
        <trans-unit id="e2643c3434dcb6df9c1e72e6681f1bedc8ada4a0" translate="yes" xml:space="preserve">
          <source>Path names are syntactically either Nim identifiers or string literals. If the path name is not a valid Nim identifier it needs to be a string literal:</source>
          <target state="translated">경로 이름은 구문 적으로 Nim 식별자 또는 문자열 리터럴입니다. 경로 이름이 유효한 Nim 식별자가 아닌 경우 문자열 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1fff6a31661b491fc40cc9c1ad7fe5e479cb7500" translate="yes" xml:space="preserve">
          <source>Pattern</source>
          <target state="translated">Pattern</target>
        </trans-unit>
        <trans-unit id="7b6c2f9c3abcefd6eb4c4d0a0b5007e45b97a311" translate="yes" xml:space="preserve">
          <source>Pattern operators</source>
          <target state="translated">패턴 연산자</target>
        </trans-unit>
        <trans-unit id="b72a4aa7fcffcb55499f6f65d9d2148428770a18" translate="yes" xml:space="preserve">
          <source>Peeks a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 부울을 엿 봅니다.</target>
        </trans-unit>
        <trans-unit id="7b6a9eba2a7a8dfeec4fef0b5ee800ec7bce466c" translate="yes" xml:space="preserve">
          <source>Peeks a char from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 문자를 피킹합니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우. EOF 마커로 '\ 0'을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c30991c6b5bff2936cbd0d88e8d9f4f17f645b52" translate="yes" xml:space="preserve">
          <source>Peeks a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 float32를 피킹합니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="e9ae27eff9b512d1dc5c6f48c66a3d7a3a0a266d" translate="yes" xml:space="preserve">
          <source>Peeks a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 float64를 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="204f73ee7651322bcdfc2623d6c7a9dcb68585ef" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 라인을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="d82e5a058ac8dd2705ce01808437b2ad8b5084fa" translate="yes" xml:space="preserve">
          <source>Peeks a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;em&gt;s&lt;/em&gt; 에서 한 줄을 찾습니다 . 참고 : 이것은 매우 효율적이지 않습니다. 레이즈 &lt;em&gt;EIO&lt;/em&gt; 에러가 발생하면.</target>
        </trans-unit>
        <trans-unit id="c0f56bf840615055642d6528d6f868484cf2948c" translate="yes" xml:space="preserve">
          <source>Peeks a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="translated">스트림에서 한 줄의 텍스트를 엿보기 &lt;code&gt;s&lt;/code&gt; 에 &lt;code&gt;line&lt;/code&gt; . &lt;code&gt;line&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아니어야합니다 ! IO 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afacc1115ea965417732e73e255661db6f4983da" translate="yes" xml:space="preserve">
          <source>Peeks a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 길이 &lt;code&gt;length&lt;/code&gt; 의 문자열을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="5f9414855f96734b147ad15c7dde82de48212d4b" translate="yes" xml:space="preserve">
          <source>Peeks an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int16을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="296a55eb24e1b0188438c22d6c2625aee424270b" translate="yes" xml:space="preserve">
          <source>Peeks an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int32를 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="84da338eff9110ffe76ec04860083e3ad8d4fda0" translate="yes" xml:space="preserve">
          <source>Peeks an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int64를 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="a726c626471c71e2bea52828da149e79477e34db" translate="yes" xml:space="preserve">
          <source>Peeks an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int8을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="37554e75d27de5e874212c2847da8d22976d57a3" translate="yes" xml:space="preserve">
          <source>Peeks an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint16을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="8a11a5412c9e16f4d463046d5b50765daaf1c35b" translate="yes" xml:space="preserve">
          <source>Peeks an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint32를 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="d9288ec1fcb9b1804858ac1c31deefe90a164960" translate="yes" xml:space="preserve">
          <source>Peeks an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint64를 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="6e3cd9c754a426dc765433ad7315ebfc501dfc7f" translate="yes" xml:space="preserve">
          <source>Peeks an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint8을 엿 봅니다. 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="b5d4c57147bf5dd3bbcaf7bdfd58b0b2226cf25d" translate="yes" xml:space="preserve">
          <source>Per convention, all strings are UTF-8 strings, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;. The iterator &lt;code&gt;runes&lt;/code&gt; from the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt; can be used for iteration over all Unicode characters.</source>
          <target state="translated">규칙에 따라 모든 문자열은 UTF-8 문자열이지만 적용되지는 않습니다. 예를 들어, 이진 파일에서 문자열을 읽을 때는 단순히 바이트 시퀀스 일뿐입니다. 인덱스 연산 &lt;code&gt;s[i]&lt;/code&gt; 는 i 번째 &lt;em&gt;unichar가&lt;/em&gt; 아니라 &lt;code&gt;s&lt;/code&gt; 의 i 번째 &lt;em&gt;char&lt;/em&gt; 을 의미합니다 . 반복자의 &lt;code&gt;runes&lt;/code&gt; 로부터 &lt;a href=&quot;unicode&quot;&gt;유니 코드 모듈은&lt;/a&gt; 모든 유니 코드 문자를 통해 반복 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ff72f9179ae9e4a2376a59a5c8d0eeb265a32c2e" translate="yes" xml:space="preserve">
          <source>Per default templates are &lt;span id=&quot;hygienic_2&quot;&gt;hygienic&lt;/span&gt;: Local identifiers declared in a template cannot be accessed in the instantiation context:</source>
          <target state="translated">기본 템플릿은 &lt;span id=&quot;hygienic_2&quot;&gt;위생적입니다&lt;/span&gt; . 인스턴스화 컨텍스트에서 템플릿에 선언 된 로컬 식별자에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="231131ea1a3863240874952ad37cf345067f33f6" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;new(x)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new(x)&lt;/code&gt; 수행합니다 . &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;ref&lt;/code&gt; 를 나타내야합니다 .</target>
        </trans-unit>
        <trans-unit id="f89cf973516a4a21e210bf15d9d57a4a7110ea58" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;newSeq(x, len)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newSeq(x, len)&lt;/code&gt; 수행합니다 . &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;seq&lt;/code&gt; 를 나타내야합니다 .</target>
        </trans-unit>
        <trans-unit id="7013d1f7d9f5962bdcdf6809fa5ec60bd9876b80" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;setLen(x, x.len+1)&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; needs to represent a &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">행한다 &lt;code&gt;setLen(x, x.len+1)&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;seq&lt;/code&gt; 를 나타내야합니다 .</target>
        </trans-unit>
        <trans-unit id="3450f41878523c76e1512334d0b887875e232269" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 딥 카피 수행 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155215fde1aa26f3ee38c0933534e538b88f9ae9" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;code&gt;y&lt;/code&gt; and copies it into &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 의 전체 복사를 수행하고 &lt;code&gt;x&lt;/code&gt; 에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="c1cd9242728b5c1a926850fd325c67f2fc62426b" translate="yes" xml:space="preserve">
          <source>Performs a deep copy of &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">의 딥 카피 수행 &lt;em&gt;을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcfc2453a55ae0dddd53cdf78d2032544f6ddc57" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions.</source>
          <target state="translated">요소 범위에서 왼쪽 회전을 수행합니다. 오른쪽으로 회전하려면 음의 &lt;code&gt;dist&lt;/code&gt; 를 사용하십시오 . 특히 &lt;code&gt;rotateLeft&lt;/code&gt; 는 &lt;code&gt;dist&lt;/code&gt; 위치 에 따라 &lt;code&gt;slice&lt;/code&gt; 에서 요소를 회전합니다 .</target>
        </trans-unit>
        <trans-unit id="88fc1469f461af1ae348df9943fa1632f7f69e69" translate="yes" xml:space="preserve">
          <source>Performs a left rotation on a range of elements. If you want to rotate right, use a negative &lt;code&gt;dist&lt;/code&gt;. Specifically, &lt;code&gt;rotateLeft&lt;/code&gt; rotates the elements at &lt;code&gt;slice&lt;/code&gt; by &lt;code&gt;dist&lt;/code&gt; positions. The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;. The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;. The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;. The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="translated">다양한 요소에서 왼쪽 회전을 수행합니다. 오른쪽으로 회전하려면 음수 &lt;code&gt;dist&lt;/code&gt; 를 사용하십시오 . 구체적 &lt;code&gt;rotateLeft&lt;/code&gt; 는 의 회전 요소 &lt;code&gt;slice&lt;/code&gt; 하여 &lt;code&gt;dist&lt;/code&gt; 위치. 인덱스에있는 요소 &lt;code&gt;slice.a + dist&lt;/code&gt; 인덱스에있을 것입니다 &lt;code&gt;slice.a&lt;/code&gt; . 인덱스의 요소 &lt;code&gt;slice.b&lt;/code&gt; 가 있을 것 &lt;code&gt;slice.a + dist -1&lt;/code&gt; . 인덱스에있는 요소 &lt;code&gt;slice.a&lt;/code&gt; 가 있을 것 &lt;code&gt;slice.b + 1 - dist&lt;/code&gt; . 인덱스에있는 요소 &lt;code&gt;slice.a + dist - 1&lt;/code&gt; 에있을 것입니다 &lt;code&gt;slice.b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="547e7eb2c01a8b7516cb21056d0deeb73c558d11" translate="yes" xml:space="preserve">
          <source>PersistentNodeFlags:</source>
          <target state="translated">PersistentNodeFlags:</target>
        </trans-unit>
        <trans-unit id="fccc2964329a971b590ec4a8a9af70e6f9bbd4ae" translate="yes" xml:space="preserve">
          <source>Pins a thread to a &lt;span id=&quot;cpu_1&quot;&gt;CPU&lt;/span&gt;.</source>
          <target state="translated">스레드를 &lt;span id=&quot;cpu_1&quot;&gt;CPU에 고정&lt;/span&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d668e43bf0a5743410bd7ab9e0edf6b66e6ccd9e" translate="yes" xml:space="preserve">
          <source>Pipe operator</source>
          <target state="translated">파이프 오퍼레이터</target>
        </trans-unit>
        <trans-unit id="1712134a62aaf8aeb730f1ebe5c06b3ad4796c1b" translate="yes" xml:space="preserve">
          <source>Platform specific file extension for executables. On Windows &lt;code&gt;[&quot;exe&quot;, &quot;cmd&quot;, &quot;bat&quot;]&lt;/code&gt;, on Posix &lt;code&gt;[&quot;&quot;]&lt;/code&gt;.</source>
          <target state="translated">실행 파일에 대한 플랫폼 별 파일 확장자입니다. Windows &lt;code&gt;[&quot;exe&quot;, &quot;cmd&quot;, &quot;bat&quot;]&lt;/code&gt; , Posix &lt;code&gt;[&quot;&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9801141d70e8a14926ba6354cb8932aea11f6959" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all constant expressions. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="translated">주의하시기 바랍니다 &lt;code&gt;static T&lt;/code&gt; 단지 기본 제네릭 형식에 대한 구문 편리 &lt;code&gt;static[T]&lt;/code&gt; . 모든 상수 표현식의 유형 클래스를 얻기 위해 유형 매개 변수를 생략 할 수 있습니다. 다른 유형 클래스로 &lt;code&gt;static&lt;/code&gt; 을 인스턴스화하여보다 구체적인 유형 클래스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91502d9216b226c484d80d6fd0eebe1eb9ccca35" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;static T&lt;/code&gt; is just a syntactic convenience for the underlying generic type &lt;code&gt;static[T]&lt;/code&gt;. The type param can be omitted to obtain the type class of all values known at compile-time. A more specific type class can be created by instantiating &lt;code&gt;static&lt;/code&gt; with another type class.</source>
          <target state="translated">주의하시기 바랍니다 &lt;code&gt;static T&lt;/code&gt; 단지 기본 제네릭 형식에 대한 구문 편리 &lt;code&gt;static[T]&lt;/code&gt; . 컴파일시 알려진 모든 값의 유형 클래스를 얻기 위해 type param을 생략 할 수 있습니다. 다른 유형 클래스를 사용하여 &lt;code&gt;static&lt;/code&gt; 을 인스턴스화하여보다 구체적인 유형 클래스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="376e940c0f4ede252519f2b91f3c32d65164170e" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;code&gt;seq[AnnotatedPtr[T]]&lt;/code&gt; or &lt;code&gt;RingBuffer[AnnotatedPtr[T]]&lt;/code&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="translated">Nim은 사용자 정의 포인터 유사 유형을 내장 포인터 유형에 대한 적절한 대안으로 취급합니다. 즉, &lt;code&gt;seq[AnnotatedPtr[T]]&lt;/code&gt; 또는 &lt;code&gt;RingBuffer[AnnotatedPtr[T]]&lt;/code&gt; 와 같은 유형도 공변으로 간주되며 다른 사용자 정의 포인터 유사 유형을 인스턴스화하여 새로운 포인터 유사 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a448e8765ceed97b70d742a1fbff8cbe9813f8" translate="yes" xml:space="preserve">
          <source>Please note that Nim will treat the user-defined pointer-like types as proper alternatives to the built-in pointer types. That is, types such as &lt;em&gt;seq[AnnotatedPtr[T]]&lt;/em&gt; or &lt;em&gt;RingBuffer[AnnotatedPtr[T]]&lt;/em&gt; will also be considered covariant and you can create new pointer-like types by instantiating other user-defined pointer-like types.</source>
          <target state="translated">Nim은 사용자 정의 포인터와 유사한 유형을 내장 포인터 유형의 적절한 대안으로 취급합니다. 즉, &lt;em&gt;seq [AnnotatedPtr [T]]&lt;/em&gt; 또는 &lt;em&gt;RingBuffer [AnnotatedPtr [T]]&lt;/em&gt; 와 같은 유형도 공변량으로 간주되며 다른 사용자 정의 포인터 유사 유형을 인스턴스화하여 새 포인터 유사 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31de791033a98daa5433ce403ccf2d1db3a3ae55" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;code&gt;Enumerable[T]&lt;/code&gt; can be matched against concrete types such as &lt;code&gt;string&lt;/code&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;code&gt;genericHead&lt;/code&gt; or &lt;code&gt;stripGenericParams&lt;/code&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;code&gt;Functor&lt;/code&gt; concept from Haskell and then demonstrate that Nim's &lt;code&gt;Option[T]&lt;/code&gt; type is an instance of it:</source>
          <target state="translated">&lt;code&gt;Enumerable[T]&lt;/code&gt; 와 같은 일반 개념 은 &lt;code&gt;string&lt;/code&gt; 과 같은 구체적인 유형과 일치시킬 수 있습니다 . Nim은 개념 유형이 일치하는 유형과 동일한 수의 매개 변수를 가질 필요가 없습니다. 일치 된 유형의 일반 매개 변수에 대한 요구 사항을 표현하려는 경우 개념 본문 내에서 &lt;code&gt;genericHead&lt;/code&gt; 또는 &lt;code&gt;stripGenericParams&lt;/code&gt; 와 같은 유형 맵핑 연산자를 사용하여 유형의 인스턴스화되지 않은 버전을 얻을 수 있습니다. 필요한 방식으로. 예를 들어, 다음은 Haskell에서 고전적인 &lt;code&gt;Functor&lt;/code&gt; 개념을 정의한 다음 Nim의 &lt;code&gt;Option[T]&lt;/code&gt; 유형이 그 인스턴스 임을 보여주는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="c6121f8f77a7e5843548ab29d76b72f1fdf494af" translate="yes" xml:space="preserve">
          <source>Please note that generic concepts such as &lt;em&gt;Enumerable[T]&lt;/em&gt; can be matched against concrete types such as &lt;em&gt;string&lt;/em&gt;. Nim doesn't require the concept type to have the same number of parameters as the type being matched. If you wish to express a requirement towards the generic parameters of the matched type, you can use a type mapping operator such as &lt;em&gt;genericHead&lt;/em&gt; or &lt;em&gt;stripGenericParams&lt;/em&gt; within the body of the concept to obtain the uninstantiated version of the type, which you can then try to instantiate in any required way. For example, here is how one might define the classic &lt;em&gt;Functor&lt;/em&gt; concept from Haskell and then demonstrate that Nim's &lt;em&gt;Option[T]&lt;/em&gt; type is an instance of it:</source>
          <target state="translated">&lt;em&gt;Enumerable [T]&lt;/em&gt; 와 같은 일반적인 개념 은 &lt;em&gt;string&lt;/em&gt; 과 같은 구체적인 유형과 비교 될 수 있습니다 . Nim은 개념 유형에 일치하는 유형과 동일한 수의 매개 변수가 필요하지 않습니다. 일치하는 유형의 일반 매개 변수에 대한 요구 사항을 표현하려는 경우 개념 본문 내에서 &lt;em&gt;genericHead&lt;/em&gt; 또는 &lt;em&gt;stripGenericParams&lt;/em&gt; 와 같은 유형 맵핑 연산자를 사용하여 유형의 인스턴스화되지 않은 버전을 얻을 수 있습니다. 필요한 방식으로. 예를 들어, 다음은 Haskell 의 클래식 &lt;em&gt;Functor&lt;/em&gt; 개념을 정의한 다음 Nim의 &lt;em&gt;Option [T]&lt;/em&gt; 유형이 그 예임을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f5ca38697a6a448107efa272f859558c7b3efed4" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;is&lt;/code&gt; operator allows one to easily verify the precise type signatures of the required operations, but since type inference and default parameters are still applied in the concept body, it's also possible to describe usage protocols that do not reveal implementation details.</source>
          <target state="translated">(가) 있습니다 &lt;code&gt;is&lt;/code&gt; 연산자는 하나 쉽게 필요한 작업의 정확한 유형의 서명을 확인 할 수 있지만 형식 유추 및 기본 매개 변수가 여전히 개념 본문에 적용되기 때문에, 그것은 구현 세부 사항을 공개하지 않는 사용 프로토콜을 설명하는 것도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="84b24489b92fa55264426ed8af25adfd53357fe7" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;the manual&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;은 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57833aa974b0e7c9c5481b4733aa65f3e38c1c57" translate="yes" xml:space="preserve">
          <source>Plugin support for the Nim compiler. Right now plugins need to be built with the compiler only: plugins using DLLs or the FFI will not work.</source>
          <target state="translated">Nim 컴파일러에 대한 플러그인 지원. 현재 플러그인은 컴파일러로만 빌드해야합니다. DLL 또는 FFI를 사용하는 플러그인은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cc451d63fbb704536042da563053eb7ff831435" translate="yes" xml:space="preserve">
          <source>Plugin to transform an inline iterator into a data structure.</source>
          <target state="translated">인라인 반복기를 데이터 구조로 변환하는 플러그인.</target>
        </trans-unit>
        <trans-unit id="6aae53af150b3796d306eb4ef6355e27209ba89b" translate="yes" xml:space="preserve">
          <source>Plugin:</source>
          <target state="translated">Plugin:</target>
        </trans-unit>
        <trans-unit id="57941ad380b619af368380c59a568808bb67d5c6" translate="yes" xml:space="preserve">
          <source>Pointer dereference &lt;code&gt;e[]&lt;/code&gt; is a path expression.</source>
          <target state="translated">포인터 역 참조 &lt;code&gt;e[]&lt;/code&gt; 는 경로 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="1e396fac5e10a7261ea311d079d21e12d48a8e32" translate="yes" xml:space="preserve">
          <source>Pop and return the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="translated">현재 가장 작은 값을 팝하여 반환하고 새 항목을 추가하십시오. 이것은 pop () 다음에 push ()보다 효율적이며 고정 크기 힙을 사용할 때 더 적합 할 수 있습니다. 반환 된 값은 item보다 클 수 있습니다! 조건부 대체의 일부로 작성되지 않은 경우이 루틴의 합리적인 사용을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7a35ff20b244cefddc1604b170c46f6cbce2de97" translate="yes" xml:space="preserve">
          <source>Pop the smallest item off the heap, maintaining the heap invariant.</source>
          <target state="translated">힙을 변하지 않고 유지하면서 힙에서 가장 작은 항목을 팝하십시오.</target>
        </trans-unit>
        <trans-unit id="34e45af26b9cdfe158c5ff6d766e12ef85dbe2c8" translate="yes" xml:space="preserve">
          <source>Pops and returns the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement:</source>
          <target state="translated">현재 가장 작은 값을 팝하여 반환하고 새 항목을 추가합니다. 이것은 pop () 다음에 push ()가 오는 것보다 효율적이며 고정 크기 힙을 사용할 때 더 적합 할 수 있습니다. 반환 된 값은 항목보다 클 수 있습니다! 이는 조건부 대체의 일부로 작성되지 않는 한이 루틴의 합리적인 사용을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4cb79c259d58f1d3802c82933611bcfb17f33f4a" translate="yes" xml:space="preserve">
          <source>Pops and returns the smallest item from &lt;code&gt;heap&lt;/code&gt;, maintaining the heap invariant.</source>
          <target state="translated">팝 반환에서 가장 작은 항목 &lt;code&gt;heap&lt;/code&gt; 힙 불변을 유지.</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="62eb2d652c640374db70b913a59f5d9da34f44b1" translate="yes" xml:space="preserve">
          <source>Porting Nim to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and Nim generates C code, porting the code generator is not necessary.</source>
          <target state="translated">C가 가장 이식 가능한 프로그래밍 언어이고 (특정 한도 내에서) Nim이 C 코드를 생성하므로 코드 생성기를 이식 할 필요가 없으므로 Nim을 새로운 아키텍처로 이식하는 것은 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="442a29f3c82b03d1fb72c4411cbd3b9a535b5dbf" translate="yes" xml:space="preserve">
          <source>Porting to new platforms</source>
          <target state="translated">새로운 플랫폼으로 포팅</target>
        </trans-unit>
        <trans-unit id="96938ac778902dc9c8a77d5d10c75b74615cc812" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen</source>
          <target state="translated">탐색이 발생하는 상대 위치</target>
        </trans-unit>
        <trans-unit id="72250df1b33b90f691fb1b3acc0b0e2ea24463ab" translate="yes" xml:space="preserve">
          <source>Position relative to which seek should happen.</source>
          <target state="translated">탐색이 발생해야하는 상대 위치입니다.</target>
        </trans-unit>
        <trans-unit id="1c44413026c7a51d5c1001acf9afe19a2fa6a8a3" translate="yes" xml:space="preserve">
          <source>Possible modes of &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 의 가능한 모드 .</target>
        </trans-unit>
        <trans-unit id="e892ba2967a8f941ba09b419a3743f5e7d66af16" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;i386&quot;&lt;/code&gt;, &lt;code&gt;&quot;alpha&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64&quot;&lt;/code&gt;, &lt;code&gt;&quot;powerpc64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;sparc&quot;&lt;/code&gt;, &lt;code&gt;&quot;amd64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips&quot;&lt;/code&gt;, &lt;code&gt;&quot;mipsel&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm&quot;&lt;/code&gt;, &lt;code&gt;&quot;arm64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64&quot;&lt;/code&gt;, &lt;code&gt;&quot;mips64el&quot;&lt;/code&gt;, &lt;code&gt;&quot;riscv64&quot;&lt;/code&gt;.</source>
          <target state="translated">가능한 값 : &lt;code&gt;&quot;i386&quot;&lt;/code&gt; , &lt;code&gt;&quot;alpha&quot;&lt;/code&gt; , &lt;code&gt;&quot;powerpc&quot;&lt;/code&gt; , &lt;code&gt;&quot;powerpc64&quot;&lt;/code&gt; , &lt;code&gt;&quot;powerpc64el&quot;&lt;/code&gt; , &lt;code&gt;&quot;sparc&quot;&lt;/code&gt; , &lt;code&gt;&quot;amd64&quot;&lt;/code&gt; , &lt;code&gt;&quot;mips&quot;&lt;/code&gt; , &lt;code&gt;&quot;mipsel&quot;&lt;/code&gt; , &lt;code&gt;&quot;arm&quot;&lt;/code&gt; , &lt;code&gt;&quot;arm64&quot;&lt;/code&gt; , &lt;code&gt;&quot;mips64&quot;&lt;/code&gt; , &lt;code&gt;&quot;mips64el&quot;&lt;/code&gt; , &lt;code&gt;&quot;riscv64&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caa912531ccb34c0bee4edeab46a67bbbcf925be" translate="yes" xml:space="preserve">
          <source>Possible values: &lt;code&gt;&quot;windows&quot;&lt;/code&gt;, &lt;code&gt;&quot;macosx&quot;&lt;/code&gt;, &lt;code&gt;&quot;linux&quot;&lt;/code&gt;, &lt;code&gt;&quot;netbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;freebsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;openbsd&quot;&lt;/code&gt;, &lt;code&gt;&quot;solaris&quot;&lt;/code&gt;, &lt;code&gt;&quot;aix&quot;&lt;/code&gt;, &lt;code&gt;&quot;haiku&quot;&lt;/code&gt;, &lt;code&gt;&quot;standalone&quot;&lt;/code&gt;.</source>
          <target state="translated">가능한 값 : &lt;code&gt;&quot;windows&quot;&lt;/code&gt; , &lt;code&gt;&quot;macosx&quot;&lt;/code&gt; , &lt;code&gt;&quot;linux&quot;&lt;/code&gt; , &lt;code&gt;&quot;netbsd&quot;&lt;/code&gt; , &lt;code&gt;&quot;freebsd&quot;&lt;/code&gt; , &lt;code&gt;&quot;openbsd&quot;&lt;/code&gt; , &lt;code&gt;&quot;solaris&quot;&lt;/code&gt; , &lt;code&gt;&quot;aix&quot;&lt;/code&gt; , &lt;code&gt;&quot;haiku&quot;&lt;/code&gt; , &lt;code&gt;&quot;standalone&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f507f61c5144c40eeb0019cc1f801d64ef47b9b" translate="yes" xml:space="preserve">
          <source>Possibly volatile-qualified integer type of an object that can be accessed as an atomic entity, even in the presence of asynchronous interrupts.</source>
          <target state="translated">비동기 인터럽트가있는 경우에도 원자 엔티티로 액세스 할 수있는 객체의 휘발성으로 한정된 정수 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7350d4c47ea4aa0bc5e9515e97fb1d18e41403e7" translate="yes" xml:space="preserve">
          <source>Postfix operator call</source>
          <target state="translated">접미사 운영자 호출</target>
        </trans-unit>
        <trans-unit id="4f334f0326bbdb4bbc89a575b872446c3dde5a89" translate="yes" xml:space="preserve">
          <source>Powerful Metaprogramming</source>
          <target state="translated">강력한 메타 프로그래밍</target>
        </trans-unit>
        <trans-unit id="d857c4a3cba6bb11f909b140e46311890f7f21c4" translate="yes" xml:space="preserve">
          <source>Pragmas</source>
          <target state="translated">Pragmas</target>
        </trans-unit>
        <trans-unit id="5d8e7de7f25aa645cd3d52db842b4045251d9dd7" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information / commands without introducing a massive number of new keywords. Pragmas are processed on the fly during semantic checking. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly brackets. Pragmas are also often used as a first implementation to play with a language feature before a nicer syntax to access the feature becomes available.</source>
          <target state="translated">Pragmas는 많은 새로운 키워드를 도입하지 않고 컴파일러에게 추가 정보 / 명령을 제공하는 Nim의 방법입니다. 시맨틱 검사 중에 프라그 마가 즉시 처리됩니다. 프라그 마는 특수 &lt;code&gt;{.&lt;/code&gt; 및 &lt;code&gt;.}&lt;/code&gt; 중괄호. Pragma는 종종 기능에 액세스하기위한 더 좋은 구문을 사용할 수있게되기 전에 언어 기능을 가지고 노는 첫 번째 구현으로도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe9ce5f74d6f359dacb6b5ff6609ec745d285ed1" translate="yes" xml:space="preserve">
          <source>Pragmas are Nim's method to give the compiler additional information/ commands without introducing a massive number of new keywords. Pragmas are enclosed in the special &lt;code&gt;{.&lt;/code&gt; and &lt;code&gt;.}&lt;/code&gt; curly dot brackets. This tutorial does not cover pragmas. See the &lt;a href=&quot;manual#pragmas&quot;&gt;manual&lt;/a&gt; or &lt;a href=&quot;nimc#additional-features&quot;&gt;user guide&lt;/a&gt; for a description of the available pragmas.</source>
          <target state="translated">Pragmas는 많은 새로운 키워드를 도입하지 않고도 컴파일러에게 추가 정보 / 명령을 제공하는 Nim의 방법입니다. 프라그 마는 특수 &lt;code&gt;{.&lt;/code&gt; 및 &lt;code&gt;.}&lt;/code&gt; 중괄호. 이 튜토리얼에서는 pragma를 다루지 않습니다. &lt;a href=&quot;manual#pragmas&quot;&gt;사용&lt;/a&gt; 가능한 pragma에 대한 설명은 설명서 또는 &lt;a href=&quot;nimc#additional-features&quot;&gt;사용 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98fd755e5931021a9b89b9579124e072dc87d99f" translate="yes" xml:space="preserve">
          <source>Pre-defined floating point types</source>
          <target state="translated">사전 정의 된 부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="fb09faa048a039f6976971e21ef11f9d51c37b06" translate="yes" xml:space="preserve">
          <source>Pre-defined floating-point types</source>
          <target state="translated">미리 정의 된 부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="ddce2e3fda9f6f78c28f745b41b5c1d94ce0affb" translate="yes" xml:space="preserve">
          <source>Pre-defined integer types</source>
          <target state="translated">미리 정의 된 정수 유형</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="e11b40e5dc046d6eacf2b9c0341a3b59b3ba5410" translate="yes" xml:space="preserve">
          <source>Precedence level</source>
          <target state="translated">우선 순위 수준</target>
        </trans-unit>
        <trans-unit id="39a03e2279ceac8cb327814928332264628e7b59" translate="yes" xml:space="preserve">
          <source>Predecessor of the value</source>
          <target state="translated">가치의 전신</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="a0632aa9c12bfe3dcd3037995eb766aec389aa10" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks. The &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="translated">이름을 키워드와 공유하는 술어는 백틱으로 이스케이프해야합니다. &lt;code&gt;alias&lt;/code&gt; 과 &lt;code&gt;noalias&lt;/code&gt; 조건뿐만 아니라 일치하는 AST에,뿐만 아니라 다른 모든 바인딩 된 매개 변수를 참조; 구문 상 일반 AST 술어 다음에 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="b360b99e5530a900c44998c81311dbde2b2172fa" translate="yes" xml:space="preserve">
          <source>Predicates that share their name with a keyword have to be escaped with backticks: `` &lt;em&gt;const&lt;/em&gt;&lt;code&gt;. The ``alias&lt;/code&gt; and &lt;code&gt;noalias&lt;/code&gt; predicates refer not only to the matching AST, but also to every other bound parameter; syntactically they need to occur after the ordinary AST predicates:</source>
          <target state="translated">키워드와 이름을 공유하는 술어는 역 따옴표로 이스케이프해야합니다 :`` &lt;em&gt;const &lt;/em&gt; &lt;code&gt;. The ``alias&lt;/code&gt; 및 &lt;code&gt;noalias&lt;/code&gt; 술어는 일치하는 AST뿐만 아니라 다른 모든 바인딩 된 매개 변수를 나타냅니다. 문법적으로 이들은 일반적인 AST 술어 다음에 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b151af2a194f19ff375b24827bd3223300579c0" translate="yes" xml:space="preserve">
          <source>Prefix operator call</source>
          <target state="translated">접두사 운영자 호출</target>
        </trans-unit>
        <trans-unit id="fbd2682b135bba426260d1de577b0322c630062a" translate="yes" xml:space="preserve">
          <source>PrefixMatch:</source>
          <target state="translated">PrefixMatch:</target>
        </trans-unit>
        <trans-unit id="66495d0734591a26213f3a366af624feb0c83b41" translate="yes" xml:space="preserve">
          <source>Prepares a string for insertion into a XML document by escaping the XML special characters.</source>
          <target state="translated">XML 특수 문자를 이스케이프 처리하여 XML 문서에 삽입 할 문자열을 준비합니다.</target>
        </trans-unit>
        <trans-unit id="a3014e7add76fcb315acde9f61b5b3077efef0f3" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="translated">노드 &lt;code&gt;n&lt;/code&gt; 을 &lt;code&gt;L&lt;/code&gt; 앞에 추가 (시작 부분에 추가)합니다 . 효율성 : O (1).</target>
        </trans-unit>
        <trans-unit id="3ad5802802da4c948ba8d3d94e9f72f06ed26198" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a node to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 에 노드를 추가 (시작에 추가)합니다 . 효율성 : O (1).</target>
        </trans-unit>
        <trans-unit id="aa6a5d3dfd1ec66e32e8f9e711f12608b4c8e461" translate="yes" xml:space="preserve">
          <source>Prepends (adds to the beginning) a value to &lt;code&gt;L&lt;/code&gt;. Efficiency: O(1).</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 에 값을 추가 (시작 부분에 추가)합니다 . 효율성 : O (1).</target>
        </trans-unit>
        <trans-unit id="a9650901619effd3019d005a7f0cabcb33160dd0" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence.</source>
          <target state="translated">시퀀스의 시작 부분에 요소 x를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="db44386f03d5b854ad6dafaca1b1eeb202b32004" translate="yes" xml:space="preserve">
          <source>Prepends the element x to the beginning of the sequence. Requires copying of the sequence</source>
          <target state="translated">x를 시퀀스의 시작 부분에 추가합니다. 시퀀스 복사 필요</target>
        </trans-unit>
        <trans-unit id="e93c24da69c1700494f35fc0d6e60ad65139bd35" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;code&gt;a&lt;/code&gt; for &lt;code&gt;sub&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sub&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 대한 테이블 a 를 전처리합니다 .</target>
        </trans-unit>
        <trans-unit id="a5ecd31a75929e40768bb20c6e9a666bcfc1c0cf" translate="yes" xml:space="preserve">
          <source>Preprocess table &lt;em&gt;a&lt;/em&gt; for &lt;em&gt;sub&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;sub &lt;/em&gt;&lt;em&gt;에&lt;/em&gt; 대한 전처리 테이블 &lt;em&gt;a&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ebd928fc5c21d8b23de923afa72f9b439e03d18" translate="yes" xml:space="preserve">
          <source>Preprocessor support</source>
          <target state="translated">전 처리기 지원</target>
        </trans-unit>
        <trans-unit id="78f94e0402b0663fec796a2cb153834ccd0300a2" translate="yes" xml:space="preserve">
          <source>Presumably this snippet of code could be used in a commercial software, reading a configuration file to display information about the person who bought the software. This external file would be generated by an online web shopping cart to be included along the program containing the license information:</source>
          <target state="translated">이 코드 조각은 상용 소프트웨어에서 사용되어 소프트웨어를 구입 한 사람에 대한 정보를 표시하는 구성 파일을 읽을 수 있습니다. 이 외부 파일은 온라인 웹 쇼핑 카트에 의해 생성되어 라이센스 정보가 포함 된 프로그램과 함께 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbaacc193c8d2a284014a58127bf356addea8297" translate="yes" xml:space="preserve">
          <source>Print out the checkpoints encountered so far and quit if &lt;code&gt;abortOnError&lt;/code&gt; is true. Otherwise, erase the checkpoints and indicate the test has failed (change exit code and test status). This template is useful for debugging, but is otherwise mostly used internally. Example:</source>
          <target state="translated">지금까지 발생한 검사 점을 인쇄하고 &lt;code&gt;abortOnError&lt;/code&gt; 가 true이면 종료 합니다. 그렇지 않으면 검사 점을 지우고 테스트가 실패했음을 나타냅니다 (종료 코드 및 테스트 상태 변경). 이 템플릿은 디버깅에 유용하지만 대부분 내부적으로 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="f51d4e0dcedaa3fc409bdb1e06a21dc4a5fd577e" translate="yes" xml:space="preserve">
          <source>Proc</source>
          <target state="translated">Proc</target>
        </trans-unit>
        <trans-unit id="eb113d7d8beac65e410d096bf62f5df0c3b28a3c" translate="yes" xml:space="preserve">
          <source>Procedural type</source>
          <target state="translated">절차 유형</target>
        </trans-unit>
        <trans-unit id="9e7331be4f43593dd7df9b640d47a72f7445dbe7" translate="yes" xml:space="preserve">
          <source>Procedure calls of the form &lt;code&gt;p(X)&lt;/code&gt; are compile-time computable if &lt;code&gt;p&lt;/code&gt; is a proc without side-effects (see the &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;noSideEffect pragma&lt;/a&gt; for details) and if &lt;code&gt;X&lt;/code&gt; is a (possibly empty) list of compile-time computable arguments.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 부작용이없는 proc (자세한 내용은 &lt;a href=&quot;#pragmas-nosideeffect-pragma&quot;&gt;noSideEffect pragma&lt;/a&gt; 참조)이고 &lt;code&gt;X&lt;/code&gt; 가 컴파일 타임 계산 가능한 인수의 목록 인 경우 &lt;code&gt;p(X)&lt;/code&gt; 형식의 프로 시저 호출 은 컴파일 타임 계산 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="b8db867373f6b118d2afb0458feddadd86fe8e12" translate="yes" xml:space="preserve">
          <source>Procedure declaration</source>
          <target state="translated">절차 선언</target>
        </trans-unit>
        <trans-unit id="d682fc9dab69c1d2daf94fe72d9c9c2027249415" translate="yes" xml:space="preserve">
          <source>Procedures</source>
          <target state="translated">Procedures</target>
        </trans-unit>
        <trans-unit id="c7e7f6611bf2da78f49f8e451d842d8bd7ab42ec" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. For dynamic dispatch replace the &lt;code&gt;proc&lt;/code&gt; keyword by &lt;code&gt;method&lt;/code&gt;:</source>
          <target state="translated">프로시 저는 항상 정적 디스패치를 ​​사용합니다. 동적 디스패치의 경우 &lt;code&gt;proc&lt;/code&gt; 키워드를 &lt;code&gt;method&lt;/code&gt; 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="1f4c0de7b4c7726fec29f652686da73a3922e3fa" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type.</source>
          <target state="translated">프로시 저는 항상 정적 디스패치를 ​​사용합니다. 메서드는 동적 디스패치를 ​​사용합니다. 동적 디스패치가 개체에 대해 작동하려면 참조 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ad221890d30672f04664877c946ff70a32ff7b5" translate="yes" xml:space="preserve">
          <source>Procedures always use static dispatch. Multi-methods use dynamic dispatch. For dynamic dispatch to work on an object it should be a reference type as well.</source>
          <target state="translated">프로시 저는 항상 정적 디스패치를 ​​사용합니다. 다중 메서드는 동적 디스패치를 ​​사용합니다. 동적 디스패치가 객체에서 작동하려면 참조 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="06fbd2dad7effcb2234aac62fd8428a3ba476436" translate="yes" xml:space="preserve">
          <source>Procedures can appear at the top level in a module as well as inside other scopes, in which case they are called nested procs. A nested proc can access local variables from its enclosing scope and if it does so it becomes a closure. Any captured variables are stored in a hidden additional argument to the closure (its environment) and they are accessed by reference by both the closure and its enclosing scope (i.e. any modifications made to them are visible in both places). The closure environment may be allocated on the heap or on the stack if the compiler determines that this would be safe.</source>
          <target state="translated">프로시 저는 모듈의 최상위 레벨과 다른 범위 내에서 나타날 수 있으며이 경우 중첩 된 프로 시저라고합니다. 중첩 된 proc은 포함 범위에서 로컬 변수에 액세스 할 수 있으며, 그렇게하면 클로저가됩니다. 캡처 된 변수는 클로저 (환경)에 대한 숨겨진 추가 인수에 저장되며 클로저와 해당 범위에 의해 참조로 액세스됩니다 (즉, 수정 된 내용은 두 곳에서 모두 볼 수 있음). 컴파일러가 안전한 것으로 판단되면 클로저 환경은 힙이나 스택에 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7841a99f25705b147bd34c0a1f7bb11c058cf2b" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such a manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="translated">이러한 방식으로 유형 클래스를 사용하는 프로시 저는 &lt;span id=&quot;implicitly-generic_1&quot;&gt;암시 적으로 제네릭&lt;/span&gt; 으로 간주됩니다 . 프로그램 내에서 사용되는 각 매개 변수 유형의 고유 한 조합에 대해 한 번씩 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d366db67df6a0b1e1efe0e08594bca71f8eee2" translate="yes" xml:space="preserve">
          <source>Procedures utilizing type classes in such manner are considered to be &lt;span id=&quot;implicitly-generic_1&quot;&gt;implicitly generic&lt;/span&gt;. They will be instantiated once for each unique combination of param types used within the program.</source>
          <target state="translated">이러한 방식으로 형식 클래스를 사용하는 절차는 &lt;span id=&quot;implicitly-generic_1&quot;&gt;암시 적으로 일반적인&lt;/span&gt; 것으로 간주됩니다 . 프로그램 내에서 사용되는 각각의 고유 한 매개 변수 유형 조합에 대해 한 번 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="77d887d3c4269645cbb00a3f203259c5546c162d" translate="yes" xml:space="preserve">
          <source>Process the closure of all inner procs in one pass and accumulate the environments. This is however not always possible.</source>
          <target state="translated">모든 내부 proc의 폐쇄를 한 번에 처리하고 환경을 축적하십시오. 그러나 이것이 항상 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e63451d3cf90040c075dc1fe95aa1f7d7528c37f" translate="yes" xml:space="preserve">
          <source>Processing</source>
          <target state="translated">Processing</target>
        </trans-unit>
        <trans-unit id="9afbe384e2a83f2b02c509b5363d71ee79a38e3a" translate="yes" xml:space="preserve">
          <source>Procs</source>
          <target state="translated">Procs</target>
        </trans-unit>
        <trans-unit id="4311d5a41c23a4400f7edfce5e0b039536a0abc1" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top level executable code.</source>
          <target state="translated">식으로서의 proc는 중첩 된 proc 및 최상위 실행 코드 내부에 모두 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e4f503b0908900893c7de08f0c51457cc0dc892" translate="yes" xml:space="preserve">
          <source>Procs as expressions can appear both as nested procs and inside top-level executable code. The &lt;a href=&quot;sugar&quot;&gt;sugar&lt;/a&gt; module contains the &lt;code&gt;=&amp;gt;&lt;/code&gt; macro which enables a more succinct syntax for anonymous procedures resembling lambdas as they are in languages like JavaScript, C#, etc.</source>
          <target state="translated">Procs as expression은 중첩 된 procs와 최상위 실행 코드 내부에 모두 나타날 수 있습니다. &lt;a href=&quot;sugar&quot;&gt;설탕&lt;/a&gt; 모듈은 포함 &lt;code&gt;=&amp;gt;&lt;/code&gt; 가 등 자바 스크립트, C #을, 같은 언어에로 람다를 닮은 익명의 절차에 대한 더 간결한 구문을 할 수 매크로를</target>
        </trans-unit>
        <trans-unit id="3a1616e4bc1aa2bed912867d0902aca437b90990" translate="yes" xml:space="preserve">
          <source>Procs can also be treated as expressions, in which case it's allowed to omit the proc's name.</source>
          <target state="translated">Procs는 표현식으로 취급 될 수도 있는데,이 경우 proc의 이름을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57362afa37cf6acde07ad138b615e180f8f62a5b" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;type&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 매개 변수를 갖춘 프로세서 는 암시 적으로 일반적인 것으로 간주됩니다. 제공된 유형의 고유 한 조합과 proc 본문 내에서 인스턴스화되며 각 매개 변수의 이름은 바운드 콘크리트 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d11e4ea5c4fc8b9c8ae45fea3562c69c5ec08ed3" translate="yes" xml:space="preserve">
          <source>Procs featuring &lt;code&gt;typedesc&lt;/code&gt; params are considered implicitly generic. They will be instantiated for each unique combination of supplied types and within the body of the proc, the name of each param will refer to the bound concrete type:</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 매개 변수를 특징으로하는 Proc 는 암시 적으로 제네릭으로 간주됩니다. 제공된 유형의 각 고유 조합에 대해 인스턴스화되며 proc 본문 내에서 각 매개 변수의 이름은 바인딩 된 구체적인 유형을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6342d3bbf4c02568a11954f011158915db9e2356" translate="yes" xml:space="preserve">
          <source>Procs have been provided to calculate statistics on arrays and sequences.</source>
          <target state="translated">배열 및 시퀀스에 대한 통계를 계산하기위한 프로세스가 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="797173c091947a15389bb8674683086569e23428" translate="yes" xml:space="preserve">
          <source>Procs that take an &lt;code&gt;onProgressChanged&lt;/code&gt; callback will call this every &lt;code&gt;progressInterval&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;onProgressChanged&lt;/code&gt; 콜백 을받는 Proc 는이 모든 &lt;code&gt;progressInterval&lt;/code&gt; 밀리 초를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cdad80c260c1b79fcf7078364eee12ddb03d0dbf" translate="yes" xml:space="preserve">
          <source>Procs written with the implicitly generic style will often need to refer to the type parameters of the matched generic type. They can be easily accessed using the dot syntax:</source>
          <target state="translated">암시 적으로 제네릭 스타일로 작성된 프로세스는 종종 일치하는 제네릭 형식의 형식 매개 변수를 참조해야합니다. 도트 구문을 사용하여 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7ff859e3411fbc571ec4264667afa27e529104" translate="yes" xml:space="preserve">
          <source>Produce and emit the parser message &lt;code&gt;arg&lt;/code&gt; to output.</source>
          <target state="translated">출력 할 구문 분석기 메시지 &lt;code&gt;arg&lt;/code&gt; 를 생성 하고 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="417499a3e724b26a485073043202bc4249cbf19c" translate="yes" xml:space="preserve">
          <source>Produces a new boolean literal node.</source>
          <target state="translated">새로운 부울 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ff054aee7691236a9993dec46a2130a988a71073" translate="yes" xml:space="preserve">
          <source>Produces a new call node. &lt;code&gt;theProc&lt;/code&gt; is the proc that is called with the arguments &lt;code&gt;args[0..]&lt;/code&gt;.</source>
          <target state="translated">새 호출 노드를 생성합니다. &lt;code&gt;theProc&lt;/code&gt; 는 &lt;code&gt;args[0..]&lt;/code&gt; 인수로 호출되는 proc입니다 .</target>
        </trans-unit>
        <trans-unit id="622a3a47b2c474ef796d04d2baf1a3173889bd80" translate="yes" xml:space="preserve">
          <source>Produces a new character literal node.</source>
          <target state="translated">새 문자 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="27ae80c128f37c9e400ccceee66df439075090a4" translate="yes" xml:space="preserve">
          <source>Produces a new float literal node.</source>
          <target state="translated">새 부동 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ddd5e7e89e83e960e4a8323a02eadefcf15728a" translate="yes" xml:space="preserve">
          <source>Produces a new integer literal node.</source>
          <target state="translated">새로운 정수 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5a27d8b9701ccfc7b4ff722f94e7f83a25b94830" translate="yes" xml:space="preserve">
          <source>Produces a new node with children.</source>
          <target state="translated">자식이있는 새 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f8b793100dbd4a4b12a262055c30b601dac0bcd2" translate="yes" xml:space="preserve">
          <source>Produces a new string literal node.</source>
          <target state="translated">새 문자열 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="973901b80807f5ff207e2042993c04bbe7029db8" translate="yes" xml:space="preserve">
          <source>Produces a new unsigned integer literal node.</source>
          <target state="translated">새로운 부호없는 정수 리터럴 노드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9a5dd73eabe0ceec3510ddd56cff50a79d0fd6a6" translate="yes" xml:space="preserve">
          <source>Produces an XML tree for:</source>
          <target state="translated">다음을위한 XML 트리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2fac879cf602e3396c116983a52de85ad6e251ad" translate="yes" xml:space="preserve">
          <source>Produces roughly this C code:</source>
          <target state="translated">대략이 C 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2659970d3474662f3ed922e19e08a245aa2fdc58" translate="yes" xml:space="preserve">
          <source>Produces the Cartesian product of the array. Warning: complexity may explode.</source>
          <target state="translated">배열의 데카르트 곱을 생성합니다. 경고 : 복잡성이 폭발 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="960e8fddc698625d55770887235e931f448d8d54" translate="yes" xml:space="preserve">
          <source>Produces:</source>
          <target state="translated">Produces:</target>
        </trans-unit>
        <trans-unit id="2c32898c6bc516c95e3a09efcc75829d8ca400b4" translate="yes" xml:space="preserve">
          <source>ProfileData:</source>
          <target state="translated">ProfileData:</target>
        </trans-unit>
        <trans-unit id="f4cf552e1f1e8c0469d4436b64b404977bcf69c9" translate="yes" xml:space="preserve">
          <source>ProfileInfo:</source>
          <target state="translated">ProfileInfo:</target>
        </trans-unit>
        <trans-unit id="5869080be0ffd6203a367dfac147459656260124" translate="yes" xml:space="preserve">
          <source>Profiler:</source>
          <target state="translated">Profiler:</target>
        </trans-unit>
        <trans-unit id="a6d68bd4be10c0820c76fc8d06aecf226d4b6440" translate="yes" xml:space="preserve">
          <source>Program is executed.</source>
          <target state="translated">프로그램이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4f17a83cbcff788a0cad5a770a0848dad49ec175" translate="yes" xml:space="preserve">
          <source>Progress reporting</source>
          <target state="translated">진행보고</target>
        </trans-unit>
        <trans-unit id="1f2140e31dbd92836ebf9c2bfdffac3015b3027f" translate="yes" xml:space="preserve">
          <source>Project switch</source>
          <target state="translated">프로젝트 스위치</target>
        </trans-unit>
        <trans-unit id="760874ddf5afe0d82343947ffb16ccd1781c1d3b" translate="yes" xml:space="preserve">
          <source>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</source>
          <target state="translated">랩핑 할 프로 시저가 복잡한 표현에서 나올 수 있기 때문에 적절한 썽크 생성이 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="5e49b9bd99ab4bc355bcfd55bdeb30deaad41741" translate="yes" xml:space="preserve">
          <source>Protecting general locations</source>
          <target state="translated">일반 위치 보호</target>
        </trans-unit>
        <trans-unit id="d8eec506723634351a9cba0d6d82397b9f72baf0" translate="yes" xml:space="preserve">
          <source>Protecting global variables</source>
          <target state="translated">전역 변수 보호</target>
        </trans-unit>
        <trans-unit id="157122474fc28e9dcab665a3696cb13a6fe9933e" translate="yes" xml:space="preserve">
          <source>Protocol version specifies the protocol to use. SSLv2, SSLv3, TLSv1 are available with the addition of &lt;code&gt;protSSLv23&lt;/code&gt; which allows for compatibility with all of them.</source>
          <target state="translated">프로토콜 버전은 사용할 프로토콜을 지정합니다. SSLv2, SSLv3, TLSv1은 &lt;code&gt;protSSLv23&lt;/code&gt; 을 추가하여 사용할 수 있어 모든 제품과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="e38d7d5b91755bfbdf05c15f5eb398d4e6becf82" translate="yes" xml:space="preserve">
          <source>Provide a restrictive API that can load/save the compiletime state to a file.</source>
          <target state="translated">컴파일 타임 상태를 파일로로드 / 저장할 수있는 제한적인 API를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="7b940e771b06f772546586fc239edc7c0e4b029b" translate="yes" xml:space="preserve">
          <source>Provide spaces around binary operators if that enhances readability.</source>
          <target state="translated">가독성을 향상시키는 경우 이진 연산자 주위에 공백을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="021a736a22fb8ccb515c4ebdd3bd6f75f2aa9698" translate="yes" xml:space="preserve">
          <source>Provides access to the compiler's instantiation stack line information of a template.</source>
          <target state="translated">템플릿의 컴파일러 인스턴스화 스택 라인 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d41454706f7a445dc20f892c59f0f20e55e32de2" translate="yes" xml:space="preserve">
          <source>Provides system information in a &lt;code&gt;Uname&lt;/code&gt; struct with sysname, nodename, release, version and machine attributes.</source>
          <target state="translated">sysname, nodename, 릴리스, 버전 및 시스템 속성과 함께 &lt;code&gt;Uname&lt;/code&gt; 구조체의 시스템 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="8ec4b541fad1239b548ff32ef94487dec816b95b" translate="yes" xml:space="preserve">
          <source>Pseudo import/include paths</source>
          <target state="translated">의사 가져 오기 / 포함 경로</target>
        </trans-unit>
        <trans-unit id="e8905062c7f92650e2b49b14825d94b7e789608b" translate="yes" xml:space="preserve">
          <source>PtrLikeKinds:</source>
          <target state="translated">PtrLikeKinds:</target>
        </trans-unit>
        <trans-unit id="b3a030279e3be16bc447509ee9cb018fef87870e" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions</source>
          <target state="translated">접두사 / 접두사 식에서 식별자 가져 오기</target>
        </trans-unit>
        <trans-unit id="ff5298d9926e7f25a3c4cd2c8956e4fd8ad809b8" translate="yes" xml:space="preserve">
          <source>Pull an identifier from prefix/postfix expressions.</source>
          <target state="translated">접두사 / 접미사 식에서 식별자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7d5ec8ce5c1cd610e2351c5a15b6b9c81346e199" translate="yes" xml:space="preserve">
          <source>Pure libraries</source>
          <target state="translated">순수한 라이브러리</target>
        </trans-unit>
        <trans-unit id="c6a218c1fffd61e7a4c8cd984b85f49ea6bce0e1" translate="yes" xml:space="preserve">
          <source>Pure libraries do not depend on any external &lt;code&gt;*.dll&lt;/code&gt; or &lt;code&gt;lib*.so&lt;/code&gt; binary while impure libraries do. A wrapper is an impure library that is a very low-level interface to a C library.</source>
          <target state="translated">순수한 라이브러리는 외부 &lt;code&gt;*.dll&lt;/code&gt; 또는 &lt;code&gt;lib*.so&lt;/code&gt; 바이너리 에 의존하지 않지만 불순한 라이브러리는 의존하지 않습니다 . 랩퍼는 C 라이브러리에 대한 매우 낮은 수준의 인터페이스 인 불순한 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="ab194e6c51955e3ece7467854fe421e48b6e4cf4" translate="yes" xml:space="preserve">
          <source>Push item onto heap, maintaining the heap invariant.</source>
          <target state="translated">힙을 변하지 않고 유지하면서 항목을 힙으로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="de1a698df31e45a8f5f4c836ee77bd27a6716e91" translate="yes" xml:space="preserve">
          <source>Pushes &lt;code&gt;item&lt;/code&gt; onto heap, maintaining the heap invariant.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 을 힙에 푸시 하여 힙을 불변으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="03af26b6f966874b74a290186d326f05c96fece2" translate="yes" xml:space="preserve">
          <source>Put the SMTP connection in TLS (Transport Layer Security) mode. May fail with ReplyError</source>
          <target state="translated">SMTP 연결을 TLS (Transport Layer Security) 모드로 설정하십시오. ReplyError로 실패 할 수 있음</target>
        </trans-unit>
        <trans-unit id="e51a6bd4b9d6286ac6ae728ccaf7c792a9d75dc7" translate="yes" xml:space="preserve">
          <source>Puts a (key, value)-pair into &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">(키, 값) 쌍을 &lt;code&gt;t&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="dfadf925b0a8b79995ad4896979cb346499bb036" translate="yes" xml:space="preserve">
          <source>Puts a new &lt;code&gt;(key, value)&lt;/code&gt; pair into &lt;code&gt;t&lt;/code&gt; even if &lt;code&gt;t[key]&lt;/code&gt; already exists.</source>
          <target state="translated">&lt;code&gt;t[key]&lt;/code&gt; 이미 존재 하더라도 &lt;code&gt;t&lt;/code&gt; 에 새로운 &lt;code&gt;(key, value)&lt;/code&gt; 쌍을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="21951821226cf6b4fe9f15bee71bff72d85baae9" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression.</source>
          <target state="translated">유사 인용 연산자. 표현식 또는 블록을 승인하고이를 나타내는 AST를 리턴합니다. 인용 된 AST 내에서 주변 범위에서 NimNode 표현식을 보간 할 수 있습니다. 연산자가 제공되지 않으면 백틱을 사용하여 인용이 수행됩니다. 그렇지 않으면 주어진 연산자를 보간 된 표현식의 접두사 연산자로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a39c27c6f3bf8974c957653b58c3fa5dc8ccf58c" translate="yes" xml:space="preserve">
          <source>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself): e.g. &lt;em&gt;@&lt;/em&gt; is escaped as &lt;em&gt;@@&lt;/em&gt;, &lt;em&gt;@@&lt;/em&gt; is escaped as &lt;em&gt;@@@&lt;/em&gt; and so on.</source>
          <target state="translated">유사 인용 연산자. 표현식 또는 블록을 승인하고이를 나타내는 AST를 리턴합니다. 인용 된 AST 내에서 주변 범위에서 NimNode 표현식을 보간 할 수 있습니다. 운영자가 제공되지 않으면 인용 부호가 사용됩니다. 그렇지 않으면 주어진 연산자는 보간 된 표현식의 접두사 연산자로 사용해야합니다. 예 : 보간 오퍼레이터의 원래 의미는 (자체 붙임에 의한)을 탈출하여 얻을 수있다 &lt;em&gt;@하는 것은&lt;/em&gt; 같이 이스케이프 &lt;em&gt;@@&lt;/em&gt; , &lt;em&gt;@@&lt;/em&gt; 같이 이스케이프 &lt;em&gt;@@@&lt;/em&gt; 등등.</target>
        </trans-unit>
        <trans-unit id="a8d92791ed83ac521184aed4c28bfc51de528ba5" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;code&gt;x&lt;/code&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="translated">정수의 밑이 2 인 로그를 빠르게 찾습니다. 경우 &lt;code&gt;x&lt;/code&gt; 되면 제로 &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; 가 설정되고, 그 결과는 -1, 그렇지 않으면 결과는 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="84df47161db68162cf2c1cf2df6862e32ae9b781" translate="yes" xml:space="preserve">
          <source>Quickly find the log base 2 of an integer. If &lt;em&gt;x&lt;/em&gt; is zero, when &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; is set, result is -1, otherwise result is undefined.</source>
          <target state="translated">정수의 로그베이스 2를 빠르게 찾으십시오. 경우 &lt;em&gt;X가&lt;/em&gt; 되면 제로 &lt;code&gt;noUndefinedBitOpts&lt;/code&gt; 가 설정되고, 그 결과는 -1, 그렇지 않으면 결과는 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="e155eddd124128a190616e7a186ae4d25f6a6ebc" translate="yes" xml:space="preserve">
          <source>QuitCalled</source>
          <target state="translated">QuitCalled</target>
        </trans-unit>
        <trans-unit id="707d835cf000590a6cbcdd3de8f6c5db75a32002" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's &lt;code&gt;pipes.quote&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 인용 하면 POSIX 쉘로 안전하게 전달할 수 있습니다. Python의 &lt;code&gt;pipes.quote&lt;/code&gt; 를 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="d43a34ec7721112f13b97cfbb0d6e0a2ad3e3442" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to POSIX shell. Based on Python's pipes.quote</source>
          <target state="translated">견적 &lt;code&gt;s&lt;/code&gt; , 그래서 안전하게 POSIX 쉘에 전달 될 수 있습니다. 파이썬의 파이프를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="ef5384530fb53a4b50a924b05202ea7f5c268758" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to Windows API.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 를 인용 하면 Windows API로 안전하게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d08dfbd0710ec2fc6ea17808fda70dbf079d436" translate="yes" xml:space="preserve">
          <source>Quote &lt;code&gt;s&lt;/code&gt;, so it can be safely passed to shell.</source>
          <target state="translated">Quote &lt;code&gt;s&lt;/code&gt; 이므로 쉘에 안전하게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d45f4b8112546563b986e1d340a3de1ceef7ec" translate="yes" xml:space="preserve">
          <source>Quote s, so it can be safely passed to Windows API. Based on Python's subprocess.list2cmdline See &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt;</source>
          <target state="translated">Quote이므로 Windows API에 안전하게 전달할 수 있습니다. Python의 subprocess.list2cmdline 기반 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/17w5ykft.aspx&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="c3a56dd5f4e333e6e2e0eafd9130d0884fa87aa3" translate="yes" xml:space="preserve">
          <source>RST Quick Reference</source>
          <target state="translated">RST 빠른 참조</target>
        </trans-unit>
        <trans-unit id="bcb0bbc7586f8b1cf1562ef98d5628eb03fc6223" translate="yes" xml:space="preserve">
          <source>Raise statement</source>
          <target state="translated">성명서</target>
        </trans-unit>
        <trans-unit id="d96d8a1fbad05e28f48bbb7b60f4cc5f83489601" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;code&gt;excepts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;excepts&lt;/code&gt; 로 표시되는 지원되는 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="728c44d434025a939b40fb468f6b464eb21b6d42" translate="yes" xml:space="preserve">
          <source>Raise the supported exceptions represented by &lt;em&gt;excepts&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;excepts로&lt;/em&gt; 표시되는 지원되는 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="ec3240294db6590d6eb674eceefe2d3080c82d81" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;0.0/0.0&lt;/code&gt;, for example.</source>
          <target state="translated">예를 들어 &lt;code&gt;0.0/0.0&lt;/code&gt; 씩 올렸습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad44127cead1a93b77e67eaafbb798c1b8d6a72" translate="yes" xml:space="preserve">
          <source>Raised by division by zero.</source>
          <target state="translated">0으로 나누면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66d476b23e649e63bb348172beb74bbf37053e03" translate="yes" xml:space="preserve">
          <source>Raised by invalid operations according to IEEE.</source>
          <target state="translated">IEEE에 따른 잘못된 작업으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0626d08315c63b21ae589949312963836c529522" translate="yes" xml:space="preserve">
          <source>Raised for inexact results.</source>
          <target state="translated">부정확 한 결과가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="99e5be4241e93c72cfe80efe56d3696ed1d11b32" translate="yes" xml:space="preserve">
          <source>Raised for invalid memory access errors</source>
          <target state="translated">유효하지 않은 메모리 액세스 오류 발생</target>
        </trans-unit>
        <trans-unit id="38c30cf567b7b9ee1eddd8acb70da472c0ad9270" translate="yes" xml:space="preserve">
          <source>Raised for overflows.</source>
          <target state="translated">오버플로가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="dd2cdbc5b0a42dacf72096db49f963030ac2eaf1" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer divide-by-zero errors.</source>
          <target state="translated">런타임 정수 0으로 나누기 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2c9304ac03b02da4616572280aa9bb8ab12791a0" translate="yes" xml:space="preserve">
          <source>Raised for runtime integer overflows.</source>
          <target state="translated">런타임 정수 오버플로로 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="32c28ea5c78055e8ea68515c83c3ba22b6953b99" translate="yes" xml:space="preserve">
          <source>Raised for string and object conversion errors.</source>
          <target state="translated">문자열 및 객체 변환 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="08c46d3ef782190797d8a4bd64e301f0fa063ecc" translate="yes" xml:space="preserve">
          <source>Raised for underflows.</source>
          <target state="translated">언더 플로에 대해 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="be95aced11bd594c29b8a4cd5b58705ab2fd7a7d" translate="yes" xml:space="preserve">
          <source>Raised for unsuccessful attempts to allocate memory.</source>
          <target state="translated">메모리 할당 시도가 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="ec59fe758ecda80d7bef1c0104bc8498d5c4a618" translate="yes" xml:space="preserve">
          <source>Raised if a dynamic library could not be loaded.</source>
          <target state="translated">동적 라이브러리를로드 할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe56f3d52954d21251fffdab96d048a6101b0e04" translate="yes" xml:space="preserve">
          <source>Raised if a key cannot be found in a table.</source>
          <target state="translated">테이블에서 키를 찾을 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bbba70332d0c775286b48ce439b172d9ba242f8e" translate="yes" xml:space="preserve">
          <source>Raised if a range check error occurred.</source>
          <target state="translated">범위 확인 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="650353b9e13b1678f3e0f946a77bce78b804cb35" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its dicriminant's value does not fit.</source>
          <target state="translated">구분자의 값이 맞지 않아 레코드 필드에 액세스 할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fffcd1cf8b129cd2ba5e5e1a92281ab5c51b0fc" translate="yes" xml:space="preserve">
          <source>Raised if a record field is not accessible because its discriminant's value does not fit.</source>
          <target state="translated">판별 자의 값이 맞지 않아 레코드 필드에 액세스 할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ad88cbc3b7ff45823f8340b1fcd5be1d429c6ad" translate="yes" xml:space="preserve">
          <source>Raised if a resource request could not be fulfilled.</source>
          <target state="translated">자원 요청을 이행 할 수없는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cd11d72b167232b61b07884734877076a77cdc66" translate="yes" xml:space="preserve">
          <source>Raised if an IO &quot;end of file&quot; error occurred.</source>
          <target state="translated">IO &quot;파일 끝&quot;오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68c91c46567b49ce511b6a68e91cd37c644d9b1b" translate="yes" xml:space="preserve">
          <source>Raised if an IO error occurred.</source>
          <target state="translated">IO 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f68ad7db1fb95353786755c35e1d60aecfb00a29" translate="yes" xml:space="preserve">
          <source>Raised if an array index is out of bounds.</source>
          <target state="translated">배열 인덱스가 범위를 벗어나면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3ef858ef306b68c4f896a6d7c87ab203440961c" translate="yes" xml:space="preserve">
          <source>Raised if an object gets assigned to its parent's object.</source>
          <target state="translated">객체가 부모 객체에 할당되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdb573346d5de72dc1dc0894684d9b86b57d2d06" translate="yes" xml:space="preserve">
          <source>Raised if an object is converted to an incompatible object type. You can use &lt;code&gt;of&lt;/code&gt; operator to check if conversion will succeed.</source>
          <target state="translated">객체가 호환되지 않는 객체 유형으로 변환되면 발생합니다. 연산자를 사용 &lt;code&gt;of&lt;/code&gt; 변환이 성공하는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da2633c286ea06df76a0438d7891623c292b571a" translate="yes" xml:space="preserve">
          <source>Raised if an operating system service failed.</source>
          <target state="translated">운영 체제 서비스가 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="028c1298a842b618b5e92022ea3c9cb7f8150b55" translate="yes" xml:space="preserve">
          <source>Raised if any kind of arithmetic error occurred.</source>
          <target state="translated">모든 종류의 산술 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b57acbd1eafc73247bdc8b7db4a7e36731116243" translate="yes" xml:space="preserve">
          <source>Raised if it is attempted to send a message to a dead thread.</source>
          <target state="translated">사용 불능 스레드에 메시지를 보내려고하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="586536f2532bdba51684aaa2faaccf9a0ee3ad93" translate="yes" xml:space="preserve">
          <source>Raised if the hardware stack used for subroutine calls overflowed.</source>
          <target state="translated">서브 루틴 호출에 사용 된 하드웨어 스택이 오버플로 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="17261fb73363d2c277ed1529e2e101dd346435d0" translate="yes" xml:space="preserve">
          <source>Raised if there is no exception to reraise.</source>
          <target state="translated">후퇴 할 예외가 없으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="351c8bf075d81572768b1ca963b6bf3b6f76ed34" translate="yes" xml:space="preserve">
          <source>Raised on attempts to re-sink an already consumed &lt;code&gt;sink&lt;/code&gt; parameter.</source>
          <target state="translated">이미 소비 된 &lt;code&gt;sink&lt;/code&gt; 매개 변수 를 다시 싱크하려는 시도가 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="c3c39e104d96138eb3a3997e68ced83f3dee4e47" translate="yes" xml:space="preserve">
          <source>Raised on dereferences of &lt;code&gt;nil&lt;/code&gt; pointers.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 포인터의 역 참조에서 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="32a2e38706f27d38537d5bf0c1530200f9030954" translate="yes" xml:space="preserve">
          <source>Raised when a tag is not properly closed</source>
          <target state="translated">태그가 제대로 닫히지 않으면 발생</target>
        </trans-unit>
        <trans-unit id="42ca68196e5e694cdc0156d223a1ff6b17dcec98" translate="yes" xml:space="preserve">
          <source>Raised when an unexpected XML Parser event occurs</source>
          <target state="translated">예기치 않은 XML 파서 이벤트가 발생할 때 발생</target>
        </trans-unit>
        <trans-unit id="4d15913f72d2ca164e122d25060193477a26ffc0" translate="yes" xml:space="preserve">
          <source>Raised when assertion is proved wrong.</source>
          <target state="translated">어설 션이 잘못되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdbcd933410345697cf76acdf9926620d94d3b8e" translate="yes" xml:space="preserve">
          <source>Raised when parsing a &lt;code&gt;TimeFormat&lt;/code&gt; string fails.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 문자열 구문 분석이 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5f0c54a9ceebd56228f9e7a47a36cc438b296a4a" translate="yes" xml:space="preserve">
          <source>Raised when parsing input using a &lt;code&gt;TimeFormat&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;TimeFormat&lt;/code&gt; 을 사용한 입력 구문 분석 이 실패 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="94babf1279c76282aa7e3b74b85ba454ebe03766" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="translated">발생시킵니다 &lt;code&gt;AssertionDefect&lt;/code&gt; 를 지정하면 &lt;code&gt;code&lt;/code&gt; 지정된 예외를 발생시키지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="ccdd67ba0a2ee1b9a768b23962088796764a4478" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionDefect&lt;/code&gt; with &lt;code&gt;msg&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is false. Note that &lt;code&gt;AssertionDefect&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionDefect].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;AssertionDefect&lt;/code&gt; 는 함께 &lt;code&gt;msg&lt;/code&gt; 경우 &lt;code&gt;cond&lt;/code&gt; false입니다. 참고 &lt;code&gt;AssertionDefect&lt;/code&gt; 가 이 발생하지 않도록, 효과 시스템에서 숨겨져 &lt;code&gt;{.raises: [AssertionDefect].}&lt;/code&gt; . 이 예외는 단위 테스트 프레임 워크에서만 포착되어야합니다.</target>
        </trans-unit>
        <trans-unit id="91029130d53f12dffcfc80d43ea48134c5d69fcf" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; if specified &lt;code&gt;code&lt;/code&gt; does not raise the specified exception. Example:</source>
          <target state="translated">발생시킵니다 &lt;code&gt;AssertionError&lt;/code&gt; 지정하면 &lt;code&gt;code&lt;/code&gt; 지정된 예외를 발생시키지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="567f8f001d78a8e744cdf6369fc805b49aa2b893" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;AssertionError&lt;/code&gt; with &lt;em&gt;msg&lt;/em&gt; if &lt;em&gt;cond&lt;/em&gt; is false. Note that &lt;code&gt;AssertionError&lt;/code&gt; is hidden from the effect system, so it doesn't produce &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt;. This exception is only supposed to be caught by unit testing frameworks.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;AssertionError&lt;/code&gt; 를은 으로 &lt;em&gt;MSG&lt;/em&gt; 경우 &lt;em&gt;콘드은&lt;/em&gt; false입니다. 참고 &lt;code&gt;AssertionError&lt;/code&gt; 를가 가 발생하지 않도록, 효과 시스템에서 숨겨져 &lt;code&gt;{.raises: [AssertionError].}&lt;/code&gt; . 이 예외는 단위 테스팅 프레임 워크에서만 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83faa64f0dc51236f90a868139ec38fb95462791" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;EDb&lt;/code&gt; if the connection could not be established.</source>
          <target state="translated">연결을 설정할 수없는 경우 &lt;code&gt;EDb&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="d66f8302c80cace007ec26b7dd8b0079cd5a50b0" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred. Returns '\0' as an EOF marker.</source>
          <target state="translated">올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우. EOF 마커로 '\ 0'을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6894f48a57ffed3e94bbf7818467bd56356354ec" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; if any of the files does not exist or information about it can not be obtained.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;OSError&lt;/code&gt; 는 어떤 파일이 존재하지 않거나 대한 정보를 얻을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="1d275297cc16ea24212ee08bfe9169118ebac459" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OSError&lt;/code&gt; in case of an error. Follows symlinks.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;OSError&lt;/code&gt; 는 오류의 경우. 심볼릭 링크를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="40cc1c9996322f8cc38f559f2584b50f088e6996" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid hex values. The comparison is case-insensitive.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 잘못된 16 진수 값에 대한. 비교는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b3e8ef72efa78e2c5caac2a7c250a94e659a2c7" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;code&gt;s&lt;/code&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 에서 잘못된 값 &lt;code&gt;s&lt;/code&gt; . 비교는 스타일에 민감하지 않은 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c22f12804c795d88ca74f939ddf08aea8931971a" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;ValueError&lt;/code&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 에서 잘못된 값 &lt;em&gt;의&lt;/em&gt; . 비교는 스타일에 무관하게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d4578456b5ba2f01543ab1822189b16a39fba87" translate="yes" xml:space="preserve">
          <source>Raises &lt;em&gt;EDb&lt;/em&gt; if the connection could not be established.</source>
          <target state="translated">발생시킵니다 &lt;em&gt;EDB를&lt;/em&gt; 연결을 설정할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="09f056dbb100b1c839a4625115b8a60c96d1a0e6" translate="yes" xml:space="preserve">
          <source>Raises EInvalidValue in case of an error.</source>
          <target state="translated">오류가 발생하면 EInvalidValue를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e0bebaa2403bca683eb4d2b3f51753adb492d176" translate="yes" xml:space="preserve">
          <source>Raises EOS on error.</source>
          <target state="translated">오류 발생시 EOS를 높입니다.</target>
        </trans-unit>
        <trans-unit id="3094065727173e7ff0610b2ec2f7fa1c58ae43f7" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;code&gt;s&lt;/code&gt; is empty.</source>
          <target state="translated">설정하면 KeyError를가 발생시킵니다 &lt;code&gt;s&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e80f698527275363029eae2721df321a059387f0" translate="yes" xml:space="preserve">
          <source>Raises KeyError if the set &lt;em&gt;s&lt;/em&gt; is empty.</source>
          <target state="translated">설정된 &lt;em&gt;s&lt;/em&gt; 가 비어 있으면 KeyError를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="dc121ba0d8a6bbb1d7c05a5c564231baa3ad236b" translate="yes" xml:space="preserve">
          <source>Raises OSError on error.</source>
          <target state="translated">오류시 OSError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1994fdf951fcefef8875ee783032c923a838b8c1" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception when failed to insert row. For Postgre this adds &lt;code&gt;RETURNING id&lt;/code&gt; to the query, so it only works if your primary key is named &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">행 삽입에 실패 하면 &lt;code&gt;DbError&lt;/code&gt; 예외가 발생합니다. Postgre의 경우 &lt;code&gt;RETURNING id&lt;/code&gt; 를 쿼리에 추가 하므로 기본 키 이름이 &lt;code&gt;id&lt;/code&gt; 인 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="59a13ee0841c3615288bf2501646fe81c56c819e" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;DbError&lt;/code&gt; exception.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;DbError&lt;/code&gt; 의 예외.</target>
        </trans-unit>
        <trans-unit id="9bcb2956d86cad57b8ce1d8879b7ac38c45bebf8" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; exception if &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt; or &lt;code&gt;contentType&lt;/code&gt; contain newline characters.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 경우 예외 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; 또는 &lt;code&gt;contentType&lt;/code&gt; 이가 개행 문자를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9e8600b37550ccb497a4af5ce01a4410e73d0d2b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the parsing fails or the value is not a correctly formatted time.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 를을 구문 분석에 실패하거나 값이 올바른 형식의 시간이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="276b555f70ce184a6b1f8f69f1b6bd8354a1579b" translate="yes" xml:space="preserve">
          <source>Raises a &lt;code&gt;ValueError&lt;/code&gt; if the response's &lt;code&gt;status&lt;/code&gt; does not have a corresponding &lt;code&gt;HttpCode&lt;/code&gt;.</source>
          <target state="translated">발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 를하는 것은 응답의 경우 &lt;code&gt;status&lt;/code&gt; 해당하지 않습니다 &lt;code&gt;HttpCode&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="307a090405fae28bbe37ae495085d4fc3467fca3" translate="yes" xml:space="preserve">
          <source>Raises a new SSL error.</source>
          <target state="translated">새로운 SSL 에러를 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="4058e50bf03acedae079d451577c7b21d4279856" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;system#OSError&quot;&gt;OSError exception&lt;/a&gt;.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;system#OSError&quot;&gt;OSError 예외를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4be1df9024700353ee279a033c20b43e611103d1" translate="yes" xml:space="preserve">
          <source>Raises an &lt;code&gt;[DbError]&lt;/code&gt; exception with ODBC error information</source>
          <target state="translated">올린다 &lt;code&gt;[DbError]&lt;/code&gt; ODBC 오류 정보와 예외</target>
        </trans-unit>
        <trans-unit id="e4b8735df78acafac0305b07c45583c0f5e06188" translate="yes" xml:space="preserve">
          <source>Raises an &lt;em&gt;[DbError]&lt;/em&gt; exception with ODBC error information</source>
          <target state="translated">올린다 &lt;em&gt;[DbError]&lt;/em&gt; ODBC 오류 정보와 예외</target>
        </trans-unit>
        <trans-unit id="172a8dadd8dd7c12c87a018821e520f360bdd00c" translate="yes" xml:space="preserve">
          <source>Raises an EOS error upon failure.</source>
          <target state="translated">실패시 EOS 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="524595e54374e963ef480df057abcc139126f7c3" translate="yes" xml:space="preserve">
          <source>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</source>
          <target state="translated">오류가 발생하면 IO 예외가 발생합니다. 현재 파일 위치가 파일의 시작 부분에 있지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="6ab99fafbb1c01fadc221231a21a65c013cfa660" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSLGetError&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SSLGetError&lt;/code&gt; (SSL 소켓의 경우)에서 반환 한 오류 코드 와 그렇지 않으면 osLastError 에 따라 OSError를 발생 &lt;code&gt;osLastError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bc197d01299cedae87da2f96f00c76ba39cb84" translate="yes" xml:space="preserve">
          <source>Raises an OSError based on the error code returned by &lt;code&gt;SSL_get_error&lt;/code&gt; (for SSL sockets) and &lt;code&gt;osLastError&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;SSL_get_error&lt;/code&gt; (SSL 소켓 용)에 의해 반환 된 오류 코드를 기반으로 OSError를 발생 &lt;code&gt;osLastError&lt;/code&gt; 그렇지 않으면 osLastError를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="981040978083ddb6aedc722b391b33e2f5b4fa72" translate="yes" xml:space="preserve">
          <source>Raises an OSError error upon failure.</source>
          <target state="translated">실패시 OSError 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="90ebae0e4f71b7a4be2a66964668697eb30ea1dc" translate="yes" xml:space="preserve">
          <source>Raises exceptions for the status codes &lt;code&gt;4xx&lt;/code&gt; and &lt;code&gt;5xx&lt;/code&gt;</source>
          <target state="translated">상태 코드 &lt;code&gt;4xx&lt;/code&gt; 및 &lt;code&gt;5xx&lt;/code&gt; 에 대한 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bbcfba3180974b175ec29f25aedc4af60fbde06f" translate="yes" xml:space="preserve">
          <source>Raises proper errors based on return values of &lt;code&gt;recv&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; 함수의 반환 값을 기반으로 적절한 오류를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2208414278b65730f3d9e753c0bd6120a6090206" translate="yes" xml:space="preserve">
          <source>Raising an exception is done with the &lt;code&gt;raise&lt;/code&gt; statement:</source>
          <target state="translated">&lt;code&gt;raise&lt;/code&gt; 문을 사용하여 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="39db0baa12271196bc8f4503eccfe33d8bedd2cf" translate="yes" xml:space="preserve">
          <source>Ranges occur in set constructors, case statement branches, or array slices. Internally, the node kind &lt;code&gt;nnkRange&lt;/code&gt; is used, but when constructing the AST, construction with &lt;code&gt;..&lt;/code&gt; as an infix operator should be used instead.</source>
          <target state="translated">범위는 집합 생성자, case 문 분기 또는 배열 조각에서 발생합니다. 내부적으로 노드 종류 &lt;code&gt;nnkRange&lt;/code&gt; 가 사용되지만 AST를 구성 할 때는 대신 &lt;code&gt;..&lt;/code&gt; 를 포함 연산자로 사용하는 구성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6d74fbec021ac49e6d5b9824dc9112431d3fb1" translate="yes" xml:space="preserve">
          <source>Rationale: Consistency with overloaded assignment or assignment-like operations, &lt;code&gt;a = b&lt;/code&gt; can be read as &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt;.</source>
          <target state="translated">이론적 근거 : 할당 또는 할당과 같은 오버로드 된 작업과 일관성이 &lt;code&gt;a = b&lt;/code&gt; 는 &lt;code&gt;performSomeCopy(a, b)&lt;/code&gt; 로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab08d8a4461364c6af80c6c7c98c0b2b7dab27a7" translate="yes" xml:space="preserve">
          <source>Rationale: This is far easier to implement than hypothetical alternatives.</source>
          <target state="translated">근거 : 이것은 가상의 대안보다 구현하기가 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ce9a4a772a88d49b6a63f78245488ac96b3f98ab" translate="yes" xml:space="preserve">
          <source>Raw string literals</source>
          <target state="translated">원시 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="386ba29889d0288988970831100059ae32e75da0" translate="yes" xml:space="preserve">
          <source>Read &lt;code&gt;size&lt;/code&gt; bytes from the specified file asynchronously starting at the current position of the file pointer.</source>
          <target state="translated">파일 포인터의 현재 위치에서 시작하여 지정된 파일에서 &lt;code&gt;size&lt;/code&gt; 바이트를 비동기 적으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7ae2849845c6540687653cb08ca1d61f314e6677" translate="yes" xml:space="preserve">
          <source>Read CGI data from a string.</source>
          <target state="translated">문자열에서 CGI 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1b9e33ecea7657999c83b3f119c92f8cdd6252a4" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="translated">CGI 데이터를 읽습니다. 클라이언트가 &lt;code&gt;allowedMethods&lt;/code&gt; 집합에 나열된 메서드를 사용하지 않으면 &lt;code&gt;ECgi&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6837b052d9e0068e0b32c146cb0a7341a45c3d40" translate="yes" xml:space="preserve">
          <source>Read CGI data. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">CGI 데이터를 읽습니다. 클라이언트가 &lt;em&gt;allowedMethods&lt;/em&gt; 세트에 나열된 메소드를 사용하지 않으면 &lt;em&gt;ECgi&lt;/em&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cec1fd33cb854b699cea99a9f755995756d5ee2f" translate="yes" xml:space="preserve">
          <source>Read a single character from the terminal, blocking until it is entered. The character is not printed to the terminal.</source>
          <target state="translated">터미널에서 단일 문자를 읽고 입력 할 때까지 차단하십시오. 문자가 터미널에 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58a1329fd636aaedc19278e8f118476d716ed20a" translate="yes" xml:space="preserve">
          <source>Read file stream example:</source>
          <target state="translated">읽기 파일 스트림 예 :</target>
        </trans-unit>
        <trans-unit id="94ae5075e8a76e1e3bf797c3ca0f0105038061c6" translate="yes" xml:space="preserve">
          <source>Read or write stream</source>
          <target state="translated">스트림 읽기 또는 쓰기</target>
        </trans-unit>
        <trans-unit id="c88bf8c215b46559275a409fea6da7ac855220c7" translate="yes" xml:space="preserve">
          <source>Read the description of the &lt;a href=&quot;#newOSError,OSErrorCode,string&quot;&gt;newOSError proc&lt;/a&gt; to learn how the exception object is created.</source>
          <target state="translated">예외 객체가 생성되는 방법을 알아 &lt;a href=&quot;#newOSError,OSErrorCode,string&quot;&gt;보려면 newOSError proc&lt;/a&gt; 에 대한 설명을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="fa1f949ee6094b79d43e6d504438e7f6f64c9ab8" translate="yes" xml:space="preserve">
          <source>Read this &lt;a href=&quot;apis&quot;&gt;document&lt;/a&gt; for a quick overview of the API design.</source>
          <target state="translated">API 디자인에 대한 간단한 개요를 보려면이 &lt;a href=&quot;apis&quot;&gt;문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e12115c2336394c1a363bbc5f4d2a10707e72fdd" translate="yes" xml:space="preserve">
          <source>Read/Write tracking</source>
          <target state="translated">읽기 / 쓰기 추적</target>
        </trans-unit>
        <trans-unit id="7bad437b94c79808d48551fc7876a886aeec220d" translate="yes" xml:space="preserve">
          <source>Reading a configuration file</source>
          <target state="translated">구성 파일 읽기</target>
        </trans-unit>
        <trans-unit id="24620e210d243aab2166090142b8a7d92b8f8897" translate="yes" xml:space="preserve">
          <source>Reading a configuration file.</source>
          <target state="translated">구성 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="7421207f915a61053be48ee1f81c1396400af83a" translate="yes" xml:space="preserve">
          <source>Reading values</source>
          <target state="translated">값 읽기</target>
        </trans-unit>
        <trans-unit id="ed5a5f0d0a31292a7e615d242d5373135350e488" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;code&gt;buf&lt;/code&gt; &lt;strong&gt;까지의 최대&lt;/strong&gt; 바이트 &lt;code&gt;size&lt;/code&gt; 읽 &lt;strong&gt;습니다.이 &lt;/strong&gt;크기 는 최소한 해당 크기 여야합니다. 반환 된 미래는 요청 된 모든 데이터를 읽거나, 데이터의 일부를 읽거나, 소켓이 연결 해제 된 경우 완료되며 미래는 &lt;code&gt;0&lt;/code&gt; 값으로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e7c0e94dad43b7d156eb9468f3ce53d820c8c1b" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;code&gt;buf&lt;/code&gt; 까지 바이트 &lt;code&gt;size&lt;/code&gt; 읽 &lt;strong&gt;습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="33491ee917470d5dff9cb97340d439812d5536b8" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;strong&gt;최대 &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; 바이트를 읽 &lt;strong&gt;습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="77c0df6a022c05feac3496fef62e568dec0833b2" translate="yes" xml:space="preserve">
          <source>Reads &lt;strong&gt;up to&lt;/strong&gt;&lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;strong&gt;최대 &lt;/strong&gt; &lt;code&gt;size&lt;/code&gt; 바이트를 읽 &lt;strong&gt;습니다&lt;/strong&gt; . 반환 된 미래는 요청 된 모든 데이터를 읽거나 데이터의 일부를 읽거나 소켓 연결이 끊어지면 미래가 완료되며,이 경우 미래는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 값으로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="978c556c2dd2a7521290801e2dc3c34fa4b57db4" translate="yes" xml:space="preserve">
          <source>Reads a &lt;em&gt;password&lt;/em&gt; from stdin without printing it. &lt;em&gt;password&lt;/em&gt; must not be &lt;code&gt;nil&lt;/code&gt;! Returns &lt;code&gt;false&lt;/code&gt; if the end of the file has been reached, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">stdin 에서 &lt;em&gt;비밀번호&lt;/em&gt; 를 인쇄하지 않고 읽 습니다. &lt;em&gt;비밀번호&lt;/em&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아니어야합니다 ! 반환 &lt;code&gt;false&lt;/code&gt; , 파일의 마지막에 이르렀을 경우 &lt;code&gt;true&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="ce48b1b4358052432406e956566fc0d7c5a91157" translate="yes" xml:space="preserve">
          <source>Reads a bool from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 부울을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="0db9e9c7c5aa541797e5f1778ae04def378cc0ce" translate="yes" xml:space="preserve">
          <source>Reads a char from the stream &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 문자를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="444646cd8abc01e30ae794dcda8cbbdb2222593d" translate="yes" xml:space="preserve">
          <source>Reads a float32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 float32를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="00d61cabb21cb1835fe80bb50992fd3d84a2ca59" translate="yes" xml:space="preserve">
          <source>Reads a float64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 float64를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="fa2d32cde52d11c29e47f77d0e5566b28e25896c" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 한 줄을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="f4c7c69f0a4086f87414fa84f0850e98e826f6a2" translate="yes" xml:space="preserve">
          <source>Reads a line from a stream &lt;em&gt;s&lt;/em&gt;. Note: This is not very efficient. Raises &lt;em&gt;EIO&lt;/em&gt; if an error occurred.</source>
          <target state="translated">스트림에서 선 읽어 &lt;em&gt;들&lt;/em&gt; . 참고 : 이것은 매우 효율적이지 않습니다. 레이즈 &lt;em&gt;EIO&lt;/em&gt; 에러가 발생하면.</target>
        </trans-unit>
        <trans-unit id="603f08eff7888543b9965532d75111a52efffb42" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;resString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;code&gt;resString&lt;/code&gt; 으로 데이터 라인을 읽 습니다 .</target>
        </trans-unit>
        <trans-unit id="7f939728ad91b0c6736db56d252e3d56ef5aac62" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 데이터 라인을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="b9683a6732a76c35b64fa9e3a0d7661b3a22d384" translate="yes" xml:space="preserve">
          <source>Reads a line of data from &lt;code&gt;socket&lt;/code&gt;. Returned future will complete once a full line is read or an error occurs.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 데이터 라인을 읽습니다 . 전체 라인을 읽거나 오류가 발생하면 반환 된 미래는 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="3847b584349df73d4d611006c26414caaf93bd15" translate="yes" xml:space="preserve">
          <source>Reads a line of data from stdin - blocks until n or EOF which happens when stdin is closed</source>
          <target state="translated">stdin에서 데이터 한 줄을 읽습니다.-stdin이 닫힐 때 발생하는 n 또는 EOF까지 블록합니다.</target>
        </trans-unit>
        <trans-unit id="1aecd3b8f1dea16d09efe88e1e8d84722091e2e7" translate="yes" xml:space="preserve">
          <source>Reads a line of text from the stream &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;line&lt;/code&gt; must not be &lt;code&gt;nil&lt;/code&gt;! May throw an IO exception.</source>
          <target state="translated">스트림에서 한 줄의 텍스트 읽어 &lt;code&gt;s&lt;/code&gt; 로 &lt;code&gt;line&lt;/code&gt; . &lt;code&gt;line&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아니어야합니다 ! IO 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512f7f707ed82b2a4fb989d157a70b5d69b30b07" translate="yes" xml:space="preserve">
          <source>Reads a password from stdin without printing it.</source>
          <target state="translated">stdin에서 비밀번호를 인쇄하지 않고 읽습니다.</target>
        </trans-unit>
        <trans-unit id="3a565e53f76c99ac01c6e7755400b49c72fd17b5" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;code&gt;f&lt;/code&gt;. Should not be used in performance sensitive code.</source>
          <target state="translated">스트림 &lt;code&gt;f&lt;/code&gt; 에서 단일 문자를 읽습니다 . 성능에 민감한 코드에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="38f82d6c2b3adf0dd37525a198d9bcda0bb8916c" translate="yes" xml:space="preserve">
          <source>Reads a single character from the stream &lt;em&gt;f&lt;/em&gt;. Should not be used in performance sensitive code.</source>
          <target state="translated">스트림 &lt;em&gt;f&lt;/em&gt; 에서 단일 문자를 읽습니다 . 성능에 민감한 코드에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4ad562c998d7d33d16f2d35016ec8f1190aaf424" translate="yes" xml:space="preserve">
          <source>Reads a single line from the specified file asynchronously.</source>
          <target state="translated">지정된 파일에서 한 줄을 비동기 적으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e6392a2ce7ba8c43bede495139762911cf43dab7" translate="yes" xml:space="preserve">
          <source>Reads a string of length &lt;code&gt;length&lt;/code&gt; from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 길이 &lt;code&gt;length&lt;/code&gt; 의 문자열을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="b45c699410e48af3598ad0ffd48f49477789d869" translate="yes" xml:space="preserve">
          <source>Reads all available data.</source>
          <target state="translated">사용 가능한 모든 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2fd12af609f6c0c44ecea736f73e6dced25a94f4" translate="yes" xml:space="preserve">
          <source>Reads all data from stdin - blocks until EOF which happens when stdin is closed</source>
          <target state="translated">stdin에서 모든 데이터 읽기-stdin이 닫힐 때 발생하는 EOF까지 블록</target>
        </trans-unit>
        <trans-unit id="2c8cdad2cd8286acdfd0d66e63f133bab5192a3c" translate="yes" xml:space="preserve">
          <source>Reads all data from the specified file.</source>
          <target state="translated">지정된 파일에서 모든 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="607456770984494827062ec12a94f5f8805c30aa" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">스트림 &lt;code&gt;file&lt;/code&gt; 에서 모든 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="50c0c9eac2fafeeecf77fef0fbd118a7d5fe097d" translate="yes" xml:space="preserve">
          <source>Reads all data from the stream &lt;em&gt;file&lt;/em&gt;.</source>
          <target state="translated">스트림 &lt;em&gt;파일&lt;/em&gt; 에서 모든 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="a7a03269d18b195e925ad9c77002d605c67ad1ac" translate="yes" xml:space="preserve">
          <source>Reads an int16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int16을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="5da7f67b91586db02c5b853ed490a5b2b0ce65ac" translate="yes" xml:space="preserve">
          <source>Reads an int32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int32를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="f6198aa8906f011e979ffbd40950dff7b0b296ef" translate="yes" xml:space="preserve">
          <source>Reads an int64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int64를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="71175b4a24a11e531a6e13b456559b45b07beffd" translate="yes" xml:space="preserve">
          <source>Reads an int8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 int8을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="4636e7a0ee095ed96e677e732b5563936ba23cd0" translate="yes" xml:space="preserve">
          <source>Reads an uint16 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint16을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="2ab8c1e7be4b6116cc56b4597be1df909a24bbb2" translate="yes" xml:space="preserve">
          <source>Reads an uint32 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint32를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="5d1ee6f7d57815e3a9aeeb3c2780f23d6024cab6" translate="yes" xml:space="preserve">
          <source>Reads an uint64 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint64를 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="d9b50c7fc4493290e27785f0bddc497b8082c478" translate="yes" xml:space="preserve">
          <source>Reads an uint8 from the stream &lt;code&gt;s&lt;/code&gt;. Raises &lt;code&gt;IOError&lt;/code&gt; if an error occurred.</source>
          <target state="translated">스트림 &lt;code&gt;s&lt;/code&gt; 에서 uint8을 읽습니다 . 올린다 &lt;code&gt;IOError&lt;/code&gt; 오류가 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="16aa2b06a9fd45fdc5177ba0791c46e2186fefff" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of.</source>
          <target state="translated">CGI 데이터를 읽고 디코딩하여 데이터로 구성된 (이름, 값) 쌍을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d02b91ef117c2e1852e6fa0ea5eaaaa055755450" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;code&gt;allowedMethods&lt;/code&gt; set, an &lt;code&gt;ECgi&lt;/code&gt; exception is raised.</source>
          <target state="translated">CGI 데이터를 읽고 디코딩하고 데이터가 구성된 (이름, 값) 쌍을 생성합니다. 클라이언트가 &lt;code&gt;allowedMethods&lt;/code&gt; 집합에 나열된 메서드를 사용하지 않으면 &lt;code&gt;ECgi&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f08e1736fd8ee6f6e4264f9ba880fc2692403ee" translate="yes" xml:space="preserve">
          <source>Reads and decodes CGI data and yields the (name, value) pairs the data consists of. If the client does not use a method listed in the &lt;em&gt;allowedMethods&lt;/em&gt; set, an &lt;em&gt;ECgi&lt;/em&gt; exception is raised.</source>
          <target state="translated">CGI 데이터를 읽고 디코딩하여 데이터로 구성된 (이름, 값) 쌍을 생성합니다. 클라이언트가 &lt;em&gt;allowedMethods&lt;/em&gt; 세트에 나열된 메소드를 사용하지 않으면 &lt;em&gt;ECgi&lt;/em&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b51006412d40deb76f46a9f4cf49b32d91c5577f" translate="yes" xml:space="preserve">
          <source>Reads data and transforms it to a type &lt;code&gt;T&lt;/code&gt; (deserialization, unmarshalling).</source>
          <target state="translated">데이터를 읽고 &lt;code&gt;T&lt;/code&gt; 형식으로 변환합니다 (역 직렬화, 비 ​​정렬 화).</target>
        </trans-unit>
        <trans-unit id="cd580d77db8229465ebeb4157251802035fe7ba1" translate="yes" xml:space="preserve">
          <source>Reads data from the specified future stream until it is completed. The data which is read is written to the file immediately and freed from memory.</source>
          <target state="translated">지정된 미래 스트림에서 완료 될 때까지 데이터를 읽습니다. 읽은 데이터는 파일에 즉시 기록되고 메모리에서 비워집니다.</target>
        </trans-unit>
        <trans-unit id="6453f710c400a1bd3088d85ace46f2b0c556b4f3" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a bool</source>
          <target state="translated">빌드 타임에서 읽기는 bool로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="595d56d3e18b21c18bca00840423ca2ea7fc2a5e" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as a string</source>
          <target state="translated">빌드 타임에서 문자열로 정의 읽기</target>
        </trans-unit>
        <trans-unit id="e8adc86af0b87b9e44aebe3a30de9bd18fc60874" translate="yes" xml:space="preserve">
          <source>Reads in a build-time define as an integer</source>
          <target state="translated">빌드 타임에서 읽기는 정수로 정의</target>
        </trans-unit>
        <trans-unit id="4598472634a594f3ffeff8206db9ccc9d9d0f85d" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt;.</source>
          <target state="translated">첫 번째 행을 읽고 열 번호에 대한 찾아보기 테이블을 작성합니다 . &lt;a href=&quot;#rowEntry.CsvParser.string&quot;&gt;rowEntry&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc93c75abc8e47d3649940dfe86c4205db62db9" translate="yes" xml:space="preserve">
          <source>Reads the first row and creates a look-up table for column numbers See also:</source>
          <target state="translated">첫 번째 행을 읽고 열 번호에 대한 조회 테이블을 만듭니다. 참고 항목 :</target>
        </trans-unit>
        <trans-unit id="5c75a689c79c66c1db3b8b33ba096a09aab5fb43" translate="yes" xml:space="preserve">
          <source>Reads the next row; if &lt;code&gt;columns&lt;/code&gt; &amp;gt; 0, it expects the row to have exactly this many columns. Returns false if the end of the file has been encountered else true.</source>
          <target state="translated">다음 행을 읽습니다. 경우 &lt;code&gt;columns&lt;/code&gt; &amp;gt; 0,은 행이 정확히이 많은 열을 가질 것으로 기대하고있다. 파일의 끝이 발견되면 false를 반환하고 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="494c153aaf278be23e83188e46e8ae53c00137ae" translate="yes" xml:space="preserve">
          <source>Reads the response's body and caches it. The read is performed only once.</source>
          <target state="translated">응답 본문을 읽고 캐시합니다. 읽기는 한 번만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c09ea5f583e17a92aa05d2a79d90d53798b88bd5" translate="yes" xml:space="preserve">
          <source>Realtime support</source>
          <target state="translated">실시간 지원</target>
        </trans-unit>
        <trans-unit id="0a4f8939ec5010f9c8a6d335f9942ba0998f0630" translate="yes" xml:space="preserve">
          <source>Reborrows</source>
          <target state="translated">Reborrows</target>
        </trans-unit>
        <trans-unit id="4818f606d1ff08f9655a082b5139170b1f1676b8" translate="yes" xml:space="preserve">
          <source>Rebuilding the compiler</source>
          <target state="translated">컴파일러 재 구축</target>
        </trans-unit>
        <trans-unit id="7a26b1287f5ff59f6b29334f315518ff72b9960f" translate="yes" xml:space="preserve">
          <source>Receive a line of data from &lt;code&gt;socket&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 으로부터 데이터 라인을받습니다 .</target>
        </trans-unit>
        <trans-unit id="45ba1787b19136d286049145b2a0b743a6c33a76" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;buf&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;, address of datagram's sender will be stored into &lt;code&gt;saddr&lt;/code&gt; and &lt;code&gt;saddrLen&lt;/code&gt;. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;code&gt;buf&lt;/code&gt; 로 데이터 그램 데이터를 수신 합니다. 최소한 size &lt;code&gt;size&lt;/code&gt; 여야합니다. 데이터 그램 발신자의 주소는 &lt;code&gt;saddr&lt;/code&gt; 및 &lt;code&gt;saddrLen&lt;/code&gt; 에 저장됩니다 . 반환 된 미래는 하나의 데이터 그램이 수신되면 완료되며 수신 된 패킷의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08a1c7a9c8b11f0330e062d3a219827691a2ced9" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt; into &lt;code&gt;data&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. The address and port of datagram's sender will be stored into &lt;code&gt;address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 에서 &lt;code&gt;data&lt;/code&gt; 로 데이터 그램 데이터를 수신합니다.이 데이터 는 최소한 크기 &lt;code&gt;size&lt;/code&gt; 여야합니다 . 데이터 그램 발신자의 &lt;code&gt;address&lt;/code&gt; 와 &lt;code&gt;port&lt;/code&gt; 는 각각 address 및 port에 저장됩니다 . 반환 된 미래는 하나의 데이터 그램이 수신되면 완료되고 수신 된 패킷의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="035642ed262c167867946bf47a15f8d3cd74423d" translate="yes" xml:space="preserve">
          <source>Receives a datagram data from &lt;code&gt;socket&lt;/code&gt;, which must be at least of size &lt;code&gt;size&lt;/code&gt;. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.</source>
          <target state="translated">최소한 크기 &lt;code&gt;size&lt;/code&gt; 여야하는 &lt;code&gt;socket&lt;/code&gt; 에서 데이터 그램 데이터를 수신합니다 . 반환 된 future는 하나의 데이터 그램이 수신되면 완료되고 다음과 함께 튜플을 반환합니다. data of packet received; 데이터 그램 발신자의 주소 및 포트.</target>
        </trans-unit>
        <trans-unit id="f5cd4737c50ee8048cd8ba70ef02d69e328a1eaf" translate="yes" xml:space="preserve">
          <source>Receives a line of data from the socket connected to the SMTP server.</source>
          <target state="translated">SMTP 서버에 연결된 소켓에서 데이터 라인을받습니다.</target>
        </trans-unit>
        <trans-unit id="c9e06d171d56b86b84dc6f8e208bc7ee0606c281" translate="yes" xml:space="preserve">
          <source>Receives a message from the channel &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">채널 &lt;code&gt;c&lt;/code&gt; 에서 메시지를받습니다 .</target>
        </trans-unit>
        <trans-unit id="cc62c15428d535855ae8065d053fb9f3dae416a2" translate="yes" xml:space="preserve">
          <source>Receives data from &lt;code&gt;socket&lt;/code&gt;. This function should normally be used with connection-less sockets (UDP sockets).</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; 으로부터 데이터를받습니다 . 이 기능은 일반적으로 비 연결 소켓 (UDP 소켓)과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fde44220b1eb77eb349f04d90b283dec9ec8fc18" translate="yes" xml:space="preserve">
          <source>Receives data from a socket.</source>
          <target state="translated">소켓에서 데이터를받습니다.</target>
        </trans-unit>
        <trans-unit id="38611008bdc8b293ba57958ff7e53cb4f0c593ef" translate="yes" xml:space="preserve">
          <source>Recursively clears all children of an XmlNode.</source>
          <target state="translated">XmlNode의 모든 자식을 재귀 적으로 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="f1cfde3be5404be7accf4a0a658b02ee7896180d" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;code&gt;dir&lt;/code&gt; and yields for each file or directory in &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="translated">재귀는 디렉토리를 통해 산책 &lt;code&gt;dir&lt;/code&gt; 에있는 각 파일이나 디렉토리 및 수율 &lt;code&gt;dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a29f5764a54e8058c540d4730c0a945d240f1f8" translate="yes" xml:space="preserve">
          <source>Recursively walks over the directory &lt;em&gt;dir&lt;/em&gt; and yields for each file or directory in &lt;em&gt;dir&lt;/em&gt;. The full path for each file or directory is returned. &lt;strong&gt;Warning&lt;/strong&gt;: Modifying the directory structure while the iterator is traversing may result in undefined behavior!</source>
          <target state="translated">재귀는 디렉토리를 통해 산책 &lt;em&gt;디렉토리&lt;/em&gt; 에있는 각 파일이나 디렉토리 및 수율 &lt;em&gt;디렉토리&lt;/em&gt; . 각 파일 또는 디렉토리의 전체 경로가 리턴됩니다. &lt;strong&gt;경고&lt;/strong&gt; : 반복자가 이동하는 동안 디렉토리 구조를 수정하면 정의되지 않은 동작이 발생할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="c20bb0f7c4d78b01fa838319a2981e9b417f1f05" translate="yes" xml:space="preserve">
          <source>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되는 경우 수정하거나 수정하지 않고 소스 및 이진 형식으로 재배포 및 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57ec4bae787e02e75ae9439f5fbfc851c887f70f" translate="yes" xml:space="preserve">
          <source>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</source>
          <target state="translated">이진 형식으로 재배포 할 경우 위의 저작권 표시,이 조건 목록 및 배포와 함께 제공된 설명서 및 / 또는 기타 자료의 다음 면책 사항을 재현해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7338b5245c44e48d0d288fd4ec6f22445873f8e" translate="yes" xml:space="preserve">
          <source>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</source>
          <target state="translated">소스 코드의 재배포에는 위의 저작권 표시,이 조건 목록 및 다음 면책 사항이 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ded5e6e7aa2ed376f64f1a24730ee173d5155d3a" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">유리한 &lt;code&gt;x&lt;/code&gt; 를 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="7a93873a7ac8bb5a91e249745de2599e8d65fd26" translate="yes" xml:space="preserve">
          <source>Reduce rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">유리수 &lt;em&gt;x를&lt;/em&gt; 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="7693e4045bbbda8ba2d5c3ae273859b958bb1b40" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;a&lt;/code&gt; by &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 &lt;code&gt;b&lt;/code&gt; 로 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="259516f23573e881a917050af2115d65af6da166" translate="yes" xml:space="preserve">
          <source>Ref objects should be used whenever inheritance is used. It isn't strictly necessary, but with non-ref objects assignments such as &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; will truncate subclass fields.</source>
          <target state="translated">상속이 사용될 때마다 Ref 객체가 사용되어야합니다. 꼭 필요한 것은 아니지만 &lt;code&gt;let person: Person = Student(id: 123)&lt;/code&gt; 과 같이 참조가 아닌 객체를 할당 하면 하위 클래스 필드가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6e957d91a2e6412d9c92ab3070be12e1aa4ce4ab" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#CountTable&quot;&gt;CountTable&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CountTable&quot;&gt;CountTable의&lt;/a&gt; Ref 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="ab1e817109e090abbcfa757ded0f90d1a5753425" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#OrderedTable&quot;&gt;OrderedTable&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#OrderedTable&quot;&gt;OrderedTable의&lt;/a&gt; 참조 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="9d4ec7a15678a29e4afdf3478e19f787f13e2172" translate="yes" xml:space="preserve">
          <source>Ref version of &lt;a href=&quot;#Table&quot;&gt;Table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Table&quot;&gt;Table의&lt;/a&gt; Ref 버전 .</target>
        </trans-unit>
        <trans-unit id="87798bcee18d1436b909618b352c96cf831e7971" translate="yes" xml:space="preserve">
          <source>RefC</source>
          <target state="translated">RefC</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5af3748c63858d0b4874cf01bae4e3756fad9124" translate="yes" xml:space="preserve">
          <source>Reference Cycles</source>
          <target state="translated">참조 사이클</target>
        </trans-unit>
        <trans-unit id="960faca00a2ea60fd367da06c6a9cf388e7dc545" translate="yes" xml:space="preserve">
          <source>Reference and pointer types</source>
          <target state="translated">참조 및 포인터 유형</target>
        </trans-unit>
        <trans-unit id="5ac8f6bcbc2bb32b6f7eada152e718040b0ff894" translate="yes" xml:space="preserve">
          <source>Reference to &lt;code&gt;RootObj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RootObj&lt;/code&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="170afdf8e2efc163d33d771c752badc8b632f258" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory (also called &lt;span id=&quot;aliasing_1&quot;&gt;aliasing&lt;/span&gt;).</source>
          <target state="translated">참조 (다른 프로그래밍 언어의 포인터와 유사)는 다 대일 관계를 도입하는 방법입니다. 이는 서로 다른 참조가 메모리에서 동일한 위치 ( &lt;span id=&quot;aliasing_1&quot;&gt;앨리어싱&lt;/span&gt; 이라고도 함 )를 가리키고 수정할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="02069e24e1a9efdb72de58330148c041dfc9b7b2" translate="yes" xml:space="preserve">
          <source>References (similar to pointers in other programming languages) are a way to introduce many-to-one relationships. This means different references can point to and modify the same location in memory.</source>
          <target state="translated">참조 (다른 프로그래밍 언어의 포인터와 유사)는 다 대일 관계를 도입하는 방법입니다. 이는 서로 다른 참조가 메모리에서 동일한 위치를 가리키고 수정할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="21261db724edbd03f7602d59e2bb7a253492652e" translate="yes" xml:space="preserve">
          <source>Regarding binary comparison, this module only provides unequal operators. The equality operator &lt;code&gt;==&lt;/code&gt; is omitted, because depending on the use case either casting to float or rounding to int might be preferred, and users should make an explicit choice.</source>
          <target state="translated">이진 비교와 관련하여이 모듈은 같지 않은 연산자 만 제공합니다. 사용 사례에 따라 부동으로 캐스팅하거나 int로 반올림하는 것이 바람직 할 수 있으므로 사용자는 명시 적으로 선택해야하므로 항등 연산자 &lt;code&gt;==&lt;/code&gt; 는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="e68ebd1d4ba803b29c2b4073e01cb0c6ecc77d97" translate="yes" xml:space="preserve">
          <source>Registers 'foreignPackageName' to the internal list of foreign deps. It is your job to ensure the package name</source>
          <target state="translated">'foreignPackageName'을 외부 dep의 내부 목록에 등록합니다. 패키지 이름을 확인하는 것은 당신의 일입니다</target>
        </trans-unit>
        <trans-unit id="dba53deed8138d1e437d395564bccc72d2fe91e1" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;fd&lt;/code&gt; with the dispatcher.</source>
          <target state="translated">디스패처에 &lt;code&gt;fd&lt;/code&gt; 를 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="bb5bd595db3b7cfbb12cdce72914e82c34cdf5db" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;ftp&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">디스패처 &lt;code&gt;d&lt;/code&gt; 에 &lt;code&gt;ftp&lt;/code&gt; 를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="cbabe5b470b654e5897fc52c60eed8e57b18f5cc" translate="yes" xml:space="preserve">
          <source>Registers &lt;code&gt;s&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">디스패처 &lt;code&gt;d&lt;/code&gt; 에 &lt;code&gt;s&lt;/code&gt; 를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac05ff3f5dcfa293b9d59ad4d7bb0664b1aef3f" translate="yes" xml:space="preserve">
          <source>Registers Unix signal notification with &lt;code&gt;signal&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">레지스터와 유닉스 신호 통지 &lt;code&gt;signal&lt;/code&gt; 선택기 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="800f133d28b9b2c3e359d4dbbeb9ddbccf642485" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction.</source>
          <target state="translated">스레드가 소멸 될 때 호출 되는 &lt;em&gt;스레드 로컬&lt;/em&gt; 핸들러를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="ac28cb53181efd36c017064827507024c32b8745" translate="yes" xml:space="preserve">
          <source>Registers a &lt;em&gt;thread local&lt;/em&gt; handler that is called at the thread's destruction. A thread is destructed when the &lt;code&gt;.thread&lt;/code&gt; proc returns normally or when it raises an exception. Note that unhandled exceptions in a thread nevertheless cause the whole process to die.</source>
          <target state="translated">스레드 삭제시 호출 되는 &lt;em&gt;스레드 로컬&lt;/em&gt; 핸들러를 등록합니다 . 스레드는 &lt;code&gt;.thread&lt;/code&gt; 프로세스 가 정상적으로 리턴되거나 예외가 발생하면 소멸됩니다 . 그럼에도 불구하고 스레드에서 처리되지 않은 예외로 인해 전체 프로세스가 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3deac7496ef34d80158290e83f7f14ef92d45c58" translate="yes" xml:space="preserve">
          <source>Registers a foreign command to the intern list of commands that can be queried later.</source>
          <target state="translated">나중에 쿼리 할 수있는 외부 명령을 인턴 명령 목록에 등록합니다.</target>
        </trans-unit>
        <trans-unit id="f6b6982c4f6e50fc17a208315b2726e3bf92e0ac" translate="yes" xml:space="preserve">
          <source>Registers a process id (pid) notification (when process has exited) in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">선택기 &lt;code&gt;s&lt;/code&gt; 에 프로세스 ID (pid) 알림 (프로세스가 종료 된 경우)을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e6ab3c2650ac19e734751307d1c267db478032" translate="yes" xml:space="preserve">
          <source>Registers async socket &lt;code&gt;sock&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">디스패처 &lt;code&gt;d&lt;/code&gt; 에 비동기 소켓 &lt;code&gt;sock&lt;/code&gt; 을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5e51b21a074f3910595269ee7ab90c19c97cbb" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when &lt;code&gt;ev&lt;/code&gt; will be signaled</source>
          <target state="translated">&lt;code&gt;ev&lt;/code&gt; 신호를받을 때 호출 할 콜백 &lt;code&gt;cb&lt;/code&gt; 를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="31450955f986e0842dc1c13efe0a244827237e9d" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when process with process ID &lt;code&gt;pid&lt;/code&gt; exited.</source>
          <target state="translated">프로세스 ID가 &lt;code&gt;pid&lt;/code&gt; 인 프로세스 가 종료 될 때 호출 될 콜백 &lt;code&gt;cb&lt;/code&gt; 를 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="e6471db9bd2a705c0ad2173f10920c7b023bff08" translate="yes" xml:space="preserve">
          <source>Registers callback &lt;code&gt;cb&lt;/code&gt; to be called when timer expired.</source>
          <target state="translated">타이머 만료시 호출 할 콜백 &lt;code&gt;cb&lt;/code&gt; 를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="337e6b2b0028085b3fcc713332555d1608d2e3ce" translate="yes" xml:space="preserve">
          <source>Registers delegate &lt;code&gt;deleg&lt;/code&gt; with dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">레지스터 위임 &lt;code&gt;deleg&lt;/code&gt; 디스패처 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0836d5ff61abf1d138e16122f0ec0c79c61d80e8" translate="yes" xml:space="preserve">
          <source>Registers file/socket descriptor &lt;code&gt;fd&lt;/code&gt; to selector &lt;code&gt;s&lt;/code&gt; with events set in &lt;code&gt;events&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when an event is triggered.</source>
          <target state="translated">레지스터는 / 소켓 기술자 파일 &lt;code&gt;fd&lt;/code&gt; 에 대한 선택 &lt;code&gt;s&lt;/code&gt; 설정 이벤트와 &lt;code&gt;events&lt;/code&gt; . &lt;code&gt;data&lt;/code&gt; 이벤트가 트리거 될 때 전달되는 애플리케이션 정의 데이터이다.</target>
        </trans-unit>
        <trans-unit id="43e16ff873d5de584458f76ad72d9537d10683d7" translate="yes" xml:space="preserve">
          <source>Registers selector BSD/MacOSX specific vnode events for file descriptor &lt;code&gt;fd&lt;/code&gt; and events &lt;code&gt;events&lt;/code&gt;. &lt;code&gt;data&lt;/code&gt; application-defined data, which to be passed, when vnode event happens.</source>
          <target state="translated">파일 설명자 &lt;code&gt;fd&lt;/code&gt; 및 events &lt;code&gt;events&lt;/code&gt; 에 대한 선택기 BSD / MacOSX 특정 vnode 이벤트를 등록 합니다 . vnode 이벤트가 발생할 때 전달 될 &lt;code&gt;data&lt;/code&gt; 응용 프로그램 정의 데이터.</target>
        </trans-unit>
        <trans-unit id="2199311ef193878f7d6db4d7b746d800cbc0159f" translate="yes" xml:space="preserve">
          <source>Registers selector event &lt;code&gt;ev&lt;/code&gt; in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">선택기 이벤트 &lt;code&gt;ev&lt;/code&gt; 를 선택기 &lt;code&gt;s&lt;/code&gt; 에 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="b636a5c4fface43e127ecfee78ea1a0d490a11bb" translate="yes" xml:space="preserve">
          <source>Registers timer notification with &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) to selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">타이머 알림을 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)로 선택자 &lt;code&gt;s&lt;/code&gt; 에 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="136039c2b54f04914b3cfa5a13100aef989f0ca7" translate="yes" xml:space="preserve">
          <source>Regular expression support for Nim.</source>
          <target state="translated">Nim에 대한 정규식 지원.</target>
        </trans-unit>
        <trans-unit id="dc6d5a0c3dd27227e0ade1d680a1afafeb5cd176" translate="yes" xml:space="preserve">
          <source>Regular expression syntax and semantics</source>
          <target state="translated">정규식 구문 및 의미</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="632284d6d44cd285a0879407d2b79c59fd92e9cc" translate="yes" xml:space="preserve">
          <source>Regular file.</source>
          <target state="translated">일반 파일.</target>
        </trans-unit>
        <trans-unit id="c73e7346189862b7e0f60858180cc71c17d6472c" translate="yes" xml:space="preserve">
          <source>Related Options</source>
          <target state="translated">관련 옵션</target>
        </trans-unit>
        <trans-unit id="c87655c3652d2c8b712e2ae3b2ceb5122f8a4e27" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this iterator. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="translated">상대 경로는이 반복기에 의해 확장되지 않습니다. 대신 상대 경로에 나타나는 디렉토리 만 통과합니다.</target>
        </trans-unit>
        <trans-unit id="0eeef2cf95f50c40792682050928f40e5526ea33" translate="yes" xml:space="preserve">
          <source>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</source>
          <target state="translated">이 과정으로 상대 경로는 확장되지 않습니다. 대신 상대 경로에 나타나는 디렉토리 만 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="682eef8fa79929553cfba1c728611c096b679fb2" translate="yes" xml:space="preserve">
          <source>RelativeDir:</source>
          <target state="translated">RelativeDir:</target>
        </trans-unit>
        <trans-unit id="b960d2de95c213b0c091babc3388bfd26b6a65b1" translate="yes" xml:space="preserve">
          <source>RelativeFile:</source>
          <target state="translated">RelativeFile:</target>
        </trans-unit>
        <trans-unit id="7bbbb9e16a836cdff3a094ab77249ddd20e70760" translate="yes" xml:space="preserve">
          <source>Releases the given lock.</source>
          <target state="translated">주어진 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="154465987117610232e8996850d08335b4100707" translate="yes" xml:space="preserve">
          <source>Remove &lt;em&gt;fromFirst&lt;/em&gt; elements from the front of the deque and &lt;em&gt;fromLast&lt;/em&gt; elements from the back. If the supplied number of elements exceeds the total number of elements in the deque, the deque will remain empty.</source>
          <target state="translated">&lt;em&gt;데크&lt;/em&gt; 앞면에서 &lt;em&gt;첫 번째&lt;/em&gt; 요소 와 &lt;em&gt;뒷면&lt;/em&gt; 에서 &lt;em&gt;마지막&lt;/em&gt; 요소에서 제거하십시오 . 제공된 요소 수가 deque의 총 요소 수를 초과하면 deque는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c3917158d99d175858d7953e6b6e9cb15550589" translate="yes" xml:space="preserve">
          <source>Remove and return an arbitrary element from the set &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">제거하고 설정에서 임의의 요소를 반환 &lt;em&gt;들&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78c544f471ec5e066eef27a4a60e2a0a6a993737" translate="yes" xml:space="preserve">
          <source>Remove and return last item of a sequence</source>
          <target state="translated">시퀀스의 마지막 항목 제거 및 반환</target>
        </trans-unit>
        <trans-unit id="2c54936e344741227a270e4e931622db1988d283" translate="yes" xml:space="preserve">
          <source>Remove and returns the first element of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 첫 번째 요소를 제거하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0fbcf13973a390df5982811fd42fe25c950652d" translate="yes" xml:space="preserve">
          <source>Remove and returns the last element of the &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq&lt;/em&gt; 의 마지막 요소를 제거하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="18df4503a467be3ff14ca69ec9dcc32d63cee2c0" translate="yes" xml:space="preserve">
          <source>Remove one level of structure in a nested &lt;code&gt;Option&lt;/code&gt;.</source>
          <target state="translated">중첩 된 &lt;code&gt;Option&lt;/code&gt; 에서 한 수준의 구조를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="384fc682f39353a0f1c47ba8e506eebd6931689b" translate="yes" xml:space="preserve">
          <source>Remove one level of structure in a nested Option.</source>
          <target state="translated">중첩 된 옵션에서 한 레벨의 구조를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="03b764d0e66d4b3da726d47a7364c4864a30ba9c" translate="yes" xml:space="preserve">
          <source>Remove the first matching prefix (in-place) from a string.</source>
          <target state="translated">문자열에서 일치하는 첫 번째 접두사를 제자리에서 제거하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
