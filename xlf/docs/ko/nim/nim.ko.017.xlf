<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="f6aed8cf30d89d1b5f778819ebedc002452ab169" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPure</source>
          <target state="translated">TSpecialWord.wPure</target>
        </trans-unit>
        <trans-unit id="2a9b67e5059e4097ecf36898a14af806e627495c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPush</source>
          <target state="translated">TSpecialWord.wPush</target>
        </trans-unit>
        <trans-unit id="165c068e1820e1d75b4534ad6c24dc64d16d0a36" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaise</source>
          <target state="translated">TSpecialWord.wRaise</target>
        </trans-unit>
        <trans-unit id="5e3d248206d073353634b05ebfd99c3b0babf77c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaises</source>
          <target state="translated">TSpecialWord.wRaises</target>
        </trans-unit>
        <trans-unit id="5a2b8c36797bc435a75f44083c6407c87375542c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRangeChecks</source>
          <target state="translated">TSpecialWord.wRangeChecks</target>
        </trans-unit>
        <trans-unit id="df27e08ee3fc7139bf78856f843294d62733b61a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReads</source>
          <target state="translated">TSpecialWord.wReads</target>
        </trans-unit>
        <trans-unit id="b5ce7ca8962a8b2d8ed038b3f6595e52dddebae2" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRef</source>
          <target state="translated">TSpecialWord.wRef</target>
        </trans-unit>
        <trans-unit id="be048d968653db1d3dc961ae8ebf53bd4c68f166" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRegister</source>
          <target state="translated">TSpecialWord.wRegister</target>
        </trans-unit>
        <trans-unit id="8b80e46864ec623fa9e8f5475e2541099b188af8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReinterpret_cast</source>
          <target state="translated">TSpecialWord.wReinterpret_cast</target>
        </trans-unit>
        <trans-unit id="7d8b98c8733ff1965441d54cd8cc78a95436d313" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReorder</source>
          <target state="translated">TSpecialWord.wReorder</target>
        </trans-unit>
        <trans-unit id="032050ad9efa5acd958a6511df599471d8cb2c74" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequires</source>
          <target state="translated">TSpecialWord.wRequires</target>
        </trans-unit>
        <trans-unit id="d3dffc73a1d96c3d802b32eb7e39ddc139958219" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequiresInit</source>
          <target state="translated">TSpecialWord.wRequiresInit</target>
        </trans-unit>
        <trans-unit id="543fd2e5c16f6bff5a0bb30047bfc1189d31acaf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRestrict</source>
          <target state="translated">TSpecialWord.wRestrict</target>
        </trans-unit>
        <trans-unit id="3e374bb07c496ab290d5cebb03264be429060f1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReturn</source>
          <target state="translated">TSpecialWord.wReturn</target>
        </trans-unit>
        <trans-unit id="cbf79c4fe8fd77f4412e027be0ff8ee2d47696e5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecall</source>
          <target state="translated">TSpecialWord.wSafecall</target>
        </trans-unit>
        <trans-unit id="d24950f44da9648166edc152a3ab956b5f6f6c1a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecode</source>
          <target state="translated">TSpecialWord.wSafecode</target>
        </trans-unit>
        <trans-unit id="98d95ab8a2424b472a9ba50754608cd2297953b7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShallow</source>
          <target state="translated">TSpecialWord.wShallow</target>
        </trans-unit>
        <trans-unit id="2b2a65bacbe207841c53d73ad99699011a3ae136" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShl</source>
          <target state="translated">TSpecialWord.wShl</target>
        </trans-unit>
        <trans-unit id="4a6bac00c52ffed152558dd3c086e472cf6cb3c6" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShort</source>
          <target state="translated">TSpecialWord.wShort</target>
        </trans-unit>
        <trans-unit id="dfb5bbf53d2e54bbe729b7e92403cdb823eb2b0c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShr</source>
          <target state="translated">TSpecialWord.wShr</target>
        </trans-unit>
        <trans-unit id="236e385d070b2597fdea7ced17163542a3f4d1c8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSideEffect</source>
          <target state="translated">TSpecialWord.wSideEffect</target>
        </trans-unit>
        <trans-unit id="9fa842e819283837867308a0207f383cafd19b3e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSigned</source>
          <target state="translated">TSpecialWord.wSigned</target>
        </trans-unit>
        <trans-unit id="27a8834c59f9ad98925bf00dc917db1852a27299" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSinkInference</source>
          <target state="translated">TSpecialWord.wSinkInference</target>
        </trans-unit>
        <trans-unit id="b00ad10e6017e9de11489ae00852840ef13fd225" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSize</source>
          <target state="translated">TSpecialWord.wSize</target>
        </trans-unit>
        <trans-unit id="67cb4412a3444bae39547e9a844ef819b51e5c7d" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSizeof</source>
          <target state="translated">TSpecialWord.wSizeof</target>
        </trans-unit>
        <trans-unit id="375d1a0f39af91da2e515b2dc881cc48501d5e81" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStackTrace</source>
          <target state="translated">TSpecialWord.wStackTrace</target>
        </trans-unit>
        <trans-unit id="e5bec72d25cba4d87d2c10fecc04697e4741a3f5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStar</source>
          <target state="translated">TSpecialWord.wStar</target>
        </trans-unit>
        <trans-unit id="fa3cff407c086fc0695af06925696dfcdc317e15" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic</source>
          <target state="translated">TSpecialWord.wStatic</target>
        </trans-unit>
        <trans-unit id="9bf7942ea69df57f385d4b9f506f1c877038b349" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStaticBoundchecks</source>
          <target state="translated">TSpecialWord.wStaticBoundchecks</target>
        </trans-unit>
        <trans-unit id="42b65dec3e989eade77bb9dafbc7c5603136b9a4" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_assert</source>
          <target state="translated">TSpecialWord.wStatic_assert</target>
        </trans-unit>
        <trans-unit id="6671b68735c96c610635b2311938beae4174f474" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_cast</source>
          <target state="translated">TSpecialWord.wStatic_cast</target>
        </trans-unit>
        <trans-unit id="7a3ee08adfebd48c3c46780dcafff249ba850cfa" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdErr</source>
          <target state="translated">TSpecialWord.wStdErr</target>
        </trans-unit>
        <trans-unit id="762d8648d881bf250497c16ae7ef71e0f5dc36b8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdIn</source>
          <target state="translated">TSpecialWord.wStdIn</target>
        </trans-unit>
        <trans-unit id="73aaa0ffe071ec1c213dc94616c825c8bfd89d25" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdOut</source>
          <target state="translated">TSpecialWord.wStdOut</target>
        </trans-unit>
        <trans-unit id="2c1652ef3797603ee1016b39ca7d1eaf6a994a64" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdcall</source>
          <target state="translated">TSpecialWord.wStdcall</target>
        </trans-unit>
        <trans-unit id="c84b20a5cb26b59a2c609a6aa076dc00025857ea" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStrDefine</source>
          <target state="translated">TSpecialWord.wStrDefine</target>
        </trans-unit>
        <trans-unit id="49ed6cea4f1b008c45de69c2ff5abf3cf0424c58" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStruct</source>
          <target state="translated">TSpecialWord.wStruct</target>
        </trans-unit>
        <trans-unit id="675cfe4ec331766796865804ca47bbb153bf0155" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStyleChecks</source>
          <target state="translated">TSpecialWord.wStyleChecks</target>
        </trans-unit>
        <trans-unit id="5fa5466ccba7748cd7dbda2f197138204862ea2f" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSubsChar</source>
          <target state="translated">TSpecialWord.wSubsChar</target>
        </trans-unit>
        <trans-unit id="828d45bd46fbb2489a62d5b498cf0a455bcd067b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSwitch</source>
          <target state="translated">TSpecialWord.wSwitch</target>
        </trans-unit>
        <trans-unit id="8ae17bcff106fd30cb7e44426aa7e930ae4a13bf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSyscall</source>
          <target state="translated">TSpecialWord.wSyscall</target>
        </trans-unit>
        <trans-unit id="2c4b7ce46a5d91db3d102fe8d5a6c90ba038aac8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTags</source>
          <target state="translated">TSpecialWord.wTags</target>
        </trans-unit>
        <trans-unit id="8259d5f2948abbbddb4fd282fd77796d6a1e188b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTemplate</source>
          <target state="translated">TSpecialWord.wTemplate</target>
        </trans-unit>
        <trans-unit id="1f8ec32bd5c894b2fb69a2e65aa4eff6d85b2b2c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThis</source>
          <target state="translated">TSpecialWord.wThis</target>
        </trans-unit>
        <trans-unit id="fa09f4d08ebeaa289b05115b03460b2345c5690b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThiscall</source>
          <target state="translated">TSpecialWord.wThiscall</target>
        </trans-unit>
        <trans-unit id="710884f3ea7828d070ac0172eb890ea19137e10b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread</source>
          <target state="translated">TSpecialWord.wThread</target>
        </trans-unit>
        <trans-unit id="a5abf2f68067daf03579eaec46403ce1d4fa3122" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThreadVar</source>
          <target state="translated">TSpecialWord.wThreadVar</target>
        </trans-unit>
        <trans-unit id="3347bce5195eab1d6dbe2e3a70137a6875a1bcd0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread_local</source>
          <target state="translated">TSpecialWord.wThread_local</target>
        </trans-unit>
        <trans-unit id="d38d2534840f4e350de5ea3f4d4dfa93750e0e35" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThrow</source>
          <target state="translated">TSpecialWord.wThrow</target>
        </trans-unit>
        <trans-unit id="a74866bc8c91b482d6c277feb2855538288fc026" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrMacros</source>
          <target state="translated">TSpecialWord.wTrMacros</target>
        </trans-unit>
        <trans-unit id="659906f78c39e51a41596c895c0ccd5fc9211098" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrue</source>
          <target state="translated">TSpecialWord.wTrue</target>
        </trans-unit>
        <trans-unit id="79ea1fcf98460dbb432b5051f2024d63e01bfe2a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTry</source>
          <target state="translated">TSpecialWord.wTry</target>
        </trans-unit>
        <trans-unit id="66986335415d83d7b446a919737a7731a6b47007" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTuple</source>
          <target state="translated">TSpecialWord.wTuple</target>
        </trans-unit>
        <trans-unit id="ccf870e3f2157fa7a58f23b262338a605c4a70c3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wType</source>
          <target state="translated">TSpecialWord.wType</target>
        </trans-unit>
        <trans-unit id="5d241960b2464b1d99ad110a5ab14d6c8c40cb1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypedef</source>
          <target state="translated">TSpecialWord.wTypedef</target>
        </trans-unit>
        <trans-unit id="578fe1dad51eb962bc7100551c55df0d2f910a05" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeid</source>
          <target state="translated">TSpecialWord.wTypeid</target>
        </trans-unit>
        <trans-unit id="4f7fa4c634320c3d0ac7ad82ea04ec56c867b2c0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypename</source>
          <target state="translated">TSpecialWord.wTypename</target>
        </trans-unit>
        <trans-unit id="81789f4e632314e9fc671603cc6f4504cb3d3c7e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeof</source>
          <target state="translated">TSpecialWord.wTypeof</target>
        </trans-unit>
        <trans-unit id="e82424012de52d35e49a0273d3bb8964198190f7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnchecked</source>
          <target state="translated">TSpecialWord.wUnchecked</target>
        </trans-unit>
        <trans-unit id="dbc5d36cd28889beee0705d587be6e2bf5f0ba24" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUndef</source>
          <target state="translated">TSpecialWord.wUndef</target>
        </trans-unit>
        <trans-unit id="279a751e05c27d1e929e77b6e74a8f8fcd202ff3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnion</source>
          <target state="translated">TSpecialWord.wUnion</target>
        </trans-unit>
        <trans-unit id="acd5245dafa7c73d3e19f18016ec4300935dbc52" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnroll</source>
          <target state="translated">TSpecialWord.wUnroll</target>
        </trans-unit>
        <trans-unit id="128bae39e8b7b9c9bd624e15b312f4239ed53544" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnsigned</source>
          <target state="translated">TSpecialWord.wUnsigned</target>
        </trans-unit>
        <trans-unit id="4538a950702fcf865d3ddc624772f08dc9bed770" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsed</source>
          <target state="translated">TSpecialWord.wUsed</target>
        </trans-unit>
        <trans-unit id="d5186b721a554f2af5bc7833570447bfbaee4ffb" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsing</source>
          <target state="translated">TSpecialWord.wUsing</target>
        </trans-unit>
        <trans-unit id="dd8d9f0aba1c048fda45ed8dd426cf658def8d93" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVar</source>
          <target state="translated">TSpecialWord.wVar</target>
        </trans-unit>
        <trans-unit id="01d3d47c3053cb3b7fb482f0e745f51c7df7a0f8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVarargs</source>
          <target state="translated">TSpecialWord.wVarargs</target>
        </trans-unit>
        <trans-unit id="85c9b1fce5be3772cd95801d5874b26567b30c50" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVirtual</source>
          <target state="translated">TSpecialWord.wVirtual</target>
        </trans-unit>
        <trans-unit id="cae380bec2b17f6a257f9414ce33fab2081ccb90" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVoid</source>
          <target state="translated">TSpecialWord.wVoid</target>
        </trans-unit>
        <trans-unit id="eaec574e0294d6f4cfe6975561364a6e8ed2ee73" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVolatile</source>
          <target state="translated">TSpecialWord.wVolatile</target>
        </trans-unit>
        <trans-unit id="ac2d56ae50a4ef8e57ef5e5be34355ca25d1e222" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarning</source>
          <target state="translated">TSpecialWord.wWarning</target>
        </trans-unit>
        <trans-unit id="815eb53d1f7c1a0ca216fd9787dd0db2ce819982" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarningAsError</source>
          <target state="translated">TSpecialWord.wWarningAsError</target>
        </trans-unit>
        <trans-unit id="e2c2ec1dda075dad3c4bc901affaf5549a2d2b75" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarnings</source>
          <target state="translated">TSpecialWord.wWarnings</target>
        </trans-unit>
        <trans-unit id="5b837dea019d23d30994653aeb2a6a8f303a568c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWchar_t</source>
          <target state="translated">TSpecialWord.wWchar_t</target>
        </trans-unit>
        <trans-unit id="f60e52204ae6220e3c6082c529bc3c10f836c8e0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhen</source>
          <target state="translated">TSpecialWord.wWhen</target>
        </trans-unit>
        <trans-unit id="22f35857d8fff1b871e90250921bcbad022c1596" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhile</source>
          <target state="translated">TSpecialWord.wWhile</target>
        </trans-unit>
        <trans-unit id="f7bf965945cdbc25c36d9e3dc84f071eb2b53200" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrite</source>
          <target state="translated">TSpecialWord.wWrite</target>
        </trans-unit>
        <trans-unit id="65b8c2c53f6ca0b94c75c1d256fefa69d322b613" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrites</source>
          <target state="translated">TSpecialWord.wWrites</target>
        </trans-unit>
        <trans-unit id="385a4cef4263d0f5309e1c0899a6b65221d03816" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wXor</source>
          <target state="translated">TSpecialWord.wXor</target>
        </trans-unit>
        <trans-unit id="d6f1af335750efb309789ef991ace31453c11f01" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wYield</source>
          <target state="translated">TSpecialWord.wYield</target>
        </trans-unit>
        <trans-unit id="e6d0cddee16c4a5b079344fd99dcab4c4d1b9e4c" translate="yes" xml:space="preserve">
          <source>TSpecialWord:</source>
          <target state="translated">TSpecialWord:</target>
        </trans-unit>
        <trans-unit id="be4d767100d61b72e964b4c9f210a5a6fe5a30b1" translate="yes" xml:space="preserve">
          <source>TSpecialWords:</source>
          <target state="translated">TSpecialWords:</target>
        </trans-unit>
        <trans-unit id="adb30911c6273d9d5b3b15cb0ce088b23e2ba860" translate="yes" xml:space="preserve">
          <source>TSrcGen:</source>
          <target state="translated">TSrcGen:</target>
        </trans-unit>
        <trans-unit id="6323d0dcdfc011e809275fb4eba73730c046c118" translate="yes" xml:space="preserve">
          <source>TStackFrame:</source>
          <target state="translated">TStackFrame:</target>
        </trans-unit>
        <trans-unit id="395d19944b46707114ce5ef88d888fc1f25becb7" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnHeap</source>
          <target state="translated">TStorageLoc.OnHeap</target>
        </trans-unit>
        <trans-unit id="a621c5b644c09975980371a6c506a414732361eb" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStack</source>
          <target state="translated">TStorageLoc.OnStack</target>
        </trans-unit>
        <trans-unit id="d50d78116f7b907d867a6196eb491acda5ae45b3" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStatic</source>
          <target state="translated">TStorageLoc.OnStatic</target>
        </trans-unit>
        <trans-unit id="aab718eb78528ad6e6e1c17a2c7f7fc049cb99e8" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnUnknown</source>
          <target state="translated">TStorageLoc.OnUnknown</target>
        </trans-unit>
        <trans-unit id="bcf92d0d35e49a4a230909f361cff8341d206060" translate="yes" xml:space="preserve">
          <source>TStorageLoc:</source>
          <target state="translated">TStorageLoc:</target>
        </trans-unit>
        <trans-unit id="cf7b832a47b0aa258a00e12b2bc337b5f3fbcb37" translate="yes" xml:space="preserve">
          <source>TStrTable:</source>
          <target state="translated">TStrTable:</target>
        </trans-unit>
        <trans-unit id="12d7fc329e1ae4a95222ebc188918ec1a1418652" translate="yes" xml:space="preserve">
          <source>TStringSeq:</source>
          <target state="translated">TStringSeq:</target>
        </trans-unit>
        <trans-unit id="05b487bb2b91485184c628ce10489134924aa98b" translate="yes" xml:space="preserve">
          <source>TSym:</source>
          <target state="translated">TSym:</target>
        </trans-unit>
        <trans-unit id="9330a751f32c5ee89229160cd7e81e74056f7182" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfAddrTaken</source>
          <target state="translated">TSymFlag.sfAddrTaken</target>
        </trans-unit>
        <trans-unit id="2dd6e5ad1a7670b695ce53f4d472c13e31c1b44b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfBorrow</source>
          <target state="translated">TSymFlag.sfBorrow</target>
        </trans-unit>
        <trans-unit id="a1efaba0d735377cf87b7f6858536df1dc6db3ca" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCallsite</source>
          <target state="translated">TSymFlag.sfCallsite</target>
        </trans-unit>
        <trans-unit id="edc5ff991665ff461d50658b207b93b6f8c66cda" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompileTime</source>
          <target state="translated">TSymFlag.sfCompileTime</target>
        </trans-unit>
        <trans-unit id="582d96473a233f6d011b615d47980f8d5dd93af3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompilerProc</source>
          <target state="translated">TSymFlag.sfCompilerProc</target>
        </trans-unit>
        <trans-unit id="b516b17c0bde4915c66c3305e883ed517bc783fa" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfConstructor</source>
          <target state="translated">TSymFlag.sfConstructor</target>
        </trans-unit>
        <trans-unit id="298f5d1d6d6ed080d23994ae981ee6bfc36fbd59" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCursor</source>
          <target state="translated">TSymFlag.sfCursor</target>
        </trans-unit>
        <trans-unit id="bd0596035433f9c47b27e85e2a8c35f5493ebfaf" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDeprecated</source>
          <target state="translated">TSymFlag.sfDeprecated</target>
        </trans-unit>
        <trans-unit id="5f92740cada22e9ed96755b4f6d2a928a0d66889" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscardable</source>
          <target state="translated">TSymFlag.sfDiscardable</target>
        </trans-unit>
        <trans-unit id="6e343a45d312a4042d970d9ec4a09af5398a6b72" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscriminant</source>
          <target state="translated">TSymFlag.sfDiscriminant</target>
        </trans-unit>
        <trans-unit id="b1fa4f615769249576344c340b880762b76bd5b7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDispatcher</source>
          <target state="translated">TSymFlag.sfDispatcher</target>
        </trans-unit>
        <trans-unit id="e455f5f383b9e0f6fbd1c12e034948b40017e87b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfError</source>
          <target state="translated">TSymFlag.sfError</target>
        </trans-unit>
        <trans-unit id="e1fb45f483c1d52633c02bc21bee7c53ec5788f9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExplain</source>
          <target state="translated">TSymFlag.sfExplain</target>
        </trans-unit>
        <trans-unit id="7e4b245f8a05a920c7655f9ad1d64bf2c9e477e0" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExportc</source>
          <target state="translated">TSymFlag.sfExportc</target>
        </trans-unit>
        <trans-unit id="2f8455ceee2fc2e375778732463006731b34784a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExported</source>
          <target state="translated">TSymFlag.sfExported</target>
        </trans-unit>
        <trans-unit id="a52c7cbacb40cf2d307722b243bc58981e796eec" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfForward</source>
          <target state="translated">TSymFlag.sfForward</target>
        </trans-unit>
        <trans-unit id="1196f111e6dc3efb4835c41b10074f675c379f1d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfFromGeneric</source>
          <target state="translated">TSymFlag.sfFromGeneric</target>
        </trans-unit>
        <trans-unit id="105365f8de9763fcf244284a5c9407c8aa4c2661" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGenSym</source>
          <target state="translated">TSymFlag.sfGenSym</target>
        </trans-unit>
        <trans-unit id="04e8b1287496c27529d274cec4f17fe9a6ba8697" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGeneratedOp</source>
          <target state="translated">TSymFlag.sfGeneratedOp</target>
        </trans-unit>
        <trans-unit id="534e05b2302e2356d51e38b679c263ef12cb5a20" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGlobal</source>
          <target state="translated">TSymFlag.sfGlobal</target>
        </trans-unit>
        <trans-unit id="533c0791334dc3ed4ded29375e0ea0e96faeeeb7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfImportc</source>
          <target state="translated">TSymFlag.sfImportc</target>
        </trans-unit>
        <trans-unit id="330bfbc6bd478f12eab1f5558ac4bf0df5cbc25a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInfixCall</source>
          <target state="translated">TSymFlag.sfInfixCall</target>
        </trans-unit>
        <trans-unit id="39f816cbf3f55a3030ca4c9728879a5779e2ce84" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInjectDestructors</source>
          <target state="translated">TSymFlag.sfInjectDestructors</target>
        </trans-unit>
        <trans-unit id="b0e41681dd3772b0d00504a1f624b641a1ce3b1e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMainModule</source>
          <target state="translated">TSymFlag.sfMainModule</target>
        </trans-unit>
        <trans-unit id="8e8263d25bd716de09e2495e4ea8b9bad934bbc8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMangleCpp</source>
          <target state="translated">TSymFlag.sfMangleCpp</target>
        </trans-unit>
        <trans-unit id="d47663c51704084f8beb0d796f58a03b269273d6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNamedParamCall</source>
          <target state="translated">TSymFlag.sfNamedParamCall</target>
        </trans-unit>
        <trans-unit id="3ec62b325c5a44dcf3588a04a6fbbe199da7fca8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNeverRaises</source>
          <target state="translated">TSymFlag.sfNeverRaises</target>
        </trans-unit>
        <trans-unit id="6b10b09be35a82d4e4c9f714e1e485d6c74a08d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoReturn</source>
          <target state="translated">TSymFlag.sfNoReturn</target>
        </trans-unit>
        <trans-unit id="1636d386afaa9112e3cafc2af385fef845e7f60a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoSideEffect</source>
          <target state="translated">TSymFlag.sfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="277ce17ae708dd1e2e807e085e44d05628bd1cc9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoalias</source>
          <target state="translated">TSymFlag.sfNoalias</target>
        </trans-unit>
        <trans-unit id="2d5cad3f2fc8b04bf4b9760b4ade680573ac4847" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNonReloadable</source>
          <target state="translated">TSymFlag.sfNonReloadable</target>
        </trans-unit>
        <trans-unit id="932c83b43941e8293a0c9790f9f7394ad71414e3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfOverriden</source>
          <target state="translated">TSymFlag.sfOverriden</target>
        </trans-unit>
        <trans-unit id="71409f73c696c09edb6da3f445713c46904ca616" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfProcvar</source>
          <target state="translated">TSymFlag.sfProcvar</target>
        </trans-unit>
        <trans-unit id="76f94fff7ac23d224a5bc526747e1686feb676cb" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfPure</source>
          <target state="translated">TSymFlag.sfPure</target>
        </trans-unit>
        <trans-unit id="4fca142ba180109698776ba0a36c4f4c9002640d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRegister</source>
          <target state="translated">TSymFlag.sfRegister</target>
        </trans-unit>
        <trans-unit id="cfa983785f95c8ce9b0d73629a1d7067f48e010e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRequiresInit</source>
          <target state="translated">TSymFlag.sfRequiresInit</target>
        </trans-unit>
        <trans-unit id="5f6ecd6b6f03c52714fb8853b88eb55430032b09" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfShadowed</source>
          <target state="translated">TSymFlag.sfShadowed</target>
        </trans-unit>
        <trans-unit id="2e289288f11f81e4ac61b02d13c1fec9e78e2192" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSideEffect</source>
          <target state="translated">TSymFlag.sfSideEffect</target>
        </trans-unit>
        <trans-unit id="8d495c01577f4bf009f6865e434af0e0d8466fa6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSingleUsedTemp</source>
          <target state="translated">TSymFlag.sfSingleUsedTemp</target>
        </trans-unit>
        <trans-unit id="7d50321a18c3926dabf7444407d02c677dbc42d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSystemModule</source>
          <target state="translated">TSymFlag.sfSystemModule</target>
        </trans-unit>
        <trans-unit id="b56a7ace7f8cb72017ccb47cf2f59ddfa3bf7a2b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfTemplateParam</source>
          <target state="translated">TSymFlag.sfTemplateParam</target>
        </trans-unit>
        <trans-unit id="f939407b7d9d720c20e219b1739d2160b2c627de" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfThread</source>
          <target state="translated">TSymFlag.sfThread</target>
        </trans-unit>
        <trans-unit id="a32d4997116a1bb7e46d6e2074c08949f77ef009" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsed</source>
          <target state="translated">TSymFlag.sfUsed</target>
        </trans-unit>
        <trans-unit id="f0e174760c583a922fc6dedbb1f219b72c2ec6e4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsedInFinallyOrExcept</source>
          <target state="translated">TSymFlag.sfUsedInFinallyOrExcept</target>
        </trans-unit>
        <trans-unit id="82552db7e730ccc1f98ac08d01dfb4dea5d1f933" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfVolatile</source>
          <target state="translated">TSymFlag.sfVolatile</target>
        </trans-unit>
        <trans-unit id="72bdf7b7b1da7510d785d165cc71e2a29d569556" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfWasForwarded</source>
          <target state="translated">TSymFlag.sfWasForwarded</target>
        </trans-unit>
        <trans-unit id="29c7d5626ad614186f0d440855956d99d98de760" translate="yes" xml:space="preserve">
          <source>TSymFlag:</source>
          <target state="translated">TSymFlag:</target>
        </trans-unit>
        <trans-unit id="d47155ecd82d26176d884a3a5c7290848bc046d7" translate="yes" xml:space="preserve">
          <source>TSymFlags:</source>
          <target state="translated">TSymFlags:</target>
        </trans-unit>
        <trans-unit id="49a417dc99897410b26a479122d7c245c98404df" translate="yes" xml:space="preserve">
          <source>TSymKind.skAlias</source>
          <target state="translated">TSymKind.skAlias</target>
        </trans-unit>
        <trans-unit id="c76f677a9ccca1cb58417acb2f2221011359b50e" translate="yes" xml:space="preserve">
          <source>TSymKind.skConditional</source>
          <target state="translated">TSymKind.skConditional</target>
        </trans-unit>
        <trans-unit id="7dfa50d9174c876ce7d15bc1fd5aa7819f6eb7e8" translate="yes" xml:space="preserve">
          <source>TSymKind.skConst</source>
          <target state="translated">TSymKind.skConst</target>
        </trans-unit>
        <trans-unit id="919d3051204679f680a8114ed54198af8cd03508" translate="yes" xml:space="preserve">
          <source>TSymKind.skConverter</source>
          <target state="translated">TSymKind.skConverter</target>
        </trans-unit>
        <trans-unit id="57d44bfce9d934c7b94cccc0ed40283adea986f6" translate="yes" xml:space="preserve">
          <source>TSymKind.skDynLib</source>
          <target state="translated">TSymKind.skDynLib</target>
        </trans-unit>
        <trans-unit id="5a6a73a73234b278355b6d90ff6594ea1532cc5b" translate="yes" xml:space="preserve">
          <source>TSymKind.skEnumField</source>
          <target state="translated">TSymKind.skEnumField</target>
        </trans-unit>
        <trans-unit id="6b13fc9942e9012939aaa24c01ee74d54785096d" translate="yes" xml:space="preserve">
          <source>TSymKind.skField</source>
          <target state="translated">TSymKind.skField</target>
        </trans-unit>
        <trans-unit id="b42eb31691f0f152a922d109173d10452db09398" translate="yes" xml:space="preserve">
          <source>TSymKind.skForVar</source>
          <target state="translated">TSymKind.skForVar</target>
        </trans-unit>
        <trans-unit id="3c93bc5280899b1704d4939e91709f91bb81c109" translate="yes" xml:space="preserve">
          <source>TSymKind.skFunc</source>
          <target state="translated">TSymKind.skFunc</target>
        </trans-unit>
        <trans-unit id="e946aeda39742b18797afdfbc5ef7d032a114722" translate="yes" xml:space="preserve">
          <source>TSymKind.skGenericParam</source>
          <target state="translated">TSymKind.skGenericParam</target>
        </trans-unit>
        <trans-unit id="8b85c87c4b38369f835e342209e7c7ab4d80b88e" translate="yes" xml:space="preserve">
          <source>TSymKind.skIterator</source>
          <target state="translated">TSymKind.skIterator</target>
        </trans-unit>
        <trans-unit id="b9bec98f25dbc1b1c1c5bd16c387a21a1ad6a3d0" translate="yes" xml:space="preserve">
          <source>TSymKind.skLabel</source>
          <target state="translated">TSymKind.skLabel</target>
        </trans-unit>
        <trans-unit id="2b17d003c02f1eed23328282ec4b75a2c7bab33a" translate="yes" xml:space="preserve">
          <source>TSymKind.skLet</source>
          <target state="translated">TSymKind.skLet</target>
        </trans-unit>
        <trans-unit id="a8285a283b0af2c8fca7edc0b6fdc1913a6ce5b6" translate="yes" xml:space="preserve">
          <source>TSymKind.skMacro</source>
          <target state="translated">TSymKind.skMacro</target>
        </trans-unit>
        <trans-unit id="b8267d7384523a8483da02476006487bdba9d91f" translate="yes" xml:space="preserve">
          <source>TSymKind.skMethod</source>
          <target state="translated">TSymKind.skMethod</target>
        </trans-unit>
        <trans-unit id="60d683994d2f4bfd3a0468b0b5765ebadb8fd4e5" translate="yes" xml:space="preserve">
          <source>TSymKind.skModule</source>
          <target state="translated">TSymKind.skModule</target>
        </trans-unit>
        <trans-unit id="d4b3f8c98e41c6b045e0cf12b69a3c13146ded9b" translate="yes" xml:space="preserve">
          <source>TSymKind.skPackage</source>
          <target state="translated">TSymKind.skPackage</target>
        </trans-unit>
        <trans-unit id="581dde25239097be52aac3d98efd76085651c04c" translate="yes" xml:space="preserve">
          <source>TSymKind.skParam</source>
          <target state="translated">TSymKind.skParam</target>
        </trans-unit>
        <trans-unit id="d5061dd8b70ade95406188521b2aff052a2b8b76" translate="yes" xml:space="preserve">
          <source>TSymKind.skProc</source>
          <target state="translated">TSymKind.skProc</target>
        </trans-unit>
        <trans-unit id="10d6d5f68c3d570f559afef9c7d0e1c503f31c82" translate="yes" xml:space="preserve">
          <source>TSymKind.skResult</source>
          <target state="translated">TSymKind.skResult</target>
        </trans-unit>
        <trans-unit id="4b1403bed05bc383c650ebbd4da253f3677a73a7" translate="yes" xml:space="preserve">
          <source>TSymKind.skStub</source>
          <target state="translated">TSymKind.skStub</target>
        </trans-unit>
        <trans-unit id="e0042cc9bef9afa39e87b6f8dea08bedd12df156" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemp</source>
          <target state="translated">TSymKind.skTemp</target>
        </trans-unit>
        <trans-unit id="baf8eeb56f3a1d01fb53ecac94f2eda78f5750d3" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemplate</source>
          <target state="translated">TSymKind.skTemplate</target>
        </trans-unit>
        <trans-unit id="a4ea389dec6af0c3a90402fd6a64c460d4965315" translate="yes" xml:space="preserve">
          <source>TSymKind.skType</source>
          <target state="translated">TSymKind.skType</target>
        </trans-unit>
        <trans-unit id="e62db8421aee5327a828a735d66f7957f7d3d74f" translate="yes" xml:space="preserve">
          <source>TSymKind.skUnknown</source>
          <target state="translated">TSymKind.skUnknown</target>
        </trans-unit>
        <trans-unit id="c279ecb87280d50b68a3bd440f8e43008b19e819" translate="yes" xml:space="preserve">
          <source>TSymKind.skVar</source>
          <target state="translated">TSymKind.skVar</target>
        </trans-unit>
        <trans-unit id="36000b209f29bc98cf392b4e4456f57a84b3b59b" translate="yes" xml:space="preserve">
          <source>TSymKind:</source>
          <target state="translated">TSymKind:</target>
        </trans-unit>
        <trans-unit id="a3b25836cfbafe08072c36a3f31b50569b89cb87" translate="yes" xml:space="preserve">
          <source>TSymKinds:</source>
          <target state="translated">TSymKinds:</target>
        </trans-unit>
        <trans-unit id="40e65df88cca5769c108db4732546e9385041477" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccBcc</source>
          <target state="translated">TSystemCC.ccBcc</target>
        </trans-unit>
        <trans-unit id="6d00814fd9c17001351f26f74ecf8e0d598070b0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccCLang</source>
          <target state="translated">TSystemCC.ccCLang</target>
        </trans-unit>
        <trans-unit id="19071fc3124e339066eeefd76c5caa5747d3b6d2" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccClangCl</source>
          <target state="translated">TSystemCC.ccClangCl</target>
        </trans-unit>
        <trans-unit id="fcb066cfa947fca39a83432714945b7e0f17d383" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccEnv</source>
          <target state="translated">TSystemCC.ccEnv</target>
        </trans-unit>
        <trans-unit id="97f6f68538eefe119e8183ea5c5e98feb0f79c6d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccGcc</source>
          <target state="translated">TSystemCC.ccGcc</target>
        </trans-unit>
        <trans-unit id="7384f9d26bb7f0967750fd1f751e72ac5b69923c" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcc</source>
          <target state="translated">TSystemCC.ccIcc</target>
        </trans-unit>
        <trans-unit id="0f268723c4eae2053cac77dd39a6d770474f8223" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcl</source>
          <target state="translated">TSystemCC.ccIcl</target>
        </trans-unit>
        <trans-unit id="2b1588d1bf0a5cc64f3bcd66ca1d8ac7081f9e0f" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccLLVM_Gcc</source>
          <target state="translated">TSystemCC.ccLLVM_Gcc</target>
        </trans-unit>
        <trans-unit id="71239fb0d7cf2675e99b0aa8d9958cad2e7f2bc0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNintendoSwitch</source>
          <target state="translated">TSystemCC.ccNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="41f122e6477383f472ab026e739beeca2659006d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNone</source>
          <target state="translated">TSystemCC.ccNone</target>
        </trans-unit>
        <trans-unit id="8e5ec951c8818fd50562a51f1771746f02dd9732" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccTcc</source>
          <target state="translated">TSystemCC.ccTcc</target>
        </trans-unit>
        <trans-unit id="d5d2fddd742551849c57359a32720a1a7c68c407" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccVcc</source>
          <target state="translated">TSystemCC.ccVcc</target>
        </trans-unit>
        <trans-unit id="e4b6b58efbe0ae82d8de0366bbeb65ef571f542b" translate="yes" xml:space="preserve">
          <source>TSystemCC:</source>
          <target state="translated">TSystemCC:</target>
        </trans-unit>
        <trans-unit id="e85203494b9cda1e361884f465c8d21638c17c47" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAVR</source>
          <target state="translated">TSystemCPU.cpuAVR</target>
        </trans-unit>
        <trans-unit id="e28d761304c4f6489545762c0b4c34008fc2245c" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAlpha</source>
          <target state="translated">TSystemCPU.cpuAlpha</target>
        </trans-unit>
        <trans-unit id="d801dcb1b7ceb4ce49f7a098ef0d8a08858eed98" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAmd64</source>
          <target state="translated">TSystemCPU.cpuAmd64</target>
        </trans-unit>
        <trans-unit id="ba596950092238df74b220c68b11c34fc419e0e0" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm</source>
          <target state="translated">TSystemCPU.cpuArm</target>
        </trans-unit>
        <trans-unit id="9ca4c13a0c290114fd7d1c85a30b5b41a67a5bc9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm64</source>
          <target state="translated">TSystemCPU.cpuArm64</target>
        </trans-unit>
        <trans-unit id="5b65105583f3819adb0632e62bb25e0a18da9bbb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuEsp</source>
          <target state="translated">TSystemCPU.cpuEsp</target>
        </trans-unit>
        <trans-unit id="8447db6ec7fdf81f194cc4ecd1414b74f623750a" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuHppa</source>
          <target state="translated">TSystemCPU.cpuHppa</target>
        </trans-unit>
        <trans-unit id="bc456545a8d7ffa3ed8212abdb78b306dde88093" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuI386</source>
          <target state="translated">TSystemCPU.cpuI386</target>
        </trans-unit>
        <trans-unit id="c6083caa9bfe02d7c40b52f99d7b6abb8d7864f7" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuIa64</source>
          <target state="translated">TSystemCPU.cpuIa64</target>
        </trans-unit>
        <trans-unit id="3e878dd5fc4a0168ff6f7991ce1f44372aedc620" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuJS</source>
          <target state="translated">TSystemCPU.cpuJS</target>
        </trans-unit>
        <trans-unit id="76fba4bb86ffe7ff850b133c4c20c39bb685b516" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuM68k</source>
          <target state="translated">TSystemCPU.cpuM68k</target>
        </trans-unit>
        <trans-unit id="f2e8398a63ef93ff4063793c053f8dc154c4a290" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMSP430</source>
          <target state="translated">TSystemCPU.cpuMSP430</target>
        </trans-unit>
        <trans-unit id="c8a9c9af2114a96e56820717902c60073ab32b1f" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips</source>
          <target state="translated">TSystemCPU.cpuMips</target>
        </trans-unit>
        <trans-unit id="24591e6c0052949e99184099449d788dad8f29a9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64</source>
          <target state="translated">TSystemCPU.cpuMips64</target>
        </trans-unit>
        <trans-unit id="6e85a81c06cdf314f2da1ba7bef924bc75a6edce" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64el</source>
          <target state="translated">TSystemCPU.cpuMips64el</target>
        </trans-unit>
        <trans-unit id="1d8ab56ff314237fa81874b96bd0c570456c7697" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMipsel</source>
          <target state="translated">TSystemCPU.cpuMipsel</target>
        </trans-unit>
        <trans-unit id="1023f73aa3e9a1c6576d33e867de8b2de6ccddc1" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNimVM</source>
          <target state="translated">TSystemCPU.cpuNimVM</target>
        </trans-unit>
        <trans-unit id="a5220471302688e090fd0384c2a6d0e2555a35dc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNone</source>
          <target state="translated">TSystemCPU.cpuNone</target>
        </trans-unit>
        <trans-unit id="e073cc300e253e5d6c5f43f1d40975ee3ee35f36" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc</source>
          <target state="translated">TSystemCPU.cpuPowerpc</target>
        </trans-unit>
        <trans-unit id="a0bb3fb97c3f25aa16dfdff5a063669cca1debb9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64</source>
          <target state="translated">TSystemCPU.cpuPowerpc64</target>
        </trans-unit>
        <trans-unit id="d9b7e25410216178660f56da74dbf1b12974e3fc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64el</source>
          <target state="translated">TSystemCPU.cpuPowerpc64el</target>
        </trans-unit>
        <trans-unit id="3541d71f45742618d1e0853f477959e0683a8d59" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuRiscV64</source>
          <target state="translated">TSystemCPU.cpuRiscV64</target>
        </trans-unit>
        <trans-unit id="33e3b76ba433a36d3634e0f2077791506ce9b7cf" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc</source>
          <target state="translated">TSystemCPU.cpuSparc</target>
        </trans-unit>
        <trans-unit id="2195ef6204df47de3f399d523e82333924ee50ee" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc64</source>
          <target state="translated">TSystemCPU.cpuSparc64</target>
        </trans-unit>
        <trans-unit id="9fa0216f565e08a88e069b22b00651362a0a2abb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuVm</source>
          <target state="translated">TSystemCPU.cpuVm</target>
        </trans-unit>
        <trans-unit id="9fb10eff42bbf00edd9d6dac15eb0b596991e106" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuWasm32</source>
          <target state="translated">TSystemCPU.cpuWasm32</target>
        </trans-unit>
        <trans-unit id="5e0590cc52dd7fd9f8c5f71948ac3e4fbb645e7d" translate="yes" xml:space="preserve">
          <source>TSystemCPU:</source>
          <target state="translated">TSystemCPU:</target>
        </trans-unit>
        <trans-unit id="0b357ac76e93964f0e9aa628cf5ff44e248e0aff" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAix</source>
          <target state="translated">TSystemOS.osAix</target>
        </trans-unit>
        <trans-unit id="57e794c9e1abb8e214350a820bef46513aa5410d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAmiga</source>
          <target state="translated">TSystemOS.osAmiga</target>
        </trans-unit>
        <trans-unit id="139f446a98c51f26d348db327105203f84121229" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAndroid</source>
          <target state="translated">TSystemOS.osAndroid</target>
        </trans-unit>
        <trans-unit id="0601a6371692f109064f096efedf7295967e8403" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAny</source>
          <target state="translated">TSystemOS.osAny</target>
        </trans-unit>
        <trans-unit id="9ae1eebbb62dc69485803ce20300a53317d7990e" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAtari</source>
          <target state="translated">TSystemOS.osAtari</target>
        </trans-unit>
        <trans-unit id="2d7d69566045aa8beeaa3254d4276bb3fcfdef2c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDos</source>
          <target state="translated">TSystemOS.osDos</target>
        </trans-unit>
        <trans-unit id="309c21832c4018ef77f374a618bd781eea84a066" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDragonfly</source>
          <target state="translated">TSystemOS.osDragonfly</target>
        </trans-unit>
        <trans-unit id="db54117145d85bc8c33b683ec9ab07263b4d6fd0" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreeRTOS</source>
          <target state="translated">TSystemOS.osFreeRTOS</target>
        </trans-unit>
        <trans-unit id="a664f10fbfe811c5a9d84bdfca93ff12f0358741" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreebsd</source>
          <target state="translated">TSystemOS.osFreebsd</target>
        </trans-unit>
        <trans-unit id="bc47a412753230d118928d7f63b36b9e6309d2c3" translate="yes" xml:space="preserve">
          <source>TSystemOS.osGenode</source>
          <target state="translated">TSystemOS.osGenode</target>
        </trans-unit>
        <trans-unit id="e940630397e431aed1fc63cca4ebe7f6fe232f0b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osHaiku</source>
          <target state="translated">TSystemOS.osHaiku</target>
        </trans-unit>
        <trans-unit id="c197905406125d16d4a6f74ab6b8199d900f4ecb" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIos</source>
          <target state="translated">TSystemOS.osIos</target>
        </trans-unit>
        <trans-unit id="e57f2d8c18cd83b14c9fb9eb4ef124e0a1e3993f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIrix</source>
          <target state="translated">TSystemOS.osIrix</target>
        </trans-unit>
        <trans-unit id="1e7216ad040dd651e0cefb1f37074ad0662ffe75" translate="yes" xml:space="preserve">
          <source>TSystemOS.osJS</source>
          <target state="translated">TSystemOS.osJS</target>
        </trans-unit>
        <trans-unit id="c87dce60adfb5c9c9dc59db4d26f6b0b61fdff55" translate="yes" xml:space="preserve">
          <source>TSystemOS.osLinux</source>
          <target state="translated">TSystemOS.osLinux</target>
        </trans-unit>
        <trans-unit id="51b2d87a29af45151db0dc281d2828f8fc776f6f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacos</source>
          <target state="translated">TSystemOS.osMacos</target>
        </trans-unit>
        <trans-unit id="f3991a53075ffa27b2f9fe0029a6a1412cc9e393" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacosx</source>
          <target state="translated">TSystemOS.osMacosx</target>
        </trans-unit>
        <trans-unit id="d7bc87d6f7e56f805a7e5c270db9eea5752ea7b2" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMorphos</source>
          <target state="translated">TSystemOS.osMorphos</target>
        </trans-unit>
        <trans-unit id="10192972afc69a1d3ba9c793e640fd1d96c5b030" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetbsd</source>
          <target state="translated">TSystemOS.osNetbsd</target>
        </trans-unit>
        <trans-unit id="c20a3ae638bccfe7eadd065e638b9ad9bfa4571b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetware</source>
          <target state="translated">TSystemOS.osNetware</target>
        </trans-unit>
        <trans-unit id="941a5d5eacc491c469cf30cfdacc174c871fce9c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNimVM</source>
          <target state="translated">TSystemOS.osNimVM</target>
        </trans-unit>
        <trans-unit id="271c3ce037881f412f8686ade95524481697197b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNintendoSwitch</source>
          <target state="translated">TSystemOS.osNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="e768046f46b0a39479496146233246e16a916c04" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNone</source>
          <target state="translated">TSystemOS.osNone</target>
        </trans-unit>
        <trans-unit id="e00eb077875a3b48219f06030696c42e78fe57a7" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOpenbsd</source>
          <target state="translated">TSystemOS.osOpenbsd</target>
        </trans-unit>
        <trans-unit id="bf32d61ca1a1af77ebe67ab324a055555ee2e6d8" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOs2</source>
          <target state="translated">TSystemOS.osOs2</target>
        </trans-unit>
        <trans-unit id="1de6f4e8e82651e9f443671af18e016ead98a709" translate="yes" xml:space="preserve">
          <source>TSystemOS.osPalmos</source>
          <target state="translated">TSystemOS.osPalmos</target>
        </trans-unit>
        <trans-unit id="f79e259295c14e93026df87a786a1dd63b1bede9" translate="yes" xml:space="preserve">
          <source>TSystemOS.osQnx</source>
          <target state="translated">TSystemOS.osQnx</target>
        </trans-unit>
        <trans-unit id="7cbac9d74c2ec82ad5104b2e56eb41053dacd2be" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSkyos</source>
          <target state="translated">TSystemOS.osSkyos</target>
        </trans-unit>
        <trans-unit id="3281c9ed268a903d82b811ed828fc68ddfc04fd5" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSolaris</source>
          <target state="translated">TSystemOS.osSolaris</target>
        </trans-unit>
        <trans-unit id="43c30ef6d951f5134eefd74464e64b290de75b49" translate="yes" xml:space="preserve">
          <source>TSystemOS.osStandalone</source>
          <target state="translated">TSystemOS.osStandalone</target>
        </trans-unit>
        <trans-unit id="0c3395ef39ac4ea1500b59f59cd08063a73bab08" translate="yes" xml:space="preserve">
          <source>TSystemOS.osVxWorks</source>
          <target state="translated">TSystemOS.osVxWorks</target>
        </trans-unit>
        <trans-unit id="f4d238b4f6b9e9640466505b29c89e6fca4fec2d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osWindows</source>
          <target state="translated">TSystemOS.osWindows</target>
        </trans-unit>
        <trans-unit id="a398d417d4982e6dc512eed7c6b59f54a754c05a" translate="yes" xml:space="preserve">
          <source>TSystemOS:</source>
          <target state="translated">TSystemOS:</target>
        </trans-unit>
        <trans-unit id="5939aea9b487dbaab0cf08324f9a9a447e0900d6" translate="yes" xml:space="preserve">
          <source>TTabIter:</source>
          <target state="translated">TTabIter:</target>
        </trans-unit>
        <trans-unit id="41a2786fc2af3e24ec0db6712d87f40503eeb20a" translate="yes" xml:space="preserve">
          <source>TType:</source>
          <target state="translated">TType:</target>
        </trans-unit>
        <trans-unit id="0179cb50ac4de959ffb192e0c7cac0b96227caa5" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taConcept</source>
          <target state="translated">TTypeAllowedFlag.taConcept</target>
        </trans-unit>
        <trans-unit id="1ab466e6e741e60ca7ec60a6466864011131025b" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taField</source>
          <target state="translated">TTypeAllowedFlag.taField</target>
        </trans-unit>
        <trans-unit id="41fc7c202eebd75be3d703e98072a7e5c8a9aa2d" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taHeap</source>
          <target state="translated">TTypeAllowedFlag.taHeap</target>
        </trans-unit>
        <trans-unit id="84923533778030da718d0e06375c33a0ac63e9e2" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsOpenArray</source>
          <target state="translated">TTypeAllowedFlag.taIsOpenArray</target>
        </trans-unit>
        <trans-unit id="b776ebbbb740385436b4bfb8d79613dfcd7bcbb0" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsTemplateOrMacro</source>
          <target state="translated">TTypeAllowedFlag.taIsTemplateOrMacro</target>
        </trans-unit>
        <trans-unit id="21016ece821aa9e90d83fb2832e84a88cacbff06" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taNoUntyped</source>
          <target state="translated">TTypeAllowedFlag.taNoUntyped</target>
        </trans-unit>
        <trans-unit id="1e6587542c7ae2cb27035918684c4c8b1e6310a4" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taProcContextIsNotMacro</source>
          <target state="translated">TTypeAllowedFlag.taProcContextIsNotMacro</target>
        </trans-unit>
        <trans-unit id="0c27a5b363ed5d06f5fcff4f8f3cd0f5b9037a56" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag:</source>
          <target state="translated">TTypeAllowedFlag:</target>
        </trans-unit>
        <trans-unit id="1c785b4d25a85f7f1bd956c98d088327a638a168" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlags:</source>
          <target state="translated">TTypeAllowedFlags:</target>
        </trans-unit>
        <trans-unit id="fc314936ddd603367171fd74694532c6adab99c5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedAsgn</source>
          <target state="translated">TTypeAttachedOp.attachedAsgn</target>
        </trans-unit>
        <trans-unit id="244a557e848e3357faa4c21471b5db088d254294" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDeepCopy</source>
          <target state="translated">TTypeAttachedOp.attachedDeepCopy</target>
        </trans-unit>
        <trans-unit id="d228ecd9ce629a0b6a2787576a6558af6f68ae3e" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDestructor</source>
          <target state="translated">TTypeAttachedOp.attachedDestructor</target>
        </trans-unit>
        <trans-unit id="f483a09d6048ebca812d1d5b4b03ae8a218b0bb1" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDispose</source>
          <target state="translated">TTypeAttachedOp.attachedDispose</target>
        </trans-unit>
        <trans-unit id="3096d633136bbc7a07581b04b5aaee8b92e9b64a" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedSink</source>
          <target state="translated">TTypeAttachedOp.attachedSink</target>
        </trans-unit>
        <trans-unit id="86d3ba82c3894d71a1b3ccc344a0436109b3a0f5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedTrace</source>
          <target state="translated">TTypeAttachedOp.attachedTrace</target>
        </trans-unit>
        <trans-unit id="11947d14da2dcca262c11f9b632e36d5279b9394" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp:</source>
          <target state="translated">TTypeAttachedOp:</target>
        </trans-unit>
        <trans-unit id="a4777dfef03acb138ec00e5f5dac24713684c810" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.AllowCommonBase</source>
          <target state="translated">TTypeCmpFlag.AllowCommonBase</target>
        </trans-unit>
        <trans-unit id="08054a53231843d58690f59314cbbb52f2cbc9e1" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactConstraints</source>
          <target state="translated">TTypeCmpFlag.ExactConstraints</target>
        </trans-unit>
        <trans-unit id="dbd1a6dd6abd1ffaf12460691d968606f8673a65" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGcSafety</source>
          <target state="translated">TTypeCmpFlag.ExactGcSafety</target>
        </trans-unit>
        <trans-unit id="9f819df93295a98eaeb321d4b6079aec8c164d85" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGenericParams</source>
          <target state="translated">TTypeCmpFlag.ExactGenericParams</target>
        </trans-unit>
        <trans-unit id="e77812cda4c0753c698e8c0498f046c40895fb34" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactTypeDescValues</source>
          <target state="translated">TTypeCmpFlag.ExactTypeDescValues</target>
        </trans-unit>
        <trans-unit id="5caaebda03569c71bc228f3143586b5714b80433" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreCC</source>
          <target state="translated">TTypeCmpFlag.IgnoreCC</target>
        </trans-unit>
        <trans-unit id="34bb7146abb78508eaa04cb5d2873ff599851422" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreTupleFields</source>
          <target state="translated">TTypeCmpFlag.IgnoreTupleFields</target>
        </trans-unit>
        <trans-unit id="bf93f85a21ebbc559f03dc5707e37933d7b14f2d" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag:</source>
          <target state="translated">TTypeCmpFlag:</target>
        </trans-unit>
        <trans-unit id="498a511c8026855650e5a2ba2b904e6d84f82234" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlags:</source>
          <target state="translated">TTypeCmpFlags:</target>
        </trans-unit>
        <trans-unit id="d0e24d269c517c1b4bc789cfecbbd836ad6fbac9" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frEmbedded</source>
          <target state="translated">TTypeFieldResult.frEmbedded</target>
        </trans-unit>
        <trans-unit id="27e394cb11693eacb4df02e2be4fb610f74ff8c5" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frHeader</source>
          <target state="translated">TTypeFieldResult.frHeader</target>
        </trans-unit>
        <trans-unit id="c880285eca6461cf26d70962d5837af33ec7cc9c" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frNone</source>
          <target state="translated">TTypeFieldResult.frNone</target>
        </trans-unit>
        <trans-unit id="f34b70cba43b23bfa6138b86b37f9d3d7361a027" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult:</source>
          <target state="translated">TTypeFieldResult:</target>
        </trans-unit>
        <trans-unit id="07dda03b526235c5508321c7c957bd5e603ef411" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfAcyclic</source>
          <target state="translated">TTypeFlag.tfAcyclic</target>
        </trans-unit>
        <trans-unit id="492bbf177977468bf98f4d90b2c9714340f015e1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfBorrowDot</source>
          <target state="translated">TTypeFlag.tfBorrowDot</target>
        </trans-unit>
        <trans-unit id="61a1d723dd629d7b07c67072f73b46bc90f0959c" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByCopy</source>
          <target state="translated">TTypeFlag.tfByCopy</target>
        </trans-unit>
        <trans-unit id="541fb2e55b81a6ab5f365397011759c9505ede38" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByRef</source>
          <target state="translated">TTypeFlag.tfByRef</target>
        </trans-unit>
        <trans-unit id="9688f0415838a906d60e24908d80b68f81241882" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCapturesEnv</source>
          <target state="translated">TTypeFlag.tfCapturesEnv</target>
        </trans-unit>
        <trans-unit id="d1b4c04a78c4c7522f83770d237e4d7dfdc924c1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCheckedForDestructor</source>
          <target state="translated">TTypeFlag.tfCheckedForDestructor</target>
        </trans-unit>
        <trans-unit id="e44aebdb77c17dcb57c1d24ad8339727bf36ae48" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCompleteStruct</source>
          <target state="translated">TTypeFlag.tfCompleteStruct</target>
        </trans-unit>
        <trans-unit id="b77dcb2df70fd10ff909ff7e2dbcff5cc591dcf3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfConceptMatchedTypeSym</source>
          <target state="translated">TTypeFlag.tfConceptMatchedTypeSym</target>
        </trans-unit>
        <trans-unit id="fefae8ad7615c4812fbb252a50d8111bf1260edb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfContravariant</source>
          <target state="translated">TTypeFlag.tfContravariant</target>
        </trans-unit>
        <trans-unit id="865ca7278467ef7c57ec318b49c36c1058995317" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCovariant</source>
          <target state="translated">TTypeFlag.tfCovariant</target>
        </trans-unit>
        <trans-unit id="7ec74d81ff75de9cfb8d82d5ab38f21444e79930" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfEnumHasHoles</source>
          <target state="translated">TTypeFlag.tfEnumHasHoles</target>
        </trans-unit>
        <trans-unit id="62891ed3c719c5f3a87e0e3b3d719a87b193e77e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicit</source>
          <target state="translated">TTypeFlag.tfExplicit</target>
        </trans-unit>
        <trans-unit id="e655c39bef25c2645747fda6be0bfd46ffb7eb95" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicitCallConv</source>
          <target state="translated">TTypeFlag.tfExplicitCallConv</target>
        </trans-unit>
        <trans-unit id="2a0a3e3e399b7653b1ce51d297d01a7567960145" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFinal</source>
          <target state="translated">TTypeFlag.tfFinal</target>
        </trans-unit>
        <trans-unit id="7efa2781c32ea8c56df82dc8fdcb82405d5e4ec3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFromGeneric</source>
          <target state="translated">TTypeFlag.tfFromGeneric</target>
        </trans-unit>
        <trans-unit id="c8218feacbb0d962dfc20c78f02f2f19249a2499" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfGenericTypeParam</source>
          <target state="translated">TTypeFlag.tfGenericTypeParam</target>
        </trans-unit>
        <trans-unit id="94b23fdc1f9be74a942541a44b48ace763b7eeba" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasAsgn</source>
          <target state="translated">TTypeFlag.tfHasAsgn</target>
        </trans-unit>
        <trans-unit id="340337f27d0ed433616603d9f2096f2fcc004030" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasGCedMem</source>
          <target state="translated">TTypeFlag.tfHasGCedMem</target>
        </trans-unit>
        <trans-unit id="1ef98b05e773391c3890de47fca15279f6381830" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasMeta</source>
          <target state="translated">TTypeFlag.tfHasMeta</target>
        </trans-unit>
        <trans-unit id="c76cb66820108662e672cda96558668868f0ee8d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasOwned</source>
          <target state="translated">TTypeFlag.tfHasOwned</target>
        </trans-unit>
        <trans-unit id="2e772657dc53ed9a1620b3a0c39627b24331dc04" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasStatic</source>
          <target state="translated">TTypeFlag.tfHasStatic</target>
        </trans-unit>
        <trans-unit id="dff62e95dca9a1dc168f15021d19e34f13feb23e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfImplicitTypeParam</source>
          <target state="translated">TTypeFlag.tfImplicitTypeParam</target>
        </trans-unit>
        <trans-unit id="4df96677e3b3240385e91807dbc9fc3358411860" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIncompleteStruct</source>
          <target state="translated">TTypeFlag.tfIncompleteStruct</target>
        </trans-unit>
        <trans-unit id="930ccf22728f33a61ab0e9df37cdee8e9fea4d7d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInferrableStatic</source>
          <target state="translated">TTypeFlag.tfInferrableStatic</target>
        </trans-unit>
        <trans-unit id="3522e964b52dcccafb9e5b9278cb94ad79dae611" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInheritable</source>
          <target state="translated">TTypeFlag.tfInheritable</target>
        </trans-unit>
        <trans-unit id="b371c0c24a850d8dea175a373e8f12f72a1bc6f9" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIterator</source>
          <target state="translated">TTypeFlag.tfIterator</target>
        </trans-unit>
        <trans-unit id="e1ca502e9e481d427baed979cec9414f52c79127" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNeedsFullInit</source>
          <target state="translated">TTypeFlag.tfNeedsFullInit</target>
        </trans-unit>
        <trans-unit id="01077f60a85e95e4495eab0f02047407c4b30ef5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNoSideEffect</source>
          <target state="translated">TTypeFlag.tfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="79d4b029bb3501a85efe8bede40509b746b3d7a5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNotNil</source>
          <target state="translated">TTypeFlag.tfNotNil</target>
        </trans-unit>
        <trans-unit id="cbd9ad039539212e281c90be72dca6bc97948623" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPacked</source>
          <target state="translated">TTypeFlag.tfPacked</target>
        </trans-unit>
        <trans-unit id="458f48a3e3ae523480285d4c0ca455dc1c932287" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPartial</source>
          <target state="translated">TTypeFlag.tfPartial</target>
        </trans-unit>
        <trans-unit id="30060e7f1dacb103767e0e3290bea2c969e2e05b" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRefsAnonObj</source>
          <target state="translated">TTypeFlag.tfRefsAnonObj</target>
        </trans-unit>
        <trans-unit id="2ce5b832b6054dca36395a8724d2b6bf08d288fd" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRequiresInit</source>
          <target state="translated">TTypeFlag.tfRequiresInit</target>
        </trans-unit>
        <trans-unit id="6cd7c314319b31e80c85e2aeaa5b6d6229861d80" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfResolved</source>
          <target state="translated">TTypeFlag.tfResolved</target>
        </trans-unit>
        <trans-unit id="57d0c1c354ebb903950e18b1ea2422f5a671ebad" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRetType</source>
          <target state="translated">TTypeFlag.tfRetType</target>
        </trans-unit>
        <trans-unit id="19da5492bd0f1c1bed7f9b0bdbb37ad9b80297f1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfShallow</source>
          <target state="translated">TTypeFlag.tfShallow</target>
        </trans-unit>
        <trans-unit id="4fbe0e2add3932e6d78c23adc9387486f4069c85" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfThread</source>
          <target state="translated">TTypeFlag.tfThread</target>
        </trans-unit>
        <trans-unit id="ab0ce2164600dc950eb2b7fb70f55a980b4758fb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfTriggersCompileTime</source>
          <target state="translated">TTypeFlag.tfTriggersCompileTime</target>
        </trans-unit>
        <trans-unit id="124971b39b855098afccb89eafe9573eb9d42cb7" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfUnresolved</source>
          <target state="translated">TTypeFlag.tfUnresolved</target>
        </trans-unit>
        <trans-unit id="1e9a1f1b732cade91b1acda56e8c05cc36b96afb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarIsPtr</source>
          <target state="translated">TTypeFlag.tfVarIsPtr</target>
        </trans-unit>
        <trans-unit id="63329715065a634decbbdfb21351e109a6523dbc" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarargs</source>
          <target state="translated">TTypeFlag.tfVarargs</target>
        </trans-unit>
        <trans-unit id="00d99459be70f9dbf6c6302eaea8bdb97e23f954" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWeakCovariant</source>
          <target state="translated">TTypeFlag.tfWeakCovariant</target>
        </trans-unit>
        <trans-unit id="b5c1f860bd9f168e67788a1c38d26ecc09dec0fa" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWildcard</source>
          <target state="translated">TTypeFlag.tfWildcard</target>
        </trans-unit>
        <trans-unit id="2adde959189d5b343f23cd353b4d37a83cace747" translate="yes" xml:space="preserve">
          <source>TTypeFlag:</source>
          <target state="translated">TTypeFlag:</target>
        </trans-unit>
        <trans-unit id="d59afbc89b03748b97eeb7784a6be209e4ec232e" translate="yes" xml:space="preserve">
          <source>TTypeFlags:</source>
          <target state="translated">TTypeFlags:</target>
        </trans-unit>
        <trans-unit id="0799b6844305ff658e62e4c61e62afea46cba75e" translate="yes" xml:space="preserve">
          <source>TTypeIter:</source>
          <target state="translated">TTypeIter:</target>
        </trans-unit>
        <trans-unit id="0e94930a34c36d8014636584ecef2e6f378c27d4" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAlias</source>
          <target state="translated">TTypeKind.tyAlias</target>
        </trans-unit>
        <trans-unit id="aaa78f2e3d082ce1fbd4438726f28035d92e095d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnd</source>
          <target state="translated">TTypeKind.tyAnd</target>
        </trans-unit>
        <trans-unit id="fd91855f9e2dcde880f924d16173113e3e1b61e1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnything</source>
          <target state="translated">TTypeKind.tyAnything</target>
        </trans-unit>
        <trans-unit id="9354bc694c58a7afeed8a1989ffdcebda8d635ba" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyArray</source>
          <target state="translated">TTypeKind.tyArray</target>
        </trans-unit>
        <trans-unit id="d683a07782061ea2f9df06f8689f622ba9454189" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBool</source>
          <target state="translated">TTypeKind.tyBool</target>
        </trans-unit>
        <trans-unit id="4c9f258391d62b12b4667b1b42b74fb340ba6b59" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBuiltInTypeClass</source>
          <target state="translated">TTypeKind.tyBuiltInTypeClass</target>
        </trans-unit>
        <trans-unit id="6e942a569bf365b7c45b78de9efe9f71ff40de3d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCString</source>
          <target state="translated">TTypeKind.tyCString</target>
        </trans-unit>
        <trans-unit id="511c95f3bf2518a4a39007d083a27a85305bedc1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyChar</source>
          <target state="translated">TTypeKind.tyChar</target>
        </trans-unit>
        <trans-unit id="7742b6ae524066429ad5352a80bda321b5285f75" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCompositeTypeClass</source>
          <target state="translated">TTypeKind.tyCompositeTypeClass</target>
        </trans-unit>
        <trans-unit id="2a784a78647c1e3e964953a212689787e672594d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyDistinct</source>
          <target state="translated">TTypeKind.tyDistinct</target>
        </trans-unit>
        <trans-unit id="18c089e63473641136815b0a6d7bf588d7d64999" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEmpty</source>
          <target state="translated">TTypeKind.tyEmpty</target>
        </trans-unit>
        <trans-unit id="2526b0c10b2351f8dbfa6da5035a8a387fa9c777" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEnum</source>
          <target state="translated">TTypeKind.tyEnum</target>
        </trans-unit>
        <trans-unit id="9fe7ce6fd6ca9fbd4f25ef3769702eb83ff469dd" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat</source>
          <target state="translated">TTypeKind.tyFloat</target>
        </trans-unit>
        <trans-unit id="a4769bad08648c768c93b8baf10d667c24671dad" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat128</source>
          <target state="translated">TTypeKind.tyFloat128</target>
        </trans-unit>
        <trans-unit id="137504e5db5f6079c3f46e17fdc68f112e26aa6f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat32</source>
          <target state="translated">TTypeKind.tyFloat32</target>
        </trans-unit>
        <trans-unit id="2320a8bfb8228efc60a98b1d16d14d4f0d1433c1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat64</source>
          <target state="translated">TTypeKind.tyFloat64</target>
        </trans-unit>
        <trans-unit id="90f5e7cf547d6b01512557903c89b0a2ad5c7032" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyForward</source>
          <target state="translated">TTypeKind.tyForward</target>
        </trans-unit>
        <trans-unit id="3b0b71a42c8eb3c1fdfda0933a8770612f7d08f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFromExpr</source>
          <target state="translated">TTypeKind.tyFromExpr</target>
        </trans-unit>
        <trans-unit id="12d126b517177624b9e02b6b96c24ae10adf45eb" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericBody</source>
          <target state="translated">TTypeKind.tyGenericBody</target>
        </trans-unit>
        <trans-unit id="de845c162ecd730c92bb80e09d4bb9053e73e573" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInst</source>
          <target state="translated">TTypeKind.tyGenericInst</target>
        </trans-unit>
        <trans-unit id="f88959f6c872ba3ea1f46dfc3561a3c5dde14c54" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInvocation</source>
          <target state="translated">TTypeKind.tyGenericInvocation</target>
        </trans-unit>
        <trans-unit id="fbb70eb257b50185f4b954462d2ba16e53967fed" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericParam</source>
          <target state="translated">TTypeKind.tyGenericParam</target>
        </trans-unit>
        <trans-unit id="853c3eecc6fcaf56b29249082e02899201195e48" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInferred</source>
          <target state="translated">TTypeKind.tyInferred</target>
        </trans-unit>
        <trans-unit id="6404738e10ebb3dcb5589e48bb5e56bb2533caaa" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt</source>
          <target state="translated">TTypeKind.tyInt</target>
        </trans-unit>
        <trans-unit id="7c8ee29852e8351d0f1d971179082ce8cd2b0024" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt16</source>
          <target state="translated">TTypeKind.tyInt16</target>
        </trans-unit>
        <trans-unit id="b5b83741acbdbefe77c61f8a51808f3d606f63cc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt32</source>
          <target state="translated">TTypeKind.tyInt32</target>
        </trans-unit>
        <trans-unit id="123cec70680ef83da6e7a9ffb0d86468a21015be" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt64</source>
          <target state="translated">TTypeKind.tyInt64</target>
        </trans-unit>
        <trans-unit id="ac89b343111dc1fff094fe7dbcf90fdc19196e9f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt8</source>
          <target state="translated">TTypeKind.tyInt8</target>
        </trans-unit>
        <trans-unit id="76f25dd9884e161024bfa5f564f1906fa8cf619f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyLent</source>
          <target state="translated">TTypeKind.tyLent</target>
        </trans-unit>
        <trans-unit id="35cb952eb790cfb8e6a4e4aab86c688b8fa7e124" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNil</source>
          <target state="translated">TTypeKind.tyNil</target>
        </trans-unit>
        <trans-unit id="71e8edc4e61c7cdf3e4997d53132d2cda61cf5fc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNone</source>
          <target state="translated">TTypeKind.tyNone</target>
        </trans-unit>
        <trans-unit id="1369f3e3f05baa699232f96db48f89e2c5242e25" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNot</source>
          <target state="translated">TTypeKind.tyNot</target>
        </trans-unit>
        <trans-unit id="9869385fdcf65fc4a99fec4a021241c955d0aa0d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyObject</source>
          <target state="translated">TTypeKind.tyObject</target>
        </trans-unit>
        <trans-unit id="76b82e94d2b94bf82bc8e9254e91d86d17d2978c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOpenArray</source>
          <target state="translated">TTypeKind.tyOpenArray</target>
        </trans-unit>
        <trans-unit id="048e0ed42c7f4744c48765cba6ff85550d9a0211" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOptDeprecated</source>
          <target state="translated">TTypeKind.tyOptDeprecated</target>
        </trans-unit>
        <trans-unit id="18dd91d976315b46cb15e86ec56c56d374119c01" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOr</source>
          <target state="translated">TTypeKind.tyOr</target>
        </trans-unit>
        <trans-unit id="cc7bb6ded55da7fb8d1720b7046d8b4bbae4787d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOrdinal</source>
          <target state="translated">TTypeKind.tyOrdinal</target>
        </trans-unit>
        <trans-unit id="cea6fcc9a7c93c39e116e6f6c1f7689425ab37da" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOwned</source>
          <target state="translated">TTypeKind.tyOwned</target>
        </trans-unit>
        <trans-unit id="be58929a3b5905e5864a5485a037acbc879065fe" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPointer</source>
          <target state="translated">TTypeKind.tyPointer</target>
        </trans-unit>
        <trans-unit id="67120b56f6d6aa69e8bc1107a81083dfa3ee051c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProc</source>
          <target state="translated">TTypeKind.tyProc</target>
        </trans-unit>
        <trans-unit id="59a5014ce6420bae5c138704ad0fd1c37bcde90a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProxy</source>
          <target state="translated">TTypeKind.tyProxy</target>
        </trans-unit>
        <trans-unit id="057a72ed748c03837581945e869c3f0ed0e92469" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPtr</source>
          <target state="translated">TTypeKind.tyPtr</target>
        </trans-unit>
        <trans-unit id="c8eed250118a7a9d611bef4dc76f8aaacce2fd38" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRange</source>
          <target state="translated">TTypeKind.tyRange</target>
        </trans-unit>
        <trans-unit id="cba8b92fdb447a4f368ae8ca4e118769c1b3efbc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRef</source>
          <target state="translated">TTypeKind.tyRef</target>
        </trans-unit>
        <trans-unit id="fa5dda72f61e0985f3c73b6f0bb85cd481daea63" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySequence</source>
          <target state="translated">TTypeKind.tySequence</target>
        </trans-unit>
        <trans-unit id="ee6ab4c13a0e2ed8b67bb350e10728fbc4cf9b33" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySet</source>
          <target state="translated">TTypeKind.tySet</target>
        </trans-unit>
        <trans-unit id="aa5a8169c7e1887deee9d36d06459624aba21871" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySink</source>
          <target state="translated">TTypeKind.tySink</target>
        </trans-unit>
        <trans-unit id="8d1466bb3d8fbc74b547dbb02f8273952a0b78af" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyStatic</source>
          <target state="translated">TTypeKind.tyStatic</target>
        </trans-unit>
        <trans-unit id="b3ef56ea678262c074740aa06af22e3a6787d993" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyString</source>
          <target state="translated">TTypeKind.tyString</target>
        </trans-unit>
        <trans-unit id="64ea2c5a8456daca800c8a3b265eba0a8ade3ce6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTuple</source>
          <target state="translated">TTypeKind.tyTuple</target>
        </trans-unit>
        <trans-unit id="88fc66a60b94046b8dcb50a75f66be0331e70f96" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTypeDesc</source>
          <target state="translated">TTypeKind.tyTypeDesc</target>
        </trans-unit>
        <trans-unit id="142da8d1e146731ca1c66fd3bcd95bba93b8fe3c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTyped</source>
          <target state="translated">TTypeKind.tyTyped</target>
        </trans-unit>
        <trans-unit id="1658fe5326db5a52a5764addf749b1e6161f0ce9" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt</source>
          <target state="translated">TTypeKind.tyUInt</target>
        </trans-unit>
        <trans-unit id="48317f7c389eeb326c561089ca5e8724017fa883" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt16</source>
          <target state="translated">TTypeKind.tyUInt16</target>
        </trans-unit>
        <trans-unit id="6238df6a06ed2f153d500aba172e98e52f860f9b" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt32</source>
          <target state="translated">TTypeKind.tyUInt32</target>
        </trans-unit>
        <trans-unit id="54b6ec0922deab6616588f895ec17ad140779038" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt64</source>
          <target state="translated">TTypeKind.tyUInt64</target>
        </trans-unit>
        <trans-unit id="a60a984a93b313cce3325fc55efa6c80fb9d3af7" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt8</source>
          <target state="translated">TTypeKind.tyUInt8</target>
        </trans-unit>
        <trans-unit id="4d387420fd3b923de5af82186671f01ffdda3b42" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUncheckedArray</source>
          <target state="translated">TTypeKind.tyUncheckedArray</target>
        </trans-unit>
        <trans-unit id="5fea571764be8dd44ae507fe59dfe65eb19a23f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUntyped</source>
          <target state="translated">TTypeKind.tyUntyped</target>
        </trans-unit>
        <trans-unit id="2f7a5d57c0ae3f1e3072ce48e36c4dfa73af6c2d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClass</source>
          <target state="translated">TTypeKind.tyUserTypeClass</target>
        </trans-unit>
        <trans-unit id="24264e5e4579a6ec06665830d8241dd5aa692ba3" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClassInst</source>
          <target state="translated">TTypeKind.tyUserTypeClassInst</target>
        </trans-unit>
        <trans-unit id="9c04403a1098db54c18beaf124b6e51bee5f7895" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVar</source>
          <target state="translated">TTypeKind.tyVar</target>
        </trans-unit>
        <trans-unit id="866cab95392f4667de7ddae8e874f6986631628a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVarargs</source>
          <target state="translated">TTypeKind.tyVarargs</target>
        </trans-unit>
        <trans-unit id="0b2d9d9a212dcc3a4f3dad5f1e7b0175893b324c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVoid</source>
          <target state="translated">TTypeKind.tyVoid</target>
        </trans-unit>
        <trans-unit id="3134e079fd35c63fb7e622ec1abdb7e40e287014" translate="yes" xml:space="preserve">
          <source>TTypeKind:</source>
          <target state="translated">TTypeKind:</target>
        </trans-unit>
        <trans-unit id="a8c405dd55f6718f5c54eeffd414bca9bafc966d" translate="yes" xml:space="preserve">
          <source>TTypeKinds:</source>
          <target state="translated">TTypeKinds:</target>
        </trans-unit>
        <trans-unit id="ae0ffc4a19658ae080fa434ffc876212d8e0d92d" translate="yes" xml:space="preserve">
          <source>TTypeMutator:</source>
          <target state="translated">TTypeMutator:</target>
        </trans-unit>
        <trans-unit id="05748a9a1a8c6a023693c76bab719c68ef5b92fd" translate="yes" xml:space="preserve">
          <source>TTypePredicate:</source>
          <target state="translated">TTypePredicate:</target>
        </trans-unit>
        <trans-unit id="c5566ac9e2bab44c01dcf254d6aee02e6b31a08b" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trBindGenericParam</source>
          <target state="translated">TTypeRelFlag.trBindGenericParam</target>
        </trans-unit>
        <trans-unit id="3e622cd2fec1785d21b7f65f5c359ac7937ffca0" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trDontBind</source>
          <target state="translated">TTypeRelFlag.trDontBind</target>
        </trans-unit>
        <trans-unit id="78c4a7d831ae9cc483125be7ce07c572063bbc4f" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trNoCovariance</source>
          <target state="translated">TTypeRelFlag.trNoCovariance</target>
        </trans-unit>
        <trans-unit id="af4b6bd841aa6a165e0d34d467927854db0bdc8a" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag:</source>
          <target state="translated">TTypeRelFlag:</target>
        </trans-unit>
        <trans-unit id="e94014289638374be4190459e1bb501dfbfe41b3" translate="yes" xml:space="preserve">
          <source>TTypeRelFlags:</source>
          <target state="translated">TTypeRelFlags:</target>
        </trans-unit>
        <trans-unit id="68cb51af66e4090ea344468d781203193c332184" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isBothMetaConvertible</source>
          <target state="translated">TTypeRelation.isBothMetaConvertible</target>
        </trans-unit>
        <trans-unit id="a2e80fd4cc56e47b80e688c235bbc805b6e28b7f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isConvertible</source>
          <target state="translated">TTypeRelation.isConvertible</target>
        </trans-unit>
        <trans-unit id="54f04f59123456c3c8647d13c32aa81bb0bc0b52" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isEqual</source>
          <target state="translated">TTypeRelation.isEqual</target>
        </trans-unit>
        <trans-unit id="76aabe09fdc4d3bcdca6dfca911f86ac68529f00" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isFromIntLit</source>
          <target state="translated">TTypeRelation.isFromIntLit</target>
        </trans-unit>
        <trans-unit id="082a825a1a1a2a4f69e162637c5a47f9d4400e34" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isGeneric</source>
          <target state="translated">TTypeRelation.isGeneric</target>
        </trans-unit>
        <trans-unit id="72c719a9fea45aac02dd7bcd06d7c7ed7f91da1d" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferred</source>
          <target state="translated">TTypeRelation.isInferred</target>
        </trans-unit>
        <trans-unit id="662bc4c4df86dd8e5b1049fa1d4acfbe0e2d8265" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferredConvertible</source>
          <target state="translated">TTypeRelation.isInferredConvertible</target>
        </trans-unit>
        <trans-unit id="8a647b6c47b21eace0c04cd901e76cde68ae44ee" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isIntConv</source>
          <target state="translated">TTypeRelation.isIntConv</target>
        </trans-unit>
        <trans-unit id="4077456390389013fe90dba0c8bf8db83eb1972c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isNone</source>
          <target state="translated">TTypeRelation.isNone</target>
        </trans-unit>
        <trans-unit id="4b202228dda6caf9d917364e5054857c13bc8b7c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubrange</source>
          <target state="translated">TTypeRelation.isSubrange</target>
        </trans-unit>
        <trans-unit id="22c70d23f666f85e7e90ddf5522d7832f8ee4f8f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubtype</source>
          <target state="translated">TTypeRelation.isSubtype</target>
        </trans-unit>
        <trans-unit id="d3d3096e711373571f5b9192698fbb731341abb9" translate="yes" xml:space="preserve">
          <source>TTypeRelation:</source>
          <target state="translated">TTypeRelation:</target>
        </trans-unit>
        <trans-unit id="bef60ed135f7ec02d27299402bbea768a713fd96" translate="yes" xml:space="preserve">
          <source>TTypeSeq:</source>
          <target state="translated">TTypeSeq:</target>
        </trans-unit>
        <trans-unit id="0424f6e7026fa4bc2c4a7043083417315113c79b" translate="yes" xml:space="preserve">
          <source>Table</source>
          <target state="translated">Table</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated">테이블 생성자</target>
        </trans-unit>
        <trans-unit id="e587514d976f1576a7f186c3a6d78f175315a9f6" translate="yes" xml:space="preserve">
          <source>Tabulator:</source>
          <target state="translated">Tabulator:</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated">태그 추적</target>
        </trans-unit>
        <trans-unit id="479ac325890826d9bc3274ae4b0deca389100a15" translate="yes" xml:space="preserve">
          <source>TagsExt:</source>
          <target state="translated">TagsExt:</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated">오염 모드</target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated">유형을 &lt;code&gt;proc&lt;/code&gt; 로 선언 할 때는 특히주의하십시오 . 이 동작은 아래의 &lt;code&gt;Procedure declaration&lt;/code&gt; 과 비슷 하지만 &lt;code&gt;nnkGenericParams&lt;/code&gt; 를 처리하지 않습니다 . 일반 매개 변수는 &lt;code&gt;proc&lt;/code&gt; 자체가 아닌 유형으로 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="d3177dcd252a829ea158763962a47c4a3515c7ff" translate="yes" xml:space="preserve">
          <source>Take the address of a memory location</source>
          <target state="translated">메모리 위치의 주소 가져 오기</target>
        </trans-unit>
        <trans-unit id="d09ca39d193d2434090092284c392d73e10f5bf2" translate="yes" xml:space="preserve">
          <source>Take the element at the reversed index &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">반전 된 인덱스 &lt;code&gt;x&lt;/code&gt; 에 있는 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">소요 &lt;code&gt;typedesc&lt;/code&gt; 의 첫 번째 인수로, 그리고 형의 표현의 일련의 &lt;code&gt;key: value&lt;/code&gt; , 각 필드에 지정된 유형의 값을 반환 &lt;code&gt;key&lt;/code&gt; 에 설정 &lt;code&gt;value&lt;/code&gt; 의 인수에 지정된대로 &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">유닉스 시대 이후의 시간 (초)을 포함하는 부동 소수점을 가져 와서 시간 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">유닉스 시대 이후의 초 수를 포함하는 int를 취하여 시간 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">정수를 취하고 &quot;hello world!&quot;를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c9d3b8db138f77125cd16835e385cbe69f4a0651" translate="yes" xml:space="preserve">
          <source>Takes any Nim variable and returns its string representation.</source>
          <target state="translated">Nim 변수를 가져 와서 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">여러 시퀀스의 항목을 가져 와서 새로운 시퀀스로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d0f497b886e1c9d3d4474b4148e5709da878636" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</source>
          <target state="translated">여러 시퀀스의 항목을 가져 와서 새 시퀀스 안에 반환합니다. 모든 시퀀스는 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">프로 시저 이름을 가져 와서 첫 번째 인수가없는 람다로 래핑합니다. &lt;code&gt;this&lt;/code&gt; 인수는 내장 된 JavaScript 를 프로 시저의 첫 번째 인수로 전달합니다. 결과 람다를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="652ac2cbbafccc62d55637f20bfa949ef565ffbd" translate="yes" xml:space="preserve">
          <source>Target:</source>
          <target state="translated">Target:</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="355e12f6e10b7be272268c5408e0e1f1879ead8f" translate="yes" xml:space="preserve">
          <source>Template based implementation of singly and doubly linked lists. The involved types should have 'prev' or 'next' fields and the list header should have 'head' or 'tail' fields.</source>
          <target state="translated">단일 및 이중 연결 목록의 템플릿 기반 구현. 관련 유형에는 'prev'또는 'next'필드가 있어야하며 목록 헤더에는 'head'또는 'tail'필드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated">템플릿 선언</target>
        </trans-unit>
        <trans-unit id="29776c1f962d7f1926246264b64cf2699a605475" translate="yes" xml:space="preserve">
          <source>Template evaluation engine. Now hygienic.</source>
          <target state="translated">템플릿 평가 엔진. 이제 위생적입니다.</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">왼쪽에서 오른쪽으로 시퀀스를 접어 누적을 반환하는 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">시퀀스를 오른쪽에서 왼쪽으로 접어 누적을 반환하는 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="59878defe4e964ab557114291111d6b850a911e6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;code&gt;useStdoutAsStdmsg&lt;/code&gt; compile-time switch.</source>
          <target state="translated">&lt;code&gt;useStdoutAsStdmsg&lt;/code&gt; 컴파일 타임 스위치 에 따라 stdout 또는 stderr로 확장되는 템플릿입니다 .</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">&lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; 컴파일 타임 스위치 에 따라 stdout 또는 stderr로 확장되는 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">매크로와 마찬가지로 템플릿은 프로세스 및 반복기와 비교할 때 AST가 약간 확장되었습니다. 그 이유는 [term-rewriting macros] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; 입니다. 통지 &lt;code&gt;nnkEmpty()&lt;/code&gt; 의 두 번째 인수로 &lt;code&gt;nnkProcDef&lt;/code&gt; 및 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 위를? 그것은 용어 재 작성 매크로가가는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="f36defcdec2c7464ebb1521bbe1cf9a515e6bfe9" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](manual.html#term-rewriting-macros). Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">템플릿 (및 매크로 포함)에는 procs 및 iterator와 비교할 때 약간 확장 된 AST가 있습니다. 그 이유는 [term-rewriting macros] (manual.html # term-rewriting-macros) 때문입니다. 통지 &lt;code&gt;nnkEmpty()&lt;/code&gt; 의 두 번째 인수로 &lt;code&gt;nnkProcDef&lt;/code&gt; 및 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 위를? 여기서 용어 재 작성 매크로가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated">템플릿은 Nim의 추상 구문 트리에서 작동하는 간단한 대체 메커니즘입니다. 템플릿은 컴파일러의 시맨틱 패스에서 처리됩니다. 이들은 나머지 언어와 잘 통합되며 C의 전 처리기 매크로 결함을 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">템플릿은 특히 게으른 평가 목적에 유용합니다. 로깅을위한 간단한 proc을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readLine&lt;/code&gt; 을 위한 임시 저장소</target>
        </trans-unit>
        <trans-unit id="436d3b3abfa26ce88c28da41a780d32ff7044d09" translate="yes" xml:space="preserve">
          <source>Ten:</source>
          <target state="translated">Ten:</target>
        </trans-unit>
        <trans-unit id="12becf9bfcde13ef359cbd10e21ac3558b60cd6c" translate="yes" xml:space="preserve">
          <source>Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.</source>
          <target state="translated">용어 다시 쓰기 매크로는 최대 제한까지 반복적으로 적용됩니다. 즉, 용어 다시 쓰기 매크로의 결과가 다른 다시 쓰기에 적합한 경우 컴파일러는 더 이상 최적화를 적용 할 수 없을 때까지이를 수행하는 등의 작업을 시도합니다. 컴파일러를 무한 루프에 넣는 것을 방지하기 위해 단일 용어 다시 쓰기 매크로를 적용 할 수있는 횟수에 대한 엄격한 제한이 있습니다. 이 제한이 지나면 용어 다시 쓰기 매크로는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">용어 재 작성 매크로</target>
        </trans-unit>
        <trans-unit id="4139a7e773cb83cc6ffda3dc77a553344908c967" translate="yes" xml:space="preserve">
          <source>Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, e.g. when rewriting term to same term plus extra content.</source>
          <target state="translated">용어 재 작성 매크로와 템플릿은 현재 탐욕스럽고 일치하는 한 재 작성됩니다. 예를 들어 용어를 같은 용어와 추가 내용으로 다시 쓸 때와 같이 일부 다시 쓰기가 한 번만 발생하도록 할 수있는 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">용어 다시 쓰기 매크로는 &lt;em&gt;이름&lt;/em&gt; 뿐만 아니라 컴파일러의 의미 검사 단계 이후에 검색 되는 &lt;em&gt;패턴&lt;/em&gt; 을 가진 매크로 또는 템플릿입니다 . 이는 사용자 정의 최적화를 통해 컴파일 파이프 라인을 쉽게 향상시킬 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated">터미널 기호</target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 기호 : &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">문법 터미널 심볼 : &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated">비동기 http 서버 인스턴스를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">서버에 대한 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">테스트 케이스 파일 형식</target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">블록 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">문자 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated">디렉토리를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">메시지 큐를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">파이프 또는 FIFO 특수 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">일반 파일을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated">세마포어를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">공유 메모리 객체를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated">소켓을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">심볼릭 링크를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="4605d91385c3aaf247a50562a412cef1a6a892ab" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;body&lt;/code&gt; raises an exception found in the passed &lt;code&gt;exceptions&lt;/code&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt; 이 전달 된 &lt;code&gt;exceptions&lt;/code&gt; 에서 발견 된 예외를 발생시키는 지 테스트합니다 . 발생한 예외가 허용 가능한 예외의 일부이면 테스트가 통과됩니다. 그렇지 않으면 실패합니다. 예:</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">전달 된 &lt;em&gt;예외&lt;/em&gt; 에서 &lt;em&gt;body&lt;/em&gt; 가 예외를 발견 했는지 테스트합니다 . 발생한 예외가 허용 가능한 예외의 일부이면 테스트에 통과합니다. 그렇지 않으면 실패합니다. 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">형식화 된 메모리 개체에 대한 테스트 매크로</target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">테스트 스위트</target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Linux, Windows, OSX와 같은 OS에서 테스트</target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">테스트는 내포 될 수 있지만 내포 된 테스트 실패는 상위 테스트를 실패한 것으로 표시하지 않습니다. 설정 및 해제가 상속됩니다. 로컬로 설정을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">일치하는 테스트 &lt;strong&gt;어떤&lt;/strong&gt; 인수가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">DOM 구현이 특정 기능을 구현하고 해당 기능이이 노드에서 지원되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="1e818cf07cf8e76c8618215a67e1d6f19768f1e0" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Amd64에서 GCC를 사용한 테스트는 '환경'포인터가 첫 번째 인수가 아닌 마지막 인수로 전달되는 것이 정말 유익하다는 것을 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Amd64에서 GCC를 사용한 테스트에서 '환경'포인터가 첫 번째 인수가 아닌 마지막 인수로 전달되면 실제로 이점이 있음을 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="eddf3fb8e9d38e4f4520f01f09a65dc746e3f5e3" translate="yes" xml:space="preserve">
          <source>TexExt:</source>
          <target state="translated">TexExt:</target>
        </trans-unit>
        <trans-unit id="e8cdc19c721145f3b16f493ae9be16412d223832" translate="yes" xml:space="preserve">
          <source>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with &lt;code&gt;-d:futureLogging&lt;/code&gt; and use the &lt;code&gt;getFuturesInProgress&lt;/code&gt; procedure to get the list of pending futures together with the stack traces to the moment of their creation.</source>
          <target state="translated">고맙게도 보류중인 각 미래의 수를 추적하는 메커니즘이 있습니다. 활성화하려면 &lt;code&gt;-d:futureLogging&lt;/code&gt; 으로 컴파일 하고 &lt;code&gt;getFuturesInProgress&lt;/code&gt; 프로 시저를 사용하여 스택 추적과 함께 생성 순간까지 보류중인 Future 목록을 가져 오면 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">조건부 구문 &lt;code&gt;$[0|1|2|else]&lt;/code&gt; 덕분 에 형식 문자열 리터럴의 &lt;span id=&quot;internationalization_1&quot;&gt;국제화&lt;/span&gt; 를 상당히 잘 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">즉, 첫 글자 만 대소 문자 구분 방식으로 비교됩니다. 다른 문자는 ASCII 범위 내에서 대소 문자를 구분하지 않고 비교되며 밑줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a28d5e34c7b2663c0713d2b4afa31d2e7083c425" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case-sensitive manner. Other letters are compared case-insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">즉, 첫 글자 만 대소 문자를 구분하여 비교됩니다. 다른 문자는 ASCII 범위 내에서 대소 문자를 구분하지 않고 비교되며 밑줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">즉, 소문자로 변환하고 '_'를 제거하는 것을 의미합니다. Nim 식별자 이름을 정규화하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3e6b575176e4e0021d4817389fa98f764c8fefe3" translate="yes" xml:space="preserve">
          <source>That means to convert to lower case and remove any '_' on all characters except first one.</source>
          <target state="translated">즉, 소문자로 변환하고 첫 번째 문자를 제외한 모든 문자에서 '_'를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5ff708ff6bc18720eda543fbf97c4bd701261199" translate="yes" xml:space="preserve">
          <source>That these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">여기에있는 이러한 필드를 직접 사용해서는 안됩니다. ㅇㅇ ㄴㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 스트림 구현이이를 대체 할 수 있도록 액세스 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">&quot;``&quot;표기법을 사용하여 다른 절차와 마찬가지로 연산자를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2ef68a81ed2af2d4d7e3322bfe17eca009c9a5" translate="yes" xml:space="preserve">
          <source>The &quot;compiler&quot; directory contains compiler sources and should not be part of the compiler binary package</source>
          <target state="translated">&quot;컴파일러&quot;디렉토리는 컴파일러 소스를 포함하며 컴파일러 바이너리 패키지의 일부가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">&quot;hello world&quot;프로그램에는 컴파일러에 이미 알려진 몇 가지 식별자 ( &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; 등) 가 포함되어 있습니다 . 이러한 내장 기능은 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈 에서 선언되며 다른 모듈에서 내재적으로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">템플릿의 &quot;유형&quot;은 &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 기호 일 수 있습니다 . 이들은 &quot;메타 유형&quot;이며 특정 상황에서만 사용할 수 있습니다. 일반 유형도 사용할 수 있습니다. 이는 &lt;code&gt;typed&lt;/code&gt; 표현식이 예상 됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="58575d0da306b056823523ef29ad9acd2044c039" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;typedesc&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated">템플릿의 &quot;유형&quot;은 &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; 또는 &lt;code&gt;typedesc&lt;/code&gt; 기호 일 수 있습니다 . 이들은 &quot;메타 유형&quot;이며 특정 컨텍스트에서만 사용할 수 있습니다. 일반 유형도 사용할 수 있습니다. 이것은 &lt;code&gt;typed&lt;/code&gt; 표현식이 예상 된다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">'정밀도'는 부동 소수점 변환에서 소수점 뒤에 표시되어야하는 자릿수를 나타내는 10 진수입니다. 숫자가 아닌 유형의 경우이 필드는 최대 필드 크기, 즉 필드 내용에서 사용될 문자 수를 나타냅니다. 정수 변환의 경우 정밀도는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">'return'문은 제어 흐름 속성이 필요할 때 이상적으로 사용해야합니다. 가능할 때마다 프로 시저의 내재적 'result'변수를 사용하십시오. 가독성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">'sign'옵션은 숫자 유형에만 유효하며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">프로그램을 빌드하는 데 사용 된 아키텍처에서 부동 소수점 유형을 나타내는 데 사용되는 기수의 값 (정수)입니다.</target>
        </trans-unit>
        <trans-unit id="ff8eeedfc1309560a0b81603400e43bdfaaa92e0" translate="yes" xml:space="preserve">
          <source>The .cursor annotation</source>
          <target state="translated">.cursor 주석</target>
        </trans-unit>
        <trans-unit id="4cb52f076b6836abd5a2c61714693f2d361382a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;format variables&lt;/a&gt; present within &lt;code&gt;frmt&lt;/code&gt; will be replaced with the corresponding values before being prepended to &lt;code&gt;args&lt;/code&gt; and returned.</source>
          <target state="translated">&lt;code&gt;frmt&lt;/code&gt; 내에 존재 하는 &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;형식 변수&lt;/a&gt; 는 &lt;code&gt;args&lt;/code&gt; 앞에 추가되어 반환 되기 전에 해당 값으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="04f1e3b636e0e7248dc7db8e6a0a959c7c1db3d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt iterator&lt;/a&gt;, which is provided for convenience, can be used to iterate through all command line options as well.</source>
          <target state="translated">&lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt는 반복자&lt;/a&gt; 의 편의를 위해 제공되고,뿐만 아니라 모든 명령 행 옵션을 반복하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">이 페이지 의 &lt;a href=&quot;#nimble&quot;&gt;하단&lt;/a&gt; 에는 Nim 커뮤니티에서 만든 타사 패키지 목록이 포함되어 있습니다. 이 패키지는 표준 라이브러리의 모듈에 유용한 추가 기능입니다.</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">&lt;a href=&quot;nimc&quot;&gt;님 컴파일러 사용 설명서의&lt;/a&gt; 사용하여 문서 전형적인 컴파일러 호출, &lt;code&gt;compile&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 변환 명령을 &lt;code&gt;.nim&lt;/code&gt; 하나 개 이상에 파일을 &lt;code&gt;.c&lt;/code&gt; 인 다음 정적 바이너리로 플랫폼의 C 컴파일러로 컴파일 된 파일. 그러나 C ++, Objective-C 또는 JavaScript로 컴파일하는 다른 명령이 있습니다. 이 문서는 모든 백엔드 및 인터페이스 옵션을 한곳에 집중하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8d531a309bd956c39bd6508c1a41b8169d1ae032" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">&lt;a href=&quot;nimc&quot;&gt;님 컴파일러 사용 설명서의&lt;/a&gt; 사용하여 문서 전형적인 컴파일러 호출, &lt;code&gt;compile&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 변환 명령을 &lt;code&gt;.nim&lt;/code&gt; 하나 개 이상에 파일을 &lt;code&gt;.c&lt;/code&gt; 인 다음 정적 바이너리로 플랫폼의 C 컴파일러로 컴파일 된 파일. 그러나 C ++, Objective-C 또는 JavaScript로 컴파일하는 다른 명령이 있습니다. 이 문서는 모든 백엔드 및 인터페이스 옵션을 한곳에 집중하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b33326c6e57348f7442036bfc7267b110b7072b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; 명령 줄 스위치 대신 정적으로 링크 뭔가 필요하면 연결 동적를 방지 할 수 있습니다. 소스 파일을 정적으로 링크하도록 설계된 Nim 래퍼 는 소스가 거의 없거나 시스템 라이브러리를 사용하는 것보다 Nim 코드와 함께 제공하는 것이 더 쉬운 경우 &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt;컴파일 pragma를&lt;/a&gt; 사용할 수 있습니다 . 호스트 시스템에 설치된 라이브러리는 &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt; 와 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; 명령 줄 스위치 대신 정적으로 링크 뭔가 필요하면 연결 동적를 방지 할 수 있습니다. 소스 파일을 정적으로 링크하도록 설계된 Nim 래퍼 는 소스가 적거나 시스템 라이브러리를 사용하는 것보다 Nim 코드를 따라 제공하는 것이 더 쉬운 경우 &lt;a href=&quot;nimc#compile-pragma&quot;&gt;컴파일 프라그 마를&lt;/a&gt; 사용할 수 있습니다 . 호스트 시스템에 설치된 라이브러리는 &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt; 와 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">&lt;a href=&quot;system#inc&quot;&gt;INC는&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;십이&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;SUCC&lt;/a&gt; 및 &lt;a href=&quot;system#pred&quot;&gt;PRED&lt;/a&gt; 동작은 상승하여 실패 할 수 &lt;em&gt;EOutOfRange&lt;/em&gt; 또는 &lt;em&gt;EOVERFLOW&lt;/em&gt; 예외. (적절한 런타임 검사를 설정 한 상태에서 코드를 컴파일 한 경우)</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; 의 운영자는 사실 템플릿에 있습니다</target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated">는 &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt; 의 운영자는 사실 템플릿에있는이는 이점이 당신이 과부하 경우 그 &lt;code&gt;==&lt;/code&gt; 연산자는 &lt;code&gt;!=&lt;/code&gt; 연산자가 자동으로 사용할 수 있고 옳은 일을한다. (IEEE 부동 소수점 수를 제외하고-NaN은 기본 부울 논리를 중단합니다.)</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; 와 &lt;code&gt;#dynlib&lt;/code&gt; 의 지시는 상호 배타적입니다. &lt;code&gt;dynlib&lt;/code&gt; 를 사용하는 바인딩 은 &lt;code&gt;header&lt;/code&gt; 를 사용하는 바인딩 보다 훨씬 선호됩니다 ! Nim 컴파일러는 C 코드를 생성하지 않는 백엔드에서는 작동하지 않으므로 향후 &lt;code&gt;header&lt;/code&gt; pragma에 대한 지원을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt; 지시어는 C 함수 프로토 타입과와 모든 수출 변수를 입력으로 인한 모든 시저에 주석을해야 c2nim을 알려줍니다 &lt;code&gt;header&lt;/code&gt; 프라그를 :</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">&lt;code&gt;#skipcomments&lt;/code&gt; 의 지시어는 c2nim는 의견을 무시하고 생성 님 파일로 복사 할 수 있도록 C 코드에 투입 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">&lt;code&gt;#typeprefixes&lt;/code&gt; 의 지시어는 c2nim가 생성 만들기 위해 C 코드로 넣을 수 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;P&lt;/code&gt; 정의 된 모든 유형에 대한 접두사.</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 운영자는 그 이름에 어떤 열거 값을 변환 할 수 있습니다, 그리고 &lt;code&gt;ord&lt;/code&gt; PROC는 기본 정수 값으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c3c3a1c938decb53d03460e20948578c7b0a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for count tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 카운트 테이블에 대한 연산자. 테이블에서 &lt;code&gt;echo&lt;/code&gt; 를 호출 할 때 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec3f7201a0436a6523f0d28e1c7472c08aaccda5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">해시 테이블 의 &lt;code&gt;$&lt;/code&gt; 연산자. 테이블에서 &lt;code&gt;echo&lt;/code&gt; 를 호출 할 때 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="592ba1cbd0b60e530272f88b56bd19674725e88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for int sets.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 INT 세트의 운영자입니다.</target>
        </trans-unit>
        <trans-unit id="f0b4969c881c889a18fdc86d07e053ec65d62580" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for ordered hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 주문 해시 테이블에 대한 연산자. 테이블에서 &lt;code&gt;echo&lt;/code&gt; 를 호출 할 때 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="87980ae4827ecb34a1ff7d3485ef0b12328b955c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for string tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; 의 문자열 테이블에 대한 연산자. 테이블에서 &lt;code&gt;echo&lt;/code&gt; 를 호출 할 때 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d2254ec838e1c34b6ee8c8791b0a6e0a4aeca15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator for string tables.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 의 문자열 테이블에 대한 연산자.</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated">는 &lt;code&gt;**&lt;/code&gt; 많이 같다 &lt;code&gt;*&lt;/code&gt; 그뿐만 아니라 모든 인수를 수집하지만 것을 제외하고, 운영자도 역 폴란드어 표기법으로 일치 운영자 :</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 연산자 수 &lt;em&gt;평탄화&lt;/em&gt; 등 중첩 진 식 &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; 에 &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7325bb59d54b70872d714ee28dd75a93b55b1c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 일반적으로 따르는 모든 토큰이 인수 것을 나타 내기 위해 사용되는 옵션은, 긴 옵션으로 해석되고, 그 이름은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; idetools 스위치는 제안 전환에 매우 유사하지만, 대신에 사용자가 점 문자를 입력 한 후 사용되는,이 하나는 사용자가 입력 매개 변수를 시작하기 위해 여는 중괄호를 입력 한 후 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;--def&lt;/code&gt; idetools는 특정 기호의 정의에 대해 수행에게 질의를 전환 할 수 있습니다. 가능한 경우, idetools는 유형, 소스 파일, 행 / 열 정보 및 기타 문서 데이터 (문서 문자열과 같은 경우)로 응답합니다. 이 정보를 통해 IDE는 사용자가 커서를 심볼 위에 놓거나 마우스를 사용하여 심볼을 선택하고 심볼이있는 위치로 리디렉션 되는 일반적인 &lt;em&gt;점프 정의를&lt;/em&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c77fdad272c7f83697c8335c9696141ee28e928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt;컴파일러 스위치를&lt;/a&gt; 변경하는 데 사용할 수 있습니다 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;컴파일러 스위치를&lt;/a&gt; 변경하는 데 사용할 수 있습니다 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="146fd580f174db8b693f082a350984eb09df126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--opt:size&lt;/code&gt; flag instructs Nim to optimize code generation for small size (with the help of the C compiler), the &lt;code&gt;flto&lt;/code&gt; flags enable link-time optimization in the compiler and linker.</source>
          <target state="translated">&lt;code&gt;--opt:size&lt;/code&gt; 플래그가 최적화 코드 생성 작은 크기 (C 컴파일러의 도움으로)에 님 지시는 &lt;code&gt;flto&lt;/code&gt; 의 플래그는 컴파일러 및 링커에 링크 - 타임 최적화를 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="1fec47225002df51e5d78ab7e3be5b902b13708f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--os:any&lt;/code&gt; target makes sure Nim does not depend on any specific operating system primitives. Your platform should support only some basic ANSI C library &lt;code&gt;stdlib&lt;/code&gt; and &lt;code&gt;stdio&lt;/code&gt; functions which should be available on almost any platform.</source>
          <target state="translated">&lt;code&gt;--os:any&lt;/code&gt; 대상이 있는지 님하게는 특정 운영 체제의 기본 요소에 의존하지 않습니다. 플랫폼은 거의 모든 플랫폼에서 사용할 수있는 일부 기본 ANSI C 라이브러리 &lt;code&gt;stdlib&lt;/code&gt; 및 &lt;code&gt;stdio&lt;/code&gt; 함수 만 지원 해야합니다.</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">&lt;code&gt;--suggest&lt;/code&gt; idetools 파일의 어느 시점에서 수행을 가능 완료 기호에 대한 질의를 전환 할 수 있습니다. IDE는 IDE가 현재 파일 (및 편집중인 언어에 대해 알고 있고 포함 / 가져 오기를 따르는 경우 관련 파일)을 스캔하고 사용자가 무언가를 입력하기 시작할 때 다른 옵션을 가진 완료 상자가 나타나는 자동 완성 기능을 쉽게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">&lt;code&gt;--usages&lt;/code&gt; 의 idetools은 위치에 나열 심볼의 모든 용도를 전환 할 수 있습니다. IDE는이를 사용하여 파일에서 기호가 사용 된 모든 위치를 찾고 동시에 모든 위치에서 이름을 바꿀 수 있습니다. 다시 말하지만 순수한 문자열 기반 검색 및 바꾸기는 함수 / 루프 범위에서 심볼을 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e88f9afb7898deea226f46d03930aa92460478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d:useMalloc&lt;/code&gt; option configures Nim to use only the standard C memory manage primitives &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt;, &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-d:useMalloc&lt;/code&gt; 의 옵션을 구성합니다 님은 관리 만 표준 C 메모리를 사용하는 프리미티브 &lt;code&gt;malloc()&lt;/code&gt; , &lt;code&gt;free()&lt;/code&gt; , &lt;code&gt;realloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; (튜플 / 객체 필드 연산자에 액세스) 및 &lt;code&gt;[]&lt;/code&gt; (배열 / 문자열 / 시퀀스 인덱스 연산자) 연산자는 참조 유형에 대해 암시 적 역 참조 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d69f7e7cab8a172b5bea310651ee4c1dc8772c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">개수 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 두 테이블에 개수가 같은 동일한 키가 포함 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3b687c86ec2ab86619a184b73c9bb7473dd71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">개수 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 반환 &lt;code&gt;true&lt;/code&gt; 중 두 테이블이있는 경우 &lt;code&gt;nil&lt;/code&gt; , 또는 둘 다 없다 &lt;code&gt;nil&lt;/code&gt; 와 모두 동일한 개수와 동일한 키가 포함되어 있습니다. 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f56b80171a975839d82b828a2290c7051d9d6a18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 반환 &lt;code&gt;true&lt;/code&gt; 중 두 테이블이있는 경우 &lt;code&gt;nil&lt;/code&gt; , 또는하지 둘 &lt;code&gt;nil&lt;/code&gt; 와 두 테이블의 내용이 동일한 키 - 값 쌍을 포함하고 있습니다. 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6340fe457b063ff32ecbbcad36851c6c0ef42d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 두 테이블의 콘텐츠에 동일한 키-값 쌍이 포함 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea4893cd5a1f2f96e22540b712be98b5f5c896cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns &lt;code&gt;true&lt;/code&gt; if both the content and the order are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 내용과 순서가 모두 같으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="097201b62a35fb9d118671fbad0be2c8082835fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns true if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;code&gt;==&lt;/code&gt; 연산자. 사실 반환 중 두 테이블이있는 경우 &lt;code&gt;nil&lt;/code&gt; , 또는하지 둘 &lt;code&gt;nil&lt;/code&gt; 와 콘텐츠 모두의 순서가 동일하다.</target>
        </trans-unit>
        <trans-unit id="40f0325065de9343e95b504b2a34a35889dcc865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=copy&lt;/code&gt; proc can be marked with the &lt;code&gt;{.error.}&lt;/code&gt; pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time. This looks like:</source>
          <target state="translated">&lt;code&gt;=copy&lt;/code&gt; 시저가 표시 될 수있다 &lt;code&gt;{.error.}&lt;/code&gt; 프라그. 그런 다음 그렇지 않으면 복사로 이어지는 할당이 컴파일 타임에 금지됩니다. 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">&lt;code&gt;C2NIM&lt;/code&gt; 의 기호 만 인식되고 &lt;code&gt;#ifdef&lt;/code&gt; 와 와 &lt;code&gt;#ifndef&lt;/code&gt; 구조! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; 가 작동 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt; 유형은 구문 분석과 다른 사용하여 포맷 할 수 있습니다 &lt;code&gt;parse&lt;/code&gt; 및 &lt;code&gt;format&lt;/code&gt; 절차를.</target>
        </trans-unit>
        <trans-unit id="341a37bcfc2e71e9b4ee3ff4166502922770ca31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INFO&lt;/code&gt; within the output is the result of a format string being prepended to the message, and it will differ depending on the message's level. Format strings are &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;explained in more detail here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;INFO&lt;/code&gt; 출력 내의이 형식 문자열의 결과 메시지에 미리 결정되고, 그리고 메시지의 레벨에 따라 달라질 것이다. 형식 문자열은 &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;여기에 자세히 설명되어 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InvalidObjectConversionError&lt;/code&gt; 의 경우 예외가 발생 &lt;code&gt;x&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f5c304640c208580c9c382b206a712cca543ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MonoTime&lt;/code&gt; type stores the timestamp in nanosecond resolution, but note that the actual supported time resolution differs for different systems.</source>
          <target state="translated">&lt;code&gt;MonoTime&lt;/code&gt; 의 유형은 나노초 해상도의 타임 스탬프를 저장하지만, 참고 서로 다른 시스템에 대한 실제 지원 시간 해상도 다르다는 점.</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">&lt;code&gt;RstParseOptions&lt;/code&gt; 는 , &lt;code&gt;FindFileHandler&lt;/code&gt; 및 &lt;code&gt;MsgHandler&lt;/code&gt; 유형은 상기에서 정의 된 &lt;a href=&quot;rst&quot;&gt;패키지 / docutils / RST 모듈&lt;/a&gt; . &lt;code&gt;options&lt;/code&gt; 은 첫 번째 파서의 동작을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 는 불리며 &lt;span id=&quot;generic-type-parameter_1&quot;&gt;제네릭 형식 매개 변수&lt;/span&gt; 또는 &lt;span id=&quot;type-variable_1&quot;&gt;형식 변수&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="550a18c4fa132b938176c8146984c85cfbb782d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeInterval&lt;/code&gt; type uses calendar units, and will say that exactly one day has passed. The &lt;code&gt;Duration&lt;/code&gt; type on the other hand normalizes everything to seconds, and will therefore say that 90000 seconds has passed, which is the same as 25 hours.</source>
          <target state="translated">&lt;code&gt;TimeInterval&lt;/code&gt; 이 유형은 일정 단위를 사용하고, 그 정확히 언젠가는 통과 말할 것이다. 반면 &lt;code&gt;Duration&lt;/code&gt; 유형은 모든 것을 초로 정규화하므로 25 시간과 동일한 90000 초가 지났다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="7e0401867a6b1c084a80db776014298aa78e4619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UncheckedArray[T]&lt;/code&gt; type is a special kind of &lt;code&gt;array&lt;/code&gt; where its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally, an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;UncheckedArray[T]&lt;/code&gt; 타입의 특별한 종류 &lt;code&gt;array&lt;/code&gt; 의 경계가 확인되지 않는다. 이것은 종종 사용자 정의 된 유연한 크기의 어레이를 구현하는 데 유용합니다. 또한 확인되지 않은 배열은 크기가 결정되지 않은 C 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated">는 &lt;code&gt;[: ]&lt;/code&gt; 표기법이 문제를 완화하기 위해 설계되었다 : &lt;code&gt;x.p[:T]&lt;/code&gt; 에 파서 재기록 &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt; 에 재 기입 &lt;code&gt;p[T](x, y)&lt;/code&gt; . 참고 있음 &lt;code&gt;[: ]&lt;/code&gt; 에는 AST 표현이없는, 재기록이 파싱 단계에서 직접 수행된다.</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 배열 액세스 연산자 과부하 제공 할 수 &lt;span id=&quot;array-properties_1&quot;&gt;배열 특성&lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 지정된 필드가 존재하지 않을 때, 운영자는 예외를 발생시킬 것이다. 이 동작을 피하려면 대신 &lt;code&gt;{}&lt;/code&gt; 연산자를 사용 하면 필드를 찾을 수 없을 때 단순히 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다. &lt;code&gt;get&lt;/code&gt; 호출 할 때 -family 절차는 기본 값을 반환합니다 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 어레이 / openarrays / 시퀀스 첨자 연산자 과부하 될 수있다.</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">&lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 주장은 오직 매우 시작과 옵션이 설정되어 어떤 주제 문자열의 끝과 일치하는지의 전통적인 곡절과 달러 다르다. 차이 &lt;code&gt;\Z&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 하다 &lt;code&gt;\Z&lt;/code&gt; 반면, 문자열뿐만 아니라, 스트링의 끝에서 마지막 문자 개행 전에 일치 &lt;code&gt;\z&lt;/code&gt; 마지막에만 일치한다.</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt; 의 접미사는 릴리스 빌드에 사용되는 &lt;code&gt;_d&lt;/code&gt; 디버그 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt; 의 기간 동안 연결 소켓 연결을 끊이 경우 호출이 오류가 발생할 수 있습니다 &lt;code&gt;accept&lt;/code&gt; . &lt;code&gt;SafeDisconn&lt;/code&gt; 플래그가 지정 되면 이 오류가 발생하지 않고 대신 accept가 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">&lt;code&gt;acyclic&lt;/code&gt; 가 순환 것 같다하지만 pragma는 비순환도로를 표시 할 객체 유형에 사용할 수 있습니다. 이것은 가비지 수집기가이 유형의 객체를주기의 일부로 간주하지 않도록 &lt;strong&gt;최적화&lt;/strong&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="266af869ff6d9dd7a44657712727c1997c3421e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;addr&lt;/code&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 연산자는 L 값의 주소를 반환한다. 위치 유형이 &lt;code&gt;T&lt;/code&gt; 이면 &lt;code&gt;addr&lt;/code&gt; 연산자 결과는 &lt;code&gt;ptr T&lt;/code&gt; 유형 입니다. 주소는 항상 추적되지 않은 참조입니다. 포인터가 스택의 객체보다 오래 살 수 있으므로 존재하지 않는 객체를 참조 할 수 있으므로 스택 에있는 객체의 주소를 가져 오는 것은 &lt;strong&gt;안전하지&lt;/strong&gt; 않습니다. 변수의 주소를 얻을 수 있지만 &lt;code&gt;let&lt;/code&gt; 문을 통해 선언 된 변수에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; 연산자는 L 값의 주소를 반환한다. 위치 유형이 &lt;code&gt;T&lt;/code&gt; 인 경우 &lt;em&gt;가산기&lt;/em&gt; 연산자 결과는 &lt;code&gt;ptr T&lt;/code&gt; 유형 입니다. 주소는 항상 추적되지 않은 참조입니다. 포인터가 스택의 객체보다 오래 존재할 수 있으므로 존재하지 않는 객체를 참조 할 수 있으므로 스택 에있는 객체의 주소를 가져 오는 것은 &lt;strong&gt;안전하지&lt;/strong&gt; 않습니다. 변수의 주소를 얻을 수는 있지만 &lt;code&gt;let&lt;/code&gt; 문을 통해 선언 된 변수에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 절차는 또한 try 문에 대한 제한적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 유형은 반환 형식과 매개 변수에 사용할 수 있습니다. 리턴 유형의 경우 컴파일러가 루틴 본문에서 유형을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt; 를 호출은 많은 상황에서 사용할 수있다. 변수 선언의 오른쪽에서 사용할 수 있습니다 : &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; ,이 경우 변수는 미래의 값으로 자동 설정됩니다. 대기하기 위해 사용될 수있는 &lt;code&gt;Future&lt;/code&gt; 개체를 복귀 절차 기다린다 사용될 수있다 &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; 문은 대응합니다 &lt;code&gt;mixin&lt;/code&gt; 문. 초기에 바인딩해야하는 식별자를 명시 적으로 선언하는 데 사용할 수 있습니다 (즉, 식별자는 템플릿 / 일반 정의의 범위에서 찾아야 함).</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">&lt;code&gt;bitsize&lt;/code&gt; pragma는 개체 필드 회원입니다. C / C ++에서 필드를 비트 필드로 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">&lt;code&gt;borrow&lt;/code&gt; pragma는 컴파일러가 구별 유형의 기본 유형 거래, 어떤 코드가 생성되지 않도록하는 시저와 같은 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 문은 즉시 블록을두고하는 데 사용됩니다. 경우 &lt;code&gt;symbol&lt;/code&gt; 주어집니다, 그것은 떠날 것입니다 바깥 쪽 블록의 이름입니다. 없는 경우 가장 안쪽 블록이 남습니다.</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">&lt;code&gt;bycopy&lt;/code&gt; 프라그 개체 또는 튜플 타입인가에 프록 값 유형을 전달하도록 컴파일러에 지시 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">&lt;code&gt;byref&lt;/code&gt; 프라그 개체 또는 튜플 타입에 적용 프록 참조 (숨겨진 포인터)으로 입력을 전달하도록 컴파일러에 지시 할 수있다.</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 제약 복사하는 의미를 가지고 종류의 이동 최적화를 구현하는 데 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="596c2ddba36b2be7462234bbca37dd7763734862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case expression&lt;/code&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;code&gt;case expression&lt;/code&gt; 다시 case 문 매우 유사합니다 :</target>
        </trans-unit>
        <trans-unit id="a107daa0b6476fd7a15fef2edb54c6f60373d558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement doesn't produce an l-value, so the following example won't work:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 문, L 자 값을 생성하지 않는 다음의 예 그렇게하지 않습니다 일 :</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 문은 if 문과 비슷하지만 여러 가지 선택을 나타냅니다. 키워드 후의 식 &lt;code&gt;case&lt;/code&gt; 평가되고 그 값이있는 경우 &lt;em&gt;slicelist&lt;/em&gt; (애프터 해당 문장 &lt;code&gt;of&lt;/code&gt; 키워드)가 실행된다. 값이 주어진에없는 경우 &lt;em&gt;slicelist &lt;/em&gt; &lt;code&gt;else&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;else&lt;/code&gt; 부분 이없고 &lt;code&gt;expr&lt;/code&gt; 이 보유 할 수있는 모든 가능한 값이 &lt;code&gt;slicelist&lt;/code&gt; 에서 발생 하지 않으면 정적 오류가 발생합니다. 이것은 서수 유형의 표현에만 적용됩니다. 의 &quot;모든 가능한 값&quot; &lt;code&gt;expr&lt;/code&gt; 에가 결정된다 &lt;code&gt;expr&lt;/code&gt; 의 유형입니다. 정적 오류를 억제하려면 빈 &lt;code&gt;discard&lt;/code&gt; 명령문이 있는 &lt;code&gt;else&lt;/code&gt; 부분을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b51cba93a6d0694db97762461996e17d9632399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cdf&lt;/code&gt; argument does not have to be normalized, and it could contain any type of elements that can be converted to a &lt;code&gt;float&lt;/code&gt;. It must be the same length as &lt;code&gt;a&lt;/code&gt;. Each element in &lt;code&gt;cdf&lt;/code&gt; should be greater than or equal to the previous element.</source>
          <target state="translated">&lt;code&gt;cdf&lt;/code&gt; 인수는 정규화 할 필요가 없습니다, 그리고 그것은으로 변환 할 수있는 요소의 모든 종류의 포함 할 수 &lt;code&gt;float&lt;/code&gt; . 와 길이가 같아야 &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;cdf&lt;/code&gt; 의 각 요소 는 이전 요소보다 크거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">&lt;code&gt;codegenDecl&lt;/code&gt; 의 프라그를 직접 님의 코드 생성기에 영향을 줄 수 있습니다. 생성 된 코드에서 변수 또는 proc가 선언되는 방식을 결정하는 형식 문자열을받습니다.</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; pragma는 컴파일하는 데 사용하고 프로젝트와 C / C ++ 소스 파일을 링크 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt; 프라그은 컴파일시에 사용하는 PROC 또는 변수를 표시하는 데 사용됩니다. 코드가 생성되지 않습니다. 컴파일 타임 프로세서는 매크로의 도우미로 유용합니다. 언어, 사용을하는 시저의 버전 0.12.0 이후 &lt;code&gt;system.NimNode&lt;/code&gt; 의 매개 변수 유형 내에서 암시 적 선언 &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b1f4b5ca84c613d5f2aec3d6366c35d47c3b092" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt; 프라그은 컴파일 시간 실행 중에 사용되는 발동 또는 변수를 표시하기 위해 사용된다. 이에 대한 코드가 생성되지 않습니다. 컴파일 타임 procs는 매크로에 대한 도우미로 유용합니다. 언어, 사용을하는 시저의 버전 0.12.0 이후 &lt;code&gt;system.NimNode&lt;/code&gt; 의 매개 변수 유형 내에서 암시 적 선언 &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">&lt;code&gt;computedGoto&lt;/code&gt; 의 프라그는 어떻게 님의 컴파일하는 컴파일러에게하는 데 사용할 수있는 &lt;span id=&quot;case_2&quot;&gt;경우를&lt;/span&gt; A의 &lt;code&gt;while true&lt;/code&gt; 문. 문법적으로 루프 내부에서 명령문으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;con&lt;/code&gt; Nimsuggest 명령은 제안 명령, 대신 사용자가 점 문자를 입력 한 후 사용되는 매우 비슷합니다,이 하나는 사용자가 입력 매개 변수를 시작하기 위해 여는 중괄호를 입력 한 후 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ddeba29bb3840db26dd678de22fc2a91b2bc365" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;code&gt;compatible string&lt;/code&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible with the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">&lt;code&gt;compatible string&lt;/code&gt; 의미 하는 &lt;code&gt;cstring&lt;/code&gt; 유형 은 컴파일 백엔드에 대한 문자열의 기본 표현입니다. C 백엔드의 경우 &lt;code&gt;cstring&lt;/code&gt; 유형은 Ansi C의 &lt;code&gt;char*&lt;/code&gt; 유형과 호환되는 0으로 끝나는 char 배열에 대한 포인터를 나타냅니다 . 주요 목적은 C와의 쉬운 인터페이스에 있습니다. 인덱스 연산 &lt;code&gt;s[i]&lt;/code&gt; 는 i 번째 &lt;em&gt;문자를&lt;/em&gt; 의미합니다. 의 &lt;code&gt;s&lt;/code&gt; ; 그러나 &lt;code&gt;cstring&lt;/code&gt; 에 대한 경계 검사 가 수행 되지 않아 인덱스 작업이 안전하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">&lt;em&gt;호환 가능한 문자열을&lt;/em&gt; 의미 하는 &lt;code&gt;cstring&lt;/code&gt; 유형 은 컴파일 백엔드에 대한 문자열의 기본 표현입니다. C 백엔드의 경우 &lt;code&gt;cstring&lt;/code&gt; 유형은 Ansi C의 &lt;code&gt;char*&lt;/code&gt; 유형과 호환되는 0으로 끝나는 char 배열에 대한 포인터를 나타냅니다 . 기본 목적은 C와 쉽게 인터페이스하는 데 있습니다. 인덱스 작업 &lt;code&gt;s[i]&lt;/code&gt; 는 i 번째 &lt;em&gt;char을&lt;/em&gt; 의미합니다. 의 &lt;code&gt;s&lt;/code&gt; ; 그러나 인덱스 작업을 안전하지 않게 만드는 &lt;code&gt;cstring&lt;/code&gt; 에 대한 경계 검사 가 수행 되지 않습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 때 전달됩니다 응용 프로그램 정의 데이터이며, &lt;code&gt;ev&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 로 처리 할 때 전달되는 애플리케이션 정의 데이터 인 &lt;code&gt;pid&lt;/code&gt; 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 신호가 상승 할 때 전달되는 애플리케이션 정의 데이터이다.</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 타이머가 트리거 될 때 전달됩니다 응용 프로그램 정의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;def&lt;/code&gt; Nimsuggest 명령을 수행하는 특정 기호의 정의에 대한 질의. 사용 가능한 경우 Nimsuggest는 유형, 소스 파일, 행 / 열 정보 및 기타 문서 데이터 (문서 문자열과 같은 경우)로 응답합니다. 이 정보를 통해 IDE는 사용자가 커서를 심볼 위에 놓거나 마우스를 사용하여 심볼을 선택하고 심볼이있는 위치로 리디렉션 되는 일반적인 &lt;em&gt;점프 정의를&lt;/em&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt; 문은 또한에 설명 된대로 블록 주석을 만드는 데 사용할 수있는 &lt;a href=&quot;#comments&quot;&gt;댓글&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3b805b82d90e245faef9fdd6f1471f89c50747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away, and should only be used when ignoring this value is known not to cause problems.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt; 문은 부작용에 대한 표현을 평가하고 멀리 식의 결과 값을 발생하고,이 값이 문제가 발생하지 알려진 무시하는 경우에만 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt; 문은 부작용에 대한 표현을 평가하고 멀리 식의 결과 값을 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;doc&lt;/code&gt; 명령</target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; 의 수입 메커니즘은 버전 관리 체계를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="cc96537bffb0b9bad329ba2a12ee9fb4ede87416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as an argument but also string expressions in general:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; 의 프라그 지원 일반적으로뿐만 아니라 일정 인수로 문자열뿐만 아니라 문자열 식 :</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; 의 프라그 지원 일반적으로뿐만 아니라 일정 인수로 문자열뿐만 아니라 문자열 식 :</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">&lt;code&gt;effects&lt;/code&gt; 프라그는 효과 분석과 프로그래머를 지원하기 위해 설계되었습니다. 컴파일러가 모든 유추 된 효과를 &lt;code&gt;effects&lt;/code&gt; 위치 까지 출력하도록하는 명령문입니다 .</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt; 프라 그마 직접 컴파일러의 코드 생성기의 출력에 영향을 미칠 수 있습니다. 따라서 코드를 다른 코드 생성기 / 백엔드로 이식 할 수 없습니다. 사용을 권장하지 않습니다! 그러나 &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; 또는 &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; 코드 와 인터페이스하는 데 매우 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1744e04ac4bf85a742e23451c47c651184464bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. The code is then unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt; 프라 그마 직접 컴파일러의 코드 생성기의 출력에 영향을 미칠 수 있습니다. 이 코드는 다른 코드 생성기 / 백엔드로 이식 할 수 없습니다. 그것의 사용은 매우 권장하지 않습니다! 그러나 &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt; 또는 &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; 코드 와의 인터페이스에는 매우 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 절차는 소요 &lt;code&gt;openarray&lt;/code&gt; 을 모두 배열 및 시퀀스 파라미터로서 전달 될 수 있도록.</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그도 (반복자 또는 PROC 같이) 심볼 주석을 사용할 수있다. &lt;em&gt;사용&lt;/em&gt; 심볼의는 컴파일 타임 오류를 트리거합니다. 이는 오버로드 및 유형 변환으로 인해 일부 작업이 유효하다는 것을 배제하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d75f88dde94403b5fd845aa53b72776cec145bb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그도 (반복자 또는 PROC 같이) 심볼 주석을 사용할 수있다. &lt;em&gt;사용&lt;/em&gt; 심볼의는 정적 오류를 트리거합니다. 이는 오버로딩 및 형식 변환으로 인해 일부 작업이 유효하다는 것을 배제하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그 지정된 콘텐츠 컴파일러 출력 된 에러 메시지를 만들기 위해 사용된다. 그래도 오류 후에 컴파일이 중단되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="33a44bbe47b4c8fdaa3be5e19f100223278506bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. The compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 프라그 지정된 콘텐츠 컴파일러 출력 된 에러 메시지를 만들기 위해 사용된다. 그러나 컴파일이 반드시 오류 후에 중단되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a55b4e02a1f03c12faf1b7a6871ee52b02f9e3c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errorCode&lt;/code&gt; will determine the message, &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc&lt;/a&gt; will be used to get this message.</source>
          <target state="translated">&lt;code&gt;errorCode&lt;/code&gt; 메시지를 결정할 것은 &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc 디렉토리는&lt;/a&gt; 이 메시지를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma는 실험적인 언어 기능을 사용할 수 있습니다. 구체적인 기능에 따라, 이는 안정적인 릴리스를 위해 기능이 너무 불안정한 것으로 간주되거나 기능의 미래가 확실하지 않다는 것을 의미합니다 (언제든지 제거 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2db09f750ba40a04b2a467b51764ca184871542b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature, this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed at any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma는 실험적인 언어 기능을 사용할 수 있습니다. 구체적인 기능에 따라 이는 기능이 안정된 릴리스에 비해 너무 불안정한 것으로 간주되거나 기능의 미래가 불확실하다는 것을 의미합니다 (언제든지 제거 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; pragma는 유형, 변수, 또는 C. 열거 형 상수에 대한 절차를 내보낼 수 없습니다를 수출 할 수있는 방법을 제공합니다. 선택적 인수는 C 식별자를 포함하는 문자열입니다. 인수가 없으면 C 이름은 &lt;em&gt;철자 그대로&lt;/em&gt; 의 Nim 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에 &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 의 &lt;code&gt;result = expr&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 컴파일러에 의해 도입 된 특별한 상징이다.</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt; 에서 &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt; 프라그 컴파일러 출력을 지정된 콘텐츠 에러 메시지를 만들기 위해 사용된다. 받는 반면 &lt;code&gt;error&lt;/code&gt; 프라그 컴파일이 래그에 의해 중단되도록 보장된다. 예:</target>
        </trans-unit>
        <trans-unit id="79c9a76ff3ec29ee56bce522b023152fceaf2553" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, the compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt; 프라그 컴파일러 출력을 지정된 콘텐츠 에러 메시지를 만들기 위해 사용된다. 받는 반면 &lt;code&gt;error&lt;/code&gt; 프라그, 컴파일이 래그에 의해 중단되도록 보장된다. 예:</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; paramater 정적 분석을 위해 충분하지만, 십오하는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 사용자가 여전히 줄을 입력의 중간에있을 수 있습니다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;dirtyfile.nim&lt;/code&gt; 옵션을 사용하여 Nimsuggest에 foobar.nim 을 &lt;code&gt;temporary/foobar.nim&lt;/code&gt; 에서 &lt;code&gt;foobar.nim&lt;/code&gt; 한다고 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d9509997434d269bb0f68e1b13ca2d2239ff7894" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 매개 변수는 정적 분석을 위해 충분하지만, 십오하는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 사용자가 여전히 줄을 입력의 중간에있을 수 있습니다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;dirtyfile.nim&lt;/code&gt; 옵션을 사용하여 Nimsuggest에 foobar.nim 을 &lt;code&gt;temporary/foobar.nim&lt;/code&gt; 에서 &lt;code&gt;foobar.nim&lt;/code&gt; 한다고 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f648707faaf2c971dac2bc6f092c42cb1b59e97e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;code&gt;filename&lt;/code&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overridden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 매개 변수는 오류보고 및 파일에 인덱스 하이퍼 링크를 만드는 데 사용됩니다,하지만 당신은 메모리 스트림을 구문 분석하는 경우 여기에 빈 문자열을 전달할 수 있습니다. 경우 &lt;code&gt;filename&lt;/code&gt; 과 끝 &lt;code&gt;.nim&lt;/code&gt; 확장, 문서의 제목은 기본적으로 설정됩니다 &lt;code&gt;Module filename&lt;/code&gt; . 이 기본 제목은 포함 된 첫 번째 제목에 의해 재정의 될 수 있지만 제목이없는 경우 생성 된 색인을 미리 설정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; pragma는 그것에서 상속 할 수 없음을 지정하는 객체 유형에 사용할 수 있습니다. 상속은 기존 객체 ( &lt;code&gt;object of SuperType&lt;/code&gt; 구문 의 객체를 통해 )에서 &lt;code&gt;inheritable&lt;/code&gt; 되거나 inheritable 로 표시된 객체에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">&lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; 구문은 더 심미적으로 만족이지만, 작은 잡았다을 숨 깁니다. 문자열은 &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;일반화 된 원시 문자열 리터럴&lt;/a&gt; 입니다. 이것은 놀라운 효과가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 본체의 단부까지 그 범위에 도달 - 루프 반복 변수를 선언한다. 반복 변수의 유형은 반복자의 리턴 유형으로 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 시퀀스로 사용될 때 진술 한 두 변수가 사용될 수있다. 하나의 변수 형식을 사용하면 변수는 시퀀스에서 제공 한 값을 보유합니다. &lt;code&gt;for&lt;/code&gt; 문에서 결과를 통해 반복되는 &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;항목 ()&lt;/a&gt; 로부터 반복자 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈을. 그러나 두 변수 형식을 사용하면 첫 번째 변수는 인덱스 위치를 유지하고 두 번째 변수는 값을 보유합니다. 여기서 &lt;code&gt;for&lt;/code&gt; 문은 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈 에서 &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs ()&lt;/a&gt; 반복자 의 결과를 반복 합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 문은 모든 요소를 통해 루프에 구조입니다 &lt;em&gt;반복자&lt;/em&gt; 제공합니다. 이 예제는 내장 &lt;a href=&quot;system#countup&quot;&gt;카운트 업&lt;/a&gt; 반복자 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 문은 또한하여 기호를 사용할 수 있도록하지만, 사용 자격이 될 필요가 기호에 네임 스페이스의 자격을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 키워드를 소개하는 바로 가기 &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect의&lt;/span&gt; PROC.</target>
        </trans-unit>
        <trans-unit id="26dd192f9577287d3ff84d0ce8f6615a75baab8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackDefect&lt;/code&gt; if there is no value. Note that &lt;code&gt;UnpackDefect&lt;/code&gt; inherits from &lt;code&gt;system.Defect&lt;/code&gt;, and should therefore never be caught. Instead, rely on checking if the option contains a value with &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt; and &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 작업이 반환 위의 기본 가치를 입증, 또는 제기 &lt;code&gt;UnpackDefect&lt;/code&gt; 을 값이없는 경우. 참고 &lt;code&gt;UnpackDefect&lt;/code&gt; 가 상속 &lt;code&gt;system.Defect&lt;/code&gt; , 따라서 잡은해서는 안됩니다. 대신 옵션에 &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt; 및 &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs 값이 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 작업이 반환 위의 기본 가치를 입증, 또는 제기 &lt;code&gt;UnpackError&lt;/code&gt; 을 값이없는 경우. 값을 얻는 또 다른 옵션이 있습니다 : &lt;code&gt;unsafeGet&lt;/code&gt; , 값이 존재하는지 확실하게 확신 할 때만 (예 : &lt;code&gt;isSome&lt;/code&gt; 확인 후 ) 사용해야 합니다. 당신이 작은 오버 헤드가 신경 쓰지 않으면 &lt;code&gt;get&lt;/code&gt; 원인을, 당신은 단순히 사용해서는 안 &lt;code&gt;unsafeGet&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="79cc36593cae272a27774d93dd0f0cb520bc5bac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt;-family helpers also accept an additional parameter which allow you to fallback to a default value should the key's values be &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; -family 헬퍼 또한 키의 값이 있어야 할 기본 값으로 폴백 할 수 있도록 추가 매개 변수 동의 &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 프라그는 글로벌 위치에 저장하도록 컴파일러에 지시 발동 내의 변수에 적용 프로그램 시작시에 한번 초기화된다.</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt; 주석은 또한 객체 내에서 필드를 보호 할 수 있습니다. 그러면 가드는 동일한 객체 또는 전역 변수 내의 다른 필드 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cecf91584150e32f7e14d844ab583125e19b5fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string constant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; pragma는 항상 문자열 상수를 기대하고있다. 문자열 상수에는 헤더 파일이 포함됩니다. C의 경우와 같이 시스템 헤더 파일은 꺾쇠 괄호로 묶여 있습니다 : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . 꺾쇠 괄호가 제공되지 않으면 Nim은 생성 된 C 코드에서 헤더 파일을 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; pragma는 항상 문자열 상수를 기대하고있다. 문자열 상수는 헤더 파일을 포함합니다. C의 경우처럼 시스템 헤더 파일은 꺾쇠 괄호로 묶습니다 : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . 꺾쇠 괄호가 제공되지 않으면 Nim은 생성 된 C 코드에서 헤더 파일을 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 프라그는 매우 유사하다 &lt;code&gt;noDecl&lt;/code&gt; 의 프라그 :이 선언되지 않아야 대신 생성 된 코드가 포함되어야한다는 것은 거의 모든 기호와 지정에 적용 할 수 &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b72401b61f0f4d4b74ca7cd37fb890761035c656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead, the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 프라그는 매우 유사하다 &lt;code&gt;noDecl&lt;/code&gt; 의 프라그 : 선언되어서는 안된다는 거의 모든 기호와 지정에 적용 할 수있는 대신, 생성 된 코드가 포함되어야 &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="10b64dbd148a29167eb5bce55224c93f8272a383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heapqueue&lt;/code&gt; module implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap data structure&lt;/a&gt; that can be used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;priority queue&lt;/a&gt;. Heaps are arrays for which &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; and &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; for all &lt;code&gt;k&lt;/code&gt;, counting elements from 0. The interesting property of a heap is that &lt;code&gt;a[0]&lt;/code&gt; is always its smallest element.</source>
          <target state="translated">&lt;code&gt;heapqueue&lt;/code&gt; 모듈 구현 &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;힙 데이터 구조&lt;/a&gt; A와 사용할 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;우선 순위 큐&lt;/a&gt; . 힙은 0부터 요소를 세는 모든 &lt;code&gt;k&lt;/code&gt; 에 대해 &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; 및 &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; 배열입니다. 힙의 흥미로운 속성은 다음과 같습니다. 있다는 &lt;code&gt;a[0]&lt;/code&gt; 항상 가장 작은 엘리먼트이다.</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; 프라그 지정된 콘텐츠 컴파일러 힌트 출력 메시지를 만들기 위해 사용된다. 힌트 후에 컴파일이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef0beadd43d9c18e85d2fbeaa068bda72ec3066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;code&gt;id&lt;/code&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 길이가 달리 특정 앵커가 생성되지 않습니다, 0이 아닌 경우에만 해시 문자로 추가됩니다. 일반적으로 독립형 첫 번째 문서의 제목에 대해 빈 &lt;code&gt;id&lt;/code&gt; 값만 전달해야합니다 (이는 &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes ()&lt;/a&gt; proc에 대해 특별합니다 . 자세한 내용 은 &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;인덱스 (idx) 파일 형식&lt;/a&gt; 참조). 다른 색인 용어와 달리 제목 항목은 항목의 논리적 순서를 유지하기 위해 누적 된 버퍼의 시작 부분에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 키워드 후 표현 : 문은 제어 흐름에 지점을 만들 수있는 간단한 방법입니다 &lt;code&gt;if&lt;/code&gt; 는 후 해당 문이 true 인 경우, 평가 &lt;code&gt;:&lt;/code&gt; 실행됩니다. 그렇지 않으면, &lt;code&gt;elif&lt;/code&gt; 이후의 표현식 이 평가되면 ( &lt;code&gt;elif&lt;/code&gt; 분기 가있는 경우), true 인 경우 &lt;code&gt;:&lt;/code&gt; 다음의 해당 명령문 이 실행됩니다. 이것은 마지막 &lt;code&gt;elif&lt;/code&gt; 까지 계속됩니다 . 모든 조건이 실패하면 &lt;code&gt;else&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;else&lt;/code&gt; 부분 이 없으면 다음 명령문으로 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0003d13f41be8193835c63a646af8124f68cb7cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; statement is only allowed at the top level.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명령문은 최상위 수준에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; 프라그는 PROC 또는 C.에서 변수 선택적 인수는 C 식별자를 포함하는 문자열을 가져올 수있는 수단을 제공한다. 인수가 없으면 C 이름은 &lt;em&gt;철자 그대로&lt;/em&gt; 의 Nim 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="eac30aaa2478fce31be57ea79b6cc59d42ac456c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement can be used outside of the top level, as such:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 문은 다음과 같은 최고 수준의 사용 외부 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated">는 &lt;code&gt;include&lt;/code&gt; 는 단지 파일의 내용을 포함한다 : 문이 모듈을 가져 오는 것보다 근본적으로 다른 일을한다. 는 &lt;code&gt;include&lt;/code&gt; 문은 여러 개의 파일로 큰 모듈을 분할하는 데 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;incompleteStruct&lt;/code&gt; 의 pragma는 기본 C를 사용하지 않도록 컴파일러에 지시 &lt;code&gt;struct&lt;/code&gt; A의 &lt;code&gt;sizeof&lt;/code&gt; 표현 :</target>
        </trans-unit>
        <trans-unit id="7544df806eff4f7313cff76422ab23377014cb76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; proc can be called with any number of arguments, i.e. &lt;code&gt;initTable(initialSize)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 시저는 인수의 수, 즉 호출 할 수 &lt;code&gt;initTable(initialSize)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt; 및 &lt;code&gt;gensym&lt;/code&gt; 래그 마를 번째 클래스 주석이고; 템플릿 정의 외부에 의미가 없으며 추상화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">&lt;code&gt;injectStmt&lt;/code&gt; 의 프라그는 현재 모듈의 다른 모든 문 앞에 성명을 주입하는 데 사용할 수 있습니다. 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc7da59a3ce1987099582089c22c83123acc3457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient &lt;code&gt;int&lt;/code&gt; set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;intsets&lt;/code&gt; 는 구현을 효율적 모듈 &lt;code&gt;int&lt;/code&gt; A와 집합 구현 &lt;span id=&quot;sparse-bit-set_1&quot;&gt;희소 비트 세트&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">&lt;code&gt;intsets&lt;/code&gt; 는 구현에게로 구현 효율적인 INT 세트 모듈 &lt;span id=&quot;sparse-bit-set_1&quot;&gt;성긴 비트 세트&lt;/span&gt; . &lt;strong&gt;참고&lt;/strong&gt; : Nim은 현재 할당 연산자의 오버로드를 허용하지 않기 때문에 &lt;code&gt;=&lt;/code&gt; int 세트의 경우 의미없는 얕은 복사를 수행합니다. 깊은 복사를 하려면 &lt;code&gt;assign&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">&lt;code&gt;int{lit}&lt;/code&gt; 형식의 표현에 대한 매개 변수 패턴 일치 &lt;code&gt;int&lt;/code&gt; 하지만 문자 그대로의 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">는 &lt;code&gt;is&lt;/code&gt; 컴파일시 타입 당량 대 운전자 검사한다. 따라서 일반 코드 내에서 유형 특수화에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="037a846ce64ff72c6c1886c38f998c5c082548cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 오퍼레이터 형 등가 확인하는 의미 론적 분석에서 평가 하였다. 따라서 일반 코드 내에서 유형 전문화에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 유형은 호출 컨벤션의 항상 &lt;code&gt;closure&lt;/code&gt; 암시; 다음 예제는 반복자를 사용하여 &lt;span id=&quot;collaborative-tasking_1&quot;&gt;협업 타스크&lt;/span&gt; 시스템 을 구현하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc0&lt;/code&gt; 의 명령</target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc&lt;/code&gt; 의 명령</target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;koch&lt;/code&gt; 프로그램은 님의 유지 보수 스크립트입니다. 이식성이 뛰어나다는 장점으로 make 및 shell 스크립팅을 대체합니다. 해당 옵션에 대한 자세한 내용은 &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 문은 같은 작품 &lt;code&gt;var&lt;/code&gt; 에 문하지만 선언 기호는 &lt;em&gt;하나의 할당&lt;/em&gt; 변수 : 초기화 한 후 그 값을 변경할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; 프라그는 스택 백 트레이스에서 볼 수 있듯이 주석 문의 라인 정보에 영향을 미칠 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8afa9eeaecb1dea09c8ad531f545e95028e51642" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement, as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; 스택 백 트레이스에서 볼 수 있듯이 프라그은, 주석 문의 라인 정보에 영향을 미칠 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">&lt;code&gt;lineDir&lt;/code&gt; 의 옵션을 켜거나 끌 수 있습니다. 생성 된 C 코드를 켜면 &lt;code&gt;#line&lt;/code&gt; 지시문이 포함 됩니다. 이것은 GDB로 디버깅하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">&lt;code&gt;lineInfoFrom&lt;/code&gt; 의 생성 코드가 충돌 할 때 매개 변수는 온라인 정보에 사용됩니다. 변환중인 노드로 설정되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">&lt;code&gt;lineTrace&lt;/code&gt; 의 옵션은 의미 &lt;code&gt;stackTrace&lt;/code&gt; 옵션을 선택합니다. 설정하면 생성 된 C에 코드가 포함되어 프로그램이 충돌하거나 포착되지 않은 예외가 발생하는 경우 행 번호 정보가있는 적절한 스택 추적이 제공되도록합니다.</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; 의 프라그는 어떻게 님의 컴파일하는 컴파일러에게하는 데 사용할 수있는 &lt;span id=&quot;case_1&quot;&gt;경우&lt;/span&gt; 문을. 문법적으로 그것은 진술로 사용되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt; 의 프라그 선형 스캐닝을 통해에 대해 테스트해야 마지막 지점에 투입되어야한다. 전체 &lt;code&gt;case&lt;/code&gt; 문의 마지막 분기에 배치 하면 전체 &lt;code&gt;case&lt;/code&gt; 문은 선형 스캔을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 프라그는 프로젝트에 추가 파일을 링크 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e60060003730f2db3edee6726ebcb73673ad9ecf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localPassc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler, but only for the C/C++ file that is produced from the Nim module the pragma resides in:</source>
          <target state="translated">&lt;code&gt;localPassc&lt;/code&gt; 의 프라그는 오직 상기 래그에 상주 모듈 님으로부터 생성되는 C / C ++ 파일은 C 컴파일러 추가 파라미터를 전달하는데 사용될 수있다 :</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; pragma는 또한 특수 값이 걸릴 수 있습니다 &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; . 동적 메소드 디스패치 컨텍스트에서 유용합니다. 다음 예에서 컴파일러는 &lt;code&gt;base&lt;/code&gt; 사례에 대해 잠금 수준 0을 유추 할 수 있습니다 . 그러나 오버로드 된 메소드 중 하나가 잠길 수있는 procvar를 호출합니다. 따라서 &lt;code&gt;g.testMethod&lt;/code&gt; 호출의 잠금 수준을 정적으로 유추 할 수 없으므로 컴파일러 경고가 발생합니다. 사용하여 &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; , 기지국 방법이 아니라 알려지지 로크 레벨을 갖는 것으로 명시 적으로 표시 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; 프라그가 잠금 식 목록 얻어 &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; 를 지원하기 위해서 &lt;em&gt;다중 잠금&lt;/em&gt; 문. 이것이 필수적인 이유는 &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;잠금 레벨&lt;/a&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; 이 더 런타임 의미가 없습니다 직접 사용할 수 없습니다 때문에 부분은 의도적으로 추한 보인다! 런타임에 일부 형식의 잠금을 구현하는 템플릿에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 수정할 수 있습니다 &lt;code&gt;val&lt;/code&gt; 과 &lt;code&gt;pairExists&lt;/code&gt; 키의 매핑을 변경하거나 테이블에서 삭제하는 값. 값을 추가 할 때 &lt;code&gt;val&lt;/code&gt; 수정과 함께 &lt;code&gt;pairExists&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 3 개 인수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt; 파라미터를 판독 할 수있는 최대 문자 수를 결정한다. 그 후에 &lt;code&gt;resString&lt;/code&gt; 이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt; 파라미터를 판독 할 수있는 최대 문자 수를 결정한다. 그 후 결과가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">&lt;code&gt;msgHandler&lt;/code&gt; 는 사용자 오류보고에 사용되는 PROC입니다. 파일 이름, 줄, 열 및 구문 분석 중에 발견 된 오류 유형으로 호출됩니다. &lt;code&gt;nil&lt;/code&gt; 을 전달 하면 표준 출력에 메시지를 쓰는 기본 메시지 핸들러가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">&lt;code&gt;nim&lt;/code&gt; (이 순서로, 나중에 파일이 이전 설정을 덮어 쓰기) 다음 디렉토리에서 실행 프로세스 구성 파일 :</target>
        </trans-unit>
        <trans-unit id="d1de4c15a5d4322e279af56e0f42cc33a1504497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes the &lt;code&gt;.nims&lt;/code&gt; configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">&lt;code&gt;nim&lt;/code&gt; 실행 처리하고 &lt;code&gt;.nims&lt;/code&gt; 의 다음 디렉토리에서 구성 파일 (이 순서로, 나중에 파일이 이전 설정을 덮어 쓰기) :</target>
        </trans-unit>
        <trans-unit id="5b963c0905e1160ea544d741ffdbf201c3a7bf09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nimDisableCertificateValidation&lt;/code&gt; define overrides verifyMode and disables certificate verification globally!</source>
          <target state="translated">&lt;code&gt;nimDisableCertificateValidation&lt;/code&gt; 는 verifyMode 및 비활성화 인증서 확인 세계를 오버라이드 (override) 정의!</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">&lt;code&gt;nnkElifBranch&lt;/code&gt; 및 &lt;code&gt;nnkElse&lt;/code&gt; 부분이 누락 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">&lt;code&gt;noDecl&lt;/code&gt; 의 pragma는 거의 모든 심볼 (변수, 시저, 유형 등)에 적용되고 C와 상호 운용성을 위해 때때로 유용 할 수 있습니다 : 그것은 C 코드의 기호에 대한 선언을 생성하지 않도록 님을 알려줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ad2ee4458517f6e547cf12f840abec614d3d433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;out T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt; 의 프라그는 PROC를 표시하는 데 사용된다 / 반복기 부작용이 없음. 즉, proc / iterator는 해당 매개 변수에서 도달 할 수있는 위치 만 변경하고 반환 값은 인수에만 의존합니다. 매개 변수가 &lt;code&gt;var T&lt;/code&gt; 또는 &lt;code&gt;out T&lt;/code&gt; 또는 &lt;code&gt;ref T&lt;/code&gt; 또는 &lt;code&gt;ptr T&lt;/code&gt; 유형을 가지지 않으면 위치가 수정되지 않음을 의미합니다. 컴파일러가이를 확인할 수없는 경우 proc / iterator에 부작용이 없음을 표시하는 것은 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt; 의 프라그는 PROC를 표시하는 데 사용된다 / 반복기 부작용이 없음. 이는 proc / iterator가 매개 변수에서 도달 할 수있는 위치 만 변경하고 리턴 값은 인수에만 의존 함을 의미합니다. &lt;code&gt;var T&lt;/code&gt; 또는 &lt;code&gt;ref T&lt;/code&gt; 또는 &lt;code&gt;ptr T&lt;/code&gt; 유형의 매개 변수가 없는 위치는 수정 된 위치가 없음을 의미합니다. 컴파일러에서이를 확인할 수없는 경우 proc / iterator에 부작용이없는 것으로 표시하는 것은 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; pragma는 결코 반환하는 발동을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85bb1f5f512bb1750c1a4d1ebcd22d1e74a421af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; keyword is always a unary operator, &lt;code&gt;a not b&lt;/code&gt; is parsed as &lt;code&gt;a(not b)&lt;/code&gt;, not as &lt;code&gt;(a) not (b)&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;not&lt;/code&gt; 키워드가 항상 단항 연산자 &lt;code&gt;a not b&lt;/code&gt; 로 파싱 &lt;code&gt;a(not b)&lt;/code&gt; 하지, &lt;code&gt;(a) not (b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 이것은 왼쪽 접힘이므로 빼기와 같은 비 연관 이진 연산의 경우 숫자 1, 2 및 3의 시퀀스는 (((1)-2)-3)으로 괄호로 묶을 것이라고 생각합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 이것은 폴드이므로 뺄셈과 같은 비 연관 이진 연산의 경우 숫자 1, 2 및 3의 시퀀스는 (1-(2-(3)))로 괄호로 묶을 것이라고 생각합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; 매개 변수는 변수를 사용하는 식이어야 및 &lt;code&gt;b&lt;/code&gt; 스크롤의 각 단계. 첫 &lt;code&gt;first&lt;/code&gt; 매개 변수는 시작 값 (첫 번째 &lt;code&gt;a&lt;/code&gt; )이므로 결과 유형을 정의합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">&lt;code&gt;optPeg&lt;/code&gt; 의 템플릿 패턴 만 프로그램 시작 한번에 분석되고 전역에 저장 될 수 있도록하는 것이, 캐릭터 문자와 PEG 생성자의 경우 최적화 &lt;code&gt;gl&lt;/code&gt; 사용 후 재이다. 이 최적화는 기존 루프 호이 스팅에 필적하기 때문에 호이 스팅이라고합니다.</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 프라그는 어떤에 적용 할 수있는 &lt;code&gt;object&lt;/code&gt; 유형입니다. 객체의 필드가 메모리에 연속적으로 패킹되도록합니다. 패킷이나 메시지를 네트워크 또는 하드웨어 드라이버와주고받는 데 유용하며 C와의 상호 운용성을 위해 유용합니다. 패킹 된 pragma와 상속을 결합하는 것은 정의되어 있지 않으며 GC의 메모리 (참조)와 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 배열을 지정 PARAMS IdentDefs 목록 뒤에 PROC의 복귀 형으로 시작한다.</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">&lt;code&gt;parseJson&lt;/code&gt; 의 절차는 JSON과 리턴이 포함 된 문자열 소요 &lt;code&gt;JsonNode&lt;/code&gt; 의 개체를. 이것은 객체 변형이며 &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt; 또는 &lt;code&gt;JNull&lt;/code&gt; 입니다. &lt;code&gt;kind&lt;/code&gt; 접근 자를 사용하여이 객체 변형의 종류를 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ab71cca6be976e0916e48654c757813ac229024a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.</source>
          <target state="translated">&lt;code&gt;parsecfg&lt;/code&gt; 의 모듈 구현하는 고성능 구성 파일 파서. 구성 파일의 구문은 Windows &lt;code&gt;.ini&lt;/code&gt; 형식 과 유사 하지만 라인 기반 파서가 아니기 때문에 훨씬 더 강력합니다. Nim 프로그래밍 언어 에서처럼 문자열 리터럴, 원시 문자열 리터럴 및 삼중 따옴표로 묶인 문자열 리터럴이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">&lt;code&gt;parsecfg&lt;/code&gt; 의 모듈 구현하는 고성능 구성 파일 파서. 구성 파일의 구문은 Windows &lt;code&gt;.ini&lt;/code&gt; 형식 과 비슷 하지만 라인 기반 파서가 아니기 때문에 훨씬 강력합니다. 문자열 리터럴, 원시 문자열 리터럴 및 삼중 따옴표 문자열 리터럴은 Nim 프로그래밍 언어에서와 같이 지원됩니다. 이것은 구성 파일의 모양에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">&lt;code&gt;parsesql&lt;/code&gt; 의 모듈 구현하는 고성능 SQL 파일 파서. PostgreSQL 구문과 SQL ANSI 표준을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passC&lt;/code&gt; 의 프라그는 사용자가 명령 줄 스위치를 사용하는 것처럼 C 컴파일러에 추가 매개 변수를 전달하는 데 사용할 수 있습니다 &lt;code&gt;--passC&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="0a226dc1945e0a231e4a09243e7cbc55428953d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like one would be using the command-line switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt; 의 래그는 하나의 명령 행 스위치 사용하는 것처럼 링커에 추가 파라미터를 전달하는데 사용될 수 &lt;code&gt;--passL&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt; 의 프라그는 사용자가 명령 줄 스위치를 사용하는 것처럼 링커에 추가 매개 변수를 전달하는 데 사용할 수 있습니다 &lt;code&gt;--passL&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="3d5b5550832a02a497dde295f605b34a81b96e37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like one would using the command-line switch &lt;code&gt;--passc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passc&lt;/code&gt; 의 래그는 하나의 커맨드 라인 스위치 이용한 것 같은 C 컴파일러의 추가 파라미터를 전달하는데 사용될 수 &lt;code&gt;--passc&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt; 기능은 자체에 이벤트를 반환하지 않습니다. 대신 적절한 &lt;code&gt;Future&lt;/code&gt; 객체가 완성됩니다. &lt;code&gt;Future&lt;/code&gt; 아직 사용할 수없는 값을 보유하고 있지만, 어떤이 유형입니다 &lt;em&gt;수 있습니다&lt;/em&gt; 미래에 사용할 수 있습니다. &lt;code&gt;finished&lt;/code&gt; 기능 을 사용하여 미래의 완료 여부를 확인할 수 있습니다 . 미래가 완료되면 보유하고있는 값을 사용할 수 있거나 대신 오류가 발생 함을 의미합니다. 후자의 상황은 미래를 완료하기위한 조작이 예외로 실패 할 때 발생합니다. &lt;code&gt;failed&lt;/code&gt; 기능으로 두 상황을 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; 프라그는 선언 사용자 정의 프라그 마를로 사용할 수 있습니다. 이것은 Nim의 템플릿과 매크로가 pragma에 영향을 미치지 않기 때문에 유용합니다. 사용자 정의 pragma는 다른 모든 기호와 다른 모듈 범위에 있습니다. 모듈에서 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51885e189673cb5c6386d2e95a8b73481f631054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user-defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User-defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; 프라그는 사용자 정의 프라그 마를를 선언하는 데 사용할 수 있습니다. 이것은 Nim의 템플릿과 매크로가 pragma에 영향을주지 않기 때문에 유용합니다. 사용자 정의 pragma는 다른 모든 기호와 다른 모듈 전체 범위에 있습니다. 모듈에서 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">&lt;code&gt;readCfgAtRuntime&lt;/code&gt; 의 PROC 지정된 파일명을 열고 돌아갑니다 &lt;code&gt;Table&lt;/code&gt; 로부터 &lt;a href=&quot;tables&quot;&gt;테이블 모듈&lt;/a&gt; . 파일 구문 분석은 &lt;a href=&quot;strutils#splitLines&quot;&gt;strutils 모듈&lt;/a&gt; 의 splitLines proc를 사용하여 유효하지 않은 데이터 또는 코너 케이스를 처리 할 때주의를 기울이지 않고 수행됩니다 . 실패 할 수있는 많은 것들이 있습니다. DRM 체계를 올바르게 구현하는 방법이 아니라 컴파일 타임에이를 실행하는 방법을 설명하는 것이 목적입니다.</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 프라그은 변수이다. 변수를 &lt;code&gt;register&lt;/code&gt; 로 선언하여 컴파일러가 변수에 빠르게 액세스하기 위해 하드웨어 레지스터에 배치해야한다는 힌트를줍니다. C 컴파일러는 일반적으로 이것을 무시하고 좋은 이유로 다음과 같이합니다. 종종 어쨌든 더 나은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a0902ad3f56f0d7c35a0065f78a040f1cd74c2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; symbol of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 &lt;code&gt;result&lt;/code&gt; 기호 .</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt; 변수는 이미 암시 적으로 'VAR 결과'로 다시 선언 할 수 있도록, 예를 들어, 동일한 이름의 일반 변수와 그림자 것, 함수의 시작 부분에 선언된다. 결과 변수는 이미 유형의 기본값으로 초기화되었습니다. 프로 시저 시작시 참조 데이터 유형은 &lt;code&gt;nil&lt;/code&gt; 아니므로 수동 초기화가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 문은 현재 프로 시저의 실행을 종료합니다. 절차에서만 허용됩니다. &lt;code&gt;expr&lt;/code&gt; 이 있으면 다음에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">&lt;code&gt;rst2tex&lt;/code&gt; 의 명령은 동일 호출 &lt;code&gt;rst2html&lt;/code&gt; , 대신 .html 중에서의 .tex 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">&lt;code&gt;scanp&lt;/code&gt; 는 구문 분석을 수행 님 코드로 문법 코드를 매핑합니다. 구문 분석은 사용자 정의 유형에 대해 구현할 수있는 3 개의 도우미 템플릿을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5a60747c9b966d14e1f72bd788f5ee6cfb1876ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; operation will block until number of unprocessed items is less than &lt;code&gt;maxItems&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 되지 않은 항목의 수보다 작을 때까지 작업이 차단됩니다 &lt;code&gt;maxItems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5376cae9b12713da42c8c136f625062e3841b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sep&lt;/code&gt; (default: &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;) is used for the path normalizations, this can be useful to ensure the relative path only contains &lt;code&gt;'/'&lt;/code&gt; so that it can be used for URL constructions.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; (기본값 : &lt;a href=&quot;#DirSep&quot;&gt;DirSep가&lt;/a&gt; ) 경로 정상화에 사용되는,이 상대 경로를 확인하는 것이 유용 할 수 있습니다 만 포함 &lt;code&gt;'/'&lt;/code&gt; 그래서 URL 구조물에 사용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">&lt;code&gt;sets&lt;/code&gt; 구현에게 효율적인 모듈 &lt;span id=&quot;hash-set_1&quot;&gt;해시 세트&lt;/span&gt; 및 정렬 해시 세트를.</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; pragma는 유형의 의미에 영향을 컴파일러가 얕은 복사본을 만들 수 있습니다. 이로 인해 심각한 의미 문제가 발생하고 메모리 안전이 손상 될 수 있습니다! 그러나 Nim의 시맨틱은 시퀀스와 문자열의 깊은 복사가 필요하기 때문에 할당 속도를 상당히 높일 수 있습니다. 특히 트리 구조를 만드는 데 시퀀스를 사용하는 경우 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="70490801fb19f53b61e82f0f32ef054d04c4ee37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sink&lt;/code&gt; and &lt;code&gt;lent&lt;/code&gt; annotations allow us to remove most (if not all) superfluous copies and destructions.</source>
          <target state="translated">&lt;code&gt;sink&lt;/code&gt; 및 &lt;code&gt;lent&lt;/code&gt; 주석 우리가 (모든 경우) 대부분의 불필요한 복사와 멸망을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a94cc1faa9d7174f44a4b0eb96e7b131e94500a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std/monotimes&lt;/code&gt; module implements monotonic timestamps. A monotonic timestamp represents the time that has passed since some system defined point in time. The monotonic timestamps are guaranteed to always increase, meaning that that the following is guaranteed to work:</source>
          <target state="translated">&lt;code&gt;std/monotimes&lt;/code&gt; 모듈 구현 단조 타임 스탬프. 단조로운 타임 스탬프는 시스템 정의 시점 이후 경과 된 시간을 나타냅니다. 단조로운 타임 스탬프는 항상 증가하도록 보장됩니다. 즉, 다음이 작동하도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3e0473bd0e810149a939133acc83ef43055abcf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode.</source>
          <target state="translated">&lt;code&gt;strtabs&lt;/code&gt; 은 구현을 문자열로 문자열에서 매핑이 효율적인 해시 테이블을 모듈. 대소 문자 구분, 대소 문자 구분, 스타일 구분 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">&lt;code&gt;strtabs&lt;/code&gt; 은 구현을 문자열로 문자열에서 매핑이 효율적인 해시 테이블을 모듈. 대소 문자 구분, 대소 문자 구분 및 스타일 구분 모드를 지원합니다. 문자열 테이블에 대한 효율적인 문자열 대체 연산자 &lt;code&gt;%&lt;/code&gt; 도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">&lt;code&gt;sug&lt;/code&gt; Nimsuggest 명령은 파일의 어느 시점에서 가능한 완료 기호에 대한 쿼리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 모듈은 컴파일러 마법 (과 사양이 그렇게 말한다 때문에 요구가 될 수있는 물건)에 의해 지원을 필요로하는 RTL의 일부가 포함되어 있습니다. C 코드 생성기는 다른 모듈과 마찬가지로 C 코드를 생성합니다. 그러나 &lt;code&gt;addInt&lt;/code&gt; 와 같은 일부 프로 시저에 대한 호출 은 CCG에 의해 삽입됩니다. 따라서 모듈 &lt;code&gt;magicsys&lt;/code&gt; 는 테이블 (포함 &lt;code&gt;compilerprocs&lt;/code&gt; 로 표시된 모든 기호) &lt;code&gt;compilerproc&lt;/code&gt; 를 . &lt;code&gt;compilerprocs&lt;/code&gt; 생성기는 코드 생성기에 필요합니다. &lt;code&gt;magic&lt;/code&gt; PROC는 동일하지 않습니다 &lt;code&gt;compilerproc&lt;/code&gt; :의 &lt;code&gt;magic&lt;/code&gt; 발동입니다 그것의 의미 검사에 대한 요구 컴파일러 마술하는 &lt;code&gt;compilerproc&lt;/code&gt; 코드 생성기가 사용하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="f9035ba56cfa6ab02534b3ec0d96d5eab1b2f002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it, just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 모듈은 컴파일러 마법 (과 사양이 그렇게 말한다 때문에 요구가 될 수있는 물건)에 의해 지원을 필요로하는 RTL의 일부가 포함되어 있습니다. C 코드 생성기는 다른 모듈과 마찬가지로 C 코드를 생성합니다. 그러나 &lt;code&gt;addInt&lt;/code&gt; 와 같은 일부 프로 시저에 대한 호출 은 CCG에 의해 삽입됩니다. 따라서 모듈 &lt;code&gt;magicsys&lt;/code&gt; 는 테이블 (포함 &lt;code&gt;compilerprocs&lt;/code&gt; 로 표시된 모든 기호) &lt;code&gt;compilerproc&lt;/code&gt; 를 . &lt;code&gt;compilerprocs&lt;/code&gt; 는 코드 생성기에 필요합니다. &lt;code&gt;magic&lt;/code&gt; PROC는 동일하지 않습니다 &lt;code&gt;compilerproc&lt;/code&gt; :의 &lt;code&gt;magic&lt;/code&gt; 발동입니다 그것의 의미 검사에 대한 요구 컴파일러 마술하는 &lt;code&gt;compilerproc&lt;/code&gt; 코드 생성기에서 사용하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 모듈은 중요한 정의 &lt;a href=&quot;system#Natural&quot;&gt;자연&lt;/a&gt; 같은 유형 &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;하이&lt;/a&gt; 리턴 최대 값). 다른 프로그래밍 언어는 자연수에 부호없는 정수 사용을 제안 할 수 있습니다. 이것은 종종 &lt;strong&gt;현명하지 않습니다&lt;/strong&gt; : 숫자가 음수가 될 수 없기 때문에 부호없는 산술 (포장)을 원하지 않습니다. Nim의 &lt;code&gt;Natural&lt;/code&gt; 유형은 이러한 일반적인 프로그래밍 오류를 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c232a0290c3aa227f3d98a650bd1b8e5ea3f4777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values.</source>
          <target state="translated">&lt;code&gt;tables&lt;/code&gt; 모듈 구현 효율적인 변종 &lt;span id=&quot;hash-table_1&quot;&gt;해시 테이블&lt;/span&gt; (종종 이름이 &lt;span id=&quot;dictionary_1&quot;&gt;사전&lt;/span&gt; 의 키와 값의 매핑은 다른 프로그래밍 언어에서).</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">&lt;code&gt;tables&lt;/code&gt; 모듈 구현 효율적인 변종 &lt;span id=&quot;hash-table_1&quot;&gt;해시 테이블&lt;/span&gt; (종종 이름이 &lt;span id=&quot;dictionary_1&quot;&gt;사전&lt;/span&gt; 의 키와 값의 매핑은 다른 프로그래밍 언어에서). &lt;code&gt;Table&lt;/code&gt; 은 일반적인 해시 테이블 인 &lt;code&gt;CountTableRef&lt;/code&gt; 입니다. &lt;code&gt;OrderedTable&lt;/code&gt; 은 &lt;code&gt;Table&lt;/code&gt; 과 유사 하지만 삽입 순서를 기억하며 &lt;code&gt;CountTable&lt;/code&gt; 은 키에서 발생 횟수까지의 매핑입니다. Nim의 다른 모든 데이터 유형과 일관성을 유지하기 위해 &lt;strong&gt;값&lt;/strong&gt; 의미가 있습니다. 즉, &lt;code&gt;=&lt;/code&gt; 는 해시 테이블의 복사본을 수행합니다. 내용 &lt;strong&gt;참조&lt;/strong&gt; 시맨틱 사용 &lt;code&gt;Ref&lt;/code&gt; : 변형 &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt; 을 . 예를 들어, &lt;em&gt;a&lt;/em&gt; 가 테이블 인 경우 &lt;em&gt;var b = a&lt;/em&gt; 는 &lt;em&gt;b&lt;/em&gt; 를 새로운 독립 테이블로 제공 합니다. B는의 내용으로 초기화된다 . 변경 &lt;em&gt;B 것은&lt;/em&gt; 영향을주지 않습니다 및 부사장을 반대 :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb85eba1af50fa871f49d79336197980e95f5e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;task&lt;/code&gt; template that the &lt;code&gt;system&lt;/code&gt; module defines allows a NimScript file to be used as a build tool. The following example defines a task &lt;code&gt;build&lt;/code&gt; that is an alias for the &lt;code&gt;c&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; 템플릿 &lt;code&gt;system&lt;/code&gt; 모듈을 정의는 NimScript 파일을 수는 빌드 도구로 사용할 수 있습니다. 다음 예제는 &lt;code&gt;c&lt;/code&gt; 명령 의 별칭 인 작업 &lt;code&gt;build&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수는 함수가 어떤 이벤트가 준비가없는 경우 차단됩니다 (밀리 초)의 최대 수를 지정합니다. 시간 초과를 &lt;code&gt;-1&lt;/code&gt; 로 지정 하면 함수가 무기한 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수는 함수가 어떤 이벤트가 준비가없는 경우 차단됩니다 (밀리 초)의 최대 수를 지정합니다. 시간 초과를 &lt;code&gt;-1&lt;/code&gt; 로 지정 하면 함수가 무기한 차단됩니다. 사용 가능한 모든 이벤트가 &lt;code&gt;results&lt;/code&gt; 배열에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3ecbe75d06cddb5ee3e9b9b74d9adedd1918e7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; parameter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 시간 (밀리 초)은 서버로의 연결을 허용하는 파라미터 지정 이루어질 수있다.</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 시간 (밀리 초) 서버와의 연결이 가능하도록 paremeter의 지정은 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38edfa829280086eb1bbb722fc058e36f403cb03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module contains routines and types for dealing with time using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;proleptic Gregorian calendar&lt;/a&gt;. It's also available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt; 모듈은 사용 시간을 처리하기위한 루틴 및 유형을 포함 &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;예 기적 그레고리 안 달력을&lt;/a&gt; . &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;자바 스크립트 타겟&lt;/a&gt; 에도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="551c95a5e7566f1190bf74f48e874beb433d9b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module exports two similar types that are both used to represent some amount of time: &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; and &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval&lt;/a&gt;. This section explains how they differ and when one should be preferred over the other (short answer: use &lt;code&gt;Duration&lt;/code&gt; unless support for months and years is needed).</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt; : 수출 둘 다 어느 정도의 시간을 나타내는 데 사용되는 두 개의 유사한 형태의 모듈 &lt;a href=&quot;#Duration&quot;&gt;기간&lt;/a&gt; 및 &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval이를&lt;/a&gt; . 이 섹션에서는 어떻게 다른지, 어떤 것이 다른 것보다 선호되어야 하는지를 설명합니다 (짧은 대답 : 월과 년에 대한 지원이 필요하지 않은 경우 &lt;code&gt;Duration&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문은 예외를 처리 :</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;unchecked&lt;/code&gt; pragma는 같은 명명 된 배열을 표시하는 데 사용할 수있는 &lt;code&gt;unchecked&lt;/code&gt; 그 경계를 확인하지 않습니다 의미를. 이것은 종종 유연한 크기의 맞춤형 배열을 구현하는 데 유용합니다. 또한 확인되지 않은 배열은 결정되지 않은 크기의 C 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 프라그는 어떤 적용 할 수 있습니다 &lt;code&gt;object&lt;/code&gt; 유형입니다. 그것은 모든 객체의 필드가 메모리에 겹쳐져 있음을 의미합니다. 이것은 생산 &lt;code&gt;union&lt;/code&gt; 대신 &lt;code&gt;struct&lt;/code&gt; 생성 된 C / C ++ 코드를. 그런 다음 객체 선언은 상속 또는 GC'ed 메모리를 사용해서는 안되지만 현재 검사되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; pragma는 그것이를 풀다해야 컴파일러 말할 수 있습니다 &lt;span id=&quot;for_2&quot;&gt;위해&lt;/span&gt; 또는 &lt;span id=&quot;while_1&quot;&gt;동시에&lt;/span&gt; 실행 효율성을 위해 루프를 :</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; Nimsuggest 명령은 위치에 심볼의 모든 용도를 나열합니다. IDE는이를 사용하여 파일에서 기호가 사용 된 모든 위치를 찾고 동시에 모든 위치에서 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1841570b4e739b5943163d9b9857a19771bd7db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usePlus&lt;/code&gt; parameter is passed down to the &lt;code&gt;encodeUrl&lt;/code&gt; function that is used for the URL encoding of the string values.</source>
          <target state="translated">&lt;code&gt;usePlus&lt;/code&gt; 의 파라미터는 아래로 통과 &lt;code&gt;encodeUrl&lt;/code&gt; 스트링 값의 URL의 인코딩에 사용되는 기능.</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 섹션은 같은 구문을 그룹화 기반 동일한 들여 쓰기를 사용 &lt;code&gt;var&lt;/code&gt; 하거나 &lt;code&gt;let&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated">그만큼 &lt;code&gt;varargs&lt;/code&gt; 프라그은 절차 (및 절차 유형)에 적용 할 수 있습니다. Nim에게 proc이 마지막으로 지정된 매개 변수 다음에 다양한 수의 매개 변수를 사용할 수 있다고 알려줍니다. 님 문자열 값은 자동으로 C 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 타입은 모든 종류의 부재를 나타낸다. &lt;code&gt;void&lt;/code&gt; 형의 파라미터 존재하지 않는 것으로 취급되며 , 리턴 유형으로서 &lt;code&gt;void&lt;/code&gt; 는 프로 시저가 값을 리턴하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 유형은 매개 변수와 반환 형식에 대해서만 유효합니다; 다른 심볼은 &lt;code&gt;void&lt;/code&gt; 유형을 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated">그만큼 &lt;code&gt;void&lt;/code&gt; 유형은 일반적인 코드에 특히 유용합니다 :</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; pragma는 전용 변수입니다. 변수를 다음과 같이 선언합니다. &lt;code&gt;volatile&lt;/code&gt; C / C ++에서 의미하는대로 volatile (시맨틱은 C / C ++에서 잘 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated">그만큼 &lt;code&gt;warning&lt;/code&gt; pragma는 컴파일러 출력에게 주어진 내용으로 경고 메시지를 만드는 데 사용됩니다. 경고 후에 컴파일이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문 조건부 컴파일 기술을 가능하게한다. 특수한 구문 확장으로 &lt;code&gt;when&lt;/code&gt; 구문은 &lt;code&gt;object&lt;/code&gt; 정의 합니다 .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 거의 동일 &lt;code&gt;if&lt;/code&gt; 일부 예외를 제외하고 문 :</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 거의 동일 &lt;code&gt;if&lt;/code&gt; 그러나 이러한 차이와, 문 :</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 문은 유사 플랫폼 특정 코드를 작성하는 데 유용합니다 &lt;code&gt;#ifdef&lt;/code&gt; 와의 C 프로그래밍 언어 구조를.</target>
        </trans-unit>
        <trans-unit id="f95ea01eb63a864b4f10f510dd1f071edf8bc9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;code&gt;implicit block&lt;/code&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 문은 때까지 실행 &lt;code&gt;expr&lt;/code&gt; false로 평가합니다. 무한 루프는 오류가 아닙니다. &lt;code&gt;while&lt;/code&gt; 문은 &lt;code&gt;implicit block&lt;/code&gt; 열어 &lt;code&gt;break&lt;/code&gt; 문을 남길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 문은 때까지 실행 &lt;code&gt;expr&lt;/code&gt; false로 평가합니다. 끝없는 루프는 오류가 없습니다. &lt;code&gt;while&lt;/code&gt; 문은 &lt;em&gt;암시 적 블록을&lt;/em&gt; 열어서 &lt;code&gt;break&lt;/code&gt; 문 으로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 문을 대신 사용된다 &lt;code&gt;return&lt;/code&gt; 반복자의 문. 반복자에서만 유효합니다. 실행자는 반복자를 호출 한 for 루프의 본문으로 리턴됩니다. 수율은 반복 프로세스를 종료하지 않지만 다음 반복이 시작되면 실행이 반복기로 다시 전달됩니다. 반복자에 대한 섹션을 참조하십시오 (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt; 반복자 및 for 문&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="74a3a7e48222419bc7a04a33163a499728766780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but the execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 문을 대신 사용된다 &lt;code&gt;return&lt;/code&gt; 반복자의 문. 반복자에서만 유효합니다. 반복기를 호출 한 for 루프의 본문으로 실행이 반환됩니다. Yield는 반복 프로세스를 종료하지 않지만 다음 반복이 시작되면 실행이 반복기로 다시 전달됩니다. 자세한 내용은 반복기 ( &lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;반복기 및 for 문&lt;/a&gt; )에 대한 섹션을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 중위 연산자로 사용되는 경우 순서대로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 기호는 대안을 표시하는 데 사용되며 우선 순위가 가장 낮습니다. &lt;code&gt;/&lt;/code&gt; 는 파서가 지정된 순서대로 대안을 시도해야하는 순서가 지정된 선택입니다. &lt;code&gt;/&lt;/code&gt; 는 문법이 모호하지 않도록 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 연산자는 것입니다 &lt;strong&gt;하지&lt;/strong&gt; 패턴 연산자 :</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;카운트 테이블 연산자.</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;해시 테이블 연산자.</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;int 세트 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;정렬 된 해시 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;문자열 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt;문자열 테이블 연산자</target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">카운트 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블에 같은 개수의 동일한 키가 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">카운트 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 둘 다 같은 개수의 동일한 키를 포함하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 두 테이블의 내용에 동일한 키-값 쌍이 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자. &lt;code&gt;true&lt;/code&gt; 를 반환두 테이블의 내용에 동일한 키-값 쌍이 포함되어 있으면 . 삽입 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자 내용과 순서가 같으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">정렬 된 해시 테이블 의 &lt;em&gt;==&lt;/em&gt; 연산자 두 테이블이 모두 &lt;code&gt;nil&lt;/code&gt; 이거나 none이 &lt;code&gt;nil&lt;/code&gt; 이고 내용과 순서가 같으면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">&lt;em&gt;님 컴파일러는&lt;/em&gt; 또한과 RST (reStructuredText) 파일에 대한 지원이 &lt;code&gt;rst2html&lt;/code&gt; 및 &lt;code&gt;rst2tex&lt;/code&gt; 명령을. 이와 같은 문서는 처음에 RST의 방언으로 작성되어 &lt;code&gt;.. code-block:: nim&lt;/code&gt; 접두어 로 nim 소스 코드 강조 표시에 대한 지원을 추가 합니다. &lt;code&gt;code-block&lt;/code&gt; 은 C ++ 및 다른 c와 유사한 언어의 강조 표시도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;em&gt;경우 표현식은&lt;/em&gt; 다시 case 문 매우 유사합니다 :</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">&lt;em&gt;문자 유형&lt;/em&gt; 이라고 &lt;code&gt;char&lt;/code&gt; . 크기는 항상 1 바이트이므로 대부분의 UTF-8 문자를 나타낼 수 없습니다. 그러나 멀티 바이트 UTF-8 문자를 구성하는 바이트 중 하나를 나타낼 &lt;em&gt;수 있습니다&lt;/em&gt; . 그 이유는 효율성입니다. 압도적 인 대다수의 유스 케이스의 경우 UTF-8이 특별히 설계되었으므로 결과 프로그램은 여전히 ​​UTF-8을 올바르게 처리합니다. 문자 리터럴은 작은 따옴표로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="b59bbeebfabbb8d232d246b925687354b59b07ba" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;duration&lt;/em&gt; of a borrow is the span of commands beginning from the assignment to the view and ending with the last usage of the view.</source>
          <target state="translated">&lt;em&gt;기간&lt;/em&gt; 빌림의 뷰에 할당에서 시작하여보기의 마지막 사용으로 끝나는 명령의 범위이다.</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 매개 변수는 오류보고 및 파일에 인덱스 하이퍼 링크를 만드는 데 사용됩니다,하지만 당신은 메모리 스트림을 구문 분석하는 경우 여기에 빈 문자열을 전달할 수 있습니다. 경우 &lt;em&gt;파일 이름&lt;/em&gt; 과 끝 &lt;code&gt;.nim&lt;/code&gt; 확장, 문서의 제목은 기본적으로 설정됩니다 &lt;code&gt;Module filename&lt;/code&gt; . 이 기본 제목은 삽입 된 첫 번째 제목으로 대체 할 수 있지만 제목이 없으면 생성 된 색인을 미리 정의하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">&lt;em&gt;핸들러의&lt;/em&gt; 매개 변수에 대한 코드 블록으로 구성 &lt;em&gt;PegKinds&lt;/em&gt; 관심의 문법 요소를 정의. 각 블록은 구문 분석기가 문법 요소와 일치하는 텍스트를 입력하고 떠날 때 실행될 핸들러 코드를 포함 할 수 있습니다. 는 &lt;em&gt;입력&lt;/em&gt; 처리기 특정 PEG AST 노드는 다음과 같이 매칭되는 액세스 할 수 &lt;em&gt;P&lt;/em&gt; 와 같은 전체 파싱 문자열 &lt;em&gt;들&lt;/em&gt; 과의 매칭 된 텍스트 세그먼트의 위치 &lt;em&gt;들&lt;/em&gt; 과 같은 &lt;em&gt;시작&lt;/em&gt; . &lt;em&gt;휴가&lt;/em&gt; 핸들러 캔 접근 &lt;em&gt;p는&lt;/em&gt; , &lt;em&gt;들&lt;/em&gt; , &lt;em&gt;시작&lt;/em&gt; 또한 일치하는 텍스트 세그먼트의 길이와 &lt;em&gt;길이를&lt;/em&gt; . 실패한 경기의 경우&lt;em&gt;입력&lt;/em&gt; 및 &lt;em&gt;휴가&lt;/em&gt; 처리기는 &lt;em&gt;길이&lt;/em&gt; 가 -1로 설정된 상태에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">&lt;em&gt;ID는&lt;/em&gt; 길이가 달리 특정 앵커가 생성되지 않습니다, 0이 아닌 경우에만 해시 문자로 추가됩니다. 일반적으로 독립형 첫 번째 문서의 제목에 대해 빈 &lt;em&gt;id&lt;/em&gt; 값만 전달해야합니다 ( &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt; 프로 시저 에는 특별합니다 . 자세한 내용 은 &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;색인 (idx) 파일 형식&lt;/a&gt; 참조). 다른 색인 용어와 달리 제목 항목은 누적 된 버퍼의 시작 부분에 삽입되어 논리적 순서의 항목을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize가의&lt;/em&gt; 매개 변수는 2의 거듭 제곱 할 필요가있다. 당신이 사용할 수있는&lt;a href=&quot;math#nextPowerOfTwo&quot;&gt; math.nextPowerOfTwo ()&lt;/a&gt; 또는 &lt;em&gt;rightSize&lt;/em&gt; 를 하여 런타임시이를 보장 . &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; 및 &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()을&lt;/a&gt; 제외하고이 모듈의 다른 프로세서와 함께 사용하기 전에 모든 설정 변수를 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize가의&lt;/em&gt; 매개 변수는 2의 거듭 제곱 할 필요가있다. &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()를&lt;/a&gt; 사용할 수 있습니다 또는 &lt;em&gt;rightSize&lt;/em&gt; 를 하여 런타임시이를 보장 . &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt; 및 &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()을&lt;/a&gt; 제외하고이 모듈의 다른 프로세서와 함께 사용하기 전에 모든 설정 변수를 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">블록의 선언 부분에 선언 된 변수 의 &lt;em&gt;범위&lt;/em&gt; 는 선언 지점부터 블록 끝까지 유효합니다. 블록에 식별자가 다시 선언 된 두 번째 블록이 포함 된 경우이 블록 내에서 두 번째 선언이 유효합니다. 내부 블록을 떠나면 첫 번째 선언이 다시 유효합니다. 프로 시저 또는 반복자 과부하 목적으로 유효한 경우를 제외하고 동일한 블록에서 식별자를 다시 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">&lt;em&gt;조잡 인터페이싱&lt;/em&gt; 예시 용도 &lt;code&gt;.emit&lt;/code&gt; 생산하는 &lt;code&gt;using namespace&lt;/code&gt; 선언을. 대신 &lt;code&gt;namespace::identifier&lt;/code&gt; 표기법을 통해 가져온 이름을 참조하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="da93781d112d6e740e1375bf8d057a1a694aa4d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;align_1&quot;&gt;align&lt;/span&gt; pragma is for variables and object field members. It modifies the alignment requirement of the entity being declared. The argument must be a constant power of 2. Valid non-zero alignments that are weaker than other align pragmas on the same declaration are ignored. Alignments that are weaker than the alignment requirement of the type are ignored.</source>
          <target state="translated">&lt;span id=&quot;align_1&quot;&gt;정렬&lt;/span&gt; 래그 변수 및 오브젝트 필드 멤버이다. 선언되는 엔티티의 정렬 요구 사항을 수정합니다. 인수는 상수 2의 거듭 제곱이어야합니다. 동일한 선언에서 다른 align pragma보다 약한 0이 아닌 유효한 정렬은 무시됩니다. 유형의 정렬 요구 사항보다 약한 정렬은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt;백 슬래시&lt;/span&gt; 문자는 여러 가지 용도가있다. 먼저 영숫자가 아닌 문자가 뒤에 오는 경우 해당 문자가 가질 수있는 특별한 의미를 제거합니다. 이스케이프 문자로 백 슬래시를 사용하면 내부 및 외부 문자 클래스에 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated">그만큼 &lt;span id=&quot;boot_1&quot;&gt;부트&lt;/span&gt; 명령은 컴파일러 부트 스트랩, 그리고 다른 옵션을 허용합니다</target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;csource_1&quot;&gt;CSOURCE&lt;/span&gt; 명령은 설치를위한 C 소스를 작성합니다. &lt;a href=&quot;#boot-command&quot;&gt;boot 명령으로&lt;/a&gt; 전달할 때와 동일한 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bdaaec8473ada505740f8f1af6c125ef2f73898b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;csource_1&quot;&gt;CSOURCE의&lt;/span&gt; 명령은 설치를위한 C 소스를 작성합니다. &lt;a href=&quot;#commands-boot-command&quot;&gt;부팅 명령에&lt;/a&gt; 전달하는 것과 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="c53b256239da4adea364a3390858d3ee5b4d0c44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks&lt;/span&gt; pragma can be used to disable this inference for a single routine:</source>
          <target state="translated">&lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks의&lt;/span&gt; 프라그는 하나의 일상이 추론을 해제 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;for_1&quot;&gt;에 대한&lt;/span&gt; 문은 컨테이너의 요소를 반복하는 추상적 인 메커니즘입니다. 그렇게하기 위해 &lt;span id=&quot;iterator_1&quot;&gt;반복자&lt;/span&gt; 에 의존합니다 . 처럼 &lt;code&gt;while&lt;/code&gt; 문 &lt;code&gt;for&lt;/code&gt; 문 열려&lt;span id=&quot;implicit-block_1&quot;&gt; 암시 적 블록을&lt;/span&gt; &lt;code&gt;break&lt;/code&gt; 문 으로 남겨 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe의&lt;/span&gt; 주석 그렇지 않으면이 속성은 컴파일러에 의해 추정되어, gcsafe로 발동을 표시하는 데 사용할 수 있습니다. &lt;code&gt;noSideEffect&lt;/code&gt; 는 gcsafe를 의미 &lt;code&gt;gcsafe&lt;/code&gt; . 스레드를 생성하는 유일한 방법은 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;createThread&lt;/code&gt; 를 통하는 것 입니다. &lt;code&gt;spawn&lt;/code&gt; 이 일반적으로 선호되는 방법입니다. 어느 쪽이든 호출 된 proc은 &lt;code&gt;var&lt;/code&gt; 매개 변수를 사용해서는 안되며 매개 변수 중 하나에 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;closure&lt;/code&gt; 유형이 포함 되어서는 안됩니다 . &lt;em&gt;힙 공유 제한&lt;/em&gt; 이 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="263dfccfb0e868076dd90d1d32172ba6edfea6cb" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. The invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe의&lt;/span&gt; 주석 그렇지 않으면이 속성은 컴파일러에 의해 추정되어, gcsafe로 발동을 표시하는 데 사용할 수 있습니다. &lt;code&gt;noSideEffect&lt;/code&gt; 는 gcsafe를 의미 &lt;code&gt;gcsafe&lt;/code&gt; . 스레드를 만드는 유일한 방법은 &lt;code&gt;spawn&lt;/code&gt; 또는 &lt;code&gt;createThread&lt;/code&gt; 를 사용하는 것 입니다. 호출 된 proc은 &lt;code&gt;var&lt;/code&gt; 매개 변수를 사용 하지 않아야하며 매개 변수에 &lt;code&gt;ref&lt;/code&gt; 또는 &lt;code&gt;closure&lt;/code&gt; 유형이 포함 되어서는 안됩니다 . 이로 인해 &lt;em&gt;힙 공유 제한&lt;/em&gt; 이 적용 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">&lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; 옵션은 코드에서의 변경은 실행중인 프로그램에 자동으로 적용 할 수있는 특수 편집 모드를 가능하게한다. 코드 재로드는 개별 모듈의 세분성에서 발생합니다. 모듈이 다시로드되면 Nim은 코드에서 표준 변수 선언으로 초기화 된 모든 전역 변수의 상태를 유지합니다. 다시로드 할 때마다 다른 모든 최상위 코드가 반복적으로 실행됩니다. 이 동작을 방지하려면 &lt;code&gt;once&lt;/code&gt; 구문 으로 코드 블록을 보호 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">&lt;span id=&quot;koch_1&quot;&gt;코흐&lt;/span&gt; 프로그램은 님의 유지 보수 스크립트입니다. 이식성이 뛰어나다는 장점으로 make 및 shell 스크립팅을 대체합니다. &lt;em&gt;koch&lt;/em&gt; 라는 단어 는 독일어로 &lt;em&gt;요리&lt;/em&gt; 하는 것을 의미 합니다. &lt;code&gt;koch&lt;/code&gt; 는 주로 Nim 컴파일러를 빌드하는 데 사용되지만 다른 작업에도 사용할 수 있습니다. 이 문서는 지원되는 명령 및 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; 디렉토리는 컴파일시에 생성되고 백엔드 대상에 따라 중 일시적 또는 최종 파일을 개최한다. 디렉토리의 기본 이름은 사용 된 백엔드 및 OS에 따라 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;컴파일러 스위치&lt;/a&gt; 를 사용하여 디렉토리 를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bf656e3ee386275c0b9697fe2e8bc71b022ce8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; 디렉토리는 컴파일시에 생성되고 백엔드 대상에 따라 중 일시적 또는 최종 파일을 개최한다. 디렉토리의 기본 이름은 사용 된 백엔드와 OS에 따라 &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt;컴파일러 스위치&lt;/a&gt; 를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">&lt;span id=&quot;parameter-constraint_1&quot;&gt;매개 변수 제약 조건&lt;/span&gt; 표현식은 연산자를 사용할 수 있습니다 &lt;code&gt;|&lt;/code&gt; (또는) &lt;code&gt;&amp;amp;&lt;/code&gt; (및) &lt;code&gt;~&lt;/code&gt; (not) 및 다음 술어 :</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">&lt;span id=&quot;pushslashpop_1&quot;&gt;푸시 / 팝&lt;/span&gt; 프라그 마를는 옵션 지시어와 매우 유사하지만, 일시적으로 설정을 재정의하는 데 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">&lt;span id=&quot;slice_1&quot;&gt;조각&lt;/span&gt; 도트를 포함하는 다른 토큰보다 우선 .. 연산자 {...}은 세 토큰 {...} 아닌 두 {토큰이다..}.</target>
        </trans-unit>
        <trans-unit id="93730bf4352ebc6a6c5b5cf40a7c97e98830ae75" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;code&gt;formatstr&lt;/code&gt; and returns a modified &lt;code&gt;formatstr&lt;/code&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_1&quot;&gt;교체&lt;/span&gt; 의 조작을 수행 문자열 치환 &lt;code&gt;formatstr&lt;/code&gt; 복귀 변형 &lt;code&gt;formatstr&lt;/code&gt; . 이를 종종 &lt;span id=&quot;string-interpolation_1&quot;&gt;문자열 보간&lt;/span&gt; 이라고 &lt;span id=&quot;string-interpolation_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_1&quot;&gt;교체&lt;/span&gt; 의 조작을 수행 문자열 치환 &lt;em&gt;formatstr&lt;/em&gt; 복귀 변형 &lt;em&gt;formatstr&lt;/em&gt; . 이것을 종종 &lt;span id=&quot;string-interpolation_1&quot;&gt;문자열 보간&lt;/span&gt; 이라고 &lt;span id=&quot;string-interpolation_1&quot;&gt;합니다.&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_2&quot;&gt;교체&lt;/span&gt; 의 조작을 수행 문자열 치환 &lt;em&gt;formatstr&lt;/em&gt; 복귀 변형 &lt;em&gt;formatstr&lt;/em&gt; . 이것은 종종 불린다&lt;span id=&quot;string-interpolation_2&quot;&gt; 문자열 보간 합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="171382137ee71e60fb08ca9fefa65698e106ef9b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">&lt;span id=&quot;test_1&quot;&gt;테스트&lt;/span&gt; 명령은 별칭으로 호출 할 수 있습니다 &lt;code&gt;tests&lt;/code&gt; . 이 명령은 Nim 테스트 스위트의 주요 드라이버 인 &lt;code&gt;testament/tester.nim&lt;/code&gt; 을 컴파일하고 실행 합니다. &lt;code&gt;test&lt;/code&gt; 명령에 옵션을 전달할 수 있으며 테스터에게 전달됩니다. 사용 가능한 옵션은 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">&lt;span id=&quot;test_1&quot;&gt;테스트&lt;/span&gt; 명령은 별칭으로 호출 할 수 있습니다 &lt;code&gt;tests&lt;/code&gt; . 이 명령은 Nim 테스트 스위트의 주요 드라이버 인 &lt;code&gt;tests/testament/tester.nim&lt;/code&gt; 을 컴파일하고 실행 합니다 . 당신은 옵션을 전달할 수 있습니다 &lt;code&gt;test&lt;/code&gt; 명령에 전달하면 테스터에게 전달됩니다. 사용 가능한 옵션에 대해서는 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;web_1&quot;&gt;웹&lt;/span&gt; 명령에 문서 변환 &lt;code&gt;doc&lt;/code&gt; HTML에 처음부터 디렉토리를. 또한 동일한 작업을 반복하지만 결과를 &lt;code&gt;web/upload&lt;/code&gt; 에 배치하여 &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt; 웹 사이트를 업데이트하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; paramater 정적 분석을 위해 충분하지만, 십오 갖는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 는 사용자가 여전히 라인 입력의 중간에있을 수있다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;--trackDirty&lt;/code&gt; 스위치 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97375906f1b0145ecfd52bd809ab81d76021e6e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">&lt;strong&gt;파일&lt;/strong&gt; 파라미터는 정적 분석을 위해 충분하지만, 십오 갖는 경향이 &lt;em&gt;저장되지 않은 버퍼&lt;/em&gt; 는 사용자가 여전히 라인 입력의 중간에있을 수있다. 이러한 상황에서 IDE는 현재 내용을 임시 파일에 저장 한 다음 &lt;code&gt;--trackDirty&lt;/code&gt; 스위치 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">API는 &lt;strong&gt;사용하기 쉽고&lt;/strong&gt; 일관 되도록 설계되었습니다 . 사용의 용이성은 구체적인 높은 수준의 행동을 달성하기위한 호출 횟수로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="24ff78d14078efdde3aa0c8a6fca83e77761f981" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high-level action.</source>
          <target state="translated">API는 &lt;strong&gt;사용하기 쉽고&lt;/strong&gt; 일관성 이 있도록 설계되었습니다 . 사용 편의성은 구체적이고 높은 수준의 작업을 수행하기위한 호출 수로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">API는 AST diffing 개념을 수용해야합니다 . 세부 사항 은 모듈 &lt;code&gt;macrocache&lt;/code&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated">님의 마지막</target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">C와 같은 백엔드는 임시 &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; 또는 &lt;code&gt;.m&lt;/code&gt; 파일을 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리에 배치합니다. 이 파일의 이름은 &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt; 패턴을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">목표와 같은 C</target>
        </trans-unit>
        <trans-unit id="898583fdf4f7e2148aa36867bf4bb2102ecd496c" translate="yes" xml:space="preserve">
          <source>The CPU this build is running on. Can be different from &lt;code&gt;system.hostCPU&lt;/code&gt; for cross compilations.</source>
          <target state="translated">이 빌드가 실행중인 CPU입니다. 교차 컴파일의 경우 &lt;code&gt;system.hostCPU&lt;/code&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">CellSet 데이터 구조</target>
        </trans-unit>
        <trans-unit id="79e6163dcab816483c82583cef72dec94ae2b158" translate="yes" xml:space="preserve">
          <source>The DOMException interface represents an abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. Each exception has a name, which is a short &quot;CamelCase&quot; style string identifying the error or abnormal condition. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</source>
          <target state="translated">DOMException 인터페이스는 메서드를 호출하거나 웹 API의 속성에 액세스 한 결과로 발생하는 비정상 이벤트 (예외라고 함)를 나타냅니다. 각 예외에는 오류 또는 비정상 상태를 식별하는 짧은 &quot;CamelCase&quot;스타일 문자열 인 이름이 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d4429a0786a309aa9d6b7928dc3d572fde709" translate="yes" xml:space="preserve">
          <source>The Debian package ships bash and ksh completion and manpages that can be reused.</source>
          <target state="translated">Debian 패키지는 재사용 할 수있는 bash 및 ksh 완성 및 맨 페이지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">DevkitPro 설정은 &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;Mac / Linux의&lt;/a&gt; 경우 &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;여기&lt;/a&gt; 또는 Windows의 경우 새 설치 프로그램의 기본값과 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1008adfd15b693fe20b376424382af8c8cea0aa1" translate="yes" xml:space="preserve">
          <source>The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</source>
          <target state="translated">FileReader 개체를 사용하면 웹 응용 프로그램이 File 또는 Blob 개체를 사용하여 읽을 파일 또는 데이터를 지정하여 사용자 컴퓨터에 저장된 파일 (또는 원시 데이터 버퍼)의 내용을 비동기 적으로 읽을 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80c27958dc268e2a60ebe42e3d8ceaa6b5e10f68" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversal leads to undefined behaviour.</source>
          <target state="translated">GC는 포인터 세트를 저장하는 데 매우 효율적인 데이터 구조에 의존 합니다. 소스 코드 에서는 &lt;code&gt;TCellSet&lt;/code&gt; 이라고합니다 . 삽입, 삭제, 검색은 일정한 시간에 이루어집니다 .. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 그러나 순회 중에 &lt;code&gt;TCellSet&lt;/code&gt; 를 수정하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">GC는 포인터 세트를 저장하기위한 매우 효율적인 데이터 구조에 의존 합니다.이를 소스 코드에서 &lt;code&gt;TCellSet&lt;/code&gt; 이라고합니다 . 삽입, 삭제 및 검색은 일정한 시간에 수행됩니다. 그러나 순회 중에 &lt;code&gt;TCellSet&lt;/code&gt; 을 수정하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">GC는 메모리 할당 작업에서만 트리거됩니다. 일부 타이머에 의해 트리거되지 않으며 백그라운드 스레드에서 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">GC의 시간 측정 방법 ( 구현 은 &lt;code&gt;lib/system/timers.nim&lt;/code&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated">가비지 콜렉터</target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">IEEE 예외는 런타임시 무시되거나 Nim 예외 &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt; 및 &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError로 매핑&lt;/span&gt; 됩니다. 이러한 예외는 &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; 기본 클래스 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffdbe4b37fb48c6e771a9c49f384954abf693614" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored during execution or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt;, &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt;, &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt;, &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt;, and &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt; base class.</source>
          <target state="translated">IEEE 예외는 실행 중에 무시되거나 Nim 예외 ( &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt; , &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt; , &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt; , &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt; 및 &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect)에 매핑&lt;/span&gt; 됩니다. 이러한 예외는 &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt; 기본 클래스 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">IEEE 표준은 5 가지 유형의 부동 소수점 예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">JS 대상은 실제로 &lt;code&gt;node.js&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">자바 스크립트 타겟</target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">JavaScript 대상에는 가비지 수집 기능이 있으므로 인터페이스에 대한 추가 고려 사항이 없지만 C 대상을 사용하려면 &lt;code&gt;NimMain&lt;/code&gt; 함수를 호출하여 Nim의 내부를 초기화해야합니다 . 또한 C 코드에서는 함수에 대해 순방향 선언을 지정해야합니다. 그렇지 않으면 컴파일러가 런타임에 프로그램 충돌을 일으킬 수있는 반환 값 및 매개 변수에 특정 유형을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="665d7845877047d3fa57ee16acbc8e493af72754" translate="yes" xml:space="preserve">
          <source>The MinGW-w64 toolchain can be installed as follows:</source>
          <target state="translated">MinGW-w64 툴체인은 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Nim 컴파일러와 표준 라이브러리의 대부분은 테 인트 모드를 지원합니다. 입력 문자열은 &lt;code&gt;system&lt;/code&gt; 모듈에 선언 된 &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; 문자열 유형으로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim 컴파일러는 &lt;code&gt;--header&lt;/code&gt; 명령 행 스위치를 통해 C 인터페이스 헤더를 생성 할 수 있습니다 . 생성 된 헤더에는 내 보낸 모든 심볼과 다른 Nim 코드보다 먼저 호출해야하는 &lt;code&gt;NimMain&lt;/code&gt; proc이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fd2ac310a54aa34b040fb3ce9d0aae68630ca11b" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command-line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim 컴파일러는 &lt;code&gt;--header&lt;/code&gt; 명령 줄 스위치를 통해 C 인터페이스 헤더를 생성 할 수 있습니다 . 생성 된 헤더에는 내 보낸 모든 기호와 다른 Nim 코드보다 먼저 호출해야하는 &lt;code&gt;NimMain&lt;/code&gt; proc이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Nim 컴파일러는 &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt; 및 &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; 메시지 와 같은 다른 종류의 메시지를 생성 합니다. &lt;em&gt;오류&lt;/em&gt; 컴파일러는 정전기가 발생하면 에러 메시지가 방출된다.</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Nim 컴파일러에는 간단한 선형 방정식 솔버가 포함되어있어 정수 산술이 관련된 일부 상황에서 정적 매개 변수를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580ec25bc986f0f51e4fc221c0aaeef6db0aa21e" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files that can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone Node.js program&lt;/a&gt;.</source>
          <target state="translated">Nim 컴파일러는 주로 C, C ++ 및 Objective-C 타겟과 JavaScript 타겟의 두 가지 백엔드 제품군을 지원합니다. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;C 유사 타겟&lt;/a&gt; 은 라이브러리 또는 최종 실행 파일로 컴파일 할 수있는 소스 파일을 생성합니다. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript 타겟&lt;/a&gt; 은 HTML 파일에서 참조 하는 &lt;code&gt;.js&lt;/code&gt; 파일을 생성하거나 &lt;a href=&quot;http://nodejs.org&quot;&gt;독립형 Node.js 프로그램을&lt;/a&gt; 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Nim 컴파일러는 주로 C, C ++ 및 Objective-C 대상과 JavaScript 대상의 두 가지 백엔드 제품군을 지원합니다. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;C like 대상&lt;/a&gt; 은 라이브러리 또는 최종 실행 파일로 컴파일 할 수있는 소스 파일을 만듭니다. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript 대상&lt;/a&gt; 은 HTML 파일에서 참조 하는 &lt;code&gt;.js&lt;/code&gt; 파일을 생성하거나 &lt;a href=&quot;http://nodejs.org&quot;&gt;독립형 nodejs 프로그램을&lt;/a&gt; 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Nim 컴파일러는 간단하지만 강력한 내장 템플릿 시스템으로서 소스 코드 필터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Nim 컴파일러는 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리 에서 생성 된 소스 파일을 &lt;code&gt;libfib.nim.a&lt;/code&gt; 정적 라이브러리로 링크하는 작업을 처리하며,이 라이브러리를 C 프로그램에 연결할 수 있습니다. 이 명령은 일반적이며 각 시스템마다 다릅니다. 예를 들어, Linux 시스템 에서는 필요한 dlopen 기능으로 링크 하기 위해 &lt;code&gt;-ldl&lt;/code&gt; 도 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Nim 라이브러리는 과부하를 많이 사용합니다. 그 이유 중 하나는 &lt;code&gt;+&lt;/code&gt; 와 같은 각 연산자 가 오버로드 된 프로 시저이기 때문입니다. 파서는 당신이 연산자를 사용할 수 있습니다 &lt;em&gt;중위 표기&lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; ) 또는 &lt;em&gt;접두사 표기법&lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ). 접두사 연산자는 항상 두 개의 인수를받습니다. 접두사 연산자는 항상 하나입니다. 이 모호한 것이기 때문에 (후위 연산자는, 불가능 : 않습니다 &lt;code&gt;a @ @ b&lt;/code&gt; 평균 &lt;code&gt;(a) @ (@b)&lt;/code&gt; 나 &lt;code&gt;(a@) @ (b)&lt;/code&gt; 그것은 항상 수단? &lt;code&gt;(a) @ (@b)&lt;/code&gt; 때문에 Nim에는 postfix 연산자가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">Nim 매뉴얼은 적절한 사양으로 발전 할 수있는 초안입니다.</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">Nim 프로그래밍 언어에는 Posix의 신호 처리 메커니즘에 대한 개념이 없습니다. 그러나 표준 라이브러리는 신호 처리를위한 기본적인 지원을 제공합니다. 특히 세그먼트 오류는 치명적인 오류로 바뀌어 스택 추적을 생성합니다. &lt;code&gt;-d:noSignalHandler&lt;/code&gt; 스위치를 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Nim 프로젝트의 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6e9fcfbb1521eca0d91e310af54c8a9ca576233" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;code&gt;addQuoted&lt;/code&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim 표준 라이브러리는 컬렉션의 문자열 표현을 생성 할 때 컬렉션의 요소에이 함수를 사용합니다. 사용자 측 컬렉션에도이 기능을 사용하는 것이 좋습니다. 사용자가 사용자 정의 된 요소 표현을 구현하려는 경우 사용자 정의 (문자열 유사) 유형에 대해 &lt;code&gt;addQuoted&lt;/code&gt; 를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim 표준 라이브러리는 컬렉션의 문자열 표현을 생성 할 때 컬렉션의 요소에서이 기능을 사용합니다. 사용자측 컬렉션에도이 기능을 사용하는 것이 좋습니다. 사용자 정의 된 요소 표현을 구현하려는 경우 사용자 정의 (문자열 유사) 유형에 대해 &lt;em&gt;addQuoted&lt;/em&gt; 를 오버로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Nim 튜토리얼 1 부에서는 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a8d8335d9b3a51e4f9b6b4bc2ad95a64b07b034f" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part three about Nim's macro system.</source>
          <target state="translated">Nim의 매크로 시스템에 대한 Nim 튜토리얼 3 부.</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Nim 튜토리얼 2 부에서는 고급 언어 구성을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b72a9ce64dd38ff10ea38449cca0b32423b2c372" translate="yes" xml:space="preserve">
          <source>The OS this build is running on. Can be different from &lt;code&gt;system.hostOS&lt;/code&gt; for cross compilations.</source>
          <target state="translated">이 빌드가 실행되는 OS입니다. 교차 컴파일의 경우 &lt;code&gt;system.hostOS&lt;/code&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">PEG 파서는이 문법을 구현합니다 (PEG 구문으로 작성).</target>
        </trans-unit>
        <trans-unit id="31c92217046cc780ba133dace9f5c246558e7313" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="translated">결과 Socket과 연결된 SocketHandle은 기본적으로 자식 프로세스에서 상속 할 수 없습니다. &lt;code&gt;inheritable&lt;/code&gt; 매개 변수 를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9ef66e58383b86b1407d1c272ce0bbbbecb587b" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="translated">결과 클라이언트와 연결된 SocketHandle은 기본적으로 자식 프로세스에서 상속 할 수 없습니다. &lt;code&gt;inheritable&lt;/code&gt; 매개 변수 를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a7b54829d9f17c2be9946ef0258220a08c1d2b0" translate="yes" xml:space="preserve">
          <source>The System module imports several separate modules, and their documentation is in separate files:</source>
          <target state="translated">시스템 모듈은 여러 개의 개별 모듈을 가져 오며 해당 설명서는 별도의 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac5ab7831528adadcc8d1ce6127667976cfbd3e6" translate="yes" xml:space="preserve">
          <source>The ability to access and modify compile-time variables adds flexibility to constant expressions that may be surprising to those coming from other statically typed languages. For example, the following code echoes the beginning of the Fibonacci series &lt;strong&gt;at compile-time&lt;/strong&gt;. (This is a demonstration of flexibility in defining constants, not a recommended style for solving this problem!)</source>
          <target state="translated">컴파일 시간 변수에 액세스하고 수정할 수있는 기능은 다른 정적으로 형식화 된 언어에서 오는 것에는 놀랄 수있는 상수 표현식에 유연성을 추가합니다. 예를 들어, 다음 코드는 &lt;strong&gt;컴파일 타임에&lt;/strong&gt; 피보나치 시리즈의 시작을 반영합니다 . (이것은이 문제를 해결하는 데 권장되는 스타일이 아니라 상수 정의의 유연성을 보여주는 것입니다!)</target>
        </trans-unit>
        <trans-unit id="8c5bb6b0158c6a354819839862ad897994206f74" translate="yes" xml:space="preserve">
          <source>The ability to override a hook leads to a phase ordering problem:</source>
          <target state="translated">후크를 재정의하는 기능으로 인해 단계 순서 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated">위의 &lt;code&gt;debug&lt;/code&gt; 매크로는 &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 이 시스템 모듈에 선언되어 인스턴스화 컨텍스트에서 볼 수 있다는 사실에 의존합니다 . 언 바운드 식별자를 사용하는 대신 바인딩 된 식별자 (일명 &lt;span id=&quot;symbols_1&quot;&gt;symbol&lt;/span&gt; ) 를 사용하는 방법이 있습니다 . &lt;code&gt;bindSym&lt;/code&gt; 의 내장은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9a16d09084424b9bb5554f6882e18d7b658ef4d4" translate="yes" xml:space="preserve">
          <source>The above code fails with the error message that &lt;code&gt;p&lt;/code&gt; is not declared. The reason for this is that the &lt;code&gt;p()&lt;/code&gt; body is type-checked before getting passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">위 코드는 &lt;code&gt;p&lt;/code&gt; 가 선언되지 않았다는 오류 메시지와 함께 실패합니다 . 그 이유는 &lt;code&gt;p()&lt;/code&gt; 본문이 &lt;code&gt;body&lt;/code&gt; 매개 변수에 전달되기 전에 유형 검사를 받고 Nim의 유형 검사는 기호 조회를 의미하기 때문입니다. 전달 된 본문은 유형 검사가 필요하지 않으므로 동일한 코드가 &lt;code&gt;untyped&lt;/code&gt; 에서도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">위의 코드는 &lt;code&gt;i&lt;/code&gt; 이미 선언 한 신비한 오류 메시지와 함께 실패합니다 . 그 이유는 &lt;code&gt;var i = ...&lt;/code&gt; body가 &lt;code&gt;body&lt;/code&gt; 매개 변수 로 전달되기 전에 형식 검사가 필요하고 Nim의 형식 검사는 기호 조회를 의미 하기 때문 입니다. 심볼 조회가 성공하려면 &lt;code&gt;i&lt;/code&gt; 현재 (즉, 외부) 범위에 추가해야합니다. 유형 점검 후 기호 테이블에 대한 이러한 추가는 롤백되지 않습니다 (더 나은지 또는 더 나쁜지). 전달 된 본문을 유형 확인하지 않아도되므로 동일한 코드가 &lt;code&gt;untyped&lt;/code&gt; 에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">위 코드는 다음과 같이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">위의 예제는 c2nim 이 이러한 정의를 &lt;em&gt;처리&lt;/em&gt; 하고 확장하도록 c2nim의 &lt;code&gt;#def&lt;/code&gt; 지시문을 사용하여 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">위 모듈은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;*&lt;/code&gt; 을 내보내 지만 &lt;code&gt;y&lt;/code&gt; 는 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">위의 출력은 다음과 같은 코드 스 니펫의 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="250cc0bde21eb567c889e1e1664f7d10ce17f191" translate="yes" xml:space="preserve">
          <source>The abstract base type of all loggers.</source>
          <target state="translated">모든 로거의 추상 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated">가드 &lt;code&gt;x.L&lt;/code&gt; 이 활성화되어 있으므로 &lt;code&gt;x.v&lt;/code&gt; 필드에 액세스 할 수 있습니다. 템플릿 확장 후, 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated">가산기 연산자</target>
        </trans-unit>
        <trans-unit id="d8dbffc47ece2be660786dac5e5599bb2db4ec50" translate="yes" xml:space="preserve">
          <source>The algorithm behind this analysis is described in the &lt;a href=&quot;#view-types-algorithm&quot;&gt;view types section&lt;/a&gt;.</source>
          <target state="translated">이 분석의 알고리즘은 &lt;a href=&quot;#view-types-algorithm&quot;&gt;뷰 유형 섹션에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">모듈 컴파일 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">알고리즘은 연속 분수 이론을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="7b81a299b4d6a7c6527f2f9089e8efaf8aa777c1" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; 를 사용 하여 공유 힙에서 할당 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f3c558bc48c770919c504ee5c6a21e8e07e4d60" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! 공유 힙에서 할당 하려면 &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7e743ac1a73193134433b9e2665ee58685338dd" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! 공유 힙에서 할당 하려면 &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3aa58ae727a722325206dd1c096f46b46d2c14b" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! 공유 힙에서 할당 하려면 &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c822d98d0919ddf989461e7416cedbec8f1ed4d7" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! 공유 힙에서 재 할당 하려면 &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6d2e95c77763501f5d08aba1067373c7bd297c8" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="translated">할당 된 메모리는 할당 스레드에 속합니다! &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt; 를 사용 하여 공유 힙에서 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="9e814504ef907959dbfcf0c83b97cf43f9dcf6be" translate="yes" xml:space="preserve">
          <source>The amount of available functions is much larger. Use the table of contents on the left-hand side and/or &lt;code&gt;Ctrl+F&lt;/code&gt; to navigate through this module.</source>
          <target state="translated">사용 가능한 기능의 양이 훨씬 큽니다. 왼쪽의 목차 및 / 또는 &lt;code&gt;Ctrl+F&lt;/code&gt; 를 사용하여이 모듈을 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="a9ba690f34c8a341aefa7154f4cab877c7806570" translate="yes" xml:space="preserve">
          <source>The amount of inserted spaces for each tab character is the difference between the current column number and the next tab position. Tab positions occur every &lt;code&gt;tabSize&lt;/code&gt; characters. The column number starts at 0 and is increased with every single character and inserted space, except for newline, which resets the column number back to 0.</source>
          <target state="translated">각 탭 문자에 대해 삽입 된 공백의 양은 현재 열 번호와 다음 탭 위치의 차이입니다. 탭 위치는 &lt;code&gt;tabSize&lt;/code&gt; 문자 마다 발생 합니다. 열 번호는 0에서 시작하고 열 번호를 다시 0으로 재설정하는 개행을 제외하고 모든 단일 문자 및 삽입 된 공백으로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="250c5ff56778e008023b7651ae2048c87b91ec39" translate="yes" xml:space="preserve">
          <source>The analysis is currently control flow insensitive:</source>
          <target state="translated">분석은 현재 제어 흐름에 민감하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b75eefe3dbc4504e1b5e9c31e816f67ebe1b353" translate="yes" xml:space="preserve">
          <source>The analysis requires as much precision about mutations as is reasonably obtainable, so it is more effective with the experimental &lt;a href=&quot;#strict-funcs&quot;&gt;strict funcs&lt;/a&gt; feature. In other words &lt;code&gt;--experimental:views&lt;/code&gt; works better with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="translated">분석에는 합리적으로 얻을 수있는만큼의 돌연변이에 대한 정밀도가 필요하므로 실험적 &lt;a href=&quot;#strict-funcs&quot;&gt;엄격한&lt;/a&gt; 기능 기능으로 더 효과적입니다 . 즉, &lt;code&gt;--experimental:views&lt;/code&gt; 는 &lt;code&gt;--experimental:strictFuncs&lt;/code&gt; 와 함께 더 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0cb382e7222271bd8b9818e2c22f1b22c1d23882" translate="yes" xml:space="preserve">
          <source>The assignment of a location that is derived from a local parameter to a view-type.</source>
          <target state="translated">로컬 매개 변수에서 파생 된 위치를 뷰 유형에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b5ef3590f8b622cbd763976b293e8b5be0c43bea" translate="yes" xml:space="preserve">
          <source>The assignment of a non-view-type to a view-type.</source>
          <target state="translated">비보기 유형을보기 유형에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">문자열 할당 연산자는 항상 문자열을 복사합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 연접 스트링.</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">문자열의 할당 연산자는 문자열을 복사합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자를 사용하여 문자열을 연결하고 문자열에 &lt;code&gt;add&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e76741ef0154f25492ed64d08d5e8f9a5bb9a741" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">튜플에 대한 할당 연산자는 각 구성 요소를 복사합니다. 개체에 대한 기본 할당 연산자는 각 구성 요소를 복사합니다. 할당 연산자의 오버로딩은 &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">튜플의 할당 연산자는 각 구성 요소를 복사합니다. 객체의 기본 할당 연산자는 각 구성 요소를 복사합니다. 할당 연산자의 오버로드는 &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">튜플의 할당 연산자는 각 구성 요소를 복사합니다. &lt;code&gt;t.field&lt;/code&gt; 표기법 은 튜플의 필드에 액세스하는 데 사용됩니다. 또 다른 표기법은 &lt;code&gt;i&lt;/code&gt; 번째 필드 에 액세스하는 &lt;code&gt;t[i]&lt;/code&gt; 입니다. 여기서 &lt;code&gt;i&lt;/code&gt; 상수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">대입 연산자는 객체 또는 고유 한 유형 &lt;code&gt;T&lt;/code&gt; 에 연결해야합니다 . 서명은 &lt;code&gt;(var T, T)&lt;/code&gt; 이어야 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated">과제 진술</target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">할당 문은 변수 또는보다 일반적으로 저장 위치에 새로운 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">비동기 디스패처는 프로 액터 패턴을 구현하고 IOCP도 구현합니다. 선택기 모듈을 통해 다른 OS에 대한 프로 액터 패턴을 구현합니다. 선물도 여기에서 구현되며 실제로 모든 절차가 미래를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">사용 가능한 부동 소수점 프리젠 테이션 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">사용 가능한 정수 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">백엔드에는 현재 처리 된 모듈이 컴파일 캐시에서 온 경우 &lt;code&gt;ast&lt;/code&gt; 필드에 액세스 할 수 없도록 몇 가지 논리가 있어야합니다 . 대신 심볼 본문에 대해 생성 된 C (++)도 캐싱하고 생성 된 C 파일에 다시 삽입해야합니다. 이 방법은 위에서 설명한 모든 문제를 해결하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">검사되지 않은 어레이의 기본 유형에는 GC 메모리가 포함되어 있지 않을 수 있지만 현재 검사되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">기본 알고리즘은 주기 감지를 사용한 &lt;em&gt;지연된 기준 계수&lt;/em&gt; 입니다. 스택의 참조는 더 나은 성능 및 더 쉬운 C 코드 생성을 위해 계산되지 않습니다. 사이클 감지는 현재 전체 (스레드 로컬 힙)를 스캔해야하는 간단한 mark &amp;amp; ​​sweep GC에 의해 수행됩니다. &lt;code&gt;--gc:v2&lt;/code&gt; 는 이것을 증분 마크와 스윕으로 대체합니다. 그러나 아직 생산 준비가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">기본 알고리즘은 주기 감지 기능 이있는 &lt;em&gt;지연 기준 계수&lt;/em&gt; 입니다. 성능 향상과 쉬운 C 코드 생성을 위해 스택의 참조는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29593df455bce4317b1e8d46d66107a58482465b" translate="yes" xml:space="preserve">
          <source>The basic flow of using this module is:</source>
          <target state="translated">이 모듈을 사용하는 기본 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated">이진 &lt;code&gt;^*&lt;/code&gt; 연산자는 두 번째 인수로 구분 된 0 개 이상의 발생에 대한 속기로 사용됩니다. 마찬가지로 &lt;code&gt;^+&lt;/code&gt; 수단은 1 이상의 어커런스 : &lt;code&gt;a ^+ b&lt;/code&gt; 약자이며 &lt;code&gt;a (b a)*&lt;/code&gt; 및 &lt;code&gt;a ^* b&lt;/code&gt; 위한 짧은 &lt;code&gt;(a (b a)*)?&lt;/code&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="838b0fbf81e65abd3b1ad6c600113a2fed59e81e" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt;.</source>
          <target state="translated">블록은 &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt; 로 해제되어야 합니다. 블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt; 보다 다소 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="8f5d0d575da00922903cac607fb2fd96251ac2cd" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">블록은 &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt; 로 해제되어야 합니다. 블록은 초기화되지 않았으므로 쓰기 전에 블록에서 읽는 것은 정의되지 않은 동작입니다!</target>
        </trans-unit>
        <trans-unit id="b3840b5815b476e7ad0468e337f35e7346b451d5" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared(block)&lt;/a&gt;.</source>
          <target state="translated">블록은 &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared (block)&lt;/a&gt; 로 해제되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="98353e7ce043623f414d9bb91bad41b576de19e8" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt;.</source>
          <target state="translated">블록은 &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt; 로 해제되어야 합니다. 블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt; 보다 다소 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="e37a54c51ba932ce88795fda3d2a30d0c461cb79" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">블록은 &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt; 로 해제되어야 합니다. 블록은 초기화되지 않았으므로 쓰기 전에 블록에서 읽는 것은 정의되지 않은 동작입니다!</target>
        </trans-unit>
        <trans-unit id="068999f6f652deacdb3f97d6673d5b7e6baf16cf" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared(block)&lt;/a&gt;.</source>
          <target state="translated">블록은 &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared (block, 0)&lt;/a&gt; 또는 &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared (block)&lt;/a&gt; 로 해제되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="63a4b678bcf75d497dac75a45beb59d65212247d" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;.</source>
          <target state="translated">블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; 보다 다소 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="2b5f58aae87fa158997bda888132721756d3cb4f" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;.</source>
          <target state="translated">블록은 0을 포함하는 모든 바이트로 초기화되므로 &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; 보다 다소 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="b47a24f074a3169393ff9b7055c7a12a147a3601" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer then realloc</source>
          <target state="translated">블록은 0을 포함하는 모든 바이트로 초기화되므로 realloc보다 다소 안전합니다.</target>
        </trans-unit>
        <trans-unit id="81438262b2b429a9e9625da21fde5d6db74d0bb7" translate="yes" xml:space="preserve">
          <source>The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">블록은 초기화되지 않았으므로 쓰기 전에 블록에서 읽는 것은 정의되지 않은 동작입니다!</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">블록 문은 명령문을 (명명 된) &lt;code&gt;block&lt;/code&gt; 으로 그룹화하는 수단 입니다. 블록 내에서 &lt;code&gt;break&lt;/code&gt; 문은 블록을 즉시 떠날 수 있습니다. &lt;code&gt;break&lt;/code&gt; 문은 떠나 어떤 블록을 지정하는 주변 블록의 이름을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated">블록 &lt;em&gt;레이블&lt;/em&gt; ( 이 예에서는 &lt;code&gt;myblock&lt;/code&gt; )은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">부울 유형의 이름 은 Nim에서 &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; 이며 미리 정의 된 두 값 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 중 하나 일 수 있습니다 . 의 조건 &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -statements이 형이 될 필요가 &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated">차용 pragma를 사용하여 고유 한 유형에 주석을 달아 특정 내장 조작을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be92dcebf622da6178429443f44552a8ca5101d2" translate="yes" xml:space="preserve">
          <source>The bounds &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; denote the indices of the first and last characters that shall be copied. If &lt;code&gt;last&lt;/code&gt; is omitted, it is treated as &lt;code&gt;high(s)&lt;/code&gt;. If &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt;, &lt;code&gt;s.len&lt;/code&gt; is used instead: This means &lt;code&gt;substr&lt;/code&gt; can also be used to &lt;span id=&quot;cut_1&quot;&gt;cut&lt;/span&gt; or &lt;span id=&quot;limit_1&quot;&gt;limit&lt;/span&gt; a string's length.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 경계 는 복사 할 첫 번째 및 마지막 문자의 색인을 나타냅니다. 경우 &lt;code&gt;last&lt;/code&gt; 생략이를 취급되어 &lt;code&gt;high(s)&lt;/code&gt; . 만약 &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt; , &lt;code&gt;s.len&lt;/code&gt; 대신 사용됩니다 :이 수단 &lt;code&gt;substr&lt;/code&gt; 에도 사용할 수 있습니다 &lt;span id=&quot;cut_1&quot;&gt;절단&lt;/span&gt; 하거나 &lt;span id=&quot;limit_1&quot;&gt;제한&lt;/span&gt; 하는 문자열의 길이를.</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated">내장 &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc은 배열의 길이를 반환합니다. &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt; 는 배열 &lt;em&gt;a에&lt;/em&gt; 대해 가장 낮은 유효한 인덱스를 반환 하고 &lt;a href=&quot;system#high&quot;&gt;high (a)&lt;/a&gt; 에 가장 높은 유효한 인덱스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9840f844923cc10024352c7ba0b3ff45a4914dcf" translate="yes" xml:space="preserve">
          <source>The builtin 'system.locals' implemented as a plugin.</source>
          <target state="translated">플러그인으로 구현 된 내장 'system.locals'.</target>
        </trans-unit>
        <trans-unit id="f452d59ca97170597b758692a3b42390c25047e4" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">내장 된 &lt;code&gt;deepCopy&lt;/code&gt; 는 클로저와 그 환경을 복제 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">내장 된 &lt;code&gt;deepCopy&lt;/code&gt; 는 클로저 및 해당 환경을 복제 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#parallel-spawn&quot;&gt;스폰&lt;/a&gt; 문서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated">내장 &lt;code&gt;system.finished&lt;/code&gt; 를 사용하여 반복자가 작업을 완료했는지 확인할 수 있습니다. 이미 작업을 완료 한 반복자를 호출하려는 시도에서는 예외가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">내장 문서 생성기 &lt;code&gt;nim doc&lt;/code&gt; 은 &lt;code&gt;.nim&lt;/code&gt; 소스 파일 에서 HTML 문서를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="1be5bb95f8a163c45d73b2bf4f448ad5d41520b0" translate="yes" xml:space="preserve">
          <source>The cache is discarded and disabled. The GC will reuse its used memory.</source>
          <target state="translated">캐시가 삭제되고 비활성화됩니다. GC는 사용 된 메모리를 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="2fc2df4285e7ce4148cd07c10af838b3599131c2" translate="yes" xml:space="preserve">
          <source>The caching of modules is critical for 'nimsuggest' and is tricky to get right. If module E is being edited, we need autocompletion (and type checking) for E but we don't want to recompile depending modules right away for faster turnaround times. Instead we mark the module's dependencies as 'dirty'. Let D be a dependency of E. If D is dirty, we need to recompile it and all of its dependencies that are marked as 'dirty'. 'nimsuggest sug' actually is invoked for the file being edited so we know its content changed and there is no need to compute any checksums. Instead of a recursive algorithm, we use an iterative algorithm:</source>
          <target state="translated">모듈 캐싱은 'nimsuggest'에 매우 중요하며 제대로하기가 까다 롭습니다. 모듈 E가 편집되는 경우 E에 대한 자동 완성 (및 유형 검사)이 필요하지만 빠른 처리 시간을 위해 모듈에 따라 즉시 재 컴파일하고 싶지 않습니다. 대신 모듈의 종속성을 '더티'로 표시합니다. D를 E의 종속성으로 두십시오. D가 더티 (dirty)이면이를 다시 컴파일해야하며 '더티'로 표시된 모든 종속성이 필요합니다. 'nimsuggest sug'는 실제로 편집중인 파일에 대해 호출되므로 해당 내용이 변경되었음을 알고 체크섬을 계산할 필요가 없습니다. 재귀 알고리즘 대신 반복 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7fee63106f29dd5e46e2f5ccdba0d7bbe8184064" translate="yes" xml:space="preserve">
          <source>The call can be made more like an inline iterator with a for loop macro:</source>
          <target state="translated">for 루프 매크로를 사용하는 인라인 반복기처럼 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">미래가 완료되면 콜백도 호출됩니다. 따라서 &lt;code&gt;finished&lt;/code&gt; 를 사용 하여 데이터가 사용 가능한지 확인 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">콜백은 다음 중 하나를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">캐럿 문자 (^)는 이스케이프 문자 또는 분리 문자로 인식되지 않습니다. 문자는 프로그램의 argv 배열로 전달되기 전에 운영 체제의 명령 행 구문 분석기에서 완전히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">case 문은 정수, 기타 서수 유형 및 문자열을 처리 할 수 ​​있습니다. (서수 유형에 대해서는 곧 설명하겠습니다.) 정수 또는 기타 서수 유형의 경우 값 범위도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="694081c9ba0ead71a23be29d98b9511f2e2c1da7" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under Windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl 규칙은 프로 시저가 C 컴파일러와 동일한 규칙을 사용해야 함을 의미합니다. Windows에서 생성 된 C 프로시 저는 &lt;code&gt;__cdecl&lt;/code&gt; 키워드로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl 규칙은 프로 시저가 C 컴파일러와 동일한 규칙을 사용해야 함을 의미합니다. 창에서 생성 된 C 프로시 저는 &lt;code&gt;__cdecl&lt;/code&gt; 키워드로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="058accd23038c62c41c53cefc9d097f2c415abea" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;메서드 호출 구문&lt;/a&gt; 덕분에 함수 연결이 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="d9e298a10b48b62e2a169d6c44a14daf34ceeedd" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;메서드 호출 구문&lt;/a&gt; 덕분에 함수 연결이 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="08aa4b50d816fd45a3310fdfe9be5b22b53c8981" translate="yes" xml:space="preserve">
          <source>The change is permanent for the rest of the execution, since this is just a shortcut for &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir()&lt;/a&gt; . Use the &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir()&lt;/a&gt; template if you want to perform a temporary change only.</source>
          <target state="translated">이것은 &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir ()&lt;/a&gt; 의 바로 가기 일 뿐이므로 변경 사항은 나머지 실행 동안 영구적입니다 . 임시 변경 만 수행 하려면 &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir ()&lt;/a&gt; 템플릿을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">POSIX의 경우 ':'또는 ';'과 같이 검색 경로 구성 요소를 분리하기 위해 운영 체제에서 일반적으로 사용하는 문자 (PATH에서와 같이) Windows 용.</target>
        </trans-unit>
        <trans-unit id="67cdf84dfd1fc80d813d4abe30055e39e2a1d442" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows.</source>
          <target state="translated">POSIX의 경우 &lt;code&gt;';'&lt;/code&gt; &lt;code&gt;':'&lt;/code&gt; 또는 ';' 과 같이 PATH에서와 같이 검색 패치 구성 요소를 분리하기 위해 운영 체제에서 일반적으로 사용하는 문자입니다 . Windows의 경우.</target>
        </trans-unit>
        <trans-unit id="db4c48c729604a1469a45dd9f280c6186f2d6305" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent a UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">문자 유형은 Nim에서 &lt;code&gt;char&lt;/code&gt; 로 명명 됩니다. 크기는 1 바이트입니다. 따라서 UTF-8 문자를 나타낼 수 없지만 그 일부를 나타냅니다. 그 이유는 효율성 때문입니다. 대부분의 사용 사례에서 결과 프로그램은 UTF-8을 위해 특별히 설계되었으므로 여전히 UTF-8을 올바르게 처리합니다. 또 다른 이유는 Nim 이 많은 알고리즘이이 기능에 의존하는 것처럼 &lt;code&gt;array[char, int]&lt;/code&gt; 또는 &lt;code&gt;set[char]&lt;/code&gt; 효율적으로 지원할 수 있기 때문입니다 . &lt;code&gt;Rune&lt;/code&gt; 유형이 유니 코드 문자에 사용되는, 어떤 유니 코드 문자를 나타낼 수 있습니다. &lt;code&gt;Rune&lt;/code&gt; 은 &lt;a href=&quot;unicode&quot;&gt;유니 코드 모듈&lt;/a&gt; 에서 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">문자 유형은 Nim에서 &lt;code&gt;char&lt;/code&gt; 로 명명 됩니다. 크기는 1 바이트입니다. 따라서 UTF-8 문자를 나타낼 수 없지만 그 일부를 나타냅니다. 그 이유는 효율성입니다. 압도적 인 대다수의 유스 케이스의 경우 UTF-8이 특별히 설계되었으므로 결과 프로그램은 여전히 ​​UTF-8을 올바르게 처리합니다. 또 다른 이유는 많은 알고리즘이이 기능에 의존하기 때문에 Nim이 &lt;code&gt;array[char, int]&lt;/code&gt; 또는 &lt;code&gt;set[char]&lt;/code&gt; 효율적으로 지원할 수 있기 때문입니다 . &lt;em&gt;룬의&lt;/em&gt; 유형이 유니 코드 문자에 사용되는, 어떤 유니 코드 문자를 나타낼 수 있습니다. &lt;code&gt;Rune&lt;/code&gt; 은 &lt;a href=&quot;unicode&quot;&gt;유니 코드 모듈&lt;/a&gt; 에서 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">운영 체제에서 경로 이름 구성 요소를 구분하기 위해 사용하는 문자 (예 : POSIX의 경우 '/', 기본 Macintosh의 경우 ':')</target>
        </trans-unit>
        <trans-unit id="25e189a51726217bd10306adb62ab204d17e2719" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example: &lt;code&gt;'/'&lt;/code&gt; for POSIX, &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh, and &lt;code&gt;'\'&lt;/code&gt; on Windows.</source>
          <target state="translated">경로 이름 구성 요소를 구분하기 위해 운영 체제에서 사용하는 문자입니다. 예를 들어 POSIX의 경우 &lt;code&gt;':'&lt;/code&gt; &lt;code&gt;'/'&lt;/code&gt; , 클래식 Macintosh의 경우 ':' , Windows의 경우 &lt;code&gt;'\'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">기본 파일 이름을 확장자와 구분하는 문자입니다. 예를 들어 '.' 에 &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb96dc2f00e727210b0dc83b639e0b79d1c8c58" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">확장자에서 기본 파일 이름을 구분하는 문자입니다. 예를 들어 &lt;code&gt;'.'&lt;/code&gt; 에 &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">스타일의 선택은 당신에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f81018fe48bb50b55f71f19831d2854f946c504" translate="yes" xml:space="preserve">
          <source>The circle constant PI (Ludolph's number)</source>
          <target state="translated">원 상수 PI (루돌프 수)</target>
        </trans-unit>
        <trans-unit id="88109739e49227795120221865f1a6d8d83ffb4e" translate="yes" xml:space="preserve">
          <source>The circle constant TAU (= 2 * PI)</source>
          <target state="translated">원 상수 TAU (= 2 * PI)</target>
        </trans-unit>
        <trans-unit id="e9025711d3d5dd3e200b0d5ab31809d3ae89c7a5" translate="yes" xml:space="preserve">
          <source>The client data field is used by the HTML parser and generator.</source>
          <target state="translated">클라이언트 데이터 필드는 HTML 구문 분석기 및 생성기에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated">닫는 &lt;code&gt;@#&lt;/code&gt; 는 선택적인 공백으로 시작하는 줄에 있어야합니다. 이런 식으로 &lt;code&gt;@#&lt;/code&gt; 은 예제와 같이 Nim 코드에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">이 코드에는 혼란스러운 &lt;code&gt;var&lt;/code&gt; 선언이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">코드에 지원되지 않는 8 진 시퀀스가 ​​포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">코드 재정렬 기능은 최상위 수준 범위에서 변수 선언 및 초기화와 함께 프로 시저, 템플릿 및 매크로 정의를 암시 적으로 재 배열 할 수 있으므로 프로그래머는 정의를 올바르게 순서화하거나 걱정할 필요가 없습니다. 모듈 내부에서 정의를 시작하는 선언.</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">이 코드는 더 이상 사용되지 않는 기호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">강제 변환 &lt;code&gt;type(x)&lt;/code&gt; 을 사용하여 주어진 표현식 &lt;code&gt;x&lt;/code&gt; 의 유형을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">콜렉터는 모든 &lt;code&gt;workPackage&lt;/code&gt; 반복 후 작업 시간이 아직 남아 있는지 확인합니다 . 현재 100으로 설정되어 있습니다. 다시 확인하기 전에 최대 100 개의 객체가 이송되고 해제됨을 의미합니다. 따라서 &lt;code&gt;workPackage&lt;/code&gt; 는 타이밍 세분성에 영향을 미치며 고도로 전문화 된 환경이나 구형 하드웨어에 맞게 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">명령 호출 구문은 복잡한 표현식을 인수로 가질 수도 없습니다. 예 : ( &lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; . ( &lt;a href=&quot;#do-notation&quot;&gt;표기법&lt;/a&gt; )은 제한되어 있지만 단일 proc에 사용할 수 있습니다 (해당 섹션의 예 참조). 인수가없는 함수 호출은 호출과 함수 자체를 첫 번째 클래스 값으로 구별하기 위해 여전히 ()이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b7e98bb35328ac84f0a9e89f36fd4180318f1d00" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. Function calls with no arguments still need () to distinguish between a call and the function itself as a first-class value.</source>
          <target state="translated">명령 호출 구문은 또한 복잡한 표현식을 인수로 가질 수 없습니다. 예 : ( &lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;try&lt;/code&gt; . 인수가없는 함수 호출은 호출과 함수 자체를 일급 값으로 구분하기 위해 여전히 ()가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">C, C ++ 또는 Objective-C로 컴파일하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated">공통 &lt;code&gt;--&lt;/code&gt; 옵션이 아닌 인수 구분 기호는 빈 문자열 긴 옵션 키로 나타납니다. &lt;code&gt;OptParser.cmd&lt;/code&gt; , &lt;code&gt;OptParser.pos&lt;/code&gt; 및 &lt;code&gt;os.parseCmdLine&lt;/code&gt; 을 사용하여 구문 분석을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">공통 연산자 &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 는 부동 소수점에 대해 정의되며 IEEE-754 표준을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">공통 연산자 &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; 는 정수로 정의됩니다. &lt;code&gt;and or xor not&lt;/code&gt; 사업자는 정수에 대해 정의하고 제공하는 &lt;em&gt;비트&lt;/em&gt; 작업을. 왼쪽 비트 이동은 &lt;code&gt;shl&lt;/code&gt; 로 수행되고 오른쪽 이동은 &lt;code&gt;shr&lt;/code&gt; 연산자로 수행됩니다. 비트 이동 연산자는 항상 인수를 &lt;em&gt;부호없는&lt;/em&gt; 것으로 취급합니다 . 들어 &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;산술 비트 시프트&lt;/span&gt; 일반적인 곱셈 또는 나눗셈을 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">컴파일러는 각 매개 변수가 정확히 하나의 인수를 수신하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 시맨틱을 검사하고 &lt;code&gt;true&lt;/code&gt; 로 평가되는 첫 번째 조건에 속하는 명령문에 &lt;em&gt;대해서만&lt;/em&gt; 코드를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">컴파일러 명령은 대상 백엔드를 선택하지만 필요한 경우 대상 CPU, 운영 체제 또는 컴파일러 / 링커 명령을 선택하기 &lt;a href=&quot;nimc#cross-compilation&quot;&gt;위해 크로스 컴파일&lt;/a&gt; 을 위한 추가 스위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bf4f876ba614fab0251ca447032e9c4223c202b" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt;specify additional switches for cross-compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">컴파일러 명령은 대상 백엔드를 선택하지만 필요한 경우 &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt;교차 컴파일&lt;/a&gt; 을 위한 추가 스위치를 지정 하여 대상 CPU, 운영 시스템 또는 컴파일러 / 링커 명령을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f2e3df2d7fda7fee4989683f7777bad3866a03e" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic.</source>
          <target state="translated">컴파일러는 제대로 작동하기 위해 시스템 모듈에 의존하고 시스템 모듈은 컴파일러에 의존합니다. 여기에 나열된 대부분의 루틴은 특별한 컴파일러 마법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 올바르게 작동하기 위해 시스템 모듈에 의존하고 시스템 모듈은 컴파일러에 의존합니다. 여기에 나열된 대부분의 루틴은 특수 컴파일러 마법을 사용합니다. 각 모듈은 시스템 모듈을 암시 적으로 가져옵니다. 명시 적으로 나열해서는 안됩니다. 이 때문에 &lt;code&gt;system&lt;/code&gt; 이라는 사용자 정의 모듈이있을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">컴파일러는 모든 코드 경로가 Null을 허용하지 않는 포인터를 포함하는 변수를 초기화하도록합니다. 이 분석의 세부 사항은 여전히 ​​여기에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcd92bbcd58119a3a0ac02288b0174193fcb4cee" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">컴파일러는 모든 코드 경로가 nilable이 아닌 포인터를 포함하는 변수를 초기화하도록합니다. 이 분석에 대한 자세한 내용은 여기에 지정해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="0c9adfb2c991d20ede8d4667f6a86d41c673563e" translate="yes" xml:space="preserve">
          <source>The compiler executes the macro body (which may invoke other procs).</source>
          <target state="translated">컴파일러는 매크로 본문 (다른 procs를 호출 할 수 있음)을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">컴파일러는 프로그래머가 다음과 같이 작성한 것처럼 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4b55dae2064aca45aa89b0fcdf2d09a19bcd4f27" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;-d:danger&lt;/code&gt; 또는 &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;명령 줄 스위치를&lt;/a&gt; 통해 수행하도록 권장되는 경우 &lt;code&gt;assert&lt;/code&gt; 에 대한 코드를 전혀 생성하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;-d:release&lt;/code&gt; 또는 &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;명령 행 스위치를&lt;/a&gt; 통해 권장되는 경우 &lt;code&gt;assert&lt;/code&gt; 위해 코드를 전혀 생성하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">이 작업을 수행하려면 컴파일러에 C ++ (명령 &lt;code&gt;cpp&lt;/code&gt; ) 을 생성하도록 지시해야합니다 . 조건부 기호 &lt;code&gt;cpp&lt;/code&gt; 는 컴파일러가 C ++ 코드를 생성 할 때 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">이 작업을 수행하려면 Objective C (명령 &lt;code&gt;objc&lt;/code&gt; ) 를 생성하도록 컴파일러에 지시해야합니다 . 조건부 기호 &lt;code&gt;objc&lt;/code&gt; 는 컴파일러가 Objective C 코드를 생성 할 때 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">컴파일러는 이제 &lt;code&gt;x * 2&lt;/code&gt; 를 &lt;code&gt;x + x&lt;/code&gt; 로 다시 씁니다 . curlies 내부의 코드는 일치시킬 패턴입니다. 연산자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 패턴이 접두사 표기법으로 작성된 경우 패턴에 특별한 의미가 있으므로 일반적인 함수 호출 구문 에 대해 그대로 사용 하려면 &lt;code&gt;*&lt;/code&gt; 일반 함수 호출 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">컴파일러는 문자열 대 / 소문자 구분 문을 최적화합니다. 여러 다른 문자열 상수를 사용하는 경우 해시 구성표가 사용됩니다. 따라서 이와 같은 코드는 합리적으로 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="eb71aee62d68e0ffc7703a0f580c4704b2a5314f" translate="yes" xml:space="preserve">
          <source>The compiler parses Nim source code into an internal data structure called the &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;abstract syntax tree&lt;/span&gt; (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Then, before executing the code or compiling it into the executable, it transforms the AST through &lt;span id=&quot;semantic-analysis_1&quot;&gt;semantic analysis&lt;/span&gt;. This adds semantic information such as expression types, identifier meanings, and in some cases expression values. An error detected during semantic analysis is called a &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt;. Errors described in this manual are static errors when not otherwise specified.</source>
          <target state="translated">컴파일러는 Nim 소스 코드를 &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;추상 구문 트리&lt;/span&gt; ( &lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt; ) 라고하는 내부 데이터 구조로 구문 분석 &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;합니다&lt;/span&gt; . 그런 다음 코드를 실행하거나 실행 파일로 컴파일하기 전에 &lt;span id=&quot;semantic-analysis_1&quot;&gt;의미 분석을&lt;/span&gt; 통해 AST를 변환합니다 . 이렇게하면 식 유형, 식별자 의미 및 경우에 따라 식 값과 같은 의미 정보가 추가됩니다. 의미 분석 중에 감지 된 오류를 &lt;span id=&quot;static-error_1&quot;&gt;정적 오류&lt;/span&gt; 라고합니다 . 이 설명서에 설명 된 오류는 달리 지정되지 않은 정적 오류입니다.</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated">컴파일러는 &lt;code&gt;IOError&lt;/code&gt; 가 발생할 수 있다는 힌트 메시지를 생성합니다 . &lt;code&gt;effects&lt;/code&gt; pragma가 나타나는 분기에서 &lt;code&gt;OSError&lt;/code&gt; 를 발생시킬 수 없으므로 OSError 가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">컴파일러는 열거를 위해 내장 된 stringify 연산자 &lt;code&gt;$&lt;/code&gt; 를 지원합니다 . stringify의 결과는 사용할 문자열 값을 명시 적으로 제공하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">그런 다음 컴파일러는 &lt;code&gt;gdata&lt;/code&gt; 에 대한 모든 액세스가 &lt;code&gt;locks&lt;/code&gt; 섹션 내에 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3c5f83ca8ab3660248326a08229e050f34a8a0c9" translate="yes" xml:space="preserve">
          <source>The compiler will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">컴파일러는 식 평가 실패 또는 가능한 유형 불일치 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="24434c511c9a0bbb881f927475e8de7c254d5387" translate="yes" xml:space="preserve">
          <source>The compiler will use this internally to add nodes that will be appended to the module after the sem pass</source>
          <target state="translated">컴파일러는 이것을 내부적으로 사용하여 sem 통과 후 모듈에 추가 될 노드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated">컴파일러의 아키텍처</target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">상보 오차 함수</target>
        </trans-unit>
        <trans-unit id="9b0073d67f30e0c2127f291bae7a611090f6e645" translate="yes" xml:space="preserve">
          <source>The complex case looks like a variant of &lt;code&gt;x = f(x)&lt;/code&gt;, we consider &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt; here:</source>
          <target state="translated">의 변형 등 복잡한 경우 보이는 &lt;code&gt;x = f(x)&lt;/code&gt; , 우리가 고려 &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt; 여기에서 :</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">컴파일러는 식을 평가하지 못한 경우 또는 가능한 유형 불일치 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="d2436daa78f5945640e1663fb72e8784ed15ea67" translate="yes" xml:space="preserve">
          <source>The concatenation operator for an openarray of ropes.</source>
          <target state="translated">로프의 openarray에 대한 연결 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="9bf0dc092d7f032ccb25780c5ba219ec8f7f8ed1" translate="yes" xml:space="preserve">
          <source>The concatenation operator for ropes.</source>
          <target state="translated">로프의 연결 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">다음과 같은 경우 개념이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">개념 유형은 일반 일반 유형과 마찬가지로 매개 변수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">A의 조건 &lt;code&gt;do while(condition)&lt;/code&gt; 문이 있어야합니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079ce34e8825e87b63959e1b6bb724035f09b43d" translate="yes" xml:space="preserve">
          <source>The configuration file used to generate this module: &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</source>
          <target state="translated">이 모듈을 생성하는 데 사용되는 구성 파일 : &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7df0cbf2a934ca63dd156a15c83a0955e4f3c96c" translate="yes" xml:space="preserve">
          <source>The constant character used by the operating system to refer to the current directory.</source>
          <target state="translated">현재 디렉토리를 참조하기 위해 운영 체제에서 사용하는 상수 문자입니다.</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">운영 체제에서 현재 디렉토리를 참조하기 위해 사용하는 상수 문자열.</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">운영 체제에서 상위 디렉토리를 참조하기 위해 사용하는 상수 문자열.</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">구속 조건은 구체적 유형 또는 유형 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; 도 있습니다. &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt; 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated">구문 &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (식별자와 여는 따옴표 사이에 공백이 없음)은 일반화 된 원시 문자열 리터럴입니다. 구성 &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt; 의 바로 가기 이므로 원시 문자열 리터럴을 유일한 인수로 사용하여 프로 시저 호출을 나타냅니다. 일반화 된 원시 문자열 리터럴은 미니 언어를 Nim에 직접 임베드 할 때 특히 편리합니다 (예 : 정규식).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 수정 자 와 함께 도입 된 반 변형 매개 변수 는 현재 이러한 의미를 갖는 가져온 유형과 인터페이스 할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">사용자 정의 형식 &lt;span id=&quot;converter_1&quot;&gt;변환기&lt;/span&gt; 로 변환 관계를 완화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">크리트 비트 트리는 문자열에서 일부 유형 &lt;code&gt;T&lt;/code&gt; 로의 맵핑 또는 &lt;code&gt;T&lt;/code&gt; 가 void 인 경우 문자열 세트 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0fa9cac7ceae42e9a66ef4fbfd5cbc0c0b98a60" translate="yes" xml:space="preserve">
          <source>The current implementation allows to switch between these different behaviors via &lt;code&gt;--panics:on|off&lt;/code&gt;. When panics are turned on, the program dies with a panic, if they are turned off the runtime errors are turned into exceptions. The benefit of &lt;code&gt;--panics:on&lt;/code&gt; is that it produces smaller binary code and the compiler has more freedom to optimize the code.</source>
          <target state="translated">현재 구현에서는 &lt;code&gt;--panics:on|off&lt;/code&gt; 를 통해 이러한 다른 동작간에 전환 할 수 있습니다 . 패닉이 켜지면 프로그램이 패닉과 함께 죽고, 꺼지면 런타임 오류가 예외로 바뀝니다. &lt;code&gt;--panics:on&lt;/code&gt; 의 이점 은 더 작은 바이너리 코드를 생성하고 컴파일러가 코드를 최적화 할 수있는 더 많은 자유를 갖는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="135086cb75d914e6f94d6cbecde1ac80f38e6fe2" translate="yes" xml:space="preserve">
          <source>The current implementation also performs &lt;code&gt;.cursor&lt;/code&gt; inference. Cursor inference is a form of copy elision.</source>
          <target state="translated">현재 구현은 &lt;code&gt;.cursor&lt;/code&gt; 추론 도 수행합니다 . 커서 추론은 복사 제거의 한 형태입니다.</target>
        </trans-unit>
        <trans-unit id="e6d19e0e77753e1c01e8179f867553475a7ffcd1" translate="yes" xml:space="preserve">
          <source>The current implementation can do a limited form of sink parameter inference. But it has to be enabled via &lt;code&gt;--sinkInference:on&lt;/code&gt;, either on the command line or via a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="translated">현재 구현은 제한된 형태의 싱크 매개 변수 추론을 수행 할 수 있습니다. 그러나 명령 줄에서 또는 &lt;code&gt;push&lt;/code&gt; pragma 를 통해 &lt;code&gt;--sinkInference:on&lt;/code&gt; 을 통해 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f5b1ca7fdfb765ee1b960287c15b23201b6d21a" translate="yes" xml:space="preserve">
          <source>The current implementation follows strategy (2). This means that resources are destroyed at the scope exit.</source>
          <target state="translated">현재 구현은 전략 (2)을 따릅니다. 이는 범위 종료시 리소스가 소멸됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">현재 구현에서는 컴파일 시간 평가에 일부 제한이 있습니다. &lt;code&gt;cast&lt;/code&gt; 를 포함 하거나 외부 함수 인터페이스를 사용 하는 코드 는 컴파일 타임에 평가할 수 없습니다. 최신 버전의 Nim은 컴파일 타임에 FFI를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a6c75b39da47586f8ce3f9497858b03d9e773673" translate="yes" xml:space="preserve">
          <source>The current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.</source>
          <target state="translated">현재 구현에서는 드물게 실행 표시 및 스윕 단계를 사용하여주기를 해제하는 참조 카운팅 가비지 수집기를 사용합니다. 마크 및 스윕 단계는 시간이 오래 걸릴 수 있으며 애플리케이션이주기를 생성하지 않는 경우 필요하지 않습니다. 따라서 마크 및 스윕 단계는 나머지 GC와 별도로 비활성화 및 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8021c64a5c2703296dd3be90acd92bb96fdc4cc3" translate="yes" xml:space="preserve">
          <source>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length &lt;code&gt;a.len div 2&lt;/code&gt;. If you do not wish to provide your own &lt;code&gt;cmp&lt;/code&gt;, you may use &lt;code&gt;system.cmp&lt;/code&gt; or instead call the overloaded version of &lt;code&gt;sort&lt;/code&gt;, which uses &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="translated">현재 구현에서는이를 위해 반복적 병합 정렬을 사용합니다. 길이 &lt;code&gt;a.len div 2&lt;/code&gt; 의 임시 시퀀스를 사용합니다 . 당신이 당신의 자신의 제공을 원하지 않는 경우 &lt;code&gt;cmp&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;system.cmp&lt;/code&gt; 를 나 대신 오버로드 된 버전 전화 &lt;code&gt;sort&lt;/code&gt; 가 사용하는, &lt;code&gt;system.cmp&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="baaad5708fa9cdaf05cfb4998ff219d4807eb0f6" translate="yes" xml:space="preserve">
          <source>The current version is compatible with Unicode v12.0.0.</source>
          <target state="translated">현재 버전은 유니 코드 v12.0.0과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">사이클 컬렉터는 &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; 및 &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; 을 사용하여 GC의 다른 부분과 독립적으로 활성화 / 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba5fbe658d27b58a801cb300b7494eb040d69ce3" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the garbage collector with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">순환 수집기는 &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; 및 &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt; 를 사용하여 가비지 수집기의 다른 부분과 독립적으로 활성화 / 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8940014c2996b2e1e7db8c6a1ff0b6fea342746b" translate="yes" xml:space="preserve">
          <source>The data structures and algorithms used here are inspired by &quot;A Graph&amp;ndash;Free Approach to Data&amp;ndash;Flow Analysis&quot; by Markus Mohnen. &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</source>
          <target state="translated">여기에 사용 된 데이터 구조와 알고리즘은 Markus Mohnen의 &quot;데이터 흐름 분석에 대한 그래프없는 접근 방식&quot;에서 영감을 얻었습니다. &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66ac7444c3221b96debd2abc66799170ac26a58d" translate="yes" xml:space="preserve">
          <source>The date (in UTC) of compilation as a string of the form &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="translated">&lt;code&gt;YYYY-MM-DD&lt;/code&gt; 형식의 문자열로 표시되는 컴파일 날짜 (UTC)입니다 . 이것은 컴파일러 마법 덕분에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="940edcabe1639013ff3203ff4f55354615da8e93" translate="yes" xml:space="preserve">
          <source>The day of the month, in the range 1 to 31.</source>
          <target state="translated">1에서 31 사이의 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="ad24cee5b08e1745f4d438cfcaeb59500a70b502" translate="yes" xml:space="preserve">
          <source>The day of the week as an enum, the ordinal value is in the range 0 (monday) to 6 (sunday).</source>
          <target state="translated">요일을 열거 형으로 표시합니다. 서수 값의 범위는 0 (월요일)에서 6 (일요일)입니다.</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">프로젝트의 기본 빌드는 &lt;span id=&quot;debug-build_1&quot;&gt;디버그 빌드&lt;/span&gt; 입니다. &lt;span id=&quot;release-build_1&quot;&gt;릴리스 빌드&lt;/span&gt; 를 컴파일하려면 &lt;code&gt;release&lt;/code&gt; 기호를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">내부 호출 프로 시저 (proc 내부의 proc)가 아닌 한 기본 호출 규칙은 &lt;code&gt;nimcall&lt;/code&gt; 입니다. 내부 프로세스의 경우 환경에 액세스하는지 여부에 대한 분석이 수행됩니다. 그렇게하면 호출 규칙 &lt;code&gt;closure&lt;/code&gt; 있고, 그렇지 않으면 호출 규칙 &lt;code&gt;nimcall&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">기본 컴파일러는 &lt;code&gt;config\nim.cfg&lt;/code&gt; 맨 위에 정의되어 있습니다. 이 설정을 변경하면 &lt;code&gt;koch&lt;/code&gt; 에서 Nim을 재 빌드하는 데 사용하는 컴파일러에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">기본 구성 ( &lt;code&gt;trim=true&lt;/code&gt; 및 &lt;code&gt;precision=10&lt;/code&gt; )은 값 을 정확하게 (최대 10 자리까지 ) 표시하는 &lt;strong&gt;가장 짧은&lt;/strong&gt; 형식을 보여줍니다 . 예를 들어 4.100000은 4.1 (수학적으로 동일 함)으로 표시되는 반면 4.1000003은 4.1000003으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">기본 구성 ( &lt;em&gt;trim = true&lt;/em&gt; 및 &lt;em&gt;precision = 10&lt;/em&gt; )은 값 을 정확하게 표시하는 최대 값 (소수점 최대 10 자리)을 &lt;strong&gt;가장 짧은&lt;/strong&gt; 형식으로 표시합니다. 예를 들어, 4.100000은 4.1 (수학적으로 동일 함)로 표시되고 4.1000003은 4.1000003으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated">기본 float 유형은 &lt;code&gt;float&lt;/code&gt; 입니다. 현재 구현에서 &lt;code&gt;float&lt;/code&gt; 는 항상 64 비트입니다.</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated">엔티티 &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 의 기호의 기본값 은 &lt;code&gt;gensym&lt;/code&gt; 이며 &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt; 는 &lt;code&gt;inject&lt;/code&gt; 됩니다. 그러나 엔터티 이름이 템플릿 매개 변수로 전달되면 주입 된 기호입니다.</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="translated">기본 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">기본 정수 유형은 &lt;code&gt;int&lt;/code&gt; 입니다. 정수 리터럴은 기본이 아닌 정수 유형을 지정하기 위해 &lt;em&gt;유형 접미&lt;/em&gt; 부를 가질 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
