<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="d7d511fa0f4131e89caffa53b1340e8da32540ee" translate="yes" xml:space="preserve">
          <source>The default is to write a stacktrace to &lt;code&gt;stderr&lt;/code&gt; and then call &lt;code&gt;quit(1)&lt;/code&gt;. Unstable API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de79cd39665eebcab7f9383b18124da290c9e6c" translate="yes" xml:space="preserve">
          <source>The default mode is case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="translated">더 이상 사용되지 않는 pragma는 기호를 사용되지 않음으로 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="762aa45b2aaec5e503b1dacdc6bb91a55cf5531c" translate="yes" xml:space="preserve">
          <source>The details of the inference algorithm are currently undocumented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e221c70b35d4c508839b98e3971cbeac27b698e" translate="yes" xml:space="preserve">
          <source>The detected command line token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 1.0과 1.0보다 작은 최소값의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 1.0과 1.0보다 작은 최소값의 차이입니다.</target>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 의 차이점은 다음 과 같습니다. &lt;code&gt;let&lt;/code&gt; 은 재 할당 할 수없는 변수를 도입합니다. &lt;code&gt;const&lt;/code&gt; 는 &quot;컴파일 시간 평가를 시행하여 데이터 섹션에 넣습니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="translated">두 세트의 차이는 수학적으로 &lt;em&gt;AB&lt;/em&gt; 로 표시되며 &lt;em&gt;s2&lt;/em&gt; 멤버가 아닌 &lt;em&gt;s1&lt;/em&gt; 멤버 인 모든 객체의 세트입니다 . 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d27f497247a1d668b9eedd90ebdd41b0705bd43" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A ∖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and not members of &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfc8212e64434b0ef38e7d2b1ac70082312d54c" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37119833f19f914acaa770542dc626979be221e3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,IntSet,int&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1b787f9dec43bac1fc4feaec6e737341d9ef05" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,OrderedSet%5BA%5D,A&quot;&gt;excl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was missing from &lt;code&gt;s&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was in &lt;code&gt;s&lt;/code&gt; and it was removed during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">받는 사람 관련하여 차이 &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;제외 ()&lt;/a&gt; PROC이 시저가 반환하는 것입니다 &lt;em&gt;진정한&lt;/em&gt; 경우 &lt;em&gt;키가&lt;/em&gt; 존재하지 않았다 &lt;em&gt;의&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">받는 사람 관련하여 차이 &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;제외 ()&lt;/a&gt; PROC이 시저가 반환하는 것입니다 &lt;em&gt;진정한&lt;/em&gt; 경우 &lt;em&gt;키가&lt;/em&gt; 존재하지 않았다 &lt;em&gt;의&lt;/em&gt; . 예:</target>
        </trans-unit>
        <trans-unit id="a71957eb2547d4bfa9f2683522934ebe61aa6db3" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,HashSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fff35f03a020121f5216e964c1f14d3d44390d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,IntSet,int&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773605a369d8054b7c253cee632444088b29e946" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,OrderedSet%5BA%5D,A&quot;&gt;incl proc&lt;/a&gt; is that this proc returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; already contained &lt;code&gt;key&lt;/code&gt;. The proc will return false if &lt;code&gt;key&lt;/code&gt; was added as a new value to &lt;code&gt;s&lt;/code&gt; during this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">&lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; proc 과의 차이점 은 &lt;em&gt;key&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 이 proc이 &lt;em&gt;true를&lt;/em&gt; 반환한다는 것 입니다. 경우 PROC는 false를 돌려줍니다 &lt;em&gt;키&lt;/em&gt; 에 새로운 값으로 추가되었다 &lt;em&gt;의&lt;/em&gt; 이 통화 중. 예:&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="translated">&lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl ()&lt;/a&gt; proc 과의 차이점 은 &lt;em&gt;key&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 이 proc이 &lt;em&gt;true를&lt;/em&gt; 반환한다는 것 입니다. 경우 PROC는 false를 돌려줍니다 &lt;em&gt;키&lt;/em&gt; 에 새로운 값으로 추가되었다 &lt;em&gt;의&lt;/em&gt; 이 통화 중. 예:&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="translated">지원되는 다양한 형식 패턴이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="translated">안전하지 않은 &lt;code&gt;asm&lt;/code&gt; 문 은 어셈블러 코드를 Nim 코드에 직접 포함시키는 기능을 지원 합니다. Nim 식별자를 참조하는 어셈블러 코드의 식별자는 명령문의 pragma에 지정할 수있는 특수 문자로 묶어야합니다. 기본 특수 문자는 &lt;code&gt;'`'&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0c22272ea471a90f449580f65ef97314fc75ce82" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;code&gt;OSError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="translated">디렉토리에 아직 존재하지 않는 여러 서브 디렉토리가있을 수 있습니다. 전체 경로가 생성됩니다. 이것이 실패하면 &lt;em&gt;OSError&lt;/em&gt; 가 발생합니다. 그것은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 대부분의 용도로이 오류를 표시하지 않기 때문에 디렉토리가 이미 존재하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="translated">디스패처는 일종의 이벤트 루프 역할을합니다. 당신은 호출해야합니다 &lt;code&gt;poll&lt;/code&gt; 거기에 (또는 같은 당신을 위해 그렇게하는 기능 &lt;code&gt;waitFor&lt;/code&gt; 또는 &lt;code&gt;runForever&lt;/code&gt; ) 미결제 이벤트에 대한 설문 조사에 위해를. 기본 구현은 Linux의 epoll, Windows의 IO Completion Ports 및 기타 운영 체제를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2fe9a5fd03163afe0a124e1e905c51d6abb0bdfb" translate="yes" xml:space="preserve">
          <source>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="translated">설명서는 여러 문서로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="160bf45ca85f5c6209e555ecebe6d41157683d3c" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation each runnableExample is put in its own file &lt;code&gt;$file_examples$i.nim&lt;/code&gt;, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="translated">문서 생성기는 이러한 예제를 알고 있으며 &lt;code&gt;##&lt;/code&gt; doc 주석의 일부로 간주합니다 . 문서 생성의 마지막 단계로 예제는 &lt;code&gt;$file_example.nim&lt;/code&gt; 파일에 저장되고 컴파일 및 테스트됩니다. 수집 된 예제는 자체 모듈에 넣어 예제가 내 보내지 않은 기호를 나타내지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="translated">효과 시스템 (발생 &lt;code&gt;raises: []&lt;/code&gt; )은 비동기 프로 시저에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bcfc8f90f78962fe572628e18093e7b6be852bf" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist - 1&lt;/code&gt; will be at &lt;code&gt;slice.b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897357254109912a2abd5ead8a14e0dc57992f7f" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a + dist&lt;/code&gt; will be at index &lt;code&gt;slice.a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670537769ac6c87d8dae3f8f255038a616b07e05" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.a&lt;/code&gt; will be at &lt;code&gt;slice.b + 1 - dist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68a5f4232d630fa057b4a20b989568ebd93ae53" translate="yes" xml:space="preserve">
          <source>The element at index &lt;code&gt;slice.b&lt;/code&gt; will be at &lt;code&gt;slice.a + dist -1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aded9e6b8b6079e27b489e1f2a3fd8422a03e391" translate="yes" xml:space="preserve">
          <source>The employed static analysis is limited and only concerned with local variables; however, object and tuple fields are treated as separate entities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">빈 &lt;a href=&quot;#procedures-discard-statement&quot;&gt;폐기 문&lt;/a&gt; 은 &lt;em&gt;아무 것도하지 않습니다&lt;/em&gt; . 컴파일러는 else 부분이있는 case 문이 실패 할 수 없으므로 오류가 사라진다는 것을 알고 있습니다. 가능한 모든 문자열 값을 처리하는 것은 불가능합니다. 따라서 문자열 케이스에는 항상 &lt;code&gt;else&lt;/code&gt; 분기 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">빈 &lt;code&gt;[]&lt;/code&gt; 의 첨자를 표기하는 데 사용될 수 &lt;em&gt;derefer&lt;/em&gt; 에 상품을 상기 기준 지점을 검색하는 의미 참조. &lt;code&gt;.&lt;/code&gt; (튜플 / 객체 필드 연산자에 액세스) 및 &lt;code&gt;[]&lt;/code&gt; (배열 / 문자열 / 시퀀스 인덱스 연산자) 연산자는 참조 유형에 대해 암시 적 역 참조 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">명시 적으로 나열되지 않은 예외가있는 경우 빈 &lt;code&gt;except&lt;/code&gt; 부분이 실행됩니다. &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;else&lt;/code&gt; 부분 과 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="translated">다르게 나열되지 않은 예외가 있으면 빈 &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; 절이 실행됩니다. &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;else&lt;/code&gt; 절 과 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="translated">빈 테이블은 &lt;code&gt;{:}&lt;/code&gt; (빈 세트와는 대조적으로 &lt;code&gt;{}&lt;/code&gt; )와 같이 쓸 수 있으며 이는 빈 배열 생성자 &lt;code&gt;[]&lt;/code&gt; 로 쓰는 또 다른 방법 입니다. 이 약간 특이한 테이블 지원 방법에는 많은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="530e09898cb17b92f8f440dddf479da4d55cb727" translate="yes" xml:space="preserve">
          <source>The endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0113abbcfc987b657ff5c91825dbc9c2097913c" translate="yes" xml:space="preserve">
          <source>The error code can be retrieved using the &lt;a href=&quot;#osLastError&quot;&gt;osLastError proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="translated">에러 기능</target>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="translated">이 예는 또한 proc의 본문이 값이 암시 적으로 리턴되는 단일 표현식으로 구성 될 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="translated">벡터는 이미 &lt;code&gt;v[]&lt;/code&gt; 액세스를 제공하는 튜플에 의해 더 잘 모델링되므로이 예는 어리 석습니다 .</target>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="translated">이 예는 일반 이진 트리를 보여줍니다. 컨텍스트에 따라 대괄호는 형식 매개 변수를 도입하거나 일반 proc, iterator 또는 형식을 인스턴스화하는 데 사용됩니다. 예제에서 알 수 있듯이 제네릭은 오버로드와 함께 작동합니다. 가장 일치하는 &lt;code&gt;add&lt;/code&gt; 가 사용됩니다. 시퀀스 에 내장 된 &lt;code&gt;add&lt;/code&gt; 프로시 저는 숨겨져 있지 않으며 &lt;code&gt;preorder&lt;/code&gt; 반복기 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="translated">이 예제에서는 while 루프를 사용하여 사용자가 아무 것도 입력하지 않는 한 계속해서 이름을 요구합니다 (RETURN 만 누름).</target>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">예외 부분 은 &lt;code&gt;except&lt;/code&gt; 부분 에서 &lt;em&gt;소비&lt;/em&gt; 됩니다 . 예외가 처리되지 않으면 호출 스택을 통해 전파됩니다. 즉, &lt;code&gt;finally&lt;/code&gt; 절에 없는 나머지 프로시 저는 종종 실행되지 않습니다 (예외가 발생한 경우).</target>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="translated">예외는 예외 처리기에서 &lt;em&gt;소비&lt;/em&gt; 됩니다. 그러나 예외 처리기는 다른 예외를 일으킬 수 있습니다. 예외가 처리되지 않으면 호출 스택을 통해 전파됩니다. 즉, &lt;code&gt;finally&lt;/code&gt; 절에 없는 나머지 프로시 저는 종종 실행되지 않습니다 (예외가 발생한 경우).</target>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="translated">예외 추적은 님 &lt;span id=&quot;effect-system_1&quot;&gt;효과 시스템&lt;/span&gt; 의 일부입니다 . 예외를 발생시키는 것이 &lt;em&gt;효과&lt;/em&gt; 입니다. 다른 효과도 정의 할 수 있습니다. 사용자 정의 효과는 루틴 에 &lt;em&gt;태그&lt;/em&gt; 를 &lt;em&gt;지정&lt;/em&gt; 하고이 태그에 대한 검사를 수행 하는 수단입니다 .</target>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="translated">예외 트리는 &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈에 정의되어 있습니다. 모든 예외는 &lt;code&gt;system.Exception&lt;/code&gt; 을 상속 합니다. 프로그래밍 버그를 나타내는 예외는 &lt;code&gt;system.Defect&lt;/code&gt; ( &lt;code&gt;Exception&lt;/code&gt; 의 하위 유형) 에서 상속되며 전체 프로세스를 종료하는 작업에 매핑 될 수 있으므로 엄밀히 말하면 잡을 수 없습니다. 잡을 수있는 다른 런타임 오류를 나타내는 예외는 &lt;code&gt;system.CatchableError&lt;/code&gt; ( &lt;code&gt;Exception&lt;/code&gt; 의 하위 유형) 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="f15c73f143df8ff81817805b3e6f84eb0426975c" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are strictly speaking not catchable as they can also be mapped to an operation that terminates the whole process. If panics are turned into exceptions, these exceptions inherit from &lt;code&gt;Defect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c146fcf11a72b2f53363e7dce3057eecf8d03ff2" translate="yes" xml:space="preserve">
          <source>The expected stdlib location is /usr/lib/nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca7c3dc848479331fda2f9d22be2cc3a93d781c" translate="yes" xml:space="preserve">
          <source>The experimental &lt;span id=&quot;nodestroy_1&quot;&gt;nodestroy&lt;/span&gt; pragma inhibits hook injections. This can be used to specialize the object traversal in order to avoid deep recursions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="translated">식 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;x.f&lt;/code&gt; 의미 (수단 심볼 조회 및 유형 검사가) 재기록되어야한다고 결정하기 전에 확인 될 필요가 &lt;code&gt;f(x)&lt;/code&gt; . 따라서 도트 구문은 템플릿 / 매크로를 호출하는 데 사용될 때 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c2dc4422e351229d30e8efd52e83f860015cd51" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;code&gt;#&lt;/code&gt; and whitespace are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="translated">확장은 &lt;em&gt;#&lt;/em&gt; 및 공백으로 시작하는 주석 이 무시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8c41536248444b965e36bdfac662bfb214beac07" translate="yes" xml:space="preserve">
          <source>The factory &lt;code&gt;proc&lt;/code&gt;, as an ordinary procedure, can be recursive. The above macro allows such recursion to look much like a recursive iterator would. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="translated">튜플 또는 객체 정의 내의 필드 식별자는 다음 위치에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="translated">&lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; 파일 은 XML 파서를 사용하여 또 다른 간단한 작업을 수행하는 방법을 보여줍니다. HTML 문서에 포함 된 모든 링크를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="translated">&lt;code&gt;examples/htmltitle.nim&lt;/code&gt; 파일 은 XML 파서를 사용하여 간단한 작업을 수행하는 방법을 보여줍니다. HTML 문서의 제목을 확인하려면.</target>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="translated">스크립트 파일의 파일 확장자입니다. 예 : POSIX의 경우 &quot;&quot;, Windows의 경우 &quot;bat&quot;</target>
        </trans-unit>
        <trans-unit id="bd4b48d3252daafd834db9d87104d9a48291a53c" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;bat&quot;&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="translated">기본 실행 파일의 파일 확장자입니다. 예 : POSIX의 경우 &quot;&quot;, Windows의 경우 &quot;exe&quot;</target>
        </trans-unit>
        <trans-unit id="3bcdd9264e0657c8e586f2111814ceedf968b16d" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &lt;code&gt;&quot;&quot;&lt;/code&gt; for POSIX, &lt;code&gt;&quot;exe&quot;&lt;/code&gt; on Windows (without a dot).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4d66cbed56a81621a70d0c80cfeafaeea567fd" translate="yes" xml:space="preserve">
          <source>The file handle associated with &lt;code&gt;f&lt;/code&gt; won't be inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185628c3622bd8c0f63cb10b192be0d0211b8807" translate="yes" xml:space="preserve">
          <source>The file handle associated with the resulting &lt;code&gt;File&lt;/code&gt; is not inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="translated">파일을 열 때 파일 모드입니다.</target>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="translated">쿼리를 수행하려는 파일입니다. 일반적으로 &lt;strong&gt;proj.nim&lt;/strong&gt; 과 동일한 값을 &lt;strong&gt;전달&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="translated">필터는 이것을 다음으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="translated">마지막 계층은 비동기 대기 변환입니다. 이를 통해 동기식 스타일로 비동기 코드를 작성할 수 있으며 C #의 대기와 유사하게 작동합니다. 변환은 비동기 프로 시저를 반복자로 변환하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="translated">첫 번째 명령은 생성 된 파일에서 &lt;code&gt;main()&lt;/code&gt; 함수 생성을 피하고, 오브젝트 파일을 최종 바이너리에 링크하지 않고, C 통합을위한 헤더 파일을 명시 적으로 생성 하지 않도록 세 가지 특수 옵션으로 Nim 컴파일러를 실행합니다 . 생성 된 모든 파일은 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리에 있습니다. 그렇기 때문에 다음 명령은 &lt;code&gt;maths.c&lt;/code&gt; 소스와 &lt;code&gt;nimcache&lt;/code&gt; 형식의 모든 &lt;code&gt;.c&lt;/code&gt; 파일을 컴파일합니다 . 이 경로 외에도 C 컴파일러에게 Nim의 &lt;code&gt;nimbase.h&lt;/code&gt; 헤더 파일 을 찾을 위치를 알려줘야 합니다.</target>
        </trans-unit>
        <trans-unit id="341e06b43aea4d82833edd740a767d94b3ccabcf" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files from &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="translated">첫 번째 줄은 메인 프로젝트 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e2c5da607ae89a09ea180cc662ffe2d3288f940" translate="yes" xml:space="preserve">
          <source>The first one is to treat Android as a simple Linux and use &lt;a href=&quot;https://wiki.termux.com&quot;&gt;Termux&lt;/a&gt; to connect and run the Nim compiler directly on android as if it was Linux. These programs are console-only programs that can't be distributed in the Play Store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d583c04d3d5573e56b1c04f936fe5a844700a2bc" translate="yes" xml:space="preserve">
          <source>The first pass over the AST computes the lifetime of each local variable based on a notion of an &quot;abstract time&quot;, in the implementation it's a simple integer that is incremented for every visited node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="translated">첫 번째 프로그램</target>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="translated">가장 먼저 알아 두어야 할 것은 모든 호출 가능한 유형에는 매개 변수가 없더라도 적어도 쉼표가 있다는 것입니다. 매개 변수가 있으면 해당 유형으로 표시되며 쉼표로 구분됩니다. 일반 기호에는 호출 가능한 유형에 따라 접미사가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="translated">소켓 사용을 시작하기 위해 항상해야 할 첫 번째 일은 &lt;code&gt;newSocket&lt;/code&gt; 프로 시저를 사용하여 &lt;code&gt;Socket&lt;/code&gt; 유형 의 새 인스턴스를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="translated">첫 번째 버전은 &lt;em&gt;cmp&lt;/em&gt; 를 사용하여 요소를 비교합니다. 예상 반환 값은 system.cmp의 반환 값과 같습니다. 두 번째 버전은 기본 비교 함수 &lt;em&gt;cmp를&lt;/em&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="translated">다음 Nim 코드 :</target>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="translated">다음 알고리즘 (의사 코드)은 두 유형이 &lt;code&gt;distinct&lt;/code&gt; 유형에 관계없이 동일한 지 여부를 결정합니다 . 간결성을 위해 보조 세트 &lt;code&gt;s&lt;/code&gt; 를 사용한 사이클 점검 이 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b6b9f3bad755134a23b880abde4691304772a2d" translate="yes" xml:space="preserve">
          <source>The following built-in procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="translated">다음과 같은 내장 프로세스는 구현의 단순성으로 인해 오버로드 될 수 없습니다 (특별한 의미 검사가 필요함).</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">다음 코드 :</target>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="translated">다음과 같은 도트 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f9399cc07df619ba3888f0184c84cb8878ae0a4" translate="yes" xml:space="preserve">
          <source>The following example below demonstrates this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="translated">다음 예는 간단한 채팅 서버를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="translated">다음 예제는 언어 선택에 따라 런타임에 판별되는 라이브러리에서 'greet'이라는 함수를로드하는 방법을 보여줍니다. 라이브러리가로드되지 않거나 'greet'함수를 찾지 못하면 실패 오류 코드와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="translated">다음 예제는 세 개의 다른 핸들러에 동시에 로깅하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eabb5a4203a8be2bb32e537097dda5d6aafcb2a1" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to use format strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18893dd703fa2cec1ca572616dda266323fe737a" translate="yes" xml:space="preserve">
          <source>The following example illustrates the difference between having an empty &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt;, which is the default, and providing arguments for those two parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="translated">다음 예제 는 가변 개수의 인수를 허용하는 강력한 &lt;code&gt;debug&lt;/code&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="translated">다음 예제는 정규식에서 어휘 분석기를 생성하는 매크로를 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c9696dddb17da694c08a2a139f76f69dd6a84a76" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modeled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="translated">다음 예제는 일반 이진 트리를 모델링 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="translated">다음 예는 어떤 형태의 호이 스팅이 구현 될 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="translated">다음 예제는 용어 재 작성으로 간단한 부분 평가를 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="translated">다음 예제는 적절하게 이름이 'sample.nim'인 아래의 고안된 &lt;em&gt;Nim&lt;/em&gt; 모듈에 대한 문서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="translated">다음과 같은 부동 소수점 유형이 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="be3a0eb96a85f116081ffd032fe5b5b0838714d7" translate="yes" xml:space="preserve">
          <source>The following floating-point types are pre-defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bad09cb370d8f3f8c755d03410041bf9dcfd47b" translate="yes" xml:space="preserve">
          <source>The following is a simple example of two different ways to use channels: blocking and non-blocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="translated">다음 키워드는 예약되어 있으며 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="translated">다음의 nim 코드 :</target>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="translated">다음 단락은 대부분 자신을 생각 나게합니다. 명심해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="1bcea16918645347b321c14f6902806d2e446d68" translate="yes" xml:space="preserve">
          <source>The following platforms are seldomly tested:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="translated">다음 섹션에서는 컴파일러가 수행하는 형식 검사를 설명하는 데 필요한 형식에 대한 몇 가지 관계를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5ffd86ef8c75a76e081502cef8cf82ac80736c9f" translate="yes" xml:space="preserve">
          <source>The following section is an outline of the algorithm that the current implementation uses. The algorithm performs two traversals over the AST of the procedure or global section of code that uses a view variable. No fixpoint iterations are performed, the complexity of the analysis is O(N) where N is the number of nodes of the AST.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="translated">다음 섹션에서는 idetools가 유효한 출력을 반환하는 각 종류의 심볼에 대해 예상되는 출력을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="translated">다음 섹션에서는 각 메타 문자 사용에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">다음 문자열은 다른 토큰을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b83acdde1dcacc8ae9aed7b53848613c608c4a6c" translate="yes" xml:space="preserve">
          <source>The following syntax is supported when arguments for the &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters, which are &lt;a href=&quot;#shortnoval-and-longnoval&quot;&gt;described later&lt;/a&gt;, are not provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2286a2e09a0398e8afb0291269b5daa96c5798f3" translate="yes" xml:space="preserve">
          <source>The following variables, which must be prefixed with a dollar sign (&lt;code&gt;$&lt;/code&gt;), are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="translated">파일 이름을 &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; 파일 로 변환하는 형식 문자열 ( 일부 운영 체제 에서는 &lt;span id=&quot;shared-object_1&quot;&gt;공유 객체&lt;/span&gt; 라고도 함 ).</target>
        </trans-unit>
        <trans-unit id="addcd5e79876ecd72925b40fce572a37877dd825" translate="yes" xml:space="preserve">
          <source>The format string used by a logger can be specified by providing the &lt;code&gt;fmtStr&lt;/code&gt; argument when creating the logger or by setting its &lt;code&gt;fmtStr&lt;/code&gt; field afterward. If not specified, the &lt;a href=&quot;#defaultFmtStr&quot;&gt;default format string&lt;/a&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="translated">반복자가 정의되면 네 번째 열은 빈 문자열이됩니다. 파일의 해당 시점에서 파서는 아직 전체 행을 처리하지 않았기 때문입니다. 반복자의 이후 인스턴스에서 서명이 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="translated">매크로가 정의되는 경우 네 번째 열은 빈 문자열이됩니다. 파일의 해당 시점에서 파서는 아직 전체 행을 처리하지 않았기 때문입니다. 서명은 매크로의 후방 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="translated">파일의 시점에서 파서가 아직 전체 행을 처리하지 않았기 때문에 메소드가 정의되는 경우 네 번째 열은 빈 문자열입니다. 서명은 메소드의 후부 인스턴스에서 완료되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="translated">파일의 해당 시점에서 파서가 아직 전체 행을 처리하지 않았으므로 proc이 정의되는 경우 네 번째 열은 빈 문자열입니다. 서명은 proc의 사후 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="translated">템플릿을 정의하는 경우 파일의 해당 시점에서 파서가 아직 전체 행을 처리하지 않았으므로 네 번째 열은 빈 문자열입니다. 서명은 템플릿의 뒤쪽 인스턴스에서 완료되어 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="translated">백 슬래시의 네 번째 용도는 특정 &lt;span id=&quot;simple-assertions_1&quot;&gt;간단한 어설 션&lt;/span&gt; 입니다. 어설 션은 제목 문자열에서 문자를 소비하지 않고 일치하는 특정 지점에서 충족되어야하는 조건을 지정합니다. 보다 복잡한 어설 션에 하위 패턴을 사용하는 방법은 다음과 같습니다. 백 슬래시 된 어설 션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="translated">지속 시간의 소수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="6cf4e08c8caff96d4a84112d274637767f157c27" translate="yes" xml:space="preserve">
          <source>The frame itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0be66077b85b0c6e6e17698732ef4f6a86fec6" translate="yes" xml:space="preserve">
          <source>The freed memory must belong to its allocating thread! Use &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared&lt;/a&gt; to deallocate from a shared heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="translated">전체 출력은 여기에서 볼 수있다 : &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html를&lt;/a&gt; . 의미 검사 후 실행되며 컴파일러가 암시 적으로 첨부 한 pragma를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="translated">&lt;code&gt;HttpClient&lt;/code&gt; 와 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 에 의해 구현 된 기능 은 동일하므로 여기에 표시된 예에서 가장 적합한 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="translated">향후 스트림이 완료되었습니다 (이는 더 이상 데이터가 기록되지 않음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="87b1c3994092b48e69bbad0698b780ef6e90d0cf" translate="yes" xml:space="preserve">
          <source>The future will complete when the connection is successfully accepted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="translated">감마 기능</target>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="translated">감마 함수 &lt;strong&gt;버전 0.19.0부터 사용되지 않음&lt;/strong&gt; : &lt;code&gt;gamma&lt;/code&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="15c99de4a4957bd4f07f1a6a1fb166d741fab63e" translate="yes" xml:space="preserve">
          <source>The garbage collectors' way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="translated">표준 형식 지정자의 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d90e9f49ac507c92c04a7f7808d9f7f219ca411c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=copy&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91909254b57a3654840f57e5570e9d7ddb4f1d0c" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=destroy&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c207d0cccf70d71e7fd5c3d827d8d82b10e6a4a" translate="yes" xml:space="preserve">
          <source>The general pattern in &lt;code&gt;=sink&lt;/code&gt; looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="translated">생성 된 C 코드에는 명시적인 호출 규칙이 없으므로 C 컴파일러의 기본 호출 규칙이 사용됩니다. 절차에 대한 Nim의 기본 호출 규칙은 속도를 향상시키기 위해 &lt;code&gt;fastcall&lt;/code&gt; 이기 때문에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="translated">이러한 랩퍼 중 일부에 대해 생성 된 HTML은 너무 커서 배포에 포함되지 않습니다. 그런 다음 웹 사이트에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e4e87c93eeee97828c02dc3485e82bbf4f6dbd4" translate="yes" xml:space="preserve">
          <source>The generated async procedures use the &lt;code&gt;async&lt;/code&gt; macro, whereas the generated synchronous procedures simply strip off the &lt;code&gt;await&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="translated">Nim이 생성하는 생성 된 파일은 모두 &lt;code&gt;nimcache&lt;/code&gt; 라는 서브 디렉토리로 이동 합니다. 전체 경로는</target>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="translated">생성 된 인덱스 &lt;strong&gt;색인 + (Ctrl + F) == 기쁨&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="translated">getrlimit () 시스템 호출은 자원 한계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="037ac60a6022509a63de6a9810813d645bcec667" translate="yes" xml:space="preserve">
          <source>The global log filter is actually a thread-local variable, so it needs to be set in each thread that uses this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="translated">좋은 소식은 많이 바뀌지 않았습니다! 먼저 입력 매개 변수 (라인 3) 처리를 변경해야합니다. 동적 버전에서 &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc은 문자열 매개 변수를 수신합니다. 그러나 매크로 버전에서는 문자열로도 선언되지만 이는 매크로 의 &lt;em&gt;외부&lt;/em&gt; 인터페이스입니다. 매크로가 실행될 때 실제로 문자열 대신 &lt;code&gt;PNimNode&lt;/code&gt; 객체를 가져 오므로 &lt;a href=&quot;macros&quot;&gt;매크로 모듈&lt;/a&gt; 에서 &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (5 행)을 호출 하여 매크로 에 전달되는 문자열을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">문법의 시작 기호는 &lt;code&gt;module&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="translated">인사말 프로그램은 순차적으로 실행되는 3 개의 문으로 구성됩니다. 가장 원시적 인 프로그램만이 벗어날 수 있습니다 : 분기 및 루핑도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="translated">보호대는 특정 유형일 필요는 없습니다. 낮은 수준의 잠금없는 메커니즘을 모델링 할 수있을만큼 유연합니다.</target>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="translated">백 슬래시와 0 이외의 숫자를 처리하는 것은 복잡합니다. 문자 클래스 외부에서 PCRE는 10 진수로 문자 및 다음 숫자를 읽습니다. 숫자가 10보다 작거나 표현식에 이전에 캡처 한 왼쪽 괄호가 많으면 전체 시퀀스가 ​​역 참조로 사용됩니다. 이것의 작동 방식에 대한 설명은 괄호 안에있는 하위 패턴에 대한 설명에 따라 나중에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5f48d8244b80a669bed1a5d54a7009aee304b1e6" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of the used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="translated">힙 덤프 기능은 아직 초기 단계이지만 이미 우리에게 유용하다는 것이 입증되었으므로 유용 할 수 있습니다. 힙 덤프를 얻으려면 &lt;code&gt;-d:nimTypeNames&lt;/code&gt; 로 컴파일하고 프로그램의 전략적 위치에서 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 를 호출 하십시오. 그러면 프로그램에서 사용 된 유형 목록과 모든 유형에 대해이 유형에 대한 총 오브젝트 인스턴스 양과 해당 인스턴스가 차지하는 총 바이트 수가 생성됩니다. 이 목록은 현재 분류되지 않았습니다! 정렬하려면 외부 쉘 스크립트 해킹을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="50e42170b04192c54cd732656dcd94cd8243444d" translate="yes" xml:space="preserve">
          <source>The highest (absolute) return value of all processes is returned. Runs &lt;code&gt;beforeRunEvent&lt;/code&gt; before running each command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5e3bf19f9b933b2e60a2ad18d610252c1b05a5" translate="yes" xml:space="preserve">
          <source>The hooks of a tuple type &lt;code&gt;(A, B, ...)&lt;/code&gt; are generated by lifting the hooks of the involved types &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, ... to the tuple type. In other words, a copy &lt;code&gt;x = y&lt;/code&gt; is implemented as &lt;code&gt;x[0] = y[0]; x[1] = y[1]; ...&lt;/code&gt;, likewise for &lt;code&gt;=sink&lt;/code&gt; and &lt;code&gt;=destroy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="translated">요청한 클라이언트의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="translated">가능한 경우 한 자리 숫자로, 0-23 범위입니다.</target>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="translated">가능하면 한 자리수의 시간입니다. 1-12 범위.</target>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="translated">항상 두 자리 숫자로 표시됩니다. 시간이 한 자리이면 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="translated">항상 두 자리 숫자로 표시됩니다. 시간이 한 자리이면 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="8756b39644a0477a0c2e1fe04a5c8675b5957021" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit, 0 is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9394e30e2a196f91ca01b9ff5b59502413c00a" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;code&gt;type&lt;/code&gt; modifier to create a named instance of the type itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 키워드 다음의 식별자 는 현재 일치하는 유형의 인스턴스를 나타냅니다. 보다 구체적인 유형의 인스턴스를 나타 내기 위해 &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ptr&lt;/code&gt; 및 &lt;code&gt;static&lt;/code&gt; 과 같은 표준 유형 수정자를 적용 할 수 있습니다 . &lt;em&gt;형식&lt;/em&gt; 수정자를 적용 하여 형식 자체의 명명 된 인스턴스를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="866a5085cacac6b94172240b1efcb741ff5bdf86" translate="yes" xml:space="preserve">
          <source>The identity hash. I.e. &lt;code&gt;hashIdentity(x) = x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="translated">idetools 명령은 컴파일러 서비스 (CAAS)로 실행될 수 있습니다. 여기서 컴파일러를 먼저 시작하면 서버처럼 온라인 상태를 유지하면서 텔넷과 같은 방식으로 쿼리를 수락합니다. 계속 유지하는 장점은 많은 쿼리의 경우 컴파일러가 컴파일 결과를 캐시 할 수 있으며 후속 쿼리는 밀리 초 범위에서 빠르므로 IDE에 충분히 응답해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="translated">if 문은 제어 흐름을 분기하는 한 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="translated">가상의 단위. &amp;radic;-1.</target>
        </trans-unit>
        <trans-unit id="5e0323c86252bd503934591b5f403aa76daecc18" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#templates-typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="translated">즉각적인 pragma는 더 이상 사용되지 않습니다. &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;형식화 된 매개 변수와 형식화되지 않은 매개 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="translated">구현은 최상의 액세스 성능을 위해 필드를 정렬합니다. 정렬은 C 컴파일러가 수행하는 방식과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="294358e6a281776103afaeb5e6074dc4ee530170" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for the best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="translated">구현은 현재 다음과 같은 가능한 옵션을 제공합니다 (다양한 옵션이 나중에 추가 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="translated">컴파일 캐시의 구현은 까다 롭습니다. 프론트 엔드 및 백엔드에 대해 해결해야 할 많은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="translated">&lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; 유형 pragma를 통해 암시 적 초기화를 방지 할 수도 있습니다 . 컴파일러는 객체와 모든 필드를 명시 적으로 초기화해야합니다. 그러나 변수가 초기화되었음을 증명하기 위해 &lt;span id=&quot;control-flow-analysis_1&quot;&gt;제어 흐름 분석&lt;/span&gt; 을 수행하며 구문 특성에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="041f7a809d44d21475e39cf4f429bf17b9449128" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However, it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="translated">&lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma를 사용하여 최적화 이유로 암시 적 초기화를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="translated">들여 쓰기 처리는 다음과 같이 구현됩니다. 어휘 분석기는 다음 토큰에 앞의 공백 수를 주석 처리합니다. 들여 쓰기는 별도의 토큰이 아닙니다. 이 방법을 사용하면 1 토큰만으로 Nim을 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="translated">인덱스 생성 도구에서 생성 된 문서를 구분하려고 &lt;code&gt;.nim&lt;/code&gt; 에서 생성 된 파일 및 문서 &lt;code&gt;.txt&lt;/code&gt; 또는 &lt;code&gt;.rst&lt;/code&gt; 파일. 전자는 항상 소스 코드와 밀접한 관련이 있으며 주로 API 항목으로 구성됩니다. 후자는 사람이 읽을 수있는 일반적인 문서입니다.</target>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; 을 호출하지 않으면 인덱스가 디스크에 기록되지 않습니다 . 색인의 목적은 &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen 도구 안내서에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="94bc31946d2cd011244938f6920b84d9ad9961d9" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#related-options-index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcd5411b31ff678f2d8be730a52fa311b3d1c92" translate="yes" xml:space="preserve">
          <source>The indices of the element range that should be rotated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">읽기 / 쓰기 추적에 대한 유추는 예외 추적에 대한 유추와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="translated">태그 추적에 대한 유추는 예외 추적에 대한 유추와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">인라인 규칙은 호출자가 프로 시저를 호출하지 말고 코드를 직접 인라인해야 함을 의미합니다. Nim은 인라인되지 않지만 C 컴파일러에 남겨 둡니다. &lt;code&gt;__inline&lt;/code&gt; 프로 시저를 생성 합니다. 이것은 단지 컴파일러에 대한 힌트 : 완전히 무시할 수 있으며, 그것은으로 표시되지 않은 절차 인라인 수 있습니다 &lt;code&gt;inline&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07ea325a19c222cc3708d3f67c25509be2bcbf07" translate="yes" xml:space="preserve">
          <source>The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="translated">스레드와 예외 간의 상호 작용은 간단합니다. 한 스레드에서 &lt;em&gt;처리 된&lt;/em&gt; 예외는 다른 스레드에 영향을 줄 수 없습니다. 그러나 하나의 스레드에서 &lt;em&gt;처리되지 않은&lt;/em&gt; 예외는 전체 &lt;em&gt;프로세스를&lt;/em&gt; 종료합니다 !</target>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="translated">흥미로운 점은 매크로가 런타임 &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; 객체를 반환하지 않는다는 것입니다 . 대신 Nim 소스 코드를 &lt;code&gt;source&lt;/code&gt; 변수에 빌드합니다 . 구성 파일의 각 행에 대해 &lt;code&gt;const&lt;/code&gt; 변수가 생성됩니다 (15 행). 충돌을 피하기 위해이 변수 앞에 &lt;code&gt;cfg&lt;/code&gt; 를 붙 입니다. 본질적으로 컴파일러가 수행하는 작업은 매크로를 호출하는 행을 다음 코드 스 니펫으로 바꾸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="translated">내부 문서는 컴파일러 구현 방법을 설명합니다. 컴파일러를 해킹하려면 이것을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="1452e6f81083a81acdb84eb68518f3f09d626249" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="translated">두 세트의 교집합은 수학적으로 &lt;em&gt;A &amp;cap; B&lt;/em&gt; 로 표시 되며 동시에 &lt;em&gt;s1&lt;/em&gt; 및 &lt;em&gt;s2의&lt;/em&gt; 구성원 인 모든 객체의 세트입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="0bac8e37845bee3e0695f85e57beaf804a472bb1" translate="yes" xml:space="preserve">
          <source>The jump function for the generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="translated">언어 구조는 BNF의 확장을 사용하여 설명한다 &lt;code&gt;(a)*&lt;/code&gt; 의미 0 이상의 의, &lt;code&gt;a+&lt;/code&gt; 수단은 1 이상의 의, 그리고 &lt;code&gt;(a)?&lt;/code&gt; 선택적인 &lt;em&gt;a를&lt;/em&gt; 의미합니다 . 괄호는 요소를 그룹화하는 데 사용될 수 있습니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 가장 큰 양수입니다.</target>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 가장 큰 양수입니다.</target>
        </trans-unit>
        <trans-unit id="910c1473620a01923d2bc965b1cb67bc12d9a347" translate="yes" xml:space="preserve">
          <source>The last statement of &lt;code&gt;body&lt;/code&gt; has special syntax that specifies the collection's add operation. Use &lt;code&gt;{e}&lt;/code&gt; for set's &lt;code&gt;incl&lt;/code&gt;, &lt;code&gt;{k: v}&lt;/code&gt; for table's &lt;code&gt;[]=&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; for seq's &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="translated">연도의 마지막 두 자리. 구문 분석 할 때 현재 세기가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf5dbfc21433db13ae75eecfb40f44883518b3c" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="translated">마지막 두 매개 변수는 인증서 파일 경로와 키 파일 경로를 지정합니다. 서버 소켓은 이러한 파일이 없으면 작동하지 않을 가능성이 높습니다. 다음 명령을 사용하여 인증서를 생성 할 수 있습니다. &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="translated">let 문</target>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="translated">문자 'l'은 식별자로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="translated">라이브러리는 이름을 짧지 만 의미있게 유지하기 위해 일반적인 약어를 사용하는 간단한 이름 지정 체계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">라이브러리는 이름을 짧지 만 의미있게 유지하기 위해 공통 약어를 사용하는 간단한 이름 지정 체계를 사용합니다. 버전 0.8.2부터이 구성표에 맞게 많은 기호의 이름이 바뀌 었습니다. 궁극적 인 목표는 프로그래머 가 이름을 &lt;em&gt;추측&lt;/em&gt; 할 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e9fa62619261048f21f9083a33a88350d8f41816" translate="yes" xml:space="preserve">
          <source>The lifetime of &lt;code&gt;v&lt;/code&gt; must not exceed &lt;code&gt;b&lt;/code&gt;'s lifetime. Note: The lifetime of a parameter is the complete proc body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b593bd8a0a8e61e207ea44310ff8458416c946da" translate="yes" xml:space="preserve">
          <source>The list of registered handlers is also a thread-local variable. If a handler will be used in multiple threads, it needs to be registered in each of those threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="translated">여기에 나열된 pragma는 proc / method / converter의 코드 생성 옵션을 대체하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c515c4489fec51db2bb23bd53fd52c5cb33b8c63" translate="yes" xml:space="preserve">
          <source>The logger that was created above logs to the console, but this module also provides loggers that log to files, such as the &lt;a href=&quot;#FileLogger&quot;&gt;FileLogger&lt;/a&gt;. Creating custom loggers is also possible by inheriting from the &lt;a href=&quot;#Logger&quot;&gt;Logger&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="translated">배열 또는 시퀀스의 하한은 내장 proc &lt;code&gt;low()&lt;/code&gt; 에 의해 수신 될 수 있으며 , &lt;code&gt;high()&lt;/code&gt; 은 high ()에 의해 제한됩니다 . 길이는 &lt;code&gt;len()&lt;/code&gt; 의해 수신 될 수 있습니다 . 시퀀스 또는 열린 배열의 경우 &lt;code&gt;low()&lt;/code&gt; 는 항상 유효한 인덱스이므로 0을 반환합니다. &lt;code&gt;add()&lt;/code&gt; proc 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 를 사용하여 시퀀스에 요소를 추가 하고 &lt;code&gt;pop()&lt;/code&gt; proc를 사용하여 시퀀스의 마지막 요소를 제거 (및 가져 오기) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="translated">매크로 호출은 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="translated">매뉴얼에서는 &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim 문자열이 암시 적으로 cstring으로 변환되어&lt;/a&gt; 상호 작용이 일반적으로 고통스럽지 않다고 언급합니다 . &lt;code&gt;cstring&lt;/code&gt; 으로 변환 된 Nim 문자열을 허용하는 대부분의 C 함수 는이 문자열을 그대로 유지할 필요가 없으며 반환 할 때 더 이상 문자열이 필요하지 않습니다. 그러나 Nim 문자열을 보존하고 C 백엔드에서 &lt;code&gt;cstring&lt;/code&gt; 으로 사용할 수있는 드문 경우에는 문자열 데이터가 &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; 및 &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt; 로 해제되지 않도록 수동으로 방지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4e04e7f0f6d6096c8019755aeb455838200906b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#types-cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed anymore. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref,string&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref,string&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="translated">일치하는 도트 연산자는 원하는 효과에 따라 호출 가능한 종류 (프로세스, 템플릿 및 매크로)의 심볼 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="translated">일치하는 AST는 호출 / 적용 식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="translated">일치하는 AST는 lvalue 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="translated">일치하는 AST에는 부작용이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="translated">일치하는 AST에는 부작용이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="translated">일치하는 AST에는 지정된 종류가 있어야합니다. (예 : &lt;code&gt;nkIfStmt&lt;/code&gt; 는 &lt;code&gt;if&lt;/code&gt; 문을 나타냅니다 .)</target>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="translated">컴파일러가 상수 접기와 같은 일부 최적화를 수행 한 후에 일치가 수행되므로 다음이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="translated">일치하는 노드에는 하위가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="translated">일치하는 노드는 &quot;abc&quot;, 12와 같은 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="translated">일치하는 노드는 심볼 (바운드 식별자)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="translated">일치하는 노드는 식별자 (바운드되지 않은 식별자) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="translated">본문에 읽을 최대 내용 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c950d90d5b11970c79ac7afd395e119a17d543c0" translate="yes" xml:space="preserve">
          <source>The maximum file size limit that &lt;code&gt;staticRead&lt;/code&gt; and &lt;code&gt;slurp&lt;/code&gt; can read is near or equal to the &lt;em&gt;free&lt;/em&gt; memory of the device you are using to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddb524c9857d48d426ebc459d6731f3dbdd9f9e" translate="yes" xml:space="preserve">
          <source>The maximum redirects can be set with the &lt;code&gt;maxRedirects&lt;/code&gt; of &lt;code&gt;int&lt;/code&gt; type, it specifies the maximum amount of redirects to follow, it defaults to &lt;code&gt;5&lt;/code&gt;, you can set it to &lt;code&gt;0&lt;/code&gt; to disable redirects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ed4b73757fde9ceb2aef3183ba998698e7a6f6" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">의 최대 값 &lt;em&gt;(X)&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="translated">두 정수의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="ea3e62d4781ad1dfcb8a4591e57dc4622e4ae0f5" translate="yes" xml:space="preserve">
          <source>The memory management for Nim's standard &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;seq&lt;/code&gt; types as well as other standard collections is performed via so-called &quot;Lifetime-tracking hooks&quot; or &quot;type-bound operators&quot;. There are 3 different hooks for each (generic or concrete) object type &lt;code&gt;T&lt;/code&gt; (&lt;code&gt;T&lt;/code&gt; can also be a &lt;code&gt;distinct&lt;/code&gt; type) that are called implicitly by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="translated">메소드 호출 구문은 명시적인 일반 인스턴스화와 충돌합니다. &lt;code&gt;x.p[T]&lt;/code&gt; 는 항상 &lt;code&gt;(x.p)[T]&lt;/code&gt; 로 구문 분석 되므로 &lt;code&gt;p[T](x)&lt;/code&gt; 는 &lt;code&gt;x.p[T]&lt;/code&gt; 로 쓸 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e29a37d51a470bd093573ef80de02da80f8ae42c" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">최소 값 &lt;em&gt;(X)&lt;/em&gt; . &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="translated">두 정수의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="translated">가능한 경우 1 자리의 분입니다.</target>
        </trans-unit>
        <trans-unit id="8120849383a0dce81fbc77edaa154da4bae069f9" translate="yes" xml:space="preserve">
          <source>The minutes in one digit if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6835c438c5815928aa2df14ad04c857ef1631d" translate="yes" xml:space="preserve">
          <source>The module contains a default Rand state for convenience. It corresponds to the default random number generator's state. The default Rand state always starts with the same values, but the &lt;a href=&quot;#randomize&quot;&gt;randomize proc&lt;/a&gt; can be used to seed the default generator with a value based on the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5990e415167b1e53c0b5e58fc592b231b04e133e" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;code&gt;noIntrinsicsBitOpts&lt;/code&gt; to disable compiler intrinsics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="translated">백엔드가 지원되지 않는 경우 모듈은 순수 nim procs로 대체됩니다. &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; 플래그 를 사용하여 컴파일러 내장 함수를 비활성화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd9fc72b4ada2f752486fbb515d1c9c09d7aa8f3" translate="yes" xml:space="preserve">
          <source>The month as an enum, the ordinal value is in the range 1 to 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="translated">가능하면 한 자리수의 월입니다.</target>
        </trans-unit>
        <trans-unit id="8ffdd973b77981374afa6bab23748caa6eb3c1fe" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended if the month value is one digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="translated">항상 두 자리 숫자로 된 월입니다. 0이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="translated">RTTI의 가장 중요한 이유. 순회 프로 시저를 생성하면 더 큰 코드가 생성되고 동적 프로 시저 바인딩을 예측하기 어렵 기 때문에 최신 하드웨어에서는 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="translated">예외를 처리하는 가장 신뢰할 수있는 방법 은 미래에 &lt;code&gt;yield&lt;/code&gt; 을 사용 하고 미래의 &lt;code&gt;failed&lt;/code&gt; 자산 을 확인하는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="translated">이 명령들 사이의 가장 중요한 차이점은 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리를 살펴보면 &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt; 또는 &lt;code&gt;.m&lt;/code&gt; 파일을 찾을 수 있다는 것 외에 다른 모든 파일이 프로젝트의 기본 바이너리를 생성한다는 것입니다. 이를 통해 생성 된 코드를 가져 와서 이러한 언어를 사용하여 프로젝트에 직접 배치 할 수 있습니다. 다음은 일반적인 명령 행 호출입니다.</target>
        </trans-unit>
        <trans-unit id="a72f50212d0085eb823c7d6f12ded16312fb8518" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command- line invocations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="translated">시간대의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ec06ca30d3763f24610615079488aee1dec49148" translate="yes" xml:space="preserve">
          <source>The need to check for self-assignments and also the need to destroy previous objects inside &lt;code&gt;=copy&lt;/code&gt; and &lt;code&gt;=sink&lt;/code&gt; is a strong indicator to treat &lt;code&gt;system.swap&lt;/code&gt; as a builtin primitive of its own that simply swaps every field in the involved objects via &lt;code&gt;copyMem&lt;/code&gt; or a comparable mechanism. In other words, &lt;code&gt;swap(a, b)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; implemented as &lt;code&gt;let tmp = move(b); b = move(a); a = move(tmp)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="translated">일반적인 &lt;code&gt;import&lt;/code&gt; 문은 모든 내 보낸 심볼을 가져옵니다 . 이는 &lt;code&gt;except&lt;/code&gt; 한정자 로 제외해야하는 이름 지정 기호로 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="translated">일반적인 작업 모드는 &lt;code&gt;ProcRun&lt;/code&gt; 이라고 하며 명령 줄에서 Nim 컴파일러를 수동으로 실행하는 것과 유사하게 각 명령 또는 쿼리에 대한 프로세스를 시작합니다. &lt;code&gt;CaasRun&lt;/code&gt; 의 모드는 모든 쿼리에 응답하는 서버 프로세스를 시작합니다. &lt;code&gt;SymbolProcRun&lt;/code&gt; 의 모드는 컴파일러 개발자에 의해 사용됩니다. 즉, 모든 테스트를 실행하려면 모든 &lt;code&gt;*.txt&lt;/code&gt; 파일을 세 번 처리해야 하므로 시간이 많이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[i]&lt;/code&gt; 표기법을 사용하여 &lt;code&gt;x&lt;/code&gt; 의 i 번째 요소에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="translated">표기 &lt;code&gt;x[i]&lt;/code&gt; 액세스의 i 번째의 요소에 사용되는 &lt;code&gt;x&lt;/code&gt; . 배열 액세스는 항상 범위를 검사합니다 (컴파일 타임 또는 런타임시). pragma를 통해 또는 &lt;code&gt;--bound_checks:off&lt;/code&gt; 명령 줄 스위치 를 사용하여 컴파일러를 호출하여 이러한 검사를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="translated">PEG에 사용 된 표기법은 EBNF와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="translated">다음 결합 문자를 포함하여 's [i]'에 속하는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="0766850e8af24901ac224e38448b654947018953" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to byte index &lt;code&gt;s[i]&lt;/code&gt;, including following combining code unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a065c415acb39bca6dfbf84627b78c96bd774e" translate="yes" xml:space="preserve">
          <source>The number of days since January 1, in the range 0 to 365.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4bc3865db45d046e1df4ff74764ae23a55e1d4" translate="yes" xml:space="preserve">
          <source>The number of hours past midnight, in the range 0 to 23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52a4ac082994b235155e44e2290132cb04c90c6" translate="yes" xml:space="preserve">
          <source>The number of minutes after the hour, in the range 0 to 59.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3348856fb20c7700d32dbefabea6931ef860b4c" translate="yes" xml:space="preserve">
          <source>The number of nanoseconds after the second, in the range 0 to 999_999_999.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e92dae4acdb9d413c25e9143865ccec7ea6c1c" translate="yes" xml:space="preserve">
          <source>The number of seconds after the minute, in the range 0 to 59.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="translated">숫자는 모든 GC 힙의 개체 수를 계산하며 현재 스레드뿐만 아니라 실행중인 모든 스레드를 나타냅니다. 현재 스레드는 &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; 를 호출하는 스레드입니다 . 이는 이후 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fbf19ead5eb4522c5f0e525c80f22c80dfd57c" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all garbage collector heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="translated">숫자 식별자는 난수 일뿐입니다. 번호는 처리중인 파일에서 심볼의 섹션과 위치에 따라 지정되며 상수에 의존해서는 안됩니다. 심볼을 추가하거나 제거하면 숫자가 뒤섞 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="translated">idetools의 사용은 사용자가 커서를 심볼에 놓거나 두 번 클릭하는 정의와 같은 정의에 적합하며 해당 심볼이 정의 된 위치에서 1 초 또는 2 초 후에 IDE가 표시됩니다. 이러한 대기 시간은 기호 제안과 같은 기능에 끔찍할 것입니다. 그리고 우리가 그것을 피할 수 있다면 왜 기다려야합니까?</target>
        </trans-unit>
        <trans-unit id="25d3919cb8bebc916c007785d723e89c51ae1b68" translate="yes" xml:space="preserve">
          <source>The offset in seconds west of UTC, including any offset due to DST. Note that the sign of this number is the opposite of the one in a formatted offset string like &lt;code&gt;+01:00&lt;/code&gt; (which would be equivalent to the UTC offset &lt;code&gt;-3600&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="translated">일이 쉽지 않은 유일한 경우는 가비지 수집기가 작동하기 위해 어셈블러 조정이 필요한 경우입니다. 표준 버전의 GC는 C의 &lt;code&gt;setjmp&lt;/code&gt; 기능을 사용하여 모든 레지스터를 하드웨어 스택에 저장합니다. 새 플랫폼에서이 일반 코드를 일부 어셈블러 코드로 바꿔야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="translated">해당 파일의 내용과이 proc에서 제공하는 값의 유일한 차이점은 &lt;code&gt;doc.file&lt;/code&gt; 변수입니다. 구성 파일 의 &lt;code&gt;doc.file&lt;/code&gt; 변수에는 독립형 페이지를 빌드하기위한 HTML이 포함되어 있으며이 proc은 &lt;code&gt;rstToHtml&lt;/code&gt; 과 같은 프로세스 의 컨텐츠 만 반환 하여 최소 HTML을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="translated">&lt;code&gt;floatChecks&lt;/code&gt; pragma의 영향을받는 유일한 작업은 부동 소수점 유형에 대한 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="899d5fc602ad3db90bd279ddd77881c1cca58eeb" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="translated">openarray 유형은 중첩 될 수 없습니다. 다차원 openarray는 거의 필요하지 않으며 효율적으로 수행 할 수 없기 때문에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="translated">작업은 원자 적으로 수행되며 &lt;code&gt;mapper&lt;/code&gt; 가 호출되는 동안 테이블의 다른 작업은 차단 되므로 짧고 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="translated">연산에서 무한 정밀도로 표현할 수없는 결과가 생성되었습니다 (예 : &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="translated">연산은 지수 범위를 초과하는 결과를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="translated">연산에서 너무 작아서 일반 숫자로 표시 할 수없는 결과가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="translated">연산자의 우선 순위는 첫 문자로 결정됩니다. 자세한 내용은 매뉴얼에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="translated">연산자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 가 중위 표기법으로 작성된 패턴에 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="translated">연산자는 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; BOOL 타입에 대해 정의된다. &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 사업자 단락 평가를 수행한다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="translated">연산자는 &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; BOOL 타입에 대해 정의된다. &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 운영자는 바로 가기 평가를 수행합니다. 예:</target>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="translated">선택적 '채우기'문자는 필드를 최소 너비로 채우는 데 사용되는 문자를 정의합니다. 채우기 문자 (있는 경우) 뒤에 정렬 플래그가 와야합니다.</target>
        </trans-unit>
        <trans-unit id="61a4c0792ebff9a51436a6a10512fd4b427609a0" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;shortNoVal&lt;/code&gt; and &lt;code&gt;longNoVal&lt;/code&gt; parameters present in &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt; are for specifying which short and long options do not accept values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="translated">선택적 align 플래그는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="translated">(키, 값) 쌍의 순서가 유지되므로 &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt; 과 같이 순서가 지정된 dict을 쉽게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="translated">교체 순서는 중요합니다. 인수 목록에서 이후의 교체보다 이전의 교체가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="3108768a24a46c2d1623f6a7352dae8089ca7973" translate="yes" xml:space="preserve">
          <source>The ordinary assignment in Nim conceptually copies the values. The &lt;code&gt;=copy&lt;/code&gt; hook is called for assignments that couldn't be transformed into &lt;code&gt;=sink&lt;/code&gt; operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="translated">그러면 원래 모듈 이름에 액세스 할 수 없습니다. &lt;code&gt;path/to/module&lt;/code&gt; 또는 &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; 표기법을 사용하여 하위 디렉토리의 모듈을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7414b6f4b65521aaf6120245a6e651f68d1e5a" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;code&gt;width&lt;/code&gt; is less than or equal to &lt;code&gt;s.len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;width&lt;/em&gt; 가 &lt;em&gt;s.len&lt;/em&gt; 보다 작거나 같은 경우 원래 문자열이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="translated">또 다른 이유는 더티 파일이 디스크의 어느 위치 (예 : tmpfs)에도 나타날 수 있지만 상대 경로 등을 사용할 때 원래 모듈과 일치하는 경로를 갖는 것으로 간주해야합니다. 그러나 쿼리는 일반 파일 이름 대신 답변에 더티 모듈 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25c28b6460c3b06db65db14b1f5007e28412aff" translate="yes" xml:space="preserve">
          <source>The outcome of the &lt;a href=&quot;math#cumsum,openArray%5BT%5D&quot;&gt;cumsum&lt;/a&gt; proc and the return value of the &lt;a href=&quot;math#cumsummed,openArray%5BT%5D&quot;&gt;cumsummed&lt;/a&gt; proc, which are both in the math module, can be used as the &lt;code&gt;cdf&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="translated">HTML 및 LaTeX의 출력은 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 및 &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; 구성 파일에서 제공됩니다. 이러한 파일을 프로젝트에 추가하고 수정하여 docgen 출력의 모양을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="translated">출력은 입력 길이의 두 배입니다. &lt;code&gt;0x&lt;/code&gt; 와 같은 접두사 는 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="translated">테스트의 출력 상세도.</target>
        </trans-unit>
        <trans-unit id="608798a73678f1416a011aa2b8e46d174cf55393" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked during semantic analysis to be free of data races. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="translated">병렬 명령문은 Nim 프로그램에서 병렬 처리를 도입하기 위해 선호되는 메커니즘입니다. Nim 언어의 하위 세트는 &lt;code&gt;parallel&lt;/code&gt; 섹션 내에서 유효합니다 . 이 서브셋은 컴파일 타임에 데이터 레이스가 없는지 확인합니다. 정교한 &lt;span id=&quot;disjoint-checker_1&quot;&gt;분리형 검사기&lt;/span&gt; 는 공유 메모리가 광범위하게 지원 되더라도 데이터 레이스가 불가능하다는 것을 보장합니다!</target>
        </trans-unit>
        <trans-unit id="c93630ff32d61caf48c2f2e72e2c5aa9f904f95c" translate="yes" xml:space="preserve">
          <source>The parameters are in reverse order! &lt;code&gt;a in b&lt;/code&gt; is a template for &lt;code&gt;contains(b, a)&lt;/code&gt;. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the &lt;code&gt;in&lt;/code&gt; operator that would be the wrong direction for this piece of code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="translated">매개 변수의 유형은 일반 유형 또는 메타 유형 &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt; 또는 &lt;code&gt;type&lt;/code&gt; 일 수 있습니다. &lt;code&gt;type&lt;/code&gt; 은 형식 기호 만 인수로 제공 될 수 있으며 &lt;code&gt;untyped&lt;/code&gt; 않음은식이 템플릿에 전달되기 전에 기호 조회 및 형식 확인이 수행되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2bbf11b9701162a2035c4b55918733e64b1b5f9b" translate="yes" xml:space="preserve">
          <source>The parser object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="translated">파서는 들여 쓰기 수준의 스택을 사용합니다. 스택은 공백을 세는 정수로 구성됩니다. 들여 쓰기 정보는 구문 분석기의 전략적 위치에서 조회되지만 그렇지 않으면 무시됩니다. 의사 터미널 &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 는 스택 맨 위에있는 항목보다 많은 공간으로 구성된 들여 쓰기를 나타냅니다. 같은 수의 공백이있는 들여 쓰기를 &lt;code&gt;IND{=}&lt;/code&gt; 로 지정하십시오. &lt;code&gt;DED&lt;/code&gt; 는 스택에서 값을 팝하는 &lt;em&gt;동작&lt;/em&gt; 을 설명하는 또 다른 의사 터미널이며 , &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; 는 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="abe385c190c44ec425b363f1b29f850fc6d40616" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo-terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75d284a399469fffe0947c898a06ce009bcfbbc" translate="yes" xml:space="preserve">
          <source>The passed file handle will no longer be inheritable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="translated">경로 분석은 &lt;strong&gt;현재&lt;/strong&gt; 소리가 좋지 않지만 그것이 쓸모없는 것은 아닙니다. 두 경로가 구문 상 동일하면 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0bbaeda5d44901c81ebec10bdd7c6c2aed094901" translate="yes" xml:space="preserve">
          <source>The path returned by this proc is set at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17327de092c7c00324e920e1dec0a84488b2def" translate="yes" xml:space="preserve">
          <source>The path returned by this template is set at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="translated">심볼의 일반 이름은 완전히 내 보낸 서명의 단순화 된 버전입니다. 변수 또는 상수는 복잡한 이름과 동일한 일반 이름 기호를 갖습니다. procs, 템플릿 및 기타 호출 가능한 유형의 일반 이름은 매개 변수, 반환 유형 및 pragma를 제거한 후 인용되지 않은 값입니다. 일반 이름을 사용하면 과부하로 인해 충돌하는 모듈이없는 경우 작동하는 짧고 멋진 심볼 링크가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 와 일치하는 부분 은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="translated">여기에 나열된 pragma는 컴파일시 -d /-define 옵션의 값을 선택적으로 승인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d21bc5558df5db984c197f09719a14cdbc33c2" translate="yes" xml:space="preserve">
          <source>The predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;countIt(@[1, 2, 3], it &amp;gt; 2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="translated">여기서 문제는 컴파일러가 이미 &lt;code&gt;toSeq&lt;/code&gt; 가 시퀀스로 변환 할 수있는 기회를 얻기 전에이 컨텍스트에서 iterator로서 &lt;code&gt;something()&lt;/code&gt; 을 호출 할 수 없다고 결정했다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9efd7fdcbe1a2580f7c97b1293f83d8747130a12" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;getSourceLanguage&lt;/code&gt; can get the language &lt;code&gt;enum&lt;/code&gt; from a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="translated">proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; 는 nim 프로그램이 예상되는 동작 인 플랫폼에 대해 사건없이 종료 될 때 암시 적으로 호출됩니다. 처리되지 않은 예외 예외는 &lt;code&gt;quit(QuitFailure)&lt;/code&gt; 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="translated">이 proc은 서버가 설정 한 &quot;Set-Cookie&quot;헤더가 아니라 클라이언트가 설정 한 Cookie 헤더를 구문 분석하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b711effa5493572608721c0ecb5734464843d0bf" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="translated">이 프로시 저는 여러 다른 공통 구문에 대한 출력을 사용할 수 있도록 설계되었습니다. &lt;strong&gt;참고&lt;/strong&gt; : Ansi C 코드 생성에는 올바르지 않습니다!</target>
        </trans-unit>
        <trans-unit id="888e3f99a533bb35f9c99bb61e235d2938bc6ca0" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section can be a single section that is wrapped around the complete routine body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa4a16f221969c520c65e78c146e6b52b5ba0e3" translate="yes" xml:space="preserve">
          <source>The produced &lt;code&gt;finally&lt;/code&gt; section is wrapped around the enclosing scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70d2b5b4c0766ea2a1f51de97640c064876e562" translate="yes" xml:space="preserve">
          <source>The program should output something similar to this, but keep in mind that exact results may vary in the real world:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;store&lt;/code&gt; 또는 &lt;code&gt;retrFile&lt;/code&gt; 프로 시저에 &lt;code&gt;onProgressChanged&lt;/code&gt; 프로 시저를 지정하여 파일 업로드 또는 파일 다운로드의 진행 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="translated">프로젝트는 더 이상 사용되지 않는 구성 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7aa2521596d9cb923517dba0d10349946353eba" translate="yes" xml:space="preserve">
          <source>The prototype of this hook for a type &lt;code&gt;T&lt;/code&gt; needs to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620c5eb2026cba7aa4895fcb3b5e5d494f483084" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;DivByZeroDefect&lt;/code&gt; inherits from &lt;code&gt;Defect&lt;/code&gt; and with &lt;code&gt;--panics:on&lt;/code&gt; Defects become unrecoverable errors. (Since version 1.4 of the language.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93069592ba4d6f8e60f9caaf9f5719067988adf0" translate="yes" xml:space="preserve">
          <source>The reason for this is that code like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9881783f395bf3db49786bb66c14efa31cbb346" translate="yes" xml:space="preserve">
          <source>The reason is that sets are implemented as high performance bit vectors. Attempting to declare a set with a larger type will result in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="translated">그 이유는 컴파일러가 이미 &lt;code&gt;echo&lt;/code&gt; 문에 대해 1을 &quot;1&quot;로 변환했기 때문입니다 . 그러나 매크로 다시 쓰기라는 용어는 의미를 변경해서는 안됩니다. 실제로 &lt;code&gt;--patterns:off&lt;/code&gt; 명령 행 옵션으로 또는 일시적으로 &lt;code&gt;patterns&lt;/code&gt; pragma 로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="944e6805f1095e70b434b5bd328b942c9eebd4e8" translate="yes" xml:space="preserve">
          <source>The reasoning is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="translated">이 코드를 컴파일 타임 proc로 다시 구현 하면 바이너리를 따라 배포 해야하는 &lt;code&gt;data.cfg&lt;/code&gt; 파일을 제거 할 수 있으며 정보가 실제로 일정하면 논리적으로 볼 수 없습니다 전역 변수에서 &lt;em&gt;변경 가능&lt;/em&gt; 하도록하려면 상수이면 더 좋습니다. 마지막으로 가장 가치있는 기능인 컴파일 타임에 일부 검증을 구현할 수 있습니다. 모든 것이 정확하지 않으면 바이너리를 얻는 것이 불가능하기 때문에 이것을 &lt;em&gt;더 나은 단위 테스트&lt;/em&gt; 라고 생각할 수 있습니다. 작은 중요한 파일이 없거나 내용이 변경되어 시작되지 않는 손상된 프로그램을 사용자에게 제공 할 수 없습니다 잘못된 것으로 실수.</target>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="translated">형식과 접미사 간의 관계 는 &lt;code&gt;compiler/docgen.nim&lt;/code&gt; 파일 의 proc &lt;code&gt;complexName&lt;/code&gt; 에 의해 이루어집니다 . 다음은 &lt;a href=&quot;system&quot;&gt;시스템 모듈&lt;/a&gt; 에서 복잡한 기호 이름의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="translated">기존 파일 제거</target>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="translated">바꾸기 필터는 각 줄의 하위 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="translated">의 표현 &lt;code&gt;if&lt;/code&gt; 표현은 미묘하지만 통과하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="translated">if 문의 표현은 미묘하지만 통과하기 쉽습니다. 어떤이없는 경우 &lt;code&gt;else&lt;/code&gt; 지점은, 더 &lt;code&gt;nnkElse&lt;/code&gt; 아이는 존재하지 않는다.</target>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="translated">응답의 본문 스트림을 동 기적으로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="translated">나머지 줄은 &lt;a href=&quot;re&quot;&gt;정규식으로&lt;/a&gt; 취급 되므로 괄호와 같은 메타 문자를 이스케이프 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f33b7db5192f55bbe370f8f53fab1a2ed0374f8" translate="yes" xml:space="preserve">
          <source>The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="translated">결과 클라이언트 소켓은 디스패처에 자동으로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="translated">결과 클라이언트는 서버 소켓의 모든 속성을 상속합니다. 예를 들어, 소켓이 버퍼링되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="58ccf12c816dba29cdb297d2baa539dbf718b0fd" translate="yes" xml:space="preserve">
          <source>The resulting state is independent of the default random number generator's state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9657a81f7e4e22d5602d19a05daddbb0eed4ab" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10dea8f7818ed973be79228742dcbd3138884e8" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;code&gt;len&lt;/code&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="translated">결과 문자열은 항상 &lt;em&gt;len&lt;/em&gt; 문자입니다. 선행 &lt;code&gt;0b&lt;/code&gt; 접두사가 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="translated">결과 문자열은 항상 &lt;em&gt;len&lt;/em&gt; 문자입니다. 선행 &lt;code&gt;0o&lt;/code&gt; 접두사가 생성 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="098958bf62961ccbbf03810cab1ba165ee727606" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;code&gt;prefix&lt;/code&gt; and suffixed with &lt;code&gt;suffix&lt;/code&gt;. Both may be empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="translated">결과 문자열 앞에 접두사가 &lt;em&gt;붙고&lt;/em&gt; 접미사가 &lt;em&gt;접미사로&lt;/em&gt; 붙습니다 . 둘 다 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="translated">결과 문자열은 앞에 0이 없을 수 있습니다. 길이는 항상 정확히 3입니다.</target>
        </trans-unit>
        <trans-unit id="f871e21f4ae6359465f4618b9a615e3d90900a7c" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;code&gt;len&lt;/code&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;code&gt;x&lt;/code&gt; is treated as an unsigned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="translated">결과 문자열은 정확히 &lt;em&gt;len&lt;/em&gt; 문자입니다. &lt;code&gt;0x&lt;/code&gt; 와 같은 접두사 는 생성 되지 않습니다 . &lt;em&gt;x&lt;/em&gt; 는 부호없는 값으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff39b06bbdb4341a3c2836e93082f26a34a7bb4" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;code&gt;minchars&lt;/code&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="translated">결과 문자열은 최소한됩니다 &lt;em&gt;minchars&lt;/em&gt; 긴 문자. 앞에 0을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="translated">호출 된 proc / iterator가 &lt;code&gt;discardable&lt;/code&gt; pragma 로 선언 된 경우 리턴 값을 내재적으로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="translated">호출 된 proc / iterator가 &lt;span id=&quot;discardable_1&quot;&gt;폐기 가능한&lt;/span&gt; pragma 로 선언 된 경우 리턴 값을 내재적으로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25d8ae7e238e57b8ff1a3ae56dc183c30b437cea" translate="yes" xml:space="preserve">
          <source>The return value is represented inside the body of a routine as the special &lt;span id=&quot;result_3&quot;&gt;result&lt;/span&gt; variable. This allows for a mechanism much like C++'s &quot;named return value optimization&quot; (&lt;span id=&quot;nrvo_1&quot;&gt;NRVO&lt;/span&gt;). NRVO means that the stores to &lt;code&gt;result&lt;/code&gt; inside &lt;code&gt;p&lt;/code&gt; directly affect the destination &lt;code&gt;dest&lt;/code&gt; in &lt;code&gt;let/var dest = p(args)&lt;/code&gt; (definition of &lt;code&gt;dest&lt;/code&gt;) and also in &lt;code&gt;dest = p(args)&lt;/code&gt; (assignment to &lt;code&gt;dest&lt;/code&gt;). This is achieved by rewriting &lt;code&gt;dest = p(args)&lt;/code&gt; to &lt;code&gt;p'(args, dest)&lt;/code&gt; where &lt;code&gt;p'&lt;/code&gt; is a variation of &lt;code&gt;p&lt;/code&gt; that returns &lt;code&gt;void&lt;/code&gt; and receives a hidden mutable parameter representing &lt;code&gt;result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="translated">리턴 된 &lt;code&gt;StringTableRef&lt;/code&gt; 에는 HTML 엔진이 최종 출력을 빌드하는 데 사용하는 매개 변수가 포함됩니다. 이 매개 변수의 정의와 목적에 대한 정보 는 컴파일러와 함께 제공되는 &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; 파일을 찾아보십시오 .</target>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="translated">모든 데이터가 지정된 파일에 기록되면 반환 된 Future는 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="08ac274d072334662c000b3093ec54665996d6d3" translate="yes" xml:space="preserve">
          <source>The returned string will have a rune-length of &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218ffc3b441a9be3f8e18751df3ec6089a753864" translate="yes" xml:space="preserve">
          <source>The root of Nim's object hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64043b281b98efb8bb51554afb42ae2b90889a5c" translate="yes" xml:space="preserve">
          <source>The rope's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="translated">컴파일 타임 계산에 대한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="translated">동일한 작업을 비동기식으로 수행 할 수도 있습니다. 간단히 &lt;code&gt;AsyncHttpClient&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf055ae5d7a11813fee9e56f81604099749907aa" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57a0f5b14742d12c24988b74a643647d6e014cc" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#*,IntSet,IntSet&quot;&gt;s1 * s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59178c6fa7f1c2f8547f8456a1befc217b20ce51" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c0ab47b65053cfe4fbb0c1f52fae0d0a057a41" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s1 + s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c286bec2a1c010ec13fa9455c84850edbfabf8eb" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-+-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 -+- s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2fb012b48cb0f33fa8dd5795c16758b107e2e" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a04f27a87dc64a5b3af5f2bfeab96ab2befb96" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s1 - s2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d403d0a3158f7f9caf11718e934542bcbbcbf185" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#escape,string&quot;&gt;result.add(escape(s))&lt;/a&gt;, but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55203671983834678f68df32a8f13dbf4dfa1cb5" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;, but works with any number of directory parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a036f8c2bc8d6fd4f9810b2d917dd44dc9677256" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#joinPath,string,string&quot;&gt;joinPath(head, tail) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="translated">같은과 같은 &lt;code&gt;add(s, formatstr % a)&lt;/code&gt; ,하지만 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;joinPath(head, tail)&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="translated">부모 디렉토리가 없으면 &lt;code&gt;parentDir(head) / tail&lt;/code&gt; 과 같습니다 . 그런 다음 &lt;code&gt;head / tail&lt;/code&gt; 가 대신 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="10d5f7b5b9b4599f963f76e595b9d0bc51dbc7a3" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt;, unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="translated">같은 &lt;em&gt;joinPath (머리, 꼬리)&lt;/em&gt; ,하지만 디렉토리 부품의 수와 함께 작동합니다. 최소한 하나의 요소를 전달해야합니다. 그렇지 않으면 proc이 디버그 빌드를 선언하고 릴리스 빌드에서 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit 반복자&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="0508e509b698b4d6f0cf31d5f5b62a59d7f990ff" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int,bool&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05c9b483502198e61912440774377608b767850" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,Rune,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488ed57d23acd7e77b2caaf8042dc1813401cb26" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="80aaf3a3a6c939a3044bf2ae3e445580283d1045" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,openArray%5BRune%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7e1196d1ae854b5b7db4b886b04c7902d49fd4" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt; 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="c568df5237500459922db2d4a0ccbe43081cd83d" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; 반복자 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="40c1516e7e4a0fb4ec604559d5cf4d9baa2aacc6" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1418168f1b08c4b0979b645260ef3e9404a43e" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace iterator&lt;/a&gt; (see its documentation), but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="translated">&lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; 반복자 와 동일 하지만 일련의 하위 문자열을 반환하는 proc입니다.</target>
        </trans-unit>
        <trans-unit id="054a8e23aeaf85595c411958cf0af98d8322986e" translate="yes" xml:space="preserve">
          <source>The same could have been achieved by manually iterating over a container and increasing each key's value with &lt;a href=&quot;#inc,CountTable%5BA%5D,A,Positive&quot;&gt;inc proc&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">같은 구문에 적용 &lt;code&gt;iterator&lt;/code&gt; (와 &lt;code&gt;nnkIteratorTy&lt;/code&gt; ),하지만 &lt;em&gt;하지 않습니다&lt;/em&gt; 에 적용되는 &lt;code&gt;converter&lt;/code&gt; 또는 &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="translated">scanp 매크로</target>
        </trans-unit>
        <trans-unit id="f71ea994a694d8297117d2c188599f3f7350c59a" translate="yes" xml:space="preserve">
          <source>The scope of the view does not matter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f812cc23782ffcc0d24f9418349fe228156d6e09" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;code&gt;*&lt;/code&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="translated">&lt;em&gt;*&lt;/em&gt; 의 두 번째 연산자 는 매개 변수 여야합니다. 모든 논증을 모으는 데 사용됩니다. 표현 &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; 에 전달되는 &lt;code&gt;optConc&lt;/code&gt; 에 (가지 특별한 목록으로 &lt;code&gt;nkArgList&lt;/code&gt; 호출 식으로 평평) 따라서 &lt;code&gt;optConc&lt;/code&gt; 를 호출 하면 다음이 생성됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="translated">시퀀스에는 최소한 하나의 요소가 있어야합니다. 이 상황에서는 프로그램의 디버그 버전이 표시되지만 릴리스 버전은 기꺼이 진행됩니다. 시퀀스에 단일 요소가있는 경우 &lt;code&gt;operation&lt;/code&gt; 을 적용하지 않고 반환 됩니다 .</target>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="translated">집합 유형은 집합의 수학적 개념을 모델링합니다. 세트의 기본 유형은 특정 크기의 서수 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="translated">setrlimit () 시스템 호출은 자원 제한을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab78f0eb24b2a7eb5c7e5cc08857a1e481515b9a" translate="yes" xml:space="preserve">
          <source>The shallow copy only changes the semantics for sequences and strings (and types which contain those).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="translated">서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="10ae4b49d52a242d61113b259ec4828eb2835c64" translate="yes" xml:space="preserve">
          <source>The simple case of &lt;code&gt;x = x&lt;/code&gt; cannot be turned into &lt;code&gt;=sink(x, x); wasMoved(x)&lt;/code&gt; because that would lose &lt;code&gt;x&lt;/code&gt;'s value. The solution is that simple self-assignments are simply transformed into an empty statement that does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="translated">부울 유형의 크기는 1 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="translated">32 비트 부동 소수점 유형으로 표시 될 수있는 가장 작은 양수 (0이 아닌) 수입니다.</target>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="translated">64 비트 부동 소수점 유형으로 표시 될 수있는 가장 작은 양수 (0이 아닌) 수입니다.</target>
        </trans-unit>
        <trans-unit id="0f3394967223653ae65cfbae0dc744d9696343e6" translate="yes" xml:space="preserve">
          <source>The socket file path is operating system specific and distribution specific, additional configuration may or may not be needed on your &lt;code&gt;postgresql.conf&lt;/code&gt;. The Postgres server must be on the same computer and only works for Unix-like operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="translated">해결책은 모듈의 최상위 문장을 &lt;strong&gt;재생&lt;/strong&gt; 하는 것입니다. 이는 pragma의 영향을받는 내부 시퀀스를 채우는 로직을 특수한 경우없이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="15c408b85fe2405afe9a50555d39cb72fd864c66" translate="yes" xml:space="preserve">
          <source>The solution is to define &lt;code&gt;proc `=destroy`[T](f: var Foo[T])&lt;/code&gt; before it is used. The compiler generates implicit hooks for all types in &lt;em&gt;strategic places&lt;/em&gt; so that an explicitly provided hook that comes too &quot;late&quot; can be detected reliably. These &lt;em&gt;strategic places&lt;/em&gt; have been derived from the rewrite rules and are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="translated">진단 메시지를 트리거 한 소스 라인.</target>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="translated">특수 &lt;code&gt;result&lt;/code&gt; 변수</target>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="translated">대괄호 &lt;code&gt;[]&lt;/code&gt; 는 선택적 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="translated">표준 배포판에는 다음 도구가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="translated">표준 오류 스트림.</target>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="translated">표준 입력 스트림</target>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="translated">표준 라이브러리는 16 비트 마이크로 컨트롤러에 대한 C 코드 생성이 가능한 지점까지 피할 수 있습니다. OS 기능이없는 베어 본 표준 라이브러리에 &lt;span id=&quot;standalone_1&quot;&gt;독립형&lt;/span&gt; 대상 ( &lt;code&gt;--os:standalone&lt;/code&gt; )을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="translated">표준 라이브러리는 일부 기능이 구현되는 방식에 영향을주는 &lt;code&gt;useX&lt;/code&gt; 조건부 정의 의 증가를 지원합니다 . 이 섹션은 완전한 목록을 제공하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="translated">표준 출력 스트림</target>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 후 명령문 은 예외 &lt;code&gt;e&lt;/code&gt; 가 발생 하지 않는 한 순차적 인 순서로 실행됩니다 . &lt;code&gt;e&lt;/code&gt; 의 예외 유형이 &lt;code&gt;except&lt;/code&gt; 절에 나열된 항목과 일치하면 해당 명령문이 실행됩니다. &lt;code&gt;except&lt;/code&gt; 절 뒤에 나오는 문장을 &lt;span id=&quot;exception-handlers_1&quot;&gt;예외 처리기&lt;/span&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 이후의 명령문 은 예외가 발생하지 않는 한 실행됩니다. 그런 다음 적절한 &lt;code&gt;except&lt;/code&gt; 부분이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="translated">진술은 새로운 범위를 열지 않습니다.</target>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="translated">true로 평가 된 표현식에 속하는 명령문은 컴파일러에 의해 변환되고 다른 명령문은 시맨틱을 검사하지 않습니다! 그러나 각 조건의 의미가 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="translated">브랜치 내의 명령문은 새로운 범위를 열지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="translated">테스트가 완료되었을 때의 상태.</target>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="translated">stdlib API는 &lt;strong&gt;사용하기 쉽고&lt;/strong&gt; 일관 되도록 설계되었습니다 . 사용의 용이성은 구체적인 높은 수준의 행동을 달성하기위한 호출 횟수로 측정됩니다. 궁극적 인 목표는 프로그래머 가 이름을 &lt;em&gt;추측&lt;/em&gt; 할 수 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="translated">stdtmpl 필터는 Nim에 간단한 템플릿 엔진을 제공합니다. 이 필터는 행 기반 구문 분석기를 사용합니다. 접 두부 &lt;em&gt;메타 문자&lt;/em&gt; (기본값 : &lt;code&gt;#&lt;/code&gt; )가 Nim 코드를 포함하고 다른 행은 그대로 사용됩니다. 들여 쓰기 기반 구문 분석은 템플릿 엔진에 적합하지 않으므로 제어 흐름 설명에는 &lt;code&gt;end X&lt;/code&gt; 구분 기호 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e5d4338933c9dd8ab3f051eed916bf14cdb0d76c" translate="yes" xml:space="preserve">
          <source>The strategy the GC should use for the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; 에 전달 된 문자열 리터럴 은 형식 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt; 에 전달 된 문자열 리터럴 은 형식 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05489799940a31c90df60dd618dd0c7f6fe09df5" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">CString 인수에 대한 stringify 연산자입니다. 문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7a06837bf4de8313fb2e9c2730a787782961e97b" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;code&gt;x&lt;/code&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="translated">부울 인수에 대한 stringify 연산자입니다. &quot;false&quot;또는 &quot;true&quot;문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="97314c01ab906677fa54e8f600a637d1ff872572" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="translated">문자 인수에 대한 stringify 연산자입니다. 문자열로 변환 된 &lt;em&gt;x를&lt;/em&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c2e8846dafca6b75fda15855933500c8558f80ec" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">float 인수의 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="896f93db18d37ef803d588829b7730d608bde104" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;code&gt;x&lt;/code&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="translated">문자열 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 그대로 반환 합니다. 이 연산자는 일반 코드에 유용하므로 &lt;code&gt;expr&lt;/code&gt; 이 이미 문자열 인 경우 &lt;code&gt;$expr&lt;/code&gt; 도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="d96bb71e7e76d2204fee18b469a16a8c12a66807" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="translated">열거 인수에 대한 stringify 연산자입니다. 컴파일러 매직 덕분에 모든 열거 유형에 사용할 수 있습니다. 경우 &lt;code&gt;$&lt;/code&gt; 의 구체적인 열거에 대한 운영자가 제공되며,이 대신 사용됩니다. (즉, &lt;em&gt;덮어 쓰기&lt;/em&gt; 가능)</target>
        </trans-unit>
        <trans-unit id="be489908ae882068231cbc7ae61f4debc3aca159" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df8dc0dea2441955def02eb0211ebe5babe803f" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="translated">정수 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="translated">정수 인수에 대한 stringify 연산자입니다. &lt;em&gt;x&lt;/em&gt; 를 10 진수 문자열로 변환하여 반환 합니다. &lt;code&gt;$&lt;/code&gt; 는 Nim의 일반적인 맞춤법 &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3505dd46d9ecade26aad746ee7fe8677daef894" translate="yes" xml:space="preserve">
          <source>The stringify operator for an unsigned integer argument. Returns &lt;code&gt;x&lt;/code&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="translated">스트립 필터는 각 행에서 선행 및 후행 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">(콜론 뒤 표현식은 &lt;code&gt;arg&lt;/code&gt; 에 &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt; )로 전달하는 옵션 인수 인 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a624d4584bba9b7ac9d39da2c584be5b0d22cc6" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is optional. It will be passed as the last argument to &lt;code&gt;formatValue&lt;/code&gt;. When the colon with the subexpression it is left out, an empty string will be taken instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="translated">실제로 하위 집합은 다음과 같은 제한 / 변경 사항이 포함 된 전체 언어입니다.</target>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="translated">대체 문자 는 문자열 리터럴 내에 Nim 표현식 &lt;em&gt;e를&lt;/em&gt; 도입합니다 . &lt;em&gt;e&lt;/em&gt; 는 &lt;em&gt;toString&lt;/em&gt; 연산 을 사용하여 문자열로 변환되며 기본값은 &lt;code&gt;$&lt;/code&gt; 입니다. 강력한 유형 검사 를 수행하려면 &lt;code&gt;toString&lt;/code&gt; 을 빈 문자열로 설정하십시오. &lt;em&gt;e&lt;/em&gt; 는이 PEG 패턴과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="translated">대체 변수 ( &lt;code&gt;$&lt;/code&gt; 뒤에 나오는 것 )는 1에서 &lt;code&gt;a.len&lt;/code&gt; 까지 열거됩니다 . 완전 &lt;code&gt;$&lt;/code&gt; 를 생성하려면 &lt;code&gt;$$&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;$#&lt;/code&gt; 표기법을 사용하여 다음 대체 변수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="translated">스위트는 개별 테스트 케이스를 나열된 순서대로 실행합니다. 기본 전역 설정을 사용하면 위 코드가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="translated">제공된 &lt;code&gt;fd&lt;/code&gt; 의 비 차단 상태는 암시 적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="translated">제네릭의 심볼 바인딩 규칙은 약간 미묘합니다. &quot;열린&quot;및 &quot;닫힌&quot;심볼이 있습니다. 인스턴스화 컨텍스트에서 &quot;닫힌&quot;기호는 리 바인드 될 수 없으며 &quot;열린&quot;기호는 가능합니다. 기본적으로 오버로드 된 심볼은 열려 있고 다른 모든 심볼은 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="translated">기호의 &lt;code&gt;ast&lt;/code&gt; 필드는 요청시 느리게로드됩니다. 이곳은 대부분의 저축에서 비롯되며 얕은 외부 AST 만 즉시 재구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb33000c4f3d80804f12a993711548c0361f873" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt; or &lt;code&gt;s2&lt;/code&gt; but not both at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A △ B&lt;/em&gt; or &lt;em&gt;A ⊖ B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="translated">두 세트의 대칭 차이는 수학적으로 &lt;em&gt;A △ B&lt;/em&gt; 또는 &lt;em&gt;A ⊖ B로 표시&lt;/em&gt; 되며 &lt;em&gt;s1&lt;/em&gt; 또는 &lt;em&gt;s2의&lt;/em&gt; 멤버 이지만 동시에 두 가지가 아닌 모든 객체의 세트입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="bf1dfb4076eebef85539bee43d7712db3fbf93bc" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;-d:flag&lt;/code&gt; is actually just a shortcut for &lt;code&gt;-d:flag=true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="translated">&lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; 구문을 사용하여 동일한 디렉토리에서 여러 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="translated">반복자의 구문은 procs와 비슷하지만 &lt;code&gt;nnkIteratorDef&lt;/code&gt; 가 nnkProcDef를 대체 &lt;code&gt;nnkProcDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="translated">다른 언어의 중첩 배열 (다차원) 구문은 일반적으로 각 차원이 다른 차원과 동일한 인덱스 유형으로 제한되므로 더 많은 괄호를 추가해야합니다. Nim에서는 색인 유형이 서로 다른 차원을 가질 수 있으므로 중첩 구문이 약간 다릅니다. 레벨이 또 다른 열거 형으로 색인화 된 열거 형 배열로 정의 된 이전 예제를 기반으로 다음 행을 추가하여 정수 색인을 통해 액세스되는 높이 레벨로 세분화 된 라이트 타워 유형을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="translated">유형 변환 구문은 &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; 은 일반 호출과 같이 )입니다.</target>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="translated">의 구문 &lt;code&gt;case&lt;/code&gt; 객체 선언은 밀접의 구문은 다음 &lt;code&gt;case&lt;/code&gt; A의 지점 : 문 &lt;code&gt;case&lt;/code&gt; 섹션은 너무 들여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="translated">템플릿 을 &lt;em&gt;호출&lt;/em&gt; 하는 구문 은 프로 시저를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="translated">구문 트리</target>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="translated">구문 트리는 임의의 수의 자식을 가질 수있는 노드로 구성됩니다. 유형과 기호는주기를 포함 할 수 있으므로 다른 노드로 표시됩니다. 의미 확인 후 AST의 모양이 변경됩니다. 이것은 코드 생성기의 삶을 더 쉽게 만들기 위해 필요합니다. 타입 정의는 &quot;ast&quot;모듈을 참조하십시오. &lt;a href=&quot;macros&quot;&gt;매크로&lt;/a&gt; 모듈은 AST 각 구문 구조를 나타냅니다 얼마나 많은 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a68b38eeb844e67ce71f2a27d7dff2458540f69" translate="yes" xml:space="preserve">
          <source>The syntax, style, and rest of the ecosystem is the same as for compiled Nim, that means there is nothing new to learn, no context switch for developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="translated">syscall 규칙은 C의 &lt;code&gt;__syscall&lt;/code&gt; 과 동일 합니다. 인터럽트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7428da08d4a9d661f397c8cd676c7d6536a3f09d" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions for working with strings, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f0d04dda05e55df0efe79df7f90f4cebd2211" translate="yes" xml:space="preserve">
          <source>The system module defines several common functions, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc67a1994589801e1401cb7812a58cafb42f5561" translate="yes" xml:space="preserve">
          <source>The target type of a cast must be a concrete type, for instance, a target type that is a type class (which is non-concrete) would be invalid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">temp 명령은 Nim 컴파일러를 빌드하지만 다른 최종 이름 ( &lt;code&gt;nim_temp&lt;/code&gt; )을 사용하므로 일반 컴파일러를 덮어 쓰지 않습니다. 이 명령을 사용하여 &lt;a href=&quot;#boot-command&quot;&gt;boot 명령&lt;/a&gt; 과 동일한 옵션을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0acf88d3c9384a4ead50fb1f94ad815480237488" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="translated">템플릿 엔진은 매우 유연합니다. 템플릿 코드를 파일에 직접 쓰는 프로 시저를 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 표현식은 변경하려는 시퀀스와 동일한 유형을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="translated">템플릿은 표현식에서 직접 사용할 수 있는 &lt;code&gt;it&lt;/code&gt; 변수를 삽입합니다 . 당신은 또한으로 전달해야 &lt;em&gt;일반&lt;/em&gt; 새로운 반환 순서가 원본보다 다른 유형을 가질 수 있기 때문에, 표현의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="translated">문자열이 먼저 &lt;code&gt;cstring&lt;/code&gt; 유형으로 변환되지 않으면 종료 0에 액세스 할 수 없습니다 . 종료 0은이 변환이 O (1)에서 할당없이 수행 될 수 있음을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="translated">테스트 상태 및 이름은 출력 또는 역 추적 후에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="translated">문자열 리터럴을 작성하는 세 번째이자 마지막 방법은 &lt;em&gt;긴 문자열 리터럴&lt;/em&gt; 입니다. 그들은 세 따옴표와 함께 기록됩니다 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; ; 여러 줄에 걸쳐있을 수 있으며 &lt;code&gt;\&lt;/code&gt; 도 이스케이프 문자가 아닙니다. 예를 들어 HTML 코드 템플릿을 포함하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="translated">백 슬래시의 세 번째 용도는 &lt;span id=&quot;generic-character-types_1&quot;&gt;일반 문자 유형&lt;/span&gt; 을 지정하는 것 입니다. 다음은 항상 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="92af40aeb29e6640bb9de3b1e1701b722a26794f" translate="yes" xml:space="preserve">
          <source>The time (in UTC) of compilation as a string of the form &lt;code&gt;HH:MM:SS&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60cef0a4060f4db69c965773dac830d6f50b6aa" translate="yes" xml:space="preserve">
          <source>The timezone represented as an implementation of &lt;code&gt;Timezone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="translated">후행 줄 바꿈 문자는 반복 된 행에서 제거됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">coercion &lt;code&gt;static(x)&lt;/code&gt; 유형을 사용하여 주어진 표현식 &lt;code&gt;x&lt;/code&gt; 의 컴파일 타임 평가를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 L- 값이고 &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; 보유 하는 경우 유형 변환 &lt;code&gt;T(a)&lt;/code&gt; 는 L- 값 입니다.</target>
        </trans-unit>
        <trans-unit id="1b02430bf6ab116f5610a3e7f89fda5b3e78e5ab" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, typeof(a))&lt;/code&gt; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">매개 변수 유형은 &lt;code&gt;var&lt;/code&gt; 키워드 로 시작될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="translated">파일 핸들을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="translated">유형 접미사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="translated">&lt;code&gt;var T&lt;/code&gt; 및 &lt;code&gt;typedesc[T]&lt;/code&gt; 유형 은 일반 인스턴스화에서 유추 할 수 없습니다. 다음은 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="6068d66d8caf9d0bc5e346b69b06b7e22f85d91a" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt;, &lt;code&gt;out T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">일반적인 컴파일러 사용법은 &lt;code&gt;compile&lt;/code&gt; 또는 &lt;code&gt;c&lt;/code&gt; 명령을 사용하여 &lt;code&gt;.nim&lt;/code&gt; 파일을 하나 이상의 &lt;code&gt;.c&lt;/code&gt; 파일로 변환 한 다음 플랫폼의 C 컴파일러를 사용하여 정적 이진 파일로 컴파일하는 것입니다. 그러나 C ++, Objective-C 또는 Javascript로 컴파일하는 다른 명령이 있습니다. 자세한 내용은 &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="733da35309da1a0adc926cfeed7cf9e4972229fa" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0930f393d96d3e129dbb5d95324e49f12cf8fc32" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc757b9810b94b3278b6f78815badc1d4f6fdea" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">이 옵션의 일반적인 사용 시나리오는 사용자가 &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;객체 지향 호출 구문&lt;/a&gt; 의 점 문자를 입력 한 후 호출하는 것 입니다. Idetools는 범위 (가장 안쪽에서 바깥쪽으로)와 항목 이름별로 정렬 된 제안을 반환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="translated">이 옵션의 일반적인 사용 시나리오는 사용자가 &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;객체 지향 호출 구문&lt;/a&gt; 의 점 문자를 입력 한 후 호출하는 것 입니다. Nimsuggest는 범위별로 (가장 안쪽에서 바깥쪽으로) 정렬 한 다음 항목 이름별로 제안을 반환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="22208dbaa100422606e56c7e131a653bc370939f" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="translated">두 세트의 합집합은 수학적으로 &lt;em&gt;A &amp;cup; B&lt;/em&gt; 로 표현되며 &lt;em&gt;s1&lt;/em&gt; , &lt;em&gt;s2&lt;/em&gt; 또는 둘 다의 구성원 인 모든 객체의 집합입니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="translated">&lt;code&gt;maxPauseInUs&lt;/code&gt; 및 &lt;code&gt;us&lt;/code&gt; 매개 변수의 단위 는 마이크로 초입니다.</target>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="translated">unsafeAddr 연산자</target>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="translated">새 파일 업로드</target>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt; 의 사용법 (실험)은 객체와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f9c91fbc8283b9f203886fd420138f36678da171" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;{.inject.}&lt;/code&gt; here is necessary again because of template expansion order and hygienic templates. But since we generally want to keep the hygienicness of &lt;code&gt;myTemplate&lt;/code&gt;, and we do not want &lt;code&gt;arg1&lt;/code&gt; to be injected into the context where &lt;code&gt;myTemplate&lt;/code&gt; is expanded, everything is wrapped in a &lt;code&gt;block&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1da7cd5635c8ed575ed2f00199382fa74a25aa" translate="yes" xml:space="preserve">
          <source>The use of wrappers that use FFI and/or &lt;code&gt;cast&lt;/code&gt; is also disallowed. Note that these wrappers include the ones in the standard libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="translated">사용 설명서에는 명령 줄 인수, 컴파일러의 특수 기능 등이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="translated">using 문은 동일한 매개 변수 이름과 유형이 반복해서 사용되는 모듈에서 구문 편의성을 제공합니다. 대신에:</target>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="translated">반환 된 열거 형의 값은 매우 자명해야합니다.</target>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="translated">var 문</target>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="translated">var 문은 새로운 지역 또는 전역 변수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="translated">변수 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;for&lt;/code&gt; 루프에 의해 암시 적으로 선언되며 &lt;code&gt;int&lt;/code&gt; 유형을 갖습니다 . 이것이 &lt;a href=&quot;system#countup&quot;&gt;countup이&lt;/a&gt; 리턴 하는 것이기 때문입니다 . &lt;code&gt;i&lt;/code&gt; 는 1, 2, .., 10 값을 통해 실행됩니다. 각 값은 &lt;code&gt;echo&lt;/code&gt; 입니다. 이 코드는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8964df6ead4489b7696bee7b0f5aec240db046f0" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;code&gt;cmpIgnoreStyle&lt;/code&gt;. &lt;code&gt;ValueError&lt;/code&gt; is raised if an ill-formed format string has been passed to the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="translated">변수는 &lt;em&gt;cmpIgnoreStyle&lt;/em&gt; 과 비교됩니다 . 형식이 잘못된 형식 문자열이 &lt;em&gt;%&lt;/em&gt; 연산자에 전달 &lt;em&gt;되면 ValueError&lt;/em&gt; 가 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61b57a2d911fc71f98fcabf040635de38c8494ca" translate="yes" xml:space="preserve">
          <source>The version uses &lt;code&gt;cmp&lt;/code&gt; to compare the elements. The expected return values are the same as that of &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66e53fcdb4e533daa1d776499d5013cc08f8baa" translate="yes" xml:space="preserve">
          <source>The version uses the default comparison function &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="translated">while 문은 간단한 루핑 구문입니다.</target>
        </trans-unit>
        <trans-unit id="4123d4bcf088a88feae5646d2165ec90f62ac31f" translate="yes" xml:space="preserve">
          <source>The workaround for this is to bind the template argument to a new local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="translated">패딩이없는 연도. 연도가 BC 인 경우에도 항상 긍정적입니다.</target>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="translated">패딩이없는 연도. 연도가 BC 인 경우 음수입니다.</target>
        </trans-unit>
        <trans-unit id="07d07d0ea9f8d13f35a29277409b0f19348eb8f7" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dbc322d029aa3d6f32b6486bd07eb9329bc1da" translate="yes" xml:space="preserve">
          <source>The year, padded to at least four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="translated">연도는 4 자리 이상으로 채워졌습니다. 연도가 BC 인 경우에도 항상 긍정적입니다. 연도가 4 자리를 초과하면 '+'가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="translated">연도는 4 자리 이상으로 채워졌습니다. 연도가 BC 인 경우 음수입니다. 연도가 4 자리를 초과하면 연도가 BC가 아닌 한 '+'가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="511ad266e7726ce686aa356a227a5ffd4428485f" translate="yes" xml:space="preserve">
          <source>The year, using astronomical year numbering (meaning that before year 1 is year 0, then year -1 and so on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#readAll&quot;&gt;readAll을&lt;/a&gt; 호출 하고 나중에 파일을 닫습니다. 문자열을 반환합니다. 오류가 발생하면 IO 예외가 발생합니다. 컴파일 타임 매크로 내에서 이것을 호출 해야하는 경우 &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="translated">그런 다음 모듈 &lt;code&gt;A&lt;/code&gt; ( &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 에 종 속됨 )가 컴파일되고 &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; 는 변경되지 않습니다. &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;G.P2&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;G.P1&lt;/code&gt; 이 필요한 모듈 &lt;code&gt;B&lt;/code&gt; 가 컴파일 됩니다. 문제 없습니다. &lt;code&gt;G.P1&lt;/code&gt; 이 심볼 파일에서로드되고 &lt;code&gt;G.c&lt;/code&gt; 이제 &lt;code&gt;G.P1&lt;/code&gt; 이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="translated">그런 다음 C 코드와 컴파일 스크립트 &lt;code&gt;compile_myproject.sh&lt;/code&gt; 를 Linux i386 시스템으로 이동하고 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7f5c1a564b56a99b8a9432588eb7749f18de807c" translate="yes" xml:space="preserve">
          <source>Then there is also the integer literal type. This is a specific type that is implicitly convertible into the requested type if the requested type can hold the value. For this to work, the type needs to know the concrete value of the literal. For example an expression &lt;code&gt;321&lt;/code&gt; will be of type &lt;code&gt;int literal(321)&lt;/code&gt;. This type is implicitly convertible to all integer types and ranges that contain the value &lt;code&gt;321&lt;/code&gt;. That would be all builtin integer types except &lt;code&gt;uint8&lt;/code&gt; and &lt;code&gt;int8&lt;/code&gt; where &lt;code&gt;321&lt;/code&gt; would be out of range. When this literal type is assigned to a new &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; variable, it's type will be resolved to just &lt;code&gt;int&lt;/code&gt;, not &lt;code&gt;int literal(321)&lt;/code&gt; unlike constants. A constant keeps the full &lt;code&gt;int literal(321)&lt;/code&gt; type. Here is an example where that difference matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3224338d78f50a303f4e2d270b284e3310633b0" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="translated">Nim에는 2 가지 종류의 반복자가 있습니다 : &lt;em&gt;인라인&lt;/em&gt; 및 &lt;em&gt;클로저&lt;/em&gt; 반복자. &lt;span id=&quot;inline-iterator_1&quot;&gt;인라인 반복자는&lt;/span&gt; 항상 추상화 제로 오버 헤드로 이어지는 컴파일러에 의해 인라인 것 반복자이지만, 코드 크기에 무거운 증가 될 수 있습니다. 인라인 반복자는 2 등 시민입니다. 템플릿, 매크로 및 기타 인라인 반복자와 같은 다른 인라인 코드 기능에만 매개 변수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="translated">유형에 바인딩 된 3 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e58d330c906290a3a72d9bf31c8b364392ece8e" translate="yes" xml:space="preserve">
          <source>There are 4 operations that are bound to a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a602bfe3df3ce7f6d337cd11a7c7400db183b00" translate="yes" xml:space="preserve">
          <source>There are a few details to keep in mind when using this module within multiple threads:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="translated">DevkitPro 라이브러리가 지원하지 않기 때문에 작동하지 않는 몇 가지가 있습니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="translated">또한 문자 &lt;code&gt;r&lt;/code&gt; (또는 &lt;code&gt;R&lt;/code&gt; ) 이 앞에 오는 원시 문자열 리터럴이 있으며 (일반 문자열 리터럴과 마찬가지로) 큰 따옴표로 일치하고 이스케이프 시퀀스를 해석하지 않습니다. 이는 정규식 또는 Windows 경로에 특히 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="translated">현재 확인 모드에는 두 가지 옵션 만 있습니다. 하나는 &lt;code&gt;CVerifyNone&lt;/code&gt; 이고 인증서는 확인되지 않으며 다른 하나는 &lt;code&gt;CVerifyPeer&lt;/code&gt; 이며 인증서는 확인되며 &lt;code&gt;CVerifyPeer&lt;/code&gt; 가 가장 안전한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="699fd27aa890266a888c5272db783bacf977a6e2" translate="yes" xml:space="preserve">
          <source>There are limitations on what Nim code can be executed at compile time; see &lt;a href=&quot;#restrictions-on-compileminustime-execution&quot;&gt;Restrictions on Compile-Time Execution&lt;/a&gt; for details. It's a static error if the compiler cannot execute the block at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 연산자 사용을 포함하여 여러 가지 방법으로이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; AST에 대한 제약은 없으며 집합 배열의 중첩 된 튜플에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cf947740d972fdc4f2ebc7b27221b71dc35fbb9e" translate="yes" xml:space="preserve">
          <source>There are no specialized &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;contains&lt;/code&gt; procedures for &lt;code&gt;seq[Rune]&lt;/code&gt; in this module because the generic variants of these procedures in the system module already work with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bda84e8a64a9ee0766ebd2e91b0b1fc8bcb50a8" translate="yes" xml:space="preserve">
          <source>There are several different types of hash tables available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="translated">의미 검사 또는 코드 생성에 사용되는 몇 가지 노드 종류가 있습니다. 이들은이 모듈에서 액세스 할 수 있지만 사용해서는 안됩니다. 다른 노드 종류는 특히 AST 조작을 쉽게하도록 설계되었습니다. 이것들은 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc14568c01dd285d589a27b7cb9cd2809008967" translate="yes" xml:space="preserve">
          <source>There are six logging levels: debug, info, notice, warn, error, and fatal. They are described in more detail within the &lt;a href=&quot;#Level&quot;&gt;Level enum's documentation&lt;/a&gt;. A message is logged if its level is at or above both the logger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter. The latter can be changed with the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca8d001ba881fc8c54bf7d03fbbb467af017be5" translate="yes" xml:space="preserve">
          <source>There are three options for verify mode: &lt;code&gt;CVerifyNone&lt;/code&gt;: certificates are not verified; &lt;code&gt;CVerifyPeer&lt;/code&gt;: certificates are verified; &lt;code&gt;CVerifyPeerUseEnvVars&lt;/code&gt;: certificates are verified and the optional environment variables SSL_CERT_FILE and SSL_CERT_DIR are also used to locate certificates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="translated">메타 문자에는 두 가지 다른 세트가 있습니다. 대괄호를 제외하고 패턴의 어느 곳에서나 인식 할 수있는 문자와 대괄호로 인식되는 것입니다. 대괄호 외부에서 메타 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="translated">두 개의 의사 디렉토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e9491c4554d1cf539e490b9c71cd03f4f655289" translate="yes" xml:space="preserve">
          <source>There are two ways to compile for Android: terminal programs (Termux) and with the NDK (Android Native Development Kit).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="translated">Nim 코드에서 PEG를 구성하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="089b0a2a4fc8aac4d751cf1e71645f608e78c87d" translate="yes" xml:space="preserve">
          <source>There are two ways to invoke a macro:</source>
          <target state="translated">매크로를 호출하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="720936a505c479b6845bfb796080ccd89a044a7d" translate="yes" xml:space="preserve">
          <source>There are two ways to write a macro, either &lt;em&gt;generating&lt;/em&gt; Nim source code and letting the compiler parse it, or creating manually an abstract syntax tree (AST) which you feed to the compiler. In order to build the AST one needs to know how the Nim concrete syntax is converted to an abstract syntax tree (AST). The AST is documented in the &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module.</source>
          <target state="translated">매크로를 작성하는 방법에는 Nim 소스 코드 를 &lt;em&gt;생성&lt;/em&gt; 하고 컴파일러가 구문 분석하도록하거나 컴파일러에 피드하는 추상 구문 트리 (AST)를 수동으로 &lt;em&gt;생성&lt;/em&gt; 하는 두 가지 방법 이 있습니다. AST를 빌드하려면 Nim 콘크리트 구문이 추상 구문 트리 (AST)로 어떻게 변환되는지 알아야합니다. AST는 &lt;a href=&quot;macros&quot;&gt;매크로&lt;/a&gt; 모듈에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9bcbe7393ec87f587011e8d840878f558c1f97b" translate="yes" xml:space="preserve">
          <source>There can be zero or more &lt;code&gt;elif&lt;/code&gt; parts, and the &lt;code&gt;else&lt;/code&gt; part is optional. The keyword &lt;code&gt;elif&lt;/code&gt; is short for &lt;code&gt;else if&lt;/code&gt;, and is useful to avoid excessive indentation. (The &lt;code&gt;&quot;&quot;&lt;/code&gt; is the empty string. It contains no characters.)</source>
          <target state="translated">&lt;code&gt;elif&lt;/code&gt; 부분은 0 개 이상있을 수 있으며 &lt;code&gt;else&lt;/code&gt; 부분은 선택 사항입니다. 키워드 &lt;code&gt;elif&lt;/code&gt; 대한 짧은 &lt;code&gt;else if&lt;/code&gt; , 과도한 들여 쓰기를 방지하는 데 유용합니다. (는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 빈 문자열입니다. 그것은 어떤 문자가 포함되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="a3d437f79271578914f708f4086005edd9d04476" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience, the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating-point literals with a type suffix can be ambiguous).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cfdf22bf86043f8acee986bff271197e1936f9" translate="yes" xml:space="preserve">
          <source>There exists a literal for each numerical type that is defined. The suffix starting with an apostrophe (''') is called a &lt;span id=&quot;type-suffix_1&quot;&gt;type suffix&lt;/span&gt;. Literals without a type suffix are of an integer type, unless the literal contains a dot or &lt;code&gt;E|e&lt;/code&gt; in which case it is of type &lt;code&gt;float&lt;/code&gt;. This integer type is &lt;code&gt;int&lt;/code&gt; if the literal is in the range &lt;code&gt;low(i32)..high(i32)&lt;/code&gt;, otherwise it is &lt;code&gt;int64&lt;/code&gt;. For notational convenience the apostrophe of a type suffix is optional if it is not ambiguous (only hexadecimal floating point literals with a type suffix can be ambiguous).</source>
          <target state="translated">정의 된 각 숫자 유형에 대한 리터럴이 있습니다. 아포스트로피 ( '' ')로 시작하는 접미 부를 &lt;span id=&quot;type-suffix_1&quot;&gt;유형 접미사&lt;/span&gt; 라고합니다 . 리터럴에 접미사가없는 리터럴은 리터럴에 점 또는 &lt;code&gt;E|e&lt;/code&gt; 가 포함되어 있지 않은 경우 정수 유형이며 정수 유형 은 &lt;code&gt;float&lt;/code&gt; 유형 입니다. 리터럴이 &lt;code&gt;low(i32)..high(i32)&lt;/code&gt; 범위에 있으면 이 정수 유형은 &lt;code&gt;int&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;int64&lt;/code&gt; 입니다. 표기법의 편의상, 타입 접미사의 아포스트로피는 모호하지 않은 경우 선택 사항입니다 (타입 접미사가있는 16 진 부동 소수점 리터럴 만 모호 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="90fe0ee868ac44e50e7a55bf1d6f6587b14d23c1" translate="yes" xml:space="preserve">
          <source>There is a syntactic sugar for calling routines: The syntax &lt;code&gt;obj.method(args)&lt;/code&gt; can be used instead of &lt;code&gt;method(obj, args)&lt;/code&gt;. If there are no remaining arguments, the parentheses can be omitted: &lt;code&gt;obj.len&lt;/code&gt; (instead of &lt;code&gt;len(obj)&lt;/code&gt;).</source>
          <target state="translated">루틴 호출을위한 구문 설탕이 있습니다. &lt;code&gt;method(obj, args)&lt;/code&gt; 대신 구문 &lt;code&gt;obj.method(args)&lt;/code&gt; 사용할 수 있습니다 . 나머지 인수가 없으면 괄호를 생략 할 수 있습니다 : &lt;code&gt;obj.len&lt;/code&gt; ( &lt;code&gt;len(obj)&lt;/code&gt; 대신 ).</target>
        </trans-unit>
        <trans-unit id="809686a502cf19e841efede0ad4446dfca6c035b" translate="yes" xml:space="preserve">
          <source>There is an analysis that checks that &lt;code&gt;counters[i].L&lt;/code&gt; is the lock that corresponds to the protected location &lt;code&gt;counters[i].v&lt;/code&gt;. This analysis is called &lt;span id=&quot;path-analysis_1&quot;&gt;path analysis&lt;/span&gt; because it deals with paths to locations like &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;counters[i].L&lt;/code&gt; 이 보호 된 위치 &lt;code&gt;counters[i].v&lt;/code&gt; 해당하는 잠금 인지 확인하는 분석이 있습니다. 이 분석은 &lt;code&gt;obj.field[i].fieldB[j]&lt;/code&gt; 와 같은 위치에 대한 경로를 처리하므로 &lt;span id=&quot;path-analysis_1&quot;&gt;경로 분석&lt;/span&gt; 이라고 &lt;span id=&quot;path-analysis_1&quot;&gt;합니다&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="9be47a2e7d24c1f78266ccdbd346bb776f9d13ab" translate="yes" xml:space="preserve">
          <source>There is another consideration. Nim has flexible type identification for its procs. Even though &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; and &lt;code&gt;proc(a, b: int)&lt;/code&gt; are equivalent in the code, the AST is a little different for the latter.</source>
          <target state="translated">다른 고려 사항이 있습니다. Nim은 프로세스에 대해 유연한 유형 식별 기능을 가지고 있습니다. 비록 &lt;code&gt;proc(a: int, b: int)&lt;/code&gt; 및 &lt;code&gt;proc(a, b: int)&lt;/code&gt; 코드에 동등의 AST는 후자 조금 다르다.</target>
        </trans-unit>
        <trans-unit id="ef0bece8693cc3f6cf7cc996e5ec28c503f5ee8c" translate="yes" xml:space="preserve">
          <source>There is no need to check for &lt;code&gt;cmdEnd&lt;/code&gt; while iterating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a21bfca1dc8f206e73873a032f9f2495f5c004" translate="yes" xml:space="preserve">
          <source>These are the major type classes:</source>
          <target state="translated">주요 유형 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f26df48cd633ca6dc9c4a4cfdeb29e86e918f9" translate="yes" xml:space="preserve">
          <source>These assertions may not appear in character classes (but note that &lt;code&gt;\b&lt;/code&gt; has a different meaning, namely the backspace character, inside a character class).</source>
          <target state="translated">이러한 어설 션은 문자 클래스에 나타나지 않을 수 있습니다 (그러나 &lt;code&gt;\b&lt;/code&gt; 는 문자 클래스 내부에서 백 스페이스 문자와 다른 의미를 갖습니다).</target>
        </trans-unit>
        <trans-unit id="74dbc337c7d11370d75e44ba74f2cb86ce0accdc" translate="yes" xml:space="preserve">
          <source>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</source>
          <target state="translated">이러한 문자 유형 순서는 내부 및 외부 문자 클래스 모두에 나타날 수 있습니다. 이들은 각각 적절한 유형의 한 문자와 일치합니다. 현재 일치 지점이 제목 문자열의 끝에 있으면 일치하는 문자가 없기 때문에 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="121cd2b220ceffc68b4f037b698a6ce125bbb7d9" translate="yes" xml:space="preserve">
          <source>These directives tell c2nim that it should annotate every proc (or proc type) with the &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; calling convention.</source>
          <target state="translated">이 지시어는 c2nim에게 &lt;code&gt;stdcall&lt;/code&gt; / &lt;code&gt;cdecl&lt;/code&gt; 호출 규칙을 사용하여 모든 proc (또는 proc 유형)에 주석을 달아야한다고 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="defe996f8d7935ccd354c5fcc6274f5321b86ee2" translate="yes" xml:space="preserve">
          <source>These examples all use the default random number generator. The &lt;a href=&quot;#Rand&quot;&gt;Rand type&lt;/a&gt; represents the state of a random number generator. For convenience, this module contains a default Rand state that corresponds to the default random number generator. Most procs in this module which do not take in a Rand parameter, including those called in the above examples, use the default generator. Those procs are &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3448534ab91afc28628316690fa8a8d7be286ead" translate="yes" xml:space="preserve">
          <source>These features also work for declarations like &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; and boolean combinations of such declarations.</source>
          <target state="translated">이러한 기능은 &lt;code&gt;#if defined(SYMBOL)&lt;/code&gt; 와 같은 선언 및 이러한 선언의 부울 조합에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3f7d81f9ef3ace4ce8ec9e07e91300c660430c" translate="yes" xml:space="preserve">
          <source>These integer types are pre-defined:</source>
          <target state="translated">이 정수 유형은 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ab24068b59d19aa34809cf736b37f6dd349129" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of as from&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55066fb4694c635ce07b74e97002d73c6ea9c5d5" translate="yes" xml:space="preserve">
          <source>These keywords are also operators: &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt;.</source>
          <target state="translated">이 키워드는 또한 연산자입니다. &lt;code&gt;and or not xor shl shr div mod in notin is isnot of&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38f129b5e4464e0480827e37320803bf08418860" translate="yes" xml:space="preserve">
          <source>These matching categories have a priority: An exact match is better than a literal match and that is better than a generic match etc. In the following &lt;code&gt;count(p, m)&lt;/code&gt; counts the number of matches of the matching category &lt;code&gt;m&lt;/code&gt; for the routine &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">이러한 일치 범주는 우선 순위를 갖습니다. 정확히 일치하는 것이 리터럴 일치보다 낫고 일반 일치보다 낫습니다. 다음 &lt;code&gt;count(p, m)&lt;/code&gt; 에서 일치하는 범주 &lt;code&gt;m&lt;/code&gt; 의 일치 횟수를 루틴 &lt;code&gt;p&lt;/code&gt; 에 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="6f68cbc9b1069e256838107b36cf58486fce6b38" translate="yes" xml:space="preserve">
          <source>These numbers are usually only for the running thread, not for the whole heap, with the exception of &lt;code&gt;--gc:boehm&lt;/code&gt; and &lt;code&gt;--gc:go&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6be02e33307dc5ed705daa9fb25cdf4cc144412" translate="yes" xml:space="preserve">
          <source>These operations are supported by sets:</source>
          <target state="translated">이러한 작업은 다음 세트에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cde2e097c323766072e20c648ae133aff15ec9e4" translate="yes" xml:space="preserve">
          <source>These operations can be &lt;em&gt;overridden&lt;/em&gt; instead of &lt;em&gt;overloaded&lt;/em&gt;. This means the implementation is automatically lifted to structured types. For instance if type &lt;code&gt;T&lt;/code&gt; has an overridden assignment operator &lt;code&gt;=&lt;/code&gt; this operator is also used for assignments of the type &lt;code&gt;seq[T]&lt;/code&gt;. Since these operations are bound to a type they have to be bound to a nominal type for reasons of simplicity of implementation: This means an overridden &lt;code&gt;deepCopy&lt;/code&gt; for &lt;code&gt;ref T&lt;/code&gt; is really bound to &lt;code&gt;T&lt;/code&gt; and not to &lt;code&gt;ref T&lt;/code&gt;. This also means that one cannot override &lt;code&gt;deepCopy&lt;/code&gt; for both &lt;code&gt;ptr T&lt;/code&gt; and &lt;code&gt;ref T&lt;/code&gt; at the same time; instead a helper distinct or object type has to be used for one pointer type.</source>
          <target state="translated">&lt;em&gt;오버로드&lt;/em&gt; 대신 이러한 작업을 &lt;em&gt;재정의&lt;/em&gt; 할 수 있습니다 . 이는 구현이 자동으로 구조화 된 유형으로 해제됨을 의미합니다. 예를 들어, 유형 &lt;code&gt;T&lt;/code&gt; 에 대체 할당 연산자가있는 경우 &lt;code&gt;=&lt;/code&gt; 이 연산자는 &lt;code&gt;seq[T]&lt;/code&gt; 유형의 할당에도 사용됩니다 . 이러한 연산은 유형에 바인딩되므로 구현이 간단하기 때문에 공칭 유형에 바인딩되어야합니다. 이는 &lt;code&gt;ref T&lt;/code&gt; 대해 대체 된 &lt;code&gt;deepCopy&lt;/code&gt; 가 실제로 T 에 바인딩되고 &lt;code&gt;T&lt;/code&gt; 를 &lt;code&gt;ref T&lt;/code&gt; 하지 않음을 의미 합니다. 이것은 또한 &lt;code&gt;ptr T&lt;/code&gt; 와 &lt;code&gt;ref T&lt;/code&gt; 모두에 대해 &lt;code&gt;deepCopy&lt;/code&gt; 를 무시할 수 없음을 의미합니다.&lt;em&gt;&lt;/em&gt;동시에; 대신 하나의 포인터 유형에 도우미 고유 또는 객체 유형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6299dd429eaf3e5782e3b62dbebbf950dd6652fe" translate="yes" xml:space="preserve">
          <source>These procs may not be imported by a module. You can import them directly for debugging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2944d8a6fb10906fbe7ddce83dab9ed4b20716" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; real-time guarantee; in particular the cycle collector is not aware of deadlines. Deactivate it to get more predictable real-time behaviour. Tests show that a 1ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d058bd216e6b19e493d9e6bac8c481c3e459bccb" translate="yes" xml:space="preserve">
          <source>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</source>
          <target state="translated">이러한 프로세스는 &quot;최선의 노력&quot;실시간 보장을 제공합니다. 특히 사이클 수집기는 마감 기한을 아직 알지 못합니다. 보다 예측 가능한 실시간 동작을 얻으려면 비활성화하십시오. 테스트 결과 최신 CPU의 거의 모든 경우 (사이클 컬렉터가 비활성화 된 상태) 최대 2ms의 일시 중지 시간이 충족되는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="30e9bd52ae679ca98f3066fcb8847b5f10bc445a" translate="yes" xml:space="preserve">
          <source>These rules ensure that the construction is tied to a variable and can easily be destructed at its scope exit. Later versions of the language will improve the support of destructors.</source>
          <target state="translated">이 규칙은 구성이 변수에 연결되어 있고 범위 종료시 쉽게 파괴 될 수 있도록합니다. 이후 버전의 언어는 소멸자의 지원을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2e945da53bb4b2f455a09e7679d83624a41491a" translate="yes" xml:space="preserve">
          <source>These rules will only be enforced for contributions to the Nim codebase and official projects, such as the Nim compiler, the standard library, and the various official tools such as C2Nim.</source>
          <target state="translated">이러한 규칙은 Nim 코드베이스 및 Nim 컴파일러, 표준 라이브러리와 같은 공식 프로젝트 및 C2Nim과 같은 다양한 공식 도구에 대한 기여에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20ac174437fbb360f6e0d2c7d84e935dee5e35b6" translate="yes" xml:space="preserve">
          <source>These templates need to be named &lt;code&gt;atom&lt;/code&gt; and &lt;code&gt;nxt&lt;/code&gt;. &lt;code&gt;atom&lt;/code&gt; should be overloaded to handle both single characters and sets of character.</source>
          <target state="translated">이 템플릿의 이름은 &lt;code&gt;atom&lt;/code&gt; 및 &lt;code&gt;nxt&lt;/code&gt; 여야 합니다. 단일 문자와 문자 세트를 모두 처리하려면 &lt;code&gt;atom&lt;/code&gt; 이 오버로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e15bd991ab50e168df4221760f8fc062679bfd84" translate="yes" xml:space="preserve">
          <source>These three kinds of tokens are enumerated in the &lt;a href=&quot;#CmdLineKind&quot;&gt;CmdLineKind enum&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feeffd43778c20cf3fc45000f1736b9d3dd71d0f" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the real-time garbage collector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1388617e7ec8cadd15c7db56c0366fdc608c12a" translate="yes" xml:space="preserve">
          <source>These two procs are the two modus operandi of the realtime GC:</source>
          <target state="translated">이 두 프로세스는 실시간 GC의 두 가지 방식입니다.</target>
        </trans-unit>
        <trans-unit id="fcd0654223087b53e78c4c1fc707eb12347ccb71" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application in production you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d97cf346f8ff44e70f702c406d7880c63dc3778" translate="yes" xml:space="preserve">
          <source>This HTTP server has not been designed to be used in production, but for testing applications locally. Because of this, when deploying your application you should use a reverse proxy (for example nginx) instead of allowing users to connect directly to this server.</source>
          <target state="translated">이 HTTP 서버는 프로덕션 환경에서 사용하도록 설계되지 않았지만 응용 프로그램을 로컬에서 테스트하기 위해 설계되었습니다. 이 때문에 응용 프로그램을 배포 할 때 사용자가이 서버에 직접 연결할 수 있도록하는 대신 리버스 프록시 (예 : nginx)를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ff934bf75567640acf83ce1e9399ceeeffb3152" translate="yes" xml:space="preserve">
          <source>This Module implements types and macros to facilitate the wrapping of, and interaction with JavaScript libraries. Using the provided types &lt;code&gt;JsObject&lt;/code&gt; and &lt;code&gt;JsAssoc&lt;/code&gt; together with the provided macros allows for smoother interfacing with JavaScript, allowing for example quick and easy imports of JavaScript variables:</source>
          <target state="translated">이 모듈은 유형 및 매크로를 구현하여 자바 스크립트 라이브러리의 래핑 및 상호 작용을 용이하게합니다. 제공된 매크로와 함께 제공된 유형 &lt;code&gt;JsObject&lt;/code&gt; 및 &lt;code&gt;JsAssoc&lt;/code&gt; 을 사용하면 JavaScript와의 원활한 인터페이스가 가능하여 JavaScript 변수를 빠르고 쉽게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9473d766d312db31a1b340bc58dd29fe1c84c3" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;in&lt;/code&gt; operator: &lt;code&gt;a.contains(item)&lt;/code&gt; is the same as &lt;code&gt;item in a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358531b90c868b5aa1914c45c295c0b938277040" translate="yes" xml:space="preserve">
          <source>This allows the GC to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the GC with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</source>
          <target state="translated">이것은 GC가 최대에 대한 몇 가지 작업을 수행 할 수 있습니다 &lt;code&gt;us&lt;/code&gt; 의 시간을. 이것은 GC가 작업을 수행 할 수 있도록 메인 루프를 호출하는 데 유용합니다. 모든 GC 활동을 &lt;code&gt;GC_step&lt;/code&gt; 호출에 바인드하려면 프로그램 시작시 &lt;code&gt;GC_disable&lt;/code&gt; 을 사용 하여 GC를 비활성화하십시오 . &lt;code&gt;strongAdvice&lt;/code&gt; 가로 설정된 경우 &lt;code&gt;true&lt;/code&gt; , GC가 수집주기를 수행하도록 강요 당할 것이다. 그렇지 않으면 GC는 수집 할 쓰레기가 많지 않으면 아무것도하지 않기로 결정할 수 있습니다. &lt;code&gt;stackSize&lt;/code&gt; 매개 변수 를 통해 현재 스택 크기를 지정할 수도 있습니다 . 스택의 특정 지점 아래에 고유 한 Nim 참조가 없다는 것을 알고 있으면 성능을 향상시킬 수 있습니다. 지정한 크기가 최악의 잠재적 크기보다 큰지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2bd372177757f2122848f7b55d70ddc516c7db4f" translate="yes" xml:space="preserve">
          <source>This allows the garbage collector to perform some work for up to &lt;code&gt;us&lt;/code&gt; time. This is useful to call in the main loop to ensure the garbage collector can do its work. To bind all garbage collector activity to a &lt;code&gt;GC_step&lt;/code&gt; call, deactivate the garbage collector with &lt;code&gt;GC_disable&lt;/code&gt; at program startup. If &lt;code&gt;strongAdvice&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then the garbage collector will be forced to perform the collection cycle. Otherwise, the garbage collector may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via &lt;code&gt;stackSize&lt;/code&gt; parameter. It can improve performance when you know that there are no unique Nim references below a certain point on the stack. Make sure the size you specify is greater than the potential worst-case size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e916ac1adfc72c259e0e62a432899799f46cd9" translate="yes" xml:space="preserve">
          <source>This allows the usage of &lt;code&gt;in&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44902b035eecd212cbee979b0a89c76d9b13672" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to write a literal in an unchecked AST that will after sem checking just be of type &lt;code&gt;int&lt;/code&gt; and not implicitly convertible to other integer types. This only works for all integer types that are not &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992f03b78bcf1d185430a70aa05788b70938c9a1" translate="yes" xml:space="preserve">
          <source>This blocks until a message has arrived! You may use &lt;a href=&quot;#peek,Channel%5BTMsg%5D&quot;&gt;peek proc&lt;/a&gt; to avoid the blocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b2e587ffff759ed345a7138f93f32e7018411a" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;match&lt;/code&gt; with an implicit declared &lt;code&gt;matches&lt;/code&gt; array that can be used in the scope of the &lt;code&gt;=~&lt;/code&gt; call:</source>
          <target state="translated">이 호출은 &lt;code&gt;match&lt;/code&gt; 암시 적 선언과 &lt;code&gt;matches&lt;/code&gt; 의 범위에서 사용할 수있는 배열 &lt;code&gt;=~&lt;/code&gt; 전화 :</target>
        </trans-unit>
        <trans-unit id="91e68c05bbcd84956d6a939da42a4d1620388308" translate="yes" xml:space="preserve">
          <source>This can be accomplished with the &lt;code&gt;#discardableprefix&lt;/code&gt; directive. As its name suggests functions of the given prefix(es) that have non-void return type get annotated with &lt;code&gt;.discardable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;#discardableprefix&lt;/code&gt; 지시문을 사용하면 됩니다 . 이름에서 알 수 있듯이 비 반환 반환 유형이있는 주어진 접두사의 기능은 &lt;code&gt;.discardable&lt;/code&gt; 로 주석 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="993037ecc6a7a9266978b1b72316c93245910c17" translate="yes" xml:space="preserve">
          <source>This can be avoided by distinguishing strings that contain SQL from strings that don't. Distinct types provide a means to introduce a new string type &lt;code&gt;SQL&lt;/code&gt; that is incompatible with &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">SQL이 포함 된 문자열과 그렇지 않은 문자열을 구별하면이를 피할 수 있습니다. 구별 유형은 문자열 과 호환되지 않는 새로운 문자열 유형 &lt;code&gt;SQL&lt;/code&gt; 을 도입하는 수단을 제공 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0f58418896b0318ad50111ccb458545bca077f8" translate="yes" xml:space="preserve">
          <source>This can be fixed by explicitly using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de90335a89d6a027e12fb152c891c86ef2f05f70" translate="yes" xml:space="preserve">
          <source>This can be used to check whether a library provides a certain feature or not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a87a7c0c14223cb397afe2f968231607dd88a29" translate="yes" xml:space="preserve">
          <source>This can be useful when you have a value that can be present or not. The absence of a value is often represented by &lt;code&gt;nil&lt;/code&gt;, but it is not always available, nor is it always a good solution.</source>
          <target state="translated">존재하거나 존재하지 않는 값이있을 때 유용 할 수 있습니다. 가치의 부재는 종종 &lt;code&gt;nil&lt;/code&gt; 로 표시되지만 항상 사용 가능한 것은 아니며 항상 좋은 해결책도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3b2e2827e1dd9cc8f707a6716c04839c0c09dae0" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only.</source>
          <target state="translated">0-9 ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b3ae4abe96c6abb652268187695385d740f80fff" translate="yes" xml:space="preserve">
          <source>This checks 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are numeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">0-9 ASCII 문자 만 검사합니다. true를 반환의 모든 문자 경우 &lt;em&gt;들&lt;/em&gt; 숫자이며, 적어도 하나 개의 문자에 존재 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b117d9b50603d6a49490348238bc1594481a404a" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only.</source>
          <target state="translated">ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="21d99d6543b30de8fb262a673a04b6b39bf07b1e" translate="yes" xml:space="preserve">
          <source>This checks ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc954298ac0dfb73fe360b4e03334044ae90394" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only.</source>
          <target state="translated">이것은 z, AZ ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="27f5c2b32f5e5afe9cd3e0adefb2a5846fa92f48" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alphabetic and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">이것은 z, AZ ASCII 문자 만 검사합니다. 진정한 반환의 모든 문자 경우 &lt;em&gt;들&lt;/em&gt; 알파벳이며, 적어도 하나 개의 문자에있다 &lt;em&gt;의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78cfd4a754ca378bfad60ee60fd52a76f4ce74da" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z ASCII characters only. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c461ad96b6496c8497bea23444e5f754d29e62" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only.</source>
          <target state="translated">이것은 az, AZ, 0-9 ASCII 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2aa227843f2651d01fb29a6a47bedb18d9c19" translate="yes" xml:space="preserve">
          <source>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in &lt;em&gt;s&lt;/em&gt; are alpanumeric and there is at least one character in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">이것은 az, AZ, 0-9 ASCII 문자 만 검사합니다. 모든 문자 경우에 true를 돌려 &lt;em&gt;들&lt;/em&gt; alpanumeric하고 적어도 하나 개의 문자에있다&lt;em&gt; 의&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb243522dd9085ea31f048f6623532706ee946c" translate="yes" xml:space="preserve">
          <source>This code demonstrates how you can iterate over all the tags in an HTML file and write back the modified version. In this case we look for hyperlinks ending with the extension &lt;code&gt;.rst&lt;/code&gt; and convert them to &lt;code&gt;.html&lt;/code&gt;.</source>
          <target state="translated">이 코드는 HTML 파일의 모든 태그를 반복하고 수정 된 버전을 다시 작성하는 방법을 보여줍니다. 이 경우 확장자가 &lt;code&gt;.rst&lt;/code&gt; 로 끝나는 하이퍼 링크를 찾아 &lt;code&gt;.html&lt;/code&gt; 로 변환합니다. .</target>
        </trans-unit>
        <trans-unit id="67e26f346f2ccd3c86198d382ef1609a459caeec" translate="yes" xml:space="preserve">
          <source>This code has a shortcoming: if &lt;code&gt;debug&lt;/code&gt; is set to false someday, the quite expensive &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; operations are still performed! (The argument evaluation for procedures is &lt;em&gt;eager&lt;/em&gt;).</source>
          <target state="translated">이 코드에는 단점이 있습니다. 언젠가 &lt;code&gt;debug&lt;/code&gt; 를 false로 설정하면 상당히 비싼 &lt;code&gt;$&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 작업이 계속 수행됩니다! (절차에 대한 논쟁 평가는 &lt;em&gt;열망이다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="ddf8456d90256ef6813274665679598a51d6b207" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape&quot;&gt;escape&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="translated">이는 반대 작업을 수행하므로 &lt;a href=&quot;#escape&quot;&gt;이스케이프&lt;/a&gt; 를 보완 합니다.</target>
        </trans-unit>
        <trans-unit id="448d34e4eec8002bcc63da9cb6384f1b398a912a" translate="yes" xml:space="preserve">
          <source>This complements &lt;a href=&quot;#escape,string,string,string&quot;&gt;escape proc&lt;/a&gt; as it performs the opposite operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb30b5d51da059f03be346551003a62694c6e6c0" translate="yes" xml:space="preserve">
          <source>This condition holds:</source>
          <target state="translated">이 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81ebbfabdc2c9ddc216dc2043c4b3f433dfa4f83" translate="yes" xml:space="preserve">
          <source>This constant is used to determine whether the destination platform is fully supported by &lt;code&gt;ioselectors&lt;/code&gt; module.</source>
          <target state="translated">이 상수는 대상 플랫폼이 &lt;code&gt;ioselectors&lt;/code&gt; 모듈에서 완전히 지원되는지 여부를 결정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec88b8f870dd5f6a3d62cb955fdcb976315090ca" translate="yes" xml:space="preserve">
          <source>This convenience proc parses any input string using rst markup (it doesn't have to be a full document!) and returns an embeddable piece of HTML. The proc is meant to be used in &lt;em&gt;online&lt;/em&gt; environments without access to a meaningful filesystem, and therefore rst &lt;code&gt;include&lt;/code&gt; like directives won't work. For an explanation of the &lt;code&gt;config&lt;/code&gt; parameter see the &lt;code&gt;initRstGenerator&lt;/code&gt; proc. Example:</source>
          <target state="translated">이 편리한 프로시 저는 첫 번째 마크 업 (전체 문서 일 필요는 없음)을 사용하여 모든 입력 문자열을 구문 분석하고 포함 가능한 HTML 조각을 반환합니다. 발동 효과가에서 사용하기위한 것입니다 &lt;em&gt;온라인으로&lt;/em&gt; 의미있는 파일 시스템에 액세스하지 않고 환경 때문에 처음 &lt;code&gt;include&lt;/code&gt; 지시문을 좋아하지 않을 것이다 일을. &lt;code&gt;config&lt;/code&gt; 매개 변수에 대한 설명은 &lt;code&gt;initRstGenerator&lt;/code&gt; proc을 참조하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="4f4da908d1b690f8e981e01fff23cd3d08db0df4" translate="yes" xml:space="preserve">
          <source>This creates a new &lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt;. If no command line arguments are provided, the real command line as provided by the &lt;code&gt;os&lt;/code&gt; module is retrieved instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9772d9f40d4b88270d7bfcc87701c67c1f206a" translate="yes" xml:space="preserve">
          <source>This directive tells c2nim that it should annotate every proc that resulted from a C function prototype with the &lt;code&gt;dynlib&lt;/code&gt; pragma:</source>
          <target state="translated">이 지시어는 c2nim에게 &lt;code&gt;dynlib&lt;/code&gt; pragma를 사용하여 C 함수 프로토 타입에서 생성 된 모든 proc에 주석을 달도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="4603ae97d0bef34ab983059dfa901c4651d6c5d6" translate="yes" xml:space="preserve">
          <source>This document aims to be a precise specification about how move semantics and destructors work in Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc11ca4313f42aaa8eb535d6e6150b0aedbf3be6" translate="yes" xml:space="preserve">
          <source>This document describes Nim's standard library.</source>
          <target state="translated">이 문서는 Nim의 표준 라이브러리에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="344be4f4ba38b24d4eb5d528848beeb4bd8811eb" translate="yes" xml:space="preserve">
          <source>This document describes features of Nim that are to be considered experimental. Some of these are not covered by the &lt;code&gt;.experimental&lt;/code&gt; pragma or &lt;code&gt;--experimental&lt;/code&gt; switch because they are already behind a special syntax and one may want to use Nim libraries using these features without using them oneself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501826eded96f905ab59473404c85f59f07e601c" translate="yes" xml:space="preserve">
          <source>This document describes how the GC works and how to tune it for (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;.</source>
          <target state="translated">이 문서는 GC 작동 방식과 ( &lt;span id=&quot;realtime-systems_1&quot;&gt;실시간&lt;/span&gt; ) &lt;span id=&quot;realtime-systems_1&quot;&gt;실시간 시스템&lt;/span&gt; 에 맞게 조정하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="82487ee5532813ed5f7833504e199d69e4451b0b" translate="yes" xml:space="preserve">
          <source>This document describes how the multi-paradigm memory management strategies work. How to tune the garbage collectors for your needs, like (soft) &lt;span id=&quot;realtime-systems_1&quot;&gt;realtime systems&lt;/span&gt;, and how the memory management strategies that are not garbage collectors work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1436145ee6291786c4efda6509df54038a00ce9" translate="yes" xml:space="preserve">
          <source>This document describes the &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;documentation generation tools&lt;/span&gt; built into the &lt;a href=&quot;nimc&quot;&gt;Nim compiler&lt;/a&gt;, which can generate HTML and JSON output from input .nim files and projects, as well as HTML and LaTeX from input RST (reStructuredText) files. The output documentation will include module dependencies (&lt;code&gt;import&lt;/code&gt;), any top-level documentation comments (##), and exported symbols (*), including procedures, types, and variables.</source>
          <target state="translated">이 문서 는 &lt;a href=&quot;nimc&quot;&gt;Nim 컴파일러에&lt;/a&gt; 내장 된 &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;문서 생성 도구에&lt;/span&gt; 대해 설명합니다.이 &lt;span id=&quot;documentation-generation-tools_1&quot;&gt;도구&lt;/span&gt; 는 입력 .nim 파일 및 프로젝트에서 HTML 및 JSON 출력은 물론 입력 RST (reStructuredText) 파일에서 HTML 및 LaTeX를 생성 할 수 있습니다. 출력 문서에는 모듈 종속성 ( &lt;code&gt;import&lt;/code&gt; ), 최상위 문서 주석 (##) 및 프로 시저, 유형 및 변수를 포함하여 내 보낸 기호 (*)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="876d6f96c63ad0dcba59ff24b243aebd3e783be3" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of Nim.</source>
          <target state="translated">이 문서는 Nim의 어휘, 구문 및 의미를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="052a5aaf43125762195ce8979a78fa337c691660" translate="yes" xml:space="preserve">
          <source>This document describes the lexis, the syntax, and the semantics of the Nim language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601f8c6b34793396897c345b490ce1360453f6a5" translate="yes" xml:space="preserve">
          <source>This document describes the upcoming Nim runtime which does not use classical GC algorithms anymore but is based on destructors and move semantics. The new runtime's advantages are that Nim programs become oblivious to the involved heap sizes and programs are easier to write to make effective use of multi-core machines. As a nice bonus, files and sockets and the like will not require manual &lt;code&gt;close&lt;/code&gt; calls anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb13f15afd5992eb20356ca76c23dc066a055b6" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (therefore is the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="translated">이 문서는 지원되는 다른 플랫폼 에서 &lt;em&gt;Nim 컴파일러&lt;/em&gt; 의 사용법을 설명합니다 . Nim 프로그래밍 언어의 정의가 아닙니다 (따라서 &lt;a href=&quot;manual&quot;&gt;매뉴얼&lt;/a&gt; 이 있습니다) 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee46bbf1bf7e5279f84d46353ef02a9266df1275" translate="yes" xml:space="preserve">
          <source>This document describes the usage of the &lt;em&gt;Nim compiler&lt;/em&gt; on the different supported platforms. It is not a definition of the Nim programming language (which is covered in the &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb274ef505ac7161b2d0c10daf0e239378a408c" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the advanced constructs of the &lt;em&gt;Nim&lt;/em&gt; programming language. &lt;strong&gt;Note that this document is somewhat obsolete as the&lt;/strong&gt;&lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt;&lt;strong&gt;contains many more examples of the advanced language features.&lt;/strong&gt;</source>
          <target state="translated">이 문서는 &lt;em&gt;Nim&lt;/em&gt; 프로그래밍 언어 의 고급 구성에 대한 튜토리얼입니다 . &lt;a href=&quot;manual&quot;&gt;매뉴얼 &lt;/a&gt;&lt;strong&gt;에 고급 언어 기능에 대한 더 많은 예제가 포함되어 &lt;/strong&gt;&lt;strong&gt;있으므로이 문서는 다소 쓸모가 없습니다 &lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51cc327eea029a9a74f8f2656806b1a3582d4c70" translate="yes" xml:space="preserve">
          <source>This document is a tutorial for the programming language &lt;em&gt;Nim&lt;/em&gt;. This tutorial assumes that you are familiar with basic programming concepts like variables, types or statements but is kept very basic. The &lt;a href=&quot;manual&quot;&gt;manual&lt;/a&gt; contains many more examples of the advanced language features. All code examples in this tutorial, as well as the ones found in the rest of Nim's documentation, follow the &lt;a href=&quot;nep1&quot;&gt;Nim style guide&lt;/a&gt;.</source>
          <target state="translated">이 문서는 프로그래밍 언어 &lt;em&gt;Nim에&lt;/em&gt; 대한 튜토리얼입니다 . 이 학습서는 변수, 유형 또는 명령문과 같은 기본 프로그래밍 개념에 익숙하지만 매우 기본적인 것으로 가정합니다. 이 &lt;a href=&quot;manual&quot;&gt;설명서&lt;/a&gt; 에는 고급 언어 기능의 더 많은 예가 포함되어 있습니다. 이 튜토리얼의 모든 코드 예제와 나머지 Nim 문서에서 찾은 코드 예제는 &lt;a href=&quot;nep1&quot;&gt;Nim 스타일 가이드를&lt;/a&gt; 따릅니다. .</target>
        </trans-unit>
        <trans-unit id="dc36e0a51521723c2d17399937c4b8017c6cb9b6" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of idetools support you can look at the test files found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt; or &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">이 문서는 사용 가능한 옵션을 안내합니다. idetools 지원의 실제 예를 보려면 &lt;a href=&quot;#test-suite&quot;&gt;테스트 스위트&lt;/a&gt; 에서 찾은 테스트 파일 또는 이미 사용 가능한 &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;다양한 편집기 통합&lt;/a&gt; 을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50c7c6fe53ac393a7c7fac0b0acdac2132c3be2" translate="yes" xml:space="preserve">
          <source>This document will guide you through the available options. If you want to look at practical examples of nimsuggest support you can look at the &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;various editor integrations&lt;/a&gt; already available.</source>
          <target state="translated">이 문서는 사용 가능한 옵션을 안내합니다. 가장 강력한 지원의 실제 예를 보려면 &lt;a href=&quot;https://github.com/Araq/Nim/wiki/Editor-Support&quot;&gt;다양한 편집기 통합을&lt;/a&gt; 볼 수 있습니다 이미 사용 가능한 을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a42362fd0fdb024567fc8917a8d4c8e5c41a8857" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is already in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20177f379121698f488e5c0b5ae0c546e34cb464" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;code&gt;key&lt;/code&gt; is not found in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9463da66a61d4818bd3012c1d824f16d76b55047" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is already in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 이미 &lt;em&gt;s에&lt;/em&gt; 있으면 아무것도하지 않습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="2d74bf1bd66d315281b8b850d55664417bfed9ea" translate="yes" xml:space="preserve">
          <source>This doesn't do anything if &lt;em&gt;key&lt;/em&gt; is not found in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="translated">&lt;em&gt;s에 &lt;/em&gt;&lt;em&gt;키&lt;/em&gt; 가 없으면 아무 것도 수행하지 않습니다 . 예:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04208e500a8d87248355c319f0fd4502fe85e0e8" translate="yes" xml:space="preserve">
          <source>This example demonstrates the usage of the W3 HTML Validator, it uses &lt;code&gt;multipart/form-data&lt;/code&gt; as the &lt;code&gt;Content-Type&lt;/code&gt; to send the HTML to be validated to the server.</source>
          <target state="translated">이 예제는 W3 HTML Validator의 사용법을 보여줍니다. &lt;code&gt;multipart/form-data&lt;/code&gt; 를 &lt;code&gt;Content-Type&lt;/code&gt; 으로 사용 하여 검증 할 HTML을 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="dfa1b9eabc9505799b820ee46f8953f4c8f974ac" translate="yes" xml:space="preserve">
          <source>This example shows a procedure named &lt;code&gt;yes&lt;/code&gt; that asks the user a &lt;code&gt;question&lt;/code&gt; and returns true if they answered &quot;yes&quot; (or something similar) and returns false if they answered &quot;no&quot; (or something similar). A &lt;code&gt;return&lt;/code&gt; statement leaves the procedure (and therefore the while loop) immediately. The &lt;code&gt;(question: string): bool&lt;/code&gt; syntax describes that the procedure expects a parameter named &lt;code&gt;question&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; and returns a value of type &lt;code&gt;bool&lt;/code&gt;. The &lt;code&gt;bool&lt;/code&gt; type is built-in: the only valid values for &lt;code&gt;bool&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. The conditions in if or while statements must be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">이 예는 사용자에게 &lt;code&gt;question&lt;/code&gt; 하고 &quot;예&quot;(또는 비슷한 것)로 대답하면 true를 반환하고 &quot;아니오&quot;(또는 비슷한 것)로 대답하면 false를 반환 하는 &lt;code&gt;yes&lt;/code&gt; 라는 프로 시저를 보여줍니다 . &lt;code&gt;return&lt;/code&gt; 문은 즉시 절차 (따라서 while 루프)를 떠난다. &lt;code&gt;(question: string): bool&lt;/code&gt; 구문은 절차라는 이름의 매개 변수를 기대하는 설명 &lt;code&gt;question&lt;/code&gt; 형식의 &lt;code&gt;string&lt;/code&gt; 입력합니다 값 반환 &lt;code&gt;bool&lt;/code&gt; . &lt;code&gt;bool&lt;/code&gt; 유형은 내장되어에 대한 유효한 값 &lt;code&gt;bool&lt;/code&gt; 있습니다 &lt;code&gt;true&lt;/code&gt; . if 또는 while 문의 조건은 &lt;code&gt;bool&lt;/code&gt; 유형이어야합니다 . 과 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="419751183c50edae04b9814dec67dc7101cf22a4" translate="yes" xml:space="preserve">
          <source>This example uses HTTP GET to retrieve &lt;code&gt;http://google.com&lt;/code&gt;:</source>
          <target state="translated">이 예는 HTTP GET을 사용하여 &lt;code&gt;http://google.com&lt;/code&gt; 을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="c530469f8ff4d36d8c0d58dcb3d2f3b70e61c1b6" translate="yes" xml:space="preserve">
          <source>This example will create an HTTP server on port 8080. The server will respond to all requests with a &lt;code&gt;200 OK&lt;/code&gt; response code and &quot;Hello World&quot; as the response body.</source>
          <target state="translated">이 예는 포트 8080에서 HTTP 서버를 작성합니다. 서버는 &lt;code&gt;200 OK&lt;/code&gt; 응답 코드와 &quot;Hello World&quot;를 응답 본문으로 사용하여 모든 요청 에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="82f9bd61449ea276e7ba79a6b51086b4f68f04d2" translate="yes" xml:space="preserve">
          <source>This exception is raised when a string parameter contains an illegal character</source>
          <target state="translated">문자열 매개 변수에 잘못된 문자가 포함 된 경우이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49884cc4168ac3b56e2f36bd32448ca533036aba" translate="yes" xml:space="preserve">
          <source>This feature is still under development. In the future it will allow an IDE to evaluate an expression in the context of the currently running/debugged user project.</source>
          <target state="translated">이 기능은 아직 개발 중입니다. 앞으로 IDE가 현재 실행중인 / 디버깅 된 사용자 프로젝트의 컨텍스트에서 표현식을 평가할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="718ecf2ca622cda3af52f68c05ddd3883f87e430" translate="yes" xml:space="preserve">
          <source>This file implements features required for IDE support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6fc55e019f2e067eb3af4f08888a5e5eab4d20" translate="yes" xml:space="preserve">
          <source>This file implements the new evaluation engine for Nim code. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baae068151a80870f517a9c80fabe195a66afe5b" translate="yes" xml:space="preserve">
          <source>This function checks for events on all the delegates in the &lt;em&gt;PDispatcher&lt;/em&gt;. It then proceeds to call the correct event handler.</source>
          <target state="translated">이 함수는 &lt;em&gt;PDispatcher의&lt;/em&gt; 모든 대리자에서 이벤트를 확인합니다 . 그런 다음 올바른 이벤트 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ef0b456d31d45682c8880248481ad8c2632bf2f5" translate="yes" xml:space="preserve">
          <source>This function is NOT reliable. Floating point numbers cannot hold non integer decimals precisely. If &lt;code&gt;places&lt;/code&gt; is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. &lt;code&gt;round(54.5) -&amp;gt; 55.0&lt;/code&gt;). If &lt;code&gt;places&lt;/code&gt; is greater than 0, round to the given number of decimal places, e.g. &lt;code&gt;round(54.346, 2) -&amp;gt; 54.350000000000001421&amp;hellip;&lt;/code&gt;. If &lt;code&gt;places&lt;/code&gt; is negative, round to the left of the decimal place, e.g. &lt;code&gt;round(537.345, -1) -&amp;gt; 540.0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4a4220996badd8db70594d8b36b935a69870fd" translate="yes" xml:space="preserve">
          <source>This function is available only when &lt;code&gt;--threads:on&lt;/code&gt; and &lt;code&gt;--tlsEmulation:off&lt;/code&gt; switches are used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4390f3f69d4871fa4d3972e4b499717ab1b670b2" translate="yes" xml:space="preserve">
          <source>This function is not implemented on all platform, test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c640f2d135e1c682951e71cb417036f1e1dabc6c" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;True&lt;/code&gt; if there are file descriptors that are still open, otherwise &lt;code&gt;False&lt;/code&gt;. File descriptors that have been closed are immediately removed from the dispatcher automatically.</source>
          <target state="translated">이 함수 는 여전히 열려있는 파일 디스크립터가 있으면 &lt;code&gt;True&lt;/code&gt; 를 리턴 하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴합니다 . 닫힌 파일 설명자는 즉시 디스패처에서 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="80da17632a4719e714bb180d2505b06fb4c81b21" translate="yes" xml:space="preserve">
          <source>This function will lookup the IP address of a hostname.</source>
          <target state="translated">이 기능은 호스트 이름의 IP 주소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="888f45de89db87248b6c42a8441e4fc3f923719d" translate="yes" xml:space="preserve">
          <source>This function will lookup the hostname of an IP Address.</source>
          <target state="translated">이 기능은 IP 주소의 호스트 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="9ba85512a6c5538eb44a83be7203148f1393be22" translate="yes" xml:space="preserve">
          <source>This function will raise an EOS exception when a socket error occurs.</source>
          <target state="translated">이 함수는 소켓 오류가 발생하면 EOS 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="83d0d0f248054169b861c6becec14e8bc119b1fc" translate="yes" xml:space="preserve">
          <source>This function will remove the data that was returned from the underlying &lt;code&gt;FutureStream&lt;/code&gt;.</source>
          <target state="translated">이 함수는 기본 &lt;code&gt;FutureStream&lt;/code&gt; 에서 반환 된 데이터를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="48be562c3c3e831dca5c27c76a3332e0fe473cb4" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs.</source>
          <target state="translated">이 함수는 오류가 발생하면 EOS 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0d0f4a3f3c929a542ada2a33db6e38abd1059abb" translate="yes" xml:space="preserve">
          <source>This function will throw an EOS exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">이 함수는 오류가 발생하면 EOS 예외를 발생시킵니다. 0보다 작은 값은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d8f3e9799faf34cc137a492d6f553e08eafcb4b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125d21a7a8629f951aed2b4a51171c5e5038ef0b" translate="yes" xml:space="preserve">
          <source>This function will throw an OSError exception when an error occurs. A value lower than 0 is never returned.</source>
          <target state="translated">이 함수는 오류가 발생하면 OSError 예외를 발생시킵니다. 0보다 작은 값은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4ca2ac4f720e72b5b82cc411b68835f82a7af2" translate="yes" xml:space="preserve">
          <source>This happens for calculations whose results are too large to fit in the provided bits.</source>
          <target state="translated">결과가 너무 커서 제공된 비트에 맞지 않는 계산에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7d396147bbaee5b1e555360e29d6e7950ec2165" translate="yes" xml:space="preserve">
          <source>This has NOT yet been (extensively) tested against ODBC drivers for Teradata, Oracle, Sybase, MSSqlvSvr, et. al. databases.</source>
          <target state="translated">이것은 Teradata, Oracle, Sybase, MSSqlvSvr 등의 ODBC 드라이버에 대해 아직 광범위하게 테스트되지 않았습니다. 알. 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="0cd633329a7f1f5e683279f4817767b6e858402b" translate="yes" xml:space="preserve">
          <source>This has further consequences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80811f797327311abf9b8bb44734abd6ccfea15" translate="yes" xml:space="preserve">
          <source>This implementation calls &lt;code&gt;math.randomize()&lt;/code&gt; for the first call of &lt;code&gt;genOid&lt;/code&gt;.</source>
          <target state="translated">이 구현 은 &lt;code&gt;genOid&lt;/code&gt; 의 첫 번째 호출에 대해 &lt;code&gt;math.randomize()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d16330d38656e17d5127ab390f1fa9fa82609de7" translate="yes" xml:space="preserve">
          <source>This is &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59b97830c5bd0f5ff50a358d8f4e2f7574886e8" translate="yes" xml:space="preserve">
          <source>This is &lt;strong&gt;unsafe&lt;/strong&gt; as it allocates an object of the passed &lt;code&gt;size&lt;/code&gt;. This should only be used for optimization purposes when you know what you're doing!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1152982ee72cd4dc2acc598e6a1878a3cb306d" translate="yes" xml:space="preserve">
          <source>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_SMTP&quot;&gt;SMTP extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291d5e1a5495802c3c84e77e045ae2f53bfb5167" translate="yes" xml:space="preserve">
          <source>This is a part of &lt;code&gt;system.nim&lt;/code&gt;, you should not manually import it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58c523ddb24f9724b2d75ac0236939620e83491" translate="yes" xml:space="preserve">
          <source>This is a raw POSIX interface module. It does not not provide any convenience: cstrings are used instead of proper Nim strings and return codes indicate errors. If you want exceptions and a proper Nim-like interface, use the OS module or write a wrapper.</source>
          <target state="translated">이것은 원시 POSIX 인터페이스 모듈입니다. 편의를 제공하지는 않습니다. 적절한 Nim 문자열 대신 cstring이 사용되며 리턴 코드는 오류를 나타냅니다. 예외와 적절한 Nim과 같은 인터페이스를 원하면 OS 모듈을 사용하거나 랩퍼를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0e187a8e9e9b4d53c523d572ffaa0449d8fd615b" translate="yes" xml:space="preserve">
          <source>This is a simple syntactic transformation into:</source>
          <target state="translated">이것은 다음과 같은 간단한 구문 변환입니다.</target>
        </trans-unit>
        <trans-unit id="baffe5aa2ca431a951c22f6627b3195c4e8e9257" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions()&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions()&lt;/a&gt; on non Windows platform. On Windows this proc is just a wrapper for &lt;a href=&quot;#copyFile&quot;&gt;copyFile()&lt;/a&gt; since that proc already copies attributes.</source>
          <target state="translated">이 래퍼의 PROC입니다 &lt;a href=&quot;#copyFile&quot;&gt;CopyFile 수 ()&lt;/a&gt; , &lt;a href=&quot;#getFilePermissions&quot;&gt;getFilePermissions ()&lt;/a&gt; 및 &lt;a href=&quot;#setFilePermissions&quot;&gt;setFilePermissions ()&lt;/a&gt; 비 Windows 플랫폼에서. Windows에서이 proc은 &lt;a href=&quot;#copyFile&quot;&gt;copyFile ()&lt;/a&gt; 의 래퍼 일뿐 입니다. 해당 proc은 이미 속성을 복사하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e7889b59af2f2b66c7a5250872376894c99e6798" translate="yes" xml:space="preserve">
          <source>This is a wrapper proc around &lt;a href=&quot;#copyFile,string,string&quot;&gt;copyFile&lt;/a&gt;, &lt;a href=&quot;#getFilePermissions,string&quot;&gt;getFilePermissions&lt;/a&gt; and &lt;a href=&quot;#setFilePermissions,string,set%5BFilePermission%5D&quot;&gt;setFilePermissions&lt;/a&gt; procs on non-Windows platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a603ff59d56a2ac3e9b3c36a052ac4a5c2114b5" translate="yes" xml:space="preserve">
          <source>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</source>
          <target state="translated">이것은 모두 단일 스레드, 완전 비 블로킹이며 많은 제어 기능을 제공합니다. 이론적으로는 Windows 이외의 플랫폼에만 관심이있는 한 이러한 계층을 상호 교환하여 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="106552ab99d75903f8f7507280b5c7f154edc971" translate="yes" xml:space="preserve">
          <source>This is also used by the code generator for the implementation of &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cad2e5f3a65e247d00d9f14abfba38cdd1e9778" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(1)&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfd16ee323a671ecdfb12c816b6de91a9a9a32f" translate="yes" xml:space="preserve">
          <source>This is an &lt;code&gt;O(n)&lt;/code&gt; operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb775bab32177650720f4b9d9b75ca0579c501f6" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#staticExec&quot;&gt;staticExec&lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="cac9bcfc62c9f2dfc091188b39f1cd9d2776d953" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticExec,string,string,string&quot;&gt;staticExec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14a0c9a9b72673d11d5220860a7e2d032297599" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f27f252061898e3dc51b007922c3601c40f37b56" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;a href=&quot;#staticRead,string&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597d82c31bdafce1e17f3e095745fae4aa8f063d" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;uint8&lt;/code&gt;, that is an unsigned integer, 8 bits wide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39548494ffeefbdea437a44fba01f90cd710d14" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over command line arguments. This creates a new OptParser. See the above &lt;code&gt;getopt(var OptParser)&lt;/code&gt; example for using default empty &lt;code&gt;NoVal&lt;/code&gt; parameters. This example is for the same option keys as that example but here option key-value separators become optional for command users:</source>
          <target state="translated">이것은 명령 행 인수를 반복하기위한 편리한 반복기입니다. 새로운 OptParser가 생성됩니다. 기본 비어있는 &lt;code&gt;NoVal&lt;/code&gt; 매개 변수 사용에 대한 위의 &lt;code&gt;getopt(var OptParser)&lt;/code&gt; 예제를 참조하십시오 . 이 예제는 예제와 동일한 옵션 키에 대한 것이지만 여기서는 명령 키 사용자에게 옵션 키-값 구분 기호가 선택 사항이됩니다.</target>
        </trans-unit>
        <trans-unit id="e447530d06e7e3f0eb38b06f1ec7e2d1eabe95e8" translate="yes" xml:space="preserve">
          <source>This is an convenience iterator for iterating over the given OptParser object. Example:</source>
          <target state="translated">주어진 OptParser 객체를 반복하기위한 편리한 반복자입니다. 예:</target>
        </trans-unit>
        <trans-unit id="46521745d7cb0cedd54b67fe6c5b314fc7bf2b49" translate="yes" xml:space="preserve">
          <source>This is an example of a configuration file.</source>
          <target state="translated">이것은 구성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="bb8b17fc24c398ee4adf40c48e79b2a6ab176591" translate="yes" xml:space="preserve">
          <source>This is an example of a third party module that uses macros and templates to translate text strings on unmodified NimScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d57d5e9e40ed277e61d9e1d580ae63f60ceef5" translate="yes" xml:space="preserve">
          <source>This is an internal helper module. Do not use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8621b33d7505ff2f752c63fce71661a8f7e46de8" translate="yes" xml:space="preserve">
          <source>This is best explained by an example:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="303d755730efc75b448e0367fb111543fb211df2" translate="yes" xml:space="preserve">
          <source>This is best illustrated by an example:</source>
          <target state="translated">이것은 예를 통해 가장 잘 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="46f5b0f3810fc00217f071160db6bcce0f78c6fb" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;a href=&quot;#cstringArrayToSeq,cstringArray,Natural&quot;&gt;cstringArrayToSeq proc&lt;/a&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d07b0945aa6279aac37be60460c485fcc1ff52f" translate="yes" xml:space="preserve">
          <source>This is binary compatible to the type &lt;code&gt;char**&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. The array's high value is large enough to disable bounds checking in practice. Use &lt;em&gt;cstringArrayToSeq&lt;/em&gt; to convert it into a &lt;code&gt;seq[string]&lt;/code&gt;.</source>
          <target state="translated">이 유형에 바이너리 호환 &lt;code&gt;char**&lt;/code&gt; 에 &lt;em&gt;C&lt;/em&gt; . 배열의 높은 값은 실제로 범위 검사를 비활성화 할만큼 충분히 큽니다. &lt;em&gt;cstringArrayToSeq&lt;/em&gt; 를 사용 하여 &lt;code&gt;seq[string]&lt;/code&gt; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8e0f1f729f18e2e3789687a0b726bb73204855" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;a href=&quot;system#div,int,int&quot;&gt;system.div&lt;/a&gt; operator, which is defined as &lt;code&gt;trunc(x / y)&lt;/code&gt;. That is, &lt;code&gt;div&lt;/code&gt; rounds towards &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;floorDiv&lt;/code&gt; rounds down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd38078b21b67094ebb387df8cff1e550ab3259" translate="yes" xml:space="preserve">
          <source>This is done using the &lt;code&gt;to&lt;/code&gt; macro. Take a look at &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;its documentation&lt;/a&gt; to see an example of its use.</source>
          <target state="translated">이것은을 사용하여 수행됩니다 &lt;code&gt;to&lt;/code&gt; 매크로. 한 번 봐 가지고 &lt;a href=&quot;#to.m,JsonNode,typedesc&quot;&gt;그 문서&lt;/a&gt; 의 사용의 예를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e255e0fbf090e03656557a6058c22d1d0988d1e" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Length&quot; header.</source>
          <target state="translated">이것은 사실상 &quot;Content-Length&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="ed8e6faffed9f4240c98845eace9c4ed1fe9f2f0" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Content-Type&quot; header.</source>
          <target state="translated">이것은 사실상 &quot;Content-Type&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="86b65d9de6d29645204c64f1e3d019cece2fb6d2" translate="yes" xml:space="preserve">
          <source>This is effectively the value of the &quot;Last-Modified&quot; header.</source>
          <target state="translated">이것은 &quot;마지막으로 수정 된&quot;헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="d640ae92e84a970ee42165aaa5616bc83d8747c3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;s = @[]; setlen(s, len)&lt;/code&gt;, but more efficient since no reallocation is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae97abc8c2bdcefb0d913bd908e2fc80b7fe31b2" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;var&lt;/code&gt;, but with &lt;code&gt;nnkLetSection&lt;/code&gt; rather than &lt;code&gt;nnkVarSection&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 동일 하지만 &lt;code&gt;nnkLetSection&lt;/code&gt; 대신 &lt;code&gt;nnkVarSection&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="36d6a591729274afeef549b79cbc02b07d624ba3" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;inet-ntoa_1&quot;&gt;inet_ntoa&lt;/span&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="31be46f14ea5182185d28153c71f2103de5579e6" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;getpeername_1&quot;&gt;getpeername의&lt;/span&gt; 고급 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="2074516e24b0521a08ed457d7f66ebecf4eb273e" translate="yes" xml:space="preserve">
          <source>This is high-level interface for &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="translated">이것은 &lt;span id=&quot;getsockname_1&quot;&gt;getsockname의&lt;/span&gt; 고급 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="5365fcbec705681207add66f8f3d448223f0b9f4" translate="yes" xml:space="preserve">
          <source>This is intended for commands like check or parse which will work on the main project file unless explicitly given a specific file argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cca37ce9a619c91bf0a3b8b5b0129b402048ee0" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addRead&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca31998cd06c4abd11a107dae0b2105838b8be7f" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;code&gt;addWrite&lt;/code&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddf14a4425a7355cc2a2fa04844ca91c2768874" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addRead&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">이것은 IOCP (Windows Completion Ports)를위한 &lt;code&gt;pure&lt;/code&gt; 메커니즘 이 아니므로 이를 피할 수 있다면 그렇게하십시오. 실제로 필요한 경우에만 &lt;em&gt;addRead를&lt;/em&gt; 사용하십시오 (주요 유스 케이스는 Windows에서 유닉스와 유사한 라이브러리를 비동기 적으로 조정하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="55bde4657459bdfc7c019b27a4bfe5a2e63714bd" translate="yes" xml:space="preserve">
          <source>This is not &lt;code&gt;pure&lt;/code&gt; mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use &lt;em&gt;addWrite&lt;/em&gt; only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</source>
          <target state="translated">이것은 IOCP (Windows Completion Ports)를위한 &lt;code&gt;pure&lt;/code&gt; 메커니즘 이 아니므로 이를 피할 수 있다면 그렇게하십시오. 실제로 필요한 경우에만 &lt;em&gt;addWrite를&lt;/em&gt; 사용하십시오 (주요 유스 케이스는 Windows에서 유닉스와 유사한 라이브러리를 비동기 적으로 조정하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="628008d53ae8c66db6ea85a99a23fa3a10da5be9" translate="yes" xml:space="preserve">
          <source>This is not as efficient as turning a fixed length array into a sequence as it always copies every element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bb6096521d3fc312bed6cb0cb52cdf4b61e4a1" translate="yes" xml:space="preserve">
          <source>This is not guaranteed for the &lt;code&gt;times.Time&lt;/code&gt; type! This means that the &lt;code&gt;MonoTime&lt;/code&gt; should be used when measuring durations of time with high precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99100dfb2d46cb56adf22ab9dcf180bb5b0d4d9b" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See &lt;a href=&quot;macros#statements-procedure-declaration&quot;&gt;Procedure declaration&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e873a8f9ecb0f52084031638cec01f7691b7b6" translate="yes" xml:space="preserve">
          <source>This is not the same AST for all uses of &lt;code&gt;var&lt;/code&gt;. See [Procedure declaration](&lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 의 모든 용도에 대해 동일한 AST는 아닙니다 . 자세한 내용은 [프로 시저 선언] ( &lt;a href=&quot;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&quot;&gt;http://nim-lang.org/docs/macros.html#statements-procedure-declaration&lt;/a&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a7fe82c8947dd52185c1702a90b9db33146699" translate="yes" xml:space="preserve">
          <source>This is not the syntax for assignment when combined with &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, or &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 와 결합 될 때 할당 구문이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4ffa6f30e8b92ee2b75fd9ae9e7c977be41a4837" translate="yes" xml:space="preserve">
          <source>This is not to be confused with &lt;a href=&quot;system#currentSourcePath.t&quot;&gt;system.currentSourcePath&lt;/a&gt; which returns the path of the source file containing that template call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b56f8d625d177685d852e8e5c0f45517f46c5cd" translate="yes" xml:space="preserve">
          <source>This is often better than disabling all warnings at once.</source>
          <target state="translated">이것은 모든 경고를 한 번에 비활성화하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="8a1f35c0ffc0ce49e85232a6bb768ebe237c3d29" translate="yes" xml:space="preserve">
          <source>This is often more efficient than &lt;code&gt;tmp = a; a = b; b = tmp&lt;/code&gt;. Particularly useful for sorting algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d6f926873c2b638a1222cdb189469c5136966c2" translate="yes" xml:space="preserve">
          <source>This is often the same as the &lt;code&gt;head&lt;/code&gt; result of &lt;code&gt;splitPath&lt;/code&gt;. If there is no parent, &quot;&quot; is returned.</source>
          <target state="translated">이것은 종종 &lt;code&gt;splitPath&lt;/code&gt; 의 &lt;code&gt;head&lt;/code&gt; 결과와 동일 합니다. 부모가 없으면 &quot;&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5387b23d1544c30a7bae7f5ad7dd90a3bed36ca1" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;code&gt;sep&lt;/code&gt;. &lt;code&gt;sep&lt;/code&gt; is only added if &lt;code&gt;dest&lt;/code&gt; is longer than &lt;code&gt;startLen&lt;/code&gt;. The following example creates a string describing an array of integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3f09919cd0742fbd659728142a828b4c8270a" translate="yes" xml:space="preserve">
          <source>This is often useful for generating some code where the items need to be &lt;em&gt;separated&lt;/em&gt; by &lt;em&gt;sep&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt; is only added if &lt;em&gt;dest&lt;/em&gt; is longer than &lt;em&gt;startLen&lt;/em&gt;. The following example creates a string describing an array of integers.</source>
          <target state="translated">항목 을 &lt;em&gt;sep&lt;/em&gt; 로 &lt;em&gt;구분&lt;/em&gt; 해야하는 코드를 생성 할 때 유용합니다 . &lt;em&gt;sep&lt;/em&gt; 는 &lt;em&gt;dest&lt;/em&gt; 가 더 긴 경우에만 추가됩니다&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt; startLen&lt;/em&gt; . 다음 예제는 정수 배열을 설명하는 문자열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1ce17a7f7111b242071cf2276a295e1114c27396" translate="yes" xml:space="preserve">
          <source>This is only needed if you need to implement a hash proc for a new datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b5a1ec53f980e2c0f3189011ffcb0ab0d3401" translate="yes" xml:space="preserve">
          <source>This is only of interest if you want to write a custom &lt;code&gt;format&lt;/code&gt; proc that should support the standard format specifiers. If &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; is true, an unknown suffix after the &lt;code&gt;type&lt;/code&gt; field is not an error.</source>
          <target state="translated">표준 형식 지정자를 지원해야하는 사용자 정의 &lt;code&gt;format&lt;/code&gt; proc 을 작성하려는 경우에만 관심이 있습니다 . 경우 &lt;code&gt;ignoreUnknownSuffix&lt;/code&gt; 는 애프터 알 수없는 접미사 사실이다 &lt;code&gt;type&lt;/code&gt; 필드는 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e9b2fa085ecd9ffb0144806ddc4d77c951b5b385" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;a href=&quot;segfaults&quot;&gt;segfaults module&lt;/a&gt; was imported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19846465c46a33495b53f4086a71823a95381c03" translate="yes" xml:space="preserve">
          <source>This is only raised if the &lt;code&gt;segfaults.nim&lt;/code&gt; module was imported!</source>
          <target state="translated">이것은 &lt;code&gt;segfaults.nim&lt;/code&gt; 인 경우에만 발생합니다. 모듈을 가져온 !</target>
        </trans-unit>
        <trans-unit id="fe15c448cc2638c08d44452df9bc1535305d8381" translate="yes" xml:space="preserve">
          <source>This is only used for speed hacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb1edaaf90d1400f49467187534983c2fef435b" translate="yes" xml:space="preserve">
          <source>This is only useful for optimization purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b8e0f949b1068c1e1a8a842d9da6796b501f9c" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command line option. This pragma only has an effect for the code generation on the Windows target, so when this pragma is forgotten and the dynamic library is only tested on Mac and/or Linux, there won't be an error. On Windows this pragma adds &lt;code&gt;__declspec(dllexport)&lt;/code&gt; to the function declaration.</source>
          <target state="translated">이것은 &lt;code&gt;--app:lib&lt;/code&gt; 명령 줄 옵션을 통해 프로그램이 동적 라이브러리로 컴파일 된 경우에만 유용합니다 . 이 pragma는 Windows 대상에서의 코드 생성에만 영향을 미치므로이 pragma를 잊어 버리고 동적 라이브러리를 Mac 및 / 또는 Linux에서만 테스트하면 오류가 발생하지 않습니다. Windows에서이 pragma는 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 을 함수 선언에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1c92294cd2a2dc37d3a8cc6e8c5557f50f24e7aa" translate="yes" xml:space="preserve">
          <source>This is only useful if the program is compiled as a dynamic library via the &lt;code&gt;--app:lib&lt;/code&gt; command-line option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d812993dd18329bdd5b49f464355b81590a6389c" translate="yes" xml:space="preserve">
          <source>This is optional.</source>
          <target state="translated">이것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f402c8f3279ea5adad0c54031820826de8af43c8" translate="yes" xml:space="preserve">
          <source>This is overridden by some tools (namely nimsuggest) via the &lt;code&gt;conf.prefixDir&lt;/code&gt; field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d41adf425cb818275923d0842af48d38ad37604" translate="yes" xml:space="preserve">
          <source>This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is &lt;em&gt;not&lt;/em&gt;&lt;code&gt;RootObj&lt;/code&gt; but a tuple of a structure that depends on the current scope. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624193289805ef01288ef5a655555f1018d6592e" translate="yes" xml:space="preserve">
          <source>This is roughly equivalent to the &lt;code&gt;async&lt;/code&gt; keyword in JavaScript code.</source>
          <target state="translated">이것은 JavaScript 코드 의 &lt;code&gt;async&lt;/code&gt; 키워드 와 거의 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f551bed65fae9c1f7ad990939d07645246c92238" translate="yes" xml:space="preserve">
          <source>This is roughly the same as &lt;code&gt;trunc(x/y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3575fcfddeaf3d18e36c701dd650fc2ec44479fc" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt;. This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in python.</source>
          <target state="translated">이것은 &lt;code&gt;x - floorDiv(x, y) * y&lt;/code&gt; 합니다. 이 proc은 파이썬 에서 &lt;code&gt;%&lt;/code&gt; 연산자 와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1d93ee2a8f74ad1e5b652d12e6c5278be5cb25" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;splitPath(path).head&lt;/code&gt; when &lt;code&gt;path&lt;/code&gt; doesn't end in a dir separator, but also takes care of path normalizations. The remainder can be obtained with &lt;a href=&quot;#lastPathPart,string&quot;&gt;lastPathPart(path) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c992b9dfa7d27ecf9f025660223103e48bc1e8" translate="yes" xml:space="preserve">
          <source>This is synced from Nimble's version module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256bc61e58ad13a05d91f1a1bf2ae4f72005afe4" translate="yes" xml:space="preserve">
          <source>This is the concrete lookup algorithm that &lt;code&gt;&amp;amp;&lt;/code&gt; uses:</source>
          <target state="translated">이것은 &lt;code&gt;&amp;amp;&lt;/code&gt; 사용 하는 구체적인 조회 알고리즘입니다 .</target>
        </trans-unit>
        <trans-unit id="36c2f5442839943020ad05dd2166b1d0f12b01e5" translate="yes" xml:space="preserve">
          <source>This is the high-level version of the above &lt;code&gt;sendTo&lt;/code&gt; function.</source>
          <target state="translated">이것은 위의 &lt;code&gt;sendTo&lt;/code&gt; 의 상위 버전입니다. 함수 .</target>
        </trans-unit>
        <trans-unit id="97bde134c3168ba7edefb1ec35ba4786bc969108" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4020d4e844ba19f46420bb9db474d77805335e" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#+,IntSet,IntSet&quot;&gt;s + other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8710ddc5d8320cf19ea0e54c6b92bf35660f23f" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,HashSet%5BA%5D,HashSet%5BA%5D&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37cf86ebf53b471461d913dd3976253d3ba7da4" translate="yes" xml:space="preserve">
          <source>This is the in-place version of &lt;a href=&quot;#-,IntSet,IntSet&quot;&gt;s - other&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4826edc58b175eebfbf7081691448d2931000418" translate="yes" xml:space="preserve">
          <source>This is the jump function for the generator. It is equivalent to 2^64 calls to next(); it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="translated">이것은 발전기의 점프 기능입니다. next ()에 대한 2 ^ 64 호출과 같습니다. 병렬 계산을 위해 2 ^ 64 비 중첩 서브 시퀀스를 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2f0ff4e73777d01102bb217c8397c6cddd4b22" translate="yes" xml:space="preserve">
          <source>This is the main &lt;em&gt;project&lt;/em&gt; filename. Most of the time you will pass in the same as &lt;strong&gt;FILE&lt;/strong&gt;, but for bigger projects this is the file which is used as main entry point for the program, the one which users compile to generate a final binary.</source>
          <target state="translated">이것이 주요 &lt;em&gt;프로젝트&lt;/em&gt; 파일 이름입니다. 대부분의 경우 &lt;strong&gt;FILE&lt;/strong&gt; 과 동일하게 전달 하지만 더 큰 프로젝트의 경우 파일이 프로그램의 기본 진입 점으로 사용되는 파일이며, 사용자가 컴파일하여 최종 바이너리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60a0c5c21aaa578b306725a8da9b601c4bd7d709" translate="yes" xml:space="preserve">
          <source>This is the name of the module or include file the query refers to.</source>
          <target state="translated">조회가 참조하는 모듈 또는 포함 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c110d8ea0aa1384440227425443ae86a6ce178fd" translate="yes" xml:space="preserve">
          <source>This is the safecall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__safecall&lt;/code&gt; keyword. The word &lt;em&gt;safe&lt;/em&gt; refers to the fact that all hardware registers shall be pushed to the hardware stack.</source>
          <target state="translated">이것은 Microsoft에서 지정한 Safecall 규칙입니다. 생성 된 C 프로시 저는 &lt;code&gt;__safecall&lt;/code&gt; 키워드로 선언됩니다 . &lt;em&gt;안전한&lt;/em&gt; 단어&lt;em&gt;&lt;/em&gt; 는 모든 하드웨어 레지스터가 하드웨어 스택으로 푸시되어야한다는 사실을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="31f95bc8194c8e476931e06554d37b68be940444" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17370dc7ee3b0fe9dd442daf544baba9de37a9cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % [a]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;formatstr % [a]&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="70a3bf31e3a4defa18a1d9c74fc782d763f566f3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; (see &lt;a href=&quot;#%25,string,openArray%5Bstring%5D&quot;&gt;% proc&lt;/a&gt;) except that it supports auto stringification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ff4983f3a23d7cc3be988cf86d83e4cd1f019" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;formatstr % a&lt;/code&gt; except that it supports auto stringification.</source>
          <target state="translated">자동 문자열 화를 지원한다는 점을 제외하면 &lt;code&gt;formatstr % a&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="01a5b235024b77996dea512c125137d383106839" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="translated">이것은 &lt;code&gt;len(splitLines(s))&lt;/code&gt; 와 동일하지만 시간적 객체를 생성하는 문자열을 수정하지 않기 때문에 훨씬 더 효율적입니다. 모든 &lt;a href=&quot;manual#character-literals&quot;&gt;문자 리터럴&lt;/a&gt; 개행 조합 (CR, LF, CR-LF)이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8d22f203eebe945efff26b7c0264ae6e58250798" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;len(splitLines(s))&lt;/code&gt;, but much more efficient because it doesn't modify the string creating temporal objects. Every &lt;a href=&quot;manual#lexical-analysis-character-literals&quot;&gt;character literal&lt;/a&gt; newline combination (CR, LF, CR-LF) is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0badd9ad97e90a77853a8cbcdf1b0629e7129eff" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;name &amp;amp; ext&lt;/code&gt; from &lt;a href=&quot;#splitFile,string&quot;&gt;splitFile(path) proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d339aebbd92622e7b2312aac755921a2fe584d45" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x - (x div y) * y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1888a678959ca4ae304b888c79aa8550425de069" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x + {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae92e2d2df7af56345a63b06cbc0c4803a8fe53" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;x = x - {y}&lt;/code&gt;, but it might be more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a366ac081a365e2c46179906b192a6a0e436be" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;char&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2698b8a90aa68f611a0ef1370a3ab044cd78c8a1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;double&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32b6f8ca0c7194eb4b06ee5d7e525de947b0dfd5" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;float&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;float&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9d8dde930868443d859228ae0d07c7a292dfc2" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;int&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="89b75f0da7ac2537212723421db03228b32fdc6c" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long double&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. This C type is not supported by Nim's code generator.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;long double&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; . 이 C 유형은 Nim의 코드 생성기에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a37990dbd3eb06078ca83a8a56a6c3bd79234e4f" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;long long&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1069dac8f5d3d5aa1a18361c4ff3f9b241cbf315" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일한 &lt;code&gt;long&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6dc406a78e144191704d8486e22dc8fbe652f6" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;short&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c3756c51223d58c50aef0d5dbf74eeee747dd1" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;signed char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;signed char&lt;/code&gt; 에 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf874f74960f31038430fb144d0f39aa055b895" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이것은 타입과 동일 &lt;code&gt;size_t&lt;/code&gt; 로 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="df1c839c0f570919cf81eef346ac2a1dbb8ad2c9" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned char&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned char&lt;/code&gt; 의 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="32542074871fb6c497f5c1eb6606f80b3822a88a" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned int&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned int&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="36b8d34561a415968642b59c4b4b326317e48753" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;unsigned long long&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0aa9bfe67b304447b5a2bcc627f38a17da1684d8" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned long&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 유형과 동일 &lt;code&gt;unsigned long&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cca46f57d68aae82238b145830c6ebed78c459d0" translate="yes" xml:space="preserve">
          <source>This is the same as the type &lt;code&gt;unsigned short&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;.</source>
          <target state="translated">이 형태와 동일 &lt;code&gt;unsigned short&lt;/code&gt; 에서 &lt;em&gt;C&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7ec63cde9c899b1832f254d3a218fb0fdefa84a7" translate="yes" xml:space="preserve">
          <source>This is the same interface that is implemented for other databases.</source>
          <target state="translated">이것은 다른 데이터베이스에 대해 구현 된 것과 동일한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="e8c042bee5c7ca8787fc37bf633177ab6f1481ae" translate="yes" xml:space="preserve">
          <source>This is the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2276f3847dd82156bd01096eddf53801bbc1da1" translate="yes" xml:space="preserve">
          <source>This is thiscall calling convention as specified by Microsoft, used on C++ class member functions on the x86 architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d76cb52dda63a7debd58296187c89613b5d29c5" translate="yes" xml:space="preserve">
          <source>This is translated to a call to the &lt;code&gt;schema&lt;/code&gt; macro with a &lt;code&gt;nnkTypeDef&lt;/code&gt; AST node capturing both the left-hand side and right-hand side of the definition. The macro can return a potentially modified &lt;code&gt;nnkTypeDef&lt;/code&gt; tree which will replace the original row in the type section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b006c0a74e5f0b534a0cf75365ae7eaf0121b5e" translate="yes" xml:space="preserve">
          <source>This is translated to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39524a8c34f8678cfa0e73ee87c4662e966e0a89" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples &lt;a href=&quot;manual#macros-bindsym&quot;&gt;here&lt;/a&gt; and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193cec7a7162a70eca01c095ac18043a02af9656" translate="yes" xml:space="preserve">
          <source>This is used, for example, in the &lt;code&gt;bindSym&lt;/code&gt; examples [here](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt;) and with &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; in the regular expression module.</source>
          <target state="translated">이것은 예를 들어 &lt;code&gt;bindSym&lt;/code&gt; 예제 [여기] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#macros-bindsym&quot;&gt;http://nim-lang.org/docs/manual.html#macros-bindsym&lt;/a&gt; )와 &lt;code&gt;re&quot;some regexp&quot;&lt;/code&gt; 정규 표현식 모듈에서 됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3384cc6ee2a6305631e3401a802d6acf72b3b1" translate="yes" xml:space="preserve">
          <source>This is useful for writing generic algorithms without performance loss. This generic implementation uses the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c869caa2cb0e2a4566d33db6c594392aa3e88fd" translate="yes" xml:space="preserve">
          <source>This is useful if you want to copy or save files across Windows, Linux, Mac, etc. You can pass full paths as argument too, but func only checks filenames. It uses &lt;code&gt;invalidFilenameChars&lt;/code&gt;, &lt;code&gt;invalidFilenames&lt;/code&gt; and &lt;code&gt;maxLen&lt;/code&gt; to verify the specified &lt;code&gt;filename&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54a83cbed83c0f42bf0a73af1d5e007c04a1c74" translate="yes" xml:space="preserve">
          <source>This is useful when one overloaded &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; but still needs reference semantics for sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814be46e563ada83f9262b5e8d3fa69226b5320b" translate="yes" xml:space="preserve">
          <source>This is very fast, but potentially dangerous. Use this iterator only if you require &lt;strong&gt;ALL&lt;/strong&gt; the rows.</source>
          <target state="translated">이것은 매우 빠르지 만 잠재적으로 위험합니다. &lt;strong&gt;모든&lt;/strong&gt; 행 이 필요한 경우에만이 반복자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="134eddc978c41c43c45ed9c6b1ceb47614d9e60b" translate="yes" xml:space="preserve">
          <source>This isn't the same as &lt;code&gt;size_t&lt;/code&gt; in &lt;em&gt;C&lt;/em&gt;. Don't use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0fbed086855b31d79192247a84655610b15079" translate="yes" xml:space="preserve">
          <source>This library relies on the header files of your C compiler. The resulting C code will just &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; define the symbols declared here.</source>
          <target state="translated">이 라이브러리는 C 컴파일러의 헤더 파일을 사용합니다. 결과 C 코드는 &lt;code&gt;#include &amp;lt;XYZ.h&amp;gt;&lt;/code&gt; 이며 여기에 선언 된 기호는 정의 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="31048b78d2181ce88fb6bfd891a52408cadc9fbf" translate="yes" xml:space="preserve">
          <source>This macro also allows for (otherwise in-place) function chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bd537d709836e793cec8da49a638fdf122f928" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352e8583e6de97b799c5da9ed3e4a4e5b04d179b" translate="yes" xml:space="preserve">
          <source>This makes it easy to delete all generated files. Files generated in this directory follow a naming logic which you can read about in the &lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 생성 된 모든 파일을 쉽게 삭제할 수 있습니다. 이 디렉토리에서 생성 된 파일은 다음에서 읽을 수있는 명명 논리를 따릅니다.&lt;a href=&quot;backends#nimcache-naming-logic&quot;&gt; Nim 백엔드 통합 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e986bf4a76bcf2a2515dce45f1d6c7ca80702bc0" translate="yes" xml:space="preserve">
          <source>This means that &quot;borrowed&quot; views can be written naturally and without explicit pointer indirections:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e5b1294716a2171951a03c64eda20f357eb30a" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;%xx&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over. If &lt;code&gt;xx&lt;/code&gt; is not a valid hexadecimal value, it is left intact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052067fc6ee68fa2f9dbd0b6a372e7c4df39a2b8" translate="yes" xml:space="preserve">
          <source>This means that any &lt;code&gt;'%xx'&lt;/code&gt; (where &lt;code&gt;xx&lt;/code&gt; denotes a hexadecimal value) are converted to the character with ordinal number &lt;code&gt;xx&lt;/code&gt;, and every other character is carried over.</source>
          <target state="translated">이것은 모든 &lt;code&gt;'%xx'&lt;/code&gt; (여기서 &lt;code&gt;xx&lt;/code&gt; 는 16 진수 값을 나타냄)가 서수를 가진 문자로 변환 됨을 의미합니다. &lt;code&gt;xx&lt;/code&gt; 다른 모든 문자가 이어짐을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20eaeefb7ad0f37cbcfe130963c8445b739d8936" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119e88cdea67075391ab49a84997ba0f8df61b5" translate="yes" xml:space="preserve">
          <source>This means that characters in the set &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; are carried over to the result. All other characters are encoded as &lt;code&gt;''%xx'&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; denotes its hexadecimal value.</source>
          <target state="translated">이는 세트 &lt;code&gt;{'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~'}&lt;/code&gt; 문자를 의미합니다 . } 결과에 전달됩니다. 다른 모든 문자는 &lt;code&gt;''%xx'&lt;/code&gt; 로 인코딩되며 , 여기서 &lt;code&gt;xx&lt;/code&gt; 는 16 진수 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40b048bf83553881e511d74bd63cac489f70ae5d" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URI's path as well as reference URI's path affect the resulting URI.</source>
          <target state="translated">이는 참조 URI 경로뿐만 아니라 기본 URI 경로 내부의 슬래시가 결과 URI에 영향을 미침을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="922850b50b784f0baf0fafd0fe540e7582cac936" translate="yes" xml:space="preserve">
          <source>This means that the slashes inside the base URIs path as well as reference URIs path affect the resulting URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d681cd1b517c30b7e61efd9d0f2710e753e51a4c" translate="yes" xml:space="preserve">
          <source>This means that when for some reason a procedure needs a disambiguation through the module name, the call needs to be written in function call syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef6d8c1596a849e1d58fe82a1e6a88d8d08fefb" translate="yes" xml:space="preserve">
          <source>This means the following compiles (for now) even though it really should not:</source>
          <target state="translated">이것은 다음과 같이 컴파일되지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="10445172840b8572e10f6fbc77991aa94729820e" translate="yes" xml:space="preserve">
          <source>This mechanism will be used by most data structures that support shared memory like channels to implement thread safe automatic memory management.</source>
          <target state="translated">이 메커니즘은 스레드 안전 자동 메모리 관리를 구현하기 위해 채널과 같은 공유 메모리를 지원하는 대부분의 데이터 구조에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5cce8e43b46c329ab2a3787ae9c0cae31bce9579" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used for any type:</source>
          <target state="translated">이 메소드 호출 구문은 객체로 제한되지 않으며 모든 유형에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18ebc20a57311d93348b03173ca9377d2b87fe3" translate="yes" xml:space="preserve">
          <source>This method call syntax is not restricted to objects, it can be used to supply any type of first argument for procedures:</source>
          <target state="translated">이 메소드 호출 구문은 객체로 제한되지 않으며 프로 시저에 대한 모든 유형의 첫 번째 인수를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ec21e93e0cf3038676cfddb7994789208b8b989" translate="yes" xml:space="preserve">
          <source>This method ignores the list of registered handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86fc0ee3a63db9a4d667e5e9867b56be701b07c" translate="yes" xml:space="preserve">
          <source>This method is not available for the JavaScript backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f76b4fe4da8b8424258ff632b4b8aba97934a0" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;s&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f6408118ba81283de7ac109aa7b480ef6c069c" translate="yes" xml:space="preserve">
          <source>This modifies &lt;code&gt;x&lt;/code&gt; itself, it does not return a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a743fd1b7ce29c9eafd7535f1bcb06655400ac" translate="yes" xml:space="preserve">
          <source>This modifies &lt;em&gt;s&lt;/em&gt; itself, it does not return a copy.</source>
          <target state="translated">이 수정 &lt;em&gt;의&lt;/em&gt; 자체, 그것은 사본을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="399957ae50c4d50ec5409505af7d5ec3350ca32a" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTable%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2c1b5b7b769344ec6ebabe55a749624b20d2f0" translate="yes" xml:space="preserve">
          <source>This modifies the internal list that kept the insertion order, so insertion order is lost after this call but key lookup and insertions remain possible after &lt;code&gt;sort&lt;/code&gt; (in contrast to the &lt;a href=&quot;#sort,CountTableRef%5BA%5D&quot;&gt;sort proc&lt;/a&gt; for count tables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5bab7c7f53e383fb7fd313b6d6578109127b68" translate="yes" xml:space="preserve">
          <source>This module &lt;strong&gt;partially&lt;/strong&gt; implements an FTP client as specified by &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959&lt;/a&gt;.</source>
          <target state="translated">이 모듈 은 &lt;a href=&quot;http://tools.ietf.org/html/rfc959&quot;&gt;RFC 959에서&lt;/a&gt; 지정한 FTP 클라이언트를 &lt;strong&gt;부분적으로&lt;/strong&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="353b9d1b799c5ad1bd4a492759bb6ea40d16c6be" translate="yes" xml:space="preserve">
          <source>This module allows high-level and efficient I/O multiplexing.</source>
          <target state="translated">이 모듈은 높은 수준의 효율적인 I / O 멀티플렉싱을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="77582b104bbd815cba00372c32475601c25cf527" translate="yes" xml:space="preserve">
          <source>This module allows you to access fields in a parsed JSON object in two different ways, one of them is described in this section.</source>
          <target state="translated">이 모듈을 사용하면 구문 분석 된 JSON 객체의 필드에 두 가지 다른 방식으로 액세스 할 수 있습니다.이 중 하나가이 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3498eb6ea3bb3348c1e6a56f205dc1cc756e769" translate="yes" xml:space="preserve">
          <source>This module also implements a &lt;code&gt;scanp&lt;/code&gt; macro, which syntax somewhat resembles an EBNF or PEG grammar, except that it uses Nim's expression syntax and so has to use prefix instead of postfix operators.</source>
          <target state="translated">이 모듈은 또한 &lt;code&gt;scanp&lt;/code&gt; 매크로를 구현하는데 ,이 구문은 Nim의 표현식 구문을 사용하므로 접미사 연산자 대신 접두사를 사용해야한다는 점을 제외하고는 EBNF 또는 PEG 문법과 다소 유사합니다.</target>
        </trans-unit>
        <trans-unit id="ef44ae92a94357463ee874a1523c9d291e715eef" translate="yes" xml:space="preserve">
          <source>This module also implements the protocol used to format messages, as specified by RFC 2822.</source>
          <target state="translated">이 모듈은 또한 RFC 2822에 지정된 메시지를 형식화하는 데 사용되는 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e13b1625e61f884e29573a44e8b33b49a44a5992" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procedures, iterators and templates for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdfcb3c036a119b924e511faf70eaedadc90ee4" translate="yes" xml:space="preserve">
          <source>This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47e628756db21f739b926daba1d8817fcf31162" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;code&gt;%*&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5d643a068677170a94b694f4f1ab9c3fa2652e" translate="yes" xml:space="preserve">
          <source>This module can also be used to comfortably create JSON using the &lt;em&gt;%*&lt;/em&gt; operator:</source>
          <target state="translated">이 모듈을 사용하여 &lt;em&gt;% *&lt;/em&gt; 연산자를 사용하여 JSON을 편안하게 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ac6344a11b0cec8bee2e186a1f2d87c14205cf3" translate="yes" xml:space="preserve">
          <source>This module contains 'typeAllowed' and friends which check for invalid types like 'openArray[var int]'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e7d195d331b7d6c15e12922caec76c1b942621" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for locks and condition vars.</source>
          <target state="translated">이 모듈에는 잠금 및 조건 변수에 대한 Nim의 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="762c0c406df7455c202f1f73c29bbcaf2e671b58" translate="yes" xml:space="preserve">
          <source>This module contains Nim's support for reentrant locks.</source>
          <target state="translated">이 모듈에는 Nim의 재진입 잠금 지원이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e2b2a3ac1f926c532ebca53a22c529f45f34b9" translate="yes" xml:space="preserve">
          <source>This module contains SSL configuration parameters obtained from &lt;a href=&quot;https://wiki.mozilla.org/Security/Server_Side_TLS&quot;&gt;Mozilla OpSec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ca976fb8b35eb3df922d2b5066e9569252023d" translate="yes" xml:space="preserve">
          <source>This module contains a &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; macro that can be used for extracting substrings from an input string. This is often easier than regular expressions. Some examples as an appetizer:</source>
          <target state="translated">이 모듈에는 입력 문자열에서 하위 문자열을 추출하는 데 사용할 수 있는 &lt;span id=&quot;scanf_1&quot;&gt;scanf&lt;/span&gt; 매크로가 포함되어 있습니다 . 이것은 보통 정규식보다 쉽습니다. 전채로서의 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="1489dea58f0e2e175da913a82f51d717b857c72e" translate="yes" xml:space="preserve">
          <source>This module contains a few procedures to control the &lt;em&gt;terminal&lt;/em&gt; (also called &lt;em&gt;console&lt;/em&gt;). On UNIX, the implementation simply uses ANSI escape sequences and does not depend on any other module, on Windows it uses the Windows API. Changing the style is permanent even after program termination! Use the code &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; to restore the defaults. Similarly, if you hide the cursor, make sure to unhide it with &lt;code&gt;showCursor&lt;/code&gt; before quitting.</source>
          <target state="translated">이 모듈에는 &lt;em&gt;터미널&lt;/em&gt; ( &lt;em&gt;콘솔&lt;/em&gt; 이라고도 함 ) 을 제어하기위한 몇 가지 절차가 포함되어 있습니다 . UNIX에서 구현은 단순히 ANSI 이스케이프 시퀀스를 사용하며 다른 모듈에 의존하지 않으며 Windows에서는 Windows API를 사용합니다. 프로그램 종료 후에도 스타일 변경은 영구적입니다! 코드 &lt;code&gt;system.addQuitProc(resetAttributes)&lt;/code&gt; 를 사용하여 기본값을 복원하십시오. 마찬가지로 커서를 숨기면 종료하기 전에 &lt;code&gt;showCursor&lt;/code&gt; 를 사용하여 커서를 숨기십시오 .</target>
        </trans-unit>
        <trans-unit id="7e93f8f54a9484fe22dcb778e11ee50ae595038e" translate="yes" xml:space="preserve">
          <source>This module contains a simple persistent id generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859cd9a84610a4573796c23e8584dde691268fe4" translate="yes" xml:space="preserve">
          <source>This module contains an algorithm to wordwrap a Unicode string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f440cc00bf2a40f36bf90840926be53d2b4581f" translate="yes" xml:space="preserve">
          <source>This module contains basic operating system facilities like retrieving environment variables, reading command line arguments, working with directories, running shell commands, etc.</source>
          <target state="translated">이 모듈에는 환경 변수 검색, 명령 행 인수 읽기, 디렉토리 작업, 쉘 명령 실행 등과 같은 기본 운영 체제 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aebeafbfc315baffdf1e6869390c403d1c5a4946" translate="yes" xml:space="preserve">
          <source>This module contains code for generating volatile loads and stores, which are useful in embedded and systems programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8484eb3bf4310e5df9a41c735476490885f266c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, identifiers, etc.</source>
          <target state="translated">이 모듈에는 토큰, 숫자, 식별자 등을 구문 분석하기위한 헬퍼가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e5ce3fb2f04f76809ea7a033742e832b442a1c" translate="yes" xml:space="preserve">
          <source>This module contains helpers for parsing tokens, numbers, integers, floats, identifiers, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86de046f7b616971dd6062d8ab76fb2ee06ec285" translate="yes" xml:space="preserve">
          <source>This module contains helpers that deal with different byte orders (&lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt;).</source>
          <target state="translated">이 모듈에는 다른 바이트 순서 ( &lt;span id=&quot;endian_1&quot;&gt;endian&lt;/span&gt; ) 를 처리하는 헬퍼가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3507a070fad07c9f9b3947b600282a6e5783a4cf" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deseralization_1&quot;&gt;deseralization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;. Warning: The serialization format could change in future!</source>
          <target state="translated">이 모듈에는 임의의 Nim 데이터 구조의 &lt;span id=&quot;serialization_1&quot;&gt;직렬화&lt;/span&gt; 및 &lt;span id=&quot;deseralization_1&quot;&gt;역 &lt;/span&gt;&lt;span id=&quot;serialization_1&quot;&gt;직렬화를&lt;/span&gt; 위한 &lt;span id=&quot;deseralization_1&quot;&gt;프로세스&lt;/span&gt; 가 포함되어 있습니다 . 직렬화 형식은 &lt;span id=&quot;json_1&quot;&gt;JSON을&lt;/span&gt; 사용합니다 . 경고 : 직렬화 형식은 나중에 변경 될 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="5f95162e9e6ccb749f85b72f9199f205223155d1" translate="yes" xml:space="preserve">
          <source>This module contains procs for &lt;span id=&quot;serialization_1&quot;&gt;serialization&lt;/span&gt; and &lt;span id=&quot;deserialization_1&quot;&gt;deserialization&lt;/span&gt; of arbitrary Nim data structures. The serialization format uses &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371318c1a0161f22d8f2e0f2e50fa5c06ee82a39" translate="yes" xml:space="preserve">
          <source>This module contains routines and types for dealing with time using a proleptic Gregorian calendar. It's also available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 그레고리력 달력을 사용하여 시간을 처리하기위한 루틴과 유형이 포함되어 있습니다. &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 대상&lt;/a&gt; 에도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="681edb1a4152d4c5c1a28a26efed7538442ba878" translate="yes" xml:space="preserve">
          <source>This module contains support for a &lt;span id=&quot;rope_1&quot;&gt;rope&lt;/span&gt; data type. Ropes can represent very long strings efficiently; especially concatenation is done in O(1) instead of O(n). They are essentially concatenation trees that are only flattened when converting to a native Nim string. The empty string is represented by &lt;code&gt;nil&lt;/code&gt;. Ropes are immutable and subtrees can be shared without copying. Leaves can be cached for better memory efficiency at the cost of runtime efficiency.</source>
          <target state="translated">이 모듈에는 &lt;span id=&quot;rope_1&quot;&gt;로프&lt;/span&gt; 데이터 유형 이 지원됩니다 . 로프는 매우 긴 줄을 효율적으로 표현할 수 있습니다. 특히 연결은 O (n) 대신 O (1)에서 수행됩니다. 그것들은 기본적으로 네이티브 Nim 문자열로 변환 할 때만 평평하게되는 연결 트리입니다. 빈 문자열은 &lt;code&gt;nil&lt;/code&gt; 로 표시됩니다 . 로프는 변경할 수 없으며 하위 트리는 복사하지 않고 공유 할 수 있습니다. 런타임 효율성을 유지하면서 메모리 효율성을 높이기 위해 잎을 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b376b4ebaaab23249fc9320639fee9fdc18842d7" translate="yes" xml:space="preserve">
          <source>This module contains the &lt;code&gt;TMsgKind&lt;/code&gt; enum as well as the &lt;code&gt;TLineInfo&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8814cd36c6aae34db1d0386489c78e9dbe808ff" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the C code generation phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b114c265f10b8a271d8de9414b2aacb4dde589" translate="yes" xml:space="preserve">
          <source>This module contains the data structures for the semantic checking phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a18d40233e79f25223ec93664005a48f943242" translate="yes" xml:space="preserve">
          <source>This module contains the interface to the compiler's abstract syntax tree (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Macros operate on this tree.</source>
          <target state="translated">이 모듈에는 컴파일러의 추상 구문 트리 ( &lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt; )에 대한 인터페이스가 포함되어 있습니다 . 매크로는이 트리에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="94973e879d7e0d952c022e954deb2fbb3c8e206b" translate="yes" xml:space="preserve">
          <source>This module contains the type definitions for the new evaluation engine. An instruction is 1-3 int32s in memory, it is a register based VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a11c4dcef359935de61e37ffe6d34cb9d89068f" translate="yes" xml:space="preserve">
          <source>This module contains various string matchers for email addresses, etc.</source>
          <target state="translated">이 모듈은 이메일 주소 등에 대한 다양한 문자열 매처를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dc6f5f3c4d5eabca058f0bb06a0585786c4d3b49" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines that are uncommonly used in comparison to &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;strutils&quot;&gt;strutils&lt;/a&gt; 와 비교하여 드물게 사용되는 다양한 문자열 유틸리티 루틴이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d2fcdeecb346421f24a622468611b1e35012c38" translate="yes" xml:space="preserve">
          <source>This module contains various string utility routines. See the module &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; for regular expression support. See the module &lt;a href=&quot;pegs&quot;&gt;pegs&lt;/a&gt; for PEG support. This module is available for the &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 다양한 문자열 유틸리티 루틴이 포함되어 있습니다. 정규식 지원에 대해서는 모듈 &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; 를 참조하십시오 . PEG 지원에 대해서는 모듈 &lt;a href=&quot;pegs&quot;&gt;페그&lt;/a&gt; 를 참조하십시오 . 이 모듈은 &lt;a href=&quot;backends#the-javascript-target&quot;&gt;JavaScript 대상에&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47c439c96c86563186d79ec7720605588cc9ed86" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types</source>
          <target state="translated">이 모듈은 유형 작업을위한 컴파일 타임 반영 프로세스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="60144eff5e3a9e63fbb73c5a6a2dab67f8c5d761" translate="yes" xml:space="preserve">
          <source>This module defines compile-time reflection procs for working with types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c756bd0d905b898b07e1bbf5dac867ce5994db8" translate="yes" xml:space="preserve">
          <source>This module does not implement any ORM features such as mapping the types from the schema. Instead, a &lt;code&gt;seq[string]&lt;/code&gt; is returned for each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de4eb1c72ff111a775ba8d7bcc00cdb24085f9e" translate="yes" xml:space="preserve">
          <source>This module implements URI parsing as specified by RFC 3986.</source>
          <target state="translated">이 모듈은 RFC 3986에 지정된대로 URI 구문 분석을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27f7329a9231fa9eb3dabedee0d7ec09c071c36c" translate="yes" xml:space="preserve">
          <source>This module implements XML DOM Level 2 Core specification (&lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt;)</source>
          <target state="translated">이 모듈은 XML DOM Level 2 Core 사양을 구현합니다 ( &lt;a href=&quot;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&quot;&gt;http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1270c3451976ca2c6dbe064b63a8c754c870a12f" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; which is an efficient container for a sorted set of strings, or for a sorted mapping of strings. Based on the excellent paper by Adam Langley. (A crit bit tree is a form of &lt;span id=&quot;radix-tree_1&quot;&gt;radix tree&lt;/span&gt; or &lt;span id=&quot;patricia-trie_1&quot;&gt;patricia trie&lt;/span&gt;.)</source>
          <target state="translated">이 모듈 은 정렬 된 문자열 세트 또는 정렬 된 문자열 매핑을위한 효율적인 컨테이너 인 &lt;span id=&quot;crit-bit-tree_1&quot;&gt;crit bit tree&lt;/span&gt; 를 구현합니다 . Adam Langley의 우수한 논문을 기반으로합니다. 크리트 비트 트리는 &lt;span id=&quot;radix-tree_1&quot;&gt;기수&lt;/span&gt; 또는 &lt;span id=&quot;patricia-trie_1&quot;&gt;패트리샤 &lt;/span&gt;&lt;span id=&quot;radix-tree_1&quot;&gt;트리&lt;/span&gt; 의 한 형태입니다 .</target>
        </trans-unit>
        <trans-unit id="d33fc50e3ca1debee0d3e81969fe922a6c7f125b" translate="yes" xml:space="preserve">
          <source>This module implements a &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser. A large subset is implemented. Some features of the &lt;span id=&quot;markdown_1&quot;&gt;markdown&lt;/span&gt; wiki syntax are also supported.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 파서를 구현합니다 . 큰 하위 집합이 구현되었습니다. &lt;span id=&quot;markdown_1&quot;&gt;마크 다운&lt;/span&gt; 위키 구문 의 일부 기능 도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6977f3d46bd112fbaa438f57a03c83e720c94436" translate="yes" xml:space="preserve">
          <source>This module implements a base object of a lexer with efficient buffer handling. Only at line endings checks are necessary if the buffer needs refilling.</source>
          <target state="translated">이 모듈은 효율적인 버퍼 처리로 렉서의 기본 객체를 구현합니다. 버퍼를 다시 채워야하는 경우 줄 끝 점검 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df7211c34a2ecd3f4fc0d583c3ad6e78e895ee92" translate="yes" xml:space="preserve">
          <source>This module implements a base64 encoder and decoder.</source>
          <target state="translated">이 모듈은 base64 인코더 및 디코더를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6081002e18d54466e7c5566ce284e757eba696e6" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;docgen&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 에서 HTML / 라텍스 생성기를 구현하고 ( 이 마크 업 구문에 대한 정보는 &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; 참조 ) 컴파일러의 &lt;a href=&quot;docgen&quot;&gt;docgen 도구에서 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="17f9d509be6ad16b77fcf94001ab38bee17334b5" translate="yes" xml:space="preserve">
          <source>This module implements a generator of HTML/Latex from &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; (see &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;http://docutils.sourceforge.net/rst.html&lt;/a&gt; for information on this markup syntax) and is used by the compiler's &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;docgen tools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e24ad7c182e7005c7758742478f3329d0f6132c" translate="yes" xml:space="preserve">
          <source>This module implements a helper for a thread pool to determine whether creating a thread is a good idea.</source>
          <target state="translated">이 모듈은 스레드 풀의 헬퍼를 구현하여 스레드 작성이 좋은지 여부를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="454ce041e8ff19cc3f47caab96d62276cdca14fe" translate="yes" xml:space="preserve">
          <source>This module implements a high performance asynchronous HTTP server.</source>
          <target state="translated">이 모듈은 고성능 비동기 HTTP 서버를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="55bdd10c5a5f89322ba8a15e1873d103379babdc" translate="yes" xml:space="preserve">
          <source>This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 &lt;code&gt;asyncdispatch&lt;/code&gt; 모듈에 정의 된 비동기 디스패처를 기반으로 상위 레벨 비동기 소켓 API를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="141c50103e76c15b79b0d58835babe4f607c974d" translate="yes" xml:space="preserve">
          <source>This module implements a high-level cross-platform sockets interface. The procedures implemented in this module are primarily for blocking sockets. For asynchronous non-blocking sockets use the &lt;code&gt;asyncnet&lt;/code&gt; module together with the &lt;code&gt;asyncdispatch&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 고급 크로스 플랫폼 소켓 인터페이스를 구현합니다. 이 모듈에서 구현 된 절차는 주로 소켓을 차단하기위한 것입니다. 비동기 비 블로킹 소켓을 위해 사용 &lt;code&gt;asyncnet&lt;/code&gt; 의 와 모듈 함께를 &lt;code&gt;asyncdispatch&lt;/code&gt; 의 모듈.</target>
        </trans-unit>
        <trans-unit id="db9ba48b68fd354aaa5fc20475e579aac2d2654d" translate="yes" xml:space="preserve">
          <source>This module implements a json parser. It is used and exported by the &lt;code&gt;json&lt;/code&gt; standard library module, but can also be used in its own right.</source>
          <target state="translated">이 모듈은 json 파서를 구현합니다. &lt;code&gt;json&lt;/code&gt; 표준 라이브러리 모듈에서 사용하고 내보내 지만 자체적으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1fdd4da540e62b9188383b60a46eeb260182e77" translate="yes" xml:space="preserve">
          <source>This module implements a low-level cross-platform sockets interface. Look at the &lt;code&gt;net&lt;/code&gt; module for the higher-level version.</source>
          <target state="translated">이 모듈은 저수준 크로스 플랫폼 소켓 인터페이스를 구현합니다. 더 높은 수준의 버전을 보려면 &lt;code&gt;net&lt;/code&gt; 모듈을 보십시오 .</target>
        </trans-unit>
        <trans-unit id="ffb0db7a5f8cb3e13d15cfbadb31dc0a731e0b20" translate="yes" xml:space="preserve">
          <source>This module implements a mimetypes database</source>
          <target state="translated">이 모듈은 mimetypes 데이터베이스를 구현합니다</target>
        </trans-unit>
        <trans-unit id="52c7b497a1d812a7103e93d248b7ce30058bcc07" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369970703d77f45ce74f0890d99dc3ad540cefb1" translate="yes" xml:space="preserve">
          <source>This module implements a series of low level methods for bit manipulation. By default, this module use compiler intrinsics to improve performance on supported compilers: &lt;code&gt;GCC&lt;/code&gt;, &lt;code&gt;LLVM_GCC&lt;/code&gt;, &lt;code&gt;CLANG&lt;/code&gt;, &lt;code&gt;VCC&lt;/code&gt;, &lt;code&gt;ICC&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 비트 조작을위한 일련의 저수준 방법을 구현합니다. 기본적으로이 모듈은 컴파일러 내장 함수를 사용하여 지원되는 컴파일러 ( &lt;code&gt;GCC&lt;/code&gt; , &lt;code&gt;LLVM_GCC&lt;/code&gt; , &lt;code&gt;CLANG&lt;/code&gt; , &lt;code&gt;VCC&lt;/code&gt; , &lt;code&gt;ICC&lt;/code&gt; )에서 성능을 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6a72068a61f0ac219b08c124ba6a885d3d706a6f" translate="yes" xml:space="preserve">
          <source>This module implements a simple &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; and &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; code generator. Each commonly used HTML tag has a corresponding macro that generates a string with its HTML representation.</source>
          <target state="translated">이 모듈은 간단한 &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; 및 &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; 코드 생성기를 구현합니다 . 일반적으로 사용되는 각 HTML 태그에는 해당 HTML 표현으로 문자열을 생성하는 해당 매크로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85bfb7ff9d532c8dadfbbeaebbf969dd68bafa42" translate="yes" xml:space="preserve">
          <source>This module implements a simple HTTP client that can be used to retrieve webpages and other data.</source>
          <target state="translated">이 모듈은 웹 페이지 및 기타 데이터를 검색하는 데 사용할 수있는 간단한 HTTP 클라이언트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="042f483a9df711dab36503622086bf978deae7dc" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; (&lt;span id=&quot;comma-separated-value_1&quot;&gt;comma separated value&lt;/span&gt;) parser.</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;csv_1&quot;&gt;CSV&lt;/span&gt; ( &lt;span id=&quot;comma-separated-value_1&quot;&gt;쉼표로 구분 된 값&lt;/span&gt; ) 파서를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="79501d3f5ff57c410bf937ebfdaefd4be7b9f7d2" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; parser. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write (unlike XML). It is easy for machines to parse and generate. JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999.</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;json_1&quot;&gt;JSON&lt;/span&gt; 파서를 구현합니다 . JSON (JavaScript Object Notation)은 XML과 달리 사람이 읽고 쓸 수있는 간단한 데이터 교환 형식입니다. 기계가 구문 분석하고 생성하기 쉽습니다. JSON은 JavaScript 프로그래밍 언어, 표준 ECMA-262 3 판-1999 년 12 월의 일부를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="06a978a90f444ab2e371ab0e33c92d28de7bff58" translate="yes" xml:space="preserve">
          <source>This module implements a simple high performance &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; parser. The only encoding that is supported is UTF-8. The parser has been designed to be somewhat error correcting, so that even most &quot;wild HTML&quot; found on the web can be parsed with it. &lt;strong&gt;Note:&lt;/strong&gt; This parser does not check that each &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; has a corresponding &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt;! These checks have do be implemented by the client code for various reasons:</source>
          <target state="translated">이 모듈은 간단한 고성능 &lt;span id=&quot;xml_1&quot;&gt;XML&lt;/span&gt; / &lt;span id=&quot;html_1&quot;&gt;HTML&lt;/span&gt; 파서를 구현합니다 . 지원되는 유일한 인코딩은 UTF-8입니다. 파서는 웹에서 발견 된 대부분의 &quot;와일드 HTML&quot;도 파싱 할 수 있도록 다소 오류를 수정하도록 설계되었습니다. &lt;strong&gt;참고 :&lt;/strong&gt; 이 파서는 각 &lt;code&gt;&amp;lt;tag&amp;gt;&lt;/code&gt; 에 해당 &lt;code&gt;&amp;lt;/tag&amp;gt;&lt;/code&gt; 이 있는지 확인하지 않습니다 ! 이러한 검사는 여러 가지 이유로 클라이언트 코드에 의해 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="a0c65178c960a4c67a65aebfc6e35293749e48ed" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48947ec421a5467d0d646e322ab81e8c9a02a691" translate="yes" xml:space="preserve">
          <source>This module implements a simple logger. It has been designed to be as simple as possible to avoid bloat, if this library does not fulfill your needs, write your own.</source>
          <target state="translated">이 모듈은 간단한 로거를 구현합니다. 이 라이브러리가 당신의 요구를 충족시키지 못하면, 자신의 글을 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="3dadb028527d802791d6f87341aff532946953c1" translate="yes" xml:space="preserve">
          <source>This module implements a simple proc for opening URLs with the user's default browser.</source>
          <target state="translated">이 모듈은 사용자의 기본 브라우저로 URL을 여는 간단한 절차를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7fb049b95846bb771385f79aa14ac44a91216509" translate="yes" xml:space="preserve">
          <source>This module implements a small wrapper for some needed Win API procedures, so that the Nim compiler does not depend on the huge Windows module.</source>
          <target state="translated">이 모듈은 필요한 Win API 프로 시저에 대해 작은 래퍼를 구현하므로 Nim 컴파일러는 거대한 Windows 모듈에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ac84b13286763d5a846ef3e91168372a188a0b8" translate="yes" xml:space="preserve">
          <source>This module implements an AST for the &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; parser.</source>
          <target state="translated">이 모듈은 &lt;span id=&quot;restructuredtext_1&quot;&gt;reStructuredText&lt;/span&gt; 파서에 대한 AST를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="be080849cfa6c4b49c9b095ad65b6fcaae6e195d" translate="yes" xml:space="preserve">
          <source>This module implements an advanced facility for executing OS processes and process communication.</source>
          <target state="translated">이 모듈은 OS 프로세스 및 프로세스 통신을 실행하기위한 고급 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0ecce61f14e63c77639e9bbde5141d17de0e240e" translate="yes" xml:space="preserve">
          <source>This module implements an algorithm to compute the &lt;span id=&quot;edit-distance_1&quot;&gt;edit distance&lt;/span&gt; between two Unicode strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4019f34ee73cf2afc6617ad82d4cc99b8a1651c5" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous FTP client. It allows you to connect to an FTP server and perform operations on it such as for example:</source>
          <target state="translated">이 모듈은 비동기 FTP 클라이언트를 구현합니다. FTP 서버에 연결하여 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13879d8d10926994138f177a507809351445a9d4" translate="yes" xml:space="preserve">
          <source>This module implements an asynchronous event loop together with asynchronous sockets which use this event loop. It is akin to Python's asyncore module. Many modules that use sockets have an implementation for this module, those modules should all have a &lt;code&gt;register&lt;/code&gt; function which you should use to add the desired objects to a dispatcher which you created so that you can receive the events associated with that module's object.</source>
          <target state="translated">이 모듈은이 이벤트 루프를 사용하는 비동기 소켓과 함께 비동기 이벤트 루프를 구현합니다. 그것은 파이썬의 asyncore 모듈과 유사합니다. 소켓을 사용하는 많은 모듈에는이 모듈에 대한 구현이 있으며, 해당 모듈에는 모두 &lt;code&gt;register&lt;/code&gt; 기능이 있어야 사용자가 작성한 디스패처에 원하는 오브젝트를 추가하여 해당 모듈의 오브젝트와 연관된 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631695dd25ee11fd41bde8946a743e509c7a762f" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). Note that even though &lt;code&gt;Any&lt;/code&gt; and its operations hide the nasty low level details from its clients, it remains inherently unsafe!</source>
          <target state="translated">이 모듈은 Nim의 &lt;span id=&quot;runtime-type-information_1&quot;&gt;런타임 유형 정보&lt;/span&gt; ( &lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt; )에 대한 인터페이스를 구현합니다 . &lt;code&gt;Any&lt;/code&gt; 및 해당 작업이 클라이언트에서 불쾌한 낮은 수준의 세부 정보를 숨기 더라도 본질적으로 안전하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="a745aa0375a74f7df55bc17c9183f618e2e8312e" translate="yes" xml:space="preserve">
          <source>This module implements an interface to Nim's &lt;span id=&quot;runtime-type-information_1&quot;&gt;runtime type information&lt;/span&gt; (&lt;span id=&quot;rtti_1&quot;&gt;RTTI&lt;/span&gt;). See the &lt;a href=&quot;marshal&quot;&gt;marshal&lt;/a&gt; module for an example of what this module allows you to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743043f366d434da8a30113b7bbb02a151e1774b" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous IO. This includes a dispatcher, a &lt;code&gt;Future&lt;/code&gt; type implementation, and an &lt;code&gt;async&lt;/code&gt; macro which allows asynchronous code to be written in a synchronous style with the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">이 모듈은 비동기 IO를 구현합니다. 여기에는 디스패처, &lt;code&gt;Future&lt;/code&gt; 유형 구현 및 &lt;code&gt;await&lt;/code&gt; 키워드 를 사용하여 비동기 코드를 동기식 스타일로 작성할 수 있는 &lt;code&gt;async&lt;/code&gt; 매크로가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff0fc0b254406eef01f02b40f3655696591bd82c" translate="yes" xml:space="preserve">
          <source>This module implements asynchronous file reading and writing.</source>
          <target state="translated">이 모듈은 비동기 파일 읽기 및 쓰기를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="be0a15236b06fa556c56498d41940c7197453f73" translate="yes" xml:space="preserve">
          <source>This module implements boilerplate to make unit testing easy.</source>
          <target state="translated">이 모듈은 상용구 테스트를 위해 보일러 플레이트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="909c88835454bdf5c0519702c5f2c7e4a9275b55" translate="yes" xml:space="preserve">
          <source>This module implements code generation for methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb823571314137136b672c316a1e4f9478ba59e" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb52bf0d87731597af09d97960c22d019bf58d4" translate="yes" xml:space="preserve">
          <source>This module implements color handling for Nim. It is used by the &lt;code&gt;graphics&lt;/code&gt; module.</source>
          <target state="translated">이 모듈은 Nim의 색상 처리를 구현합니다. &lt;code&gt;graphics&lt;/code&gt; 모듈에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b8921996b5c256e40c5e6c977e3725a0386307f" translate="yes" xml:space="preserve">
          <source>This module implements common simple lowerings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7729efb631e2eb7bcfa9fd3c15327853bf181948" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers.</source>
          <target state="translated">이 모듈은 복소수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aeaf9342dd5833ed552b5a2102d34b6d6ec873cf" translate="yes" xml:space="preserve">
          <source>This module implements complex numbers. Complex numbers are currently implemented as generic on a 64-bit or 32-bit float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fb167dafb36722d30f92f4593ecfc130a3dae2" translate="yes" xml:space="preserve">
          <source>This module implements efficient computations of hash values for diverse Nim types. All the procs are based on these two building blocks:</source>
          <target state="translated">이 모듈은 다양한 Nim 유형에 대한 해시 값의 효율적인 계산을 구현합니다. 모든 procs는 다음 두 가지 구성 요소를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="94a7c29bf4d442270eb47c16d094dbac2bb71a71" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for CGI applications. Example:</source>
          <target state="translated">이 모듈은 CGI 응용 프로그램을위한 도우미 프로세스를 구현합니다. 예:</target>
        </trans-unit>
        <trans-unit id="06e4f877dc2f02ff6d7623b1d21e1442d6e6e0aa" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for SCGI applications. Example:</source>
          <target state="translated">이 모듈은 SCGI 응용 프로그램을위한 도우미 프로세스를 구현합니다. 예:</target>
        </trans-unit>
        <trans-unit id="00f7e73405ca98ef55459bd8cb137c930c54ce67" translate="yes" xml:space="preserve">
          <source>This module implements helper procs for parsing Cookies.</source>
          <target state="translated">이 모듈은 쿠키 파싱을위한 헬퍼 프로세스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0d7dad71176a5274e0ff15c36d8d42475024e144" translate="yes" xml:space="preserve">
          <source>This module implements helpers for the macro cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7aa9306839a9e2f1eb10857736527eb56ecd2a" translate="yes" xml:space="preserve">
          <source>This module implements lifting for type-bound operations (&lt;code&gt;=sink&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;=destroy&lt;/code&gt;, &lt;code&gt;=deepCopy&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa51e0bbdd73802dae08d36a67835190e007e6d" translate="yes" xml:space="preserve">
          <source>This module implements nice syntactic sugar based on Nim's macro system.</source>
          <target state="translated">이 모듈은 Nim의 매크로 시스템을 기반으로 멋진 구문 설탕을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="605fb43c6c6ebd7d6234f48fb476d48d8bab0b46" translate="yes" xml:space="preserve">
          <source>This module implements operations for the built-in &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; type which were inspired by functional programming languages.</source>
          <target state="translated">이 모듈 은 기능적 프로그래밍 언어에서 영감을 얻은 내장 &lt;span id=&quot;seq_1&quot;&gt;seq&lt;/span&gt; 유형 에 대한 작업을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="03602f44dc99d2a2f1feb228793b9d5dc7bd7cfd" translate="yes" xml:space="preserve">
          <source>This module implements portable sockets, it supports a mix of different types of sockets. Sockets are buffered by default meaning that data will be received in &lt;code&gt;BufferSize&lt;/code&gt; (4000) sized chunks, buffering behaviour can be disabled by setting the &lt;code&gt;buffered&lt;/code&gt; parameter when calling the &lt;code&gt;socket&lt;/code&gt; function to &lt;em&gt;false&lt;/em&gt;. Be aware that some functions may not yet support buffered sockets (mainly the recvFrom function).</source>
          <target state="translated">이 모듈은 휴대용 소켓을 구현하고 다양한 유형의 소켓을 혼합하여 지원합니다. 소켓은 기본적으로 버퍼링되어 데이터가 &lt;code&gt;BufferSize&lt;/code&gt; 로 수신됩니다. (4000) 크기의 덩어리, 버퍼링 동작은 설정하여 비활성화 할 수 있습니다 &lt;code&gt;buffered&lt;/code&gt; 호출 할 때 매개 변수를 &lt;code&gt;socket&lt;/code&gt; 에 기능 &lt;em&gt;거짓을&lt;/em&gt; . 일부 함수는 아직 버퍼 소켓 (주로 recvFrom 함수)을 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e03448c70f64476d8a1af87251f0850a190b56c" translate="yes" xml:space="preserve">
          <source>This module implements procs to determine the number of CPUs / cores.</source>
          <target state="translated">이 모듈은 프로세서를 구현하여 CPU / 코어 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="75d697bfa5c4fe5f66a9e6c4166274beadef8e27" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;code&gt;num&lt;/code&gt; and a denominator &lt;code&gt;den&lt;/code&gt;, both of type int. The denominator can not be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b020312c18d7f1e3e79c3c6ff8a468feda67a72" translate="yes" xml:space="preserve">
          <source>This module implements rational numbers, consisting of a numerator &lt;em&gt;num&lt;/em&gt; and a denominator &lt;em&gt;den&lt;/em&gt;, both of type int. The denominator can not be 0.</source>
          <target state="translated">이 모듈 구현 유리수하는 분자로 구성된 &lt;em&gt;납입&lt;/em&gt; 와 분모의 &lt;em&gt;서재&lt;/em&gt; , int 형의 모두. 분모는 0이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cf5cab5d8bf4f6c2215c0c3d51c3ca1a3596a21" translate="yes" xml:space="preserve">
          <source>This module implements semantic checking for calls.this module does the semantic checking of statementsThis module does the semantic transformation of the fields* iterators.This module implements Nim's object construction rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fdbdda66a11d9e4dcd5f67ececbd1313751a08" translate="yes" xml:space="preserve">
          <source>This module implements some common generic algorithms.</source>
          <target state="translated">이 모듈은 몇 가지 일반적인 일반 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="15596de96df6a5d16f5a2c6304d05b802e3f3dd2" translate="yes" xml:space="preserve">
          <source>This module implements stream wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6360fdb1a0d14929ad9c3c0a54011a7ceeb73b7" translate="yes" xml:space="preserve">
          <source>This module implements the '.liftLocals' pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11c7939e3afe546c05d00ad6b841be9456fe883" translate="yes" xml:space="preserve">
          <source>This module implements the 'implies' relation for guards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324900edca6f658b4339cf4b65eb81ff95b693e9" translate="yes" xml:space="preserve">
          <source>This module implements the C code generator.This include file contains the logic to produce constant string and seq literals. The code here is responsible that &lt;code&gt;const x = [&quot;a&quot;, &quot;b&quot;]&lt;/code&gt; works without hidden runtime creation code. The price is that seqs and strings are not purely a library implementation.Generates traversal procs for the C backend.Code specialization instead of the old, incredibly slow 'genericReset' implementation.Thread var support for crappy architectures that lack native support for thread local storage. (&lt;strong&gt;Thank you Mac OS X!&lt;/strong&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5033575ad43160cfe00aa6032cd8e72c2229f7f9" translate="yes" xml:space="preserve">
          <source>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</source>
          <target state="translated">이 모듈은 RFC 5321에 지정된 SMTP 클라이언트 프로토콜을 구현하며 SMTP 서버로 메일을 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6a93e5b19faa7bc126c3e2fc94d788bde65745" translate="yes" xml:space="preserve">
          <source>This module implements the ability to access symbols from shared libraries. On POSIX this uses the &lt;code&gt;dlsym&lt;/code&gt; mechanism, on Windows &lt;code&gt;LoadLibrary&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 공유 라이브러리에서 심볼에 액세스하는 기능을 구현합니다. POSIX에서는 Windows 에서 &lt;code&gt;dlsym&lt;/code&gt; 메커니즘을 사용합니다. &lt;code&gt;LoadLibrary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3873bd4d455f4aaaae3cbab2055aa96d93f86ba" translate="yes" xml:space="preserve">
          <source>This module implements the basics for Linux distribution (&quot;distro&quot;) detection and the OS's native package manager. Its primary purpose is to produce output for Nimble packages like:</source>
          <target state="translated">이 모듈은 Linux 배포 ( &quot;distro&quot;) 감지 및 OS 기본 패키지 관리자에 대한 기본 사항을 구현합니다. 주요 목적은 다음과 같은 Nimble 패키지의 출력을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0923959ce15bcdc564ea4a58b3ac4fecf2023c6" translate="yes" xml:space="preserve">
          <source>This module implements the canonalization for the various caching mechanisms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07a4bf44a78d1d257e8619bf8a77573a5a9c90b" translate="yes" xml:space="preserve">
          <source>This module implements the code generator for the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a38d94bda812e8dfd26d5856d7d5a0ebec8243b" translate="yes" xml:space="preserve">
          <source>This module implements the generation of &lt;code&gt;.ndi&lt;/code&gt; files for better debugging support of Nim code. &quot;ndi&quot; stands for &quot;Nim debug info&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6156a97839b4290df6ebce6deed6bed5a01d783" translate="yes" xml:space="preserve">
          <source>This module implements the merge operation of 2 different C files. This is needed for incremental compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10dd027360f5be6d220e9a48b8828a68cc03c43" translate="yes" xml:space="preserve">
          <source>This module implements the module graph data structure. The module graph represents a complete Nim project. Single modules can either be kept in RAM or stored in a Sqlite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870290fb4763d9ca97f463a24d11a0f61a137a38" translate="yes" xml:space="preserve">
          <source>This module implements the passes functionality. A pass must implement the &lt;code&gt;TPass&lt;/code&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcd3512a3ab958ff6ee67f05599b41b02ebd9df" translate="yes" xml:space="preserve">
          <source>This module implements the pattern matching features for term rewriting macro support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70367e3386c4a0bfa37a82d45a19f9a7ed417f54" translate="yes" xml:space="preserve">
          <source>This module implements the signature matching for resolving the call to overloaded procs, generic procs and operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7af9f244bfd95dc4b59560e53168beb2ea1039" translate="yes" xml:space="preserve">
          <source>This module implements the style checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf87db50efeea8af15f9c9cb3ade6f25c05a723d" translate="yes" xml:space="preserve">
          <source>This module implements the symbol importing mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5c7b7b5304374db892e2c02470b732730375fb" translate="yes" xml:space="preserve">
          <source>This module implements threadpool's &lt;code&gt;spawn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b881f434ad53307745d9873f33cc83cdf48e46" translate="yes" xml:space="preserve">
          <source>This module implements types and macros for writing asynchronous code for the JS backend. It provides tools for interaction with JavaScript async API-s and libraries, writing async procedures in Nim and converting callback-based code to promises.</source>
          <target state="translated">이 모듈은 JS 백엔드에 대한 비동기 코드를 작성하기위한 유형 및 매크로를 구현합니다. JavaScript 비동기 API 및 라이브러리와의 상호 작용, Nim에서 비동기 프로 시저 작성 및 콜백 기반 코드를 약속으로 변환하는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="96a223a86302396be5588794d00dcc5a992fb05a" translate="yes" xml:space="preserve">
          <source>This module implements types which encapsulate an optional value.</source>
          <target state="translated">이 모듈은 선택적 값을 캡슐화하는 유형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8b05223d9ca6772d764f5fcaadb7295f47ed88d6" translate="yes" xml:space="preserve">
          <source>This module is a sample.</source>
          <target state="translated">이 모듈은 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="a2a203baf067681d5e0468d7220606f23e9f491a" translate="yes" xml:space="preserve">
          <source>This module is also compatible with other backends: &lt;code&gt;Javascript&lt;/code&gt;, &lt;code&gt;Nimscript&lt;/code&gt; as well as the &lt;code&gt;compiletime VM&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 다른 백엔드 ( &lt;code&gt;Javascript&lt;/code&gt; , &lt;code&gt;Nimscript&lt;/code&gt; 및 &lt;code&gt;compiletime VM&lt;/code&gt; 타임 VM ) 와도 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3531490dbe3e2f25dede9c41e4fcef79b629cad" translate="yes" xml:space="preserve">
          <source>This module is available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ac486e597f76fa9f3aeade5377d8139863cf06" translate="yes" xml:space="preserve">
          <source>This module is based on Python's Unidecode module by Tomaz Solc, which in turn is based on the &lt;code&gt;Text::Unidecode&lt;/code&gt; Perl module by Sean M. Burke (&lt;a href=&quot;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&quot;&gt;http://search.cpan.org/~sburke/Text-Unidecode-0.04/lib/Text/Unidecode.pm&lt;/a&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12453f55babdb4a27c1f7e732c0c542926e9cbdc" translate="yes" xml:space="preserve">
          <source>This module is experimental and its interface may change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcaffb7c268575c15a197b066d88f31f66ee5014" translate="yes" xml:space="preserve">
          <source>This module is for compiler internal use only. For reliable error messages and range checks, the compiler needs a data type that can hold all from &lt;code&gt;low(BiggestInt)&lt;/code&gt; to &lt;code&gt;high(BiggestUInt)&lt;/code&gt;, This type is for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5689b667695647b8ab8ef22840d0cdf1b5bb67f" translate="yes" xml:space="preserve">
          <source>This module is implemented by providing a wrapper around the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE (Perl-Compatible Regular Expressions)&lt;/a&gt; C 라이브러리 주위에 랩퍼를 제공하여 구현됩니다 . 이것은이 모듈을 사용할 때 응용 프로그램이 PCRE 라이브러리의 라이센스에 의존한다는 것을 의미하지만 문제는 아닙니다. PCRE의 라이센스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edd45a27ac656172236276c240c2474c18a6f78e" translate="yes" xml:space="preserve">
          <source>This module needs the data file &quot;unidecode.dat&quot; to work: This file is embedded as a resource into your application by default. But you an also define the symbol &lt;code&gt;--define:noUnidecodeTable&lt;/code&gt; during compile time and use the &lt;code&gt;loadUnidecodeTable&lt;/code&gt; proc to initialize this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fccb6a29ddaf211868c4b8302f35490b759841" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expression, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda1d94b3b5a9dcfb70f16a91a3ec170b750b323" translate="yes" xml:space="preserve">
          <source>This module offers implementations of common binary operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and comparison operations, which work for mixed float/int operands. All operations convert the integer operand into the type of the float operand. For numerical expressions, the return type is always the type of the float involved in the expresssion, i.e., there is no auto conversion from float32 to float64.</source>
          <target state="translated">이 모듈은 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 와 같은 일반적인 이진 연산의 구현을 제공합니다 및 비교 부동 소수점 / int 피연산자에 대해 작동하는 . 모든 연산은 정수 피연산자를 부동 피연산자의 유형으로 변환합니다. 숫자 식의 경우 반환 유형은 항상 표현에 관련된 부동 유형입니다. 즉 float32에서 float64로 자동 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3267cc83830f712bb14c086f0878bf139791739" translate="yes" xml:space="preserve">
          <source>This module only exists to generate docs for the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7396f239f24da0a4e4690ab1044ff64d650f1306" translate="yes" xml:space="preserve">
          <source>This module parses a XML Document into a XML DOM Document representation.</source>
          <target state="translated">이 모듈은 XML 문서를 XML DOM 문서 표현으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a9bcdabb8e24bc9cc089f0f13411ad03a03519bc" translate="yes" xml:space="preserve">
          <source>This module parses an HTML document and creates its XML tree representation. It is supposed to handle the &lt;em&gt;wild&lt;/em&gt; HTML the real world uses.</source>
          <target state="translated">이 모듈은 HTML 문서를 구문 분석하고 XML 트리 표현을 만듭니다. 실제 세계에서 사용 하는 &lt;em&gt;와일드&lt;/em&gt; HTML 을 처리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6cd96ee218d8bf4a40ad0320da8cac9d72214020" translate="yes" xml:space="preserve">
          <source>This module parses an XML document and creates its XML tree representation.</source>
          <target state="translated">이 모듈은 XML 문서를 구문 분석하고 XML 트리 표현을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9092d7288554b84b5306c5e4d5f8c8a0d7f59d2c" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;a href=&quot;#FileStream&quot;&gt;FileStream&lt;/a&gt; and the &lt;a href=&quot;#StringStream&quot;&gt;StringStream&lt;/a&gt; which implement the stream interface for Nim file objects (&lt;code&gt;File&lt;/code&gt;) and strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a07c876b6cd8245c5dfacca935fec67d4db93ff" translate="yes" xml:space="preserve">
          <source>This module provides a stream interface and two implementations thereof: the &lt;em&gt;FileStream&lt;/em&gt; and the &lt;em&gt;StringStream&lt;/em&gt; which implement the stream interface for Nim file objects (&lt;em&gt;File&lt;/em&gt;) and strings. Other modules may provide other implementations for this standard stream interface.</source>
          <target state="translated">이 모듈은 스트림 인터페이스와 그 두 가지 구현을 제공합니다. &lt;em&gt;FileStream&lt;/em&gt; 과 &lt;em&gt;StringStream&lt;/em&gt; 은 Nim 파일 객체 ( &lt;em&gt;File&lt;/em&gt; )와 문자열에 대한 스트림 인터페이스를 구현합니다 . 다른 모듈은이 표준 스트림 인터페이스에 대한 다른 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab8f9a52d2829796af73473cde494f332d9e364" translate="yes" xml:space="preserve">
          <source>This module provides an easy to use sockets-style nim interface to the OpenSSL library.</source>
          <target state="translated">이 모듈은 OpenSSL 라이브러리에 사용하기 쉬운 소켓 스타일의 nim 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49dbd9ba77d32ac31376544311a3b10bed584209" translate="yes" xml:space="preserve">
          <source>This module provides both a synchronous and asynchronous implementation. The asynchronous implementation requires you to use the &lt;code&gt;asyncFTPClient&lt;/code&gt; function. You are then required to register the &lt;code&gt;AsyncFTPClient&lt;/code&gt; with a asyncio dispatcher using the &lt;code&gt;register&lt;/code&gt; function. Take a look at the asyncio module documentation for more information.</source>
          <target state="translated">이 모듈은 동기 및 비동기 구현을 모두 제공합니다. 비동기 구현에서는 &lt;code&gt;asyncFTPClient&lt;/code&gt; 함수 를 사용해야합니다 . 그런 다음 등록해야 &lt;code&gt;AsyncFTPClient&lt;/code&gt; 을 사용하여 asyncio 디스패처와 &lt;code&gt;register&lt;/code&gt; 기능을. 자세한 내용은 asyncio 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce590e4e5a122965a43db23fbb2cb01e20c16510" translate="yes" xml:space="preserve">
          <source>This module provides support for &lt;span id=&quot;memory-mapped-files_1&quot;&gt;memory mapped files&lt;/span&gt; (Posix's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt;) on the different operating systems.</source>
          <target state="translated">이 모듈은 다른 운영 체제에서 &lt;span id=&quot;memory-mapped-files_1&quot;&gt;메모리 매핑 파일&lt;/span&gt; (Posix 's &lt;span id=&quot;mmap_1&quot;&gt;mmap&lt;/span&gt; )을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="65c4c619ae2b38e38065fa4fe9a46d6bc185ed6a" translate="yes" xml:space="preserve">
          <source>This module provides support to handle the Unicode UTF-8 encoding.</source>
          <target state="translated">이 모듈은 유니 코드 UTF-8 인코딩 처리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f60f9e4146057e2aadde33d2726a83b70d00ccbc" translate="yes" xml:space="preserve">
          <source>This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features.</source>
          <target state="translated">이 모듈은 표준 Nim 명령 줄 파서를 제공합니다. 모든 명령 행 옵션과 일부 하위 레벨 기능에 대해 하나의 편의 반복자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="be630a10c2306e1da8b699aa549bd1507ce73a7f" translate="yes" xml:space="preserve">
          <source>This module supports helper routines for working with &lt;code&gt;cstring&lt;/code&gt; without having to convert &lt;code&gt;cstring&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt; in order to save allocations.</source>
          <target state="translated">이 모듈은 할당을 저장하기 위해 &lt;code&gt;cstring&lt;/code&gt; 을 &lt;code&gt;string&lt;/code&gt; 로 변환하지 않고도 &lt;code&gt;cstring&lt;/code&gt; 에 대한 작업을위한 헬퍼 루틴을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="5a7ff45a67a6ab46e7d1fb35b3306305d6ba07fa" translate="yes" xml:space="preserve">
          <source>This module wraps core JavaScript functions.</source>
          <target state="translated">이 모듈은 핵심 JavaScript 함수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="0f7196bd18c3887a77199794d0417e3686fb88b6" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessDefect&lt;/code&gt; exception. To be able to catch a NilAccessDefect all you have to do is to import this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b840bfc815d3caad906fc572e9454af313da4d0" translate="yes" xml:space="preserve">
          <source>This modules registers a signal handler that turns access violations / segfaults into a &lt;code&gt;NilAccessError&lt;/code&gt; exception. To be able to catch a NilAccessError all you have to do is to import this module.</source>
          <target state="translated">이 모듈은 액세스 위반 / segfault를 &lt;code&gt;NilAccessError&lt;/code&gt; 예외 로 바꾸는 신호 핸들러를 등록합니다 . NilAccessError를 잡으려면이 모듈을 가져 오기만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fee1833b4c51904885c4305b4d12a4e1e8ea0e21" translate="yes" xml:space="preserve">
          <source>This most often useful for constructing sequences with the array constructor: &lt;code&gt;@[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;seq[int]&lt;/code&gt;, while &lt;code&gt;[1, 2, 3]&lt;/code&gt; has the type &lt;code&gt;array[0..2, int]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6390ea355bcccac1df3928830a46c0fa9200368c" translate="yes" xml:space="preserve">
          <source>This must be called on an unconnected socket; an SSL session will be started when the socket is connected.</source>
          <target state="translated">연결되지 않은 소켓에서 호출해야합니다. 소켓이 연결되면 SSL 세션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0dc417a03ed217016727b05e73fb23e9635c5936" translate="yes" xml:space="preserve">
          <source>This needs to be called to set &lt;code&gt;x&lt;/code&gt;'s runtime object type field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08443e3f06cf9773785c99d4ad98608f4e9eebf" translate="yes" xml:space="preserve">
          <source>This operator computes the difference of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f79ed7bc0326a97f82d04a96b028c6113002f150" translate="yes" xml:space="preserve">
          <source>This operator computes the intersection of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 교집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9a4b0639403e85faa9616f997f6d194f55eeab89" translate="yes" xml:space="preserve">
          <source>This operator computes the union of two sets.</source>
          <target state="translated">이 연산자는 두 세트의 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b046c8a4096963070b190a5e641fbd439e8358a7" translate="yes" xml:space="preserve">
          <source>This operator is the assignment operator. Note that in the contexts &lt;code&gt;result = expr&lt;/code&gt;, &lt;code&gt;parameter = defaultValue&lt;/code&gt; or for parameter passing no assignment is performed. For a type &lt;code&gt;T&lt;/code&gt; that has an overloaded assignment operator &lt;code&gt;var v = T()&lt;/code&gt; is rewritten to &lt;code&gt;var v: T; v = T()&lt;/code&gt;; in other words &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; contexts do count as assignments.</source>
          <target state="translated">이 연산자는 할당 연산자입니다. 컨텍스트 &lt;code&gt;result = expr&lt;/code&gt; , &lt;code&gt;parameter = defaultValue&lt;/code&gt; 또는 매개 변수 전달에 대해 지정이 수행되지 않습니다. 오버로드 된 할당 연산자가 있는 유형 &lt;code&gt;T&lt;/code&gt; 의 경우 &lt;code&gt;var v = T()&lt;/code&gt; 가 &lt;code&gt;var v: T; v = T()&lt;/code&gt; 로 다시 작성됩니다 . T; v = T () ; 즉, &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 컨텍스트가 할당으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c815aa40abb9bedda70e19c6d2ad3999d74da028" translate="yes" xml:space="preserve">
          <source>This operator will be matched against assignments to missing fields.</source>
          <target state="translated">이 연산자는 누락 된 필드에 대한 지정과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="877c6b770d02ce2daf96f01b490c8ab96ed58851" translate="yes" xml:space="preserve">
          <source>This operator will be matched against both field accesses and method calls.</source>
          <target state="translated">이 연산자는 필드 액세스 및 메소드 호출 모두와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8eb5171b4785a372e6e7687e57e17ace11b78ea3" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;code&gt;.&lt;/code&gt; operator and this allows one to handle expressions like &lt;code&gt;x.y&lt;/code&gt; and &lt;code&gt;x.y()&lt;/code&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c71fe5d49c4e442130e8d4e9b6e7107de926b7" translate="yes" xml:space="preserve">
          <source>This operator will be matched exclusively against method calls. It has higher precedence than the &lt;em&gt;.&lt;/em&gt; operator and this allows one to handle expressions like &lt;em&gt;x.y&lt;/em&gt; and &lt;em&gt;x.y()&lt;/em&gt; differently if one is interfacing with a scripting language for example.</source>
          <target state="translated">이 연산자는 메소드 호출과 독점적으로 일치합니다. 보다 우선 순위가 높습니다 &lt;em&gt;. &lt;/em&gt;연산자를 사용하면 &lt;em&gt;xy&lt;/em&gt; 및 &lt;em&gt;xy ()&lt;/em&gt; 와 같은 표현식을 처리 할 수 ​​있습니다&lt;em&gt;&lt;/em&gt;예를 들어 스크립트 언어와 인터페이스하는 경우 다르게 .</target>
        </trans-unit>
        <trans-unit id="fdce8c1c9dd850ca032055512e1bd9d5a06936f2" translate="yes" xml:space="preserve">
          <source>This page provide hints on distributing Nim using OS packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c195c31e5829f87707abb98358a691d8131229a7" translate="yes" xml:space="preserve">
          <source>This passes the expression &lt;code&gt;x + y * z - x&lt;/code&gt; to the &lt;code&gt;optM&lt;/code&gt; macro as an &lt;code&gt;nnkArgList&lt;/code&gt; node containing:</source>
          <target state="translated">이것은 &lt;code&gt;x + y * z - x&lt;/code&gt; 표현식 을 다음을 포함 하는 &lt;code&gt;nnkArgList&lt;/code&gt; 노드 로 &lt;code&gt;optM&lt;/code&gt; 매크로에 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="779a96266029c48032a8abc57497d759ae90622e" translate="yes" xml:space="preserve">
          <source>This pragma can also take in an optional warning string to relay to developers.</source>
          <target state="translated">이 pragma는 개발자에게 릴레이하기 위해 선택적 경고 문자열을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b75ce5f723cf09cb35bbfecf4010bd348d284353" translate="yes" xml:space="preserve">
          <source>This pragma has no effect on the JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bac99517eec01add92d42595b9d17d1a79dbd9" translate="yes" xml:space="preserve">
          <source>This proc adds the necessary Content-Length header.</source>
          <target state="translated">이 절차는 필요한 Content-Length 헤더를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7b6638b54fd693beeb9b92d654723a7cc066942f" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection</source>
          <target state="translated">이 프로세스는 리디렉션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bec96c78d9187ae27072063a2599e2d8041f75b3" translate="yes" xml:space="preserve">
          <source>This proc also handles redirection.</source>
          <target state="translated">이 proc도 리디렉션을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="17bc78789836f23c301ac5b842a1060d7a4db4c3" translate="yes" xml:space="preserve">
          <source>This proc behaves the same as the &lt;code&gt;%&lt;/code&gt; operator in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3938ad51042cbaba9e98c935176fa62ab2de2077" translate="yes" xml:space="preserve">
          <source>This proc can be used to create tree structures on the fly (sometimes called &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt;):</source>
          <target state="translated">이 proc을 사용하여 트리 구조를 즉석에서 만들 수 있습니다 (때때로 &lt;span id=&quot;autovivification_1&quot;&gt;autovivification&lt;/span&gt; 이라고 &lt;span id=&quot;autovivification_1&quot;&gt;함&lt;/span&gt; ).</target>
        </trans-unit>
        <trans-unit id="d26c6b6b611681b46566a5e4a79f3225cadc8212" translate="yes" xml:space="preserve">
          <source>This proc doesn't perform any normalization! For example, &lt;code&gt;initTimeInterval(hours = 24)&lt;/code&gt; and &lt;code&gt;initTimeInterval(days = 1)&lt;/code&gt; are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3940a36413be40e433cc94d22655956da42c2d56" translate="yes" xml:space="preserve">
          <source>This proc doesn't raise an exception on error, beware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb824dcf7f8bb590cee2ba4a4f3a5cbd9ae6dff" translate="yes" xml:space="preserve">
          <source>This proc expects to be passed as &lt;code&gt;n&lt;/code&gt; the parameters of any callable. The string output is meant for the HTML renderer. If there are no parameters, the empty string is returned. The parameters will be joined by &lt;code&gt;sep&lt;/code&gt; but other characters may appear too, like &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f135f77463cef43ee9fac9055909ade3fefb1c63" translate="yes" xml:space="preserve">
          <source>This proc is equivalent to 2^64 calls to &lt;a href=&quot;#next,Rand&quot;&gt;next&lt;/a&gt;, and it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350b35231bf552e3848fa0167786f99d3c79a8be" translate="yes" xml:space="preserve">
          <source>This proc is mostly useful for meta programming (eg. &lt;code&gt;assert&lt;/code&gt; template) to retrieve information about the current filename and line number. Example:</source>
          <target state="translated">이 proc은 현재 메타 데이터 (예 : &lt;code&gt;assert&lt;/code&gt; template)가 현재 파일 이름과 줄 번호에 대한 정보를 검색하는 데 유용합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="bf91fb862b9ad244ab7a7fe8893c5ec5d0d1450b" translate="yes" xml:space="preserve">
          <source>This proc is normally used with connectionless sockets (UDP sockets).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da63af19bd44e5c45f60183bb9599bcc8b3d3e9" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the &lt;a href=&quot;#expandTilde,string&quot;&gt;expandTilde proc&lt;/a&gt; for the convenience of processing paths coming from user configuration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc13541eec5a8625bb4f501795d54288285926d" translate="yes" xml:space="preserve">
          <source>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</source>
          <target state="translated">이 proc은 사용자 구성 파일에서 오는 경로 처리의 편의를 위해 expandTilde proc에 의해 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="5e959921234b63d76dbef4bc106055bfeccf3fc5" translate="yes" xml:space="preserve">
          <source>This proc must be called before any other usage of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8173dbe5f7a8294af8a1a1ddc4730d7ef3e88" translate="yes" xml:space="preserve">
          <source>This proc only needs to be called once, and it should be called before the first usage of procs from this module that use the default random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333b238bdf3008bb02960b98a410ac4836f3911d" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname, if a hostname is specified this function will try each IP of that hostname.</source>
          <target state="translated">이 proc은 지정된 &lt;code&gt;address&lt;/code&gt; 로 &lt;code&gt;data&lt;/code&gt; 를 보냅니다 . IP 주소 또는 호스트 이름 일 수 있습니다. 호스트 이름이 지정된 경우이 함수는 해당 호스트 이름의 각 IP를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="938649feb3030899c2e766999d5b87bd8659f3c6" translate="yes" xml:space="preserve">
          <source>This proc sends &lt;code&gt;data&lt;/code&gt; to the specified &lt;code&gt;address&lt;/code&gt;, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ed4d34f9d82a4db2eb217526e348dc0895635d" translate="yes" xml:space="preserve">
          <source>This proc uses the default random number generator. Thus, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eaf268233c731f7c482448d362f14c34db36aa" translate="yes" xml:space="preserve">
          <source>This proc will assert if the node is not of the expected type. The empty string will be returned as a minimum. Any value in the rst will be stripped form leading/trailing whitespace.</source>
          <target state="translated">이 proc은 노드가 예상되는 유형이 아닌 경우에 주장합니다. 빈 문자열은 최소값으로 반환됩니다. 첫 번째 값은 선행 / 후행 공백에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bdafab7045ac0766f9e79ee5dc6b8e55ba43a53a" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;code&gt;dir&lt;/code&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile,RstGenerator,string&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626f1119535b21954263807e2c460288c1806626" translate="yes" xml:space="preserve">
          <source>This proc will first scan &lt;em&gt;dir&lt;/em&gt; for index files with the &lt;code&gt;.idx&lt;/code&gt; extension previously created by commands like &lt;code&gt;nim doc|rst2html&lt;/code&gt; which use the &lt;code&gt;--index:on&lt;/code&gt; switch. These index files are the result of calls to &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; and &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;, so they are simple tab separated files.</source>
          <target state="translated">이 proc은 먼저 &lt;code&gt;--index:on&lt;/code&gt; 스위치 를 사용하는 &lt;code&gt;nim doc|rst2html&lt;/code&gt; 과 같은 명령에 의해 생성 된 &lt;code&gt;.idx&lt;/code&gt; 확장자를 가진 인덱스 파일에 대한 &lt;em&gt;dir&lt;/em&gt; 을 스캔 합니다. 이 색인 파일은 &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; 및 &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile ()&lt;/a&gt; 호출의 결과 이므로 간단한 탭으로 구분 된 파일입니다.</target>
        </trans-unit>
        <trans-unit id="a4394af6524fbdf2935a5287c6e403358c97c2f3" translate="yes" xml:space="preserve">
          <source>This proc will return true if given two alternative hard-linked or sym-linked paths to the same file or directory.</source>
          <target state="translated">이 proc은 동일한 파일 또는 디렉토리에 대한 두 개의 대체 하드 링크 또는 sym 링크 경로가 제공되면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fa999fcdc85222ac9f9bda4589a9a95ca91d7d4" translate="yes" xml:space="preserve">
          <source>This proc works similarly to &lt;a href=&quot;#sample,Rand,openArray%5BT%5D,openArray%5BU%5D&quot;&gt;sample[T, U](Rand, openArray[T], openArray[U])&lt;/a&gt;. See that proc's documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c1f778626a828d02676e44a9e588073cc53bdc" translate="yes" xml:space="preserve">
          <source>This procedure causes any unwritten data for that stream to be delivered to the host environment to be written to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a80f4b7504eb42e35ef57671474e7f95b75a669" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string according to MIME spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab576674f0fae9f5c2db872b47e1b80cc3065ba" translate="yes" xml:space="preserve">
          <source>This procedure encodes a string.</source>
          <target state="translated">이 절차는 문자열을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="c324daca0847c9b512385b859ab2363a1841f9c6" translate="yes" xml:space="preserve">
          <source>This procedure encodes an openarray (array or sequence) of either integers or characters.</source>
          <target state="translated">이 절차는 정수 또는 문자의 열린 배열 (배열 또는 시퀀스)을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="dadefb2f162797b5b8e737417830e0aaa5615a6d" translate="yes" xml:space="preserve">
          <source>This procedure exists only for optimization purposes; the same effect can be achieved with the &lt;code&gt;&amp;amp;&lt;/code&gt; operator or with &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31397687949c9dfdee06b359b12e24a49c3d9c7" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;a href=&quot;#declared&quot;&gt;declared()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4fef9f6de3ef8d675cc867d40c13213fa9353a" translate="yes" xml:space="preserve">
          <source>This procedure is not guaranteed to be available for all platforms. Test for availability with &lt;code&gt;declared() &amp;lt;system.html#declared,untyped&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba0aeda7a3e7c849c8d97ba20a2191682f9515" translate="yes" xml:space="preserve">
          <source>This procedure is perfect for saving streamed data to a file without wasting memory.</source>
          <target state="translated">이 절차는 메모리 낭비없이 파일로 스트리밍 된 데이터를 저장하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d1f961f21ff0a84bd8db8e05ca89330dfa9923ef" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;Duration&lt;/code&gt; values to strings.</source>
          <target state="translated">이 절차는 &lt;code&gt;Duration&lt;/code&gt; 값을 문자열 로 변환하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="520fb6fa62d760ce421de4aaa2f6105b1555063b" translate="yes" xml:space="preserve">
          <source>This procedure is useful for converting &lt;code&gt;TimeInterval&lt;/code&gt; values to strings. E.g. then you need to implement custom interval printing</source>
          <target state="translated">이 절차는 &lt;code&gt;TimeInterval&lt;/code&gt; 값을 문자열 로 변환하는 데 유용합니다 . 예를 들어 사용자 정의 간격 인쇄를 구현해야합니다</target>
        </trans-unit>
        <trans-unit id="52e91210394e398f992437bda6d4effa40dcc4a1" translate="yes" xml:space="preserve">
          <source>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The &lt;code&gt;OSErrorMsg&lt;/code&gt; procedure can then be used to convert this code into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70517cf24694c69da8efa582ddd657d7197346ed" translate="yes" xml:space="preserve">
          <source>This procedure uses httpClient values such as &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0479019038d3102021d1669951bf95b837b91563" translate="yes" xml:space="preserve">
          <source>This procedure will &lt;strong&gt;not&lt;/strong&gt; close the client socket.</source>
          <target state="translated">이 절차는 클라이언트 소켓을 닫지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9c22aaa48bc7cddb7839a6f9a879afc83e6b75" translate="yes" xml:space="preserve">
          <source>This procedure will also create a brand new file descriptor for this socket.</source>
          <target state="translated">이 절차는 또한이 소켓에 대한 새로운 파일 디스크립터를 생성 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1288ff1149ba87d487f19440b9d10966e30531a7" translate="yes" xml:space="preserve">
          <source>This procedure will follow redirects up to a maximum number of redirects specified in &lt;code&gt;client.maxRedirects&lt;/code&gt;.</source>
          <target state="translated">이 절차는 &lt;code&gt;client.maxRedirects&lt;/code&gt; 에 지정된 최대 리디렉션 수까지 리디렉션을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="7a5c3737642080f0e83823f3dcd1cc4baeb39760" translate="yes" xml:space="preserve">
          <source>This procedure will immediately return, it will not block until a connection is made. It is up to the caller to make sure the connection has been established by checking (using &lt;code&gt;select&lt;/code&gt;) whether the socket is writeable.</source>
          <target state="translated">이 절차는 즉시 반환되며 연결될 때까지 차단되지 않습니다. 소켓의 쓰기 가능 여부 를 점검 ( &lt;code&gt;select&lt;/code&gt; 사용 ) 하여 연결이 설정되었는지 확인하는 것은 호출자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8185dc4f223c6b697125a69fc7c20cfa4abf8f29" translate="yes" xml:space="preserve">
          <source>This procedure will resolve symlinks.</source>
          <target state="translated">이 절차는 심볼릭 링크를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="014cae8b1a1962b4f1faa243de196e5e656ee26d" translate="yes" xml:space="preserve">
          <source>This provides higher efficiency than the &lt;code&gt;pretty&lt;/code&gt; procedure as it does &lt;strong&gt;not&lt;/strong&gt; attempt to format the resulting JSON to make it human readable.</source>
          <target state="translated">결과 JSON을 사람이 읽을 수 있도록 형식화 하지 &lt;strong&gt;않기&lt;/strong&gt; 때문에 &lt;code&gt;pretty&lt;/code&gt; 프로 시저 보다 높은 효율성을 제공합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="526a6ce57682bfa6e8b959cd6e81435a72cdfc8d" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle it generates the above trivial implementations:</source>
          <target state="translated">이것은 빠르게 지루해집니다. 구현은 사소한 것이며 컴파일러는 나중에이 코드를 최적화하기 위해이 코드를 모두 생성해서는 안됩니다. 모든 &lt;code&gt;+&lt;/code&gt; 달러는 int &lt;code&gt;+&lt;/code&gt; 와 동일한 이진 코드를 생성해야합니다 . pragma &lt;span id=&quot;borrow_1&quot;&gt;차용은&lt;/span&gt; 이 문제를 해결하도록 설계되었습니다. 원칙적으로 위의 간단한 구현을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77e02d73fd63a6b9ecbe38066eb72908681331b1" translate="yes" xml:space="preserve">
          <source>This quickly gets tedious. The implementations are trivial and the compiler should not generate all this code only to optimize it away later - after all &lt;code&gt;+&lt;/code&gt; for dollars should produce the same binary code as &lt;code&gt;+&lt;/code&gt; for ints. The pragma &lt;span id=&quot;borrow_1&quot;&gt;borrow&lt;/span&gt; has been designed to solve this problem; in principle, it generates the above trivial implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47005e240c8afd6e1584cbc26a7622dbbbd1d07" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;partial case insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="translated">식별자 비교를 수행하는 다소 정통적인 방법을 &lt;span id=&quot;partial-case-insensitivity_1&quot;&gt;부분 대소 문자 구분&lt;/span&gt; 이라고 하며 기존 대소 문자 구분에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="601b78ebce6eee9b81f17aee5fe0af4dacad523a" translate="yes" xml:space="preserve">
          <source>This rather unorthodox way to do identifier comparisons is called &lt;span id=&quot;partial-caseminusinsensitivity_1&quot;&gt;partial case-insensitivity&lt;/span&gt; and has some advantages over the conventional case sensitivity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ed54e7055d8ae85d9b5529ed324762a3d069ea" translate="yes" xml:space="preserve">
          <source>This requires the OpenSSL library, fortunately it's widely used and installed on many operating systems. httpclient will use SSL automatically if you give any of the functions a url with the &lt;code&gt;https&lt;/code&gt; schema, for example: &lt;code&gt;https://github.com/&lt;/code&gt;.</source>
          <target state="translated">이를 위해서는 OpenSSL 라이브러리가 필요하지만 많은 운영 체제에서 널리 사용되고 사용됩니다. &lt;code&gt;https&lt;/code&gt; 스키마가 있는 URL에 함수를 제공하면 httpclient는 SSL을 자동으로 사용합니다 ( 예 : &lt;code&gt;https://github.com/&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="3909002e9ad606364e490e6f4e79bacb7e050226" translate="yes" xml:space="preserve">
          <source>This retrieves ALL rows into memory before iterating through the rows. Large dataset queries will impact on memory usage.</source>
          <target state="translated">행을 반복하기 전에 모든 행을 메모리로 검색합니다. 큰 데이터 집합 쿼리는 메모리 사용에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="096ad9b3f2bcb1230451399427a373a8d336f90f" translate="yes" xml:space="preserve">
          <source>This returns &lt;strong&gt;only&lt;/strong&gt; the parameters. If you want to get the application executable filename, call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt;.</source>
          <target state="translated">매개 변수 &lt;strong&gt;만&lt;/strong&gt; 리턴 &lt;strong&gt;합니다&lt;/strong&gt; . 응용 프로그램 실행 파일 이름을 얻으려면 &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename ()을&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa9d6a77d63381c1d09d47733e42419e7a92f6c1" translate="yes" xml:space="preserve">
          <source>This section can only help you with the last item.</source>
          <target state="translated">이 섹션은 마지막 항목에만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7e30a1e9a0acdfc19a0c0083bbed66bee81f8c64" translate="yes" xml:space="preserve">
          <source>This section deals with the basic built-in types and the operations that are available for them in detail.</source>
          <target state="translated">이 섹션에서는 기본 내장 유형 및 해당 유형에 대해 사용할 수있는 작업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="39b66580a9224160aed4a56da61d43fa2a3bbf6f" translate="yes" xml:space="preserve">
          <source>This section describes Nim's additional features that are not listed in the Nim manual. Some of the features here only make sense for the C code generator and are subject to change.</source>
          <target state="translated">이 섹션에서는 Nim 매뉴얼에 나열되지 않은 Nim의 추가 기능에 대해 설명합니다. 이 기능 중 일부는 C 코드 생성기에만 해당되며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfa8ca764ad8bfb7ab8cb634f105e3b8af514a0" translate="yes" xml:space="preserve">
          <source>This section describes additional pragmas that the current Nim implementation supports but which should not be seen as part of the language specification.</source>
          <target state="translated">이 섹션에서는 현재 Nim 구현이 지원하지만 언어 사양의 일부로 보여서는 안되는 추가 실습에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a3df74b1ff5eebb36ece2e259d2d5e805032af28" translate="yes" xml:space="preserve">
          <source>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (&lt;code&gt;NimNode&lt;/code&gt;) with a variable number of children. Each node has a field named &lt;code&gt;kind&lt;/code&gt; which describes what the node contains:</source>
          <target state="translated">이 섹션에서는 AST가 Nim 유형 시스템으로 모델링되는 방법을 설명합니다. AST는 가변 개수의 자식이있는 노드 ( &lt;code&gt;NimNode&lt;/code&gt; ) 로 구성됩니다 . 각 노드에는 노드에 포함 된 내용을 설명하는 &lt;code&gt;kind&lt;/code&gt; 라는 필드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28cfadb305f94e005219763b91c53ae1a57afd3" translate="yes" xml:space="preserve">
          <source>This section lists Nim's standard syntax. How the parser handles the indentation is already described in the &lt;a href=&quot;#lexical-analysis&quot;&gt;Lexical Analysis&lt;/a&gt; section.</source>
          <target state="translated">이 섹션에는 Nim의 표준 구문이 나와 있습니다. 파서가 들여 쓰기를 처리하는 방법은 &lt;a href=&quot;#lexical-analysis&quot;&gt;사전 분석&lt;/a&gt; 섹션 에 이미 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd3a9a0b54b906c2f17ac03b05d99470504a894" translate="yes" xml:space="preserve">
          <source>This should be called on a connected socket, and will perform an SSL handshake immediately.</source>
          <target state="translated">연결된 소켓에서 호출되어야하며 즉시 SSL 핸드 셰이크를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="206d66b1088d1b595bbfc280833418dec7ec898c" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures, or use &lt;code&gt;waitFor&lt;/code&gt; if you need to wait for the future's completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33d2aee12f9e4445c80f6903f9125cbac15130e" translate="yes" xml:space="preserve">
          <source>This should be used instead of &lt;code&gt;discard&lt;/code&gt; to discard void futures.</source>
          <target state="translated">이것은 무효 선물 을 &lt;code&gt;discard&lt;/code&gt; 하기 위해 폐기 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79d43e8081cd2738e9c8a30d0556e7afa9f98284" translate="yes" xml:space="preserve">
          <source>This should produce roughly this code:</source>
          <target state="translated">이것은 대략 다음 코드를 생성해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
