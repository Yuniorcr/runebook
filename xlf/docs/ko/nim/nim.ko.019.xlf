<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="6b78681456f7ad6085cc3fd61d2310d5e876df2d" translate="yes" xml:space="preserve">
          <source>This should resolve to root of nim sources, whether running nim from a local</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829889669aebe1d850c5abf95f09a062fffb5092" translate="yes" xml:space="preserve">
          <source>This string can be passed as the &lt;code&gt;frmStr&lt;/code&gt; argument to procs that create new loggers, such as the &lt;a href=&quot;#newConsoleLogger&quot;&gt;newConsoleLogger proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4682779a113516e431fc633b78e3eb5afe0b69" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; to override the temporary directory returned by &lt;code&gt;os.getTempDir()&lt;/code&gt;. The value &lt;strong&gt;should&lt;/strong&gt; end with a directory separator character. (Relevant for the Android platform)</source>
          <target state="translated">이 기호는 &lt;code&gt;--define:tempDir:/some/temp/path&lt;/code&gt; 와 같이 문자열을 값 으로 사용하여 &lt;code&gt;os.getTempDir()&lt;/code&gt; 반환 한 임시 디렉토리를 재정의합니다 . 값 &lt;strong&gt;은&lt;/strong&gt; 디렉토리 구분 문자로 끝나야합니다. (Android 플랫폼과 관련 있음)</target>
        </trans-unit>
        <trans-unit id="9b990f66ca4d7aa57f0cf0dd33176a666917f9d2" translate="yes" xml:space="preserve">
          <source>This symbol takes a string as its value, like &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; to override the path for the &lt;code&gt;sh&lt;/code&gt; binary, in cases where it is not located in the default location &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">이 기호는 기본 위치 &lt;code&gt;/bin/sh&lt;/code&gt; 에 있지 않은 경우 &lt;code&gt;--define:useShPath:/opt/sh/bin/sh&lt;/code&gt; 와 같이 문자열을 값 으로 사용하여 &lt;code&gt;sh&lt;/code&gt; 바이너리 의 경로를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="7c554f8359760cdb8ba631a7cf391a049d75587f" translate="yes" xml:space="preserve">
          <source>This template will resolve into &quot;&lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;&quot; which is a string literal and since {.discardable.} doesn't apply to literals, the compiler will error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8c91cc0539e7ac1fcb6913e444dfab0dfc651" translate="yes" xml:space="preserve">
          <source>This the stdcall convention as specified by Microsoft. The generated C procedure is declared with the &lt;code&gt;__stdcall&lt;/code&gt; keyword.</source>
          <target state="translated">이것은 Microsoft에서 지정한 stdcall 규칙입니다. 생성 된 C 프로시 저는 &lt;code&gt;__stdcall&lt;/code&gt; 키워드로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b9b3843bbbc030dffd360d54d7289f5101d67e4" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;a href=&quot;#genericHead,typedesc&quot;&gt;genericHead&lt;/a&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a29bb19075988ba4154f245cf61264e6c3403b" translate="yes" xml:space="preserve">
          <source>This trait is similar to &lt;em&gt;genericHead&lt;/em&gt;, but instead of producing error for non-generic types, it will just return them unmodified.</source>
          <target state="translated">이 특성은 &lt;em&gt;genericHead&lt;/em&gt; 와 유사 하지만 제네릭이 아닌 유형에 오류를 생성하는 대신 수정되지 않은 상태로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7ffbddf53bccfca8c9441dc5126a0ad4adef516e" translate="yes" xml:space="preserve">
          <source>This trait returns true if the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b73c4d12f30a07a08773a16f4683aba0e028b0" translate="yes" xml:space="preserve">
          <source>This trait returns true iff the type &lt;code&gt;t&lt;/code&gt; is safe to use for &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt;. Other languages name a type like these &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt;.</source>
          <target state="translated">이 특성은 유형 &lt;code&gt;t&lt;/code&gt; 가 &lt;span id=&quot;copymem_1&quot;&gt;copyMem&lt;/span&gt; 에 사용하기에 안전한 경우 true를 리턴합니다 . 다른 언어의 이름은 이러한 &lt;span id=&quot;blob_1&quot;&gt;blob&lt;/span&gt; 과 같은 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="3824e56a10ede7c713ffb39e26e88a788482118a" translate="yes" xml:space="preserve">
          <source>This transformation is only done if the varargs parameter is the last parameter in the procedure header. It is also possible to perform type conversions in this context:</source>
          <target state="translated">이 변환은 varargs 매개 변수가 프로 시저 헤더의 마지막 매개 변수 인 경우에만 수행됩니다. 이 컨텍스트에서 유형 변환을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d1986229bd95fd619538b360b3cc3585eddf09" translate="yes" xml:space="preserve">
          <source>This type contains a description of a person</source>
          <target state="translated">이 유형은 사람에 대한 설명을 포함합니다</target>
        </trans-unit>
        <trans-unit id="fbd40a9a943d55e10d3df8977110f491416639de" translate="yes" xml:space="preserve">
          <source>This uses saturated arithmetic, so that each color component cannot overflow (255 is used as a maximum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccecba9f8fd98b29868f4f80752b0322a7cb469c" translate="yes" xml:space="preserve">
          <source>This uses saturated arithmetic, so that each color component cannot underflow (0 is used as a minimum).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d9daad0926694b235ad99d9f58721fb3438862" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="translated">이것은 선형 메모리 오버 헤드만으로 &lt;span id=&quot;levenshtein_1&quot;&gt;Levenshtein&lt;/span&gt; 거리 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6b48430da58c59da89011fc9d5e023d5bae81854" translate="yes" xml:space="preserve">
          <source>This uses the &lt;span id=&quot;levenshtein_2&quot;&gt;Levenshtein&lt;/span&gt; distance algorithm with only a linear memory overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4922584a12b79a219eaa16925bbb909743a91e2e" translate="yes" xml:space="preserve">
          <source>This uses the algorithm specified in &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;section 5.2.2 of RFC 3986&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;RFC 3986의 섹션 5.2.2에&lt;/a&gt; 지정된 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e216d34b156aa03e46b15d955959dbcd959d74" translate="yes" xml:space="preserve">
          <source>This uses the configuration defined in &lt;code&gt;config\nim.cfg&lt;/code&gt; for &lt;code&gt;lvm_gcc&lt;/code&gt;.</source>
          <target state="translated">이에 정의 된 구성을 사용하여 &lt;code&gt;config\nim.cfg&lt;/code&gt; 에 대한 &lt;code&gt;lvm_gcc&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="94ac188fe1ac2d6a8cd8bd239dd487b9b38f11d0" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a &lt;strong&gt;starting parameter&lt;/strong&gt;. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5505a00f1063702f80a5818b1a5c8c32d61e3710" translate="yes" xml:space="preserve">
          <source>This version of &lt;code&gt;foldl&lt;/code&gt; gets a starting parameter. This makes it possible to accumulate the sequence into a different type than the sequence elements.</source>
          <target state="translated">이 버전의 &lt;code&gt;foldl&lt;/code&gt; 은 시작 매개 변수를 얻습니다. 이것에 의해, 시퀀스를 시퀀스 요소와 다른 타입으로 축적 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7bac1b6d0db41715df5581bb4825ea90b0b4190f" translate="yes" xml:space="preserve">
          <source>This will generate a file called &lt;code&gt;switchhomebrew.elf&lt;/code&gt; which can then be turned into an nro file with the &lt;code&gt;elf2nro&lt;/code&gt; tool in the DevkitPro release. Examples can be found at &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;the nim-libnx github repo&lt;/a&gt;.</source>
          <target state="translated">이것은라는 파일이 생성됩니다 &lt;code&gt;switchhomebrew.elf&lt;/code&gt; 그와 함께 NRO 파일로 전환 할 수 &lt;code&gt;elf2nro&lt;/code&gt; DevkitPro 릴리스 도구를. 예제는 &lt;a href=&quot;https://github.com/jyapayne/nim-libnx.git&quot;&gt;nim-libnx github repo&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26136905c2efd9e1d537dc87f61ea998287f6a6d" translate="yes" xml:space="preserve">
          <source>This will generate an index of all the exported symbols in the input Nim module, and put it into a neighboring file with the extension of &lt;code&gt;.idx&lt;/code&gt;. The index file is line oriented (newlines have to be escaped). Each line represents a tab separated record of several columns, the first two mandatory, the rest optional. See the &lt;a href=&quot;#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; section for details.</source>
          <target state="translated">입력 Nim 모듈에서 내 보낸 모든 심볼의 인덱스를 생성하고 확장자가 &lt;code&gt;.idx&lt;/code&gt; 인 인접 파일에 넣습니다 . 색인 파일은 줄 지향적입니다 (줄 바꿈을 이스케이프해야 함). 각 줄은 여러 열의 탭으로 구분 된 레코드를 나타내며 처음 두 개는 필수이며 나머지는 선택 사항입니다. 자세한 내용은 &lt;a href=&quot;#index-idx-file-format&quot;&gt;색인 (idx) 파일 형식&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ead03785f5fb54bd6190bd855d00357524e06d3" translate="yes" xml:space="preserve">
          <source>This will provide Hints in the compiler output either every time the concept is not matched or only on the particular call-site.</source>
          <target state="translated">이것은 개념이 일치하지 않거나 특정 콜 사이트에서만 컴파일러 출력에 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aa4705d432fb1b0185c67d13ccff0749b0afd34e" translate="yes" xml:space="preserve">
          <source>This will raise &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;future&lt;/code&gt; is finished.</source>
          <target state="translated">이것은 올릴 &lt;code&gt;ValueError&lt;/code&gt; 하면 &lt;code&gt;future&lt;/code&gt; 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="77dd0890df14804d1f6f5c6ad7d8c663331e013e" translate="yes" xml:space="preserve">
          <source>This will recursively generate documentation of all nim modules imported into the input module that belong to the Nimble package that &lt;code&gt;filename.nim&lt;/code&gt; belongs to.</source>
          <target state="translated">그러면 &lt;code&gt;filename.nim&lt;/code&gt; 이 속한 Nimble 패키지에 속하는 입력 모듈로 가져온 모든 nim 모듈에 대한 문서가 재귀 적으로 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="01e5c517031f780132f7de304e80ce21fd6382d8" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;.</source>
          <target state="translated">문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cd34efcb73d9e9a4a38033e49417a668da60801" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 . 유니 코드 문자에 사용할 수있는 버전 은 &lt;a href=&quot;unicode#toLower&quot;&gt;unicode.toLower&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d28e108b410326da5c7b53479c9b85473d7f8bc9" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower,Rune&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234fd83af98adae4a04fed787579367a1e8b539" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toLower,string&quot;&gt;unicode.toLower&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3189c7fd9700aaadbf4a4dd6af6df7937cf0b2d7" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="translated">문자 &lt;code&gt;A-Z&lt;/code&gt; 에만 적용됩니다 . 유니 코드 문자에 사용할 수있는 버전 은 &lt;a href=&quot;unicode#toUpper&quot;&gt;unicode.toUpper&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9616a4c434f44d69fc9dd652fbbd1ccf5a4d774" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper,Rune&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002ee894dde8162f608dbcae78b528d1a0a98f9" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. See &lt;a href=&quot;unicode#toUpper,string&quot;&gt;unicode.toUpper&lt;/a&gt; for a version that works for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8039b7fd0e6adffb69eb9d5e34ba51659c72eed" translate="yes" xml:space="preserve">
          <source>This works only for the letters &lt;code&gt;A-Z&lt;/code&gt;. Use &lt;a href=&quot;unicode&quot;&gt;Unicode module&lt;/a&gt; for UTF-8 support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc168569a3d857e9b97041d394676d2e416f6807" translate="yes" xml:space="preserve">
          <source>This would be any of the other idetools available options, like &lt;code&gt;--def&lt;/code&gt; or &lt;code&gt;--suggest&lt;/code&gt; explained in the following sections.</source>
          <target state="translated">다음 절에서 설명하는 &lt;code&gt;--def&lt;/code&gt; 또는 &lt;code&gt;--suggest&lt;/code&gt; 와 같은 다른 idetools 사용 가능한 옵션 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="3974135028a38a44142b8af58d9f501e1acc3c71" translate="yes" xml:space="preserve">
          <source>This zero copy, memchr-limited interface is probably the fastest way to iterate over line-like records in a file. However, returned (data,size) objects are not Nim strings, bounds checked Nim arrays, or even terminated C strings. So, care is required to access the data (e.g., think C mem* functions, not str* functions).</source>
          <target state="translated">이 사본이없는 memchr- 제한된 인터페이스는 아마도 파일에서 줄 같은 레코드를 반복하는 가장 빠른 방법 일 것입니다. 그러나 반환 된 (데이터, 크기) 객체는 Nim 문자열이 아니거나, 검사 된 Nim 배열 또는 종료 된 C 문자열이 아닙니다. 따라서 데이터에 액세스하려면주의를 기울여야합니다 (예 : str * 함수가 아닌 C mem * 함수를 생각하십시오).</target>
        </trans-unit>
        <trans-unit id="3f848317832fae19e0085de9e23738862798395f" translate="yes" xml:space="preserve">
          <source>Though it should be pretty obvious what the program does, I will explain the syntax: statements which are not indented are executed when the program starts. Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed.</source>
          <target state="translated">프로그램이 무엇을하는지는 분명해야하지만, 프로그램이 시작될 때 들여 쓰기되지 않은 문장이 실행됩니다. 들여 쓰기는 님의 문장을 그룹화하는 방법입니다. 들여 쓰기는 공백으로 만 수행되며 테이블 작성기는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d02e1b27f5da6165217ae6af04fef8718253485" translate="yes" xml:space="preserve">
          <source>Though the Nim Standard Library is still evolving, it is already quite usable. It is divided into &lt;em&gt;pure libraries&lt;/em&gt;, &lt;em&gt;impure libraries&lt;/em&gt; and &lt;em&gt;wrappers&lt;/em&gt;.</source>
          <target state="translated">Nim 표준 라이브러리는 여전히 발전하고 있지만 이미 사용 가능합니다. &lt;em&gt;순수한 라이브러리&lt;/em&gt; , &lt;em&gt;불순한 라이브러리&lt;/em&gt; 및 &lt;em&gt;랩퍼&lt;/em&gt; 로 나뉩니다 .</target>
        </trans-unit>
        <trans-unit id="b4cc7e4d5579d2abc9a379f6ffd100e925cda3b1" translate="yes" xml:space="preserve">
          <source>Thread coordination</source>
          <target state="translated">스레드 조정</target>
        </trans-unit>
        <trans-unit id="59a7e2e5a99004361b87c2d5390e14c75d8f283e" translate="yes" xml:space="preserve">
          <source>Thread pragma</source>
          <target state="translated">스레드 프라 그마</target>
        </trans-unit>
        <trans-unit id="1e7adbec474ff10a2fb8698f0489cdf3b418554b" translate="yes" xml:space="preserve">
          <source>Thread support for Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb1d54b91c07f35c7604f3ddd4b6f833468ea9ba" translate="yes" xml:space="preserve">
          <source>Thread support for Nim. &lt;strong&gt;Note&lt;/strong&gt;: This is part of the system module. Do not import it directly. To activate thread support you need to compile with the &lt;code&gt;--threads:on&lt;/code&gt; command line switch.</source>
          <target state="translated">Nim에 대한 스레드 지원. &lt;strong&gt;참고&lt;/strong&gt; : 이것은 시스템 모듈의 일부입니다. 직접 가져 오지 마십시오. 스레드 지원을 활성화하려면 &lt;code&gt;--threads:on&lt;/code&gt; 명령 행 스위치 를 사용하여 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="efcacaedc288d5f1ee9e06293407eb061bd561ea" translate="yes" xml:space="preserve">
          <source>Threads and exceptions</source>
          <target state="translated">스레드와 예외</target>
        </trans-unit>
        <trans-unit id="9e9af3f7a423d176c8e989c93a406d4e77eaeeca" translate="yes" xml:space="preserve">
          <source>Threadvar pragma</source>
          <target state="translated">Threadvar Pragma</target>
        </trans-unit>
        <trans-unit id="7c599a1317d70c1913cfd27374ce0f1835f7e408" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. &lt;code&gt;def&lt;/code&gt; for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">반환 된 답변의 유형을 나타내는 세 문자 (예 : 정의의 &lt;code&gt;def&lt;/code&gt; , 제안의 &lt;code&gt;sug&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="cb0fdc12f844b31a8cf54439d51d7813e5ece7c9" translate="yes" xml:space="preserve">
          <source>Three characters indicating the type of returned answer (e.g. def for definition, &lt;code&gt;sug&lt;/code&gt; for suggestion, etc).</source>
          <target state="translated">반환 된 답변의 유형을 나타내는 세 문자 (예 : 정의의 def, 제안의 &lt;code&gt;sug&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="04a4b67d34c6ea267e9e2aa731f12d8004957357" translate="yes" xml:space="preserve">
          <source>Three letter string which indicates the day of the week.</source>
          <target state="translated">요일을 나타내는 3 글자 문자열.</target>
        </trans-unit>
        <trans-unit id="166b5ad7cdc1ddb77e376400c9f9b2e942b944d7" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where certain safety checks are omitted for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="translated">관통 &lt;code&gt;-d:x&lt;/code&gt; 또는 &lt;code&gt;--define:x&lt;/code&gt; 조건부 컴파일 시간을 컴파일 기호를 정의 할 수 있습니다 전환합니다. 정의 된 스위치는 함께 소스 코드에서 확인할 수 있습니다 &lt;a href=&quot;manual#when-statement&quot;&gt;때 문&lt;/a&gt; 및 &lt;a href=&quot;system#defined&quot;&gt;정의 PROC&lt;/a&gt; . 이 스위치의 일반적인 용도는 성능 향상을 위해 특정 안전 점검이 생략 된 릴리스 모드 ( &lt;code&gt;-d:release&lt;/code&gt; )에서 빌드를 활성화하는 것입니다 . 다른 일반적인 용도는 SSL 소켓을 활성화하기 위한 &lt;code&gt;-d:ssl&lt;/code&gt; 스위치입니다.</target>
        </trans-unit>
        <trans-unit id="b77791f49945f5e1a1fc02beea100a1fbe48fd06" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;-d:x&lt;/code&gt; or &lt;code&gt;--define:x&lt;/code&gt; switch you can define compile-time symbols for conditional compilation. The defined switches can be checked in source code with the &lt;a href=&quot;manual#statements-and-expressions-when-statement&quot;&gt;when statement&lt;/a&gt; and &lt;a href=&quot;system#defined,untyped&quot;&gt;defined proc&lt;/a&gt;. The typical use of this switch is to enable builds in release mode (&lt;code&gt;-d:release&lt;/code&gt;) where optimizations are enabled for better performance. Another common use is the &lt;code&gt;-d:ssl&lt;/code&gt; switch to activate SSL sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053686996ea91f5f0bd8bfc5be9311b2dfb9563b" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;nimsuggest&lt;/code&gt; tool, any IDE can query a &lt;code&gt;.nim&lt;/code&gt; source file and obtain useful information like definition of symbols or suggestions for completion.</source>
          <target state="translated">가장 &lt;code&gt;nimsuggest&lt;/code&gt; 도구를 통해 모든 IDE는 &lt;code&gt;.nim&lt;/code&gt; 소스 파일을 쿼리하고 심볼 정의 또는 완성 제안과 같은 유용한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645311b7482290ae055f08a018122a58f2c3b9eb" translate="yes" xml:space="preserve">
          <source>Through the use of the optional &lt;code&gt;{.raises.}&lt;/code&gt; pragma you can specify that a proc is meant to raise a specific set of exceptions, or none at all. If the &lt;code&gt;{.raises.}&lt;/code&gt; pragma is used, the compiler will verify that this is true. For instance, if you specify that a proc raises &lt;code&gt;IOError&lt;/code&gt;, and at some point it (or one of the procs it calls) starts raising a new exception the compiler will prevent that proc from compiling. Usage example:</source>
          <target state="translated">선택적 &lt;code&gt;{.raises.}&lt;/code&gt; pragma를 사용하여 proc이 특정 예외 세트를 발생 시키거나 전혀 발생하지 않도록 지정할 수 있습니다. 는 IF &lt;code&gt;{.raises.}&lt;/code&gt; 프라그를 사용하는 컴파일러는이 사실임을 확인합니다. 예를 들어, proc이 &lt;code&gt;IOError&lt;/code&gt; 를 발생 시키도록 지정 하고 어느 시점에서 (또는 호출 하는 프로세서 중 하나) 새로운 예외가 발생하기 시작하면 컴파일러는 해당 proc이 컴파일되지 못하게합니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="7e4ee67f0e9e151a472bd4d369d44933d3da7821" translate="yes" xml:space="preserve">
          <source>Thrown in the &lt;code&gt;getContent&lt;/code&gt; proc and &lt;code&gt;postContent&lt;/code&gt; proc, when the server returns an error</source>
          <target state="translated">에 슬로우 &lt;code&gt;getContent&lt;/code&gt; PROC 및 &lt;code&gt;postContent&lt;/code&gt; 의 서버가 오류를 반환 PROC,</target>
        </trans-unit>
        <trans-unit id="03d3eb95788413ec11f05c2375f128ca82e7acba" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;code&gt;errorMsgExpected&lt;/code&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37977e3077bc9851c1ffd00107b486f2f8f09038" translate="yes" xml:space="preserve">
          <source>Thus the checks would have been very difficult to implement properly with little benefit, especially since they are simple to implement in the client. The client should use the &lt;em&gt;errorMsgExpected&lt;/em&gt; proc to generate a nice error message that fits the other error messages this library creates.</source>
          <target state="translated">따라서 검사는 클라이언트에서 구현하기가 간단하기 때문에 이점이 거의없이 제대로 구현하기가 매우 어려웠습니다. 클라이언트는 &lt;em&gt;errorMsgExpected&lt;/em&gt; proc를 사용 하여이 라이브러리가 생성하는 다른 오류 메시지에 맞는 멋진 오류 메시지를 생성 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d39bb08fac5f6360feb78a680d458fc658579909" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">따라서 일반 식별자보다 키워드와 유사하게 작동합니다. A는 그러나 키워드 달리 재정의 할 수 &lt;span id=&quot;shadow_1&quot;&gt;그림자&lt;/span&gt; 의 정의 &lt;code&gt;system&lt;/code&gt; 모듈을. 이 목록에서 다음이로 작성해서는 안 점 표기법 &lt;code&gt;x.f&lt;/code&gt; 이후 &lt;code&gt;x&lt;/code&gt; 가 이 전달되기 전에 유형을 확인할 수 없습니다 &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d79fc7d78ae54d780ab0a897b4c2f9e3e7adc79" translate="yes" xml:space="preserve">
          <source>Thus they act more like keywords than like ordinary identifiers; unlike a keyword however, a redefinition may &lt;span id=&quot;shadow_1&quot;&gt;shadow&lt;/span&gt; the definition in the &lt;code&gt;system&lt;/code&gt; module. From this list the following should not be written in dot notation &lt;code&gt;x.f&lt;/code&gt; since &lt;code&gt;x&lt;/code&gt; cannot be type-checked before it gets passed to &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee323ffc9625d6bc28b4f8cc717e26ebd77ac1a" translate="yes" xml:space="preserve">
          <source>Thus, north &amp;lt; east &amp;lt; south &amp;lt; west. The comparison operators can be used with enumeration types. Instead of &lt;code&gt;north&lt;/code&gt; etc, the enum value can also be qualified with the enum type that it resides in, &lt;code&gt;Direction.north&lt;/code&gt;.</source>
          <target state="translated">따라서 북쪽 &amp;lt;동쪽 &amp;lt;남쪽 &amp;lt;서쪽입니다. 비교 연산자는 열거 유형과 함께 사용할 수 있습니다. &lt;code&gt;north&lt;/code&gt; 등 대신에 열거 형 값을 &lt;code&gt;Direction.north&lt;/code&gt; 에있는 열거 형 유형으로 한정 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4b8a59ee4623c1899387bf6de6586afc3a5dc2" translate="yes" xml:space="preserve">
          <source>Time components are subtracted one-by-one, see output:</source>
          <target state="translated">시간 구성 요소는 하나씩 뺍니다 (출력 참조).</target>
        </trans-unit>
        <trans-unit id="3fb812b32f09c8031753f69acac0c61789f34460" translate="yes" xml:space="preserve">
          <source>Time effect.</source>
          <target state="translated">시간 효과.</target>
        </trans-unit>
        <trans-unit id="7a03fc1f8577334bd0ba540d8fe94c1c217d7663" translate="yes" xml:space="preserve">
          <source>Time handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3ccfa05db1ce4bb37a133e936dac6618864488" translate="yes" xml:space="preserve">
          <source>Time measurement</source>
          <target state="translated">시간 측정</target>
        </trans-unit>
        <trans-unit id="9d68e0ad84b52240f2e76d776405ad96e1165a01" translate="yes" xml:space="preserve">
          <source>Time measurement with garbage collectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98089835cc8515ca7a14ba6cd9c114f2b93470b4" translate="yes" xml:space="preserve">
          <source>TimeInterval</source>
          <target state="translated">TimeInterval</target>
        </trans-unit>
        <trans-unit id="f4fb52fb2152cd12040e0a822c3f35572a335a53" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;d&lt;/code&gt; days.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 일의 시간 간격</target>
        </trans-unit>
        <trans-unit id="45493a2f2864af1ad59f4e6002d36f0afb4f0012" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;h&lt;/code&gt; hours.</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; 시간 의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="48a2bec4e7d8f08615b4a69538e1d873fd8cabd4" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; minutes.</source>
          <target state="translated">의 TimeInterval이 &lt;code&gt;m&lt;/code&gt; 의 분.</target>
        </trans-unit>
        <trans-unit id="fd8b1b84cf164e73ebf16147dec8fe94eb87b149" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;m&lt;/code&gt; months.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 개월의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="2e35c45093c4c75c76cc0ad1730384cf89bc1aab" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;micros&lt;/code&gt; microseconds.</source>
          <target state="translated">&lt;code&gt;micros&lt;/code&gt; 초의 TimeInterval .</target>
        </trans-unit>
        <trans-unit id="571851bb6763be044dfb20a43ad6453fa502f0ca" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;ms&lt;/code&gt; 간격 ( 밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="a0a7b6a6e6dabdcbf91694569154f0821829247a" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;nanos&lt;/code&gt; nanoseconds.</source>
          <target state="translated">&lt;code&gt;nanos&lt;/code&gt; 나노초 의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="843631ff0523a6f86df81cbca0448371ae88177c" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;s&lt;/code&gt; seconds.</source>
          <target state="translated">의 TimeInterval이 &lt;code&gt;s&lt;/code&gt; 초.</target>
        </trans-unit>
        <trans-unit id="bdc17d9ec9d80bdf5f4294a7ade05be0d237182e" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;w&lt;/code&gt; weeks.</source>
          <target state="translated">&lt;code&gt;w&lt;/code&gt; 주의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="77b05f6f1a5def9a860eb63a1be452d2e901c363" translate="yes" xml:space="preserve">
          <source>TimeInterval of &lt;code&gt;y&lt;/code&gt; years.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 년의 시간 간격 .</target>
        </trans-unit>
        <trans-unit id="27a4f2c5a6aa7d957af2668e0ec53e32944aba26" translate="yes" xml:space="preserve">
          <source>Timeouts</source>
          <target state="translated">Timeouts</target>
        </trans-unit>
        <trans-unit id="f7ce4ce477d909626616b9bc1923c16e96624252" translate="yes" xml:space="preserve">
          <source>Timer support for the realtime GC. Based on &lt;a href=&quot;https://github.com/jckarter/clay/blob/master/compiler/hirestimer.cpp&quot;&gt;https://github.com/jckarter/clay/blob/master/compiler/hirestimer.cpp&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbd71a2dd6f5fad9c94891375be2effb56321a4" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;a href=&quot;#DateTime&quot;&gt;DateTime&lt;/a&gt;s of arbitrary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49563f216566fe13f36b6d6f96d904d2f0012073" translate="yes" xml:space="preserve">
          <source>Timezone interface for supporting &lt;code&gt;DateTime&lt;/code&gt;'s of arbritary timezones. The &lt;code&gt;times&lt;/code&gt; module only supplies implementations for the systems local time and UTC.</source>
          <target state="translated">임의 시간대의 &lt;code&gt;DateTime&lt;/code&gt; 을 지원하기위한 시간대 인터페이스 . &lt;code&gt;times&lt;/code&gt; 시스템 현지 시간과 UTC 만 공급 구현을 모듈.</target>
        </trans-unit>
        <trans-unit id="005f759cb3d18c4ae00a285a0712a53038aa8ad6" translate="yes" xml:space="preserve">
          <source>To &lt;em&gt;invoke&lt;/em&gt; a template, call it like a procedure.</source>
          <target state="translated">템플릿 을 &lt;em&gt;호출&lt;/em&gt; 하려면 프로 시저처럼 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="6ce1339a3fbb20d91263c5b8ca905cfc7af9e20c" translate="yes" xml:space="preserve">
          <source>To access multiple values of a key, use the overloaded &lt;code&gt;[]&lt;/code&gt; below or to get all of them access the &lt;code&gt;table&lt;/code&gt; field directly.</source>
          <target state="translated">키의 여러 값에 액세스하려면 아래 의 오버로드 된 &lt;code&gt;[]&lt;/code&gt; 를 사용하거나 모든 값이 &lt;code&gt;table&lt;/code&gt; 필드에 직접 액세스하도록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a8854509b79b921922ff284c021ca2226c66887" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; has to be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The documentation of the system module contains further information.</source>
          <target state="translated">새로운 추적 객체를 할당하려면 내장 프로 시저 &lt;code&gt;new&lt;/code&gt; 를 사용해야합니다. 추적되지 않은 메모리를 처리하기 위해 &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; 및 &lt;code&gt;realloc&lt;/code&gt; 프로 시저를 사용할 수 있습니다. 시스템 모듈 설명서에는 추가 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b75bdb6d108ccec959da5a9406fd4ee6f129b2" translate="yes" xml:space="preserve">
          <source>To allocate a new traced object, the built-in procedure &lt;code&gt;new&lt;/code&gt; must be used. To deal with untraced memory, the procedures &lt;code&gt;alloc&lt;/code&gt;, &lt;code&gt;dealloc&lt;/code&gt; and &lt;code&gt;realloc&lt;/code&gt; can be used. The &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module's documentation contains further details.</source>
          <target state="translated">새로운 추적 오브젝트를 할당하려면 내장 프로 시저 &lt;code&gt;new&lt;/code&gt; 를 사용해야합니다. 추적되지 않은 메모리를 처리하기 위해 &lt;code&gt;alloc&lt;/code&gt; , &lt;code&gt;dealloc&lt;/code&gt; 및 &lt;code&gt;realloc&lt;/code&gt; 프로 시저를 사용할 수 있습니다. &lt;a href=&quot;system&quot;&gt;시스템&lt;/a&gt; 모듈의 문서는 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e078eeb299e1530ea0a1c7ae42a41d998f5aecf7" translate="yes" xml:space="preserve">
          <source>To be documented.</source>
          <target state="translated">문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="00e012bc8e89aa9418caf9860b1e2d2f2d1a0432" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;code&gt;s&lt;/code&gt; is preallocated with an additional amount equal to the byte length of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4aa18bea852a508605d53caeef9c5f926d90dc" translate="yes" xml:space="preserve">
          <source>To be the most efficient, make sure &lt;em&gt;s&lt;/em&gt; is preallocated with an additional amount equal to the byte length of &lt;em&gt;c&lt;/em&gt;.</source>
          <target state="translated">가장 효율적으로 만들 려면 바이트 길이 &lt;em&gt;c&lt;/em&gt; 와 동일한 추가 양으로 &lt;em&gt;s&lt;/em&gt; 를 미리 할당해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2e8cced600feca55a223908d10e5130220dfada" translate="yes" xml:space="preserve">
          <source>To be used when diffing times. Consider using &lt;em&gt;between&lt;/em&gt; instead.</source>
          <target state="translated">디핑 시간에 사용됩니다. 대신 &lt;em&gt;사이&lt;/em&gt; 를 사용하는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="9599c6de97f8d0342f31be2e0d82a6fa8e679162" translate="yes" xml:space="preserve">
          <source>To be written.</source>
          <target state="translated">쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e63287bf2192ba9bdf47d785bd859bfea604a0" translate="yes" xml:space="preserve">
          <source>To call a procedure that returns a value just for its side effects and ignoring its return value, a &lt;code&gt;discard&lt;/code&gt; statement &lt;strong&gt;must&lt;/strong&gt; be used. Nim does not allow silently throwing away a return value:</source>
          <target state="translated">부작용에 대해서만 값을 리턴하고 리턴 값을 무시하는 프로 시저를 호출하려면 &lt;code&gt;discard&lt;/code&gt; 명령문을 &lt;strong&gt;사용해야&lt;/strong&gt; 합니다. Nim은 리턴 값을 자동으로 버릴 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbd6812cedca0f8d3ecee1c4880b1874c327d444" translate="yes" xml:space="preserve">
          <source>To change the compiler from the default compiler (at the command line):</source>
          <target state="translated">명령 행에서 기본 컴파일러에서 컴파일러를 변경하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1d675135247ec07f554ba8d3985a64fe7d37897a" translate="yes" xml:space="preserve">
          <source>To choose the memory management strategy use the &lt;code&gt;--gc:&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0088b38a72221b3666a3e4577722f03717e36918" translate="yes" xml:space="preserve">
          <source>To compensate, the standard library has modules &lt;a href=&quot;lib#pure-libraries-modules-for-js-backend&quot;&gt;catered to the JS backend&lt;/a&gt; and more support will come in the future (for instance, Node.js bindings to get OS info).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19383e7fc36ba5267d99a080abfc1737c7f18bc" translate="yes" xml:space="preserve">
          <source>To compile a &lt;span id=&quot;dangerous-release-build_1&quot;&gt;dangerous release build&lt;/span&gt; define the &lt;code&gt;danger&lt;/code&gt; symbol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e14482cffd7a387356de093fd85fe0f7385173" translate="yes" xml:space="preserve">
          <source>To compile a Nim module into a &lt;code&gt;.js&lt;/code&gt; file use the &lt;code&gt;js&lt;/code&gt; command; the default is a &lt;code&gt;.js&lt;/code&gt; file that is supposed to be referenced in an &lt;code&gt;.html&lt;/code&gt; file. However, you can also run the code with &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; (&lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt;):</source>
          <target state="translated">Nim 모듈을 &lt;code&gt;.js&lt;/code&gt; 파일 로 컴파일하려면 &lt;code&gt;js&lt;/code&gt; 명령을 사용하십시오 . 기본값은 &lt;code&gt;.html&lt;/code&gt; 파일 에서 참조되어야 하는 &lt;code&gt;.js&lt;/code&gt; 파일입니다 . 그러나 &lt;span id=&quot;nodejs_1&quot;&gt;nodejs&lt;/span&gt; ( &lt;a href=&quot;http://nodejs.org&quot;&gt;http://nodejs.org&lt;/a&gt; )를 사용 하여 코드를 실행할 수도 있습니다 .&lt;span id=&quot;nodejs_1&quot;&gt;&lt;/span&gt;</target>
        </trans-unit>
        <trans-unit id="94b72107dca9af29a5cf8e0cbfd67507a7bbcd4c" translate="yes" xml:space="preserve">
          <source>To compile a release version use:</source>
          <target state="translated">릴리스 버전을 컴파일하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f801814ad063fdd28a5552ef1cb208d05b01510" translate="yes" xml:space="preserve">
          <source>To compute power between integers (e.g. 2^6), use &lt;a href=&quot;#%5E,T,Natural&quot;&gt;^ proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dace50e38237573560e76fd9fe662d2da1a4dc" translate="yes" xml:space="preserve">
          <source>To compute power between integers, use &lt;em&gt;^&lt;/em&gt; e.g. 2 ^ 6</source>
          <target state="translated">정수 사이의 거듭 제곱을 계산하려면 &lt;em&gt;^를&lt;/em&gt; 사용하십시오. 예 : 2 ^ 6</target>
        </trans-unit>
        <trans-unit id="4e1e5cf85172e7687329245173ff57b79c54d5ed" translate="yes" xml:space="preserve">
          <source>To create a new &lt;code&gt;Duration&lt;/code&gt;, use &lt;a href=&quot;#initDuration,int64,int64,int64,int64,int64,int64,int64,int64&quot;&gt;initDuration proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfec38068b998d71adfbd1d224349d1732adf770" translate="yes" xml:space="preserve">
          <source>To create a new &lt;code&gt;TimeFormat&lt;/code&gt; use &lt;a href=&quot;#initTimeFormat,string&quot;&gt;initTimeFormat proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d351e4cf238073c675c29349e5026ed8e407aa" translate="yes" xml:space="preserve">
          <source>To create a new compiler for each run, use &lt;code&gt;koch temp&lt;/code&gt;:</source>
          <target state="translated">각 실행에 대해 새 컴파일러를 작성하려면 &lt;code&gt;koch temp&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="55053d7dbb6eec73712afca1d06925e6eb2fac3c" translate="yes" xml:space="preserve">
          <source>To cross compile, use for example:</source>
          <target state="translated">크로스 컴파일하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="11a7709cee7ccc11aa34460a13e3a236b452d950" translate="yes" xml:space="preserve">
          <source>To cross-compile for Windows from Linux or macOS using the MinGW-w64 toolchain:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f91945ed5921e2c3fd56557cac05da24a1e0e3" translate="yes" xml:space="preserve">
          <source>To cross-compile for iOS you need to be on a macOS computer and use XCode. Normal languages for iOS development are Swift and Objective C. Both of these use LLVM and can be compiled into object files linked together with C, C++ or Objective C code produced by Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e0b2d9936526053d98cae64c97e80a452c5953" translate="yes" xml:space="preserve">
          <source>To decode a base64 encoded data string simply call the &lt;code&gt;decode&lt;/code&gt; procedure:</source>
          <target state="translated">base64로 인코딩 된 데이터 문자열을 디코딩하려면 간단히 &lt;code&gt;decode&lt;/code&gt; 절차 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff5be3702ce16d9f83c4069146c2c5cbe57cdba3" translate="yes" xml:space="preserve">
          <source>To define a new operator enclose the operator in backticks &quot;``&quot;:</source>
          <target state="translated">새 연산자를 정의하려면 연산자를 백틱 &quot;&quot; &quot;으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="bb15e30b9d578a4da7a5878df01aeed724c88088" translate="yes" xml:space="preserve">
          <source>To define new commands like &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; and &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; in the examples, the concept of a &lt;em&gt;procedure&lt;/em&gt; is needed. (Some languages call them &lt;em&gt;methods&lt;/em&gt; or &lt;em&gt;functions&lt;/em&gt;.) In Nim new procedures are defined with the &lt;code&gt;proc&lt;/code&gt; keyword:</source>
          <target state="translated">예제에서 &lt;a href=&quot;system#echo&quot;&gt;echo&lt;/a&gt; 및 &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; 과 같은 새 명령을 정의하려면 &lt;em&gt;프로 시저&lt;/em&gt; 개념 이 필요합니다. (일부 언어 에서는 &lt;em&gt;메소드&lt;/em&gt; 또는 &lt;em&gt;함수&lt;/em&gt; 라고 부릅니다 .) Nim에서 새로운 프로시 저는 &lt;code&gt;proc&lt;/code&gt; 키워드 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ffd042c88fd638ec0eb1bc11b67961325aa17c18" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;code&gt;documentation&lt;/code&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;code&gt;generated API&lt;/code&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb3cbb5f800fd3864fa68084a11d47c5e74ac25" translate="yes" xml:space="preserve">
          <source>To differentiate between a documentation and API file a convention is used: indices which contain one entry without the HTML hash character (#) will be considered &lt;em&gt;documentation&lt;/em&gt;, since this hash-less entry is the explicit title of the document. Indices without this explicit entry will be considered &lt;em&gt;generated API&lt;/em&gt; extracted out of a source &lt;code&gt;.nim&lt;/code&gt; file.</source>
          <target state="translated">문서와 API 파일을 구별하기 위해 규칙이 사용됩니다. HTML 해시 문자 (#)없이 하나의 항목을 포함하는 색인은 &lt;em&gt;문서&lt;/em&gt; 로 간주됩니다. 이 해시리스 항목은 문서의 명시적인 제목이기 때문입니다. 이 명시적인 항목이없는 인덱스 는 소스 &lt;code&gt;.nim&lt;/code&gt; 파일에서 추출 된 &lt;em&gt;생성 된 API&lt;/em&gt; 로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="42c41b02b95231a84de881a8a918eb15cfd5edbe" translate="yes" xml:space="preserve">
          <source>To differentiate both types (documents and APIs), the index generator will add to the index of documents an entry with the title of the document. Since the title is the topmost element, it will be added with a second field containing just the filename without any HTML anchor. By convention this entry without anchor is the &lt;em&gt;title entry&lt;/em&gt;, and since entries in the index file are added as they are scanned, the title entry will be the first line. The title for APIs is not present because it can be generated concatenating the name of the file to the word &lt;strong&gt;Module&lt;/strong&gt;.</source>
          <target state="translated">두 유형 (문서 및 API)을 구별하기 위해 색인 생성기는 문서 제목이있는 항목을 문서 색인에 추가합니다. 제목이 최상위 요소이므로 HTML 앵커없이 파일 이름 만 포함하는 두 번째 필드가 추가됩니다. 일반적으로 앵커가없는이 항목은 &lt;em&gt;제목 항목&lt;/em&gt; 이며 색인 파일의 항목이 스캔 될 때 추가되므로 제목 항목이 첫 번째 행이됩니다. 파일 이름을 &lt;strong&gt;Module&lt;/strong&gt; 단어에 연결하여 생성 할 수 있으므로 API 제목이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bef5a818796377280bc3642d6382ec51f107837f" translate="yes" xml:space="preserve">
          <source>To enable it for a section of code, one can use &lt;code&gt;{.push sinkInference: on.}&lt;/code&gt;...`{.pop.}`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43995c5af49127cb76e1c6ca0a761449448d15fe" translate="yes" xml:space="preserve">
          <source>To enable real-time support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the garbage collector supports the following operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee4e0702447b58e78b6bb613d5d237b6836e9f3" translate="yes" xml:space="preserve">
          <source>To enable realtime support, the symbol &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; needs to be defined via &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; (you can put this into your config file as well). With this switch the GC supports the following operations:</source>
          <target state="translated">실시간 지원을 활성화하려면 &lt;span id=&quot;userealtimegc_1&quot;&gt;useRealtimeGC&lt;/span&gt; 심볼을 &lt;span id=&quot;userealtimegc_1&quot;&gt;--define &lt;/span&gt; &lt;code&gt;--define:useRealtimeGC&lt;/code&gt; 를 통해 정의 해야합니다 (이를 구성 파일에도 넣을 수 있음). 이 스위치를 사용하여 GC는 다음 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7636be4ab67a90f1533c1be5ea8689d1d192cf03" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low level thread API. There are also high level parallelism constructs available. See &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="translated">스레드 지원을 활성화하려면 &lt;code&gt;--threads:on&lt;/code&gt; 명령 행 스위치를 사용해야합니다. &lt;code&gt;system&lt;/code&gt; 모듈은 여러 스레딩 기본 요소가 포함되어 있습니다. 저수준 스레드 API에 대해서는 &lt;a href=&quot;threads&quot;&gt;스레드&lt;/a&gt; 및 &lt;a href=&quot;channels&quot;&gt;채널&lt;/a&gt; 모듈을 참조하십시오 . 높은 수준의 병렬 구조가 있습니다. 자세한 내용은 &lt;a href=&quot;#parallel-spawn&quot;&gt;스폰&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8db9266812e26b3af9d81dc1d4af73baeb7b7a0b" translate="yes" xml:space="preserve">
          <source>To enable thread support the &lt;code&gt;--threads:on&lt;/code&gt; command-line switch needs to be used. The &lt;code&gt;system&lt;/code&gt; module then contains several threading primitives. See the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;channels&quot;&gt;channels&lt;/a&gt; modules for the low-level thread API. There are also high-level parallelism constructs available. See &lt;a href=&quot;manual_experimental#parallel-amp-spawn&quot;&gt;spawn&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f67214a98c7af6393e104288de7c2a4eb6ee46" translate="yes" xml:space="preserve">
          <source>To execute a program without having a shell involved, use &lt;a href=&quot;osproc#execProcess,string,string,openArray%5Bstring%5D,StringTableRef,set%5BProcessOption%5D&quot;&gt;osproc.execProcess proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0f5e0bd57a707dc272d6bdaa13536fe61b6dd8" translate="yes" xml:space="preserve">
          <source>To find the name of a nimble package the compiler searches for a &lt;code&gt;*.nimble&lt;/code&gt; file in the parent directory hierarchy of whatever module you are compiling. Even if you are in a subdirectory of your project, a parent &lt;code&gt;*.nimble&lt;/code&gt; file will influence the naming of the nimcache name. This means that on Unix systems creating the file &lt;code&gt;~/foo.nimble&lt;/code&gt; will automatically prefix all nimcache files not part of another package with the string &lt;code&gt;foo_&lt;/code&gt;.</source>
          <target state="translated">민첩 패키지의 이름을 찾기 위해 컴파일러 는 컴파일하는 모듈의 상위 디렉토리 계층에서 &lt;code&gt;*.nimble&lt;/code&gt; 파일을 검색합니다 . 프로젝트의 하위 디렉토리에 &lt;code&gt;*.nimble&lt;/code&gt; 상위 * .nimble 파일은 nimcache 이름의 이름에 영향을줍니다. 이것은 유닉스 시스템에서 &lt;code&gt;~/foo.nimble&lt;/code&gt; 파일을 생성하면 다른 패키지의 일부가 아닌 모든 nimcache 파일 앞에 문자열 &lt;code&gt;foo_&lt;/code&gt; 가 붙는다 는 것을 자동으로 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="8ab93f39bb400a5b2494d8a733289a48baa43e8f" translate="yes" xml:space="preserve">
          <source>To force a full collection call &lt;code&gt;GC_fullCollect&lt;/code&gt;. Note that it is generally better to let the GC do its work and not enforce a full collection.</source>
          <target state="translated">전체 콜렉션을 강제 실행하려면 &lt;code&gt;GC_fullCollect&lt;/code&gt; 를 호출 하십시오 . 일반적으로 GC가 작업을 수행하고 전체 수집을 시행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83582671ff318357a306f2d73afcc6c6193db0e5" translate="yes" xml:space="preserve">
          <source>To generate an AST we would need to intimately know the structures used by the Nim compiler exposed in the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt;, which at first look seems a daunting task. But we can use as helper shortcut the &lt;a href=&quot;macros#dumpTree&quot;&gt;dumpTree macro&lt;/a&gt;, which is used as a statement macro instead of an expression macro. Since we know that we want to generate a bunch of &lt;code&gt;const&lt;/code&gt; symbols we can create the following source file and compile it to see what the compiler &lt;em&gt;expects&lt;/em&gt; from us:</source>
          <target state="translated">AST를 생성하려면 &lt;a href=&quot;macros&quot;&gt;macros 모듈에&lt;/a&gt; 노출 된 Nim 컴파일러가 사용하는 구조를 자세히 알아야합니다 . 처음에는 어려운 작업입니다. 그러나 &lt;a href=&quot;macros#dumpTree&quot;&gt;덤프 매크로&lt;/a&gt; 를 도우미 단축키로 사용할 수 있습니다. dumpTree 매크로 는 표현식 매크로 대신 명령문 매크로로 사용됩니다. 우리는 많은 &lt;code&gt;const&lt;/code&gt; 심볼 을 생성하고 싶다는 것을 알고 있으므로 다음 소스 파일을 생성하고 컴파일하여 컴파일러 가 우리에게 &lt;em&gt;기대&lt;/em&gt; 하는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48e80bf64e7a28669c506f4ab558d9ed800f9037" translate="yes" xml:space="preserve">
          <source>To get rid of hygiene in templates, one can use the &lt;span id=&quot;dirty_1&quot;&gt;dirty&lt;/span&gt; pragma for a template. &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; have no effect in &lt;code&gt;dirty&lt;/code&gt; templates.</source>
          <target state="translated">템플릿에서 위생을 제거하기 위해 템플릿에 &lt;span id=&quot;dirty_1&quot;&gt;더티&lt;/span&gt; pragma를 사용할 수 있습니다 . &lt;code&gt;inject&lt;/code&gt; 및 &lt;code&gt;gensym&lt;/code&gt; 은 &lt;code&gt;dirty&lt;/code&gt; 템플릿에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="58450466735ada0fbb487e804b99bbb91cc0bc78" translate="yes" xml:space="preserve">
          <source>To get started, first create a logger:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880901e6af0187dc97108dbae586cf60f49f512f" translate="yes" xml:space="preserve">
          <source>To get started, here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185ba609c2d82dc814e3d0e957a35bb0c0f0e77b" translate="yes" xml:space="preserve">
          <source>To get the directory containing the current source, use it with &lt;a href=&quot;os#parentDir%2Cstring&quot;&gt;os.parentDir()&lt;/a&gt; as &lt;code&gt;currentSourcePath.parentDir()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f3a2ffb603c43346bb1ea2785b67acec3d702" translate="yes" xml:space="preserve">
          <source>To give a footstart to writing macros we will show now how to turn your typical dynamic code into something that compiles statically. For the exercise we will use the following snippet of code as the starting point:</source>
          <target state="translated">매크로 작성을 시작하기 위해 일반적인 동적 코드를 정적으로 컴파일되는 코드로 바꾸는 방법을 보여 드리겠습니다. 연습을 위해 다음 코드 스 니펫을 시작점으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d4d17c22610a24b1162bf0c1482d2f125036d28e" translate="yes" xml:space="preserve">
          <source>To give an example, when &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;Table&lt;/code&gt;, then &lt;code&gt;var b = a&lt;/code&gt; gives &lt;code&gt;b&lt;/code&gt; as a new independent table. &lt;code&gt;b&lt;/code&gt; is initialised with the contents of &lt;code&gt;a&lt;/code&gt;. Changing &lt;code&gt;b&lt;/code&gt; does not affect &lt;code&gt;a&lt;/code&gt; and vice versa:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961c6551432a67ce81ead4213eeed93dc039ac98" translate="yes" xml:space="preserve">
          <source>To implement bit fields with enums see &lt;a href=&quot;#set-type-bit-fields&quot;&gt;Bit fields&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045da0daa554f9ba7ddd34e0914b0a8dec5e90c2" translate="yes" xml:space="preserve">
          <source>To initialize an empty deque use &lt;a href=&quot;#initDeque,int&quot;&gt;initDeque proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d0e681756bb835e0d6abe73186f21ddc912c3a" translate="yes" xml:space="preserve">
          <source>To initialize it, use the &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdd15dad6acf9a5da0ded8e85b664281b70e46a" translate="yes" xml:space="preserve">
          <source>To learn about scripting in Nim see &lt;a href=&quot;nims&quot;&gt;NimScript&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c2e67d28904d49b05aaa4ea39706b64637dec" translate="yes" xml:space="preserve">
          <source>To learn how to compile Nim programs and generate documentation see &lt;a href=&quot;nimc&quot;&gt;Compiler User Guide&lt;/a&gt; and &lt;a href=&quot;https://nim-lang.org/docs/docgen.html&quot;&gt;DocGen Tools Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a57ad28acbc5e4b10960f2e801cd4aa99747b3" translate="yes" xml:space="preserve">
          <source>To link against &lt;code&gt;nimrtl.dll&lt;/code&gt; use the command:</source>
          <target state="translated">&lt;code&gt;nimrtl.dll&lt;/code&gt; 에 연결하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2039b927dcf641bab171f78845015d45672f1c9e" translate="yes" xml:space="preserve">
          <source>To make the &lt;code&gt;createWindow&lt;/code&gt; proc easier to use it should provide &lt;em&gt;default values&lt;/em&gt;; these are values that are used as arguments if the caller does not specify them:</source>
          <target state="translated">&lt;code&gt;createWindow&lt;/code&gt; proc을 사용하기 쉽게 하려면 &lt;em&gt;기본값&lt;/em&gt; 을 제공해야 &lt;em&gt;합니다&lt;/em&gt; . 다음은 호출자가 지정하지 않은 경우 인수로 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="f8a5b8288b3fecf0f566c82b883159042530cd8e" translate="yes" xml:space="preserve">
          <source>To make the compiler output code for a 16bit target use the &lt;code&gt;--cpu:avr&lt;/code&gt; target.</source>
          <target state="translated">16 비트 대상에 대한 컴파일러 출력 코드를 만들려면 &lt;code&gt;--cpu:avr&lt;/code&gt; 대상을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="70e565fb479983d4033bbd0b16c4058d64c2d84c" translate="yes" xml:space="preserve">
          <source>To move a variable into a collection usually &lt;code&gt;sink&lt;/code&gt; parameters are involved. A location that is passed to a &lt;code&gt;sink&lt;/code&gt; parameter should not be used afterward. This is ensured by a static analysis over a control flow graph. If it cannot be proven to be the last usage of the location, a copy is done instead and this copy is then passed to the sink parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42baf71f77a71d00884ecfeb14a9f68b623bec2c" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.cast(gcsafe).}&lt;/code&gt; pragma block can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50bfd9dce33230fbb2c8127c3c5a8cde5dbf040a" translate="yes" xml:space="preserve">
          <source>To override the compiler's gcsafety analysis a &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma block can be used:</source>
          <target state="translated">컴파일러의 gcsafety 분석을 무시하기 위해 &lt;code&gt;{.gcsafe.}&lt;/code&gt; pragma 블록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec136682e26157ec999d8bfed82c55af3e94bc3" translate="yes" xml:space="preserve">
          <source>To override the compiler's side effect analysis a &lt;code&gt;{.noSideEffect.}&lt;/code&gt;&lt;code&gt;cast&lt;/code&gt; pragma block can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd77706967ab0eca2f0aba7e8dc6a7369cc5358" translate="yes" xml:space="preserve">
          <source>To pass a block of statements to a template, use 'untyped' for the last parameter:</source>
          <target state="translated">문장 블록을 템플리트에 전달하려면 마지막 매개 변수에 'untyped'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae1d6bbadfa15e666e4a5bc97ac5b074bba176ef" translate="yes" xml:space="preserve">
          <source>To prevent confusing code there is a parsing limitation; if the &lt;code&gt;try&lt;/code&gt; follows a &lt;code&gt;(&lt;/code&gt; it has to be written as a one liner:</source>
          <target state="translated">혼동되는 코드를 방지하기 위해 구문 분석 제한이 있습니다. 경우 생성 &lt;code&gt;try&lt;/code&gt; 다음 &lt;code&gt;(&lt;/code&gt; 그것은 하나의 라이너로 쓸 수있다 :</target>
        </trans-unit>
        <trans-unit id="cee8374e17ee5570d2e73eb9424e263793331053" translate="yes" xml:space="preserve">
          <source>To produce a single &lt;code&gt;&quot;&lt;/code&gt; within a raw string literal, it has to be doubled:</source>
          <target state="translated">원시 문자열 리터럴 내 에서 단일 &lt;code&gt;&quot;&lt;/code&gt; 를 생성하려면 두 배가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a67c70af6b5e6b03d2581b5a5c05f83968ba3a74" translate="yes" xml:space="preserve">
          <source>To produce a single substitution character it has to be doubled: &lt;code&gt;$$&lt;/code&gt; produces &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">이 두 배로해야하는 하나의 대체 문자를 생성하려면 &lt;code&gt;$$&lt;/code&gt; 생산 &lt;code&gt;$&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="6149c77815fef9fc27e4a6217efcefadefe95220" translate="yes" xml:space="preserve">
          <source>To remove this event you should use the &lt;code&gt;delHandleWrite&lt;/code&gt; function. It is advised to use that function instead of just setting the event to &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; as that would mean that that function would be called constantly.</source>
          <target state="translated">이 이벤트를 제거하려면 &lt;code&gt;delHandleWrite&lt;/code&gt; 함수를 사용해야합니다 . 이벤트를 &lt;code&gt;proc (s: AsyncSocket) = nil&lt;/code&gt; 로 설정하는 대신 해당 함수를 사용하는 것이 좋습니다. 이는 해당 함수가 지속적으로 호출됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4dc2bd124108bb715e2125357f3ca8cff675a9b" translate="yes" xml:space="preserve">
          <source>To retrieve the value of &lt;code&gt;&quot;key&quot;&lt;/code&gt; you can do the following:</source>
          <target state="translated">&lt;code&gt;&quot;key&quot;&lt;/code&gt; 값을 검색하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2272069ae83ac24e5887939db19d33d7075a38" translate="yes" xml:space="preserve">
          <source>To see a list of Nimble's packages, check out &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; or the &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;packages repos&lt;/a&gt; on GitHub.</source>
          <target state="translated">Nimble의 패키지 목록을 보려면 &lt;a href=&quot;https://nimble.directory/&quot;&gt;https://nimble.directory/&lt;/a&gt; 또는 GitHub 의 &lt;a href=&quot;https://github.com/nim-lang/packages&quot;&gt;패키지 저장소&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c36f079cdcdbec7456a7ff4487e0a0d41d8fc11" translate="yes" xml:space="preserve">
          <source>To see how and when we can do that, think about this question: In &lt;code&gt;dest = src&lt;/code&gt; when do we really have to &lt;em&gt;materialize&lt;/em&gt; the full copy? - Only if &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; are mutated afterward. If &lt;code&gt;dest&lt;/code&gt; is a local variable that is simple to analyze. And if &lt;code&gt;src&lt;/code&gt; is a location derived from a formal parameter, we also know it is not mutated! In other words, we do a compile-time copy-on-write analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bb591463a2bf5bfe74be5c756dd27d755e4b62" translate="yes" xml:space="preserve">
          <source>To specify the AST for the different Nim constructs, the notation &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; or &lt;code&gt;nodekind(value)&lt;/code&gt; or &lt;code&gt;nodekind(field=value)&lt;/code&gt; is used.</source>
          <target state="translated">다른 Nim 구문에 AST를 지정하려면 &lt;code&gt;nodekind(son1, son2, ...)&lt;/code&gt; 또는 &lt;code&gt;nodekind(value)&lt;/code&gt; 또는 &lt;code&gt;nodekind(field=value)&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0d95ec7d1bdea5264d30098e88834030ad1102b" translate="yes" xml:space="preserve">
          <source>To stream files from disk when performing the request, use &lt;code&gt;addFiles&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23947ec0494a83fa76619311a6fe3ef2b338db4" translate="yes" xml:space="preserve">
          <source>To the end of the tuple/object definition.</source>
          <target state="translated">튜플 / 객체 정의의 끝.</target>
        </trans-unit>
        <trans-unit id="9f79e9096a797c7afc08420ab23a519537e4fb67" translate="yes" xml:space="preserve">
          <source>To understand some of the different ways of specifying the indices of strings, arrays, sequences, etc., it must be remembered that Nim uses zero-based indices.</source>
          <target state="translated">문자열, 배열, 시퀀스 등의 인덱스를 지정하는 여러 가지 방법을 이해하려면 Nim은 0부터 시작하는 인덱스를 사용한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="596784d34744359d8630e6bf6d5a5b5ef239775c" translate="yes" xml:space="preserve">
          <source>To unpack raw bytes look at the &lt;a href=&quot;streams&quot;&gt;streams&lt;/a&gt; module.</source>
          <target state="translated">원시 바이트의 압축을 풀려면 &lt;a href=&quot;streams&quot;&gt;스트림&lt;/a&gt; 모듈을보십시오.</target>
        </trans-unit>
        <trans-unit id="9dd0e4773e807b447d8759bcce32b13725171fb1" translate="yes" xml:space="preserve">
          <source>To use</source>
          <target state="translated">쓰다</target>
        </trans-unit>
        <trans-unit id="de696deb8ffc9ecc04b7f3951a9928d4cb92e1a3" translate="yes" xml:space="preserve">
          <source>To use Unix sockets with &lt;code&gt;db_postgres&lt;/code&gt;, change the server address to the socket file path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142355009167cc6a95bc27c6846c8bb91aa3b8b9" translate="yes" xml:space="preserve">
          <source>To use a &lt;code&gt;HeapQueue&lt;/code&gt; with a custom object, the &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fa9c66bf6fe6910167c4b6d93b8e2ef5d6e2c3" translate="yes" xml:space="preserve">
          <source>To use a filter for a source file the &lt;code&gt;#?&lt;/code&gt; notation is used:</source>
          <target state="translated">소스 파일에 필터를 사용하려면 &lt;code&gt;#?&lt;/code&gt; 표기법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="04e302c6728e7a9bb5aad8c6631a551defc4ffef" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;CC&lt;/code&gt; environment variable, use &lt;code&gt;nim c --cc:env myfile.nim&lt;/code&gt;. To use the &lt;code&gt;CXX&lt;/code&gt; environment variable, use &lt;code&gt;nim cpp --cc:env myfile.nim&lt;/code&gt;. &lt;code&gt;--cc:env&lt;/code&gt; is available since Nim version 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd3786ffe14095836ecde08c5a7353e00f84790" translate="yes" xml:space="preserve">
          <source>To use threadsafe version of this module, it needs to be compiled with both &lt;code&gt;-d:threadsafe&lt;/code&gt; and &lt;code&gt;--threads:on&lt;/code&gt; options.</source>
          <target state="translated">이 모듈의 스레드 세이프 버전을 사용하려면 &lt;code&gt;-d:threadsafe&lt;/code&gt; 및 &lt;code&gt;--threads:on&lt;/code&gt; 옵션 으로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="31052631155b690d2c6d4d6d38ee09a1e1936e39" translate="yes" xml:space="preserve">
          <source>To verify that idetools is working properly there are files in the &lt;code&gt;tests/caas/&lt;/code&gt; directory which provide unit testing. If you find odd idetools behaviour and are able to reproduce it, you are welcome to report it as a bug and add a test to the suite to avoid future regressions.</source>
          <target state="translated">idetools가 제대로 작동하는지 확인하기 위해 &lt;code&gt;tests/caas/&lt;/code&gt; 디렉토리에 유닛 테스트를 제공하는 파일이 있습니다 . 이상한 idetools 동작을 발견하고이를 재현 할 수 있으면 버그로보고하고 향후 회귀를 피하기 위해 스위트에 테스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e9f1bbe8f37ac15cd7d8886750a127655bd140" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;c2nim&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="translated">네이티브 코드를 래핑하려면 &lt;a href=&quot;c2nim&quot;&gt;c2nim 도구&lt;/a&gt; 를 살펴보고 헤더 파일을 스캔하고 Nim 인터페이스로 변환하는 프로세스를 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="b9f9c53a4e3a6ac9348d14114004e52bdf2eb009" translate="yes" xml:space="preserve">
          <source>To wrap native code, take a look at the &lt;a href=&quot;https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst&quot;&gt;c2nim tool&lt;/a&gt; which helps with the process of scanning and transforming header files into a Nim interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b661fcccef784df68a5a22da94f9a1df408bd3" translate="yes" xml:space="preserve">
          <source>To write macros, one needs to know how the Nim concrete syntax is converted to an AST.</source>
          <target state="translated">매크로를 작성하려면 Nim 콘크리트 구문이 AST로 어떻게 변환되는지 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="2f549b2a892218558d523d98dae57570829a8f93" translate="yes" xml:space="preserve">
          <source>TokType.tkAccent</source>
          <target state="translated">TokType.tkAccent</target>
        </trans-unit>
        <trans-unit id="833b136eeb7b71ba6135f430bf1f1340bb500f57" translate="yes" xml:space="preserve">
          <source>TokType.tkAddr</source>
          <target state="translated">TokType.tkAddr</target>
        </trans-unit>
        <trans-unit id="489a603081fd6b748fae558121aa7f4f61658c4a" translate="yes" xml:space="preserve">
          <source>TokType.tkAnd</source>
          <target state="translated">TokType.tkAnd</target>
        </trans-unit>
        <trans-unit id="94b4a65e0bedbd02e98c807ebade522187aaa19d" translate="yes" xml:space="preserve">
          <source>TokType.tkAs</source>
          <target state="translated">TokType.tkAs</target>
        </trans-unit>
        <trans-unit id="8978a3df45f0f0c1280d12531bc2f625112ac39d" translate="yes" xml:space="preserve">
          <source>TokType.tkAsm</source>
          <target state="translated">TokType.tkAsm</target>
        </trans-unit>
        <trans-unit id="6e6e12af7c053f49bd6c1c695636733d2e8539a3" translate="yes" xml:space="preserve">
          <source>TokType.tkBind</source>
          <target state="translated">TokType.tkBind</target>
        </trans-unit>
        <trans-unit id="a9c054648356a5ec5e40c7f127bf578c4288c552" translate="yes" xml:space="preserve">
          <source>TokType.tkBlock</source>
          <target state="translated">TokType.tkBlock</target>
        </trans-unit>
        <trans-unit id="799e59cf0082e0e4c7375f1a4e4937227bc944da" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketDotLe</source>
          <target state="translated">TokType.tkBracketDotLe</target>
        </trans-unit>
        <trans-unit id="d579d9f7a587e27b121abe68fa54484aa2b465e6" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketDotRi</source>
          <target state="translated">TokType.tkBracketDotRi</target>
        </trans-unit>
        <trans-unit id="aec7469553259228c2e655b2f774e9098c73bc7f" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketLe</source>
          <target state="translated">TokType.tkBracketLe</target>
        </trans-unit>
        <trans-unit id="3f63d6eac226a1be137b7031a8785f893f5a495f" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketLeColon</source>
          <target state="translated">TokType.tkBracketLeColon</target>
        </trans-unit>
        <trans-unit id="f5608001df1c7ece8b568bd999c86c4a07fcfee6" translate="yes" xml:space="preserve">
          <source>TokType.tkBracketRi</source>
          <target state="translated">TokType.tkBracketRi</target>
        </trans-unit>
        <trans-unit id="bd6c5a59b7780d71184d650a75030a393e821833" translate="yes" xml:space="preserve">
          <source>TokType.tkBreak</source>
          <target state="translated">TokType.tkBreak</target>
        </trans-unit>
        <trans-unit id="70336fae723b490f3d259d55b94c13671027bb61" translate="yes" xml:space="preserve">
          <source>TokType.tkCase</source>
          <target state="translated">TokType.tkCase</target>
        </trans-unit>
        <trans-unit id="8dc6f35ba845aa81f4f5f622e37c43f0e79f01ea" translate="yes" xml:space="preserve">
          <source>TokType.tkCast</source>
          <target state="translated">TokType.tkCast</target>
        </trans-unit>
        <trans-unit id="f020bdb6e98b4892b67745a64d132ebdcfece0a9" translate="yes" xml:space="preserve">
          <source>TokType.tkCharLit</source>
          <target state="translated">TokType.tkCharLit</target>
        </trans-unit>
        <trans-unit id="f570a44feb96040aa0cf36964543ce010ead0207" translate="yes" xml:space="preserve">
          <source>TokType.tkColon</source>
          <target state="translated">TokType.tkColon</target>
        </trans-unit>
        <trans-unit id="ac4dbb39702d0085d09e81886b42d3a0dafd5bda" translate="yes" xml:space="preserve">
          <source>TokType.tkColonColon</source>
          <target state="translated">TokType.tkColonColon</target>
        </trans-unit>
        <trans-unit id="3017c21990854b2405655e1c23fd5134ba8297f9" translate="yes" xml:space="preserve">
          <source>TokType.tkComma</source>
          <target state="translated">TokType.tkComma</target>
        </trans-unit>
        <trans-unit id="8ce94490aca0297f31abb207a0b70a7b70791e95" translate="yes" xml:space="preserve">
          <source>TokType.tkComment</source>
          <target state="translated">TokType.tkComment</target>
        </trans-unit>
        <trans-unit id="b16b7d6ecc33bd18d836a0e7e87f0d81d81c258e" translate="yes" xml:space="preserve">
          <source>TokType.tkConcept</source>
          <target state="translated">TokType.tkConcept</target>
        </trans-unit>
        <trans-unit id="7995c63d3c8383418a7b5f2752499cfc560e551d" translate="yes" xml:space="preserve">
          <source>TokType.tkConst</source>
          <target state="translated">TokType.tkConst</target>
        </trans-unit>
        <trans-unit id="b82e96e5b46e99566ea1b135f67b86a58cd09971" translate="yes" xml:space="preserve">
          <source>TokType.tkContinue</source>
          <target state="translated">TokType.tkContinue</target>
        </trans-unit>
        <trans-unit id="5f5f3d3eaa7b5aa9e659eb6b5e38250fb65cf833" translate="yes" xml:space="preserve">
          <source>TokType.tkConverter</source>
          <target state="translated">TokType.tkConverter</target>
        </trans-unit>
        <trans-unit id="9876d6456204358b4d82d8ede84e3bc570caff57" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyDotLe</source>
          <target state="translated">TokType.tkCurlyDotLe</target>
        </trans-unit>
        <trans-unit id="3140a2f9479c230fecac5cda2b3819643802aa1d" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyDotRi</source>
          <target state="translated">TokType.tkCurlyDotRi</target>
        </trans-unit>
        <trans-unit id="0b8e92e90ebd362d3f261b33460785178a3438e8" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyLe</source>
          <target state="translated">TokType.tkCurlyLe</target>
        </trans-unit>
        <trans-unit id="6c872b5900732c711099c764c44fd40f8639a93b" translate="yes" xml:space="preserve">
          <source>TokType.tkCurlyRi</source>
          <target state="translated">TokType.tkCurlyRi</target>
        </trans-unit>
        <trans-unit id="278e1aefae81581962fcb14f20c027c65b217564" translate="yes" xml:space="preserve">
          <source>TokType.tkDefer</source>
          <target state="translated">TokType.tkDefer</target>
        </trans-unit>
        <trans-unit id="a0b37a18ffee5487dd9dd4008308703b3647c0ac" translate="yes" xml:space="preserve">
          <source>TokType.tkDiscard</source>
          <target state="translated">TokType.tkDiscard</target>
        </trans-unit>
        <trans-unit id="629d8184f142fa861965b6c3c4f034dc2cd1bd12" translate="yes" xml:space="preserve">
          <source>TokType.tkDistinct</source>
          <target state="translated">TokType.tkDistinct</target>
        </trans-unit>
        <trans-unit id="3ea505d47e347a086d25f28bf4603ca7947b1ed9" translate="yes" xml:space="preserve">
          <source>TokType.tkDiv</source>
          <target state="translated">TokType.tkDiv</target>
        </trans-unit>
        <trans-unit id="1d340ea17fa45033ea175e4770eabeaecbad72ba" translate="yes" xml:space="preserve">
          <source>TokType.tkDo</source>
          <target state="translated">TokType.tkDo</target>
        </trans-unit>
        <trans-unit id="b90b8328ec3252a655efd56f5224038d5478d18c" translate="yes" xml:space="preserve">
          <source>TokType.tkDot</source>
          <target state="translated">TokType.tkDot</target>
        </trans-unit>
        <trans-unit id="2004458b042724837f22397f308b5f8b307d0ebb" translate="yes" xml:space="preserve">
          <source>TokType.tkDotDot</source>
          <target state="translated">TokType.tkDotDot</target>
        </trans-unit>
        <trans-unit id="7783ac35cb2e808bbad9d0e1f16379e4b0ec15c1" translate="yes" xml:space="preserve">
          <source>TokType.tkElif</source>
          <target state="translated">TokType.tkElif</target>
        </trans-unit>
        <trans-unit id="acb1195127603d466c0e119e8e5aff4bc77c55f5" translate="yes" xml:space="preserve">
          <source>TokType.tkElse</source>
          <target state="translated">TokType.tkElse</target>
        </trans-unit>
        <trans-unit id="3b9c80840fbc903249e7fec67e07f673c46ad5d2" translate="yes" xml:space="preserve">
          <source>TokType.tkEnd</source>
          <target state="translated">TokType.tkEnd</target>
        </trans-unit>
        <trans-unit id="73fef38d6b1d7b254cf5006fd374c48677312c39" translate="yes" xml:space="preserve">
          <source>TokType.tkEnum</source>
          <target state="translated">TokType.tkEnum</target>
        </trans-unit>
        <trans-unit id="e6965ef3ef17e34a49d9fb943a50e15c77bf9e15" translate="yes" xml:space="preserve">
          <source>TokType.tkEof</source>
          <target state="translated">TokType.tkEof</target>
        </trans-unit>
        <trans-unit id="c6b8aa3483ae8cfb176381d143be9012f8c644d5" translate="yes" xml:space="preserve">
          <source>TokType.tkEquals</source>
          <target state="translated">TokType.tkEquals</target>
        </trans-unit>
        <trans-unit id="1bfce305d9f664de95721359feb9f16c2ca69df9" translate="yes" xml:space="preserve">
          <source>TokType.tkExcept</source>
          <target state="translated">TokType.tkExcept</target>
        </trans-unit>
        <trans-unit id="c532476f9950e5f7bc1d47975766004ca0788a35" translate="yes" xml:space="preserve">
          <source>TokType.tkExport</source>
          <target state="translated">TokType.tkExport</target>
        </trans-unit>
        <trans-unit id="9e0c512a9e26612ffad2cc71d6cec952bf187a1b" translate="yes" xml:space="preserve">
          <source>TokType.tkFinally</source>
          <target state="translated">TokType.tkFinally</target>
        </trans-unit>
        <trans-unit id="738c8281635f8f6f3bf4474f2d57cd7fdc75ee1d" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat128Lit</source>
          <target state="translated">TokType.tkFloat128Lit</target>
        </trans-unit>
        <trans-unit id="06388573c31a5cbd43b0f7ffe62af7c5b0358dd9" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat32Lit</source>
          <target state="translated">TokType.tkFloat32Lit</target>
        </trans-unit>
        <trans-unit id="ad31d1c1449a83a8c103f06d0fc23e86c9dd14ab" translate="yes" xml:space="preserve">
          <source>TokType.tkFloat64Lit</source>
          <target state="translated">TokType.tkFloat64Lit</target>
        </trans-unit>
        <trans-unit id="2c660aae5c634bc997bfac8609ec9ee4ae1eb395" translate="yes" xml:space="preserve">
          <source>TokType.tkFloatLit</source>
          <target state="translated">TokType.tkFloatLit</target>
        </trans-unit>
        <trans-unit id="6b9f4ccdf4113bb7905eb1ab596947e522fda2fa" translate="yes" xml:space="preserve">
          <source>TokType.tkFor</source>
          <target state="translated">TokType.tkFor</target>
        </trans-unit>
        <trans-unit id="ece859e80c67a4ac071de48e1023901d560c656a" translate="yes" xml:space="preserve">
          <source>TokType.tkFrom</source>
          <target state="translated">TokType.tkFrom</target>
        </trans-unit>
        <trans-unit id="ce742ed274f4122583fc65cec0c0f6dd54b7a765" translate="yes" xml:space="preserve">
          <source>TokType.tkFunc</source>
          <target state="translated">TokType.tkFunc</target>
        </trans-unit>
        <trans-unit id="ff2f32e5ecca86e0c97c8bbabcb2e4b31d4fe2da" translate="yes" xml:space="preserve">
          <source>TokType.tkGStrLit</source>
          <target state="translated">TokType.tkGStrLit</target>
        </trans-unit>
        <trans-unit id="6c1a0ae6c63b05ac5b31dd72bdbd4f90d91b9561" translate="yes" xml:space="preserve">
          <source>TokType.tkGTripleStrLit</source>
          <target state="translated">TokType.tkGTripleStrLit</target>
        </trans-unit>
        <trans-unit id="271e5dc7a48fe13922aac2398d53b7c54b4744a6" translate="yes" xml:space="preserve">
          <source>TokType.tkIf</source>
          <target state="translated">TokType.tkIf</target>
        </trans-unit>
        <trans-unit id="575e4aeda974ae70cf93a71e377557bd8e72342f" translate="yes" xml:space="preserve">
          <source>TokType.tkImport</source>
          <target state="translated">TokType.tkImport</target>
        </trans-unit>
        <trans-unit id="88763a2b67947d2ed05c26b489efa287d3a369ac" translate="yes" xml:space="preserve">
          <source>TokType.tkIn</source>
          <target state="translated">TokType.tkIn</target>
        </trans-unit>
        <trans-unit id="065b5c379ddc0dd3fd8118403edf454bb6ceb110" translate="yes" xml:space="preserve">
          <source>TokType.tkInclude</source>
          <target state="translated">TokType.tkInclude</target>
        </trans-unit>
        <trans-unit id="c722ffd4f4df7c6836676daa4492d6bb38443d6a" translate="yes" xml:space="preserve">
          <source>TokType.tkInfixOpr</source>
          <target state="translated">TokType.tkInfixOpr</target>
        </trans-unit>
        <trans-unit id="d7e34ebd8f00c7f75979d6c4958cc3a9b388306d" translate="yes" xml:space="preserve">
          <source>TokType.tkInt16Lit</source>
          <target state="translated">TokType.tkInt16Lit</target>
        </trans-unit>
        <trans-unit id="ff7ad1e42476da2e25e2cc6fdc600fc1028c2f55" translate="yes" xml:space="preserve">
          <source>TokType.tkInt32Lit</source>
          <target state="translated">TokType.tkInt32Lit</target>
        </trans-unit>
        <trans-unit id="3da5dd9fe852a4aa31ef4de610e752548fb1fb2a" translate="yes" xml:space="preserve">
          <source>TokType.tkInt64Lit</source>
          <target state="translated">TokType.tkInt64Lit</target>
        </trans-unit>
        <trans-unit id="8d8ad3d9ba8153046c3a61d28a31075f291ec4a3" translate="yes" xml:space="preserve">
          <source>TokType.tkInt8Lit</source>
          <target state="translated">TokType.tkInt8Lit</target>
        </trans-unit>
        <trans-unit id="311b6ea614ffd85b191d1fee73ff2961444b3968" translate="yes" xml:space="preserve">
          <source>TokType.tkIntLit</source>
          <target state="translated">TokType.tkIntLit</target>
        </trans-unit>
        <trans-unit id="5708e6732566f8da68ce71c8f52a71a33dee7bdc" translate="yes" xml:space="preserve">
          <source>TokType.tkInterface</source>
          <target state="translated">TokType.tkInterface</target>
        </trans-unit>
        <trans-unit id="6b88324d5a5c439840eb4efdcf19beb3be9c173e" translate="yes" xml:space="preserve">
          <source>TokType.tkInvalid</source>
          <target state="translated">TokType.tkInvalid</target>
        </trans-unit>
        <trans-unit id="2e789e65b0db1b238a7905afec1bd4686d84de69" translate="yes" xml:space="preserve">
          <source>TokType.tkIs</source>
          <target state="translated">TokType.tkIs</target>
        </trans-unit>
        <trans-unit id="f92fb5f0d067b72bf463d3b45ba05d8f8cef9d90" translate="yes" xml:space="preserve">
          <source>TokType.tkIsnot</source>
          <target state="translated">TokType.tkIsnot</target>
        </trans-unit>
        <trans-unit id="bfdc015ae6704f5464684b15cfdb1598a470a209" translate="yes" xml:space="preserve">
          <source>TokType.tkIterator</source>
          <target state="translated">TokType.tkIterator</target>
        </trans-unit>
        <trans-unit id="1d8f3cde1b5f33caf2cadb92bbe5a3dd1dcd0429" translate="yes" xml:space="preserve">
          <source>TokType.tkLet</source>
          <target state="translated">TokType.tkLet</target>
        </trans-unit>
        <trans-unit id="0fc10e428188bbff220afee5438329764b4b6fad" translate="yes" xml:space="preserve">
          <source>TokType.tkMacro</source>
          <target state="translated">TokType.tkMacro</target>
        </trans-unit>
        <trans-unit id="e007679f5686fe51a42063b11bd4c57ff8f792a4" translate="yes" xml:space="preserve">
          <source>TokType.tkMethod</source>
          <target state="translated">TokType.tkMethod</target>
        </trans-unit>
        <trans-unit id="75b2a89b430c78e8ae4147898b037ccf2befee64" translate="yes" xml:space="preserve">
          <source>TokType.tkMixin</source>
          <target state="translated">TokType.tkMixin</target>
        </trans-unit>
        <trans-unit id="0a7722f0e23e54a8fa1e0ba72602ec02c7e47051" translate="yes" xml:space="preserve">
          <source>TokType.tkMod</source>
          <target state="translated">TokType.tkMod</target>
        </trans-unit>
        <trans-unit id="d6fe6afa97e9092dc4570b4f4df3d8ebc2f309cf" translate="yes" xml:space="preserve">
          <source>TokType.tkNil</source>
          <target state="translated">TokType.tkNil</target>
        </trans-unit>
        <trans-unit id="3ff52598e52be03db3a473c0eb62c1f368b5b15d" translate="yes" xml:space="preserve">
          <source>TokType.tkNot</source>
          <target state="translated">TokType.tkNot</target>
        </trans-unit>
        <trans-unit id="caef4ae846b11c8164f2f09a338dd76a7f4fca74" translate="yes" xml:space="preserve">
          <source>TokType.tkNotin</source>
          <target state="translated">TokType.tkNotin</target>
        </trans-unit>
        <trans-unit id="0590b10afb9128c28b3fd5fd41edacd63de74f41" translate="yes" xml:space="preserve">
          <source>TokType.tkObject</source>
          <target state="translated">TokType.tkObject</target>
        </trans-unit>
        <trans-unit id="83ec18aeb378ffa5c9ec8cc024fe7ec2173128bb" translate="yes" xml:space="preserve">
          <source>TokType.tkOf</source>
          <target state="translated">TokType.tkOf</target>
        </trans-unit>
        <trans-unit id="ffd6523d8240fd35c99aa22196c5b35bb9d4d0aa" translate="yes" xml:space="preserve">
          <source>TokType.tkOpr</source>
          <target state="translated">TokType.tkOpr</target>
        </trans-unit>
        <trans-unit id="931dfd4097f801bc1c9c1d82f244816f2bc5ca36" translate="yes" xml:space="preserve">
          <source>TokType.tkOr</source>
          <target state="translated">TokType.tkOr</target>
        </trans-unit>
        <trans-unit id="7eacf1f5a223853dc4c380f703b802c3d18a68a5" translate="yes" xml:space="preserve">
          <source>TokType.tkOut</source>
          <target state="translated">TokType.tkOut</target>
        </trans-unit>
        <trans-unit id="81c5ba52456d16dd63ee37bb9c884854fb002380" translate="yes" xml:space="preserve">
          <source>TokType.tkParDotLe</source>
          <target state="translated">TokType.tkParDotLe</target>
        </trans-unit>
        <trans-unit id="40b6dbedcdeaf10d112bc3dd7120c51df6eb3505" translate="yes" xml:space="preserve">
          <source>TokType.tkParDotRi</source>
          <target state="translated">TokType.tkParDotRi</target>
        </trans-unit>
        <trans-unit id="38b6bd25f440de0eeee800b517e9f4dd82eec1a9" translate="yes" xml:space="preserve">
          <source>TokType.tkParLe</source>
          <target state="translated">TokType.tkParLe</target>
        </trans-unit>
        <trans-unit id="dcc8c3203a3a310ad350eefc8044a6612f585985" translate="yes" xml:space="preserve">
          <source>TokType.tkParRi</source>
          <target state="translated">TokType.tkParRi</target>
        </trans-unit>
        <trans-unit id="7656a02536e6370b226dfd1985e0854b8ff34dc5" translate="yes" xml:space="preserve">
          <source>TokType.tkPostfixOpr</source>
          <target state="translated">TokType.tkPostfixOpr</target>
        </trans-unit>
        <trans-unit id="f88529421ab0eaa4346de1c92ed0cbf614bf5e73" translate="yes" xml:space="preserve">
          <source>TokType.tkPrefixOpr</source>
          <target state="translated">TokType.tkPrefixOpr</target>
        </trans-unit>
        <trans-unit id="733242cd0f33b8839aca02409ffe08c0b8befbc5" translate="yes" xml:space="preserve">
          <source>TokType.tkProc</source>
          <target state="translated">TokType.tkProc</target>
        </trans-unit>
        <trans-unit id="b62ce3689ea3fb22a978318effd11684c6589e5e" translate="yes" xml:space="preserve">
          <source>TokType.tkPtr</source>
          <target state="translated">TokType.tkPtr</target>
        </trans-unit>
        <trans-unit id="15518423eb969fe135a9589dd520a96d2ef908c8" translate="yes" xml:space="preserve">
          <source>TokType.tkRStrLit</source>
          <target state="translated">TokType.tkRStrLit</target>
        </trans-unit>
        <trans-unit id="472312b9a8e3cb57b034bc27016c1e68fc3da49c" translate="yes" xml:space="preserve">
          <source>TokType.tkRaise</source>
          <target state="translated">TokType.tkRaise</target>
        </trans-unit>
        <trans-unit id="22e4fdcee6b54d717f30eddcf95808e28a717636" translate="yes" xml:space="preserve">
          <source>TokType.tkRef</source>
          <target state="translated">TokType.tkRef</target>
        </trans-unit>
        <trans-unit id="0456d086f77971a9666cb1842e1d8e6602f84998" translate="yes" xml:space="preserve">
          <source>TokType.tkReturn</source>
          <target state="translated">TokType.tkReturn</target>
        </trans-unit>
        <trans-unit id="72d18684d6c011c529065e3856024bec0ba2c884" translate="yes" xml:space="preserve">
          <source>TokType.tkSemiColon</source>
          <target state="translated">TokType.tkSemiColon</target>
        </trans-unit>
        <trans-unit id="68dd5afb9f257e8a09828abe98617ae0b556f528" translate="yes" xml:space="preserve">
          <source>TokType.tkShl</source>
          <target state="translated">TokType.tkShl</target>
        </trans-unit>
        <trans-unit id="adce6edbf7a09830e6aea09b00e51103bcdd8c69" translate="yes" xml:space="preserve">
          <source>TokType.tkShr</source>
          <target state="translated">TokType.tkShr</target>
        </trans-unit>
        <trans-unit id="a7e0ce692e8eef9620693f8d1686107af11d3621" translate="yes" xml:space="preserve">
          <source>TokType.tkSpaces</source>
          <target state="translated">TokType.tkSpaces</target>
        </trans-unit>
        <trans-unit id="8ede613d2b8a8c0925955c215d72651d2d1fe100" translate="yes" xml:space="preserve">
          <source>TokType.tkStatic</source>
          <target state="translated">TokType.tkStatic</target>
        </trans-unit>
        <trans-unit id="3e1f802b0766e1d896f407432018cfcf714b0074" translate="yes" xml:space="preserve">
          <source>TokType.tkStrLit</source>
          <target state="translated">TokType.tkStrLit</target>
        </trans-unit>
        <trans-unit id="e533a04ad49883518c5569b7942f4720930b22fd" translate="yes" xml:space="preserve">
          <source>TokType.tkSymbol</source>
          <target state="translated">TokType.tkSymbol</target>
        </trans-unit>
        <trans-unit id="5dfe431832d87861aef40ed981f51aa72acd6be1" translate="yes" xml:space="preserve">
          <source>TokType.tkTemplate</source>
          <target state="translated">TokType.tkTemplate</target>
        </trans-unit>
        <trans-unit id="b5fdc9e9a791e7e6914796f66c2b4b31637f0f5f" translate="yes" xml:space="preserve">
          <source>TokType.tkTripleStrLit</source>
          <target state="translated">TokType.tkTripleStrLit</target>
        </trans-unit>
        <trans-unit id="db8110eca97c7cfaa37bf7fa24e13537979a4829" translate="yes" xml:space="preserve">
          <source>TokType.tkTry</source>
          <target state="translated">TokType.tkTry</target>
        </trans-unit>
        <trans-unit id="6a6b802dc1cc093d4926740ac2b4c6c5040906c7" translate="yes" xml:space="preserve">
          <source>TokType.tkTuple</source>
          <target state="translated">TokType.tkTuple</target>
        </trans-unit>
        <trans-unit id="3ca68e6d27fa575abe34e5ca00ac1d61f7da1f65" translate="yes" xml:space="preserve">
          <source>TokType.tkType</source>
          <target state="translated">TokType.tkType</target>
        </trans-unit>
        <trans-unit id="ce40c933fe6843eaf07c490f2a9366ae2ebefa8d" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt16Lit</source>
          <target state="translated">TokType.tkUInt16Lit</target>
        </trans-unit>
        <trans-unit id="8e7c763326c2c45bff5836760724b3710c13bd20" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt32Lit</source>
          <target state="translated">TokType.tkUInt32Lit</target>
        </trans-unit>
        <trans-unit id="72334b652ed7e35758949ef493f7d2943cb84b7c" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt64Lit</source>
          <target state="translated">TokType.tkUInt64Lit</target>
        </trans-unit>
        <trans-unit id="cc5bc533909e3a2281f243d22474cadf11e06e43" translate="yes" xml:space="preserve">
          <source>TokType.tkUInt8Lit</source>
          <target state="translated">TokType.tkUInt8Lit</target>
        </trans-unit>
        <trans-unit id="27574dc7c60e8440a7e378a0a73b5ef43e381826" translate="yes" xml:space="preserve">
          <source>TokType.tkUIntLit</source>
          <target state="translated">TokType.tkUIntLit</target>
        </trans-unit>
        <trans-unit id="f57c8920a4bc0b0a15fbeb713b25f13cde39cb36" translate="yes" xml:space="preserve">
          <source>TokType.tkUsing</source>
          <target state="translated">TokType.tkUsing</target>
        </trans-unit>
        <trans-unit id="87240d73886341c28e34fbdaca7b8d2e99da415b" translate="yes" xml:space="preserve">
          <source>TokType.tkVar</source>
          <target state="translated">TokType.tkVar</target>
        </trans-unit>
        <trans-unit id="737b654200742d4bf4060f9449a7fa8328111ac3" translate="yes" xml:space="preserve">
          <source>TokType.tkWhen</source>
          <target state="translated">TokType.tkWhen</target>
        </trans-unit>
        <trans-unit id="8643ea2504e09c98a8baaa8319d4dd9f0d4b5f7d" translate="yes" xml:space="preserve">
          <source>TokType.tkWhile</source>
          <target state="translated">TokType.tkWhile</target>
        </trans-unit>
        <trans-unit id="b918ba580d455cae98401f54ebc3dec2d8285d7c" translate="yes" xml:space="preserve">
          <source>TokType.tkXor</source>
          <target state="translated">TokType.tkXor</target>
        </trans-unit>
        <trans-unit id="cddea888d26bf5d77691d54dc6f57715b25a035e" translate="yes" xml:space="preserve">
          <source>TokType.tkYield</source>
          <target state="translated">TokType.tkYield</target>
        </trans-unit>
        <trans-unit id="15a9c6fe569a4d59b6c4eba1d897854c5fb808d8" translate="yes" xml:space="preserve">
          <source>TokType:</source>
          <target state="translated">TokType:</target>
        </trans-unit>
        <trans-unit id="362082473cde64c91141d06ca89885d3fc43e871" translate="yes" xml:space="preserve">
          <source>TokTypes:</source>
          <target state="translated">TokTypes:</target>
        </trans-unit>
        <trans-unit id="717e44080c0f9b1316356858fca76eee0fd0dbd5" translate="yes" xml:space="preserve">
          <source>Token:</source>
          <target state="translated">Token:</target>
        </trans-unit>
        <trans-unit id="e343b4c58f98bfc11776b6a5f56d3141edf483c2" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;code&gt;s&lt;/code&gt; into substrings for interpolation purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f059218a4518a885adf6307ec93a797dedad724" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b94544fc25d4f617242b0db05703f0c24a3b42d" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings for interpolation purposes.</source>
          <target state="translated">보간을 위해 문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 토큰 화합니다 .</target>
        </trans-unit>
        <trans-unit id="9dabecffbc85d3462b703f6f51a8d742d3888dc3" translate="yes" xml:space="preserve">
          <source>Tokenizes the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="translated">문자열 &lt;em&gt;s&lt;/em&gt; 를 하위 문자열 로 토큰 화합니다 .</target>
        </trans-unit>
        <trans-unit id="4df68215c8e8bc621359763d151b72a86c6da974" translate="yes" xml:space="preserve">
          <source>Tools available with Nim</source>
          <target state="translated">Nim과 함께 사용 가능한 도구</target>
        </trans-unit>
        <trans-unit id="58446c7f2b2e4db0f99d43b03101c0a822d287a4" translate="yes" xml:space="preserve">
          <source>Tools documentation</source>
          <target state="translated">도구 문서</target>
        </trans-unit>
        <trans-unit id="1fe5db2636efc921cd0bb4e6546d660babab9b05" translate="yes" xml:space="preserve">
          <source>Top level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="translated">최고 수준의 &lt;code&gt;defer&lt;/code&gt; 이 같은 문을 참조해야하는지 불분명하기 때문에 문은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb14fa6e0884cf02668ea33f83561399f74d1358" translate="yes" xml:space="preserve">
          <source>Top level accesses to &lt;code&gt;gdata&lt;/code&gt; are always allowed so that it can be initialized conveniently. It is &lt;em&gt;assumed&lt;/em&gt; (but not enforced) that every top level statement is executed before any concurrent action happens.</source>
          <target state="translated">&lt;code&gt;gdata&lt;/code&gt; 에 대한 최상위 액세스 는 항상 허용되므로 편리하게 초기화 할 수 있습니다. 이되는 &lt;em&gt;것으로&lt;/em&gt; 어떤 동시 행동이 발생하기 전에 모든 최상위 명령문이 실행된다 (그러나 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="eddf8fc4150fb378c850cd2207e5cd6cdfec3026" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;defer&lt;/code&gt; statements are not supported since it's unclear what such a statement should refer to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1df960d5a8bc3c6b227df69c648f6de356c26d" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;code&gt;ptr T&lt;/code&gt; is implicitly convertible to the &lt;code&gt;pointer&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aac1979dafc6f8136821295c2c76ca0331a0e00" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword, untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword. In general, a &lt;em&gt;ptr T&lt;/em&gt; is implicitly convertible to the &lt;em&gt;pointer&lt;/em&gt; type.</source>
          <target state="translated">추적 된 참조는 &lt;strong&gt;ref&lt;/strong&gt; 키워드 로 선언되고 추적되지 않은 참조는 &lt;strong&gt;ptr&lt;/strong&gt; 키워드 로 선언됩니다 . 일반적으로, &lt;em&gt;ptr T&lt;/em&gt; 는 암시 적으로 &lt;em&gt;포인터&lt;/em&gt; 유형으로 변환 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0e0c2775cf7c51f8a1bb67ce0e0ab81a950538e4" translate="yes" xml:space="preserve">
          <source>Traced references are declared with the &lt;strong&gt;ref&lt;/strong&gt; keyword; untraced references are declared with the &lt;strong&gt;ptr&lt;/strong&gt; keyword.</source>
          <target state="translated">추적 된 참조는 &lt;strong&gt;ref&lt;/strong&gt; 키워드 로 선언됩니다 . 추적되지 않은 참조는 &lt;strong&gt;ptr&lt;/strong&gt; 키워드 로 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc498182e45877c7d386bad77456516385d934" translate="yes" xml:space="preserve">
          <source>Traditional select function. This function will return the number of sockets that are ready to be read from, written to, or which have errors. If there are none; 0 is returned. &lt;code&gt;Timeout&lt;/code&gt; is in milliseconds and -1 can be specified for no timeout.</source>
          <target state="translated">전통적인 선택 기능. 이 함수는 읽을 준비가되었거나 오류가있는 소켓의 수를 반환합니다. 없는 경우; 0이 반환됩니다. &lt;code&gt;Timeout&lt;/code&gt; 는 밀리 초이며 시간 초과없이 -1을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6a1b2ac3012e50748232ba8eb954103f97ad1c" translate="yes" xml:space="preserve">
          <source>Transformation:</source>
          <target state="translated">Transformation:</target>
        </trans-unit>
        <trans-unit id="b166fd2494951b4a9dd6614893d73631313e5287" translate="yes" xml:space="preserve">
          <source>Transforms &lt;code&gt;x&lt;/code&gt; in-place (must be declared as &lt;code&gt;var&lt;/code&gt;) into its cumulative (aka prefix) summation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee891e5e3e3894f6430c52409c74a31424cf68c" translate="yes" xml:space="preserve">
          <source>Transforms any iterable (anything that can be iterated over, e.g. with a for-loop) into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7b92acc9a145b44981e2aafa578d392367d9b9" translate="yes" xml:space="preserve">
          <source>Transforms any iterator into a sequence.</source>
          <target state="translated">반복자를 시퀀스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="06d8c014bbeddfd36b3452bacbcdbea84d51a7e7" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;code&gt;replacements&lt;/code&gt; proc to substitute words inside &lt;code&gt;s&lt;/code&gt; with their replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab31ee25d07a8f9d5ddc9927e74c06ef43d27b4f" translate="yes" xml:space="preserve">
          <source>Translates words in a string using the &lt;em&gt;replacements&lt;/em&gt; proc to substitute words inside &lt;em&gt;s&lt;/em&gt; with their replacements</source>
          <target state="translated">사용하여 문자열의 단어 번역 &lt;em&gt;교체의&lt;/em&gt; PROC 내부 단어로 대체합니다 &lt;em&gt;들&lt;/em&gt; 자신의 교체와 함께</target>
        </trans-unit>
        <trans-unit id="a7c36d78b13e6dda8f6d500d67c359740cbced46" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the indexes do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an array.</source>
          <target state="translated">노드를 순회하고 주어진 값을 얻습니다. 색인이 존재하지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 . 중간 데이터 구조 중 하나가 배열이 아닌 경우 에도 &lt;code&gt;nil&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3793e0cbf6a67e24ccddc9cfe73cf06db3bff8f2" translate="yes" xml:space="preserve">
          <source>Traverses the node and gets the given value. If any of the keys do not exist, returns &lt;code&gt;nil&lt;/code&gt;. Also returns &lt;code&gt;nil&lt;/code&gt; if one of the intermediate data structures is not an object.</source>
          <target state="translated">노드를 순회하고 주어진 값을 얻습니다. 키가 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 중간 데이터 구조 중 하나가 오브젝트가 아닌 경우 에도 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9165124d411bbca6b0b36e2cf0040381f82a3771" translate="yes" xml:space="preserve">
          <source>Traverses the node and tries to set the value at the given location to &lt;code&gt;value&lt;/code&gt;. If any of the keys are missing, they are added.</source>
          <target state="translated">노드를 순회하고 지정된 위치의 값을 value로 설정하려고 &lt;code&gt;value&lt;/code&gt; . 누락 된 키가 있으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bdaad0ebd0308235ded505de3934e9cc0046795a" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and adds them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9ed1decb50308f5e6aa06d20161f00ecb9ca93" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;gt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c48e0fdd0ebc4b2891001348bd40e23a61cf6c0" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;gt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b683e854fa9bdd3e32c9c74b2f4273e5c40e4565" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;lt; unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3499bddf2f40a8fa9694d375c62bdc702ba8be5" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compares them. Returns true if &lt;code&gt;unsigned(x) &amp;lt;= unsigned(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363b3a920ec3ebefa623919736db3dc30615daad" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and compute the modulo of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1379c334be5ee52f0718ac9b9e84741f86f51f0c" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and divides them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb7930e147b0baa66f7cc291fe453c89d88037d" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and multiplies them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9065cd842104ab82e826f5e260486a20aa1973e4" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; as unsigned and subtracts them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be21b1bce2de067bd3e786afad75fd72756bccb7" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;code&gt;true&lt;/code&gt; on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156e25a6b8cf8a864963e049e7d35bac34d38d59" translate="yes" xml:space="preserve">
          <source>Tries to acquire the given lock. Returns &lt;em&gt;true&lt;/em&gt; on success.</source>
          <target state="translated">주어진 잠금을 얻으려고 시도합니다. 성공하면 &lt;em&gt;true&lt;/em&gt; 를 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="052b52ab3d9fabc546aeeb6ac42140e3b6adb0d3" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468da52d5869ae376d9b95725718bd6ff03dd727" translate="yes" xml:space="preserve">
          <source>Tries to execute the query and returns true if successful, false otherwise.</source>
          <target state="translated">쿼리 실행을 시도하고 성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43cd3232070ab3327532d46fceeb76f1a6c24cef" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;code&gt;c&lt;/code&gt;, but this can fail for all sort of reasons, including contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0489b14e1e492e61e5c98226d96a5ae8a905f" translate="yes" xml:space="preserve">
          <source>Tries to receive a message from the channel &lt;em&gt;c&lt;/em&gt;, but this can fail for all sort of reasons, including contention. If it fails, it returns &lt;code&gt;(false, default(msg))&lt;/code&gt; otherwise it returns &lt;code&gt;(true, msg)&lt;/code&gt;.</source>
          <target state="translated">채널 &lt;em&gt;c&lt;/em&gt; 에서 메시지를 받으려고 시도 하지만 경합을 포함하여 모든 종류의 이유로 실패 할 수 있습니다. 실패하면 &lt;code&gt;(false, default(msg))&lt;/code&gt; 반환하고 그렇지 않으면 &lt;code&gt;(true, msg)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b8e54d5c6c55af29c2af25e91a4e9b9de9368ad" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;code&gt;data&lt;/code&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e8185659254fff6635dee26e78e5d85bff42cc" translate="yes" xml:space="preserve">
          <source>Tries to reset browser state and writes &lt;em&gt;data&lt;/em&gt; to stdout in &amp;lt;plaintext&amp;gt; tag.</source>
          <target state="translated">브라우저 상태를 재설정하려고 시도하고 &amp;lt;plaintext&amp;gt; 태그에서 stdout에 &lt;em&gt;데이터&lt;/em&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fe1371bcbeb7e55667bc32ef0a2f430e58ebcb67" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1f450205803ed460a630c26002dda1d5353960" translate="yes" xml:space="preserve">
          <source>Tries to send a message to a thread. &lt;em&gt;msg&lt;/em&gt; is deeply copied. Doesn't block. Returns &lt;em&gt;false&lt;/em&gt; if the message was not sent because number of pending items in the channel exceeded &lt;em&gt;maxItems&lt;/em&gt;.</source>
          <target state="translated">스레드에 메시지를 보내려고합니다. &lt;em&gt;msg&lt;/em&gt; 가 깊이 복사되었습니다. 차단하지 않습니다. 채널의 보류중인 항목 수가 &lt;em&gt;maxItems를&lt;/em&gt; 초과하여 메시지가 전송되지 않은 경우 &lt;em&gt;false를&lt;/em&gt; 리턴 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c7db82aabe0ec4b37ab6dba207f6dfa98f250d7" translate="yes" xml:space="preserve">
          <source>Trigger event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">트리거 이벤트 &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3c207482b9595dc0f6457a13d2f1e61c56e381" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value (&lt;em&gt;x&lt;/em&gt;). Modifies the passed value.</source>
          <target state="translated">형식이 지정된 부동 소수점 값 ( &lt;em&gt;x&lt;/em&gt; ) 에서 후행 0을 자릅니다 . 전달 된 값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="dfc10a85898402be5a0dc29ff3a151acbc0ec82c" translate="yes" xml:space="preserve">
          <source>Trim trailing zeros from a formatted floating point value &lt;code&gt;x&lt;/code&gt; (must be declared as &lt;code&gt;var&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afddc6dcc2da91db52e6db34c078cda6ecf5a529" translate="yes" xml:space="preserve">
          <source>Triple quoted string literals</source>
          <target state="translated">삼중 인용 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="ece7dfe6456e82fc094101afe039e9008b540f9c" translate="yes" xml:space="preserve">
          <source>True if the file system is case sensitive, false otherwise. Used by &lt;a href=&quot;#cmpPaths,string,string&quot;&gt;cmpPaths proc&lt;/a&gt; to compare filenames properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12506a0b7ae22bbc9eda9b9dbf90cd45acb51a13" translate="yes" xml:space="preserve">
          <source>True only when accessed in the main module. This works thanks to compiler magic. It is useful to embed testing code in a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052493e1431b2d637a77a0276e53ee054de7f589" translate="yes" xml:space="preserve">
          <source>Truncates &lt;code&gt;x&lt;/code&gt; to the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245ceee2586082dc5a73679c70b42d08a85510ee" translate="yes" xml:space="preserve">
          <source>Truncates &lt;em&gt;x&lt;/em&gt; to the decimal point</source>
          <target state="translated">&lt;em&gt;x&lt;/em&gt; 를 소수점으로 자릅니다</target>
        </trans-unit>
        <trans-unit id="02715c4b7ff15274f4612905c77b4bda81876e45" translate="yes" xml:space="preserve">
          <source>Try can also be used as an expression; the type of the &lt;code&gt;try&lt;/code&gt; branch then needs to fit the types of &lt;code&gt;except&lt;/code&gt; branches, but the type of the &lt;code&gt;finally&lt;/code&gt; branch always has to be &lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">try는 표현식으로도 사용할 수 있습니다. &lt;code&gt;try&lt;/code&gt; 브랜치 의 타입은 브랜치를 &lt;code&gt;except&lt;/code&gt; 타입에 맞아야 하지만 &lt;code&gt;finally&lt;/code&gt; 브랜치 의 타입은 항상 &lt;code&gt;void&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a7af062d7b75f8335dbdc49667ebc20f3bbd46f5" translate="yes" xml:space="preserve">
          <source>Try expression</source>
          <target state="translated">표현을 시도</target>
        </trans-unit>
        <trans-unit id="f526bd18e3a74520efcc9c43abfaeabfe401e20b" translate="yes" xml:space="preserve">
          <source>Try statement</source>
          <target state="translated">진술을보십시오</target>
        </trans-unit>
        <trans-unit id="282a53848958015adde9657c323c058f36bbfd19" translate="yes" xml:space="preserve">
          <source>Tuple access &lt;code&gt;e[0]&lt;/code&gt; is a path expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb959bb7d8da3f5b1a99088eb043845c557941e" translate="yes" xml:space="preserve">
          <source>Tuple or object scope</source>
          <target state="translated">튜플 또는 객체 범위</target>
        </trans-unit>
        <trans-unit id="3f99aa09c1ddebfc55f57b61f023038ddf8cd672" translate="yes" xml:space="preserve">
          <source>Tuple unpacking</source>
          <target state="translated">튜플 포장 풀기</target>
        </trans-unit>
        <trans-unit id="538a8ce3fbdcaee00a14353bd57bcf3600c6e0d0" translate="yes" xml:space="preserve">
          <source>Tuples</source>
          <target state="translated">Tuples</target>
        </trans-unit>
        <trans-unit id="b3e2bebd3f6bc134f276b0e73ccd708819d73bd3" translate="yes" xml:space="preserve">
          <source>Tuples and object types</source>
          <target state="translated">튜플 및 객체 유형</target>
        </trans-unit>
        <trans-unit id="4591fb7e2e6af521b3d77017031f788c69e63561" translate="yes" xml:space="preserve">
          <source>Tuples can be &lt;em&gt;unpacked&lt;/em&gt; during variable assignment (and only then!). This can be handy to assign directly the fields of the tuples to individually named variables. An example of this is the &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc from the &lt;a href=&quot;os&quot;&gt;os module&lt;/a&gt; which returns the directory, name and extension of a path at the same time. For tuple unpacking to work you must use parentheses around the values you want to assign the unpacking to, otherwise you will be assigning the same value to all the individual variables! For example:</source>
          <target state="translated">변수 할당 중에 튜플의 &lt;em&gt;압축을 풀&lt;/em&gt; 수 있습니다 (만!). 이것은 튜플의 필드를 개별적으로 명명 된 변수에 직접 할당하는 데 편리 할 수 ​​있습니다. 이 예제 는 &lt;a href=&quot;os&quot;&gt;os 모듈&lt;/a&gt; 의 &lt;a href=&quot;os#splitFile&quot;&gt;splitFile&lt;/a&gt; proc입니다 로 경로, 디렉토리, 이름 및 확장자를 동시에 반환합니다. 튜플 압축 풀기 작업을 수행하려면 압축 풀기를 지정할 값 주위에 괄호를 사용해야합니다. 그렇지 않으면 모든 개별 변수에 동일한 값을 할당하게됩니다! 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8352a113514bb2d5c1a998e7f4b0ab2c15a44826" translate="yes" xml:space="preserve">
          <source>Tuples which are longer than one line should indent their parameters to align with the parameters above it.</source>
          <target state="translated">한 줄보다 긴 튜플은 매개 변수를 들여 쓰기하여 그 위에있는 매개 변수와 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b346e4953356d44049c162bd3c503c985bc5b32" translate="yes" xml:space="preserve">
          <source>Turn a deque into its string representation.</source>
          <target state="translated">deque를 문자열 표현으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8743e385990daa129ed7fd77c0aab253383cfcf0" translate="yes" xml:space="preserve">
          <source>Turn a rational number into a string.</source>
          <target state="translated">유리수를 문자열로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="b2da04eb9b0e013eba1b39577106beaef7dc951b" translate="yes" xml:space="preserve">
          <source>Turn an array into a sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6530f1075ffd79f7adf57fbf48c454fea802b4a4" translate="yes" xml:space="preserve">
          <source>Turning the &lt;code&gt;log&lt;/code&gt; proc into a template solves this problem:</source>
          <target state="translated">회전 &lt;code&gt;log&lt;/code&gt; 템플릿에 PROC하면이 문제를 해결할 수 :</target>
        </trans-unit>
        <trans-unit id="6b5850fb86ac4e5bc322e41268cc7861df7f4a1d" translate="yes" xml:space="preserve">
          <source>Turns (value) into (let tmp = value; tmp) so that 'value' can be re-used freely, multiple times. This is frequently required and such a builtin would also be handy to have in macros.nim. The value that can be reused is 'result.lastSon'!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce023416124f914bcf593ab1171ad47e64ee136f" translate="yes" xml:space="preserve">
          <source>Turns &lt;code&gt;c&lt;/code&gt; into a string representation. Example outputs: &lt;code&gt;{keyA: value, keyB: value}&lt;/code&gt;, &lt;code&gt;{:}&lt;/code&gt; If &lt;code&gt;T&lt;/code&gt; is void the outputs look like: &lt;code&gt;{keyA, keyB}&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5c445f42d980d9d76e1b24ead074b3acaa5bae" translate="yes" xml:space="preserve">
          <source>Turns a deque into its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87914654685c51bf6075828a3fc05f1ffba0dd2" translate="yes" xml:space="preserve">
          <source>Turns a heap into its string representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8592a9737bc490409f41923903054f7ad13a61" translate="yes" xml:space="preserve">
          <source>Turns a list into its string representation for logging and printing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a894b4e80dd8a689f15cb3cdb75de82b7974cfe0" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;code&gt;new&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcf0ab5d7d983b90173092de9a62442f37e633f" translate="yes" xml:space="preserve">
          <source>Turns a regular function call into an invocation of the JavaScript's &lt;em&gt;new&lt;/em&gt; operator</source>
          <target state="translated">일반 함수 호출을 JavaScript의 &lt;em&gt;새로운&lt;/em&gt; 호출로 변환&lt;em&gt;&lt;/em&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="410075e7c67c71aa15636d4a25f20948e3529970" translate="yes" xml:space="preserve">
          <source>Turns an &lt;em&gt;openArray&lt;/em&gt; into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a68ab01e5fdf86eb4cc6a9e499aac1727c22cce" translate="yes" xml:space="preserve">
          <source>Turns an &lt;span id=&quot;inminusplace_1&quot;&gt;in-place&lt;/span&gt; algorithm into one that works on a copy and returns this copy, without modifying its input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292edd42e18453646e66461a30abbc138ecc6f39" translate="yes" xml:space="preserve">
          <source>Turns an array into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991bb0cdd074717a07e7eda33f5d12a9f36f5c9e" translate="yes" xml:space="preserve">
          <source>Turns multiple slashes into single slashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38263a1e88c596b067b79f85537502d7865f6da" translate="yes" xml:space="preserve">
          <source>Turns off all runtime checks and turns on the optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4a9c5e9fbeb1731e11e217df10a5e9df4c2462" translate="yes" xml:space="preserve">
          <source>Turns off runtime checks and turns on the optimizer.</source>
          <target state="translated">런타임 검사를 끄고 옵티 마이저를 켭니다.</target>
        </trans-unit>
        <trans-unit id="b70652e73562b96df645462aed3ab29925d1a6e7" translate="yes" xml:space="preserve">
          <source>Turns on the optimizer. More aggressive optimizations are possible, e.g.: &lt;code&gt;--passC:-ffast-math&lt;/code&gt; (but see issue #10305)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f84b7302f8b2c0acedd7493fcbdb678ea820d7e" translate="yes" xml:space="preserve">
          <source>Turns the code generation for all runtime checks on or off.</source>
          <target state="translated">모든 런타임 검사에 대한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="8359c50c168a0d32c1676689b7b9be53909574c9" translate="yes" xml:space="preserve">
          <source>Turns the code generation for array bound checks on or off.</source>
          <target state="translated">배열 바운드 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="78de984f73e6a96b608abf84f509342b6416676c" translate="yes" xml:space="preserve">
          <source>Turns the code generation for assertions on or off.</source>
          <target state="translated">어설 션에 대한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="f85728da201c7e87406c7977edcd7efb848370e2" translate="yes" xml:space="preserve">
          <source>Turns the code generation for nil pointer checks on or off.</source>
          <target state="translated">nil 포인터 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="7443a6fe5c166cf5312e85d734da57674e23a9ea" translate="yes" xml:space="preserve">
          <source>Turns the code generation for over- or underflow checks on or off.</source>
          <target state="translated">오버 플로우 또는 언더 플로우 검사를위한 코드 생성을 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="634d9e7817c9bcc8bdbbd8305a699f04a3c9ba2f" translate="yes" xml:space="preserve">
          <source>Turns the hint messages of the compiler on or off.</source>
          <target state="translated">컴파일러의 힌트 메시지를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="96dcbf296f2f4c34221163dd4a790e8efb28f099" translate="yes" xml:space="preserve">
          <source>Turns the term rewriting templates/macros on or off.</source>
          <target state="translated">템플릿 / 매크로 다시 쓰기 용어를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="f31cc462c8ec7105eb07e2c1b5bb943c21db3b4d" translate="yes" xml:space="preserve">
          <source>Turns the warning messages of the compiler on or off.</source>
          <target state="translated">컴파일러의 경고 메시지를 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="779de5f9680bb0a0d05277f00d89d734c054b346" translate="yes" xml:space="preserve">
          <source>Tutorial (part I)</source>
          <target state="translated">튜토리얼 (1 부)</target>
        </trans-unit>
        <trans-unit id="e8a76eed53f23547280f2ddf6517628c83064326" translate="yes" xml:space="preserve">
          <source>Tutorial (part II)</source>
          <target state="translated">튜토리얼 (2 부)</target>
        </trans-unit>
        <trans-unit id="12eddb48c045f6baba27243ad34ddf90603d7edf" translate="yes" xml:space="preserve">
          <source>Tutorial (part III)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5778f261d1733e81971ab8e088ac48fafe7c0eb" translate="yes" xml:space="preserve">
          <source>Tweaking the GC</source>
          <target state="translated">GC 조정</target>
        </trans-unit>
        <trans-unit id="04c56f6663c1accf7ccbcdda0087beb3f2683037" translate="yes" xml:space="preserve">
          <source>Tweaking the garbage collector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfc4e5ee613e56b16e91f9c1891af1bb27a177f" translate="yes" xml:space="preserve">
          <source>Tweaking the refc GC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778080b9d6142ab857443b50014ddb8d3ccd44e2" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;Timezone&lt;/code&gt;'s are considered equal if their name is equal.</source>
          <target state="translated">이름이 같으면 두 개의 &lt;code&gt;Timezone&lt;/code&gt; 가 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6a865c6e91cc1b9c8041b930bdded2be0556b0e5" translate="yes" xml:space="preserve">
          <source>Two identifiers are considered equal if the following algorithm returns true:</source>
          <target state="translated">다음 알고리즘이 true를 반환하면 두 식별자가 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="24954bd408579a9efa899f397b4b12b6c9f4f267" translate="yes" xml:space="preserve">
          <source>Two output parameters should never be aliased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6298e080874877d7a98b594edb938f20831dfff6" translate="yes" xml:space="preserve">
          <source>Two spaces should be used for indentation of blocks; tabstops are not allowed (the compiler enforces this). Using spaces means that the appearance of code is more consistent across editors. Unlike spaces, tabstop width varies across editors, and not all editors provide means of changing this width.</source>
          <target state="translated">블록의 들여 쓰기에는 두 개의 공백이 사용되어야합니다. tabstops는 허용되지 않습니다 (컴파일러가이를 시행합니다). 공백을 사용한다는 것은 코드 전체가 편집기에서보다 일관되게 나타납니다. 공백과 달리 탭 스톱 너비는 편집기마다 다르며 모든 편집기가이 너비를 변경하는 수단을 제공하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="04ebb4da7a084030b721611207edce2d27a82c1d" translate="yes" xml:space="preserve">
          <source>Type Class representing valid types for use with atomic procs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4286f84aa2ec1726d2f29d48fef0c9bf605e85" translate="yes" xml:space="preserve">
          <source>Type Classes</source>
          <target state="translated">타입 클래스</target>
        </trans-unit>
        <trans-unit id="5e1573953474c6c0a25673b1f064154b46a8a93e" translate="yes" xml:space="preserve">
          <source>Type Conversion</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="c0eb387e477546545eec601f050672bd06c02038" translate="yes" xml:space="preserve">
          <source>Type Suffix</source>
          <target state="translated">접미사</target>
        </trans-unit>
        <trans-unit id="517963ffe8430bed0d4f132dcd51c0d4eb3001b7" translate="yes" xml:space="preserve">
          <source>Type bound operations</source>
          <target state="translated">타입 바운드 연산</target>
        </trans-unit>
        <trans-unit id="b2ce942200cd4ed497c93d87123ffa3584d50070" translate="yes" xml:space="preserve">
          <source>Type casts</source>
          <target state="translated">캐스트</target>
        </trans-unit>
        <trans-unit id="bf3e880739673e946c25d0dedcde2653a7c48216" translate="yes" xml:space="preserve">
          <source>Type casts are a crude mechanism to interpret the bit pattern of an expression as if it would be of another type. Type casts are only needed for low-level programming and are inherently unsafe.</source>
          <target state="translated">타입 캐스트는 표현식의 비트 패턴을 마치 다른 타입 인 것처럼 해석하는 조잡한 메커니즘입니다. 타입 캐스트는 저수준 프로그래밍에만 필요하며 본질적으로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcb23833423a0c957ef8e5ee3ce4a0cc20e63ea9" translate="yes" xml:space="preserve">
          <source>Type casts should not be confused with &lt;em&gt;type conversions,&lt;/em&gt; as mentioned in the prior section. Unlike type conversions, a type cast cannot change the underlying bit pattern of the data being casted (aside from that the size of the target type may differ from the source type). Casting resembles &lt;em&gt;type punning&lt;/em&gt; in other languages or C++'s &lt;code&gt;reinterpret_cast&lt;/code&gt; and &lt;code&gt;bit_cast&lt;/code&gt; features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25c1533427c8ff248b8fa04b1c204166e4d6cfb" translate="yes" xml:space="preserve">
          <source>Type class matching all floating point number types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8994b5555953cecba5cb081c02065f691c4aade1" translate="yes" xml:space="preserve">
          <source>Type class matching all integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1410da13aa78eef42cd75e9aef9e7ae941423f0" translate="yes" xml:space="preserve">
          <source>Type class matching all number types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7e962b06f2dac22d8ef78d4c96b0beac2ff0ac" translate="yes" xml:space="preserve">
          <source>Type class matching all ordinal types; however this includes enums with holes. See also &lt;code&gt;Ordinal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565f4c82db0ce42bc5ab6b923e5ac75a404d5a81" translate="yes" xml:space="preserve">
          <source>Type class matching all signed integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740183d28c2d3d07b55c914d92dfe4035410fee0" translate="yes" xml:space="preserve">
          <source>Type class matching all unsigned integer types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21eb352df05ecea6a3a588dc0c8590e21dbccc2" translate="yes" xml:space="preserve">
          <source>Type classes can be combined using the standard boolean operators to form more complex type classes:</source>
          <target state="translated">표준 부울 연산자를 사용하여 형식 클래스를 결합하여보다 복잡한 형식 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c79e908c3824182db454f062b8835b391eaee1" translate="yes" xml:space="preserve">
          <source>Type conversion can also be used to disambiguate overloaded routines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d7f20ec3a1f2c32685f21a24578ef7bfd33afb" translate="yes" xml:space="preserve">
          <source>Type conversions</source>
          <target state="translated">타입 변환</target>
        </trans-unit>
        <trans-unit id="7893cb518df1f3e86b37b8f2c89bf262fddc71ea" translate="yes" xml:space="preserve">
          <source>Type conversions are a much more polite way to convert a type into another: They preserve the abstract &lt;em&gt;value&lt;/em&gt;, not necessarily the &lt;em&gt;bit-pattern&lt;/em&gt;. If a type conversion is not possible, the compiler complains or an exception is raised.</source>
          <target state="translated">형식 변환은 형식을 다른 형식으로 변환하는 훨씬 더 정중 한 방법 &lt;em&gt;입니다&lt;/em&gt; . 반드시 &lt;em&gt;비트 패턴이&lt;/em&gt; 아닌 추상 &lt;em&gt;값을&lt;/em&gt; 유지합니다 . 유형 변환이 불가능하면 컴파일러가 불평하거나 예외가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d227e4926b1f493d28e95f292386e3a242d08693" translate="yes" xml:space="preserve">
          <source>Type conversions are compile-time computable.</source>
          <target state="translated">타입 변환은 컴파일 타임 계산 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bdf318c64b4a51210846dda92e239137e03f96fe" translate="yes" xml:space="preserve">
          <source>Type describing the endianness of a processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705eb0947010d2f2d419bb724e3d94cb8a2e7780" translate="yes" xml:space="preserve">
          <source>Type equality</source>
          <target state="translated">유형 평등</target>
        </trans-unit>
        <trans-unit id="ad5ad7af6975f8633efeb665458c5b9ad70586b8" translate="yes" xml:space="preserve">
          <source>Type equality modulo type distinction</source>
          <target state="translated">타입 평등 모듈로 타입 구별</target>
        </trans-unit>
        <trans-unit id="c5a4537d409bc84d0e6885dd98224efa069a4125" translate="yes" xml:space="preserve">
          <source>Type identifiers should be in PascalCase. All other identifiers should be in camelCase with the exception of constants which &lt;strong&gt;may&lt;/strong&gt; use PascalCase but are not required to.</source>
          <target state="translated">타입 식별자는 PascalCase에 있어야합니다. PascalCase를 사용할 &lt;strong&gt;수&lt;/strong&gt; 있지만 필수는 아닌 상수를 제외하고 다른 모든 식별자는 camelCase에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6cdb48b9a7ae81b2d7e34e795c5ca9c78816283e" translate="yes" xml:space="preserve">
          <source>Type info generation for the JS backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f50bbe8baba25a1929146d13b1d95279794e199" translate="yes" xml:space="preserve">
          <source>Type of the symbol. This can be &lt;code&gt;skProc&lt;/code&gt;, &lt;code&gt;skLet&lt;/code&gt;, and just about any of the enums defined in the module &lt;code&gt;compiler/ast.nim&lt;/code&gt;.</source>
          <target state="translated">심볼의 유형입니다. 이것은 &lt;code&gt;skProc&lt;/code&gt; , &lt;code&gt;skLet&lt;/code&gt; 일 수 있으며 모듈 &lt;code&gt;compiler/ast.nim&lt;/code&gt; 에 정의 된 열거 형 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbabd93da3123882a924672c6250533f840354ef" translate="yes" xml:space="preserve">
          <source>Type relations</source>
          <target state="translated">타입 관계</target>
        </trans-unit>
        <trans-unit id="f8b2d40508694dd4577a697d9c6b4c5f2e3511da" translate="yes" xml:space="preserve">
          <source>Type section</source>
          <target state="translated">유형 섹션</target>
        </trans-unit>
        <trans-unit id="19ed3f78d17ddb423376e5e7d24d9be0086053f6" translate="yes" xml:space="preserve">
          <source>Type sections</source>
          <target state="translated">유형 섹션</target>
        </trans-unit>
        <trans-unit id="caebdb05624ce558cc24e284e7ee360a137ea7d2" translate="yes" xml:space="preserve">
          <source>Type that can hold a single Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a919a22549142ebb39423637cf5e8cc1b5dc6cbb" translate="yes" xml:space="preserve">
          <source>Type that describes &quot;standard format specifiers&quot;.</source>
          <target state="translated">&quot;표준 형식 지정자&quot;를 설명하는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="14b70f38880bb4c9b3736c428ce15bf9ddfdfa1b" translate="yes" xml:space="preserve">
          <source>Type that is constructed by &lt;code&gt;^&lt;/code&gt; for reversed array accesses. (See &lt;a href=&quot;#%5E.t,int&quot;&gt;^ template&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032fbf901a92d8ba594b05e679993e6b981d225b" translate="yes" xml:space="preserve">
          <source>Type union representing &lt;code&gt;HashSet&lt;/code&gt; or &lt;code&gt;OrderedSet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ed1febf2dc93666a9e94d3bca2653e2f2eba89" translate="yes" xml:space="preserve">
          <source>Type/signature. For variables and enums this will contain the type of the symbol, for procs, methods and templates this will contain the full unique signature (e.g. &lt;code&gt;proc (File)&lt;/code&gt;).</source>
          <target state="translated">타입 / 서명. 변수 및 열거 형의 경우 여기에는 기호 유형이 포함되며, 프로세스, 메소드 및 템플릿의 경우 완전한 고유 서명 (예 : &lt;code&gt;proc (File)&lt;/code&gt; )이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1afd965c71f69efe092cfb0d0da2e47e018c1458" translate="yes" xml:space="preserve">
          <source>TypeCache:</source>
          <target state="translated">TypeCache:</target>
        </trans-unit>
        <trans-unit id="0aa83d8e7bf39f57f10caf572c84d7e435d76d43" translate="yes" xml:space="preserve">
          <source>TypeCacheWithOwner:</source>
          <target state="translated">TypeCacheWithOwner:</target>
        </trans-unit>
        <trans-unit id="5204c9867a362caf0bea9525b902dfe2dc066c0b" translate="yes" xml:space="preserve">
          <source>Typed future.</source>
          <target state="translated">입력 된 미래.</target>
        </trans-unit>
        <trans-unit id="a1cf3d18ff7e16dcb6cdb495e43f6f5c061a5575" translate="yes" xml:space="preserve">
          <source>Typed vs untyped parameters</source>
          <target state="translated">유형화되지 않은 매개 변수</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="a4d826f2d99cd7f5fe802f315c32dc5f53188f2d" translate="yes" xml:space="preserve">
          <source>Typical usage for each logging level, from lowest to highest, is described below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c69ab987059b075ca59e012555a1691460df54" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;a href=&quot;net#connect%2CSocket%2Cstring&quot;&gt;connect&lt;/a&gt; procedure. They can simply start sending data immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5720ec6d00feb96f366d8679918ecb98f50f66f7" translate="yes" xml:space="preserve">
          <source>UDP is a connectionless protocol, so UDP sockets don't have to explicitly call the &lt;code&gt;connect&lt;/code&gt; procedure. They can simply start sending data immediately.</source>
          <target state="translated">UDP는 비 연결 프로토콜이므로 UDP 소켓은 &lt;code&gt;connect&lt;/code&gt; 절차 를 명시 적으로 호출 할 필요가 없습니다 . 그들은 단순히 데이터를 즉시 보내기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9248393d371f6ac0d6c435085d705c597add4700" translate="yes" xml:space="preserve">
          <source>UNIX domain socket.</source>
          <target state="translated">UNIX 도메인 소켓</target>
        </trans-unit>
        <trans-unit id="5994d61577cd9a76d59a20c617c73875837d1477" translate="yes" xml:space="preserve">
          <source>UNIX specific</source>
          <target state="translated">유닉스 전용</target>
        </trans-unit>
        <trans-unit id="26c859ee3fb5d4d62e0efa2847233766e5ddaefc" translate="yes" xml:space="preserve">
          <source>URL Safe Base64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08be76278172f212466b4e4efbc9f3b81608c450" translate="yes" xml:space="preserve">
          <source>Un-necessary allocations are avoided and appropriate algorithms are used at the expense of code clarity when justified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b518ac79c337e4bc96c2923b9da28064822828b" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;+&lt;/code&gt; operator for an integer. Has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b171ced91159e0a196e56ce77416b733c4e754c" translate="yes" xml:space="preserve">
          <source>Unary &lt;code&gt;-&lt;/code&gt; operator for an integer. Negates &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b8776f6733aef4d62e2f6de4be839fb81aa572" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;+&lt;/em&gt; operator for an integer. Has no effect.</source>
          <target state="translated">정수에 대한 단항 &lt;em&gt;+&lt;/em&gt; 연산자. 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb73268790c9b1bb4d1863a2400ec7e0bd4b9f82" translate="yes" xml:space="preserve">
          <source>Unary &lt;em&gt;-&lt;/em&gt; operator for an integer. Negates &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">단항 &lt;em&gt;-&lt;/em&gt; 정수 연산자. &lt;em&gt;x를&lt;/em&gt; 부정 합니다.</target>
        </trans-unit>
        <trans-unit id="f2efdf3396f6406dd06e7f15768f255977acfd0a" translate="yes" xml:space="preserve">
          <source>Unary &lt;span id=&quot;slice_2&quot;&gt;slice&lt;/span&gt; operator that constructs an interval &lt;code&gt;[default(int), b]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70afc8908f864590618bb835ddbe12b01425b489" translate="yes" xml:space="preserve">
          <source>Unary minus for complex numbers.</source>
          <target state="translated">복소수에 대한 단항 빼기.</target>
        </trans-unit>
        <trans-unit id="2b26f2db358e2b9c8ee6c1ec77a16447b17be07f" translate="yes" xml:space="preserve">
          <source>Unary minus for rational numbers.</source>
          <target state="translated">유리수에 대한 단항 빼기.</target>
        </trans-unit>
        <trans-unit id="26886835eb6cc81330ad426b552f908727e34bfa" translate="yes" xml:space="preserve">
          <source>Unary operators always bind stronger than any binary operator: &lt;code&gt;$a + b&lt;/code&gt; is &lt;code&gt;($a) + b&lt;/code&gt; and not &lt;code&gt;$(a + b)&lt;/code&gt;.</source>
          <target state="translated">단항 연산자는 항상 이항 연산자보다 강력하게 바인딩됩니다. &lt;code&gt;$a + b&lt;/code&gt; 는 &lt;code&gt;$(a + b)&lt;/code&gt; 아니라 &lt;code&gt;($a) + b&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d1b9627be7abe82c7754c81d7b9ac180e552d8f7" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;code&gt;==&lt;/code&gt; operator and also when types dependent on them are being matched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15caf31c9aaa57bf878b33c847d4e21c87bdd599" translate="yes" xml:space="preserve">
          <source>Unbound static params will be inferred from expressions involving the &lt;em&gt;==&lt;/em&gt; operator and also when types dependent on them are being matched:</source>
          <target state="translated">바인딩되지 않은 정적 매개 변수는 &lt;em&gt;==&lt;/em&gt; 연산자를 포함하는 표현식과 해당 유형에 종속 된 유형이 일치 할 때 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c3eeb69afc01f369c316019c678b4ba126d3679" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;code&gt;s.push(T)&lt;/code&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;code&gt;x.pop is T&lt;/code&gt; and &lt;code&gt;x.data is seq[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb24ca63e88421d2f543a770d935d8deff96d75" translate="yes" xml:space="preserve">
          <source>Unbound types can appear both as params to calls such as &lt;em&gt;s.push(T)&lt;/em&gt; and on the right-hand side of the &lt;code&gt;is&lt;/code&gt; operator in cases such as &lt;em&gt;x.pop is T&lt;/em&gt; and &lt;em&gt;x.data is seq[T]&lt;/em&gt;.</source>
          <target state="translated">언 바운드 유형은 &lt;em&gt;.s.push (T)&lt;/em&gt; 와 같은 호출에 대한 매개 변수 와 &lt;em&gt;x.pop이 T&lt;/em&gt; 이고 &lt;em&gt;x.data가 seq [T] 인&lt;/em&gt; 경우 &lt;code&gt;is&lt;/code&gt; 연산자 의 오른쪽에 모두 표시 될 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c3ed69a126746aabd63e358344911c553469b30" translate="yes" xml:space="preserve">
          <source>Unchecked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a277ebe87b91b0033079926c198a2b95dd5a89ed" translate="yes" xml:space="preserve">
          <source>Unchecked pragma</source>
          <target state="translated">확인되지 않은 pragma</target>
        </trans-unit>
        <trans-unit id="780b27a9e0cd026ae3df440893ad4cc13c021cef" translate="yes" xml:space="preserve">
          <source>Under Windows, &lt;code&gt;ShellExecute&lt;/code&gt; is used. Under Mac OS X the &lt;code&gt;open&lt;/code&gt; command is used. Under Unix, it is checked if &lt;code&gt;xdg-open&lt;/code&gt; exists and used if it does. Otherwise the environment variable &lt;code&gt;BROWSER&lt;/code&gt; is used to determine the default browser to use.</source>
          <target state="translated">Windows에서는 &lt;code&gt;ShellExecute&lt;/code&gt; 가 사용됩니다. Mac OS X에서는 &lt;code&gt;open&lt;/code&gt; 명령이 사용됩니다. 유닉스에서는 &lt;code&gt;xdg-open&lt;/code&gt; 이 존재 하는지 검사 하고 존재한다면 사용합니다. 그렇지 않으면 환경 변수 &lt;code&gt;BROWSER&lt;/code&gt; 를 사용하여 사용할 기본 브라우저를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b4e16afd830482ab436e6b9d76d2fcedf615298d" translate="yes" xml:space="preserve">
          <source>Under the &lt;code&gt;--gc:arc|orc&lt;/code&gt; modes Nim's &lt;code&gt;ref&lt;/code&gt; type is implemented via the same runtime &quot;hooks&quot; and thus via reference counting. This means that cyclic structures cannot be freed immediately (&lt;code&gt;--gc:orc&lt;/code&gt; ships with a cycle collector). With the &lt;code&gt;.cursor&lt;/code&gt; annotation one can break up cycles declaratively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf8b89716eab57348a639af00765efe9e3f101" translate="yes" xml:space="preserve">
          <source>Underflow: operation produces a result that is too small to be represented as a normal number, for example, MINDOUBLE * MINDOUBLE.</source>
          <target state="translated">언더 플로 : 연산은 너무 작아서 일반 숫자로 표현하기에 너무 작습니다 (예 : MINDOUBLE * MINDOUBLE).</target>
        </trans-unit>
        <trans-unit id="58ba826c45dce7d957937f1e6f84d4a93f7c990b" translate="yes" xml:space="preserve">
          <source>Unequals operator. This is a shorthand for &lt;code&gt;not (x == y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18949943f1b3a53df4651c7816095f5de22eef" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec38b8f74e8905e6cb3c56b8e4d8603f3e7c7d9" translate="yes" xml:space="preserve">
          <source>Unescapes a string &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;s를&lt;/em&gt; 이스케이프 해제 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b681f3dab8eeb99f700c878d07af066931b521" translate="yes" xml:space="preserve">
          <source>Unfortunately optimizations are hard to get right and even the tiny example is &lt;strong&gt;wrong&lt;/strong&gt;:</source>
          <target state="translated">불행히도 최적화는 제대로 이루어지기 어렵고 작은 예제조차 &lt;strong&gt;잘못되었습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="979fe2a9e37e36b1d1a6a4517ab5b601b5d48fdb" translate="yes" xml:space="preserve">
          <source>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</source>
          <target state="translated">불행하게도 try 문의 의미가 항상 정확하지 않을 수도 있으며 때로는 컴파일이 완전히 실패 할 수도 있습니다. 따라서 가능하면 전자를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fab317435de1ae8699f1bac973f0926492ea1744" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;d + 12.Dollar&lt;/code&gt; is not allowed either, because &lt;code&gt;+&lt;/code&gt; is defined for &lt;code&gt;int&lt;/code&gt; (among others), not for &lt;code&gt;Dollar&lt;/code&gt;. So a &lt;code&gt;+&lt;/code&gt; for dollars needs to be defined:</source>
          <target state="translated">불행히도, &lt;code&gt;d + 12.Dollar&lt;/code&gt; 때문에, 어느 허용되지 &lt;code&gt;+&lt;/code&gt; 가 정의되어 &lt;code&gt;int&lt;/code&gt; 아닌 다른 사람 () &lt;code&gt;Dollar&lt;/code&gt; . 따라서 달러 에 &lt;code&gt;+&lt;/code&gt; 를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="257828b764d9609e93e07a012bbe1f755b3e4143" translate="yes" xml:space="preserve">
          <source>Unicast link-local address.</source>
          <target state="translated">유니 캐스트 링크 로컬 주소</target>
        </trans-unit>
        <trans-unit id="db89ced902c1b469d3ee6d37350cad15573da1b7" translate="yes" xml:space="preserve">
          <source>Unicast site-local address.</source>
          <target state="translated">유니 캐스트 사이트 로컬 주소</target>
        </trans-unit>
        <trans-unit id="bad1fc2425affd686a4928faa36042363958ccf7" translate="yes" xml:space="preserve">
          <source>Unicode combining characters are correctly interpreted as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3781765e85fd98bc0b743ec878930ad45c9936e" translate="yes" xml:space="preserve">
          <source>Uniform Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20432d22d5eb062ea9c2106c1c80aefa6d897164" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">각 행 Unindents &lt;code&gt;s&lt;/code&gt; 에 의해 &lt;code&gt;count&lt;/code&gt; 량 &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c52400f9c64e17163dee3359a107d4513be811c2" translate="yes" xml:space="preserve">
          <source>Unindents each line in &lt;code&gt;s&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt; amount of &lt;code&gt;padding&lt;/code&gt;. The only difference between this and the &lt;a href=&quot;#unindent,string,Natural,string&quot;&gt;unindent proc&lt;/a&gt; is that this by default only cuts off the amount of indentation that all lines of &lt;code&gt;s&lt;/code&gt; share as opposed to all indentation. It only supports spaces as padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d1bc1786787b9f5cf6f8701a1fb442f4f59285" translate="yes" xml:space="preserve">
          <source>Union</source>
          <target state="translated">Union</target>
        </trans-unit>
        <trans-unit id="924d62607597504901be1ad3edea9517a5c76a1f" translate="yes" xml:space="preserve">
          <source>Union pragma</source>
          <target state="translated">연합 프라 그마</target>
        </trans-unit>
        <trans-unit id="74c7db218dedd779b36f1a6025b0a8e82da0f838" translate="yes" xml:space="preserve">
          <source>Unix Socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa0003b8a6b26c8afe5d3f50a8127082e93fdb8" translate="yes" xml:space="preserve">
          <source>Unknown file type.</source>
          <target state="translated">알 수없는 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5d54b46bfaf14d75428528167ddeece95ff7879d" translate="yes" xml:space="preserve">
          <source>UnknownLockLevel:</source>
          <target state="translated">UnknownLockLevel:</target>
        </trans-unit>
        <trans-unit id="166ac37560cdd4598d06f97eb16234b6f79cecbb" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;code&gt;{.pure.}&lt;/code&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d54b69a2b42e57628182cdd2fb4ccd4dc4e49e" translate="yes" xml:space="preserve">
          <source>Unless marked with the &lt;em&gt;{.pure.}&lt;/em&gt; pragma, members of enums should have an identifying prefix, such as an abbreviation of the enum's name.</source>
          <target state="translated">&lt;em&gt;{.pure.}&lt;/em&gt; pragma 로 표시되지 않은 경우 열거 형 멤버에는 열거 형 이름의 약어와 같이 식별 접두사가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c77cfc5cfbe4717f5e7654df9d751e7a64ef661c" translate="yes" xml:space="preserve">
          <source>Unless you are implementing a custom logger, there is little need to call this directly. Use either a logger's log method or one of the logging templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1db02d8fefccbf077d86e2884c344faded7045" translate="yes" xml:space="preserve">
          <source>Unless you explicitly use the &lt;code&gt;-o:filename.js&lt;/code&gt; switch as mentioned in the previous examples, the compiler will create a &lt;code&gt;filename.js&lt;/code&gt; file in the &lt;code&gt;nimcache&lt;/code&gt; directory using the name of your input nim file. There are no other temporary files generated, the output is always a single self contained &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">이전 예제에서 언급 한대로 &lt;code&gt;-o:filename.js&lt;/code&gt; 스위치 를 명시 적으로 사용하지 않으면 컴파일러는 입력 nim 파일의 이름을 사용하여 &lt;code&gt;nimcache&lt;/code&gt; 디렉토리 에 &lt;code&gt;filename.js&lt;/code&gt; 파일을 작성 합니다. 다른 임시 파일이 생성되지 않으며 출력은 항상 하나의 자체 포함 된 &lt;code&gt;.js&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="555ac3aebe10e2203997f49b6308860e82f3cf38" translate="yes" xml:space="preserve">
          <source>Unless your application has very specific requirements and solely targets JavaScript, you should be using the relevant functions in the &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;times&lt;/code&gt; stdlib modules instead.</source>
          <target state="translated">응용 프로그램에 특정 요구 사항이 있고 JavaScript 만 대상으로하지 않는 한 &lt;code&gt;math&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;times&lt;/code&gt; stdlib 모듈 의 관련 함수를 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8a103bee5df59c3c762061b4c9d13541d1ab2e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;read&lt;/code&gt;, this function will not raise an exception if the Future has not been finished.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 와 달리 ,이 함수는 Future가 완료되지 않은 경우 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86d3c06510e1a9b072a372d11ed5099a19477622" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;sockets.recvLine&lt;/code&gt; this function will raise an EOS or ESSL exception if an error occurs.</source>
          <target state="translated">&lt;code&gt;sockets.recvLine&lt;/code&gt; 과 달리이 함수는 오류가 발생하면 EOS 또는 ESSL 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e750c92c37341f3392054d626734256f8a0787c9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual paramater with &lt;a href=&quot;#paramStr&quot;&gt;paramStr()&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams()&lt;/a&gt;.</source>
          <target state="translated">C의 &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; 와 달리 바이너리가 매개 변수없이 호출되면 0이 반환됩니다. &lt;a href=&quot;#paramStr&quot;&gt;paramStr ()을 사용&lt;/a&gt; 하여 각 개별 매개 변수를 쿼리 하거나 &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams ()&lt;/a&gt; 을 사용하여 모든 매개 변수를 한 번에 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c9f5fc5648b91a0ecea42942dbf604af71e575e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;span id=&quot;argc_1&quot;&gt;argc&lt;/span&gt; in C, if your binary was called without parameters this will return zero. You can query each individual parameter with &lt;a href=&quot;#paramStr,int&quot;&gt;paramStr proc&lt;/a&gt; or retrieve all of them in one go with &lt;a href=&quot;#commandLineParams&quot;&gt;commandLineParams proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834e7e344f224920e087953eb402fca07a2f1f3c" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="translated">다른 IO 작업과 달리 &lt;code&gt;echo&lt;/code&gt; 는 디버깅 편의를 위해 자주 사용 되므로 스레드로부터 안전 합니다. 당신이 사용하려는 경우 &lt;code&gt;echo&lt;/code&gt; 돌며 &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;부작용없이 PROC&lt;/a&gt; 당신이 사용할 수있는 &lt;a href=&quot;#debugEcho&quot;&gt;debugEcho을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="bb1d8697e6f5b8b93bcc0fbb54b7a52aa6ab9c41" translate="yes" xml:space="preserve">
          <source>Unlike other IO operations this is guaranteed to be thread-safe as &lt;code&gt;echo&lt;/code&gt; is very often used for debugging convenience. If you want to use &lt;code&gt;echo&lt;/code&gt; inside a &lt;a href=&quot;manual#pragmas-nosideeffect-pragma&quot;&gt;proc without side effects&lt;/a&gt; you can use &lt;a href=&quot;#debugEcho,varargs%5Btyped,%5D&quot;&gt;debugEcho&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a7eb1335a4c8a4d13042f64d4169aab404e95e" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#all,openArray%5BT%5D,proc(T)&quot;&gt;all proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;allIt(&quot;abba&quot;, it == 'a')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b25e1135d73b4979029b11d846cffe0d4e62bc0" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#any,openArray%5BT%5D,proc(T)&quot;&gt;any proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;anyIt(&quot;abba&quot;, it == 'a')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df788be57d38cfdfe8e607fa4cc3da35094447d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#filter,openArray%5BT%5D,proc(T)&quot;&gt;filter proc&lt;/a&gt; and &lt;a href=&quot;#filter.i,openArray%5BT%5D,proc(T)&quot;&gt;filter iterator&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dffcac06d6078b88787893047caf056ddba47e3" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#keepIf,seq%5BT%5D,proc(T)&quot;&gt;keepIf proc&lt;/a&gt;, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22870d2d3c9ed068f87598a420f675c1914b8e0c" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;em&gt;PROC의&lt;/em&gt; 버전 술어가 필요하여 표현 될 &lt;code&gt;it&lt;/code&gt; : 같은 테스트를 위해 변수 &lt;code&gt;filterIt(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7abf83a8fb810b07df5666c0186be330c1d74dbb" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;em&gt;proc&lt;/em&gt; version, the predicate needs to be an expression using the &lt;code&gt;it&lt;/code&gt; variable for testing, like: &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;proc&lt;/em&gt; 버전 과 달리 술어는 테스트 를 위해 &lt;code&gt;it&lt;/code&gt; 변수를 사용하는 표현식이어야합니다 . &lt;code&gt;keepItIf(&quot;abcxyz&quot;, it == 'x')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea70e7b2b434633b0b06e23b1f895b37ed910c3" translate="yes" xml:space="preserve">
          <source>Unlock pages starting from a1 for a1 bytes and allow them to be swapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1220ad1301b65c81ce9bc7668e60651b0a6e0b98" translate="yes" xml:space="preserve">
          <source>Unlocks all memory for the running process to allow swapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fecd7c098d4594a31a6bfb718661e5d0021b5" translate="yes" xml:space="preserve">
          <source>Unmarshalling</source>
          <target state="translated">Unmarshalling</target>
        </trans-unit>
        <trans-unit id="e21aec3b4730e3f9365e0105b5ee932445d7a6ca" translate="yes" xml:space="preserve">
          <source>Unmarshalling JSON into a type</source>
          <target state="translated">JSON을 형식으로 비 정렬 화</target>
        </trans-unit>
        <trans-unit id="00c3031c922055e41a04fe1f36e44c0871affcd9" translate="yes" xml:space="preserve">
          <source>Unnamed procedures can be used as lambda expressions to pass into other procedures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274fd6abb97e41f164eb1ef8fe9181521b3bcfb9" translate="yes" xml:space="preserve">
          <source>Unregisters &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; 등록을 취소 합니다.</target>
        </trans-unit>
        <trans-unit id="cc5d6ca9aa56c6378bdd4192beb1a23d43d8436b" translate="yes" xml:space="preserve">
          <source>Unregisters deleg &lt;code&gt;deleg&lt;/code&gt; from dispatcher &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">디스패처 &lt;code&gt;d&lt;/code&gt; 에서 위임 &lt;code&gt;deleg&lt;/code&gt; 을 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="da32f8ccff4f9629c24e55368ee80c187804e943" translate="yes" xml:space="preserve">
          <source>Unregisters event &lt;code&gt;ev&lt;/code&gt;.</source>
          <target state="translated">이벤트 &lt;code&gt;ev&lt;/code&gt; 를 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="fcde071a887a5fe31b2a030c3e5fa7b13b8951b5" translate="yes" xml:space="preserve">
          <source>Unregisters file/socket descriptor &lt;code&gt;fd&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">선택기 &lt;code&gt;s&lt;/code&gt; 에서 파일 / 소켓 디스크립터 &lt;code&gt;fd&lt;/code&gt; 를 등록 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="289ac9aad529193af73566b90baf875386cf6586" translate="yes" xml:space="preserve">
          <source>Unregisters user-defined event &lt;code&gt;ev&lt;/code&gt; from selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">등록을 해제 사용자 정의 이벤트 &lt;code&gt;ev&lt;/code&gt; 선택에서 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef917446c92814f3fe225d448c9dd016899c48e" translate="yes" xml:space="preserve">
          <source>Unsigned 16 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed468bf679e5b1f5808790c2a19e95d512a2b2a8" translate="yes" xml:space="preserve">
          <source>Unsigned 32 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d7e382d3bf439812e3803ec8a443a454d1726f" translate="yes" xml:space="preserve">
          <source>Unsigned 64 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b11a7b01485a2c63525c49dc3fe966f7bea903" translate="yes" xml:space="preserve">
          <source>Unsigned 8 bit integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97fa8d5ff01f95267b94caf79b8f3070f72dfcf" translate="yes" xml:space="preserve">
          <source>Unsigned default integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce62d653fe1244a4a172cf34cf9ff901d873cb95" translate="yes" xml:space="preserve">
          <source>Unsigned operations all wrap around; they cannot lead to over- or under-flow errors.</source>
          <target state="translated">서명되지 않은 작업은 모두 마무리됩니다. 오버플로 또는 언더 플로 오류가 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="793e97a099a191f13d3623cc72e9fcc4ea98314f" translate="yes" xml:space="preserve">
          <source>Unspecified address.</source>
          <target state="translated">지정되지 않은 주소</target>
        </trans-unit>
        <trans-unit id="5c457d2272b8e63c2b91ba916ee48f5876df5664" translate="yes" xml:space="preserve">
          <source>UnspecifiedLockLevel:</source>
          <target state="translated">UnspecifiedLockLevel:</target>
        </trans-unit>
        <trans-unit id="ed961fcd4c8176dc450c49284ace2318f446a007" translate="yes" xml:space="preserve">
          <source>Unstable API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6076c17bc49c0e24e74221d46dcde766430db135" translate="yes" xml:space="preserve">
          <source>Unstable API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ad21855bb503556f8c5a04db8667a68253a7e7" translate="yes" xml:space="preserve">
          <source>Untyped base class for &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2eed1f531c71d473a16fbfc4bdc992980d7fde4" translate="yes" xml:space="preserve">
          <source>Untyped future.</source>
          <target state="translated">형식화되지 않은 미래.</target>
        </trans-unit>
        <trans-unit id="338a06f904b267724d0e4a6607e91229e8bd5122" translate="yes" xml:space="preserve">
          <source>Unused symbols in the code.</source>
          <target state="translated">코드에서 사용되지 않은 기호.</target>
        </trans-unit>
        <trans-unit id="b761e5e6e2982b87d1d1ce7451421af2e056fcdd" translate="yes" xml:space="preserve">
          <source>Update file/socket descriptor &lt;code&gt;fd&lt;/code&gt;, registered in selector &lt;code&gt;s&lt;/code&gt; with new events set &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="translated">업데이트 파일 / 소켓 기술자 &lt;code&gt;fd&lt;/code&gt; , 셀렉터에 등록 &lt;code&gt;s&lt;/code&gt; 새로운 이벤트 세트 &lt;code&gt;event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42cfa979c0a47064ebf21099c1cc012f9b61f497" translate="yes" xml:space="preserve">
          <source>Updates the &lt;code&gt;MD5Context&lt;/code&gt; with the &lt;code&gt;input&lt;/code&gt; data of length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ac74192ba332a2e96c10e6e3a98aa5ef90a38c" translate="yes" xml:space="preserve">
          <source>Uploading a new file</source>
          <target state="translated">새 파일 업로드</target>
        </trans-unit>
        <trans-unit id="8437e83622dcd6616eee43bc0f900abcc44066bc" translate="yes" xml:space="preserve">
          <source>Uploads &lt;code&gt;file&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt; on the remote FTP server. Usage of this function asynchronously is recommended to view the progress of the download. The &lt;code&gt;EvStore&lt;/code&gt; event is passed to the specified &lt;code&gt;handleEvent&lt;/code&gt; function when the upload is finished, and the &lt;code&gt;filename&lt;/code&gt; field will be equal to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">원격 FTP 서버 에서 &lt;code&gt;dest&lt;/code&gt; 으로 &lt;code&gt;file&lt;/code&gt; 을 업로드 합니다. 다운로드 진행 상황을 보려면이 기능을 비동기 적으로 사용하는 것이 좋습니다. &lt;code&gt;EvStore&lt;/code&gt; 의 이벤트는 지정된에 전달 &lt;code&gt;handleEvent&lt;/code&gt; 업로드가 완료 될 때 기능과 &lt;code&gt;filename&lt;/code&gt; 필드와 동일합니다 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="37b7ab0e221278f7b19c0e2120c647473f14e9c5" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;shallow&lt;/code&gt; is always safe once you know the string won't be modified anymore, similar to Ruby's &lt;span id=&quot;freeze_1&quot;&gt;freeze&lt;/span&gt;.</source>
          <target state="translated">의 사용 &lt;code&gt;shallow&lt;/code&gt; 루비의 유사, 문자열이 더 이상 수정되지 않습니다 알면 항상 안전 &lt;span id=&quot;freeze_1&quot;&gt;동결&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6529bc139872e1326ba28cf98763fb25162be0ed" translate="yes" xml:space="preserve">
          <source>Usage with custom object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="da1aeb06d30b6fb8ade7df07c4d3ac7287c9a066" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,OrderedTable%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b385b14640b269bd61b970e50ca557ba55241410" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,OrderedTableRef%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e49ab6964399f7deaf92634bcdb57677aacec05" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,Table%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db4d600ebdba4cdb503933887336a61072892ee" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#%5B%5D=,TableRef%5BA,B%5D,A,B&quot;&gt;[]= proc&lt;/a&gt; for inserting a new (key, value) pair in the table without introducing duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d04b7b8c1cf86ab3106c3b5d5f17672b7a6b5fb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; or &lt;a href=&quot;#initHashSet,int&quot;&gt;initHashSet proc&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50c56f66708798022fbc1f1eb983ee9aeeb0b23" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initSet&quot;&gt;initSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">사용 &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;의 init ()&lt;/a&gt; 또는 &lt;a href=&quot;#initSet&quot;&gt;initSet [유형] ()&lt;/a&gt; 이 다른 발동를 호출하기 전에.</target>
        </trans-unit>
        <trans-unit id="b9fe7a018967570be7ed52bffde1f973e6d871c2" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet,int&quot;&gt;initOrderedSet proc&lt;/a&gt; before calling other procs on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b9c2cf3847d0d4137fb09319498c7a48280b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; or &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet[type]()&lt;/a&gt; before calling other procs on it.</source>
          <target state="translated">사용 &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;의 init ()&lt;/a&gt; 또는 &lt;a href=&quot;#initOrderedSet&quot;&gt;initOrderedSet [유형] ()&lt;/a&gt; 이 다른 발동를 호출하기 전에.</target>
        </trans-unit>
        <trans-unit id="87bb73511d0e9c5ae418b5d251233153dc842135" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initDoublyLinkedList&quot;&gt;initDoublyLinkedList proc&lt;/a&gt; to create a new empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f182f9fe3cac0d41eb40bd94d58261ee8713fd3e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initDoublyLinkedRing&quot;&gt;initDoublyLinkedRing proc&lt;/a&gt; to create a new empty ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b42887b1698bc1c4d8fcb3ff2cca4489eb861" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initSinglyLinkedList&quot;&gt;initSinglyLinkedList proc&lt;/a&gt; to create a new empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03415c75219325917b792cada407fd71875afc67" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#initSinglyLinkedRing&quot;&gt;initSinglyLinkedRing proc&lt;/a&gt; to create a new empty ring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e3b878759b63e84ae32bbb1966962476e9a602" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#newXmlTree,string,openArray%5BXmlNode%5D,XmlAttributes&quot;&gt;newXmlTree proc&lt;/a&gt; for creating a new tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8808a38944ad2c6429fe6ee01b22a73933231013" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#toXmlAttributes,varargs%5Btuple%5Bstring,string%5D%5D&quot;&gt;toXmlAttributes proc&lt;/a&gt; to create &lt;code&gt;XmlAttributes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b04bfccbb051335b0b40343602f2f7a1105be6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;os#createDir,string&quot;&gt;os.createDir()&lt;/a&gt; and similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad60fd229e0a543ae8f2a0fedd46081297abc08d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#!/usr/bin/env -S nim --hints:off&lt;/code&gt; to disable hints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9918d6dedfaffdd4e2a4d97f4660d314efeecf3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--cpu:i386&lt;/code&gt; or &lt;code&gt;--cpu:amd64&lt;/code&gt; to switch the CPU architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c400bb7ca317cc76e65e260f6f0a40d428a811" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;nim c -c --cpu:arm --os:android -d:androidNDK --noMain:on&lt;/code&gt; to generate the C source files you need to include in your Android Studio project. Add the generated C files to CMake build script in your Android project. Then do the final compile with Android Studio which uses Gradle to call CMake to compile the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638e8ddcafcc7f4e68eb97d0d0f10fc49acd170f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;nim c -c --os:ios --noMain:on&lt;/code&gt; to generate C files and include them in your XCode project. Then you can use XCode to compile, link, package and sign everything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9ac410d33d9a91a19e2694390cd157758427bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;openChar&lt;/code&gt; instead of '{' and &lt;code&gt;closeChar&lt;/code&gt; instead of '}'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96634ba03db12a7ee8aeb6e65e274aa872380712" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;subjectVerb&lt;/code&gt;, not &lt;code&gt;verbSubject&lt;/code&gt;, e.g.: &lt;code&gt;fileExists&lt;/code&gt;, not &lt;code&gt;existsFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069c6a70b51730b216fe49517948e5c25ee3f68d" translate="yes" xml:space="preserve">
          <source>Use CamelCase, not underscored_identifiers.</source>
          <target state="translated">밑줄 _ 식별자가 아닌 CamelCase를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0419552b8b43316dc697b19a811e19aebbdcdf2" translate="yes" xml:space="preserve">
          <source>Use a proc when possible, only using the more powerful facilities of macros, templates, iterators, and converters when necessary.</source>
          <target state="translated">가능한 경우보다 강력한 매크로, 템플릿, 반복자 및 변환기 기능 만 사용하여 proc을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee29cb81b4a1c27e3913f57892fcf63971ad6672" translate="yes" xml:space="preserve">
          <source>Use a space after a colon, but not before it.</source>
          <target state="translated">콜론 뒤에는 사용하지만 그 앞에는 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="91c6843062b7105452ce869cb5ff5806e5657240" translate="yes" xml:space="preserve">
          <source>Use an &lt;a href=&quot;#OptParser&quot;&gt;OptParser&lt;/a&gt; to parse command line options. It can be created with &lt;a href=&quot;#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D&quot;&gt;initOptParser&lt;/a&gt;, and &lt;a href=&quot;#next,OptParser&quot;&gt;next&lt;/a&gt; advances the parser by one token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eaeb50702c4af6019f309c53108d48c5e121d67" translate="yes" xml:space="preserve">
          <source>Use an ordinary proc/iterator, if possible.</source>
          <target state="translated">가능하면 일반적인 proc / iterator를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8b595f99133340d0138766361433ada7a9e184d" translate="yes" xml:space="preserve">
          <source>Use bundled setjmp implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6821b710e595e256c74f90ecbec64f90226d87" translate="yes" xml:space="preserve">
          <source>Use native debugger (gdb)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d611bbc294e217a815cb04d3fa29d3d30b810658" translate="yes" xml:space="preserve">
          <source>Use regular &lt;code&gt;nim c&lt;/code&gt; inside termux to make Android terminal programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18016a67bd4f948da9845d49f07cb8371b4ab483" translate="yes" xml:space="preserve">
          <source>Use setjmp backend.</source>
          <target state="translated">setjmp 백엔드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f72ae5e3053e46a037835089c157a676efe9253b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;let&lt;/code&gt; statement (not the &lt;code&gt;var&lt;/code&gt; statement) when declaring variables that do not change within their scope. Using the &lt;code&gt;let&lt;/code&gt; statement ensures that variables remain immutable, and gives those who read the code a better idea of the code's purpose.</source>
          <target state="translated">해당 범위 내에서 변경되지 않는 변수를 선언 할 때는 &lt;code&gt;let&lt;/code&gt; 문 ( &lt;code&gt;var&lt;/code&gt; 문이 아님)을 사용하십시오 . &lt;code&gt;let&lt;/code&gt; 문을 사용하면 변수를 변경할 수 없으며 코드를 읽는 사람들에게 코드의 목적을 더 잘 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66274d10986776dc87f06f202d0f3cb8c3fe3937" translate="yes" xml:space="preserve">
          <source>Use the linenoise library for interactive mode (not needed on Windows).</source>
          <target state="translated">대화식 모드에 대해서는 Linenoise 라이브러리를 사용하십시오 (Windows에서는 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="fa6549bd6999bce5cb0be51276ff5b08c60300d9" translate="yes" xml:space="preserve">
          <source>Use this if you want to use asyncio's dispatcher.</source>
          <target state="translated">asyncio의 디스패처를 사용하려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4532086f3654531ca15b50c1e47098b39b985e32" translate="yes" xml:space="preserve">
          <source>Use this instead of &lt;code&gt;=&lt;/code&gt; for a &lt;span id=&quot;shallow-copy_1&quot;&gt;shallow copy&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cf95979f5d27ec020c489b4e3794d91e84592b" translate="yes" xml:space="preserve">
          <source>Use this on documentation name nodes to extract the &lt;em&gt;raw&lt;/em&gt; symbol name, without decorations, parameters, or anything. That can be used as the base for the HTML hyperlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc79ccd7635f50d22e57841cdbe2adc22f78a697" translate="yes" xml:space="preserve">
          <source>Use this overload if one of the enums specified above does not contain what you need.</source>
          <target state="translated">위에 지정된 열거 중 하나에 필요한 내용이 포함되어 있지 않으면이 과부하를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="865aa831216ca96d4d105c4dd19b7daa3f190a58" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a 'spawn' or a direct call is preferable. If it returns 'true' a 'spawn' may make sense. In general it is not necessary to call this directly; use 'spawnX' instead.</source>
          <target state="translated">'스폰'또는 직접 통화가 바람직한 지 여부를 빠르게 결정하려면이 절차를 사용하십시오. 'true'를 반환하면 'spawn'이 의미가있을 수 있습니다. 일반적으로 이것을 직접 호출 할 필요는 없습니다. 대신 'spawnX'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ffaf615de7e722de9c61894288fe41edf0bc0e9" translate="yes" xml:space="preserve">
          <source>Use this proc to determine quickly if a &lt;code&gt;spawn&lt;/code&gt; or a direct call is preferable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bc2b4499c7c25fe666bf75531910175755c00e" translate="yes" xml:space="preserve">
          <source>Use uClibc instead of libc. (Relevant for Unix-like OSes)</source>
          <target state="translated">libc 대신 uClibc를 사용하십시오. (유닉스 계열 OS 관련)</target>
        </trans-unit>
        <trans-unit id="5f211d2e480794537e3020e2cfb5c46539ca8d42" translate="yes" xml:space="preserve">
          <source>Use ucontext backend.</source>
          <target state="translated">ucontext 백엔드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e128770cbe82e55e9551991395c199aea047021" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;asynchttpserver&lt;/code&gt; and &lt;code&gt;httpclient&lt;/code&gt; internally and should not be used by you.</source>
          <target state="translated">내부적 으로 &lt;code&gt;asynchttpserver&lt;/code&gt; 및 &lt;code&gt;httpclient&lt;/code&gt; 에서 사용되며 사용자가 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e1eb04a34bb0de21c4be629b42f0c67166e892ed" translate="yes" xml:space="preserve">
          <source>Used if you have a table with duplicate keys (as a result of using &lt;a href=&quot;#add,Table%5BA,B%5D,A,B&quot;&gt;add proc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8732bc6e9c0c3e17ad4cc39e7b18e2c8e01853" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars).</source>
          <target state="translated">원자 (보통 문자)의 일치를 위해 scanp에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a86ce7ff320140dd835db0e2950bd610e5a8508" translate="yes" xml:space="preserve">
          <source>Used in scanp for the matching of atoms (usually chars). EOF is matched as &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afe7ce396a5c489b0063645153c095dbf7fc11e" translate="yes" xml:space="preserve">
          <source>Used internally by the &lt;a href=&quot;#round,T,int&quot;&gt;round proc&lt;/a&gt; when the specified number of places is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a711f1f66f43620c76efb83f91a45bb11becf844" translate="yes" xml:space="preserve">
          <source>Used throughout the compiler code to test whether a type tree contains or doesn't contain a specific type/types - it is often the case that only the last child nodes of a type tree need to be searched. This is a really hot path within the compiler!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d6504832c00269c338b88a50a90a3ced2d75595" translate="yes" xml:space="preserve">
          <source>Useful for &lt;code&gt;disarming&lt;/code&gt; dangling pointers explicitly for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150c36f24d07810f97e415f3dff1c4a4f82fb6da" translate="yes" xml:space="preserve">
          <source>Useful for creating &quot;2D&quot; sequences - sequences containing other sequences or to populate fields of the created sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02c3c02a1cba6f1b623a143ee4ff49577aeda10" translate="yes" xml:space="preserve">
          <source>Useful if performing parallel analysis of data series and need to re-combine parallel result sets</source>
          <target state="translated">데이터 계열의 병렬 분석을 수행하고 병렬 결과 세트를 다시 조합해야하는 경우 유용</target>
        </trans-unit>
        <trans-unit id="6287591a47bd6f7727cd724ffad351b20d4e6e8a" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51e8109e780dfdf6a418dbd0475739d284873d7" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:</source>
          <target state="translated">현재 반복 값으로 로컬 루프 변수를 캡처하기 위해 루프에서 클로저를 작성할 때 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="ffffb46bb26e51b2c63f7e473654047d3d1b549a" translate="yes" xml:space="preserve">
          <source>Useful when creating a closure in a loop to capture some local loop variables by their current iteration values. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8a2389a20ca0752aa9e95093515517e90e194c" translate="yes" xml:space="preserve">
          <source>User</source>
          <target state="translated">User</target>
        </trans-unit>
        <trans-unit id="e62ab5dd60dc7797b971e6696b18be2c527a419c" translate="yes" xml:space="preserve">
          <source>User definable matchers</source>
          <target state="translated">사용자 정의 가능 매처</target>
        </trans-unit>
        <trans-unit id="cdb81abb7fd49094ec59b4c3147077b637691ca6" translate="yes" xml:space="preserve">
          <source>User defined matcher. Uses the proc &lt;code&gt;foo&lt;/code&gt; to perform the match. See below for more details.</source>
          <target state="translated">사용자 정의 매처. proc &lt;code&gt;foo&lt;/code&gt; 를 사용하여 일치를 수행합니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b935fbc2614493a2c4b14ccf26901cbcb010eb56" translate="yes" xml:space="preserve">
          <source>User defined operators are allowed. Nothing stops you from defining your own &lt;code&gt;@!?+~&lt;/code&gt; operator, but doing so may reduce readability.</source>
          <target state="translated">사용자 정의 연산자가 허용됩니다. 자신 만의 &lt;code&gt;@!?+~&lt;/code&gt; 연산자 를 정의 할 수있는 것은 없지만 가독성을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8f45c91aea8077d8fc0d06a397a16ed0dc1c79" translate="yes" xml:space="preserve">
          <source>User-defined generic types may also be covariant with respect to some of their parameters. By default, all generic params are considered invariant, but you may choose the apply the prefix modifier &lt;code&gt;in&lt;/code&gt; to a parameter to make it contravariant or &lt;code&gt;out&lt;/code&gt; to make it covariant:</source>
          <target state="translated">사용자 정의 제네릭 형식은 일부 매개 변수와 관련하여 공변량 일 수도 있습니다. 기본적으로 모든 일반적인 PARAMS는 불변으로 간주됩니다,하지만 당신은 접두사 수정을 적용 할 수도 있습니다 &lt;code&gt;in&lt;/code&gt; 이 contravariant 또는 확인하기 위해 매개 변수 &lt;code&gt;out&lt;/code&gt; 확인하는 것이 공변 :</target>
        </trans-unit>
        <trans-unit id="fe530b5d90cc0ff755c2c5978933fa9a5980a785" translate="yes" xml:space="preserve">
          <source>User-defined pragmas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce325aeace53a2b93d052357d730389323d4341" translate="yes" xml:space="preserve">
          <source>UserRaw</source>
          <target state="translated">UserRaw</target>
        </trans-unit>
        <trans-unit id="453171c4373884a1b140871f1519f0b7a2ce0a5f" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;default&lt;/code&gt; for an invalid value in &lt;code&gt;s&lt;/code&gt;. The comparison is done in a style insensitive way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d37885af11f22c8954936ebdddac6bdeacfbc6c" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;fn&lt;/code&gt; to mix the colors &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e300487a9b9ba07551dbd02395ad2f5ceb2cd7ff" translate="yes" xml:space="preserve">
          <source>Uses &lt;em&gt;default&lt;/em&gt; for an invalid value in &lt;em&gt;s&lt;/em&gt;. The comparison is done in a style insensitive way.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 에서 유효하지 않은 값 &lt;em&gt;으로 기본값&lt;/em&gt; 을 사용합니다 . 스타일을 구분하지 않는 방식으로 비교합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91247aefaea76611ed3be253ec73d5452247797e" translate="yes" xml:space="preserve">
          <source>Uses the state to compute a new &lt;code&gt;uint64&lt;/code&gt; random number.</source>
          <target state="translated">상태를 사용하여 새로운 &lt;code&gt;uint64&lt;/code&gt; 난수 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="82312a15160a4eb2e934bf4a7bfbfafc8e93262e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from math as m import pow&lt;/code&gt; works identically to the &lt;code&gt;as&lt;/code&gt; modifier with the &lt;code&gt;import&lt;/code&gt; statement, but wrapped in &lt;code&gt;nnkFromStmt&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;from math as m import pow&lt;/code&gt; 받는 동일하게 작동 &lt;code&gt;as&lt;/code&gt; 와 수정 &lt;code&gt;import&lt;/code&gt; 문, 그러나에 싸여 &lt;code&gt;nnkFromStmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434eb8681f8aae0fc0009510a5ce82ae4ac62f77" translate="yes" xml:space="preserve">
          <source>Using HTTP POST</source>
          <target state="translated">HTTP POST 사용</target>
        </trans-unit>
        <trans-unit id="ed0f47b1f4fe7cff5fa3f8cc793df2dd41f14561" translate="yes" xml:space="preserve">
          <source>Using Unix sockets instead of TCP connection can &lt;a href=&quot;https://momjian.us/main/blogs/pgblog/2012.html#June_6_2012&quot;&gt;improve performance up to 30% ~ 175% for some operations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597d5caf1abedf8be885d6b02a498c8313c21cab" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;enum&lt;/code&gt; is similar to using an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">사용하여 &lt;code&gt;enum&lt;/code&gt; 사용하는 것과 비슷 &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56bf266901cc02f50f464b5a26b067601243b007" translate="yes" xml:space="preserve">
          <source>Using default values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2077b1edc67aa09ddf48ed8fc866598362c96a" translate="yes" xml:space="preserve">
          <source>Using statement</source>
          <target state="translated">성명서 사용</target>
        </trans-unit>
        <trans-unit id="dfb7c6171f4d1e4bf5091b862fae5147fe7d176a" translate="yes" xml:space="preserve">
          <source>Usually it is advised to use &lt;a href=&quot;#spawn,typed&quot;&gt;spawn proc&lt;/a&gt; in order to not block the producer for an unknown amount of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d38117d85b7f952c74849e783f652c0d1186c" translate="yes" xml:space="preserve">
          <source>Usually it is not necessary to call this explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0ffb656f43cb27f5cdd45b79d0245f11508098" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;#assert&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#assert&quot;&gt;assert () 템플릿&lt;/a&gt; 을 사용한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="174b2645b450d09512ed8264a52d52439c1d6ecc" translate="yes" xml:space="preserve">
          <source>Usually the result of using the &lt;a href=&quot;assertions#assert.t,untyped,string&quot;&gt;assert() template&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b613dc5bf77d7eebd40398bbfcda8a848bcf8f" translate="yes" xml:space="preserve">
          <source>Usually to pass a block of code to a template the parameter that accepts the block needs to be of type &lt;code&gt;untyped&lt;/code&gt;. Because symbol lookups are then delayed until template instantiation time:</source>
          <target state="translated">일반적으로 코드 블록을 템플릿에 전달하려면 블록을 허용하는 매개 변수 유형이 &lt;code&gt;untyped&lt;/code&gt; 이어야 합니다. 그러면 템플릿 인스턴스화 시간까지 심볼 조회가 지연되기 때문에 :</target>
        </trans-unit>
        <trans-unit id="1926bc9218cc799324b71f0caa656e3d2180032c" translate="yes" xml:space="preserve">
          <source>Usually used via the &lt;code&gt;in&lt;/code&gt; operator. It is the equivalent of &lt;code&gt;deq.find(item) &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0e47d9fc2b0057aa59726a8d6d1ec706dd8492" translate="yes" xml:space="preserve">
          <source>VS Code only supports these three</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4056c9024148aba228496422c08fad4e874361b" translate="yes" xml:space="preserve">
          <source>VT:</source>
          <target state="translated">VT:</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="94caea3c7c64ca00d9ac21ea83a77703d0e697ae" translate="yes" xml:space="preserve">
          <source>Var parameters</source>
          <target state="translated">Var 파라미터</target>
        </trans-unit>
        <trans-unit id="f94fe3891ba9b2a70b6f7c93dcf19ff406473182" translate="yes" xml:space="preserve">
          <source>Var return type</source>
          <target state="translated">Var 반환 유형</target>
        </trans-unit>
        <trans-unit id="ed0b2dfd47bbac896a3b7fa7c65e08461b5b0de0" translate="yes" xml:space="preserve">
          <source>Var section</source>
          <target state="translated">Var 섹션</target>
        </trans-unit>
        <trans-unit id="914863c14c6479013852278b1f8b3334db12b752" translate="yes" xml:space="preserve">
          <source>Var statement</source>
          <target state="translated">Var 문</target>
        </trans-unit>
        <trans-unit id="add491eaab149ea45f6c1fe0151b0684f58a9169" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma separated list of variables can be used to specify variables of the same type:</source>
          <target state="translated">Var 문은 새로운 지역 및 전역 변수를 선언하고 초기화합니다. 쉼표로 구분 된 변수 목록을 사용하여 동일한 유형의 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7189cf27aa01cb34bf0ab7fce27a6c539ba4e0" translate="yes" xml:space="preserve">
          <source>Var statements declare new local and global variables and initialize them. A comma-separated list of variables can be used to specify variables of the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8aad770addffb7c9ee321a2ae20d74343b6752" translate="yes" xml:space="preserve">
          <source>Varargs</source>
          <target state="translated">Varargs</target>
        </trans-unit>
        <trans-unit id="7d9fcf6d5d84f212e746c0dd60f0871afacbb237" translate="yes" xml:space="preserve">
          <source>Varargs matching</source>
          <target state="translated">Varargs 매칭</target>
        </trans-unit>
        <trans-unit id="1e1a470ac65b2238b82d8d8713eb8a548a3249ba" translate="yes" xml:space="preserve">
          <source>Varargs of untyped</source>
          <target state="translated">형식화되지 않은 바라 그</target>
        </trans-unit>
        <trans-unit id="77559312e7c433e8e5ee29c1bb6cbeca9a08ec04" translate="yes" xml:space="preserve">
          <source>Varargs pragma</source>
          <target state="translated">바라크 프라 그마</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="805fa97816cdbe137bc65aece5e19b6969589e6d" translate="yes" xml:space="preserve">
          <source>Variables can also be reordered as well. Variables that are &lt;em&gt;initialized&lt;/em&gt; (i.e. variables that have their declaration and assignment combined in a single statement) can have their entire initialization statement reordered. Be wary of what code is executed at the top level:</source>
          <target state="translated">변수도 재정렬 할 수 있습니다. 하는 변수 &lt;em&gt;초기화&lt;/em&gt; 그들의 전체 초기화 문을 다시 정렬 할 수 있습니다 (자신의 선언과 하나의 문장으로 결합 할당을 즉, 변수). 최상위 레벨에서 어떤 코드가 실행되는지주의하십시오.</target>
        </trans-unit>
        <trans-unit id="f285e0b395df604d798c7e2bb2b23e2eae4f1e8f" translate="yes" xml:space="preserve">
          <source>Variant of &lt;code&gt;recvFrom&lt;/code&gt; for non-blocking sockets. Unlike &lt;code&gt;recvFrom&lt;/code&gt;, this function will raise an EOS error whenever a socket error occurs.</source>
          <target state="translated">변형 &lt;code&gt;recvFrom&lt;/code&gt; 비 블로킹 소켓 recvFrom . &lt;code&gt;recvFrom&lt;/code&gt; 과 달리이 함수는 소켓 오류가 발생할 때마다 EOS 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="37a9cbeb25f6e324f126507ad323389964644919" translate="yes" xml:space="preserve">
          <source>Variant of select with only a read and write list.</source>
          <target state="translated">읽기 및 쓰기 목록 만있는 선택의 변형</target>
        </trans-unit>
        <trans-unit id="b9069e323599df5d27b7c9d2e68cb81566e2b60e" translate="yes" xml:space="preserve">
          <source>Vars</source>
          <target state="translated">Vars</target>
        </trans-unit>
        <trans-unit id="c0e92bae9fcb6a7281bd801df9748260bc15749f" translate="yes" xml:space="preserve">
          <source>Verbatim string match for back reference.</source>
          <target state="translated">역 참조를위한 완전 문자열 일치.</target>
        </trans-unit>
        <trans-unit id="be6cf59698ac3aaae8c44d3c15b6e3e4cda4c5a2" translate="yes" xml:space="preserve">
          <source>Verbatim string match: Use this to override a global &lt;code&gt;\i&lt;/code&gt; or &lt;code&gt;\y&lt;/code&gt; modifier.</source>
          <target state="translated">완전 문자열 일치 : 전역 &lt;code&gt;\i&lt;/code&gt; 또는 &lt;code&gt;\y&lt;/code&gt; 수정자를 .</target>
        </trans-unit>
        <trans-unit id="f0f86f02d25018ae2892b7bd1afddf0b541788d2" translate="yes" xml:space="preserve">
          <source>Verbosity levels</source>
          <target state="translated">상세 수준</target>
        </trans-unit>
        <trans-unit id="c12b4e999b16e9b02d25b9fcdd67d4fd655e16ae" translate="yes" xml:space="preserve">
          <source>Verify if a statement or a list of statements is true. A helpful error message and set checkpoints are printed out on failure (if &lt;code&gt;outputLevel&lt;/code&gt; is not &lt;code&gt;PRINT_NONE&lt;/code&gt;). Example:</source>
          <target state="translated">명령문 또는 명령문 목록이 참인지 확인하십시오. 유용한 오류 메시지 및 설정 체크 포인트가 실패시 출력됩니다 ( &lt;code&gt;outputLevel&lt;/code&gt; 이 &lt;code&gt;PRINT_NONE&lt;/code&gt; 이 아닌 경우). ). 예:</target>
        </trans-unit>
        <trans-unit id="d2784d4602912caafb5ad3d11f152f082f9e1b16" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getType&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf92590226e4f935af31645efa1ac42d722021ca" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeImpl&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 를 취하는 &lt;code&gt;getTypeImpl&lt;/code&gt; 의 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="57aa9247bf27c4880a6334aaec93af41db7006d4" translate="yes" xml:space="preserve">
          <source>Version of &lt;code&gt;getTypeInst&lt;/code&gt; which takes a &lt;code&gt;typedesc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typedesc&lt;/code&gt; 를 취하는 &lt;code&gt;getTypeInst&lt;/code&gt; 버전 .</target>
        </trans-unit>
        <trans-unit id="9f49127025fb5873ad1bd738867c76e3725ffeaa" translate="yes" xml:space="preserve">
          <source>Version:</source>
          <target state="translated">Version:</target>
        </trans-unit>
        <trans-unit id="3b6698fb0fff6c21a0dacb845a8168b700a8f071" translate="yes" xml:space="preserve">
          <source>VersionAsString:</source>
          <target state="translated">VersionAsString:</target>
        </trans-unit>
        <trans-unit id="858b1e6c9eca4cf7c78fcd8fab9318b40196ab03" translate="yes" xml:space="preserve">
          <source>Viceversa, one can also use &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; to declare that &lt;code&gt;SYMBOL&lt;/code&gt; should be considered not defined, and hence skip &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; sections.</source>
          <target state="translated">viceversa에, 하나는 또한 사용할 수 있습니다 &lt;code&gt;#assumendef SYMBOL&lt;/code&gt; 선언하는 &lt;code&gt;SYMBOL&lt;/code&gt; 정의되지 고려되어야한다, 따라서 생략 &lt;code&gt;#ifdef SYMBOL&lt;/code&gt; 섹션.</target>
        </trans-unit>
        <trans-unit id="446e8e3fce5e3128e133d64c529899ea1dd858b1" translate="yes" xml:space="preserve">
          <source>View types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8eef146e6b277dbe5d9e005320c3315cc7d039" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.immutableView</source>
          <target state="translated">ViewTypeKind.immutableView</target>
        </trans-unit>
        <trans-unit id="dff874c131f8bb325b7f9624ec5e0a907eebf1c6" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.mutableView</source>
          <target state="translated">ViewTypeKind.mutableView</target>
        </trans-unit>
        <trans-unit id="32ee0924ac03c2fd5d1496f594108118d64746e0" translate="yes" xml:space="preserve">
          <source>ViewTypeKind.noView</source>
          <target state="translated">ViewTypeKind.noView</target>
        </trans-unit>
        <trans-unit id="e1365390bd60db43644d2c7fe33cdc7c97aac284" translate="yes" xml:space="preserve">
          <source>ViewTypeKind:</source>
          <target state="translated">ViewTypeKind:</target>
        </trans-unit>
        <trans-unit id="fa3a6215333724f6e30c443dd490c943e2c34323" translate="yes" xml:space="preserve">
          <source>VmArgs:</source>
          <target state="translated">VmArgs:</target>
        </trans-unit>
        <trans-unit id="02574e1c3e8efd085f63bcb781df8802c484d8b8" translate="yes" xml:space="preserve">
          <source>VmCallback:</source>
          <target state="translated">VmCallback:</target>
        </trans-unit>
        <trans-unit id="f9b4a6297c88554060939c3b1d4cb2536eb7bee3" translate="yes" xml:space="preserve">
          <source>Void context</source>
          <target state="translated">공허한 맥락</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">공허 유형</target>
        </trans-unit>
        <trans-unit id="962f34b2afbbced77fbbf76af036107dbe53ad9d" translate="yes" xml:space="preserve">
          <source>Volatile pragma</source>
          <target state="translated">휘발성 프라 그마</target>
        </trans-unit>
        <trans-unit id="a1c74f4c3dc47b71577d22318b41d7984b1abbb7" translate="yes" xml:space="preserve">
          <source>Waiting for a subprocess to finish. A subprocess can be started, but right now it can't be waited on, which sort of makes subprocesses a bit hard to use</source>
          <target state="translated">서브 프로세스가 완료되기를 기다리는 중입니다. 하위 프로세스를 시작할 수는 있지만 지금은 기다릴 수 없으므로 하위 프로세스를 사용하기가 조금 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e74d0d5b2aa91ca4f2eda490c658dd7df90ccca2" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available.</source>
          <target state="translated">완료 이벤트를 대기하고 처리합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 대기중인 작업이없는 경우. &lt;code&gt;poll&lt;/code&gt; 과 달리이 프로세스는 사용 가능한 많은 이벤트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8c6c37027d7f2e6c6ab4b80a9728bdfd41e4de6e" translate="yes" xml:space="preserve">
          <source>Waits for completion events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. This runs the underlying OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; or &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; primitive only once.</source>
          <target state="translated">완료 이벤트를 대기하고 처리합니다. 발생시킵니다 &lt;code&gt;ValueError&lt;/code&gt; 대기중인 작업이없는 경우. 기본 OS &lt;span id=&quot;epoll_1&quot;&gt;epoll&lt;/span&gt; 또는 &lt;span id=&quot;kqueue_1&quot;&gt;kqueue&lt;/span&gt; 프리미티브를 한 번만 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="204793720c46d08681ddecb190249c9c8af8a373" translate="yes" xml:space="preserve">
          <source>Waits for completion of &lt;strong&gt;all&lt;/strong&gt; events and processes them. Raises &lt;code&gt;ValueError&lt;/code&gt; if there are no pending operations. In contrast to &lt;code&gt;poll&lt;/code&gt; this processes as many events as are available until the timeout has elapsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7309ba8763f2cd6a0b2e52be4a1bdf5400867492" translate="yes" xml:space="preserve">
          <source>Waits for events registered in selector &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">셀렉터에 등록 이벤트에 대한 대기 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f0c4139884d2abda2de2444e4464c33fd6fa67" translate="yes" xml:space="preserve">
          <source>Waits for every thread in &lt;code&gt;t&lt;/code&gt; to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fc9ffeaa2d05fb1d780035185e1cba8feba761" translate="yes" xml:space="preserve">
          <source>Waits for the process to finish and returns &lt;code&gt;p&lt;/code&gt;'s error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada9df230ef438f4a792b7d49e4ffd90a8b1ec6b" translate="yes" xml:space="preserve">
          <source>Waits for the thread &lt;code&gt;t&lt;/code&gt; to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9446e39ca3b4a238ae239559d7ae690626b7ce" translate="yes" xml:space="preserve">
          <source>Waits until the value for the &lt;code&gt;fv&lt;/code&gt; arrives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14f81123dca7f0c9abebcb68de165f609c234d7" translate="yes" xml:space="preserve">
          <source>Walking is not recursive. If &lt;code&gt;relative&lt;/code&gt; is true (default: false) the resulting path is shortened to be relative to &lt;code&gt;dir&lt;/code&gt;. Example: This directory structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c69a06317f4a5f9baf9a7788e0ebd385a13e24" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;code&gt;followFilter&lt;/code&gt; controls the behaviour of the iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a009040341eedf69627aff9b5c29bf4b8425403d" translate="yes" xml:space="preserve">
          <source>Walking is recursive. &lt;em&gt;filters&lt;/em&gt; controls the behaviour of the iterator:</source>
          <target state="translated">걷기는 재귀 적입니다. &lt;em&gt;필터&lt;/em&gt; 는 반복자의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="257e0c4a2da1427367d784ff2749db7746c92812" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd311d8cb591a6fc0622efcf10ea3ea470116f2" translate="yes" xml:space="preserve">
          <source>Walks over all parent directories of a given &lt;em&gt;path&lt;/em&gt;</source>
          <target state="translated">주어진 &lt;em&gt;경로&lt;/em&gt; 의 모든 부모 디렉토리를 걷는다&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="589a4634f66a4771a96b3527d7d465ed30a8f110" translate="yes" xml:space="preserve">
          <source>Walks over the directory &lt;code&gt;dir&lt;/code&gt; and yields for each directory or file in &lt;code&gt;dir&lt;/code&gt;. The component type and full path for each item are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f677a76b732f719f239cf0dfdab57ecc27685012" translate="yes" xml:space="preserve">
          <source>Wang Yi's hash_v1 for 8B int. &lt;a href=&quot;https://github.com/rurban/smhasher&quot;&gt;https://github.com/rurban/smhasher&lt;/a&gt; has more details. This passed all scrambling tests in Spring 2019 and is simple. NOTE: It's ok to define &lt;code&gt;proc(x: int16): Hash = hashWangYi1(Hash(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f61ac580a8669e5f5ddb85827db56efd269d4d4" translate="yes" xml:space="preserve">
          <source>Warning: This function may block. Especially on directories with many files, because a full list of file names must be retrieved.</source>
          <target state="translated">경고 :이 기능은 차단 될 수 있습니다. 전체 파일 이름 목록을 검색해야하기 때문에 특히 많은 파일이있는 디렉토리에서.</target>
        </trans-unit>
        <trans-unit id="99a2a483409f9e01cee9aa93831fe0f06d054b92" translate="yes" xml:space="preserve">
          <source>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</source>
          <target state="translated">경고 : 이것은 실제로 'for'를 변형시키고 루프를 풀어줍니다. 현재 구현에는 루프 본문의 심볼 바인딩에 영향을주는 버그도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7412166e831c66d50243ea6b997febce22e1c0db" translate="yes" xml:space="preserve">
          <source>Warning: URL-encoded and Unicode attempts at directory traversal are not detected. Triple dot is not handled.</source>
          <target state="translated">경고 : 디렉토리 순회에서 URL 인코딩 및 유니 코드 시도가 감지되지 않습니다. 트리플 도트는 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0e0c14f084e128be516580f7f46caa6b881111d" translate="yes" xml:space="preserve">
          <source>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file &lt;code&gt;lib/system/hti.nim&lt;/code&gt; for more information.</source>
          <target state="translated">우리는 이미 컴파일러에서 타입 정보를 그래프로 알고 있습니다. 따라서이 코드를 C 코드 생성을위한 RTTI로 직렬화해야합니다. 자세한 정보는 &lt;code&gt;lib/system/hti.nim&lt;/code&gt; 파일을보십시오 .</target>
        </trans-unit>
        <trans-unit id="7b2d825d8ef9b527c8f3ffcca749e04b73530ffc" translate="yes" xml:space="preserve">
          <source>We cache generic instantiations and need to ensure this caching works well with the incremental compilation feature. Since the cache is attached to the &lt;code&gt;PSym&lt;/code&gt; datastructure, it should work without any special logic.</source>
          <target state="translated">일반 인스턴스를 캐시하고이 캐싱이 증분 컴파일 기능과 제대로 작동하는지 확인해야합니다. 캐시는 &lt;code&gt;PSym&lt;/code&gt; 데이터 구조에 연결되므로 특별한 논리없이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bf6af0d4d4b7bb7491ad339f0cd6b4eecccde3c" translate="yes" xml:space="preserve">
          <source>We call a proc &lt;code&gt;p&lt;/code&gt;&lt;span id=&quot;gc-safe_1&quot;&gt;GC safe&lt;/span&gt; when it doesn't access any global variable that contains GC'ed memory (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; or a closure) either directly or indirectly through a call to a GC unsafe proc.</source>
          <target state="translated">&lt;span id=&quot;gc-safe_1&quot;&gt;GC 안전&lt;/span&gt; 하지 않은 프로 시저에 대한 호출을 통해 GC의 메모리 ( &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; 또는 클로저)를 직접 또는 간접적으로 포함하는 전역 변수에 액세스하지 않으면 proc &lt;code&gt;p&lt;/code&gt; &lt;span id=&quot;gc-safe_1&quot;&gt;GC safe를&lt;/span&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ba455d231bded2509ebd8f9d1e8763309c843c4f" translate="yes" xml:space="preserve">
          <source>We can &quot;replay&quot; &lt;code&gt;stCode.add&lt;/code&gt; only if the values of &lt;code&gt;st&lt;/code&gt; and &lt;code&gt;apicall&lt;/code&gt; are known. And even then a hash table's &lt;code&gt;add&lt;/code&gt; with its hashing mechanism is too hard to replay.</source>
          <target state="translated">&lt;code&gt;st&lt;/code&gt; 및 &lt;code&gt;apicall&lt;/code&gt; 의 값을 &lt;code&gt;stCode.add&lt;/code&gt; 있는 경우에만 stCode.add를 &quot;재생&quot;할 수 있습니다 . 그리고 해시 메커니즘 으로 해시 테이블을 &lt;code&gt;add&lt;/code&gt; 해도 재생하기가 너무 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="f6c15cc4bcae38711205717122d00cbaec2e62f3" translate="yes" xml:space="preserve">
          <source>We can achieve this using the &lt;code&gt;bindMethod&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;bindMethod&lt;/code&gt; 매크로를 사용하여이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31fc4caa6ec680ff0de718216907b6b39698fd69" translate="yes" xml:space="preserve">
          <source>We cannot duplicate 'a' if it denotes an expression that has a side effect! Fortunately Nim supports side effect analysis:</source>
          <target state="translated">부작용이있는 표현식을 나타내는 경우 'a'를 복제 할 수 없습니다! 다행히 Nim은 부작용 분석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cc498265cc3ceafbd88456ff11eb0a32bb180e8f" translate="yes" xml:space="preserve">
          <source>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</source>
          <target state="translated">항상 내부 anon procs를 인라인하여 중첩 환경을 제거 할 수 있습니다. 그러나 환경의 이스케이프 분석 및 스택 할당이 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e11914dec9459002787db2ce90468c35fd15a6ab" translate="yes" xml:space="preserve">
          <source>We have already seen the simple &lt;code&gt;import&lt;/code&gt; statement that just imports all exported symbols. An alternative that only imports listed symbols is the &lt;code&gt;from import&lt;/code&gt; statement:</source>
          <target state="translated">우리는 이미 내 보낸 모든 심볼을 &lt;code&gt;import&lt;/code&gt; 간단한 import 문을 보았습니다 . 나열된 기호 만 가져 오는 대안은 &lt;code&gt;from import&lt;/code&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="59c4a855c5c497242383a03a1f691a7e5a85ba0a" translate="yes" xml:space="preserve">
          <source>We have to decide at runtime whether the reference is on the stack or not. The generated code looks roughly like this:</source>
          <target state="translated">런타임에 참조가 스택에 있는지 여부를 결정해야합니다. 생성 된 코드는 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf92005b68f4a7df3a08d2ee2fa3d3d923557d80" translate="yes" xml:space="preserve">
          <source>We need an API that hides the complex aliasing problems by not relying on Nim's global variables. The obvious solution is to use string keys instead of global variables:</source>
          <target state="translated">Nim의 전역 변수에 의존하지 않음으로써 복잡한 앨리어싱 문제를 숨기는 API가 필요합니다. 확실한 해결책은 전역 변수 대신 문자열 키를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c36085b01e4f6e8f59835097cfb83f524dc4b57" translate="yes" xml:space="preserve">
          <source>We start the tour with a modified &quot;hello world&quot; program:</source>
          <target state="translated">수정 된 &quot;hello world&quot;프로그램으로 둘러보기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="41e38ed24e3a1be9264a0daea556df68c3aba5e6" translate="yes" xml:space="preserve">
          <source>We store a module's AST of a successful semantic check in a SQLite database. There are plenty of features that require a sub sequence to be re-applied, for example:</source>
          <target state="translated">우리는 성공적인 의미 검사의 모듈의 AST를 SQLite 데이터베이스에 저장합니다. 하위 시퀀스를 다시 적용해야하는 많은 기능이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a8ba9ee33c2a6fb270c2b9858e20ee9e6e1de37" translate="yes" xml:space="preserve">
          <source>We use a mixture of bitset and hash table for this. The hash table maps &lt;em&gt;pages&lt;/em&gt; to a page descriptor. The page descriptor contains a bit for any possible cell address within this page. So including a cell is done as follows:</source>
          <target state="translated">이를 위해 비트 셋과 해시 테이블을 혼합하여 사용합니다. 해시 테이블은 &lt;em&gt;페이지&lt;/em&gt; 를 페이지 디스크립터에 맵핑 &lt;em&gt;합니다&lt;/em&gt; . 페이지 디스크립터는이 페이지 내에서 가능한 셀 주소에 대한 비트를 포함합니다. 따라서 셀 포함은 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="aab20012d1620f5b85c5c37ea977935d4f505aea" translate="yes" xml:space="preserve">
          <source>We want to generate roughly this JavaScript:</source>
          <target state="translated">우리는 대략이 JavaScript를 생성하고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="113b69b591d6182bb037d0575303c945f53858ae" translate="yes" xml:space="preserve">
          <source>What is happening here is that the types used for table keys require to have a &lt;code&gt;hash()&lt;/code&gt; proc which will convert them to a &lt;a href=&quot;hashes#Hash&quot;&gt;Hash&lt;/a&gt; value, and the compiler is listing all the hash functions it knows. Additionally there has to be a &lt;code&gt;==&lt;/code&gt; operator that provides the same semantics as its corresponding &lt;code&gt;hash&lt;/code&gt; proc.</source>
          <target state="translated">여기서 발생하는 것은 테이블 키에 사용되는 형식 에 &lt;a href=&quot;hashes#Hash&quot;&gt;해시&lt;/a&gt; 값으로 변환 하는 &lt;code&gt;hash()&lt;/code&gt; proc이 있어야하며 컴파일러가 알고있는 모든 해시 함수를 나열한다는 것입니다. 또한 해당 &lt;code&gt;hash&lt;/code&gt; 프로세스 와 동일한 의미를 제공 하는 &lt;code&gt;==&lt;/code&gt; 연산자가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7366e079f6ffab6bc9ad768b8631449c4256e61f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="translated">대부분의 프로그래밍 언어에서 &lt;span id=&quot;methods_1&quot;&gt;메소드&lt;/span&gt; 또는 &lt;span id=&quot;functions_1&quot;&gt;함수&lt;/span&gt; 를 호출 하는 것을 Nim에서 &lt;span id=&quot;procedures_1&quot;&gt;프로 시저&lt;/span&gt; 라고 &lt;span id=&quot;procedures_1&quot;&gt;합니다&lt;/span&gt; . 프로 시저 선언은 식별자, 0 개 이상의 형식 매개 변수, 반환 값 유형 및 코드 블록으로 구성됩니다. 공식 매개 변수는 쉼표 또는 세미콜론으로 구분 된 식별자 목록으로 선언됩니다. 매개 변수는 &lt;code&gt;: typename&lt;/code&gt; 유형으로 제공됩니다 . 이 유형은 매개 변수 목록의 시작, 세미콜론 구분 기호 또는 이미 입력 된 매개 변수에 도달 할 때까지 모든 매개 변수에 바로 적용됩니다. 세미콜론을 사용하면 유형과 후속 식별자를보다 명확하게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a8ccce98f65c3a6b48e55191a5b345ee1e0b8f" translate="yes" xml:space="preserve">
          <source>What most programming languages call &lt;span id=&quot;methods_1&quot;&gt;methods&lt;/span&gt; or &lt;span id=&quot;functions_1&quot;&gt;functions&lt;/span&gt; are called &lt;span id=&quot;procedures_1&quot;&gt;procedures&lt;/span&gt; in Nim. A procedure declaration consists of an identifier, zero or more formal parameters, a return value type and a block of code. Formal parameters are declared as a list of identifiers separated by either comma or semicolon. A parameter is given a type by &lt;code&gt;: typename&lt;/code&gt;. The type applies to all parameters immediately before it, until either the beginning of the parameter list, a semicolon separator, or an already typed parameter, is reached. The semicolon can be used to make separation of types and subsequent identifiers more distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcfff2350bc510e79fd004ac68bd4cb1f311382" translate="yes" xml:space="preserve">
          <source>What optimizers really need to do is a &lt;em&gt;canonicalization&lt;/em&gt;:</source>
          <target state="translated">옵티마이 저가 실제로해야하는 것은 &lt;em&gt;정규화입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93ccfee40ae325efd18fb6ffe045c18cb229f18f" translate="yes" xml:space="preserve">
          <source>What seem to be C code generation problems is often a bug resulting from not producing prototypes, so that some types default to &lt;code&gt;cint&lt;/code&gt;. Testing without the &lt;code&gt;-w&lt;/code&gt; option helps!</source>
          <target state="translated">C 코드 생성 문제인 것처럼 보이는 것은 종종 프로토 타입을 생성하지 않아 발생하는 버그이므로 일부 유형의 기본값은 &lt;code&gt;cint&lt;/code&gt; 입니다. &lt;code&gt;-w&lt;/code&gt; 옵션 없이 테스트 하면 도움이됩니다!</target>
        </trans-unit>
        <trans-unit id="da9f923a36a4b94d0ac1b66475ca125ddde61625" translate="yes" xml:space="preserve">
          <source>What to install:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f4a3ec696cf15db4c5199b757938fbcc68be19" translate="yes" xml:space="preserve">
          <source>When 0 is returned the socket's connection has been closed.</source>
          <target state="translated">0이 반환되면 소켓의 연결이 종료 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5309ac6e6a926e840908775be647c2028a478adb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned the socket's connection has been closed.</source>
          <target state="translated">때 &lt;code&gt;&quot;&quot;&lt;/code&gt; 반환되는 소켓의 연결이 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="017a1cdbf43acad895afedf8019b709fbd1b8c09" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a ref type then the resulting type will be &lt;code&gt;T&lt;/code&gt;, otherwise it will be &lt;code&gt;ref T&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;T&lt;/code&gt; 가 의 Ref 타입 후 얻어진 타입 것이다 &lt;code&gt;T&lt;/code&gt; , 그렇지 않으면 것이다 &lt;code&gt;ref T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e650c5cd9ed1e1728a9de1aefd1194bac45412b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;defer&lt;/code&gt; is at the outermost scope of a template/macro, its scope extends to the block where the template is called from:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e8e46dee2340d03eb3fb2d57a8748f8123b5a2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;followSymlink&lt;/code&gt; is true (default), symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec56473fcbf52718a6d7f0b9557faeb53416095" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importc&lt;/code&gt; is applied to a &lt;code&gt;let&lt;/code&gt; statement it can omit its value which will then be expected to come from C. This can be used to import a C &lt;code&gt;const&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82a67761bf009b1ccc17019d024dead497b2c8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;importcpp&lt;/code&gt; is applied to an enum type the numerical enum values are annotated with the C++ enum type, like in this example: &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt;. (This turned out to be the simplest way to implement it.)</source>
          <target state="translated">&lt;code&gt;importcpp&lt;/code&gt; 가 열거 형에 적용될 때 숫자 열거 형 값은 다음 예제에서와 같이 C ++ 열거 형으로 주석이 추가됩니다 : &lt;code&gt;((TheCppEnum)(3))&lt;/code&gt; . (이를 구현하는 가장 간단한 방법으로 밝혀졌습니다.)</target>
        </trans-unit>
        <trans-unit id="c0ec291075ab47c66b9aca7ce77f93fc4bdac281" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt; is non-empty, users are not required to separate short options and their values with a ':' or '=' since the parser knows which options accept values and which ones do not. This behavior also applies for long options if &lt;code&gt;longNoVal&lt;/code&gt; is non-empty. For short options, &lt;code&gt;-j4&lt;/code&gt; becomes supported syntax, and for long options, &lt;code&gt;--foo bar&lt;/code&gt; becomes supported. This is in addition to the &lt;a href=&quot;#supported-syntax&quot;&gt;previously mentioned syntax&lt;/a&gt;. Users can still separate options and their values with ':' or '=', but that becomes optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a139f37abab95c9bed1e71a37e9ff86bb1b47c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt; are non-empty then the ':' and '=' above are still accepted, but become optional. Note that these option key sets must be updated along with the set of option keys taking no value, but keys which do take values need no special updates as their set evolves.</source>
          <target state="translated">때 &lt;code&gt;shortNoVal&lt;/code&gt; / &lt;code&gt;longNoVal&lt;/code&gt; 는 ':'와 '='위에서 여전히 허용됩니다,하지만 선택 사항이 될 수있는 다음 비 웁니다. 이러한 옵션 키 세트는 값을 가지지 않는 옵션 키 세트와 함께 업데이트해야하지만 값을 취하는 키는 세트가 진화함에 따라 특별한 업데이트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24f30d768e45c2d32aab10d32954550abeb7d4e8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;useStream&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the file will be read into memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c515c96ec96f99594496b1328f30048f3de0cd1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;followSymlink&lt;/em&gt; is true, symlinks are followed and the information retrieved is information related to the symlink's target. Otherwise, information on the symlink itself is retrieved.</source>
          <target state="translated">때 &lt;em&gt;followSymlink는&lt;/em&gt; 사실, 심볼릭 링크는 다음과 검색된 정보는 심볼릭 링크의 대상에 관한 정보입니다 있습니다. 그렇지 않으면 심볼릭 링크 자체에 대한 정보가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="de4680275e7c901d5f3833c727cc99c5fb135e40" translate="yes" xml:space="preserve">
          <source>When Nim encounters an expression that cannot be resolved by the standard overload resolution rules, the current scope will be searched for a dot operator that can be matched against a re-written form of the expression, where the unknown field or proc name is passed to an &lt;code&gt;untyped&lt;/code&gt; parameter:</source>
          <target state="translated">Nim에서 표준 과부하 해결 규칙으로 확인할 수없는 표현식이 발견되면 현재 범위에서 알 수없는 필드 또는 프로 시저 이름이 전달 된 표현식의 다시 작성된 양식과 일치 할 수있는 도트 연산자를 검색합니다. &lt;code&gt;untyped&lt;/code&gt; 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="e2eaaa4e3170b1469cf0690081d49d1771a1d85a" translate="yes" xml:space="preserve">
          <source>When OpenSSL is dynamically linked, the wrapper provides partial forward and backward compatibility for OpenSSL versions above and below 1.1.0</source>
          <target state="translated">OpenSSL이 동적으로 연결되면 래퍼는 Open1.0 버전 1.1.0 이상에서 부분적인 앞뒤 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9ae81d2c9c4d1fafceab9a15e0a86562d3247333" translate="yes" xml:space="preserve">
          <source>When a generic type is instantiated with a type class instead of a concrete type, this results in another more specific type class:</source>
          <target state="translated">일반 유형이 구체적 유형이 아닌 유형 클래스로 인스턴스화되면보다 구체적인 유형 클래스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b7ee84914a1420903931986e31a5241d62b138" translate="yes" xml:space="preserve">
          <source>When a procedure uses the special &lt;code&gt;var&lt;/code&gt; type return variable, the result is different from that of a var section.</source>
          <target state="translated">프로 시저가 특수 &lt;code&gt;var&lt;/code&gt; 유형 리턴 변수를 사용하는 경우 결과는 var 섹션의 결과와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="97b4b802a770e586e56855a558c28871a136f5e3" translate="yes" xml:space="preserve">
          <source>When a request is made by a client the specified callback will be called.</source>
          <target state="translated">클라이언트가 요청하면 지정된 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c1a7a3d1dd71e0b4cf302372876e2f1c5cc12058" translate="yes" xml:space="preserve">
          <source>When a request is made to a different hostname, the current connection will be closed.</source>
          <target state="translated">다른 호스트 이름으로 요청하면 현재 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c3a07f0075ab0a45bf34eaf52dac74c940e4d650" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which can be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readfds&lt;/code&gt; 의 소켓을 읽을 준비가되면 읽을 수있는 소켓 수를 지정하여 0이 아닌 값이 리턴됩니다. 읽을 수있는 소켓도 &lt;code&gt;readfds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c3e80f170b0b81a10db5a4ea99b1003d321d7c6" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;readfds&lt;/code&gt; is ready to be read from then a non-zero value will be returned specifying the count of the sockets which can be read from. The sockets which cannot be read from will also be removed from &lt;code&gt;readfds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2377e8684393b2ce892159f2a4e80c538b1e3d8" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which &lt;strong&gt;cannot&lt;/strong&gt; be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;writefds&lt;/code&gt; 의 소켓에 쓸 준비가되면 쓸 수있는 소켓의 수를 지정하여 0이 아닌 값이 반환됩니다. 쓸 &lt;strong&gt;수없는&lt;/strong&gt; 소켓 도 &lt;code&gt;writefds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="43add50714f33e02f97cb791ebd99cd5319627ba" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which can be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;writefds&lt;/code&gt; 의 소켓에 쓸 준비가되면 쓸 수있는 소켓의 수를 지정하여 0이 아닌 값이 반환됩니다. 쓸 수있는 소켓도 &lt;code&gt;writefds&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="a593716765a85f211ef6839461ec2eec5b0c72ee" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;writefds&lt;/code&gt; is ready to be written to then a non-zero value will be returned specifying the count of the sockets which can be written to. The sockets which cannot be written to will also be removed from &lt;code&gt;writefds&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39bcbf0203513201bce5ea953d3b4e8ffa73d031" translate="yes" xml:space="preserve">
          <source>When adding a test case to the suite it is a good idea to write a few comments about what the test is meant to verify.</source>
          <target state="translated">테스트 케이스를 스위트에 추가 할 때 테스트의 의미에 대한 몇 가지 의견을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc850e7757d223791640269bd02d07871233442e" translate="yes" xml:space="preserve">
          <source>When both in-place mutation and 'returns transformed copy' are available the latter is a past participle of the former:</source>
          <target state="translated">인플레 이스 돌연변이와 '반환 변환 된 사본'을 모두 사용할 수있는 경우 후자는 전자의 과거 분사입니다.</target>
        </trans-unit>
        <trans-unit id="fdb02b24eb641a3d9df1e0f52c1e38d930194554" translate="yes" xml:space="preserve">
          <source>When compiled with the JS backend and executed in a browser, this proc calls &lt;code&gt;window.performance.now()&lt;/code&gt;, which is not supported by older browsers. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;MDN&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7871f40dcafcdf1db9af282909ed84f0a0d5c2" translate="yes" xml:space="preserve">
          <source>When expression</source>
          <target state="translated">표현할 때</target>
        </trans-unit>
        <trans-unit id="e76302e3e95252b2019148fcb20b2d9970fedac2" translate="yes" xml:space="preserve">
          <source>When growing, the new bytes of the block is initialized with all bytes containing zero, so it is somewhat safer then reallocShared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbcf6cc45ef40cb8b09cddb917f5aa2365f97f0" translate="yes" xml:space="preserve">
          <source>When installing documentation, .idx files are not required</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a33db9dee6b5b4dcbb8428eaf86543cac8e5c6" translate="yes" xml:space="preserve">
          <source>When multiple macro pragmas are applied to the same definition, the compiler will apply them consequently from left to right. Each macro will receive as input the output of the previous one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92587e3f6b92f3a82ee328815d7af4169d33454f" translate="yes" xml:space="preserve">
          <source>When multiple threads are generating random numbers, each thread must own the &lt;a href=&quot;#Rand&quot;&gt;Rand&lt;/a&gt; state it is using so that the thread can safely obtain random numbers. However, if each thread creates its own Rand state, the subsequences of random numbers that each thread generates may overlap, even if the provided seeds are unique. This is more likely to happen as the number of threads and amount of random numbers generated increases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5390519091e9974a31ed036eaeb0253339bd37ca" translate="yes" xml:space="preserve">
          <source>When multiple type params are present, they will bind freely to different types. To force a bind-once behavior one can use an explicit generic param:</source>
          <target state="translated">여러 유형의 매개 변수가 있으면 다른 유형에 자유롭게 바인딩됩니다. 한 번만 바인딩 동작을 수행하려면 명시적인 일반 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="020893f63cc1aaaba0f76060df95101dd9c22483" translate="yes" xml:space="preserve">
          <source>When naming types that come in value, pointer, and reference varieties, use a regular name for the variety that is to be used the most, and add a &quot;Obj&quot;, &quot;Ref&quot;, or &quot;Ptr&quot; suffix for the other varieties. If there is no single variety that will be used the most, add the suffixes to the pointer variants only. The same applies to C/C++ wrappers.</source>
          <target state="translated">값, 포인터 및 참조 품종으로 이름이 지정된 유형의 이름을 지정할 때는 가장 많이 사용되는 품종의 정규 이름을 사용하고 다른 품종에 대해 &quot;Obj&quot;, &quot;Ref&quot;또는 &quot;Ptr&quot;접미사를 추가하십시오. 가장 많이 사용되는 품종이 하나도없는 경우 접미사를 포인터 변형에만 추가하십시오. C / C ++ 랩퍼에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1225645594c00f94369b8ea3ee23053edbf83ba3" translate="yes" xml:space="preserve">
          <source>When nimvm statement</source>
          <target state="translated">언제 nimvm 문</target>
        </trans-unit>
        <trans-unit id="09a8f1f485ac1b789483ae38b3a6729e9b633fdc" translate="yes" xml:space="preserve">
          <source>When on Windows, it calls &lt;a href=&quot;#quoteShellWindows,string&quot;&gt;quoteShellWindows proc&lt;/a&gt;. Otherwise, calls &lt;a href=&quot;#quoteShellPosix,string&quot;&gt;quoteShellPosix proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda49f871e7ef45866bd4f710af7f4927e2c1a8d" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=' they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="translated">옵션 값이 ':'또는 '='로 시작하면 옵션은 &lt;code&gt;--delim::&lt;/code&gt; 에서와 같이 두 배로 증가 하거나 &lt;code&gt;--delim=:&lt;/code&gt; 에서와 같이 대체 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="945bbd04315e6d758eef0a07352a6c2a1e483402" translate="yes" xml:space="preserve">
          <source>When option values begin with ':' or '=', they need to be doubled up (as in &lt;code&gt;--delim::&lt;/code&gt;) or alternated (as in &lt;code&gt;--delim=:&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbb0504613b19518d968c26eceaaa8391745e36" translate="yes" xml:space="preserve">
          <source>When socket is non-blocking and no data is available on the socket, &lt;code&gt;-1&lt;/code&gt; will be returned and &lt;code&gt;data&lt;/code&gt; will be &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">socket이 비 블로킹이고 소켓에서 사용 가능한 데이터가 없으면 &lt;code&gt;-1&lt;/code&gt; 이 리턴되고 &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c99b697aa205b3dce70845af926b4da0b0718d3" translate="yes" xml:space="preserve">
          <source>When statement</source>
          <target state="translated">언제 진술</target>
        </trans-unit>
        <trans-unit id="bd80507fb2abefe95238353b2a9a7cfba726d9d1" translate="yes" xml:space="preserve">
          <source>When the 'returns transformed copy' version already exists like &lt;code&gt;strutils.replace&lt;/code&gt; an in-place version should get an &lt;code&gt;-In&lt;/code&gt; suffix (&lt;code&gt;replaceIn&lt;/code&gt; for this example).</source>
          <target state="translated">'returns transformed copy'버전이 이미 &lt;code&gt;strutils.replace&lt;/code&gt; 와 같이 존재 하는 경우 전체 버전은 &lt;code&gt;-In&lt;/code&gt; 접미사 ( 이 예제의 &lt;code&gt;replaceIn&lt;/code&gt; ) 를 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="ee41ae36de358d86d21ea16751455620675ba69a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;NimMain()&lt;/code&gt; function is called Nim initializes the garbage collector to the current thread, which is usually the main thread of your application. If your C code later spawns a different thread and calls Nim code, the garbage collector will fail to work properly and you will crash.</source>
          <target state="translated">&lt;code&gt;NimMain()&lt;/code&gt; 함수가 호출 되면 Nim은 가비지 수집기를 현재 스레드 (일반적으로 응용 프로그램의 기본 스레드)로 초기화합니다. C 코드가 나중에 다른 스레드를 생성하고 Nim 코드를 호출하면 가비지 수집기가 제대로 작동하지 않아 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="daad49e43f5115581c4b76d4a507c298160c9cb2" translate="yes" xml:space="preserve">
          <source>When the concept type is matched against a concrete type, the unbound type parameters are inferred from the body of the concept in a way that closely resembles the way generic parameters of callable symbols are inferred on call sites.</source>
          <target state="translated">개념 유형이 구체적 유형과 일치하는 경우, 호출 가능 심볼의 일반 매개 변수가 호출 사이트에서 유추되는 방식과 매우 유사한 방식으로 개념 본문에서 언 바운드 유형 매개 변수가 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="dc424979483c1453191890f6ad9d1875c3650e02" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;code&gt;AnnotatedPtr&lt;/code&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd24854ac2b1bea3f20fcea6158974c3a2524eb3" translate="yes" xml:space="preserve">
          <source>When the designated generic parameter is used to instantiate a pointer-like type as in the case of &lt;em&gt;AnnotatedPtr&lt;/em&gt; above, the resulting generic type will also have pointer-like covariance:</source>
          <target state="translated">위 의 &lt;em&gt;AnnotatedPtr&lt;/em&gt; 의 경우와 같이 지정된 제네릭 매개 변수를 사용하여 포인터와 같은 유형을 인스턴스화 하면 결과 제네릭 유형에도 포인터와 같은 공분산이 있습니다.</target>
        </trans-unit>
        <trans-unit id="055150de9c9775f611475f63ebc0e4678ce3f168" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. One can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c835f980849f2df2e29fb8df8dab183460e5e580" translate="yes" xml:space="preserve">
          <source>When the exported symbol is another module, all of its definitions will be forwarded. You can use an &lt;code&gt;except&lt;/code&gt; list to exclude some of the symbols.</source>
          <target state="translated">내 보낸 심볼이 다른 모듈 인 경우 모든 정의가 전달됩니다. &lt;code&gt;except&lt;/code&gt; 목록을 사용하여 일부 기호를 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07201729b3d6ca0d16d967e218a5729fc461cb07" translate="yes" xml:space="preserve">
          <source>When the flag &lt;code&gt;--benchmarkVM&lt;/code&gt; is passed to the compiler, this proc is also available at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668933161717cee32fe06aec026264b62ffd1bcd" translate="yes" xml:space="preserve">
          <source>When the garbage collector frees the object, &lt;code&gt;finalizer&lt;/code&gt; is called. The &lt;code&gt;finalizer&lt;/code&gt; may not keep a reference to the object pointed to by &lt;code&gt;x&lt;/code&gt;. The &lt;code&gt;finalizer&lt;/code&gt; cannot prevent the GC from freeing the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf92696d3f2ea1ae3634b81406709cbcffab8999" translate="yes" xml:space="preserve">
          <source>When the matched type within a concept is directly tested against a different concept, we say that the outer concept is a refinement of the inner concept and thus it is more-specific. When both concepts are matched in a call during overload resolution, Nim will assign a higher precedence to the most specific one. As an alternative way of defining concept refinements, you can use the object inheritance syntax involving the &lt;code&gt;of&lt;/code&gt; keyword:</source>
          <target state="translated">개념 내에서 일치하는 유형이 다른 개념에 대해 직접 테스트되면 외부 개념이 내부 개념을 개선 한 것이므로보다 구체적입니다. 과부하 해결 중 통화에서 두 개념이 일치하면 Nim은 가장 구체적인 개념에 우선 순위를 더 높게 지정합니다. 개념 세분화를 정의하는 대체 방법으로 &lt;code&gt;of&lt;/code&gt; 키워드를 포함하는 객체 상속 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="254e2ddbd3dd05fc683e34f1716f23a33c331fe1" translate="yes" xml:space="preserve">
          <source>When the process has finished executing, cleanup related handles.</source>
          <target state="translated">프로세스 실행이 완료되면 정리 관련 핸들.</target>
        </trans-unit>
        <trans-unit id="efe7cb68f3a591e4c2d4dcbbc522f1614fc7e0f0" translate="yes" xml:space="preserve">
          <source>When used as a table constructor, the syntax is different.</source>
          <target state="translated">테이블 생성자로 사용하면 구문이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="aaaf6332aae7b182e062b2664c8075404ebd76b7" translate="yes" xml:space="preserve">
          <source>When used for matching, keep in mind that likewise scanf, no backtracking is performed.</source>
          <target state="translated">매칭에 사용될 때, 마찬가지로 scanf, 역 추적은 수행되지 않는다는 것을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="5f917a7650b1a36cb2a4a1c6a6acf808f3f394e5" translate="yes" xml:space="preserve">
          <source>When used within a generic proc, a separate unique global variable will be created for each instantiation of the proc. The order of initialization of the created global variables within a module is not defined, but all of them will be initialized after any top-level variables in their originating module and before any variable in a module that imports it.</source>
          <target state="translated">일반 proc 내에서 사용될 때 proc의 각 인스턴스화마다 별도의 고유 전역 변수가 작성됩니다. 모듈 내에서 생성 된 전역 변수의 초기화 순서는 정의되어 있지 않지만 모든 변수는 원래 모듈에서 최상위 변수 다음에 그리고 모듈을 가져 오는 모듈에서 변수 전에 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d40d10962eaf620a88343cac40c78562830e1dd8" translate="yes" xml:space="preserve">
          <source>When using multiple loggers, calling the log proc for each logger can become repetitive. Instead of doing that, register each logger that will be used with the &lt;a href=&quot;#addHandler,Logger&quot;&gt;addHandler proc&lt;/a&gt;, which is demonstrated in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a843b1f225c4f364c5548dd36862fb04be3cf402" translate="yes" xml:space="preserve">
          <source>When using the style insensitive mode (&lt;code&gt;modeStyleInsensitive&lt;/code&gt;), all letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d07aa5bc818ad3ec9bad7f3accf7a490ff3025" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header (requires a C compiler with _Static_assert support, like any C11 compiler)</source>
          <target state="translated">C 헤더의 유형을 사용할 때 Nim 파일의 내용과 C 헤더의 내용을 비교하는 검사를 추가하십시오 (C11 컴파일러와 같이 _Static_assert 지원이있는 C 컴파일러 필요)</target>
        </trans-unit>
        <trans-unit id="781e441cbec5e078d843ea22975079918a7fc4e9" translate="yes" xml:space="preserve">
          <source>When using types from C headers, add checks that compare what's in the Nim file with what's in the C header. This may become enabled by default in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f14056818f81ec01f7058b5fdd03ac34cc67b2" translate="yes" xml:space="preserve">
          <source>When you are making an imported module accessible by modules that import yours, the &lt;code&gt;export&lt;/code&gt; syntax is pretty straightforward.</source>
          <target state="translated">가져온 모듈에서 가져온 모듈에 액세스 할 수있게하면 &lt;code&gt;export&lt;/code&gt; 구문이 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="226a5c35d585a47f9b67c9a9683d57977935ece5" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Another way to do the same without &lt;code&gt;when&lt;/code&gt; is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the &lt;code&gt;value&lt;/code&gt; to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08835fa964ca44a302c76938b48f30469a0f0a5b" translate="yes" xml:space="preserve">
          <source>When you iterate over objects with different field types you have to use the compile time &lt;code&gt;when&lt;/code&gt; instead of a runtime &lt;code&gt;if&lt;/code&gt; to select the code you want to run for each type. To perform the comparison use the &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is operator&lt;/a&gt;. Example:</source>
          <target state="translated">당신으로 반복이 끝난 다른 필드 유형의 개체를 할 때 당신은 컴파일 시간을 사용 할 &lt;code&gt;when&lt;/code&gt; 대신 런타임의 &lt;code&gt;if&lt;/code&gt; 각 유형에 대해 실행할 코드를 선택할 수 있습니다. 비교를 수행하려면 &lt;a href=&quot;manual#generics-is-operator&quot;&gt;is 연산자를&lt;/a&gt; 사용하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="3c6b91dbf30c6480d506d993a62a2e5ede60b7e6" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;docSeeSrcUrl&lt;/code&gt; switch to docgen, after each documented item in your source code the hyper link &lt;em&gt;See source&lt;/em&gt; will appear pointing to the implementation of that item on a GitHub repository. You can click the link to see the implementation of the item.</source>
          <target state="translated">&lt;code&gt;docSeeSrcUrl&lt;/code&gt; 스위치를 docgen으로 전달하면 소스 코드의 각 문서화 된 항목 후에 하이퍼 링크 &lt;em&gt;참조 소스&lt;/em&gt; 가 GitHub 저장소에서 해당 항목의 구현을 가리키는 것으로 나타납니다. 링크를 클릭하면 항목의 구현을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18a97667681fbb7bac72211a2b07123eb883bd7" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;rst2html&lt;/code&gt; command, all sections in the RST document will get an anchor you can hyper link to. Usually you can guess the anchor lower casing the section title and replacing spaces with dashes, and in any case you can get it from the table of contents. But when you run the &lt;code&gt;doc&lt;/code&gt; or &lt;code&gt;doc2&lt;/code&gt; commands to generate API documentation, some symbol get one or two anchors at the same time: a numerical identifier, or a plain name plus a complex name.</source>
          <target state="translated">&lt;code&gt;rst2html&lt;/code&gt; 명령 을 실행하면 RST 문서의 모든 섹션에 하이퍼 링크로 연결할 수있는 앵커가 생깁니다. 일반적으로 앵커가 섹션 제목을 케이싱하고 공백을 대시로 바꾸는 것을 짐작할 수 있으며 어쨌든 목차에서 얻을 수 있습니다. 그러나 &lt;code&gt;doc&lt;/code&gt; 또는 &lt;code&gt;doc2&lt;/code&gt; 명령을 실행하여 API 문서를 생성하면 일부 기호는 동시에 하나 또는 두 개의 앵커 (숫자 식별자 또는 일반 이름과 복잡한 이름)를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1ce4c6ad2b222c2702bd12ce14dc109cc99b9422" translate="yes" xml:space="preserve">
          <source>Whenever a user creates a specialized object, implementation of this procedure provides for &lt;code&gt;string&lt;/code&gt; representation.</source>
          <target state="translated">사용자가 특수 객체를 만들 때마다이 절차의 구현은 &lt;code&gt;string&lt;/code&gt; 표현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2d22034a155b9699e175c8c7b19c04441bf5e978" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same HTML file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4cc3bb373e7618b80ba75c42e4df4653d3d72e" translate="yes" xml:space="preserve">
          <source>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same html file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with &lt;code&gt;importc&lt;/code&gt;.</source>
          <target state="translated">이러한 pragma를 사용할 때마다 기본 코드를 최종 바이너리에 통합해야합니다. JavaScript의 경우에는 전혀 문제가되지 않습니다. 생성 된 JavaScript를 호스팅하는 동일한 html 파일은 &lt;code&gt;importc&lt;/code&gt; 로 가져 오는 다른 JavaScript 함수를 제공 할 가능성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df5560ebce6ac6ecfb31be9b51c86e4c7e9d1e1c" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;pathto/nim&lt;/code&gt; is any nim binary sufficiently recent (e.g. &lt;code&gt;bin/nim_cources&lt;/code&gt; built during bootstrap or &lt;code&gt;$HOME/.nimble/bin/nim&lt;/code&gt; installed by &lt;code&gt;choosenim 1.2.0&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeeaa58356082edb9c3248aa2f5880d152480e90" translate="yes" xml:space="preserve">
          <source>Where we are currently connected.</source>
          <target state="translated">우리가 현재 연결된 곳.</target>
        </trans-unit>
        <trans-unit id="46461b4ca7f105357f8fd52e913f10563d7fe3fd" translate="yes" xml:space="preserve">
          <source>Whether a checked runtime error results in an exception or in a fatal error at runtime is implementation specific. Thus the following program is always invalid:</source>
          <target state="translated">확인 된 런타임 오류로 인해 예외가 발생하는지 또는 런타임시 치명적인 오류가 발생하는지 여부는 구현에 따라 다릅니다. 따라서 다음 프로그램은 항상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3010c5cc1d5ed1605bdeec839471bc6e04c0c36" translate="yes" xml:space="preserve">
          <source>Whether a panic results in an exception or in a fatal error is implementation specific. Thus the following program is invalid; even though the code purports to catch the &lt;code&gt;IndexDefect&lt;/code&gt; from an out-of-bounds array access, the compiler may instead choose to allow the program to die with a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7602811bf6ae08bd5e22293258701c16580af8be" translate="yes" xml:space="preserve">
          <source>Whether a symbol that is declared in a template is exposed to the instantiation scope is controlled by the &lt;span id=&quot;inject_1&quot;&gt;inject&lt;/span&gt; and &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragmas: gensym'ed symbols are not exposed but inject'ed are.</source>
          <target state="translated">템플릿에 선언 된 기호가 인스턴스화 범위에 노출되는지 여부는 &lt;span id=&quot;inject_1&quot;&gt;주입&lt;/span&gt; 및 &lt;span id=&quot;gensym_1&quot;&gt;gensym&lt;/span&gt; pragma에 의해 제어됩니다 . gensym'ed 기호는 노출되지 않지만 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="855714febc5eeb00b339faa0d12bd25d89659cb1" translate="yes" xml:space="preserve">
          <source>Whether an operator is used a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="translated">연산자가 접두사 연산자를 사용하는지 여부는 선행 공백의 영향을받습니다 (이 구문 분석 변경 사항은 버전 0.13.0에서 도입되었습니다).</target>
        </trans-unit>
        <trans-unit id="8ae21edd574f3c50f91eb00c23c59d5accbfd946" translate="yes" xml:space="preserve">
          <source>Whether an operator is used as a prefix operator is also affected by preceding whitespace (this parsing change was introduced with version 0.13.0):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102554eef2805bb3ae93fa7e9ef62d55dda0a660" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the ConsoleLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c93dd156d356ea796a972f1b6f05d7ee3b682af" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the FileLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7820f01afe2100f3608e67fbc46fe5d7bd0c4d71" translate="yes" xml:space="preserve">
          <source>Whether the message is logged depends on both the RollingFileLogger's &lt;code&gt;levelThreshold&lt;/code&gt; field and the global log filter set using the &lt;a href=&quot;#setLogFilter,Level&quot;&gt;setLogFilter proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d41ff5608431c17e7d0fc23a167d921f5683a39" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$p.name&lt;/code&gt; can also be used, the &lt;code&gt;$&lt;/code&gt; operation on a string does nothing. Note that we cannot rely on automatic conversion from an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;string&lt;/code&gt; like we can for the &lt;code&gt;echo&lt;/code&gt; proc.</source>
          <target state="translated">&lt;code&gt;$p.name&lt;/code&gt; 도 사용할 수 있지만 문자열에 대한 &lt;code&gt;$&lt;/code&gt; 작업은 아무 것도 수행하지 않습니다. &lt;code&gt;echo&lt;/code&gt; proc 과 같이 &lt;code&gt;int&lt;/code&gt; 에서 &lt;code&gt;string&lt;/code&gt; 로의 자동 변환에 의존 할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="837197cffaa6ba949530b17e33bcba42ef50a34d" translate="yes" xml:space="preserve">
          <source>While Nim's support for object oriented programming (OOP) is minimalistic, powerful OOP techniques can be used. OOP is seen as &lt;em&gt;one&lt;/em&gt; way to design a program, not &lt;em&gt;the only&lt;/em&gt; way. Often a procedural approach leads to simpler and more efficient code. In particular, preferring composition over inheritance is often the better design.</source>
          <target state="translated">객체 지향 프로그래밍 (OOP)에 대한 Nim의 지원은 최소한이지만 강력한 OOP 기술을 사용할 수 있습니다. OOP는 다음과 같이 볼 수 있습니다 &lt;em&gt;하나의&lt;/em&gt; 프로그램이 아닌 설계 방법 &lt;em&gt;유일한&lt;/em&gt; 방법. 절차 적 접근 방식은 종종 더 간단하고 효율적인 코드로 이어집니다. 특히 상속보다 구성을 선호하는 것이 종종 더 나은 디자인입니다.</target>
        </trans-unit>
        <trans-unit id="3fff640cbdad99fe09274abee24df7bbf25d0561" translate="yes" xml:space="preserve">
          <source>While at the language level a method is differentiated from others by the parameters and return value, the signature of the method returned by idetools returns also the pragmas for the method.</source>
          <target state="translated">언어 수준에서 메서드는 매개 변수와 반환 값으로 다른 메서드와 차별화되지만 idetools에서 반환하는 메서드의 서명은 메서드에 대한 pragma도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="562bd6173e445712f1af66a953e8986ba0c2374d" translate="yes" xml:space="preserve">
          <source>While at the language level a proc is differentiated from others by the parameters and return value, the signature of the proc returned by idetools returns also the pragmas for the proc.</source>
          <target state="translated">언어 수준에서 proc은 매개 변수와 반환 값으로 다른 것과 구별되지만 idetools가 반환 한 proc의 서명은 proc에 대한 pragma도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f559b04b89f66e7a89345b0d5c2467b3e04e5d8" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daec9332bd403083c7c81ec7ddda4c8cfb83913d" translate="yes" xml:space="preserve">
          <source>While macros enable advanced compile-time code transformations, they cannot change Nim's syntax. However, this is no real restriction because Nim's syntax is flexible enough anyway.</source>
          <target state="translated">매크로는 고급 컴파일 타임 코드 변환을 가능하게하지만 Nim의 구문을 변경할 수는 없습니다. 그러나 Nim의 구문이 충분히 유연하기 때문에 이것은 실제 제한이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2ec95ebb740e8da659961135df7e65656f864a68" translate="yes" xml:space="preserve">
          <source>While similar to the &lt;span id=&quot;caller-info_1&quot;&gt;caller info&lt;/span&gt; of other languages, it is determined at compile time.</source>
          <target state="translated">다른 언어 의 &lt;span id=&quot;caller-info_1&quot;&gt;발신자 정보&lt;/span&gt; 와 비슷하지만 컴파일 타임에 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab874ba2e993f09c0db307995f9d97ec18bcd164" translate="yes" xml:space="preserve">
          <source>While statement</source>
          <target state="translated">성명서</target>
        </trans-unit>
        <trans-unit id="05b23a27e685e52955f50c8053fddf88076c61de" translate="yes" xml:space="preserve">
          <source>While the default Nim configuration is targeted for optimal performance on modern PC hardware and operating systems with ample memory, it is very well possible to run Nim code and a good part of the Nim standard libraries on small embedded microprocessors with only a few kilobytes of memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e660ee44904244d4ad0daaebc79a0ccc4b690ca1" translate="yes" xml:space="preserve">
          <source>Whilst the syntax of type classes appears to resemble that of ADTs/algebraic data types in ML-like languages, it should be understood that type classes are static constraints to be enforced at type instantiations. Type classes are not really types in themselves but are instead a system of providing generic &quot;checks&quot; that ultimately &lt;em&gt;resolve&lt;/em&gt; to some singular type. Type classes do not allow for runtime type dynamism, unlike object variants or methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441460d8bae7a87fe7d9e0c8e6f1dc6c4fb048ac" translate="yes" xml:space="preserve">
          <source>Whole routines (procs, iterators etc.) can also be passed to a template or a macro via the pragma notation:</source>
          <target state="translated">pragma 표기법을 통해 전체 루틴 (프로 시저, 반복자 등)을 템플릿 또는 매크로로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="455cc265958fecb1e713d605b1e591a53e7b0eb7" translate="yes" xml:space="preserve">
          <source>Whole routines can also be annotated with a &lt;code&gt;locks&lt;/code&gt; pragma that takes a lock level. This then means that the routine may acquire locks of up to this level. This is essential so that procs can be called within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">전체 루틴은 잠금 레벨을 취하는 &lt;code&gt;locks&lt;/code&gt; 프라그 마로 주석을 달 수 있습니다 . 이것은 루틴이이 레벨까지의 잠금을 획득 할 수 있음을 의미합니다. &lt;code&gt;locks&lt;/code&gt; 섹션 내에서 procs를 호출 할 수 있도록하기 위해 반드시 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="34796431c4136a13fc1a272537e43a27d56433b1" translate="yes" xml:space="preserve">
          <source>Windows specific</source>
          <target state="translated">특정 윈도우</target>
        </trans-unit>
        <trans-unit id="d5112a64c16520957eef986a882e256783fd1b64" translate="yes" xml:space="preserve">
          <source>Windows-specific</source>
          <target state="translated">Windows-specific</target>
        </trans-unit>
        <trans-unit id="f082c74fae11cd24ce038c421b38da0f7f03aa4d" translate="yes" xml:space="preserve">
          <source>Windows: this is still supported despite Windows platform not having this convention; also, both &lt;code&gt;~/&lt;/code&gt; and &lt;code&gt;~\&lt;/code&gt; are handled.</source>
          <target state="translated">Windows :이 규칙이없는 Windows 플랫폼에도 불구하고 여전히 지원됩니다. 또한 &lt;code&gt;~/&lt;/code&gt; 와 &lt;code&gt;~\&lt;/code&gt; 가 모두 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2ff415fa045bd448401a30116ad4b171a87ce64f" translate="yes" xml:space="preserve">
          <source>With 'getType' you can access the node's &lt;span id=&quot;type_1&quot;&gt;type&lt;/span&gt;. A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call &lt;code&gt;typeKind&lt;/code&gt; on getType's result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10d3f7f20c0f9046a906444b8a60a2f35498a01" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;except&lt;/code&gt;, we get &lt;code&gt;nnkImportExceptStmt&lt;/code&gt;.</source>
          <target state="translated">를 &lt;code&gt;except&lt;/code&gt; &lt;code&gt;nnkImportExceptStmt&lt;/code&gt; 를 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="b4974a309f4c94a4f9d5a2467682e0908cb7a682" translate="yes" xml:space="preserve">
          <source>With parenthesis and semicolons &lt;code&gt;(;)&lt;/code&gt; you can use statements where only an expression is allowed:</source>
          <target state="translated">괄호와 세미콜론 &lt;code&gt;(;)&lt;/code&gt; 을 사용하면 표현식 만 허용되는 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d171ddc79243587420ce2e420c38a86ca6d787e" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--run&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;switch&lt;/a&gt; Nim executes the file automatically after compilation. You can give your program command line arguments by appending them after the filename:</source>
          <target state="translated">&lt;code&gt;--run&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;스위치를&lt;/a&gt; 사용하면 Nim은 컴파일 후 파일을 자동으로 실행합니다. 파일 이름 뒤에 추가하여 프로그램 명령 줄 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd482d4d9faa3aac000c3242487f0f59daaef12" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure can also be exported to a dynamic library. The pragma then has no argument and has to be used in conjunction with the &lt;code&gt;exportc&lt;/code&gt; pragma:</source>
          <target state="translated">으로 &lt;code&gt;dynlib&lt;/code&gt; 의 프라그 절차는 동적 라이브러리로 내보낼 수 있습니다. 그런 다음 pragma에는 인수가 없으며 &lt;code&gt;exportc&lt;/code&gt; pragma 와 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="023454d8e1cf65bbb06463e1b3d0c36017c3e388" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;dynlib&lt;/code&gt; pragma a procedure or a variable can be imported from a dynamic library (&lt;code&gt;.dll&lt;/code&gt; files for Windows, &lt;code&gt;lib*.so&lt;/code&gt; files for UNIX). The non-optional argument has to be the name of the dynamic library:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt; pragma를 사용하면 동적 라이브러리 ( Windows의 경우 &lt;code&gt;.dll&lt;/code&gt; 파일, UNIX의 경우 &lt;code&gt;lib*.so&lt;/code&gt; 파일) 에서 프로 시저 또는 변수를 가져올 수 있습니다 . 선택 사항이 아닌 인수는 동적 라이브러리의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="94e21cefadb9559dc5ffe233e376ae6b6407e1ce" translate="yes" xml:space="preserve">
          <source>With the language mechanisms described here, a custom seq could be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ed0ac91dffc6d43c92455d3eaf4fb792201cb9" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="translated">대신에이 두 파일을 사용하면 실행할 수 있습니다 &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; 과 님 컴파일러는 컴파일 &lt;code&gt;logic.c&lt;/code&gt; 의 뿐만 아니라 파일을 &lt;code&gt;calculator.nim&lt;/code&gt; 및 출력 실행으로 모두 연결 &lt;code&gt;10&lt;/code&gt; 때 실행. C 파일을 정적으로 링크하고 동일한 효과를 얻는 또 다른 방법은 &lt;code&gt;compile&lt;/code&gt; pragma로 줄을 제거 하고 다음과 같은 일반적인 Unix 명령을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="25e2a3b917bb5d88c58d0943d534994772fafb16" translate="yes" xml:space="preserve">
          <source>With these two files in place, you can run &lt;code&gt;nim c -r calculator.nim&lt;/code&gt; and the Nim compiler will compile the &lt;code&gt;logic.c&lt;/code&gt; file in addition to &lt;code&gt;calculator.nim&lt;/code&gt; and link both into an executable, which outputs &lt;code&gt;10&lt;/code&gt; when run. Another way to link the C file statically and get the same effect would be to remove the line with the &lt;code&gt;compile&lt;/code&gt; pragma and run the following typical Unix commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703804d49b5d6d854ebf524062c82cd68bb2640b" translate="yes" xml:space="preserve">
          <source>With this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134c388489465dbdb52a685a4462b7c0722ae58b" translate="yes" xml:space="preserve">
          <source>With this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f010be8a21b14dff05310dc71f698e090ed9c5" translate="yes" xml:space="preserve">
          <source>With this notation we can now easily define the core of the grammar: A block of statements (simplified example):</source>
          <target state="translated">이 표기법을 사용하여 문법의 핵심을 쉽게 정의 할 수 있습니다. 문장 블록 (단순화 된 예) :</target>
        </trans-unit>
        <trans-unit id="0036fe9e484a381c94e7a2817c459b4a03ab955b" translate="yes" xml:space="preserve">
          <source>With this output we have a better idea of what kind of input the compiler expects. We need to generate a list of statements. For each constant the source code generates a &lt;code&gt;ConstSection&lt;/code&gt; and a &lt;code&gt;ConstDef&lt;/code&gt;. If we were to move all the constants to a single &lt;code&gt;const&lt;/code&gt; block we would see only a single &lt;code&gt;ConstSection&lt;/code&gt; with three children.</source>
          <target state="translated">이 출력을 통해 컴파일러가 어떤 종류의 입력을 기대할 수 있는지 더 잘 알 수 있습니다. 진술 목록을 생성해야합니다. 각각의 상수에 대한 소스 코드가 생성 &lt;code&gt;ConstSection&lt;/code&gt; 및 &lt;code&gt;ConstDef&lt;/code&gt; 를 . 모든 상수를 단일 &lt;code&gt;const&lt;/code&gt; 블록으로 &lt;code&gt;ConstSection&lt;/code&gt; 세 개의 자식이 있는 하나의 ConstSection 만 보입니다 .</target>
        </trans-unit>
        <trans-unit id="fae6de82250865ee469a39f7ecbc1836e2a60ef6" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;parallel&lt;/code&gt; section sometimes the &lt;code&gt;FlowVar[T]&lt;/code&gt; is eliminated to &lt;code&gt;T&lt;/code&gt;. This happens when &lt;code&gt;T&lt;/code&gt; does not contain any GC'ed memory. The compiler can ensure the location in &lt;code&gt;location = spawn f(...)&lt;/code&gt; is not read prematurely within a &lt;code&gt;parallel&lt;/code&gt; section and so there is no need for the overhead of an indirection via &lt;code&gt;FlowVar[T]&lt;/code&gt; to ensure correctness.</source>
          <target state="translated">내에서 &lt;code&gt;parallel&lt;/code&gt; 섹션 때때로 &lt;code&gt;FlowVar[T]&lt;/code&gt; 로 제거 &lt;code&gt;T&lt;/code&gt; . 이것은 &lt;code&gt;T&lt;/code&gt; 에 GC 메모리가 없을 때 발생 합니다. 컴파일러는 &lt;code&gt;location = spawn f(...)&lt;/code&gt; 가 &lt;code&gt;parallel&lt;/code&gt; 섹션 내에서 조기에 &lt;code&gt;FlowVar[T]&lt;/code&gt; 않도록 보장 할 수 있으므로 정확성을 보장하기 위해 FlowVar [T] 를 통한 간접비의 오버 헤드가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b61954fea1e9977075452ce15801a081ce8368da" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause it is possible to access the current exception using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f36950618b8748e3741661dd8fec794ecb08261" translate="yes" xml:space="preserve">
          <source>Within an &lt;code&gt;except&lt;/code&gt; clause, it is possible to use &lt;code&gt;getCurrentException&lt;/code&gt; to retrieve the exception that has been raised:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 절 내에서 &lt;code&gt;getCurrentException&lt;/code&gt; 을 사용 하여 발생한 예외를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ae57f97edbcd123ef0194b0d49cf9ec52d7039" translate="yes" xml:space="preserve">
          <source>Within the concept body, types can appear in positions where ordinary values and parameters are expected. This provides a more convenient way to check for the presence of callable symbols with specific signatures:</source>
          <target state="translated">개념 본문 내에서 유형은 일반적인 값과 매개 변수가 필요한 위치에 나타날 수 있습니다. 이를 통해 특정 서명이있는 호출 가능한 기호가 있는지보다 편리하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7765888ff783f01e496adca7f847d2e186e708cb" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;GCunref&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="translated">&lt;code&gt;GCunref&lt;/code&gt; 호출이 없으면 &lt;code&gt;d.s&lt;/code&gt; 문자열에 할당 된 메모리 가 해제되지 않습니다. 이 예제는 또한 저수준 프로그래밍의 두 가지 중요한 기능을 보여줍니다. &lt;code&gt;sizeof&lt;/code&gt; proc는 유형 또는 값의 크기를 바이트 단위로 반환합니다. &lt;code&gt;cast&lt;/code&gt; 연산자는 타입 시스템을 우회 할 수 있습니다 컴파일러는 결과 치료하기 위해 강제로 &lt;code&gt;alloc0&lt;/code&gt; 의 이 유형 것처럼 (지정되지 않은 포인터를 반환) 호출 &lt;code&gt;ptr Data&lt;/code&gt; . 피할 수없는 경우에만 캐스팅을 수행해야합니다. 유형 안전을 위반하고 버그로 인해 신비한 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e4895a8f2ad8f356ca5ea9759cc4d11c134c3e8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;reset&lt;/code&gt; call the memory allocated for the &lt;code&gt;d.s&lt;/code&gt; string would never be freed. The example also demonstrates two important features for low-level programming: the &lt;code&gt;sizeof&lt;/code&gt; proc returns the size of a type or value in bytes. The &lt;code&gt;cast&lt;/code&gt; operator can circumvent the type system: the compiler is forced to treat the result of the &lt;code&gt;alloc0&lt;/code&gt; call (which returns an untyped pointer) as if it would have the type &lt;code&gt;ptr Data&lt;/code&gt;. Casting should only be done if it is unavoidable: it breaks type safety and bugs can lead to mysterious crashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2688119cf2f2a4b43b3fc29913f8b3c9d7e8a24d" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39a9ca07a5dddf13d83fab735c567da3357a0bf" translate="yes" xml:space="preserve">
          <source>Word wraps &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">단어는 &lt;em&gt;s를&lt;/em&gt; 감 쌉니다 .</target>
        </trans-unit>
        <trans-unit id="6962ff8c9e27a68a644675d133701514aae2e762" translate="yes" xml:space="preserve">
          <source>Would output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="3975aca436c50894cad487d4bc2ad703a4570339" translate="yes" xml:space="preserve">
          <source>Wrap pipe for reading with PipeOutStream so that you can use peek* procs and generate runtime error when setPosition/getPosition is called or write operation is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46922791e8808797fd6b6b49d2da608b707afc45" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,HashSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; for initialization of hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9948186b583eed7e908d2b1fc1c7b13e25370f72" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,OrderedSet%5BA%5D,int&quot;&gt;init proc&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436516f371b709f69cf997c54adc4f028f9eebcd" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of ordered hash sets.</source>
          <target state="translated">순서화 된 해시 세트의 초기화를위한 &lt;a href=&quot;#init,TOrderedSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; 주위의 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="aef47240f283c974795c0afe97ed4a86669acef1" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init()&lt;/a&gt; for initialization of hash sets.</source>
          <target state="translated">해시 세트의 초기화를위한 &lt;a href=&quot;#init,TSet%5BA%5D,int&quot;&gt;init ()&lt;/a&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="68af9e3f5b6fc9029361a1014092e5519a57f230" translate="yes" xml:space="preserve">
          <source>Wrapper for the &lt;a href=&quot;http://webserver2.tecgraf.puc-rio.br/iup&quot;&gt;IUP native GUI library&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f194a53efcd466e3ff60aa4bb858d39668b2accb" translate="yes" xml:space="preserve">
          <source>Wrapper for the &lt;code&gt;console&lt;/code&gt; object for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript backend&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d365d3fa59d526a0f2809a9f61b0028c5e94b10" translate="yes" xml:space="preserve">
          <source>Wrappers</source>
          <target state="translated">Wrappers</target>
        </trans-unit>
        <trans-unit id="533cb09f4efea84d68d3be20e42d0338fe89c618" translate="yes" xml:space="preserve">
          <source>Wrapping constructors</source>
          <target state="translated">래핑 생성자</target>
        </trans-unit>
        <trans-unit id="11cdbcadb273848cfeb799098c4c21e8db2e9d40" translate="yes" xml:space="preserve">
          <source>Wrapping destructors</source>
          <target state="translated">포장 소멸자</target>
        </trans-unit>
        <trans-unit id="9c3c9e84480e553d08468d0746063eeb3c7f119f" translate="yes" xml:space="preserve">
          <source>Wraps a connected socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket. &lt;code&gt;hostname&lt;/code&gt; should be specified so that the client knows which hostname the server certificate should be validated against.</source>
          <target state="translated">연결된 소켓을 SSL 컨텍스트로 래핑합니다. 이 기능은 &lt;code&gt;socket&lt;/code&gt; 을 SSL 소켓으로 효과적으로 전환 합니다. 클라이언트가 서버 인증서의 유효성을 검증 할 호스트 이름을 알 수 있도록 &lt;code&gt;hostname&lt;/code&gt; 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ddc5519e19aff7c9640076ae420da42486453ed" translate="yes" xml:space="preserve">
          <source>Wraps a socket in an SSL context. This function effectively turns &lt;code&gt;socket&lt;/code&gt; into an SSL socket.</source>
          <target state="translated">소켓을 SSL 문맥으로 랩합니다. 이 기능은 &lt;code&gt;socket&lt;/code&gt; 을 SSL 소켓으로 효과적으로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="02cc7fed3b72e2c8ac3c8047c2bf9e4c909ccdc0" translate="yes" xml:space="preserve">
          <source>Wraps an already initialized &lt;code&gt;Socket&lt;/code&gt; into a AsyncSocket. This is useful if you want to use an already connected Socket as an asynchronous AsyncSocket in asyncio's event loop.</source>
          <target state="translated">이미 초기화 된 &lt;code&gt;Socket&lt;/code&gt; 을 AsyncSocket에 래핑합니다. 이것은 이미 연결된 소켓을 asyncio의 이벤트 루프에서 비동기 AsyncSocket으로 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="396fc10d54c3cf990455330123fbffedf5d5823d" translate="yes" xml:space="preserve">
          <source>Write a varint into z. The buffer z must be at least 9 characters long to accommodate the largest possible varint. Returns the number of bytes used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffafe37f8960be4ae464063375188b7367ce278" translate="yes" xml:space="preserve">
          <source>Write file stream example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f942433295c32b403eab1ccdf7cdbcb2774f2494" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;data&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">비동기 적으로 지정된 파일에 &lt;code&gt;data&lt;/code&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7c97819e5811aa1e2b05fd1d97141d7dc4900644" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;size&lt;/code&gt; bytes from &lt;code&gt;buf&lt;/code&gt; to the file specified asynchronously.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 에서 &lt;code&gt;size&lt;/code&gt; 바이트를 비동기 적으로 지정된 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="897e1a9e1ed791afbff422f3f8123f94d65ede78" translate="yes" xml:space="preserve">
          <source>Writes &lt;em&gt;data&lt;/em&gt; to the socket.</source>
          <target state="translated">소켓에 &lt;em&gt;데이터&lt;/em&gt; 를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="796e89b2dfa91121c9081a71fb4dbffb2ef52227" translate="yes" xml:space="preserve">
          <source>Writes a hint message at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e02f96826ac037cab146bc6bc90e2ae64673c1" translate="yes" xml:space="preserve">
          <source>Writes a rope to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e26a88656e91e6fb039c88ea549d3868acb5ba9" translate="yes" xml:space="preserve">
          <source>Writes a rope to a stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e5333ad312886271eeed037f50490e8ec4c73b" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;code&gt;f&lt;/code&gt;. May throw an IO exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e3f5c8aacd0969383d67b232c4242e0fbab6cf" translate="yes" xml:space="preserve">
          <source>Writes a value to the file &lt;em&gt;f&lt;/em&gt;. May throw an IO exception.</source>
          <target state="translated">파일 &lt;em&gt;f에&lt;/em&gt; 값을 씁니다 . IO 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed03d9b983f99dab4aa01201c58720371e95d88f" translate="yes" xml:space="preserve">
          <source>Writes a warning message at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752d2fff4c96bf5371611ce6c8cf86108850f7b6" translate="yes" xml:space="preserve">
          <source>Writes an error message at compile time. The optional &lt;code&gt;n: NimNode&lt;/code&gt; parameter is used as the source for file and line number information in the compilation error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b82505d585d59b7b931841c5790d2d061a18cf" translate="yes" xml:space="preserve">
          <source>Writes and flushes the parameters to the standard output.</source>
          <target state="translated">매개 변수를 표준 출력에 쓰고 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="9fe62811850204f6989910a722d883718ece800c" translate="yes" xml:space="preserve">
          <source>Writes data to the specified future stream as the file is read.</source>
          <target state="translated">파일을 읽을 때 지정된 미래 스트림에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="01df58caf78b67ac5c60557abefc959157051a68" translate="yes" xml:space="preserve">
          <source>Writes given message string to stderr by default. If &lt;code&gt;--stdout&lt;/code&gt; option is given, writes to stdout instead. If message hook is present, then it is used to output message rather than stderr/stdout. This behavior can be altered by given optional flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92242dea02e29327d993eb1cc3297777dff63be" translate="yes" xml:space="preserve">
          <source>Writes into &lt;code&gt;result&lt;/code&gt; the rst ast &lt;code&gt;n&lt;/code&gt; using the &lt;code&gt;d&lt;/code&gt; configuration.</source>
          <target state="translated">에 기록이 &lt;code&gt;result&lt;/code&gt; RST AST &lt;code&gt;n&lt;/code&gt; 은 USING &lt;code&gt;d&lt;/code&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="0dc097c5b3691675769f2dac59504815afe50f52" translate="yes" xml:space="preserve">
          <source>Writes one or more strings to the the stream &lt;code&gt;s&lt;/code&gt; followed by a new line. No length field or terminating zero is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37126a1a008a17bc0fde47d26b420dbd7ee35bc" translate="yes" xml:space="preserve">
          <source>Writes one or more strings to the the stream. No length fields or terminating zeros are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f25f4df96580649fbf61c73bf96f72aec9e3b5f" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to string. Note: Comment statement will be ignored.</source>
          <target state="translated">테이블의 내용을 문자열에 씁니다. 참고 : 설명문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ba6e3b9c400f1eef44b307552759341bc86ee5ce" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified configuration file. Note: Comment statement will be ignored.</source>
          <target state="translated">테이블의 내용을 지정된 구성 파일에 씁니다. 참고 : 설명문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="943a3e5523074ab2149addf7bbeb0fa3c3bf1c09" translate="yes" xml:space="preserve">
          <source>Writes the contents of the table to the specified stream</source>
          <target state="translated">테이블의 내용을 지정된 스트림에 씁니다.</target>
        </trans-unit>
        <trans-unit id="6cd9e881510f9be093ebe517fe9b4aa83cc82a0a" translate="yes" xml:space="preserve">
          <source>Writes the current index buffer to the specified output file.</source>
          <target state="translated">현재 색인 버퍼를 지정된 출력 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="e1de254c163d199c70c1b6b5d6c0d804cf679251" translate="yes" xml:space="preserve">
          <source>Writes the current stack trace to &lt;code&gt;stderr&lt;/code&gt;. This is only works for debug builds. Since it's usually used for debugging, this is proclaimed to have no IO effect!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd32587819be16f41963d9f477e3a15c30356f1" translate="yes" xml:space="preserve">
          <source>Writes the given RST node as JSON that is in the form</source>
          <target state="translated">주어진 RST 노드를 JSON 형식으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3bbbda5ef7f0ace5ebf184908b2e7da636d8527f" translate="yes" xml:space="preserve">
          <source>Writes the list of registered foreign deps to stdout.</source>
          <target state="translated">등록 된 외부 뎁 목록을 stdout에 씁니다.</target>
        </trans-unit>
        <trans-unit id="0cfd7a39f362d2a77758e5c07bcd311bfabd3290" translate="yes" xml:space="preserve">
          <source>Writes the specified value inside the specified future stream.</source>
          <target state="translated">지정된 미래 스트림 내에 지정된 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="5c2eb2f5a72f7c3f1d91128581c5c2ff25e6b9df" translate="yes" xml:space="preserve">
          <source>Writes the string &lt;code&gt;x&lt;/code&gt; to the the stream &lt;code&gt;s&lt;/code&gt;. No length field or terminating zero is written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8255ac21cf77099d0f6ff9ac6e846fb5cdb0fda" translate="yes" xml:space="preserve">
          <source>Writes the string:</source>
          <target state="translated">문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="fa9e4f26c45e8a0cad793cc3ee793fe2081404dd" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;code&gt;txt&lt;/code&gt; in a given &lt;code&gt;style&lt;/code&gt; to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2914acbe1102d062a4f2393594889f72ba0c206e" translate="yes" xml:space="preserve">
          <source>Writes the text &lt;em&gt;txt&lt;/em&gt; in a given &lt;em&gt;style&lt;/em&gt; to stdout.</source>
          <target state="translated">주어진 &lt;em&gt;스타일&lt;/em&gt; 의 텍스트 &lt;em&gt;txt&lt;/em&gt; 를 stdout 에 씁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="273726bd38de7eff2c09ffae11f809aa1fb0834f" translate="yes" xml:space="preserve">
          <source>Written by Philip Hazel</source>
          <target state="translated">필립 헤이젤</target>
        </trans-unit>
        <trans-unit id="f7b03e2f61abd9d04fffa15c8355e3436931a0ae" translate="yes" xml:space="preserve">
          <source>XDeclaredButNotUsed</source>
          <target state="translated">XDeclaredButNotUsed</target>
        </trans-unit>
        <trans-unit id="d647f348ffbbc7a4d48d8ae4bec579637ae0ee51" translate="yes" xml:space="preserve">
          <source>XML Processing</source>
          <target state="translated">XML 처리</target>
        </trans-unit>
        <trans-unit id="48398d8a1771285228591dd83034fba7e8e2884d" translate="yes" xml:space="preserve">
          <source>YES-cases:</source>
          <target state="translated">YES-cases:</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="d850dd17ecf96df39630839c6d073caf7cb5fb52" translate="yes" xml:space="preserve">
          <source>Yield every (position, value) of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq의&lt;/em&gt; 모든 (위치, 값)을 &lt;em&gt;산출&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="755dd97240e42a3dc4431ff54cbcde0d38f93331" translate="yes" xml:space="preserve">
          <source>Yield every element of &lt;em&gt;deq&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;deq의&lt;/em&gt; 모든 요소를 &lt;em&gt;산출하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ca75af94090e37bbf9398ee1de83cc580bdc1c" translate="yes" xml:space="preserve">
          <source>Yield statement</source>
          <target state="translated">수율 진술</target>
        </trans-unit>
        <trans-unit id="871ed0e0067addcd6d123efb1b36f30a773f4184" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411b555314d7bea23a1f5dea43d50bcf2cb6f9d5" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt;. The yielded values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcc8e4db61e555c560cceaf1ae0fbe7dd651d9d" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="153e16ecf7518e033c97e0e1289c930db427903e" translate="yes" xml:space="preserve">
          <source>Yields all (key, value)-pairs of &lt;code&gt;c&lt;/code&gt;. The yielded values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c9dc8ace4645a635c6317e0a7e3490ea0317b9" translate="yes" xml:space="preserve">
          <source>Yields all keys in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70578c25e269ef74aa752deb3a85fb90f00ed337" translate="yes" xml:space="preserve">
          <source>Yields all keys starting with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1ac4376c91d07e7515d60a7f26a24af693a955" translate="yes" xml:space="preserve">
          <source>Yields all keys starting with &lt;code&gt;prefix&lt;/code&gt;. If &lt;code&gt;longestMatch&lt;/code&gt; is true, the longest match is returned, it doesn't have to be a complete match then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b74859a60c7beb5e048dac80c77f1ca93b2cc30" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;code&gt;substrings&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f3a56dbd00c322681bd3d8cb3a2e92bba08be1" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치 하는 &lt;code&gt;s&lt;/code&gt; 의 일치하는 모든 &lt;em&gt;하위 문자열&lt;/em&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="5dbe19c48460bbfdb0a7ecb4ffe08a0ee9cd8526" translate="yes" xml:space="preserve">
          <source>Yields all matching &lt;em&gt;substrings&lt;/em&gt; of &lt;em&gt;s&lt;/em&gt; that match &lt;em&gt;pattern&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pattern&lt;/em&gt; 과 일치 하는 &lt;em&gt;s의&lt;/em&gt; 일치하는 모든 &lt;em&gt;하위 문자열&lt;/em&gt; 을 생성 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="169e24bd87b1517e6d052811177d3433fa68b902" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; in the lexicographical order of the corresponding keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e384e37f49f3071bbd9d91f79ba3ec7eaff6081a" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; in the lexicographical order of the corresponding keys. The values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032d25dce63f802943bc4f5a82bd2715601f6348" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt; of the corresponding keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522c184791ecd24f9d68cbd3ce71cdd02c50441f" translate="yes" xml:space="preserve">
          <source>Yields all values of &lt;code&gt;c&lt;/code&gt; starting with &lt;code&gt;prefix&lt;/code&gt; of the corresponding keys. The values can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26171d2547797d7b792e1c5b0afcc0cbe263ef92" translate="yes" xml:space="preserve">
          <source>Yields each key, value pair.</source>
          <target state="translated">각 키, 값 쌍을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b31f81b8732998c727005f0698e5647bea870a3d" translate="yes" xml:space="preserve">
          <source>Yields every (position, value) of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3077cb4e1456fcbff5c2be8421c2ec48d4578f0" translate="yes" xml:space="preserve">
          <source>Yields every element of &lt;code&gt;deq&lt;/code&gt;, which can be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7118acdad38de564553a07a9a5d6d15077a33629" translate="yes" xml:space="preserve">
          <source>Yields every element of &lt;code&gt;deq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac42bb6f91f9cbe0cbde4387b00af7ec5d6e7f53" translate="yes" xml:space="preserve">
          <source>Yields every value of &lt;code&gt;L&lt;/code&gt; so that you can modify it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091382909836c7d012e749cd20e26a4eb8483aad" translate="yes" xml:space="preserve">
          <source>Yields every value of &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b52ded50cecd2d2df18504d55b3b58b1a2b74ce" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;keys&lt;/code&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625400c91d9b41d4450d5dc3e48a6585aee75eec" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;names&lt;/code&gt; of each field in a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d1ffb21fc391e5830bf786e111b49811f9781" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;values&lt;/code&gt; in a JsAssoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675c49cde4f31484041edd74cabab71e5878b730" translate="yes" xml:space="preserve">
          <source>Yields the &lt;code&gt;values&lt;/code&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d7e3fc8749812999838907214d1eb8450309265" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;keys&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">JsAssoc 의 &lt;em&gt;키&lt;/em&gt; 를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a2417d997628d8ba1aefeea2d89fe75654c22728" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;names&lt;/em&gt; of each field in a JsObject.</source>
          <target state="translated">JsObject에서 각 필드 의 &lt;em&gt;이름&lt;/em&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93956d196d887cc0861e43d2a531388eaa74a029" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; in a JsAssoc.</source>
          <target state="translated">JsAssoc 의 &lt;em&gt;값&lt;/em&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1f1a656995365fee941d9a0f7f934014284b0f0a" translate="yes" xml:space="preserve">
          <source>Yields the &lt;em&gt;values&lt;/em&gt; of each field in a JsObject, wrapped into a JsObject.</source>
          <target state="translated">수율 &lt;em&gt;값&lt;/em&gt; JSObject가로 싸서 JSObject를 각 필드의이.</target>
        </trans-unit>
        <trans-unit id="3fe8766634b03a0c571dde2851555af85b82423a" translate="yes" xml:space="preserve">
          <source>Yields the child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">&lt;em&gt;Peg&lt;/em&gt; 변형 오브젝트 의 하위 노드가있는 경우이를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d8ec21b096062ab66fc1c72aaf6915c5df074b73" translate="yes" xml:space="preserve">
          <source>Yields the indices and child nodes of a &lt;em&gt;Peg&lt;/em&gt; variant object where present.</source>
          <target state="translated">&lt;em&gt;Peg&lt;/em&gt; 변형 오브젝트 의 인덱스 및 하위 노드를 나타 냅니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="e7f74ddd7d348b61efb92c54d7525b3431582e18" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;code&gt;key&lt;/code&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9787a201226a9a90fb295daca65242e9806ef392" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(K, V)&lt;/code&gt;, with the first entry being a &lt;em&gt;key&lt;/em&gt; in the JsAssoc and the second being its corresponding value.</source>
          <target state="translated">&lt;code&gt;(K, V)&lt;/code&gt; 유형의 튜플을 생성 합니다. 첫 번째 항목 은 JsAssoc 의 &lt;em&gt;키&lt;/em&gt; 이고 두 번째 항목은 해당 값입니다.</target>
        </trans-unit>
        <trans-unit id="809aab236ff4a1a93f81d6d340fb24ba29fa5d00" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;code&gt;name&lt;/code&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5fe99d112e72e96635690ca13742e71ee3b251" translate="yes" xml:space="preserve">
          <source>Yields tuples of type &lt;code&gt;(cstring, JsObject)&lt;/code&gt;, with the first entry being the &lt;em&gt;name&lt;/em&gt; of a fields in the JsObject and the second being its value wrapped into a JsObject.</source>
          <target state="translated">&lt;code&gt;(cstring, JsObject)&lt;/code&gt; 유형의 튜플을 생성 합니다. 첫 번째 항목 은 JsObject의 필드 &lt;em&gt;이름&lt;/em&gt; 이고 두 번째 항목 은 JsObject에 래핑 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="41454d09396bcb771849a87c8bc4283f5e65feb4" translate="yes" xml:space="preserve">
          <source>You can also bisect using custom options to build the compiler, for example if you don't need a debug version of the compiler (which runs slower), you can replace &lt;code&gt;./koch temp&lt;/code&gt; by explicit compilation command, see &lt;a href=&quot;intern#rebuilding-the-compiler&quot;&gt;Rebuilding the compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0096f64ab9c850e6d8688547c2fb784796e80a1" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;RstGenerator&lt;/code&gt; structure and populate it with the other lower level methods to finally build complete documents. This requires many options and tweaking, but you are not limited to snippets and can generate &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX documents&lt;/a&gt; too.</source>
          <target state="translated">&lt;code&gt;RstGenerator&lt;/code&gt; 구조를 작성 하고 다른 하위 레벨 메소드로 채워 최종 문서를 빌드 할 수도 있습니다. 여기에는 많은 옵션과 조정이 필요하지만 스 니펫에만 국한되지 않고 &lt;a href=&quot;https://en.wikipedia.org/wiki/LaTeX&quot;&gt;LaTeX 문서&lt;/a&gt; 도 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d188ca0a71a4ddf286451e750b7f8f446c7afd4" translate="yes" xml:space="preserve">
          <source>You can also make post requests with custom headers. This example sets &lt;code&gt;Content-Type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt; and uses a json object for the body</source>
          <target state="translated">사용자 정의 헤더를 사용하여 게시 요청을 할 수도 있습니다. 이 예에서는 &lt;code&gt;Content-Type&lt;/code&gt; 을 &lt;code&gt;application/json&lt;/code&gt; 으로 설정 하고 본문에 json 객체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a3c699b0079e23cf973cc2c8fc4fa4297a4a353a" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;#addEscaped,string,string&quot;&gt;addEscaped proc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7714759afec1609cb47128c6129eb72d509b791d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; together with &lt;em&gt;long string literals&lt;/em&gt; to create block comments:</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;#procedures-discard-statement&quot;&gt;폐기 문을&lt;/a&gt; 함께 &lt;em&gt;긴 문자열 리터럴&lt;/em&gt; 블록 주석을 만들 수 :</target>
        </trans-unit>
        <trans-unit id="97084a1faa8455f2406ffb033740ec1bfec72684" translate="yes" xml:space="preserve">
          <source>You can also use the convenience procedures called &lt;code&gt;milliseconds&lt;/code&gt;, &lt;code&gt;seconds&lt;/code&gt;, &lt;code&gt;minutes&lt;/code&gt;, &lt;code&gt;hours&lt;/code&gt;, &lt;code&gt;days&lt;/code&gt;, &lt;code&gt;months&lt;/code&gt;, and &lt;code&gt;years&lt;/code&gt;.</source>
          <target state="translated">또한라는 편리한 절차를 사용할 수 &lt;code&gt;milliseconds&lt;/code&gt; , &lt;code&gt;seconds&lt;/code&gt; , &lt;code&gt;minutes&lt;/code&gt; , &lt;code&gt;hours&lt;/code&gt; , &lt;code&gt;days&lt;/code&gt; , &lt;code&gt;months&lt;/code&gt; 및 &lt;code&gt;years&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac3b8da731d961b104b75c9c69b89b7521fd2d57" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered GC run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the GC and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="translated">프로그램 시작시 &lt;code&gt;GC_SetMaxPause&lt;/code&gt; 를 호출 하면 트리거 된 각 GC 실행이 &lt;code&gt;maxPause&lt;/code&gt; 시간 보다 오래 걸리지 않습니다 . 그러나 &lt;code&gt;new&lt;/code&gt; 호출 이 GC를 트리거 할 수 있으므로 &lt;code&gt;maxPause&lt;/code&gt; 시간 이 걸리므 로 작업이 균등하게 분배되지 않을 수 있습니다 (그리고 일반적입니다) .</target>
        </trans-unit>
        <trans-unit id="36174c6fb37927600d8d222f40bdfea256eae11d" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;GC_SetMaxPause&lt;/code&gt; at program startup and then each triggered garbage collector run tries to not take longer than &lt;code&gt;maxPause&lt;/code&gt; time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to &lt;code&gt;new&lt;/code&gt; can trigger the garbage collector and thus take &lt;code&gt;maxPause&lt;/code&gt; time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d868e08bf3946c7157b73bf733855e596866fd1c" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,HashSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409fedb343fbf4112734b304e207a767c54d9c6f" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized hash set, which will discard all its values. This might be more convenient than iterating over existing values and calling &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; on them. Example:</source>
          <target state="translated">이전에 초기화 된 해시 세트에서이 proc을 호출하면 모든 값이 삭제됩니다. 기존 값을 반복하고 &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl ()&lt;/a&gt; 을 호출하는 것보다 편리 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="b94d52a9f40f9d3456df4a8df7e7eb81a57a523b" translate="yes" xml:space="preserve">
          <source>You can call this proc on a previously initialized ordered hash set to discard its values. At the moment this is the only proc to remove elements from an ordered hash set. Example:</source>
          <target state="translated">이전에 초기화 된 순서화 된 해시 세트에서이 proc을 호출하여 해당 값을 버릴 수 있습니다. 현재 순서가 지정된 해시 세트에서 요소를 제거하는 유일한 방법입니다. 예:</target>
        </trans-unit>
        <trans-unit id="0c9f2bb20b3a8bb8c844c809d36ed14d3101dd69" translate="yes" xml:space="preserve">
          <source>You can create your own modules to be compatible with NimScript, and check &lt;a href=&quot;https://nimble.directory&quot;&gt;Nimble&lt;/a&gt; to search for third party modules that may work on NimScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a15a89c8527958b5725cea61c34db20ebbeafb" translate="yes" xml:space="preserve">
          <source>You can find examples of client/server communication in the idetools tests found in the &lt;a href=&quot;#test-suite&quot;&gt;Test suite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#test-suite&quot;&gt;테스트 스위트&lt;/a&gt; 에있는 idetools 테스트에서 클라이언트 / 서버 통신의 예를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d157a3f2f7ccab099eb8d42373b8eee643ec59fc" translate="yes" xml:space="preserve">
          <source>You can force the evaluation of a certain expression at compile-time by coercing it to a corresponding &lt;code&gt;static&lt;/code&gt; type:</source>
          <target state="translated">컴파일 타임에 특정 &lt;code&gt;static&lt;/code&gt; 표현식을 해당 정적 유형으로 강제 변환하여 강제로 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fbd4752c2519417bd7580131c8b434b52acfe30" translate="yes" xml:space="preserve">
          <source>You can generate HTML output through the convenience proc &lt;code&gt;rstToHtml&lt;/code&gt;, which provided an input string with rst markup returns a string with the generated HTML. The final output is meant to be embedded inside a full document you provide yourself, so it won't contain the usual &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; parts.</source>
          <target state="translated">편의 proc &lt;code&gt;rstToHtml&lt;/code&gt; 을 통해 HTML 출력을 생성 할 수 있습니다. 첫 번째 마크 업이있는 입력 문자열은 생성 된 HTML이있는 문자열을 리턴합니다. 최종 결과물은 사용자가 직접 제공 한 전체 문서에 포함되므로 일반적인 &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 부분이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="db428874c2fa95de5693e83c0a003d99482e25e7" translate="yes" xml:space="preserve">
          <source>You can import the &lt;a href=&quot;rstgen&quot;&gt;packages/docutils/rstgen module&lt;/a&gt; in your programs if you want to reuse the compiler's documentation generation procs.</source>
          <target state="translated">컴파일러의 문서 생성 &lt;a href=&quot;rstgen&quot;&gt;프로세스&lt;/a&gt; 를 재사용하려는 경우 프로그램에서 패키지 / docutils / rstgen 모듈 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26dd058177b18bbce0e1976ca233b4444e8bfaa9" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-do-notation&quot;&gt;do 표기법으로&lt;/a&gt; 임시 비교 프로세서를 인라인 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="efd5e3f984449b138f9e80e01560768d39a51ce8" translate="yes" xml:space="preserve">
          <source>You can inline adhoc comparison procs with the &lt;a href=&quot;manual_experimental#do-notation&quot;&gt;do notation&lt;/a&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ee456de749cd07f777df2dbfca526efcaac8de" translate="yes" xml:space="preserve">
          <source>You can make one overload matching with a constraint and one without, and the one with a constraint will have precedence, and so you can handle both cases differently.</source>
          <target state="translated">하나의 과부하가 구속 조건과 일치하고 다른 하나는 구속 조건없이 일치 할 수 있으며, 구속 조건이있는 것은 우선 순위를 가지므로 두 경우를 다르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a3e0b3e912356fd0eb7d1dfb77943e7ce6efb8f9" translate="yes" xml:space="preserve">
          <source>You can obtain the type of a given expression by constructing a &lt;code&gt;type&lt;/code&gt; value from it (in many other languages this is known as the &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; operator):</source>
          <target state="translated">주어진 식의 &lt;code&gt;type&lt;/code&gt; 값을 구성하여 주어진 식의 형식을 얻을 수 있습니다 (다른 많은 언어에서는 &lt;span id=&quot;typeof_1&quot;&gt;typeof&lt;/span&gt; 연산자 라고 함 ).</target>
        </trans-unit>
        <trans-unit id="fef0a20f2b09c4d9edfa4d02db9759a10ded5a2e" translate="yes" xml:space="preserve">
          <source>You can of course use GDB or Visual Studio to debug the compiler (via &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt;). However, there are also lots of procs that aid in debugging:</source>
          <target state="translated">물론 GDB 또는 Visual Studio를 사용하여 컴파일러를 디버깅 할 수 있습니다 ( &lt;code&gt;--debuginfo --lineDir:on&lt;/code&gt; 사용 ). 그러나 디버깅에 도움이되는 많은 프로세스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1dcc44050776a85f416ff13b391cd7420a7ea6" translate="yes" xml:space="preserve">
          <source>You can pass a block of statements as the last argument to a template following the special &lt;code&gt;:&lt;/code&gt; syntax:</source>
          <target state="translated">special &lt;code&gt;:&lt;/code&gt; 구문에 따라 템플릿에 마지막 인수로 문장 블록을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de9943ccdfa9f733cf2cde821140c6ff9f7f54f8" translate="yes" xml:space="preserve">
          <source>You can pass any additional options such as &lt;code&gt;-d:leanCompiler&lt;/code&gt; if you don't need certain features or &lt;code&gt;-d:debug --stacktrace:on --excessiveStackTrace --stackTraceMsgs&lt;/code&gt; for debugging the compiler. See also &lt;a href=&quot;intern#debugging-the-compiler&quot;&gt;Debugging the compiler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96758067b5a0f32b36e397740ce0787c73dee231" translate="yes" xml:space="preserve">
          <source>You can peek returned stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b44f09ab99fcb89435c32281cfd112526a80f" translate="yes" xml:space="preserve">
          <source>You can run peek operation to returned stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3235ae291f967014004169d6dd7919accac84950" translate="yes" xml:space="preserve">
          <source>You can then begin accepting connections using the &lt;code&gt;accept&lt;/code&gt; procedure.</source>
          <target state="translated">그런 다음 &lt;code&gt;accept&lt;/code&gt; 절차를 사용하여 연결 수락을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="229f698a5d2a1c44c1f9b047aaac16d395d3ac54" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; to &lt;em&gt;always&lt;/em&gt; add the &lt;code&gt;.discardable&lt;/code&gt; pragma since every name starts with the empty string prefix.</source>
          <target state="translated">모든 이름은 빈 문자열 접두어로 시작하므로 &lt;code&gt;#discardableprefix &quot;&quot;&lt;/code&gt; 를 사용 하여 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;.discardable&lt;/code&gt; pragma를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31a4b169ec568b104fcd414ec6ef62dff7bef87e" translate="yes" xml:space="preserve">
          <source>You can use NimScript to deploy to production, run tests, build projects, do benchmarks, generate documentation, and all kinds of DevOps/SysAdmin specific tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522e6e68fd4224a4e7b5d122bef202f975c7268d" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;fmt&lt;/code&gt; or the unary &lt;code&gt;&amp;amp;&lt;/code&gt; operator for formatting. The difference between them is subtle but important.</source>
          <target state="translated">당신도 사용할 수 있습니다 &lt;code&gt;fmt&lt;/code&gt; 또는 단항 &lt;code&gt;&amp;amp;&lt;/code&gt; 포맷에 대한 연산자를. 그들 사이의 차이점은 미묘하지만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2385979f1e2cb34c5a4d63322747823dfb72c102" translate="yes" xml:space="preserve">
          <source>You can use the iterators &lt;a href=&quot;#pairs.i,CountTable%5BA%5D&quot;&gt;pairs&lt;/a&gt;, &lt;a href=&quot;#keys.i,CountTable%5BA%5D&quot;&gt;keys&lt;/a&gt;, and &lt;a href=&quot;#values.i,CountTable%5BA%5D&quot;&gt;values&lt;/a&gt; to iterate over &lt;code&gt;t&lt;/code&gt; in the sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad705944ac8aba7f5b1ba7a79096cb62ea1d3012" translate="yes" xml:space="preserve">
          <source>You can use the iterators &lt;a href=&quot;#pairs.i,CountTableRef%5BA%5D&quot;&gt;pairs&lt;/a&gt;, &lt;a href=&quot;#keys.i,CountTableRef%5BA%5D&quot;&gt;keys&lt;/a&gt;, and &lt;a href=&quot;#values.i,CountTableRef%5BA%5D&quot;&gt;values&lt;/a&gt; to iterate over &lt;code&gt;t&lt;/code&gt; in the sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6db4f8bc927328b58f5dd31eba7cffedc758cc6" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</source>
          <target state="translated">이를 Nim의 추상 구문 트리를 탐색하고 특정 표현 / 문을 나타 내기 위해 어떤 종류의 노드를 만들어야하는지 알아내는 도구로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddf568174dd61d7a80305dc0a3e7df19330c174" translate="yes" xml:space="preserve">
          <source>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</source>
          <target state="translated">예제 출력을 작성한 다음 스 니펫을 매크로에 복사하여 매크로를 더 빨리 작성하는 도구로 이것을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c2d59459a913b746b98925a2a3fc29f24dc533" translate="yes" xml:space="preserve">
          <source>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">이 절차를 사용하여 분기 조건을 꾸밀 수 있습니다. 특정 플랫폼에서는 프로세서가 어떤 분기를 실행할지 더 잘 예측할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a6cd8fbf55f404670383a401ae7b6bcd1b50acf2" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34048e340fae2cd8a9b340afd693e3e0e20b294" translate="yes" xml:space="preserve">
          <source>You can use this proc to transform the elements from a set. Example:</source>
          <target state="translated">이 proc을 사용하여 세트에서 요소를 변환 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a91b944ee43ceb5d18d013c159338cbb935b2855" translate="yes" xml:space="preserve">
          <source>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</source>
          <target state="translated">이 템플릿을 사용하여 분기 조건을 꾸밀 수 있습니다. 특정 플랫폼에서는 프로세서가 어떤 분기를 실행할지 더 잘 예측할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="9e058274075398cc26b01a6b7ed794f3e1a26b4c" translate="yes" xml:space="preserve">
          <source>You can use this to build your own syntax highlighting, check this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786f4a9c940aa7c5a0838e96623ddf57a6935a80" translate="yes" xml:space="preserve">
          <source>You can verify this yourself adding the line &lt;code&gt;echo source&lt;/code&gt; somewhere at the end of the macro and compiling the program. Another difference is that instead of calling the usual &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; to abort (which we could still call) this version calls the &lt;a href=&quot;macros#error&quot;&gt;error proc&lt;/a&gt; (line 14). The &lt;code&gt;error&lt;/code&gt; proc has the same behavior as &lt;code&gt;quit&lt;/code&gt; but will dump also the source and file line information where the error happened, making it easier for the programmer to find where compilation failed. In this situation it would point to the line invoking the macro, but &lt;strong&gt;not&lt;/strong&gt; the line of &lt;code&gt;data.cfg&lt;/code&gt; we are processing, that's something the macro itself would need to control.</source>
          <target state="translated">매크로 끝에 어딘가에 라인 &lt;code&gt;echo source&lt;/code&gt; 추가 하고 프로그램을 컴파일하여 직접 확인할 수 있습니다 . 또 다른 차이점은 일반적인 &lt;a href=&quot;system#quit&quot;&gt;quit proc&lt;/a&gt; 을 중단 ( 대신 호출 할 수 있음)하는 대신 &lt;a href=&quot;macros#error&quot;&gt;오류 proc&lt;/a&gt; (라인 14)을 호출한다는 것 입니다. &lt;code&gt;error&lt;/code&gt; 로 PROC는 같은 동작을 가지고 &lt;code&gt;quit&lt;/code&gt; 뿐만 아니라 오류가 발생 소스 및 파일 라인 정보를 덤프, 쉽게 컴파일이 실패 곳 프로그래머가 찾을 수 있도록. 이 상황에서는 매크로를 호출하는 행을 &lt;code&gt;data.cfg&lt;/code&gt; 만 처리 하는 data.cfg 행은 가리 키지 &lt;strong&gt;않습니다&lt;/strong&gt; . 즉, 매크로 자체가 제어해야하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92f1ea59a6005fb17221b573220c7eb96afe4382" translate="yes" xml:space="preserve">
          <source>You cannot perform peek/write/setOption operations to this stream. Use &lt;a href=&quot;#peekableErrorStream,Process&quot;&gt;peekableErrorStream proc&lt;/a&gt; if you need to peek stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a55706dc42f105735697061fa660a19336cf0e" translate="yes" xml:space="preserve">
          <source>You cannot perform peek/write/setOption operations to this stream. Use &lt;a href=&quot;#peekableOutputStream,Process&quot;&gt;peekableOutputStream proc&lt;/a&gt; if you need to peek stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1927317fdc7e6a2effb5166b6eaa7c316bb014" translate="yes" xml:space="preserve">
          <source>You may add a constraint to the resulting type to trigger a compile-time error if the expression doesn't have the expected type:</source>
          <target state="translated">식에 예상 형식이없는 경우 결과 형식에 제약 조건을 추가하여 컴파일 타임 오류를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8ec20025fee9a409388762110a23a28945941" translate="yes" xml:space="preserve">
          <source>You may also find it useful to use this &lt;a href=&quot;https://github.com/dom96/prometheus&quot;&gt;prometheus package&lt;/a&gt; which will log the pending futures into prometheus, allowing you to analyse them via a nice graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f30ee997aa1c1a9a827cafb053cce15b31f0463" translate="yes" xml:space="preserve">
          <source>You may specify a callback procedure to be called during an HTTP request. This callback will be executed every second with information about the progress of the HTTP request.</source>
          <target state="translated">HTTP 요청 중에 호출 할 콜백 프로 시저를 지정할 수 있습니다. 이 콜백은 1 초마다 HTTP 요청 진행에 대한 정보와 함께 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5dd8d98d03acf607976a61f844d04f595a458ee9" translate="yes" xml:space="preserve">
          <source>You must create a new SSL context with the &lt;code&gt;newContext&lt;/code&gt; function defined in the &lt;code&gt;net&lt;/code&gt; module. You may then call &lt;code&gt;wrapSocket&lt;/code&gt; on your socket using the newly created SSL context to get an SSL socket.</source>
          <target state="translated">&lt;code&gt;net&lt;/code&gt; 모듈에 정의 된 &lt;code&gt;newContext&lt;/code&gt; 함수를 사용하여 새 SSL 컨텍스트를 작성해야합니다 . 그런 다음 새로 작성된 SSL 컨텍스트를 사용하여 소켓에서 &lt;code&gt;wrapSocket&lt;/code&gt; 을 호출 하여 SSL 소켓을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536dd70e47958cfa1309fb9e5c1a1f72e1c1ece3" translate="yes" xml:space="preserve">
          <source>You need to &lt;a href=&quot;#close,Process&quot;&gt;close&lt;/a&gt; the process when done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f02dcaa349af52efc752e41b14a80f4aa7a8f58" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;code&gt;config&lt;/code&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;code&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36e9e49af8f68c7f3865ace300bab1eeae94fdd" translate="yes" xml:space="preserve">
          <source>You need to call this before using a &lt;code&gt;RstGenerator&lt;/code&gt; with any other procs in this module. Pass a non &lt;code&gt;nil&lt;/code&gt;&lt;code&gt;StringTableRef&lt;/code&gt; value as &lt;em&gt;config&lt;/em&gt; with parameters used by the HTML output generator. If you don't know what to use, pass the results of the &lt;em&gt;defaultConfig() &amp;lt;#defaultConfig&amp;gt;_&lt;/em&gt; proc.</source>
          <target state="translated">이 모듈의 다른 &lt;code&gt;RstGenerator&lt;/code&gt; 와 함께 RstGenerator 를 사용하기 전에 이것을 호출해야 합니다. HTML 출력 생성기에서 사용하는 매개 변수를 사용하여 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;StringTableRef&lt;/code&gt; 값을 &lt;em&gt;구성&lt;/em&gt; 으로 전달하십시오. 무엇을 사용해야할지 모르는 경우 &lt;em&gt;defaultConfig () &amp;lt;#defaultConfig&amp;gt; _&lt;/em&gt; proc 의 결과를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="e99014be72901d30cf9903b89e767bc47ddd9adc" translate="yes" xml:space="preserve">
          <source>You need to make sure that &lt;code&gt;fromAddr&lt;/code&gt; and &lt;code&gt;toAddrs&lt;/code&gt; don't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628b0c494a0fc9a208f986729cf9af920542035a" translate="yes" xml:space="preserve">
          <source>You need to make sure that &lt;code&gt;mSubject&lt;/code&gt;, &lt;code&gt;mTo&lt;/code&gt; and &lt;code&gt;mCc&lt;/code&gt; don't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1815471bce16da5553a9fd3eceb5099d8be523e4" translate="yes" xml:space="preserve">
          <source>You need to make sure that the &lt;code&gt;url&lt;/code&gt; doesn't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768d3b1f449e8e44f77a2b81c1991631053c4aa0" translate="yes" xml:space="preserve">
          <source>You need to make sure that the message &lt;code&gt;m&lt;/code&gt; doesn't contain any newline characters. Failing to do so will raise &lt;code&gt;AssertionDefect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450b5c3a1da9d0e1fa5bb777f9cd543e75eb7cd9" translate="yes" xml:space="preserve">
          <source>You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aec2725098b8ffc1761bd9c7f7b9f1682bf6e2" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="translated">이전에는 &lt;a href=&quot;#setIndexTerm&quot;&gt;setIndexTerm ()&lt;/a&gt; proc 을 사용하여 색인에 항목을 추가해야합니다 . 색인이 비어 있으면 파일이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="441987ce595f159ce24b92f3d1cf8ed65cb9679a" translate="yes" xml:space="preserve">
          <source>You previously need to add entries to the index with the &lt;a href=&quot;#setIndexTerm,RstGenerator,string,string,string,string,string&quot;&gt;setIndexTerm()&lt;/a&gt; proc. If the index is empty the file won't be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737fc4006bdf416ca1aa1927d2320a57138985ef" translate="yes" xml:space="preserve">
          <source>You should prefer to call &lt;code&gt;acceptRequest&lt;/code&gt; instead with a custom server loop so that you're in control over the error handling and logging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d047869868e7ac2dd137df50888c63412be12d0" translate="yes" xml:space="preserve">
          <source>You should send this before sending your HTML page, for example.</source>
          <target state="translated">예를 들어 HTML 페이지를 보내기 전에이를 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="3d103567ee18cb5218c37709ddcec0d6177298f4" translate="yes" xml:space="preserve">
          <source>You will also have to compile with &lt;code&gt;ssl&lt;/code&gt; defined like so: &lt;code&gt;nim c -d:ssl ...&lt;/code&gt;.</source>
          <target state="translated">또한 컴파일해야합니다 &lt;code&gt;ssl&lt;/code&gt; 과 같이 정의 : &lt;code&gt;nim c -d:ssl ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9c34b8df4c5ac422a24f59076119b6a4247781a" translate="yes" xml:space="preserve">
          <source>Zero and negative numbers are not a power of two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eb3bc3ec64f5874a762feb41843df520cfd18d" translate="yes" xml:space="preserve">
          <source>Zero and negative numbers get rounded up to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058062ffe3d7415398c63db4c4c474b3de0c89a9" translate="yes" xml:space="preserve">
          <source>Zero or One</source>
          <target state="translated">0 또는 1</target>
        </trans-unit>
        <trans-unit id="42ff50143f9dda79f19f7750e8d1e6ebfb6a9117" translate="yes" xml:space="preserve">
          <source>Zero or more</source>
          <target state="translated">0 이상</target>
        </trans-unit>
        <trans-unit id="225c32bbd814f50677575343a2af6f98ab452cb4" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;code&gt;E&lt;/code&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0e6558a1175af4a938d82662dd24b2fa417681" translate="yes" xml:space="preserve">
          <source>Zero or more: Apply expression &lt;em&gt;E&lt;/em&gt; repeatedly to match the text ahead, as long as it succeeds. Consume the matched text (if any). Always indicate success.</source>
          <target state="translated">0 이상 : 성공하는 한 텍스트 &lt;em&gt;E&lt;/em&gt; 와 일치하도록 식 &lt;em&gt;E를&lt;/em&gt; 반복해서 적용 합니다. 일치하는 텍스트를 사용하십시오 (있는 경우). 항상 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e13005fad6e40191c809667ff4527563540506f8" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;code&gt;E&lt;/code&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a721c45ae571dec5e2aa89e2c4b85966c95f70" translate="yes" xml:space="preserve">
          <source>Zero or one: If expression &lt;em&gt;E&lt;/em&gt; matches the text ahead, consume it. Always indicate success.</source>
          <target state="translated">0 또는 1 : 식 &lt;em&gt;E&lt;/em&gt; 가 앞의 텍스트와 일치하면 소비하십시오. 항상 성공을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2af78455018bdfce1224f9a413429c8d1cf682b3" translate="yes" xml:space="preserve">
          <source>Zero value for durations. Useful for comparisons.</source>
          <target state="translated">지속 기간에 대한 값이 없습니다. 비교에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6060a4786b6be76ff108ebceec44d2daa4c15f06" translate="yes" xml:space="preserve">
          <source>Zero-indexed counting have two shortcuts &lt;code&gt;..&amp;lt;&lt;/code&gt; and &lt;code&gt;..^&lt;/code&gt; to simplify counting to one less than the higher index:</source>
          <target state="translated">제로 인덱싱 카운팅에는 더 높은 인덱스보다 1보다 적은 카운팅을 단순화하기 위해 두 개의 바로 가기 &lt;code&gt;..&amp;lt;&lt;/code&gt; 및 &lt;code&gt;..^&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c04b19973470d92242f49b06eef1b73f56d44e" translate="yes" xml:space="preserve">
          <source>Zero:</source>
          <target state="translated">Zero:</target>
        </trans-unit>
        <trans-unit id="8b89c7935e4227693c26bb38dab6ce4cc59d630c" translate="yes" xml:space="preserve">
          <source>[] proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54bc76320ca46951b95cdd0ab681cbf780a7c2e" translate="yes" xml:space="preserve">
          <source>[]= proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be19fd422dffae7a0636938f97b2aa24b5cb13a9" translate="yes" xml:space="preserve">
          <source>[default(T), ...]</source>
          <target state="translated">[기본 (T), ...]</target>
        </trans-unit>
        <trans-unit id="725341cb2d0f3c779b1327977070fadc20557a50" translate="yes" xml:space="preserve">
          <source>[deprecated] Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c1c85e428b2e6ebcfe53d58ea3210e8ab6cc25" translate="yes" xml:space="preserve">
          <source>^ proc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371ecc3918ac9832694f112b1cde6b20c8008173" translate="yes" xml:space="preserve">
          <source>`$`:</source>
          <target state="translated">`$`:</target>
        </trans-unit>
        <trans-unit id="11ee73713a5957d1c36553f7b429779054fa253e" translate="yes" xml:space="preserve">
          <source>`%`:</source>
          <target state="translated">`%`:</target>
        </trans-unit>
        <trans-unit id="41545b1430077baa11ec6fa83c225da8abe403ed" translate="yes" xml:space="preserve">
          <source>`&amp;amp;`:</source>
          <target state="translated">`&amp;amp;`:</target>
        </trans-unit>
        <trans-unit id="d8f7ea3a6b1c4c48cd7a700315a88ee7bc6a687f" translate="yes" xml:space="preserve">
          <source>`&amp;lt;=`:</source>
          <target state="translated">`&amp;lt;=`:</target>
        </trans-unit>
        <trans-unit id="976d0279af4eea7fb942f226e53f3f50881762b8" translate="yes" xml:space="preserve">
          <source>`&amp;lt;`:</source>
          <target state="translated">`&amp;lt;`:</target>
        </trans-unit>
        <trans-unit id="847e31187f83a3335456a3f40b8940007dd68407" translate="yes" xml:space="preserve">
          <source>`*=`:</source>
          <target state="translated">`*=`:</target>
        </trans-unit>
        <trans-unit id="5bc553896438f181cc7995e4eb398d952e01fdf4" translate="yes" xml:space="preserve">
          <source>`*`:</source>
          <target state="translated">`*`:</target>
        </trans-unit>
        <trans-unit id="e3953df9a5db82ff4ece5adbb279d2c461636172" translate="yes" xml:space="preserve">
          <source>`+=`:</source>
          <target state="translated">`+=`:</target>
        </trans-unit>
        <trans-unit id="44b4104641bfde4f4384922de79c977971467dcb" translate="yes" xml:space="preserve">
          <source>`+`:</source>
          <target state="translated">`+`:</target>
        </trans-unit>
        <trans-unit id="0ff5ae87fb15c748cc5a95c88a16a2e7a8fbceb0" translate="yes" xml:space="preserve">
          <source>`-=`:</source>
          <target state="translated">`-=`:</target>
        </trans-unit>
        <trans-unit id="5e0d3b10f837f56a00e6f74eaea4d2e410c02da6" translate="yes" xml:space="preserve">
          <source>`-`:</source>
          <target state="translated">`-`:</target>
        </trans-unit>
        <trans-unit id="6b2df1d06dbd13007c498d563bb9319e30e79789" translate="yes" xml:space="preserve">
          <source>`/`:</source>
          <target state="translated">`/`:</target>
        </trans-unit>
        <trans-unit id="a702c9636ffdac06c22c5fcaccae945de70590ef" translate="yes" xml:space="preserve">
          <source>`==`:</source>
          <target state="translated">`==`:</target>
        </trans-unit>
        <trans-unit id="c532728e4314439eba81ce91aae1705cd2f0d283" translate="yes" xml:space="preserve">
          <source>`??`:</source>
          <target state="translated">`??`:</target>
        </trans-unit>
        <trans-unit id="4d6cdbc688fe70cc00178dec81d57b0a392370ef" translate="yes" xml:space="preserve">
          <source>`[]=`:</source>
          <target state="translated">`[]=`:</target>
        </trans-unit>
        <trans-unit id="1be0b27d1fc97bd5cb1ec8d4ebfb2a55addb15f2" translate="yes" xml:space="preserve">
          <source>`[]`:</source>
          <target state="translated">`[]`:</target>
        </trans-unit>
        <trans-unit id="586638f457645338d33d63761281c221a23a1f55" translate="yes" xml:space="preserve">
          <source>`div`:</source>
          <target state="translated">`div`:</target>
        </trans-unit>
        <trans-unit id="c381745b80f7dcd1a8969b63f332aae419494122" translate="yes" xml:space="preserve">
          <source>`mod`:</source>
          <target state="translated">`mod`:</target>
        </trans-unit>
        <trans-unit id="7749321cac8293dfb4116f22eb6fcf0c9d4c4765" translate="yes" xml:space="preserve">
          <source>`shl`:</source>
          <target state="translated">`shl`:</target>
        </trans-unit>
        <trans-unit id="fdf5b59f33b1c6600da8344413c66e95fe677d26" translate="yes" xml:space="preserve">
          <source>`shr`:</source>
          <target state="translated">`shr`:</target>
        </trans-unit>
        <trans-unit id="1017c901abb02f8893c41373551fbb054bdde2c5" translate="yes" xml:space="preserve">
          <source>`|*|`:</source>
          <target state="translated">`|*|`:</target>
        </trans-unit>
        <trans-unit id="121541bf72dab89f27211a54be372b6f9975dc37" translate="yes" xml:space="preserve">
          <source>`|+|`:</source>
          <target state="translated">`|+|`:</target>
        </trans-unit>
        <trans-unit id="37999d7d1ef6f471b5c0d50acf800904aa2fa893" translate="yes" xml:space="preserve">
          <source>`|-|`:</source>
          <target state="translated">`|-|`:</target>
        </trans-unit>
        <trans-unit id="c733403d0e712203c63fa82e7f7135997be2918a" translate="yes" xml:space="preserve">
          <source>`|abs|`:</source>
          <target state="translated">`|abs|`:</target>
        </trans-unit>
        <trans-unit id="326c5eeec777158d2150463ba65036b7c861a93d" translate="yes" xml:space="preserve">
          <source>`|div|`:</source>
          <target state="translated">`|div|`:</target>
        </trans-unit>
        <trans-unit id="73a677eb50a90a7dc1cd484584bc13523f3e0505" translate="yes" xml:space="preserve">
          <source>`|mod|`:</source>
          <target state="translated">`|mod|`:</target>
        </trans-unit>
        <trans-unit id="3260d07b4b25223a8645751735794410787c060e" translate="yes" xml:space="preserve">
          <source>`~`:</source>
          <target state="translated">`~`:</target>
        </trans-unit>
        <trans-unit id="e5176dbef42a406c169d587b0655624ce1159b6a" translate="yes" xml:space="preserve">
          <source>a &amp;amp; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37f6cc195c1e8086901c5a7d04cf29e2f0b24fc" translate="yes" xml:space="preserve">
          <source>a &amp;lt; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bcb53e7fa75d08af319378fe95ba44e0341af6" translate="yes" xml:space="preserve">
          <source>a * b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e17da83cb99df2cd97660136aec7f67a2a9d641" translate="yes" xml:space="preserve">
          <source>a + b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278f96e8954808de5c6166fde0ae0b15f4876a3c" translate="yes" xml:space="preserve">
          <source>a - b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ca1dd1bea0541c6a3a1ff782308757b21ca927" translate="yes" xml:space="preserve">
          <source>a .. b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849f46055dbfb5ab989b68969bf5c16c1eeeda04" translate="yes" xml:space="preserve">
          <source>a ..&amp;lt; b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e6b28f1c2dc315223c6c96b4dcd47b8339bd9c" translate="yes" xml:space="preserve">
          <source>a ..^ b</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6181759dbfbc1d13cea8897bba860e1cd1f1b7f" translate="yes" xml:space="preserve">
          <source>a channel for thread communication</source>
          <target state="translated">스레드 통신을위한 채널</target>
        </trans-unit>
        <trans-unit id="ceb1c4b07f128179a3a629f3d8297730fe20d8c2" translate="yes" xml:space="preserve">
          <source>a color stored as RGB</source>
          <target state="translated">RGB로 저장된 색상</target>
        </trans-unit>
        <trans-unit id="d0b439a1db8b1636f87a882db4e959779e8dfe6b" translate="yes" xml:space="preserve">
          <source>a compiled regular expression</source>
          <target state="translated">컴파일 된 정규식</target>
        </trans-unit>
        <trans-unit id="446a499c83ee189e881728b9614bb1c610b42820" translate="yes" xml:space="preserve">
          <source>a complex number, consisting of a real and an imaginary part</source>
          <target state="translated">실수와 허수로 구성된 복소수</target>
        </trans-unit>
        <trans-unit id="d4c0dd8cbb911234aafd65e42ebe2e16d8dd9a13" translate="yes" xml:space="preserve">
          <source>a convenience proc that runs the &lt;em&gt;command&lt;/em&gt;, grabs all its output and exit code and returns both.</source>
          <target state="translated">&lt;em&gt;명령&lt;/em&gt; 을 실행하고 모든 출력 및 종료 코드를 잡고 둘 다 리턴 하는 편리한 proc .</target>
        </trans-unit>
        <trans-unit id="3d1d312821fd56659d05a796c0721e1a9ac1ecd1" translate="yes" xml:space="preserve">
          <source>a convenience procedure for:</source>
          <target state="translated">다음에 대한 편의 절차 :</target>
        </trans-unit>
        <trans-unit id="697ab90ee8ea779b4e9d7e4d582cc0de7bbcb857" translate="yes" xml:space="preserve">
          <source>a data flow variable</source>
          <target state="translated">데이터 흐름 변수</target>
        </trans-unit>
        <trans-unit id="236302a21803b39674181eb1c1e1dad827d987da" translate="yes" xml:space="preserve">
          <source>a distinct string type that is &lt;span id=&quot;tainted_1&quot;&gt;tainted&lt;/span&gt;, see &lt;a href=&quot;manual#taint-mode&quot;&gt;taint mode&lt;/a&gt; for details. It is an alias for &lt;code&gt;string&lt;/code&gt; if the taint mode is not turned on.</source>
          <target state="translated">하는 고유 한 문자열 유형 &lt;span id=&quot;tainted_1&quot;&gt;오염은&lt;/span&gt; 참조 &lt;a href=&quot;manual#taint-mode&quot;&gt;더러운 모드에&lt;/a&gt; 대한 자세한 내용을. 오염 모드가 켜져 있지 않으면 &lt;code&gt;string&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="24c60b77672236b3310392791c9159e7da691559" translate="yes" xml:space="preserve">
          <source>a doubly linked list</source>
          <target state="translated">이중 연결 목록</target>
        </trans-unit>
        <trans-unit id="92f8d2cb7eddeae18a8926cceebe9ab14e904d46" translate="yes" xml:space="preserve">
          <source>a doubly linked ring</source>
          <target state="translated">이중 연결 고리</target>
        </trans-unit>
        <trans-unit id="9667a5641fafbc88c7babe208bd484588610acb6" translate="yes" xml:space="preserve">
          <source>a handle that can be</source>
          <target state="translated">될 수있는 손잡이</target>
        </trans-unit>
        <trans-unit id="c673f94589cd025a94f4df85ea7cbc620e46a6b6" translate="yes" xml:space="preserve">
          <source>a handle that can be used to get a row's column text on demand</source>
          <target state="translated">요청시 행의 열 텍스트를 얻는 데 사용할 수있는 핸들</target>
        </trans-unit>
        <trans-unit id="9e35a0ed419e04673fabc57db7de755c9a5158d9" translate="yes" xml:space="preserve">
          <source>a handle to a dynamically loaded library</source>
          <target state="translated">동적으로로드 된 라이브러리에 대한 핸들</target>
        </trans-unit>
        <trans-unit id="727eb5fb1890186a7705b301c37bcb5a3a011c04" translate="yes" xml:space="preserve">
          <source>a hash value; hash tables using these values should always have a size of a power of two and can use the &lt;code&gt;and&lt;/code&gt; operator instead of &lt;code&gt;mod&lt;/code&gt; for truncation of the hash value.</source>
          <target state="translated">해시 값; 이러한 값을 사용하는 해시 테이블의 크기는 항상 2의 거듭 제곱이어야 하며 해시 값을 자르기 위해 &lt;code&gt;mod&lt;/code&gt; 대신 &lt;code&gt;and&lt;/code&gt; 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb7c3a20e1c58ee4786768f999120ebe9f74132e" translate="yes" xml:space="preserve">
          <source>a identifier for the prepared queries</source>
          <target state="translated">준비된 쿼리의 식별자</target>
        </trans-unit>
        <trans-unit id="e15266dcad2adbaa4f2ad63108ef729cf76beda5" translate="yes" xml:space="preserve">
          <source>a node a doubly linked list consists of</source>
          <target state="translated">이중 연결리스트로 구성된 노드</target>
        </trans-unit>
        <trans-unit id="5ba782577875c08c01d890dce7e8dd4aecffd0bd" translate="yes" xml:space="preserve">
          <source>a node a singly linked list consists of</source>
          <target state="translated">단독으로 연결된 목록으로 구성된 노드</target>
        </trans-unit>
        <trans-unit id="c5092df10e1c3e85e7d83e22f3d8ff19de9aee98" translate="yes" xml:space="preserve">
          <source>a parallel section can be used to execute a block in parallel. &lt;code&gt;body&lt;/code&gt; has to be in a DSL that is a particular subset of the language. Please refer to the manual for further information.</source>
          <target state="translated">병렬 섹션은 블록을 병렬로 실행하는 데 사용될 수 있습니다. &lt;code&gt;body&lt;/code&gt; 는 언어의 특정 하위 집합 인 DSL에 있어야합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b464620548b26647c2039d50b3534a202b2e5405" translate="yes" xml:space="preserve">
          <source>a rational number, consisting of a numerator and denominator</source>
          <target state="translated">분자와 분모로 구성된 유리수</target>
        </trans-unit>
        <trans-unit id="69540ea7fe9bd9fdc5e24939d260de6bfcf3083e" translate="yes" xml:space="preserve">
          <source>a row in a CSV file</source>
          <target state="translated">CSV 파일의 행</target>
        </trans-unit>
        <trans-unit id="a5ec37625145ddf6373e511cf4b862af7fe73b7a" translate="yes" xml:space="preserve">
          <source>a row of a dataset. NULL database values will be converted to nil.</source>
          <target state="translated">데이터 세트의 행 NULL 데이터베이스 값은 nil로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a9a46cf5d23594a7585e289276bf5ca00498ca" translate="yes" xml:space="preserve">
          <source>a set of files and directories from the &lt;a href=&quot;ssl_certs&quot;&gt;ssl_certs&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9fa41fb39e8c2391daf5b73b38611f05be5128" translate="yes" xml:space="preserve">
          <source>a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.</source>
          <target state="translated">'..'와 '^'사이에 공백이 필요하다는 일반적인 문제를 피하기 위해 '.. ^'에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="302bd8c00ad8f3e86bc63558821e98698620a746" translate="yes" xml:space="preserve">
          <source>a shortcut for 'a .. (when b is BackwardsIndex: succ(b) else: pred(b))'.</source>
          <target state="translated">'a ..에 대한 지름길 (b가 BackwardsIndex 인 경우 : succ (b) else : pred (b))'.</target>
        </trans-unit>
        <trans-unit id="440e2c2edfe2d93548694539384ebaec70e26a08" translate="yes" xml:space="preserve">
          <source>a shorthand for &lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;echo(errormsg); quit(errorcode)&lt;/code&gt; 의 줄임말 ; quit (errorcode) .</target>
        </trans-unit>
        <trans-unit id="f1ea92069e80f9a3e02b527138ba54f9fbd0ee56" translate="yes" xml:space="preserve">
          <source>a simple barrier to wait for all spawn'ed tasks. If you need more elaborate waiting, you have to use an explicit barrier.</source>
          <target state="translated">스폰 된 모든 작업을 기다리는 간단한 장벽. 좀 더 정교한 대기가 필요한 경우, 명확한 장벽을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c6d3caa14558753d210d77ea2d36fd6a1513d28" translate="yes" xml:space="preserve">
          <source>a single backslash</source>
          <target state="translated">단일 백 슬래시</target>
        </trans-unit>
        <trans-unit id="837f51c3591f8b2d4452f90b5ddbc53e912a5c22" translate="yes" xml:space="preserve">
          <source>a singly linked list</source>
          <target state="translated">단독으로 연결된 목록</target>
        </trans-unit>
        <trans-unit id="216912de21be007513f346fea51719c0bc9710bb" translate="yes" xml:space="preserve">
          <source>a singly linked ring</source>
          <target state="translated">단일 연결 고리</target>
        </trans-unit>
        <trans-unit id="fca33daf462dcc183c16697e01011fdb26d89e19" translate="yes" xml:space="preserve">
          <source>a standard ASCII identifier: &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</source>
          <target state="translated">표준 ASCII 식별자 : &lt;code&gt;[a-zA-Z_][a-zA-Z_0-9]*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e234deb8ba8a81933c4f81a3052a4d28e6cd985e" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;code&gt;MemFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d78f86643008d4db0ec1bb8602ad193b2839d13" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;File&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 을 캡슐화하는 스트림&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c6c55b76ac43aa1bd1841c6cca1606179fd844" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a &lt;em&gt;MemFile&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MemFile&lt;/em&gt; 을 캡슐화하는 스트림&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86e6a991d0bca4656b36ada97342374f6e9a343" translate="yes" xml:space="preserve">
          <source>a stream that encapsulates a string</source>
          <target state="translated">문자열을 캡슐화하는 스트림</target>
        </trans-unit>
        <trans-unit id="43bd8c81bc8b1cc0db1629419cf49867fb9cbc47" translate="yes" xml:space="preserve">
          <source>a string that describes the application type. Possible values: &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;.</source>
          <target state="translated">응용 프로그램 유형을 설명하는 문자열 가능한 값은 &quot;console&quot;, &quot;gui&quot;, &quot;lib&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="78097f72ab7bfacc92af44cb293dd8fef3e05b08" translate="yes" xml:space="preserve">
          <source>a string that describes the host CPU. Possible values: &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot;, &quot;mips64el&quot;, &quot;riscv64&quot;.</source>
          <target state="translated">호스트 CPU를 설명하는 문자열 가능한 값 : &quot;i386&quot;, &quot;alpha&quot;, &quot;powerpc&quot;, &quot;powerpc64&quot;, &quot;powerpc64el&quot;, &quot;sparc&quot;, &quot;amd64&quot;, &quot;mips&quot;, &quot;mipsel&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;mips64&quot; , &quot;mips64el&quot;, &quot;riscv64&quot;.</target>
        </trans-unit>
        <trans-unit id="2904b6a5abddd9d8deb65901f6588cd84e307512" translate="yes" xml:space="preserve">
          <source>a string that describes the host operating system. Possible values: &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;.</source>
          <target state="translated">호스트 운영 체제를 설명하는 문자열 가능한 값은 &quot;windows&quot;, &quot;macosx&quot;, &quot;linux&quot;, &quot;netbsd&quot;, &quot;freebsd&quot;, &quot;openbsd&quot;, &quot;solaris&quot;, &quot;aix&quot;, &quot;haiku&quot;, &quot;standalone&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="5c43be61e01495675e75b60bd73d6e649f9ba570" translate="yes" xml:space="preserve">
          <source>a superset of datatypes that might be supported.</source>
          <target state="translated">지원 될 수있는 데이터 유형의 상위 집합</target>
        </trans-unit>
        <trans-unit id="a2c632390784343f0815794eeb84cfdac8c1f1ba" translate="yes" xml:space="preserve">
          <source>a value greater than zero, if &lt;code&gt;x &amp;gt; y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5cc52883790725ee03147e0be56b3cd467ca14" translate="yes" xml:space="preserve">
          <source>a value less than zero, if &lt;code&gt;x &amp;lt; y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb8dc66c4591d977b2d998365743f6aaaf4b288" translate="yes" xml:space="preserve">
          <source>a[^x]</source>
          <target state="translated">a[^x]</target>
        </trans-unit>
        <trans-unit id="a89d23d5633110676b6f5518d74dfd438ac8770d" translate="yes" xml:space="preserve">
          <source>abs:</source>
          <target state="translated">abs:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
