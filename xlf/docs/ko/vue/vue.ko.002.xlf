<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="d4d360c1c9029915eaf8eaa012bcc1434524bc17" translate="yes" xml:space="preserve">
          <source>Above, you&amp;rsquo;ll see that we can use &lt;code&gt;v-bind&lt;/code&gt; to dynamically pass props. This is especially useful when you don&amp;rsquo;t know the exact content you&amp;rsquo;re going to render ahead of time, like when &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sbLgr0ad&quot;&gt;fetching posts from an API&lt;/a&gt;.</source>
          <target state="translated">위에서 &lt;code&gt;v-bind&lt;/code&gt; 를 사용 하여 소품을 동적으로 전달할 수 있음을 알 수 있습니다 . &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/sbLgr0ad&quot;&gt;API에서 게시물을 가져올&lt;/a&gt; 때와 같이 미리 렌더링 할 정확한 콘텐츠를 모르는 경우 특히 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="ca8e6064c2333672a4be1482e62c50361ebd7fc4" translate="yes" xml:space="preserve">
          <source>Above, you'll see that we can use &lt;code&gt;v-bind&lt;/code&gt; to dynamically pass props. This is especially useful when you don't know the exact content you're going to render ahead of time.</source>
          <target state="translated">위에서 &lt;code&gt;v-bind&lt;/code&gt; 를 사용 하여 props를 동적으로 전달할 수 있음을 알 수 있습니다 . 이는 미리 렌더링 할 정확한 콘텐츠를 모르는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1385b7f0b7cff03dc6fd2497bb9a00e4dff7f57" translate="yes" xml:space="preserve">
          <source>Absent enumerated attr</source>
          <target state="translated">열거 된 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e2fa59b1775dcf414f85f1c2616538302393cce" translate="yes" xml:space="preserve">
          <source>Accepts one argument: &lt;code&gt;component&lt;/code&gt;</source>
          <target state="translated">하나의 인수 허용 : &lt;code&gt;component&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5c9915ad775905b6d36fd6366e0372c79ac1481" translate="yes" xml:space="preserve">
          <source>Accepts one argument: &lt;code&gt;name&lt;/code&gt;</source>
          <target state="translated">하나의 인수 허용 : &lt;code&gt;name&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f017bf3c90bc5a4f6ab1094c57f6d07d5a16ce59" translate="yes" xml:space="preserve">
          <source>Accepts three arguments: &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; , &lt;code&gt;props&lt;/code&gt; 및 &lt;code&gt;children&lt;/code&gt; 의 세 가지 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8b5776add92d702df2a820a2c1e202248faaa42b" translate="yes" xml:space="preserve">
          <source>Accepts two arguments: &lt;code&gt;HostNode&lt;/code&gt; and &lt;code&gt;HostElement&lt;/code&gt;</source>
          <target state="translated">두 개의 인수 허용 : &lt;code&gt;HostNode&lt;/code&gt; 및 &lt;code&gt;HostElement&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b2d34d77731fd6ca6f50e7fd4b634c893fd37f9" translate="yes" xml:space="preserve">
          <source>Accepts two arguments: &lt;code&gt;vnode&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;vnode&lt;/code&gt; 및 &lt;code&gt;directives&lt;/code&gt; 두 가지 인수를 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ec904b80a69be9b5f71240a9dae398f94fe32c4" translate="yes" xml:space="preserve">
          <source>Access both the previous and current value of the watched state.</source>
          <target state="translated">감시 상태의 이전 값과 현재 값에 모두 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0a52b0d5edaa2ede0d229f615b761ebeb981131b" translate="yes" xml:space="preserve">
          <source>Access in Reactive Objects</source>
          <target state="translated">반응 적 개체에서 액세스</target>
        </trans-unit>
        <trans-unit id="f6f87f3c77a7867b32ff9b31d0d8486e59753621" translate="yes" xml:space="preserve">
          <source>Accessible Rich Internet Applications (WAI-ARIA) 1.2 (opens new window)</source>
          <target state="translated">액세스 가능한 리치 인터넷 애플리케이션 (WAI-ARIA) 1.2 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="8e9d3a84713f2a204fe24aeef0f135721d0c5e9a" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;this.$slots&lt;/code&gt; is most useful when writing a component with a &lt;a href=&quot;../guide/render-function&quot;&gt;render function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;this.$slots&lt;/code&gt; 액세스 하는 것은 &lt;a href=&quot;../guide/render-function&quot;&gt;렌더링 함수&lt;/a&gt; 로 구성 요소를 작성할 때 가장 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="5b50b62f5cbc40072eea261aa6929a1cb82ee0d5" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;vm.$scopedSlots&lt;/code&gt; is most useful when writing a component with a &lt;a href=&quot;../guide/render-function&quot;&gt;render function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vm.$scopedSlots&lt;/code&gt; 액세스 하는 것은 &lt;a href=&quot;../guide/render-function&quot;&gt;렌더링 기능으로&lt;/a&gt; 구성 요소를 작성할 때 가장 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="43cc7124b3cd5bce237d9cb731b89c1b2d4441c4" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;vm.$slots&lt;/code&gt; is most useful when writing a component with a &lt;a href=&quot;../guide/render-function&quot;&gt;render function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;vm.$slots&lt;/code&gt; 액세스 하는 것은 &lt;a href=&quot;../guide/render-function&quot;&gt;render 함수를 사용&lt;/a&gt; 하여 구성 요소를 작성할 때 가장 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="aa5360da634be9b4703e888f353bb4cb930b0c39" translate="yes" xml:space="preserve">
          <source>Accessing Child Component Instances &amp;amp; Child Elements</source>
          <target state="translated">자식 구성 요소 인스턴스 및 자식 요소에 액세스</target>
        </trans-unit>
        <trans-unit id="000884e75d68697f91351e43a49d51fe7c50139e" translate="yes" xml:space="preserve">
          <source>Accessing Component Properties</source>
          <target state="translated">구성 요소 속성 액세스</target>
        </trans-unit>
        <trans-unit id="3e070cd358201567e0214607dc834ffde3324729" translate="yes" xml:space="preserve">
          <source>Accessing the Parent Component Instance</source>
          <target state="translated">부모 구성 요소 인스턴스에 액세스</target>
        </trans-unit>
        <trans-unit id="f3400d1a5e37cdaf0529c23c93b2c085bc355aa4" translate="yes" xml:space="preserve">
          <source>Accessing the Root Instance</source>
          <target state="translated">루트 인스턴스에 액세스</target>
        </trans-unit>
        <trans-unit id="9916dfe13f23eef38cf2dd9e0ac980248d896f9a" translate="yes" xml:space="preserve">
          <source>Active community and team</source>
          <target state="translated">활발한 커뮤니티 및 팀</target>
        </trans-unit>
        <trans-unit id="74cf6ada1913c2571c8305ddc043ddfe353af5e2" translate="yes" xml:space="preserve">
          <source>Add one or more global assets: directives/filters/transitions etc. (e.g. &lt;a href=&quot;https://github.com/vuejs/vue-touch&quot;&gt;vue-touch (opens new window)&lt;/a&gt;).</source>
          <target state="translated">하나 이상의 글로벌 자산을 추가합니다 : 지시문 / 필터 / 전환 등 (예 : &lt;a href=&quot;https://github.com/vuejs/vue-touch&quot;&gt;vue-touch (새 창 열기)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0558b15a1e843f3e820f05a7831ba76cff8484ca" translate="yes" xml:space="preserve">
          <source>Add one or more global assets: directives/filters/transitions etc. e.g. &lt;a href=&quot;https://github.com/vuejs/vue-touch&quot;&gt;vue-touch&lt;/a&gt;</source>
          <target state="translated">하나 이상의 글로벌 자산 추가 : 지시문 / 필터 / 전환 등 &lt;a href=&quot;https://github.com/vuejs/vue-touch&quot;&gt;vue-touch&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4d0ce34829d9491f99c124a1a46de95499eedd6" translate="yes" xml:space="preserve">
          <source>Add some Vue instance methods by attaching them to Vue.prototype.</source>
          <target state="translated">Vue 인스턴스 메소드를 Vue.prototype에 첨부하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="af945b971224834f829575210e472680682bfe61" translate="yes" xml:space="preserve">
          <source>Add some component options by global mixin (e.g. &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router (opens new window)&lt;/a&gt;).</source>
          <target state="translated">글로벌 믹스 인 (예 : &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router (새 창에서 열림)&lt;/a&gt; )으로 일부 구성 요소 옵션을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8521ac8394f55fe417b5a588330dbc88d1f9ad" translate="yes" xml:space="preserve">
          <source>Add some component options by global mixin. e.g. &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router&lt;/a&gt;</source>
          <target state="translated">글로벌 믹스 인으로 일부 구성 요소 옵션을 추가하십시오. 예 : &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="206bced9c10caa4ad462774b1d49408967f3ae08" translate="yes" xml:space="preserve">
          <source>Add some global instance methods by attaching them to &lt;code&gt;config.globalProperties&lt;/code&gt;.</source>
          <target state="translated">일부 글로벌 인스턴스 메소드를 &lt;code&gt;config.globalProperties&lt;/code&gt; 에 연결하여 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="63dd40ed5ca7c541f65641f78af57cbbcff48da5" translate="yes" xml:space="preserve">
          <source>Add some global methods or properties, e.g. &lt;a href=&quot;https://github.com/karol-f/vue-custom-element&quot;&gt;vue-custom-element (opens new window)&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://github.com/karol-f/vue-custom-element&quot;&gt;vue-custom-element (새 창에서 열림)&lt;/a&gt; 와 같은 일부 전역 메서드 또는 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="35ab17ed46d3ba5668bc28248feebff2125e2e51" translate="yes" xml:space="preserve">
          <source>Add some global methods or properties. e.g. &lt;a href=&quot;https://github.com/karol-f/vue-custom-element&quot;&gt;vue-custom-element&lt;/a&gt;</source>
          <target state="translated">글로벌 메소드 또는 특성을 추가하십시오. 예 : &lt;a href=&quot;https://github.com/karol-f/vue-custom-element&quot;&gt;vue-custom-element&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c233bccc4dfd135faa12ee3138b60f3181270d4" translate="yes" xml:space="preserve">
          <source>Add to your project&amp;rsquo;s &lt;code&gt;package.json&lt;/code&gt;:</source>
          <target state="translated">프로젝트의 &lt;code&gt;package.json&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cb7895f7b12adcd6febf5ad68fa3b2f1f5d82b0" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;aria-hidden=&quot;true&quot;&lt;/code&gt; will hide the element from assistive technology but leave it visually available for other users. Do not use it on focusable elements, purely on decorative, duplicated or offscreen content.</source>
          <target state="translated">&lt;code&gt;aria-hidden=&quot;true&quot;&lt;/code&gt; 를 추가하면 보조 기술에서 요소가 숨겨 지지만 다른 사용자가 시각적으로 사용할 수 있습니다. 초점을 맞출 수있는 요소, 순전히 장식, 복제 또는 오프 스크린 콘텐츠에 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="38858dc789c3506ce5a09afeb4bbf5b0bc9f0cf2" translate="yes" xml:space="preserve">
          <source>Adding Reactivity</source>
          <target state="translated">반응성 추가</target>
        </trans-unit>
        <trans-unit id="94246ef8043f9858fdd0d59bfb07c083e643aa09" translate="yes" xml:space="preserve">
          <source>Additionally, since we have access to the &lt;code&gt;app&lt;/code&gt; object, all other capabilities like using &lt;code&gt;mixin&lt;/code&gt; and &lt;code&gt;directive&lt;/code&gt; are available to the plugin. To learn more about &lt;code&gt;createApp&lt;/code&gt; and the application instance, check out the &lt;a href=&quot;../api/application-api&quot;&gt;Application API documentation&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;app&lt;/code&gt; 개체에 액세스 할 수 있으므로 &lt;code&gt;mixin&lt;/code&gt; 및 &lt;code&gt;directive&lt;/code&gt; 사용 과 같은 다른 모든 기능 을 플러그인에서 사용할 수 있습니다. &lt;code&gt;createApp&lt;/code&gt; 및 애플리케이션 인스턴스 에 대해 자세히 알아 보려면 &lt;a href=&quot;../api/application-api&quot;&gt;애플리케이션 API 문서를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="ccf474c7bf42434572400eb8429d6d5b83653a7a" translate="yes" xml:space="preserve">
          <source>Adds a global property that can be accessed in any component instance inside the application. The component&amp;rsquo;s property will take priority when there are conflicting keys.</source>
          <target state="translated">응용 프로그램 내의 모든 구성 요소 인스턴스에서 액세스 할 수있는 전역 속성을 추가합니다. 충돌하는 키가있는 경우 구성 요소의 속성이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b39cddc1d643ab738b6dccc79617b70ec367a05a" translate="yes" xml:space="preserve">
          <source>Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. &lt;code&gt;this.myObject.newProperty = 'hi'&lt;/code&gt;).</source>
          <target state="translated">반응 형 객체에 속성을 추가하여 새 속성도 반응 형이므로 뷰 업데이트를 트리거합니다. Vue가 일반적인 속성 추가를 감지 할 수 없으므로 (예 : &lt;code&gt;this.myObject.newProperty = 'hi'&lt;/code&gt; ) 반응성 객체에 새 속성을 추가하는 데 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9598f333eae7963e0a17dc25fb44481a25f2272" translate="yes" xml:space="preserve">
          <source>Affected APIs</source>
          <target state="translated">영향을받는 API</target>
        </trans-unit>
        <trans-unit id="49eb6fb8980e7b35ff3b18a7428b662ad4f4c199" translate="yes" xml:space="preserve">
          <source>After a Vue app has been initialized with &lt;code&gt;createApp()&lt;/code&gt;, you can add a plugin to your application by calling the &lt;code&gt;use()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;createApp()&lt;/code&gt; 으로 Vue 앱을 초기화 한 후 &lt;code&gt;use()&lt;/code&gt; 메서드를 호출하여 애플리케이션에 플러그인을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7ad3ea0d73c47cc510dd161a21610c0f1c71ede" translate="yes" xml:space="preserve">
          <source>After adding &lt;code&gt;functional: true&lt;/code&gt;, updating the render function of our anchored heading component would require adding the &lt;code&gt;context&lt;/code&gt; argument, updating &lt;code&gt;this.$slots.default&lt;/code&gt; to &lt;code&gt;context.children&lt;/code&gt;, then updating &lt;code&gt;this.level&lt;/code&gt; to &lt;code&gt;context.props.level&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;functional: true&lt;/code&gt; 추가 한 후 : true , 앵커 된 표제 구성 요소의 렌더링 기능을 업데이트하려면 &lt;code&gt;context&lt;/code&gt; 인수를 추가하고 &lt;code&gt;this.$slots.default&lt;/code&gt; 를 &lt;code&gt;context.children&lt;/code&gt; 으로 업데이트 한 다음 &lt;code&gt;this.level&lt;/code&gt; 을 &lt;code&gt;context.props.level&lt;/code&gt; 로 업데이트 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="66a779e5725692a0551ebe28b853a76b730cc51f" translate="yes" xml:space="preserve">
          <source>After being initialized with &lt;code&gt;createApp(/* options */)&lt;/code&gt;, the app instance &lt;code&gt;app&lt;/code&gt; can be used to mount a root component instance with &lt;code&gt;app.mount(domTarget)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createApp(/* options */)&lt;/code&gt; 로 초기화 된 후 &lt;code&gt;app.mount(domTarget)&lt;/code&gt; 로 루트 구성 요소 인스턴스를 마운트하는 데 앱 인스턴스 &lt;code&gt;app&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5179b5b2a43182c70638c6dd48526689cccdd9bf" translate="yes" xml:space="preserve">
          <source>After including the above code as a declaration file (like &lt;code&gt;my-property.d.ts&lt;/code&gt;) in your project, you can use &lt;code&gt;$myProperty&lt;/code&gt; on a Vue instance.</source>
          <target state="translated">위 코드를 선언 파일 (예 : &lt;code&gt;my-property.d.ts&lt;/code&gt; )로 프로젝트 에 포함시킨 후 Vue 인스턴스에서 &lt;code&gt;$myProperty&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584fb7bea52bf2a8057d7f7a3fcb966585501642" translate="yes" xml:space="preserve">
          <source>After that, browse through the table of contents for this page in the sidebar. If you see a topic you may be affected by, but the migration helper didn&amp;rsquo;t catch, check it out.</source>
          <target state="translated">그런 다음 사이드 바에서이 페이지의 목차를 찾아보십시오. 영향을받을 수있는 주제가 있지만 마이그레이션 도우미가 발견하지 못한 경우 해당 주제를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5545c04b66e1e2439288f5b5b54f970a924d0478" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be ready to contribute to Vue&amp;rsquo;s core repositories:</source>
          <target state="translated">그런 다음 Vue의 핵심 리포지토리에 기여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8129005cdb1c6d7de8c2f7f86aff513a42faeafb" translate="yes" xml:space="preserve">
          <source>After the first render, a component would have tracked a list of dependencies &amp;mdash; the properties it accessed during the render. Conversely, the component becomes a subscriber to each of these properties. When a proxy intercepts a set operation, the property will notify all of its subscribed components to re-render.</source>
          <target state="translated">첫 번째 렌더링 후 구성 요소는 종속성 목록, 즉 렌더링 중에 액세스 한 속성을 추적했을 것입니다. 반대로 구성 요소는 이러한 각 속성에 대한 구독자가됩니다. 프록시가 집합 작업을 가로 채면 속성은 구독 된 모든 구성 요소에 다시 렌더링하도록 알립니다.</target>
        </trans-unit>
        <trans-unit id="c9d485dbd20011f611535fdf446b3d653a7c76ba" translate="yes" xml:space="preserve">
          <source>After the instance is created, the original data object can be accessed as &lt;code&gt;vm.$data&lt;/code&gt;. The Vue instance also proxies all the properties found on the data object, so &lt;code&gt;vm.a&lt;/code&gt; will be equivalent to &lt;code&gt;vm.$data.a&lt;/code&gt;.</source>
          <target state="translated">인스턴스가 작성된 후 원래 데이터 오브젝트는 &lt;code&gt;vm.$data&lt;/code&gt; 로 액세스 할 수 있습니다 . Vue 인스턴스는 데이터 객체에있는 모든 속성을 프록시하므로 &lt;code&gt;vm.a&lt;/code&gt; 는 &lt;code&gt;vm.$data.a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7863379fe644a8287c0be1de76df6d5fc86e3b54" translate="yes" xml:space="preserve">
          <source>After the instance is created, the original data object can be accessed as &lt;code&gt;vm.$data&lt;/code&gt;. The component instance also proxies all the properties found on the data object, so &lt;code&gt;vm.a&lt;/code&gt; will be equivalent to &lt;code&gt;vm.$data.a&lt;/code&gt;.</source>
          <target state="translated">인스턴스가 생성 된 후 원래 데이터 개체는 &lt;code&gt;vm.$data&lt;/code&gt; 로 액세스 할 수 있습니다 . 또한 구성 요소 인스턴스는 데이터 개체에있는 모든 속성을 프록시하므로 &lt;code&gt;vm.a&lt;/code&gt; 는 &lt;code&gt;vm.$data.a&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d666349c92f3219ad13aa2920b4d2b8183e64ea0" translate="yes" xml:space="preserve">
          <source>After the instance is mounted, the resolved element will be accessible as &lt;code&gt;vm.$el&lt;/code&gt;.</source>
          <target state="translated">인스턴스가 마운트되면 해결 된 요소는 &lt;code&gt;vm.$el&lt;/code&gt; 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccaf124ea8cb4d40376eaf9b3098c579b4150a79" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;ve taken a day to dive into these resources, we recommend checking out &lt;a href=&quot;https://cli.vuejs.org/&quot;&gt;Vue CLI 3&lt;/a&gt;. Follow the instructions and you should have a Vue project with &lt;code&gt;.vue&lt;/code&gt; components, ES2015, Webpack and hot-reloading in no time!</source>
          <target state="translated">이러한 리소스를 살펴 보려면 하루를 보낸 후 &lt;a href=&quot;https://cli.vuejs.org/&quot;&gt;Vue CLI 3를&lt;/a&gt; 확인하는 것이 좋습니다 . 지침을 따르십시오. &lt;code&gt;.vue&lt;/code&gt; 구성 요소, ES2015, Webpack 및 핫 리로드 가 포함 된 Vue 프로젝트가 곧 있어야합니다!</target>
        </trans-unit>
        <trans-unit id="a87ba746bdc87e41af0052df197b513d1f93e1ba" translate="yes" xml:space="preserve">
          <source>After you've taken a day to dive into these resources, we recommend checking out &lt;a href=&quot;https://cli.vuejs.org/&quot;&gt;Vue CLI (opens new window)&lt;/a&gt;. Follow the instructions and you should have a Vue project with &lt;code&gt;.vue&lt;/code&gt; components, ES2015, webpack and hot-reloading in no time!</source>
          <target state="translated">이러한 리소스에 대해 하루를 보냈 으면 &lt;a href=&quot;https://cli.vuejs.org/&quot;&gt;Vue CLI (새 창에서 열림)를&lt;/a&gt; 확인하는 것이 좋습니다 . 지침을 따르고 &lt;code&gt;.vue&lt;/code&gt; 구성 요소, ES2015, 웹팩 및 핫 리로딩 이 포함 된 Vue 프로젝트를 즉시 얻을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="4035fa2559db72aeae2fe32d00fce2ce3541064d" translate="yes" xml:space="preserve">
          <source>Again due to limitations of modern JavaScript, &lt;strong&gt;Vue cannot detect property addition or deletion&lt;/strong&gt;. For example:</source>
          <target state="translated">최신 JavaScript의 한계로 인해 &lt;strong&gt;Vue는 속성 추가 또는 삭제를 감지 할 수 없습니다&lt;/strong&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13d06ad758afa4d98d31afc22e29029433a54989" translate="yes" xml:space="preserve">
          <source>Again, if you&amp;rsquo;re using string templates, this limitation does not apply.</source>
          <target state="translated">문자열 템플릿을 사용하는 경우에도이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4720b8a4c356d7b6bc82aec32bb55591c1ece2bb" translate="yes" xml:space="preserve">
          <source>Again, if you're using string templates, this limitation does not apply.</source>
          <target state="translated">다시 말하지만, 문자열 템플릿을 사용하는 경우이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a5fd8f6fe7da6eb27ee847128e973cae177d678" translate="yes" xml:space="preserve">
          <source>Again, the object syntax is often used in conjunction with computed properties that return objects.</source>
          <target state="translated">다시, 객체 구문은 종종 객체를 반환하는 계산 된 속성과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0efe0b2c75c1c670b3146f5f276e23a667f15ec" translate="yes" xml:space="preserve">
          <source>Alerts</source>
          <target state="translated">Alerts</target>
        </trans-unit>
        <trans-unit id="882c2811e5772305a01848736e50210f7d5c7909" translate="yes" xml:space="preserve">
          <source>Aliasing &lt;code&gt;createElement&lt;/code&gt; to &lt;code&gt;h&lt;/code&gt; is a common convention you&amp;rsquo;ll see in the Vue ecosystem and is actually required for JSX. Starting with &lt;a href=&quot;https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection&quot;&gt;version 3.4.0&lt;/a&gt; of the Babel plugin for Vue, we automatically inject &lt;code&gt;const h = this.$createElement&lt;/code&gt; in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the &lt;code&gt;(h)&lt;/code&gt; parameter. With prior versions of the plugin, your app would throw an error if &lt;code&gt;h&lt;/code&gt; was not available in the scope.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; 를 &lt;code&gt;h&lt;/code&gt; 로 별칭 지정 하는 것은 Vue 에코 시스템에서 볼 수있는 일반적인 규칙이며 실제로 JSX에 필요합니다. Vue 용 Babel 플러그인 &lt;a href=&quot;https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection&quot;&gt;버전 3.4.0&lt;/a&gt; 부터는 JSX가 포함 된 ES2015 구문으로 선언 된 모든 메소드 및 getter (함수 또는 화살표 함수 아님)에 &lt;code&gt;const h = this.$createElement&lt;/code&gt; 를 자동으로 삽입 하므로 &lt;code&gt;(h)&lt;/code&gt; 파라미터. 플러그인의 이전 버전 에서는 범위에서 &lt;code&gt;h&lt;/code&gt; 를 사용할 수 없으면 앱에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="67e512a516784e547a77cdcbe9a92b128f542007" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;$slots&lt;/code&gt; are now also exposed on &lt;code&gt;$scopedSlots&lt;/code&gt; as functions. If you work with render functions, it is now recommended to always access slots via &lt;code&gt;$scopedSlots&lt;/code&gt;, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.</source>
          <target state="translated">모든 &lt;code&gt;$slots&lt;/code&gt; 은 이제 &lt;code&gt;$scopedSlots&lt;/code&gt; 에 함수로 노출됩니다 . 렌더 기능으로 작업하는 경우 현재 범위를 사용하는지 여부에 관계없이 항상 &lt;code&gt;$scopedSlots&lt;/code&gt; 를 통해 슬롯에 액세스하는 것이 좋습니다 . 이를 통해 향후 리팩터링을 통해 범위를보다 간단하게 추가 할 수있을뿐만 아니라 모든 슬롯이 작동하는 Vue 3로 최종 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fc5c0811f2637eb910708a252d6026f43f9a64" translate="yes" xml:space="preserve">
          <source>All UMD builds can be used directly as an AMD module.</source>
          <target state="translated">모든 UMD 빌드는 AMD 모듈로 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df38f74745e7028f377542dd26c5bcd8b69c02e7" translate="yes" xml:space="preserve">
          <source>All VNodes in the component tree must be unique. That means the following render function is invalid:</source>
          <target state="translated">컴포넌트 트리의 모든 VNode는 고유해야합니다. 이는 다음 렌더링 기능이 유효하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="518e8e3823613ecc844aca79a863b64325e131d7" translate="yes" xml:space="preserve">
          <source>All lifecycle hooks automatically have their &lt;code&gt;this&lt;/code&gt; context bound to the instance, so that you can access data, computed properties, and methods. This means &lt;strong&gt;you should not use an arrow function to define a lifecycle method&lt;/strong&gt; (e.g. &lt;code&gt;created: () =&amp;gt; this.fetchTodos()&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.fetchTodos&lt;/code&gt; will be undefined.</source>
          <target state="translated">모든 수명주기 후크는 자동 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 인스턴스에 바인딩되므로 데이터, 계산 된 속성 및 메서드에 액세스 할 수 있습니다. 즉 &lt;strong&gt;, 화살표 함수를 사용하여 수명주기 메소드를 정의하면 안됩니다&lt;/strong&gt; (예 &lt;code&gt;created: () =&amp;gt; this.fetchTodos()&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같이 뷰 인스턴스되지 않습니다 &lt;code&gt;this.fetchTodos&lt;/code&gt; 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6d5b316c6250c459062cf49b4156c307aef67de" translate="yes" xml:space="preserve">
          <source>All lifecycle hooks automatically have their &lt;code&gt;this&lt;/code&gt; context bound to the instance, so that you can access data, computed properties, and methods. This means &lt;strong&gt;you should not use an arrow function to define a lifecycle method&lt;/strong&gt; (e.g. &lt;code&gt;created: () =&amp;gt; this.fetchTodos()&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.fetchTodos&lt;/code&gt; will be undefined.</source>
          <target state="translated">모든 수명주기 후크는 자동 &lt;code&gt;this&lt;/code&gt; 컨텍스트를 인스턴스에 바인딩하므로 데이터, 계산 된 속성 및 메서드에 액세스 할 수 있습니다. 즉 &lt;strong&gt;, 수명주기 메서드를 정의하기 위해 화살표 함수를 사용해서는 안됩니다&lt;/strong&gt; (예 : &lt;code&gt;created: () =&amp;gt; this.fetchTodos()&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같은 구성 요소 인스턴스되지 않습니다 &lt;code&gt;this.fetchTodos&lt;/code&gt; 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a553f4e55cf9a4f38374a8b130ada77154ec8f5a" translate="yes" xml:space="preserve">
          <source>All lowercase</source>
          <target state="translated">모두 소문자</target>
        </trans-unit>
        <trans-unit id="92ef783c31a5231f8805e1226433106fab22814c" translate="yes" xml:space="preserve">
          <source>All of our official libraries and tools now support Vue 3, but most of them are still in beta status and distributed under the &lt;code&gt;next&lt;/code&gt; dist tag on npm. &lt;strong&gt;We are planning to stabilize and switch all projects to use the &lt;code&gt;latest&lt;/code&gt; dist tag by end of 2020.&lt;/strong&gt;</source>
          <target state="translated">모든 공식 라이브러리 및 도구는 이제 Vue 3을 지원하지만 대부분은 아직 베타 상태이며 npm 의 &lt;code&gt;next&lt;/code&gt; dist 태그로 배포됩니다 . &lt;strong&gt;2020 년 말까지 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;latest&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; dist 태그 &lt;/strong&gt;&lt;strong&gt;를 사용하도록 모든 프로젝트를 안정화하고 전환 할 계획 입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a1fd707965d908f856ca354f3073f7702a25ad9" translate="yes" xml:space="preserve">
          <source>All of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can animate these state changes using 3rd-party libraries to tween state, in combination with Vue&amp;rsquo;s reactivity and component systems.</source>
          <target state="translated">이들 모두는 이미 원시 숫자로 저장되거나 숫자로 변환 될 수 있습니다. 그렇게하면 Vue의 반응성 및 구성 요소 시스템과 함께 타사 라이브러리를 사용하여 상태를 트윈 상태로 변경하여 이러한 상태 변경에 애니메이션을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131009f3b69b3f95ceb94a456565356bf090f91c" translate="yes" xml:space="preserve">
          <source>All of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can animate these state changes using 3rd-party libraries to tween state, in combination with Vue's reactivity and component systems.</source>
          <target state="translated">이들 모두는 이미 원시 숫자로 저장되거나 숫자로 변환 될 수 있습니다. 그렇게하면 Vue의 반응성 및 구성 요소 시스템과 함께 타사 라이브러리를 사용하여 상태를 트위닝하도록 이러한 상태 변경을 애니메이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a83d046e31f738e64b7093dda5db51fee1bd192" translate="yes" xml:space="preserve">
          <source>All of these are solved by &lt;strong&gt;single-file components&lt;/strong&gt; with a &lt;code&gt;.vue&lt;/code&gt; extension, made possible with build tools such as Webpack or Browserify.</source>
          <target state="translated">이러한 모든 기능은 Webpack 또는 Browserify와 같은 빌드 도구를 사용하여 확장명 이 &lt;code&gt;.vue&lt;/code&gt; 인&lt;strong&gt;단일 파일 구성 요소&lt;/strong&gt; 로 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbd7c86cf57a1979736fa7387dcaa8d2606bc3fc" translate="yes" xml:space="preserve">
          <source>All other global APIs that do not globally mutate behavior are now named exports, as documented in &lt;a href=&quot;global-api-treeshaking&quot;&gt;Global API Treeshaking&lt;/a&gt;.</source>
          <target state="translated">전역 적으로 동작을 변경하지 않는 다른 모든 전역 API는 이제 &lt;a href=&quot;global-api-treeshaking&quot;&gt;Global API Treeshaking에&lt;/a&gt; 설명 된대로 내보내기로 이름이 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="c167a5e717e3cf2ba619d5219265e210d79f7e3c" translate="yes" xml:space="preserve">
          <source>All props form a &lt;strong&gt;one-way-down binding&lt;/strong&gt; between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent&amp;rsquo;s state, which can make your app&amp;rsquo;s data flow harder to understand.</source>
          <target state="translated">모든 소품 은 자식 속성과 부모 속성 사이에 &lt;strong&gt;단방향 바인딩을&lt;/strong&gt; 형성합니다. 부모 속성이 업데이트되면 자식 속성으로 내려가지만 다른 방법은 아닙니다. 이렇게하면 자식 구성 요소가 실수로 부모의 상태를 변경하지 못하게되어 앱의 데이터 흐름을 이해하기가 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2662a446fc83696aa230d21479eada7808da2e4f" translate="yes" xml:space="preserve">
          <source>All props form a &lt;strong&gt;one-way-down binding&lt;/strong&gt; between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.</source>
          <target state="translated">모든 props 는 자식 속성과 부모 속성 사이에 &lt;strong&gt;단방향 바인딩을&lt;/strong&gt; 형성합니다. 부모 속성이 업데이트되면 자식으로 흐르지 만 반대 방향은 아닙니다. 이렇게하면 하위 구성 요소가 실수로 상위의 상태를 변경하는 것을 방지하여 앱의 데이터 흐름을 이해하기 어렵게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16eab474b1ec4a1329577a71f5e9c584e38a8532" translate="yes" xml:space="preserve">
          <source>All routing mode options have been condensed into a single &lt;a href=&quot;https://router.vuejs.org/en/api/options.html#mode&quot;&gt;&lt;code&gt;mode&lt;/code&gt; option&lt;/a&gt;. Update:</source>
          <target state="translated">모든 라우팅 모드 옵션이 단일 &lt;a href=&quot;https://router.vuejs.org/en/api/options.html#mode&quot;&gt; &lt;code&gt;mode&lt;/code&gt; 옵션&lt;/a&gt; 으로 압축되었습니다 . 최신 정보:</target>
        </trans-unit>
        <trans-unit id="8eb0ad80548989252fccb966f36ec90afb0e191a" translate="yes" xml:space="preserve">
          <source>All subcomponents will now be able to access this instance and use it as a global store:</source>
          <target state="translated">모든 하위 구성 요소는 이제이 인스턴스에 액세스하여 전역 저장소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b786b1e86ded052a10ac30b2941b171f237ad7" translate="yes" xml:space="preserve">
          <source>All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue&amp;rsquo;s rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</source>
          <target state="translated">이 페이지의 모든 기능은 엣지 케이스 처리를 문서화하는데, 이는 때때로 Vue의 규칙을 약간 구부려 야하는 비정상적인 상황을 의미합니다. 그러나 모두 위험 할 수있는 단점이나 상황이 있습니다. 이들은 각각의 경우에 언급되므로 각 기능을 사용하기로 결정할 때 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="becf4efdd4a5d9342eb314b751bb8e36a281b237" translate="yes" xml:space="preserve">
          <source>All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue's rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</source>
          <target state="translated">이 페이지의 모든 기능은 Vue의 규칙을 약간 변경해야하는 비정상적인 상황을 의미하는 엣지 케이스의 처리를 문서화합니다. 그러나 그들 모두는 위험 할 수있는 단점이나 상황이 있다는 점에 유의하십시오. 이는 각각의 경우에 기록되므로 각 기능을 사용하기로 결정할 때 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="6ce03eb6970bf7238f60e7b5faf1c518811ed16c" translate="yes" xml:space="preserve">
          <source>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with &lt;code&gt;Vue.component()&lt;/code&gt;, the global ID is automatically set as its name.</source>
          <target state="translated">컴포넌트가 템플리트에서 재귀 적으로 호출하도록 허용하십시오. 컴포넌트가 &lt;code&gt;Vue.component()&lt;/code&gt; 글로벌로 등록 되면 글로벌 ID가 자동으로 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1b04de3107b3f6be86295a9cb3bb35c3d22759" translate="yes" xml:space="preserve">
          <source>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with &lt;code&gt;Vue.createApp({}).component({})&lt;/code&gt;, the global ID is automatically set as its name.</source>
          <target state="translated">구성 요소가 템플릿에서 자신을 재귀 적으로 호출 할 수 있도록합니다. 컴포넌트가 &lt;code&gt;Vue.createApp({}).component({})&lt;/code&gt; 전역 적으로 등록 되면 전역 ID가 자동으로 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4030c4050fc12765d9ba75383685566375d8c859" translate="yes" xml:space="preserve">
          <source>Allows a custom component to customize the prop and event used when it&amp;rsquo;s used with &lt;code&gt;v-model&lt;/code&gt;. By default, &lt;code&gt;v-model&lt;/code&gt; on a component uses &lt;code&gt;value&lt;/code&gt; as the prop and &lt;code&gt;input&lt;/code&gt; as the event, but some input types such as checkboxes and radio buttons may want to use the &lt;code&gt;value&lt;/code&gt; prop for a different purpose. Using the &lt;code&gt;model&lt;/code&gt; option can avoid the conflict in such cases.</source>
          <target state="translated">사용자 정의 구성 요소가 &lt;code&gt;v-model&lt;/code&gt; 과 함께 사용될 때 사용되는 prop 및 이벤트를 사용자 정의 할 수 있습니다 . 기본적 으로 구성 요소의 &lt;code&gt;v-model&lt;/code&gt; 은 &lt;code&gt;value&lt;/code&gt; 을 소품으로 사용하고 &lt;code&gt;input&lt;/code&gt; 을 이벤트로 사용하지만 확인란 및 라디오 버튼과 같은 일부 입력 유형 은 다른 용도로 &lt;code&gt;value&lt;/code&gt; 소품 을 사용하려고 할 수 있습니다 . 이러한 경우 &lt;code&gt;model&lt;/code&gt; 옵션을 사용하면 충돌을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a11a0da446af74672e18852449f10c594254be9d" translate="yes" xml:space="preserve">
          <source>Allows applying directives to a &lt;strong&gt;VNode&lt;/strong&gt;. Returns a VNode with the applied directives.</source>
          <target state="translated">&lt;strong&gt;VNode에&lt;/strong&gt; 지시문을 적용 할 수 있습니다. 적용된 지시문이있는 VNode를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f29503ea12f3831556bab8df3d4f0c4b219c2ed7" translate="yes" xml:space="preserve">
          <source>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use &lt;code&gt;Vue.extend&lt;/code&gt;. This is primarily intended to make it easier to extend between single file components.</source>
          <target state="translated">&lt;code&gt;Vue.extend&lt;/code&gt; 를 사용하지 않고도 다른 컴포넌트 (일반 옵션 오브젝트 또는 생성자 일 수 있음)를 선언적으로 확장 할 수 있습니다 . 이것은 주로 단일 파일 구성 요소 사이에서보다 쉽게 ​​확장 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="34f7f6417109be7e39daad72f807171a5a572a1c" translate="yes" xml:space="preserve">
          <source>Allows declaratively extending another component (could be either a plain options object or a constructor). This is primarily intended to make it easier to extend between single file components.</source>
          <target state="translated">다른 구성 요소를 선언적으로 확장 할 수 있습니다 (일반 옵션 개체 또는 생성자 일 수 있음). 이는 주로 단일 파일 구성 요소간에 쉽게 확장 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3159749099ca327b688b9879dae339e6d29ed389" translate="yes" xml:space="preserve">
          <source>Allows resolving a &lt;code&gt;component&lt;/code&gt; by its name, if it is available in the current application instance.</source>
          <target state="translated">현재 응용 프로그램 인스턴스에서 사용할 수있는 경우 이름 으로 &lt;code&gt;component&lt;/code&gt; 를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e3a07fb5fe93adc952e55ad59751882dc585a8c" translate="yes" xml:space="preserve">
          <source>Allows resolving a &lt;code&gt;component&lt;/code&gt; by the same mechanism that &lt;code&gt;&amp;lt;component :is=&quot;&quot;&amp;gt;&lt;/code&gt; employs.</source>
          <target state="translated">분해능 허용 &lt;code&gt;component&lt;/code&gt; 하는 것과 같은기구에 의해 &lt;code&gt;&amp;lt;component :is=&quot;&quot;&amp;gt;&lt;/code&gt; 이용한다.</target>
        </trans-unit>
        <trans-unit id="1e470e82c591f9e7b121bb5f808a34653fc10377" translate="yes" xml:space="preserve">
          <source>Allows resolving a &lt;code&gt;directive&lt;/code&gt; by its name, if it is available in the current application instance.</source>
          <target state="translated">현재 응용 프로그램 인스턴스에서 사용할 수있는 경우 해당 이름 으로 &lt;code&gt;directive&lt;/code&gt; 을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6dffc1a59016ba4924a07ce8c06a70463e3df8" translate="yes" xml:space="preserve">
          <source>Already know Vue 2 and just want to learn about what's new in Vue 3? Check out the &lt;a href=&quot;guide/migration/introduction&quot;&gt;Migration Guide&lt;/a&gt;!</source>
          <target state="translated">이미 Vue 2를 알고 있고 Vue 3의 새로운 기능에 대해 알고 싶으십니까? &lt;a href=&quot;guide/migration/introduction&quot;&gt;마이그레이션 가이드를&lt;/a&gt; 확인하십시오 !</target>
        </trans-unit>
        <trans-unit id="71832ae8fbec097aca1233a41a5a8145116e6ffd" translate="yes" xml:space="preserve">
          <source>Also note that &lt;strong&gt;what&amp;rsquo;s considered &amp;ldquo;highest-level&amp;rdquo; will be contextual to your app&lt;/strong&gt;. For example, imagine an app with a search form. It may include components like this one:</source>
          <target state="translated">또한 &lt;strong&gt;'최상위 수준'으로 간주되는 것은 앱의 맥락에 따라 달라&lt;/strong&gt; 집니다. 예를 들어 검색 양식이있는 앱을 상상해보십시오. 다음과 같은 구성 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f89180ba9ef252bcd11b9c3c7737256ca8230b" translate="yes" xml:space="preserve">
          <source>Also note that &lt;strong&gt;what's considered &quot;highest-level&quot; will be contextual to your app&lt;/strong&gt;. For example, imagine an app with a search form. It may include components like this one:</source>
          <target state="translated">또한 &lt;strong&gt;'최상위 수준'으로 간주되는 항목은 앱과 관련이 있습니다&lt;/strong&gt; . 예를 들어 검색 양식이있는 앱을 상상해보십시오. 다음과 같은 구성 요소가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29ecac72ed7922b3f8b6ffb06c3eef36a16fd7e" translate="yes" xml:space="preserve">
          <source>Also note that if you&amp;rsquo;ve already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, &lt;strong&gt;using kebab-case everywhere is also acceptable.&lt;/strong&gt;</source>
          <target state="translated">또한 케밥 케이스에 이미 많은 투자를 한 경우 HTML 규칙과의 일관성 및 모든 프로젝트에서 동일한 케이싱을 사용할 수있는 것이 위에 나열된 이점보다 더 중요 할 수 있습니다. 이 경우 &lt;strong&gt;케밥 케이스를 어디에서나 사용하는 것도 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130e67dd4ee44d66913c7a147bc88bfacd3ee008" translate="yes" xml:space="preserve">
          <source>Also note that if you've already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, &lt;strong&gt;using kebab-case everywhere is also acceptable.&lt;/strong&gt;</source>
          <target state="translated">또한 이미 kebab-case에 많은 투자를했다면 HTML 규칙과의 일관성과 모든 프로젝트에서 동일한 대 / 소문자를 사용할 수있는 것이 위에 나열된 장점보다 더 중요 할 수 있습니다. 이 경우 &lt;strong&gt;케밥 케이스를 모든 곳&lt;/strong&gt; 에서 &lt;strong&gt;사용하는 것도 허용됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bfbb7fab0be9654dae857edec1fc82f73c59ac8f" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;deployment&quot;&gt;Production Deployment Tips&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;deployment&quot;&gt;프로덕션 배포 팁&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a5f25cd1bd9fc6ec0020b798e541e322dff0926" translate="yes" xml:space="preserve">
          <source>Also, HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names and event handler parameters need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">또한 HTML 속성 이름은 대소 문자를 구분하지 않으므로 브라우저는 모든 대문자를 소문자로 해석합니다. 즉, DOM 내 템플릿을 사용할 때 camelCased 소품 이름 및 이벤트 처리기 매개 변수는 케밥으로 구분 된 (하이픈으로 구분 된) 해당 항목을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f487bebba4e014aae57733509d0b523313cef4c7" translate="yes" xml:space="preserve">
          <source>Also, you can add another &lt;code&gt;ref&lt;/code&gt; to the component itself and use it to trigger &lt;code&gt;focusInput&lt;/code&gt; event from the parent component:</source>
          <target state="translated">또한 컴포넌트 자체 에 다른 &lt;code&gt;ref&lt;/code&gt; 를 추가 하고이를 사용 하여 상위 컴포넌트에서 &lt;code&gt;focusInput&lt;/code&gt; 이벤트 를 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9733af4a520a87f91ee5c9edbce6f05a4300b1ea" translate="yes" xml:space="preserve">
          <source>Alternate Template Definitions</source>
          <target state="translated">대체 템플릿 정의</target>
        </trans-unit>
        <trans-unit id="51b99148cfc142b5a31b58642239e228c01a3ced" translate="yes" xml:space="preserve">
          <source>Alternatively, it can take an object with &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; functions to create a writable ref object.</source>
          <target state="translated">또는 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 함수가 있는 개체 를 사용하여 쓰기 가능한 참조 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4426261061285bf374d897220d238dab7f02cebc" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag with &lt;code&gt;v-for&lt;/code&gt; to wrap the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">또는 &lt;code&gt;v-for&lt;/code&gt; 와 함께 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 태그를 사용 하여 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 를 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90594d18c278847211cf8a22342e70877c15c228" translate="yes" xml:space="preserve">
          <source>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</source>
          <target state="translated">또는 인덱스의 별칭 (또는 개체에서 사용되는 경우 키)을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22e48b068451a1b508a0584e33d878e7bc951c8" translate="yes" xml:space="preserve">
          <source>Alternatively, you can attach the instructions to the input with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-describedby_attribute&quot;&gt;&lt;code&gt;aria-describedby&lt;/code&gt; (opens new window)&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-describedby_attribute&quot;&gt; &lt;code&gt;aria-describedby&lt;/code&gt; (새 창에서 열림)&lt;/a&gt; 를 사용하여 입력에 지침을 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c21cb25a7f1aa0b87f4b576985c4e9de23a4f8a" translate="yes" xml:space="preserve">
          <source>Although Vue doesn&amp;rsquo;t use custom elements internally, it has &lt;a href=&quot;https://custom-elements-everywhere.com/#vue&quot;&gt;great interoperability&lt;/a&gt; when it comes to consuming or distributing as custom elements. Vue CLI also supports building Vue components that register themselves as native custom elements.</source>
          <target state="translated">Vue는 내부적으로 사용자 정의 요소를 사용하지 않지만 사용자 정의 요소 로 소비하거나 배포 할 때 &lt;a href=&quot;https://custom-elements-everywhere.com/#vue&quot;&gt;큰 상호 운용성&lt;/a&gt; 을 제공합니다. Vue CLI는 또한 기본 사용자 정의 요소로 자신을 등록하는 Vue 구성 요소 빌드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="353ace787b097d97c63d368a16a5b51a78b1103d" translate="yes" xml:space="preserve">
          <source>Although Vue doesn't use custom elements internally, it has &lt;a href=&quot;https://custom-elements-everywhere.com/#vue&quot;&gt;great interoperability (opens new window)&lt;/a&gt; when it comes to consuming or distributing as custom elements. Vue CLI also supports building Vue components that register themselves as native custom elements.</source>
          <target state="translated">Vue는 내부적으로 사용자 정의 요소를 사용하지 않지만 사용자 정의 요소 로 소비하거나 배포 할 때 &lt;a href=&quot;https://custom-elements-everywhere.com/#vue&quot;&gt;상호 운용성&lt;/a&gt; 이 뛰어납니다 (새 창에서 열림) . Vue CLI는 네이티브 사용자 지정 요소로 등록하는 Vue 구성 요소 빌드도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5f919759cdbbe867e98788b24924bdb6828f1ec1" translate="yes" xml:space="preserve">
          <source>Although filters within text interpolations are still allowed, all of the filters have been removed. Instead, it&amp;rsquo;s recommended to use more specialized libraries for solving problems in each domain (e.g. &lt;a href=&quot;https://date-fns.org/&quot;&gt;&lt;code&gt;date-fns&lt;/code&gt;&lt;/a&gt; to format dates and &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; for currencies).</source>
          <target state="translated">텍스트 보간 내의 필터는 여전히 허용되지만 모든 필터가 제거되었습니다. 대신, 각 도메인의 문제를 해결하기 위해보다 전문화 된 라이브러리를 사용하는 것이 좋습니다 (예 : &lt;a href=&quot;https://date-fns.org/&quot;&gt; &lt;code&gt;date-fns&lt;/code&gt; &lt;/a&gt; 형식화 및 통화 &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt; 위한 date-fns ).</target>
        </trans-unit>
        <trans-unit id="b1ac3bd6e1472eb849313c6df48cfe913bb44e46" translate="yes" xml:space="preserve">
          <source>Although not strictly associated with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Model_View_ViewModel&quot;&gt;MVVM pattern (opens new window)&lt;/a&gt;, Vue's design was partly inspired by it. As a convention, we often use the variable &lt;code&gt;vm&lt;/code&gt; (short for ViewModel) to refer to a component instance.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Model_View_ViewModel&quot;&gt;MVVM 패턴 (새 창에서 열림)&lt;/a&gt; 과 엄격하게 연관되지는 않았지만 Vue의 디자인은 부분적으로 영감을 받았습니다. 관례 적 으로 컴포넌트 인스턴스를 참조하기 위해 종종 변수 &lt;code&gt;vm&lt;/code&gt; (ViewModel의 약자)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e7f3a16ff67996f9ee85352b2dcd3bbfebfca43" translate="yes" xml:space="preserve">
          <source>Although not strictly associated with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Model_View_ViewModel&quot;&gt;MVVM pattern&lt;/a&gt;, Vue&amp;rsquo;s design was partly inspired by it. As a convention, we often use the variable &lt;code&gt;vm&lt;/code&gt; (short for ViewModel) to refer to our Vue instance.</source>
          <target state="translated">Vue의 디자인은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Model_View_ViewModel&quot;&gt;MVVM 패턴&lt;/a&gt; 과 밀접하게 관련되어 있지는 않지만 부분적으로 영감을 받았습니다. 일반적으로 우리는 종종 Vue 인스턴스를 참조하기 위해 변수 &lt;code&gt;vm&lt;/code&gt; (ViewModel의 줄임말)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6e2abdd63f46c9a3613fd79d0b250df5d3579bf6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;errorCaptured&lt;/code&gt; hook can return &lt;code&gt;false&lt;/code&gt; to prevent the error from propagating further. This is essentially saying &quot;this error has been handled and should be ignored.&quot; It will prevent any additional &lt;code&gt;errorCaptured&lt;/code&gt; hooks or the global &lt;code&gt;config.errorHandler&lt;/code&gt; from being invoked for this error.</source>
          <target state="translated">&lt;code&gt;errorCaptured&lt;/code&gt; 의 후크 돌아갈 수 &lt;code&gt;false&lt;/code&gt; 상기 전파 에러를 방지 할 수있다. 이것은 본질적으로 &quot;이 오류는 처리되었으므로 무시해야합니다.&quot;라는 의미입니다. 추가 &lt;code&gt;errorCaptured&lt;/code&gt; 후크 또는 전역 &lt;code&gt;config.errorHandler&lt;/code&gt; 가이 오류에 대해 호출되는 것을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="48633038159d243023310c2ad16e9d558e2af750" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;errorCaptured&lt;/code&gt; hook can return &lt;code&gt;false&lt;/code&gt; to prevent the error from propagating further. This is essentially saying &amp;ldquo;this error has been handled and should be ignored.&amp;rdquo; It will prevent any additional &lt;code&gt;errorCaptured&lt;/code&gt; hooks or the global &lt;code&gt;config.errorHandler&lt;/code&gt; from being invoked for this error.</source>
          <target state="translated">&lt;code&gt;errorCaptured&lt;/code&gt; 의 후크 돌아갈 수 &lt;code&gt;false&lt;/code&gt; 상기 전파 에러를 방지 할 수있다. 이것은 본질적으로 &quot;이 오류는 처리되었으므로 무시해야합니다.&quot;입니다. 이 오류에 대해 추가 &lt;code&gt;errorCaptured&lt;/code&gt; 후크 또는 전역 &lt;code&gt;config.errorHandler&lt;/code&gt; 가 호출 되지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="58f4f6bd8d5d0f3d0487babbd6780e94653ebe06" translate="yes" xml:space="preserve">
          <source>An HTML tag name, a component or an async component. Using function returning null would render a comment. This parameter is required</source>
          <target state="translated">HTML 태그 이름, 구성 요소 또는 비동기 구성 요소입니다. null을 반환하는 함수를 사용하면 주석이 렌더링됩니다. 이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="64d706889200d5c69d5b89403c4e715620449a2a" translate="yes" xml:space="preserve">
          <source>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript.</source>
          <target state="translated">JavaScript의 완전한 프로그래밍 기능을 활용할 수 있도록하는 문자열 템플릿의 대안입니다.</target>
        </trans-unit>
        <trans-unit id="a79dd4fc23e6041bcb9f258f161a2a973a10be8c" translate="yes" xml:space="preserve">
          <source>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a &lt;code&gt;createElement&lt;/code&gt; method as it&amp;rsquo;s first argument used to create &lt;code&gt;VNode&lt;/code&gt;s.</source>
          <target state="translated">JavaScript의 전체 프로그래밍 기능을 활용할 수있는 문자열 템플릿의 대안. render 함수는 &lt;code&gt;VNode&lt;/code&gt; 를 만드는 데 사용되는 첫 번째 인수이므로 &lt;code&gt;createElement&lt;/code&gt; 메서드를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="36d02f9030c89bce78c3d426c802558bbc1973ce" translate="yes" xml:space="preserve">
          <source>An app instance exposes a subset of the Vue 2 global APIs. The rule of thumb is &lt;em&gt;any APIs that globally mutate Vue's behavior are now moved to the app instance&lt;/em&gt;. Here is a table of the Vue 2 global APIs and their corresponding instance APIs:</source>
          <target state="translated">앱 인스턴스는 Vue 2 글로벌 API의 하위 집합을 노출합니다. 경험상의 규칙은 &lt;em&gt;Vue의 동작을 전역 적으로 변경하는 모든 API가 이제 앱 인스턴스로 이동된다는 것&lt;/em&gt; 입니다. 다음은 Vue 2 글로벌 API 및 해당 인스턴스 API의 표입니다.</target>
        </trans-unit>
        <trans-unit id="56d9594c3b6afdd1342544d2a5f58112661c98c9" translate="yes" xml:space="preserve">
          <source>An application needs to be mounted into a DOM element. For example, if we want to mount a Vue application into &lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;, we should pass &lt;code&gt;#app&lt;/code&gt;:</source>
          <target state="translated">애플리케이션은 DOM 요소에 마운트되어야합니다. 예를 들어 Vue 애플리케이션을 &lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 에 &lt;code&gt;#app&lt;/code&gt; 을 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e70cddb81402ecd32e5708b578322688412f5c7" translate="yes" xml:space="preserve">
          <source>An array of directives.</source>
          <target state="translated">지시문의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="aad46feb893197e823380e42690bcdca813fd97a" translate="yes" xml:space="preserve">
          <source>An async function implicitly returns a Promise, but the cleanup function needs to be registered immediately before the Promise resolves. In addition, Vue relies on the returned Promise to automatically handle potential errors in the Promise chain.</source>
          <target state="translated">비동기 함수는 암시 적으로 Promise를 반환하지만 Promise가 해결되기 직전에 정리 함수를 등록해야합니다. 또한 Vue는 반환 된 Promise를 사용하여 Promise 체인의 잠재적 오류를 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ca3799ca57153370cb0516f1ebcb1401ebe08e12" translate="yes" xml:space="preserve">
          <source>An example of a custom directive using some of these properties:</source>
          <target state="translated">다음 속성 중 일부를 사용하는 사용자 지정 지시문의 예 :</target>
        </trans-unit>
        <trans-unit id="b0d30581a4ac7962ecae5a1d28316366708ba0db" translate="yes" xml:space="preserve">
          <source>An ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or &lt;code&gt;this.$parent&lt;/code&gt; can simplify two components that are already deeply coupled.</source>
          <target state="translated">이상적인 Vue 응용 프로그램은 소품을 내려 놓고 이벤트를 올리는 것입니다. 이 규칙을 준수하면 구성 요소를 훨씬 쉽게 이해할 수 있습니다. 그러나 prop mutation 또는 &lt;code&gt;this.$parent&lt;/code&gt; 가 이미 깊이 결합되어있는 두 가지 구성 요소를 단순화 할 수 있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8f457aa9789280586eabf3b4043968fac51eb9b" translate="yes" xml:space="preserve">
          <source>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don&amp;rsquo;t exist yet! &lt;code&gt;$refs&lt;/code&gt; is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</source>
          <target state="translated">심판 등록 타이밍에 대한 중요한 참고 사항 : 심판 자체는 렌더 기능의 결과로 생성되기 때문에 초기 렌더에서는 액세스 할 수 없습니다. 아직 존재하지 않습니다! &lt;code&gt;$refs&lt;/code&gt; 도 반응성이 없으므로 데이터 바인딩을위한 템플릿에서 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="70f3fe5f25ba8edd1f2191e01296d226f1994362" translate="yes" xml:space="preserve">
          <source>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! &lt;code&gt;$refs&lt;/code&gt; is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</source>
          <target state="translated">참조 등록 타이밍에 대한 중요한 참고 사항 : 참조 자체는 렌더링 기능의 결과로 생성되기 때문에 초기 렌더링에서 액세스 할 수 없습니다. 아직 존재하지 않습니다! &lt;code&gt;$refs&lt;/code&gt; 도 비 반응 적이므로 데이터 바인딩을 위해 템플릿에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bbecd26964624650991d90447203ccd0665ac7d1" translate="yes" xml:space="preserve">
          <source>An object containing application configurations.</source>
          <target state="translated">응용 프로그램 구성을 포함하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="f60d89f5cd0181a6e8c881d5010259e02151ddb3" translate="yes" xml:space="preserve">
          <source>An object containing the following properties.</source>
          <target state="translated">다음 속성을 포함하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b63a82eb5a35c005f930dbdaa504cea629e7d004" translate="yes" xml:space="preserve">
          <source>An object corresponding to the attributes, props and events we would use in a template. Optional</source>
          <target state="translated">템플릿에서 사용할 속성, 소품 및 이벤트에 해당하는 개체입니다. 선택 과목</target>
        </trans-unit>
        <trans-unit id="31adc28bf741f1caac66398ce75f50fb8901e915" translate="yes" xml:space="preserve">
          <source>An object of DOM elements and component instances, registered with &lt;a href=&quot;#ref&quot;&gt;&lt;code&gt;ref&lt;/code&gt; attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 속성으로&lt;/a&gt; 등록 된 DOM 요소 및 컴포넌트 인스턴스의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="ae9ec5ae289062e068fddf7ffa17e903e1a9e7d7" translate="yes" xml:space="preserve">
          <source>An object of DOM elements and component instances, registered with &lt;a href=&quot;../guide/component-template-refs&quot;&gt;&lt;code&gt;ref&lt;/code&gt; attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/component-template-refs&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 속성으로&lt;/a&gt; 등록 된 DOM 요소 및 구성 요소 인스턴스의 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="429233ae8c44c337cc867f9ffe3dabc28329fcda" translate="yes" xml:space="preserve">
          <source>An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.</source>
          <target state="translated">컴포넌트가 수신 한 현재 소품을 나타내는 객체입니다. Vue 인스턴스는 props 객체의 속성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="38d4a53bfc500d7da498f98f1d231b78bdfae66d" translate="yes" xml:space="preserve">
          <source>An object representing the current props a component has received. The component instance proxies access to the properties on its props object.</source>
          <target state="translated">구성 요소가받은 현재 소품을 나타내는 개체입니다. 구성 요소 인스턴스는 해당 props 개체의 속성에 대한 액세스를 프록시합니다.</target>
        </trans-unit>
        <trans-unit id="b854f15df3197587296b2c1985187a344087cda1" translate="yes" xml:space="preserve">
          <source>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call &lt;code&gt;$watch()&lt;/code&gt; for each entry in the object at instantiation.</source>
          <target state="translated">키가 감시 할 표현식이고 값이 해당 콜백 인 객체입니다. 값은 메소드 이름의 문자열이거나 추가 옵션이 포함 된 오브젝트 일 수도 있습니다. Vue 인스턴스는 인스턴스화시 객체의 각 항목에 대해 &lt;code&gt;$watch()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1861a6e34a5d28eb9252c05a2fc6cc98a140eb50" translate="yes" xml:space="preserve">
          <source>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The component instance will call &lt;code&gt;$watch()&lt;/code&gt; for each entry in the object at instantiation. See &lt;a href=&quot;instance-methods#watch&quot;&gt;$watch&lt;/a&gt; for more information about the &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;immediate&lt;/code&gt; and &lt;code&gt;flush&lt;/code&gt; options.</source>
          <target state="translated">키가 관찰 할 표현식이고 값이 해당 콜백 인 객체입니다. 값은 메서드 이름의 문자열이거나 추가 옵션이 포함 된 개체 일 수도 있습니다. 구성 요소 인스턴스는 인스턴스화 할 때 개체의 각 항목에 대해 &lt;code&gt;$watch()&lt;/code&gt; 를 호출 합니다. &lt;code&gt;deep&lt;/code&gt; , &lt;code&gt;immediate&lt;/code&gt; 및 &lt;code&gt;flush&lt;/code&gt; 옵션 에 대한 자세한 내용은 &lt;a href=&quot;instance-methods#watch&quot;&gt;$ watch&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d66b28a0c3c480fee0ad93d29ffb417a189eb3e" translate="yes" xml:space="preserve">
          <source>An object with component options</source>
          <target state="translated">구성 요소 옵션이있는 개체</target>
        </trans-unit>
        <trans-unit id="8556bee67d1ac16eb2bddc45f539ca743c027d08" translate="yes" xml:space="preserve">
          <source>Anchored headings are used very frequently, we should create a component:</source>
          <target state="translated">고정 된 제목은 매우 자주 사용되므로 구성 요소를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="a910bf09a64caf648d8684b0e13f7b12b51b445f" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt; are especially well-suited to this task:</source>
          <target state="translated">그리고 &lt;a href=&quot;render-function#Functional-Components&quot;&gt;기능 컴포넌트&lt;/a&gt; 는이 작업에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="4f2d8a5ea853de2d832e41d30344cf66ad54abde" translate="yes" xml:space="preserve">
          <source>And access scoped slots as functions that return VNodes from &lt;a href=&quot;../api/index#vm-scopedSlots&quot;&gt;&lt;code&gt;this.$scopedSlots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그리고 액세스 기능으로 슬롯 범위와는 반환 v- 노드 &lt;a href=&quot;../api/index#vm-scopedSlots&quot;&gt; &lt;code&gt;this.$scopedSlots&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="06be132e44569998b6713037b4938f2f9326d7b0" translate="yes" xml:space="preserve">
          <source>And another for the index:</source>
          <target state="translated">그리고 색인에 대한 또 다른 것 :</target>
        </trans-unit>
        <trans-unit id="ccd97cfa695145777f87153245644b8bc85629fb" translate="yes" xml:space="preserve">
          <source>And even define methods for use by the parent:</source>
          <target state="translated">부모가 사용할 방법을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7d45958b448393338d03638ac230b5bb7b84ad4e" translate="yes" xml:space="preserve">
          <source>And here is the same bounce in JS using GreenSock:</source>
          <target state="translated">다음은 GreenSock을 사용하는 JS에서 동일한 바운스입니다.</target>
        </trans-unit>
        <trans-unit id="3fe400f8b1de3f59d8a0a26cac0f5d38cdc0768f" translate="yes" xml:space="preserve">
          <source>And in both cases, Vue automatically keeps the page updated, even when &lt;code&gt;blogTitle&lt;/code&gt; changes.</source>
          <target state="translated">두 경우 모두 Vue는 &lt;code&gt;blogTitle&lt;/code&gt; 이 변경 되어도 페이지를 자동으로 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="aa8e03ffca44029ba6d6a5c3e8c8278a8a4a1af8" translate="yes" xml:space="preserve">
          <source>And in the component, target the template using a selector:</source>
          <target state="translated">구성 요소에서 선택기를 사용하여 템플릿을 대상으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="02afd3485814018314fc92f3b2cbf8e1256b1cfe" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;data-date-picker=&quot;activated&quot;&lt;/code&gt; attribute will automatically be added to the root element of &lt;code&gt;bootstrap-date-input&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;data-date-picker=&quot;activated&quot;&lt;/code&gt; 속성은 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 의 루트 요소에 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d0f2b48e78d27ea894b9f9744256fd5b0718f4e" translate="yes" xml:space="preserve">
          <source>And the following data:</source>
          <target state="translated">그리고 다음 데이터 :</target>
        </trans-unit>
        <trans-unit id="c6d1ad79131294b1b2ea6cece145a23b5d1a5f6c" translate="yes" xml:space="preserve">
          <source>And then maybe also translated so that they look like slide transitions:</source>
          <target state="translated">그런 다음 슬라이드 전환처럼 보이도록 번역 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bea4805e289e5266afef44a2c3df305bd6c1471" translate="yes" xml:space="preserve">
          <source>And then the searching functionality:</source>
          <target state="translated">그리고 검색 기능 :</target>
        </trans-unit>
        <trans-unit id="f88e89f891451dac006fc9aa01b950c6d0caecdf" translate="yes" xml:space="preserve">
          <source>And we are done!</source>
          <target state="translated">그리고 우리는 끝났습니다!</target>
        </trans-unit>
        <trans-unit id="01d4821f264f724822eee5ed15bd1dc2f4201faf" translate="yes" xml:space="preserve">
          <source>And we want to display different messages depending on if &lt;code&gt;author&lt;/code&gt; already has some books or not</source>
          <target state="translated">그리고 &lt;code&gt;author&lt;/code&gt; 이미 책을 가지고 있는지 여부에 따라 다른 메시지를 표시하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="4bdf794aeb2b23b094b3034c23079b99a98b7fe1" translate="yes" xml:space="preserve">
          <source>And when you need to reference scoped slots programmatically, they are now unified into the &lt;code&gt;$slots&lt;/code&gt; option.</source>
          <target state="translated">프로그래밍 방식으로 범위가 지정된 슬롯을 참조해야하는 경우 이제 &lt;code&gt;$slots&lt;/code&gt; 옵션 으로 통합됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b9af529f591ec25d3f2779afcadcc8505cb56cf" translate="yes" xml:space="preserve">
          <source>Angular (Formerly known as Angular 2)</source>
          <target state="translated">Angular (이전의 Angular 2)</target>
        </trans-unit>
        <trans-unit id="4127a41ec2530d25dc05e74ba8d8ef42d6dfeb13" translate="yes" xml:space="preserve">
          <source>Angular essentially requires using TypeScript, given that almost all its documentation and learning resources are TypeScript-based. TypeScript has its benefits - static type checking can be very useful for large-scale applications, and can be a big productivity boost for developers with backgrounds in Java and C#.</source>
          <target state="translated">Angular는 거의 모든 문서 및 학습 리소스가 TypeScript 기반이기 때문에 TypeScript를 사용해야합니다. TypeScript는 장점이 있습니다. 정적 형식 검사는 대규모 응용 프로그램에 매우 유용 할 수 있으며 Java 및 C #에 대한 배경 지식이있는 개발자에게는 생산성이 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e44881591b06fbc4a45833b87c07555b78e7ddd2" translate="yes" xml:space="preserve">
          <source>Angular&amp;rsquo;s learning curve is much steeper. The API surface of the framework is huge and as a user you will need to familiarize yourself with a lot more concepts before getting productive. The complexity of Angular is largely due to its design goal of targeting only large, complex applications - but that does make the framework a lot more difficult for less-experienced developers to pick up.</source>
          <target state="translated">Angular의 학습 곡선은 훨씬 가파 릅니다. 프레임 워크의 API 표면은 방대하므로 사용자는 생산성을 높이기 전에 훨씬 더 많은 개념을 숙지해야합니다. Angular의 복잡성은 주로 크고 복잡한 응용 프로그램만을 대상으로하는 설계 목표로 인한 것이지만 경험이 부족한 개발자가 프레임 워크를 훨씬 더 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0bebd6505683a5460e20d1f583af41eb627ff410" translate="yes" xml:space="preserve">
          <source>AngularJS (Angular 1)</source>
          <target state="translated">AngularJS (앵귤러 1)</target>
        </trans-unit>
        <trans-unit id="f27be6768b82160617147c1127846e551b257da7" translate="yes" xml:space="preserve">
          <source>AngularJS has strong opinions about how your applications should be structured, while Vue is a more flexible, modular solution. While this makes Vue more adaptable to a wide variety of projects, we also recognize that sometimes it&amp;rsquo;s useful to have some decisions made for you, so that you can just start coding.</source>
          <target state="translated">AngularJS는 애플리케이션 구성 방식에 대한 강력한 의견을 가지고 있으며 Vue는보다 유연한 모듈 식 솔루션입니다. 이로 인해 Vue는 다양한 프로젝트에보다 적합하게 적응할 수 있지만 코딩을 시작할 수 있도록 결정을 내리는 것이 유용한 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0199e29cf3b3f4d7cda82c53037ac25108e233de" translate="yes" xml:space="preserve">
          <source>AngularJS uses two-way binding between scopes, while Vue enforces a one-way data flow between components. This makes the flow of data easier to reason about in non-trivial applications.</source>
          <target state="translated">AngularJS는 범위간에 양방향 바인딩을 사용하는 반면 Vue는 구성 요소간에 단방향 데이터 흐름을 시행합니다. 따라서 사소한 응용 프로그램에서 데이터 흐름을 쉽게 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89cdaaa526dab7508f980424466958d70c6ea504" translate="yes" xml:space="preserve">
          <source>Animating State with Watchers</source>
          <target state="translated">감시자와 함께 애니메이션 상태</target>
        </trans-unit>
        <trans-unit id="b9aac4781d928e3649da99bc1c240f932325f574" translate="yes" xml:space="preserve">
          <source>Animation at Work by Rachel Nabors (opens new window)</source>
          <target state="translated">Rachel Nabors의 Animation at Work (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="ffd74d60df4081b77abb7e2348f1b1bf3d64777f" translate="yes" xml:space="preserve">
          <source>Annotating Props</source>
          <target state="translated">소품에 주석 달기</target>
        </trans-unit>
        <trans-unit id="a5fe4216ab1a65fba7f939921a81d64835706feb" translate="yes" xml:space="preserve">
          <source>Annotating Return Types</source>
          <target state="translated">반환 타입 주석</target>
        </trans-unit>
        <trans-unit id="272b6c9e9dd12ac041b79affdb0bdc0271614af0" translate="yes" xml:space="preserve">
          <source>Annotating emits</source>
          <target state="translated">주석 달기</target>
        </trans-unit>
        <trans-unit id="fac26fa78a26c835cdff8ea91702976f8d085d17" translate="yes" xml:space="preserve">
          <source>Another advantage of this approach is there will be times when debouncing isn&amp;rsquo;t quite the right wrapper function. For example, when hitting an API for search suggestions, waiting to offer suggestions until after the user has stopped typing for a period of time isn&amp;rsquo;t an ideal experience. What you probably want instead is a &lt;strong&gt;throttling&lt;/strong&gt; function. Now since you&amp;rsquo;re already using a utility library like lodash, refactoring to use its &lt;code&gt;throttle&lt;/code&gt; function instead takes only a few seconds.</source>
          <target state="translated">이 접근법의 또 다른 장점은 디 바운싱이 올바른 랩퍼 기능이 아닌 경우가 있다는 것입니다. 예를 들어 검색 제안에 대한 API를 사용할 때 사용자가 일정 시간 동안 입력을 중단 할 때까지 제안을 기다리는 것은 이상적인 경험이 아닙니다. 아마도 당신이 원하는 것은 &lt;strong&gt;조절&lt;/strong&gt; 기능입니다. lodash와 같은 유틸리티 라이브러리를 이미 사용하고 있으므로 &lt;code&gt;throttle&lt;/code&gt; 기능 을 사용하도록 리팩토링 하는 데 몇 초 밖에 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d95d01a2555e47d48b056b1b9cc033076748074d" translate="yes" xml:space="preserve">
          <source>Another benefit of specifying a &lt;code&gt;name&lt;/code&gt; option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (opens new window)&lt;/a&gt;, unnamed components will show up as &lt;code&gt;&amp;lt;AnonymousComponent&amp;gt;&lt;/code&gt;, which isn't very informative. By providing the &lt;code&gt;name&lt;/code&gt; option, you will get a much more informative component tree.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 옵션 을 지정하는 또 다른 이점 은 디버깅입니다. 명명 된 구성 요소는 더 유용한 경고 메시지를 표시합니다. 또한 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (새 창 열기)&lt;/a&gt; 에서 앱을 검사 할 때 이름이 지정되지 않은 구성 요소가 &lt;code&gt;&amp;lt;AnonymousComponent&amp;gt;&lt;/code&gt; 로 표시 되며 이는 그다지 유익하지 않습니다. &lt;code&gt;name&lt;/code&gt; 옵션 을 제공하면 훨씬 더 많은 정보를 제공하는 구성 요소 트리를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ca4d422cbd550db9e33ff6b547ff5cabe7506b" translate="yes" xml:space="preserve">
          <source>Another benefit of specifying a &lt;code&gt;name&lt;/code&gt; option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, unnamed components will show up as &lt;code&gt;&amp;lt;AnonymousComponent&amp;gt;&lt;/code&gt;, which isn&amp;rsquo;t very informative. By providing the &lt;code&gt;name&lt;/code&gt; option, you will get a much more informative component tree.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 옵션 을 지정하면 얻을 수있는 또 다른 이점 은 디버깅입니다. 명명 된 구성 요소로 인해보다 유용한 경고 메시지가 나타납니다. 또한 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; 에서 앱을 검사 할 때 이름이 지정되지 않은 구성 요소는 &lt;code&gt;&amp;lt;AnonymousComponent&amp;gt;&lt;/code&gt; 로 표시 되며 이는 그리 유익하지 않습니다. &lt;code&gt;name&lt;/code&gt; 옵션 을 제공하면 훨씬 유익한 구성 요소 트리를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31060b2f3ee14e175dd33ab59b19ad27c7e002ff" translate="yes" xml:space="preserve">
          <source>Another change that has been made from 2.x is that the &lt;code&gt;component&lt;/code&gt; option is now renamed to &lt;code&gt;loader&lt;/code&gt; in order to accurately communicate that a component definition cannot be provided directly.</source>
          <target state="translated">2.x에서 변경된 또 다른 변경 사항은 구성 요소 정의를 직접 제공 할 수 없음을 정확하게 전달하기 위해 &lt;code&gt;component&lt;/code&gt; 옵션의 이름이 이제 &lt;code&gt;loader&lt;/code&gt; 로 바뀌 었다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5308008001fa5061e1f04723030a1ce8f47aa8b9" translate="yes" xml:space="preserve">
          <source>Another example is the &lt;code&gt;v-on&lt;/code&gt; directive, which listens to DOM events:</source>
          <target state="translated">또 다른 예는 DOM 이벤트를 수신 하는 &lt;code&gt;v-on&lt;/code&gt; 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="d1ecc65f67e6969ebcc8bbf972265b09018de544" translate="yes" xml:space="preserve">
          <source>Another important difference between these offerings is that Vue&amp;rsquo;s companion libraries for state management and routing (among &lt;a href=&quot;https://github.com/vuejs&quot;&gt;other concerns&lt;/a&gt;) are all officially supported and kept up-to-date with the core library. React instead chooses to leave these concerns to the community, creating a more fragmented ecosystem. Being more popular though, React&amp;rsquo;s ecosystem is considerably richer than Vue&amp;rsquo;s.</source>
          <target state="translated">이 서비스들 사이의 또 다른 중요한 차이점은 Vue의 상태 관리 및 라우팅을위한 동반 라이브러리 ( 공식적으로 &lt;a href=&quot;https://github.com/vuejs&quot;&gt;관심사 포함&lt;/a&gt; )가 모두 공식적으로 지원되며 핵심 라이브러리를 통해 최신 상태로 유지된다는 것입니다. 대신 React는 이러한 우려를 커뮤니티에 맡기고보다 단편적인 생태계를 만듭니다. 그러나 React의 생태계는 Vue보다 훨씬 더 유명합니다.</target>
        </trans-unit>
        <trans-unit id="279abeb88c89906481a812ea27f12adaee86a4e4" translate="yes" xml:space="preserve">
          <source>Another option for conditionally displaying an element is the &lt;code&gt;v-show&lt;/code&gt; directive. The usage is largely the same:</source>
          <target state="translated">요소를 조건부로 표시하는 또 다른 옵션은 &lt;code&gt;v-show&lt;/code&gt; 지시문입니다. 사용법은 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3df284c618aa9b322bcba8cd186336d81e30b6b1" translate="yes" xml:space="preserve">
          <source>Another option is &lt;a href=&quot;https://nativescript-vue.org/&quot;&gt;NativeScript-Vue&lt;/a&gt;, a &lt;a href=&quot;https://www.nativescript.org/&quot;&gt;NativeScript&lt;/a&gt; plugin for building truly native applications using Vue.js.</source>
          <target state="translated">또 다른 옵션은 &lt;a href=&quot;https://nativescript-vue.org/&quot;&gt;Vue.js를&lt;/a&gt; 사용하여 진정한 네이티브 애플리케이션을 빌드하기위한 &lt;a href=&quot;https://www.nativescript.org/&quot;&gt;NativeScript&lt;/a&gt; 플러그인 인 NativeScript-Vue입니다 .</target>
        </trans-unit>
        <trans-unit id="55460035a142e91591751fadc9b8306dd4a61e63" translate="yes" xml:space="preserve">
          <source>Another way of implementing &lt;code&gt;v-model&lt;/code&gt; within this component is to use the ability of &lt;code&gt;computed&lt;/code&gt; properties to define a getter and setter. The &lt;code&gt;get&lt;/code&gt; method should return the &lt;code&gt;modelValue&lt;/code&gt; property and the &lt;code&gt;set&lt;/code&gt; method should emit the corresponding event:</source>
          <target state="translated">이 구성 요소 내에서 &lt;code&gt;v-model&lt;/code&gt; 을 구현하는 또 다른 방법은 &lt;code&gt;computed&lt;/code&gt; 속성 의 기능 을 사용하여 getter 및 setter를 정의하는 것입니다. &lt;code&gt;get&lt;/code&gt; 방법은 반환해야 &lt;code&gt;modelValue&lt;/code&gt; 의 속성과 &lt;code&gt;set&lt;/code&gt; 해당 이벤트를 방출한다 방법 :</target>
        </trans-unit>
        <trans-unit id="c01c2e1f17f76fd0637bdf50179307408d9d2e2f" translate="yes" xml:space="preserve">
          <source>Another way to define templates is inside of a script element with the type &lt;code&gt;text/x-template&lt;/code&gt;, then referencing the template by an id. For example:</source>
          <target state="translated">템플릿을 정의하는 또 다른 방법은 &lt;code&gt;text/x-template&lt;/code&gt; 유형의 script 요소 내부 에서 id로 템플릿을 참조하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cda3e49a97051d5db6b9d25a3a76956d585d8a46" translate="yes" xml:space="preserve">
          <source>Any number of objects can be passed, with properties from later arguments taking precedence. Event listeners are handled specially, as are &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, with the values of these properties being merged rather than overwritten.</source>
          <target state="translated">이후 인수의 속성이 우선적으로 적용되어 원하는 수의 개체를 전달할 수 있습니다. 이벤트 리스너는 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 과 같이 특별히 처리되며 이러한 속성의 값은 덮어 쓰지 않고 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="b2151d681dcbfc67a52e5624c98d86c82b4824c9" translate="yes" xml:space="preserve">
          <source>Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price.</source>
          <target state="translated">이름을 지정할 수있는 모든 값이보기에 유용 할 수 있습니다. 예를 들어, 우리는 얼마나 많은 돈을 절약했는지 알려주는 메시지를 표시하기로 결정할 수 있습니다. 또한 판매 세를 계산하기로 결정할 수도 있지만 최종 가격의 일부가 아닌 별도로 세금을 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62b70f056a0f2de6c9c51efc819c923d57838d8" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;el&lt;/code&gt;, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset&quot;&gt;dataset&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;el&lt;/code&gt; 외에도이 인수는 읽기 전용으로 취급하고 절대 수정하지 않아야합니다. 후크를 통해 정보를 공유해야하는 경우 element의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset&quot;&gt;dataset을&lt;/a&gt; 통해 공유하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ac01b66a4dd4a5c91e508f5f329a0f261f143434" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;el&lt;/code&gt;, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset&quot;&gt;dataset (opens new window)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;el&lt;/code&gt; 외에도 이러한 인수를 읽기 전용으로 취급하고 절대 수정하지 않아야합니다. 후크간에 정보를 공유해야하는 경우 요소의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset&quot;&gt;데이터 세트 (새 창 열기)를&lt;/a&gt; 통해 공유하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6d299c0f48f39d2b0feb39ddbb1885486785bc4c" translate="yes" xml:space="preserve">
          <source>Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:</source>
          <target state="translated">포럼 및 채팅에서 질문에 대답하고 리소스를 공유하는 것 외에도 알고있는 것을 공유하고 확장하는 몇 가지 덜 명백한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c651848ddbd4b45cea72e46e079db8a67dbfce4" translate="yes" xml:space="preserve">
          <source>Application &amp;amp; Component Instances</source>
          <target state="translated">응용 프로그램 및 구성 요소 인스턴스</target>
        </trans-unit>
        <trans-unit id="130186466296873e864ae9570b1660269fdac9ac" translate="yes" xml:space="preserve">
          <source>Application API</source>
          <target state="translated">애플리케이션 API</target>
        </trans-unit>
        <trans-unit id="7f152c5c396a75113ff2b13176410f1a2dc0cddb" translate="yes" xml:space="preserve">
          <source>Application Config</source>
          <target state="translated">애플리케이션 구성</target>
        </trans-unit>
        <trans-unit id="2786f44001e34d7e193a25679dd76ea16e9672fa" translate="yes" xml:space="preserve">
          <source>Apply a global &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; transform to your bundle. This allows the minifier to strip out all the warnings in Vue's source code wrapped in env variable conditional blocks. For example:</source>
          <target state="translated">번들에 전역 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (새 창에서 열림)&lt;/a&gt; 변환을 적용합니다. 이를 통해 minifier는 env 변수 조건 블록에 래핑 된 Vue의 소스 코드에서 모든 경고를 제거 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdd6b99bbdb5d0bd3b9a45910d4fa7d7b8dd9d8a" translate="yes" xml:space="preserve">
          <source>Apply a global &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; transform to your bundle.</source>
          <target state="translated">번들에 글로벌 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; 변환을 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="757dea009fa74f7bf6dcb184ed31259ffcbc037f" translate="yes" xml:space="preserve">
          <source>Apply a global &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; transform to your bundle. This allows the minifier to strip out all the warnings in Vue&amp;rsquo;s source code wrapped in env variable conditional blocks. For example:</source>
          <target state="translated">번들에 글로벌 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; 변환을 적용하십시오 . 이를 통해 축소 기는 env 변수 조건부 블록으로 싸인 Vue의 소스 코드에서 모든 경고를 제거 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="403327cdfd6455034e7a5903a902c785cc738a89" translate="yes" xml:space="preserve">
          <source>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. &lt;strong&gt;Not recommended in application code&lt;/strong&gt;.</source>
          <target state="translated">믹스 인을 전체적으로 적용하면 나중에 생성 된 모든 Vue 인스턴스에 영향을줍니다. 플러그인 작성자가이를 사용하여 사용자 정의 동작을 컴포넌트에 주입 할 수 있습니다. &lt;strong&gt;응용 프로그램 코드에서는 권장되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6943d4aabc589dae21e58eeae637038cbb3955d2" translate="yes" xml:space="preserve">
          <source>Apply a mixin in the whole application scope. Once registered they can be used in the template of any component within the current application. This can be used by plugin authors to inject custom behavior into components. &lt;strong&gt;Not recommended in application code&lt;/strong&gt;.</source>
          <target state="translated">전체 적용 범위에 믹스 인을 적용합니다. 등록한 후에는 현재 응용 프로그램 내의 모든 구성 요소 템플릿에서 사용할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이것은 플러그인 작성자가 사용자 정의 동작을 구성 요소에 삽입하는 데 사용할 수 있습니다. &lt;strong&gt;응용 프로그램 코드에서는 권장되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f4735ef213d3d24765c464d6cd890777f7cf436c" translate="yes" xml:space="preserve">
          <source>Arbitrary Route Properties &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">임의의 경로 속성이 &lt;sup&gt;대체되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="267ad5229d54ec1973232c405c353b0796523fe6" translate="yes" xml:space="preserve">
          <source>Arbitrary route properties must now be scoped under the new meta property, to avoid conflicts with future features. So for example, if you had defined:</source>
          <target state="translated">향후 기능과의 충돌을 피하기 위해 이제 임의 경로 속성을 새 메타 속성으로 범위를 지정해야합니다. 예를 들어, 다음을 정의한 경우 :</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="ff66cc6d677ef24332635378ca4342dd60d4f561" translate="yes" xml:space="preserve">
          <source>Array Change Detection</source>
          <target state="translated">어레이 변경 감지</target>
        </trans-unit>
        <trans-unit id="708e0f765f5d842c0a59b838022e6e808b06e5a7" translate="yes" xml:space="preserve">
          <source>Array Syntax</source>
          <target state="translated">배열 구문</target>
        </trans-unit>
        <trans-unit id="431cfc33d593378c19117ccdb64404a678a59458" translate="yes" xml:space="preserve">
          <source>As a result, once we click the button to open the modal, Vue will correctly render the modal's content as a child of the &lt;code&gt;body&lt;/code&gt; tag.</source>
          <target state="translated">결과적으로 버튼을 클릭하여 모달을 열면 Vue는 모달의 콘텐츠를 &lt;code&gt;body&lt;/code&gt; 태그 의 자식으로 올바르게 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="2d7d3458f0a0c3aac7529c4d1387ffdaf4ba0be7" translate="yes" xml:space="preserve">
          <source>As a result, the only remaining use case for functional components is simple components, such as a component to create a dynamic heading. Otherwise, it is recommended to use stateful components as you normally would.</source>
          <target state="translated">결과적으로 기능 구성 요소에 대한 유일한 사용 사례는 동적 제목을 만드는 구성 요소와 같은 간단한 구성 요소입니다. 그렇지 않으면 평소처럼 상태 저장 구성 요소를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b53469dec094904e072eb3488a323f3d2d279b1c" translate="yes" xml:space="preserve">
          <source>As a result, this means that &lt;code&gt;config.keyCodes&lt;/code&gt; is now also deprecated and will no longer be supported.</source>
          <target state="translated">결과적으로 이는 &lt;code&gt;config.keyCodes&lt;/code&gt; 도 이제 더 이상 사용되지 않으며 더 이상 지원되지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4ab524c1211c73bf04858502f22ef0470f4d2fb6" translate="yes" xml:space="preserve">
          <source>As a rule, remember that:</source>
          <target state="translated">일반적으로 다음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="b059cf6741c0409285deffd2e281e5839db913a8" translate="yes" xml:space="preserve">
          <source>As an example, we&amp;rsquo;ll now walk the migration of a two-way currency filter:</source>
          <target state="translated">예를 들어, 이제 양방향 통화 필터의 마이그레이션을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c7dad05163db61d51ef343a96c387115e0e4b67a" translate="yes" xml:space="preserve">
          <source>As for Vuex, even version 0.8 is compatible with Vue 2, so you&amp;rsquo;re not forced to upgrade. The only reason you may want to upgrade immediately is to take advantage of the new features in Vuex 2, such as modules and reduced boilerplate.</source>
          <target state="translated">Vuex의 경우 버전 0.8조차 Vue 2와 호환되므로 업그레이드하지 않아도됩니다. 즉시 업그레이드하려는 유일한 이유는 Vuex 2의 새로운 기능 (예 : 모듈 및 상용구 감소)을 활용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="af69a0700c77f9910c08f70bc1ad9fd3da6ce652" translate="yes" xml:space="preserve">
          <source>As for the &lt;code&gt;$&lt;/code&gt; prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for &lt;em&gt;private&lt;/em&gt; properties would not be appropriate.</source>
          <target state="translated">에 관해서는 &lt;code&gt;$&lt;/code&gt; 를 위해 그것을 사용 그래서 접두사의 뷰 생태계 내에서의 목적은 사용자에게 노출되는 특수 인스턴스 속성입니다 &lt;em&gt;개인&lt;/em&gt; 속성 것은 적절하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8928a0eece301fdb8d986f28f6779f52d5b80d8c" translate="yes" xml:space="preserve">
          <source>As it&amp;rsquo;s transitioning between the &amp;ldquo;on&amp;rdquo; button and the &amp;ldquo;off&amp;rdquo; button, both buttons are rendered - one transitioning out while the other transitions in. This is the default behavior of &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; - entering and leaving happens simultaneously.</source>
          <target state="translated">&quot;켜기&quot;버튼과 &quot;끄기&quot;버튼 사이를 전환 할 때 두 버튼이 모두 렌더링됩니다. 하나는 전환되고 다른 하나는 전환됩니다. 이것은 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 의 기본 동작이며 , 들어가고 나가는 것이 동시에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a58968f69a702436c24ef2d010ce2409c77d155" translate="yes" xml:space="preserve">
          <source>As it's transitioning between the &quot;on&quot; button and the &quot;off&quot; button, both buttons are rendered - one transitioning out while the other transitions in. This is the default behavior of &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; - entering and leaving happens simultaneously.</source>
          <target state="translated">&quot;on&quot;버튼과 &quot;off&quot;버튼 사이를 전환 할 때 두 버튼이 모두 렌더링됩니다. 하나는 전환되고 다른 하나는 전환됩니다. 이것은 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 의 기본 동작입니다 . 입력과 종료가 동시에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ef4317b45147929e0ddbe9426f277343959730df" translate="yes" xml:space="preserve">
          <source>As of v4.5.0, &lt;code&gt;vue-cli&lt;/code&gt; now provides the built-in option to choose Vue 3 when creating a new project. You can upgrade &lt;code&gt;vue-cli&lt;/code&gt; and run &lt;code&gt;vue create&lt;/code&gt; to create a Vue 3 project today.</source>
          <target state="translated">v4.5.0부터 &lt;code&gt;vue-cli&lt;/code&gt; 는 이제 새 프로젝트를 만들 때 Vue 3을 선택할 수있는 기본 제공 옵션을 제공합니다. 지금 &lt;code&gt;vue-cli&lt;/code&gt; 를 업그레이드 하고 &lt;code&gt;vue create&lt;/code&gt; 를 실행 하여 Vue 3 프로젝트를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d926c9870beb71dbe5afe4d5a4aec59ff016a79" translate="yes" xml:space="preserve">
          <source>As our component grows, it&amp;rsquo;s likely we&amp;rsquo;ll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:</source>
          <target state="translated">구성 요소가 커짐에 따라 게시물의 제목과 내용뿐만 아니라 게시 된 날짜, 의견 등이 필요할 수 있습니다. 각 관련 정보에 대한 소품을 정의하면 매우 성 가실 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="301a8e1a96b0efb19480a241d8d5495a88e81d7c" translate="yes" xml:space="preserve">
          <source>As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.</source>
          <target state="translated">약속 한대로 Pug, Babel (ES2015 모듈 포함) 및 Stylus와 같은 프리 프로세서를 사용하여 더 깨끗하고 기능이 풍부한 구성 요소를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b03d167387b5605a0a6bb9bbf2ea7dda59e896" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;use&lt;/code&gt; global API is no longer available in Vue 3, this method will cease to work and calling &lt;code&gt;Vue.use()&lt;/code&gt; will now trigger a warning. Instead, the end-user will now have to explicitly specify using the plugin on the app instance:</source>
          <target state="translated">는 AS &lt;code&gt;use&lt;/code&gt; 글로벌 API는 뷰 3에서 더 이상 사용할 수 없습니다,이 방법은 작업을 중단하고 호출 &lt;code&gt;Vue.use()&lt;/code&gt; 지금 경고를 트리거합니다. 대신 최종 사용자는 이제 앱 인스턴스에서 플러그인을 사용하여 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="93822eb668e20b3a72d64366b15044afe31b739b" translate="yes" xml:space="preserve">
          <source>As we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.</source>
          <target state="translated">구성 요소가 상점에 속하는 상태를 직접 변경하지 못하고 조치를 수행하도록 상점에 알리는 이벤트를 전달해야하는 규칙을 계속 개발함에 따라 결국 &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; 아키텍처에 도달합니다 . 이 컨벤션의 장점은 상점에 발생하는 모든 상태 돌연변이를 기록하고 돌연변이 로그, 스냅 샷 및 기록 재롤 / 시간 여행과 같은 고급 디버깅 도우미를 구현할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8f2b534877ec67503d1817cd697302690f576a7e" translate="yes" xml:space="preserve">
          <source>As we continue developing the convention, where components are never allowed to directly mutate state that belongs to a store but should instead dispatch events that notify the store to perform actions, we eventually arrive at the &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux (opens new window)&lt;/a&gt; architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.</source>
          <target state="translated">컴포넌트가 스토어에 속한 상태를 직접 변경할 수는 없지만 대신 스토어에 작업을 수행하도록 알리는 이벤트를 전달해야하는 규칙을 계속 개발하면 결국 &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux (새 창 열기)&lt;/a&gt; 아키텍처에 도달합니다 . 이 규칙의 이점은 상점에서 발생하는 모든 상태 변형을 기록하고 변형 로그, 스냅 샷 및 기록 재롤 / 시간 여행과 같은 고급 디버깅 도우미를 구현할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e429605ef74fa34ab46a6d4e088182aea98e60a9" translate="yes" xml:space="preserve">
          <source>As we develop our &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size.</source>
          <target state="translated">&lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소를 개발할 때 일부 기능을 사용하려면 부모와 다시 통신해야 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들어, 블로그 게시물의 텍스트를 확대하고 페이지의 나머지 부분은 기본 크기로 유지하는 접근성 기능을 포함하기로 결정할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="7a95384968f4932d7b5246463d0cff519b6a7b61" translate="yes" xml:space="preserve">
          <source>As we develop our &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:</source>
          <target state="translated">&lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소를 개발할 때 일부 기능을 사용하려면 부모와 통신해야합니다. 예를 들어, 블로그 게시물의 텍스트를 확대하고 나머지 페이지는 기본 크기로 유지하기 위해 접근성 기능을 포함하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="677aa42cad19e243a5a406552c9cdef36f36b15d" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;component-props#prop-casing-camelcase-vs-kebab-case&quot;&gt;props casing&lt;/a&gt;, we recommend using kebab-cased event listeners when you are using in-DOM templates. If you're using string templates, this limitation does not apply.</source>
          <target state="translated">&lt;a href=&quot;component-props#prop-casing-camelcase-vs-kebab-case&quot;&gt;props casing&lt;/a&gt; 과 마찬가지로 in-DOM 템플릿을 사용할 때 케밥 케이스 이벤트 리스너를 사용하는 것이 좋습니다. 문자열 템플릿을 사용하는 경우이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6a3f74af5652088551ae51dbeff194fa3bfa2e1" translate="yes" xml:space="preserve">
          <source>As with Vue&amp;rsquo;s transition components, the data backing state transitions can be updated in real time, which is especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be difficult to conceive of until you&amp;rsquo;ve played with the variables a little.</source>
          <target state="translated">Vue의 트랜지션 구성 요소와 마찬가지로 데이터 백업 상태 트랜지션을 실시간으로 업데이트 할 수있어 프로토 타이핑에 특히 유용합니다! 간단한 SVG 다각형을 사용하더라도 변수를 약간 연주 할 때까지 생각하기 어려운 많은 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="446bdcb2288872778b17c550ae95ceda0f03e6a4" translate="yes" xml:space="preserve">
          <source>As with Vue's transition components, the data backing state transitions can be updated in real time, which is especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be difficult to conceive of until you've played with the variables a little.</source>
          <target state="translated">Vue의 전환 구성 요소와 마찬가지로 데이터 백업 상태 전환을 실시간으로 업데이트 할 수 있으므로 프로토 타이핑에 특히 유용합니다! 단순한 SVG 다각형을 사용하더라도 변수를 조금만 사용하기 전까지는 상상하기 어려운 많은 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44e77060c27c4b30c454259c170d12f7db1f1bf" translate="yes" xml:space="preserve">
          <source>As with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md&quot;&gt;the contributing guide&lt;/a&gt;.</source>
          <target state="translated">모든 프로젝트와 마찬가지로 기여 규칙이 있습니다. 최대한 빨리 도움을 받거나 풀 요청을 수락 할 수 있도록 &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md&quot;&gt;기고 안내서&lt;/a&gt; 를 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="4277c9ab681082594a6c686adbf5a2ea751b7cf3" translate="yes" xml:space="preserve">
          <source>As you can see, &lt;code&gt;v-model&lt;/code&gt;&amp;lsquo;s two-way binding doesn&amp;rsquo;t make sense here. Setting &lt;code&gt;str&lt;/code&gt; to another value in the iterator function will do nothing because it&amp;rsquo;s only a local variable in the function scope.</source>
          <target state="translated">보시다시피 &lt;code&gt;v-model&lt;/code&gt; 의 양방향 바인딩은 여기에서 의미가 없습니다. 반복자 함수에서 &lt;code&gt;str&lt;/code&gt; 을 다른 값으로 설정 하면 함수 범위의 로컬 변수이기 때문에 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f86f35da8609362873eeac8961d84a1980af67be" translate="yes" xml:space="preserve">
          <source>As you can see, in the console we have &lt;code&gt;toVal&lt;/code&gt; and &lt;code&gt;fromVal&lt;/code&gt; printed first from the mixin and then from the &lt;code&gt;app&lt;/code&gt;. We always return &lt;code&gt;fromVal&lt;/code&gt; if it exists, that's why &lt;code&gt;this.$options.custom&lt;/code&gt; is set to &lt;code&gt;hello!&lt;/code&gt; in the end. Let's try to change a strategy to &lt;em&gt;always return a value from the child instance&lt;/em&gt;:</source>
          <target state="translated">보시다시피 콘솔 에서 먼저 mixin에서 &lt;code&gt;toVal&lt;/code&gt; 과 &lt;code&gt;fromVal&lt;/code&gt; 을 인쇄 한 다음 &lt;code&gt;app&lt;/code&gt; 에서 인쇄했습니다 . 존재하는 경우 항상 &lt;code&gt;fromVal&lt;/code&gt; 반환 하므로 &lt;code&gt;this.$options.custom&lt;/code&gt; 이 &lt;code&gt;hello!&lt;/code&gt; 로 설정됩니다 ! 결국. &lt;em&gt;항상 자식 인스턴스에서 값을 반환하도록&lt;/em&gt; 전략을 변경해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="68e217a3fa103d696c6e74b9f87eab8bc71775c3" translate="yes" xml:space="preserve">
          <source>As you can see, the factory function receives a &lt;code&gt;resolve&lt;/code&gt; callback, which should be called when you have retrieved your component definition from the server. You can also call &lt;code&gt;reject(reason)&lt;/code&gt; to indicate the load has failed. The &lt;code&gt;setTimeout&lt;/code&gt; here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&amp;rsquo;s code-splitting feature&lt;/a&gt;:</source>
          <target state="translated">보다시피 팩토리 함수는 서버로부터 컴포넌트 정의를 검색 할 때 호출되어야 하는 &lt;code&gt;resolve&lt;/code&gt; 콜백을 받습니다 . &lt;code&gt;reject(reason)&lt;/code&gt; 를 호출 하여로드가 실패했음을 나타낼 수도 있습니다 . 여기서 &lt;code&gt;setTimeout&lt;/code&gt; 은 데모 용입니다. 구성 요소를 검색하는 방법은 사용자에게 달려 있습니다. 한 가지 권장 방법은 &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack의 코드 분할 기능&lt;/a&gt; 과 함께 비동기 구성 요소를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b4469fc4946675eb3b52eefc4e1deae0b0ecd5e5" translate="yes" xml:space="preserve">
          <source>As you can see, this method accepts a factory function returning a &lt;code&gt;Promise&lt;/code&gt;. Promise's &lt;code&gt;resolve&lt;/code&gt; callback should be called when you have retrieved your component definition from the server. You can also call &lt;code&gt;reject(reason)&lt;/code&gt; to indicate the load has failed.</source>
          <target state="translated">보시다시피이 메서드는 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 팩토리 함수를받습니다 . Promise의 &lt;code&gt;resolve&lt;/code&gt; 콜백은 서버에서 구성 요소 정의를 검색 할 때 호출되어야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 또한 &lt;code&gt;reject(reason)&lt;/code&gt; 를 호출 하여로드가 실패했음을 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b27b282e2f1a441686dd2390d9c4cdad9154bb2" translate="yes" xml:space="preserve">
          <source>As you might notice, it&amp;rsquo;s quite difficult to see which components are specific to the search. Now let&amp;rsquo;s rename the components according to the rule:</source>
          <target state="translated">알다시피 검색에 특정한 구성 요소를 확인하는 것은 매우 어렵습니다. 이제 규칙에 따라 구성 요소의 이름을 바꾸겠습니다.</target>
        </trans-unit>
        <trans-unit id="2fe222c6b4525a2e2ce18af955716bf84e80eb11" translate="yes" xml:space="preserve">
          <source>As you might notice, it's quite difficult to see which components are specific to the search. Now let's rename the components according to the rule:</source>
          <target state="translated">아시다시피 검색과 관련된 구성 요소를 확인하는 것은 매우 어렵습니다. 이제 규칙에 따라 구성 요소의 이름을 변경해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2c7c8cb3256126ff26063df02fbf5c2d122e806e" translate="yes" xml:space="preserve">
          <source>As you&amp;rsquo;ll see above, we just add the slot where we want it to go &amp;ndash; and that&amp;rsquo;s it. We&amp;rsquo;re done!</source>
          <target state="translated">위에서 볼 수 있듯이 원하는 슬롯을 추가하기 만하면됩니다. 끝났습니다!</target>
        </trans-unit>
        <trans-unit id="d8d904d21af5959a36aa96381ac7c16a0b15261b" translate="yes" xml:space="preserve">
          <source>As you'll see above, we use the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; as a placeholder where we want the content to go &amp;ndash; and that's it. We're done!</source>
          <target state="translated">위에서 볼 수 있듯이, 우리 는 콘텐츠를 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 자리 표시 자로 &amp;lt;slot&amp;gt; 을 사용 합니다. 그게 전부입니다. 끝났습니다!</target>
        </trans-unit>
        <trans-unit id="245bafa0153d44f38f0fe4e7da9cafd1e866bd32" translate="yes" xml:space="preserve">
          <source>Asserting Asynchronous Updates</source>
          <target state="translated">비동기 업데이트 확인</target>
        </trans-unit>
        <trans-unit id="20e338624cee29d0effead85b0dd0e70de783b4c" translate="yes" xml:space="preserve">
          <source>Assets</source>
          <target state="translated">Assets</target>
        </trans-unit>
        <trans-unit id="c20e3e21906793ff78c0157e3834f5147fd7b664" translate="yes" xml:space="preserve">
          <source>Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.</source>
          <target state="translated">런타임 Vue 경고에 대한 사용자 정의 핸들러를 지정하십시오. 이것은 개발 중에 만 작동하며 프로덕션에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b7dd9120ca91c830c9b578fa32779c54df5b7b8e" translate="yes" xml:space="preserve">
          <source>Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.</source>
          <target state="translated">컴포넌트 렌더 기능 및 감시자 중에 포착되지 않은 오류에 대한 핸들러를 지정하십시오. 핸들러는 오류 및 Vue 인스턴스와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="846dc727c271fbbb5ae9eec199042602f69ec1a1" translate="yes" xml:space="preserve">
          <source>Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the application instance.</source>
          <target state="translated">구성 요소 렌더링 기능 및 감시자 중에 포착되지 않은 오류에 대한 처리기를 할당합니다. 핸들러는 오류 및 애플리케이션 인스턴스와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd3516207bfa9fc802e7d99d2554ea8842f8c370" translate="yes" xml:space="preserve">
          <source>Assistive Technologies</source>
          <target state="translated">보조 기술</target>
        </trans-unit>
        <trans-unit id="1f65677a6f8971fcdedcedabf6d1fc56a644736c" translate="yes" xml:space="preserve">
          <source>Async Components</source>
          <target state="translated">비동기 부품</target>
        </trans-unit>
        <trans-unit id="582e6084935f72aceab9de2dba0ee5645c7f04b5" translate="yes" xml:space="preserve">
          <source>Async Update Queue</source>
          <target state="translated">비동기 업데이트 큐</target>
        </trans-unit>
        <trans-unit id="ab96635c745b58b85be2f676dc6a76f3e4a4221c" translate="yes" xml:space="preserve">
          <source>Async components are &lt;em&gt;suspensible&lt;/em&gt; by default. This means if it has a &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; in the parent chain, it will be treated as an async dependency of that &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;. In this case, the loading state will be controlled by the &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;, and the component's own loading, error, delay and timeout options will be ignored.</source>
          <target state="translated">비동기 구성 요소는 &lt;em&gt;suspensible&lt;/em&gt; 기본적으로. 그것은이 경우이 방법 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 부모 체인, 그것은 그 종속성 비동기로 처리한다 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; . 이 경우로드 상태는 &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; 에 의해 제어되며 구성 요소 자체의로드, 오류, 지연 및 시간 초과 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="47ede0302fd6bc787b31fdcb73791ef595fb98b3" translate="yes" xml:space="preserve">
          <source>Async components now require &lt;code&gt;defineAsyncComponent&lt;/code&gt; method to be created</source>
          <target state="translated">비동기 구성 요소는 이제 &lt;code&gt;defineAsyncComponent&lt;/code&gt; 메서드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="aad87d6e8c00b32fa186c27488e91c838a266b3b" translate="yes" xml:space="preserve">
          <source>Async is now required for rendering performance.</source>
          <target state="translated">렌더링 성능을 위해 비동기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="66da5414bc3e62fe79d78edfd1fc4676709e0d5b" translate="yes" xml:space="preserve">
          <source>At the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax:</source>
          <target state="translated">Vue.js의 핵심에는 간단한 템플릿 구문을 사용하여 선언적으로 데이터를 DOM에 렌더링 할 수있는 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4a475bf74fd33040278d881bd3eae2ccb03e6c" translate="yes" xml:space="preserve">
          <source>At the very least, you&amp;rsquo;ll want to include the post&amp;rsquo;s content:</source>
          <target state="translated">최소한 게시물의 내용을 포함하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd25e6ff7eedb72d30f8f53d41ba4a9b33bf7f4a" translate="yes" xml:space="preserve">
          <source>At this moment, Weex is still in active development and is not as mature and battle-tested as React Native, but its development is driven by the production needs of the largest e-commerce business in the world, and the Vue team will also actively collaborate with the Weex team to ensure a smooth experience for Vue developers.</source>
          <target state="translated">현재 Weex는 여전히 활발한 개발을 진행하고 있으며 React Native만큼 성숙하고 전투 테스트를 거치지 않았지만, 개발은 세계 최대 전자 상거래 비즈니스의 생산 요구에 따라 이루어지며 Vue 팀도 적극적으로 노력할 것입니다 Vue 개발자에게 원활한 경험을 보장하기 위해 Weex 팀과 협력하십시오.</target>
        </trans-unit>
        <trans-unit id="2ae82b5d7365e10184a3d194c06da7efdb526826" translate="yes" xml:space="preserve">
          <source>At this point you probably already know the drill, so let&amp;rsquo;s skip to the end and migrate the leftover filtering functionality. We don&amp;rsquo;t really need to get into the implementation details as it&amp;rsquo;s not the point of this guide.</source>
          <target state="translated">이 시점에서 이미 드릴을 알고있을 것이므로 끝으로 건너 뛰고 남은 필터링 기능을 마이그레이션 해 보겠습니다. 이 가이드의 요점이 아니므로 구현 세부 사항에 대해 자세히 살펴볼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5419a18af94811377577a489eb8cec03778592a5" translate="yes" xml:space="preserve">
          <source>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays &lt;code&gt;message&lt;/code&gt; in reverse. The problem is made worse when you want to include the reversed message in your template more than once.</source>
          <target state="translated">이 시점에서 템플릿은 더 이상 단순하고 선언적이지 않습니다. &lt;code&gt;message&lt;/code&gt; 를 반대로 표시한다는 것을 깨닫기 전에 잠시 기다려야합니다 . 반전 된 메시지를 템플리트에 두 번 이상 포함하려는 경우 문제점이 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="a8aa3b3c574faa254ff30f4af5d773750b2a8ccc" translate="yes" xml:space="preserve">
          <source>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it performs a calculation depending on &lt;code&gt;author.books&lt;/code&gt;. The problem is made worse when you want to include this calculation in your template more than once.</source>
          <target state="translated">이 시점에서 템플릿은 더 이상 단순하고 선언적이지 않습니다. &lt;code&gt;author.books&lt;/code&gt; 에 따라 계산을 수행한다는 것을 깨닫기 전에 잠시 봐야 합니다. 이 계산을 템플릿에 두 번 이상 포함하려는 경우 문제가 더 악화됩니다.</target>
        </trans-unit>
        <trans-unit id="282508b59fa6f1279fded58d092f544b220e4742" translate="yes" xml:space="preserve">
          <source>Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.</source>
          <target state="translated">요소에 이벤트 리스너를 연결합니다. 이벤트 유형은 인수로 표시됩니다. 표현식은 메소드 이름, 인라인 명령문이거나 수정자가있는 경우 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f8647b29ded8c6aa47aa4b9ca700c81275a5426" translate="yes" xml:space="preserve">
          <source>Attempting to check for changes of properties in a deeply nested object or array will still require the &lt;code&gt;deep&lt;/code&gt; option to be true:</source>
          <target state="translated">깊이 중첩 된 객체 또는 배열의 속성 변경을 확인하려면 여전히 &lt;code&gt;deep&lt;/code&gt; 옵션이 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="5755695133197f383f55fe6a165f21b2ad0c3c16" translate="yes" xml:space="preserve">
          <source>Attribute Coercion Behavior</source>
          <target state="translated">속성 강제 동작</target>
        </trans-unit>
        <trans-unit id="0c991694965b0f231085d1352058af6d1c20ccc5" translate="yes" xml:space="preserve">
          <source>Attribute Inheritance</source>
          <target state="translated">속성 상속</target>
        </trans-unit>
        <trans-unit id="aa31a131805ede2ba027883a1f2407c6a5c7793f" translate="yes" xml:space="preserve">
          <source>Attribute Inheritance on Multiple Root Nodes</source>
          <target state="translated">여러 루트 노드의 속성 상속</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="2d1447b83b4b4f812b2b940155f5db517c72245a" translate="yes" xml:space="preserve">
          <source>Attributes bound to a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element are called &lt;strong&gt;slot props&lt;/strong&gt;. Now, in the parent scope, we can use &lt;code&gt;v-slot&lt;/code&gt; with a value to define a name for the slot props we&amp;rsquo;ve been provided:</source>
          <target state="translated">&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에 바인딩 된 속성을 &lt;strong&gt;슬롯 props&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 이제 상위 범위에서 &lt;code&gt;v-slot&lt;/code&gt; 을 값과 함께 사용하여 제공된 슬롯 소품의 이름을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84a37dbdd5aed3065f50c5bbddaedcd842ae2b91" translate="yes" xml:space="preserve">
          <source>Attributes bound to a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element are called &lt;strong&gt;slot props&lt;/strong&gt;. Now, in the parent scope, we can use &lt;code&gt;v-slot&lt;/code&gt; with a value to define a name for the slot props we've been provided:</source>
          <target state="translated">&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에 바인딩 된 속성을 &lt;strong&gt;슬롯 소품&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 이제 부모 범위에서 값이있는 &lt;code&gt;v-slot&lt;/code&gt; 을 사용하여 제공된 슬롯 소품의 이름을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="992e4bbe51b2e7365584c6a1a46ab551923a68d8" translate="yes" xml:space="preserve">
          <source>Attributes coercion strategy changed</source>
          <target state="translated">속성 강제 전략이 변경됨</target>
        </trans-unit>
        <trans-unit id="0459983436456e9881a22198841fc54994764174" translate="yes" xml:space="preserve">
          <source>Attributes in &lt;code&gt;$attrs&lt;/code&gt; are no longer automatically added to the root element, leaving it to the developer to decide where to add them.</source>
          <target state="translated">&lt;code&gt;$attrs&lt;/code&gt; 속성 은 더 이상 루트 요소에 자동으로 추가되지 않으므로 개발자가 추가 할 위치를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6784f96c452a0c7bc91364bfd3f389e53aeacd0d" translate="yes" xml:space="preserve">
          <source>Augmenting Types for Use with Plugins</source>
          <target state="translated">플러그인과 함께 사용하기위한 기능 보강 유형</target>
        </trans-unit>
        <trans-unit id="c827e43d1c41fb3949b8ae5df02f4e522baf0305" translate="yes" xml:space="preserve">
          <source>Authoring Tool Accessibility Guidelines (ATAG) (opens new window)</source>
          <target state="translated">저작 도구 접근성 지침 (ATAG) (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="33d277414317dcbde6c548c863a000f272b2ba1b" translate="yes" xml:space="preserve">
          <source>Auto-prefixing</source>
          <target state="translated">Auto-prefixing</target>
        </trans-unit>
        <trans-unit id="8480e807d8afb131491cf0856a67ff1f4d11a3a3" translate="yes" xml:space="preserve">
          <source>Automated Tools</source>
          <target state="translated">자동화 도구</target>
        </trans-unit>
        <trans-unit id="e62f264454fa035298bd4525a87eab2e74959394" translate="yes" xml:space="preserve">
          <source>Automatic Global Registration of Base Components</source>
          <target state="translated">기본 컴포넌트의 자동 글로벌 등록</target>
        </trans-unit>
        <trans-unit id="d5811d62e717b2d7a44720d5443324bf72b9662e" translate="yes" xml:space="preserve">
          <source>Autonomous Custom Elements</source>
          <target state="translated">자율 사용자 지정 요소</target>
        </trans-unit>
        <trans-unit id="5fada8c65210fc29160102a7e4e88dbb24309041" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;v-if&lt;/code&gt; with &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">않도록 &lt;code&gt;v-if&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c6cd7e6129cb702932bff65fb9661126f68211bd" translate="yes" xml:space="preserve">
          <source>Avoid using placeholders as they can confuse many users.</source>
          <target state="translated">많은 사용자에게 혼란을 줄 수 있으므로 자리 표시자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="677c52df1b8d2a0a67237f2cc1537f7da03218f1" translate="yes" xml:space="preserve">
          <source>Avoid v-if with v-for</source>
          <target state="translated">v-for로 v-if를 피하십시오</target>
        </trans-unit>
        <trans-unit id="c52d0351c06571b65129935f4c84f34fb5940839" translate="yes" xml:space="preserve">
          <source>Back to our example, let's create a reactive &lt;code&gt;repositories&lt;/code&gt; variable:</source>
          <target state="translated">예제로 돌아가서 반응 &lt;code&gt;repositories&lt;/code&gt; 변수를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="042fd1df7a4a13c0287f65bf8289380a720a781f" translate="yes" xml:space="preserve">
          <source>Base Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="ed5305a1a3c7ea2038ed6b0922e96b3a5d1d42ab" translate="yes" xml:space="preserve">
          <source>Base component names</source>
          <target state="translated">기본 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="afb696d8130130ecabb5326a69e2eb71d47369d7" translate="yes" xml:space="preserve">
          <source>Base component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">기본 구성 요소 이름을 &lt;sup&gt;적극 권장합니다&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="bbf61c9d812772ea35cf603e7164154bde0b32d5" translate="yes" xml:space="preserve">
          <source>Basic Reactivity APIs</source>
          <target state="translated">기본 반응성 API</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="2fbd5ba03b81757d77bfd8f406e44d25ef0312f6" translate="yes" xml:space="preserve">
          <source>Basics of Composition API</source>
          <target state="translated">Composition API의 기초</target>
        </trans-unit>
        <trans-unit id="ebbf3c729056bf3f76dc2c04caed458d2d3f6887" translate="yes" xml:space="preserve">
          <source>Be more specific about what state should trigger the watcher to re-run;</source>
          <target state="translated">감시자가 다시 실행되도록 트리거해야하는 상태에 대해 더 구체적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5cf9ea44ab59181a8666caafd4a3e3d084bebdae" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setup&lt;/code&gt; is run around the &lt;code&gt;beforeCreate&lt;/code&gt; and &lt;code&gt;created&lt;/code&gt; lifecycle hooks, you do not need to explicitly define them. In other words, any code that would be written inside those hooks should be written directly in the &lt;code&gt;setup&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 은 &lt;code&gt;beforeCreate&lt;/code&gt; 및 &lt;code&gt;created&lt;/code&gt; 수명주기 후크를 중심으로 실행 되므로 명시 적으로 정의 할 필요가 없습니다. 즉, 이러한 후크 내부에 작성되는 모든 코드는 &lt;code&gt;setup&lt;/code&gt; 함수 에서 직접 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1bc019e851603df6ba175b433b3fe2a1197430af" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;v-if&lt;/code&gt; is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use &lt;code&gt;v-if&lt;/code&gt; on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, which serves as an invisible wrapper. The final rendered result will not include the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">때문에 &lt;code&gt;v-if&lt;/code&gt; 지시어는, 단일 요소에 첨부되어야한다. 그러나 둘 이상의 요소를 전환하려면 어떻게해야합니까? 이 경우 보이지 않는 래퍼 역할 을하는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소 에 &lt;code&gt;v-if&lt;/code&gt; 를 사용할 수 있습니다 . 최종 렌더링 결과에는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb0dc0725f59ff24b2ec784f60eede2c055c6414" translate="yes" xml:space="preserve">
          <source>Because of a &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/38845&quot;&gt;design limitation (opens new window)&lt;/a&gt; in TypeScript when it comes to type inference of function expressions, you have to be careful with &lt;code&gt;validators&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; values for objects and arrays:</source>
          <target state="translated">함수 표현식의 유형 추론과 관련하여 TypeScript 의 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/38845&quot;&gt;디자인 제한 (새 창&lt;/a&gt; 에서 열림 ) 으로 인해 객체 및 배열의 &lt;code&gt;validators&lt;/code&gt; 와 &lt;code&gt;default&lt;/code&gt; 주의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a372bf443e6b55ba392d12b1ef28e77d0fe75e24" translate="yes" xml:space="preserve">
          <source>Because of the circular nature of Vue&amp;rsquo;s declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like &lt;code&gt;render&lt;/code&gt; and those in &lt;code&gt;computed&lt;/code&gt;.</source>
          <target state="translated">Vue 선언 파일의 순환 특성으로 인해 TypeScript는 특정 메소드의 유형을 유추하는 데 어려움을 겪을 수 있습니다. 따라서 &lt;code&gt;render&lt;/code&gt; 와 같은 메소드 및 &lt;code&gt;computed&lt;/code&gt; 의 메소드에 리턴 유형에 주석을 달아야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="139a35ae0b306d90f72a646c330a37c8e32695d4" translate="yes" xml:space="preserve">
          <source>Because of the circular nature of Vue&amp;rsquo;s declaration files, TypeScript may have difficulties inferring the types of computed. For this reason, you may need to annotate the return type of computed properties.</source>
          <target state="translated">Vue 선언 파일의 순환 특성으로 인해 TypeScript는 계산 된 유형을 추론하는 데 어려움을 겪을 수 있습니다. 이러한 이유로 계산 된 속성의 반환 유형에 주석을 추가해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="871f81427d357a492d238d81b8d955f6bcc45a9a" translate="yes" xml:space="preserve">
          <source>Because the component instance is not yet created when &lt;code&gt;setup&lt;/code&gt; is executed, there is no &lt;code&gt;this&lt;/code&gt; inside a &lt;code&gt;setup&lt;/code&gt; option. This means, with the exception of &lt;code&gt;props&lt;/code&gt;, you won't be able to access any properties declared in the component &amp;ndash; &lt;strong&gt;local state&lt;/strong&gt;, &lt;strong&gt;computed properties&lt;/strong&gt; or &lt;strong&gt;methods&lt;/strong&gt;.</source>
          <target state="translated">때 구성 요소 인스턴스가 아직 생성되지 않기 때문에 &lt;code&gt;setup&lt;/code&gt; 실행되고, 더이없는 &lt;code&gt;this&lt;/code&gt; , 안쪽 &lt;code&gt;setup&lt;/code&gt; 옵션을 선택합니다. 즉, &lt;code&gt;props&lt;/code&gt; 를 제외하고 &lt;strong&gt;로컬 상태&lt;/strong&gt; , &lt;strong&gt;계산 된 속성&lt;/strong&gt; 또는 &lt;strong&gt;메서드&lt;/strong&gt; 와 같은 구성 요소에 선언 된 속성에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8d354e1f0395c2c7bde80f3d0635afd447b1534e" translate="yes" xml:space="preserve">
          <source>Become a Community Leader</source>
          <target state="translated">커뮤니티 리더가 되십시오</target>
        </trans-unit>
        <trans-unit id="55afcdde181ce3a9452e5047a10f6b50159b446a" translate="yes" xml:space="preserve">
          <source>Before v2.1.8, we had two transition classes for each transition direction: initial and active states.</source>
          <target state="translated">v2.1.8 이전에는 각 전환 방향에 대해 초기 및 활성 상태의 두 가지 전환 클래스가있었습니다.</target>
        </trans-unit>
        <trans-unit id="799bed431f75d62e2ee7199cced467223a9ef08b" translate="yes" xml:space="preserve">
          <source>Before we dive into render functions, it&amp;rsquo;s important to know a little about how browsers work. Take this HTML for example:</source>
          <target state="translated">렌더링 함수에 들어가기 전에 브라우저 작동 방식에 대해 조금 알아야합니다. 이 HTML을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f9e94c53c5aed844febb6a90128d5a6fb0a5085d" translate="yes" xml:space="preserve">
          <source>Behind the scenes, templates use &lt;code&gt;resolveDynamicComponent&lt;/code&gt; to implement the &lt;code&gt;is&lt;/code&gt; attribute. We can use the same function if we need all the flexibility provided by &lt;code&gt;is&lt;/code&gt; in our &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">이면에서 템플릿은 &lt;code&gt;resolveDynamicComponent&lt;/code&gt; 를 사용 하여 &lt;code&gt;is&lt;/code&gt; 속성 을 구현 합니다. 에서 제공하는 모든 유연성 &lt;code&gt;is&lt;/code&gt; &lt;code&gt;render&lt;/code&gt; 함수 에 필요한 경우 동일한 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21fefc2aed895fea23a9fcaa8f08933e083c11cd" translate="yes" xml:space="preserve">
          <source>Being so similar in scope, we&amp;rsquo;ve put more time into fine-tuning this comparison than any other. We want to ensure not only technical accuracy, but also balance. We point out where React outshines Vue, for example in the richness of their ecosystem and abundance of their custom renderers.</source>
          <target state="translated">범위가 매우 유사하기 때문에, 우리는이 비교를 다른 어떤 것보다 미세 조정하는 데 더 많은 시간을 투자했습니다. 우리는 기술적 정확성뿐만 아니라 균형을 유지하고자합니다. 우리는 React가 Vue를 능가하는 곳, 예를 들어 풍부한 생태계와 풍부한 커스텀 렌더러를 지적합니다.</target>
        </trans-unit>
        <trans-unit id="bd6db4741fd073ae0a7d8447883e2b90ecb5347c" translate="yes" xml:space="preserve">
          <source>Below is a diagram for the instance lifecycle. You don&amp;rsquo;t need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.</source>
          <target state="translated">아래는 인스턴스 수명주기에 대한 다이어그램입니다. 현재 진행중인 모든 것을 완전히 이해할 필요는 없지만 더 많이 배우고 구축 할 때 유용한 참조 자료가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc1280e6b9b97054a2028ddc4d9c5df4ef575b27" translate="yes" xml:space="preserve">
          <source>Below is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.</source>
          <target state="translated">아래는 인스턴스 수명주기에 대한 다이어그램입니다. 지금 진행되는 모든 것을 완전히 이해할 필요는 없지만 더 많이 배우고 구축하면 유용한 참고 자료가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="235d0b8767114f70c53f2b4e152b46e080f3734e" translate="yes" xml:space="preserve">
          <source>Below is an example of our &lt;code&gt;capitalize&lt;/code&gt; filter being used:</source>
          <target state="translated">다음은 사용되는 &lt;code&gt;capitalize&lt;/code&gt; 필터 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="118c169de4184a1a92bb4146dfa31b6b77e2b0aa" translate="yes" xml:space="preserve">
          <source>Better performance. Riot &lt;a href=&quot;http://riotjs.com/compare/#virtual-dom-vs-expressions-binding&quot;&gt;traverses a DOM tree&lt;/a&gt; rather than using a virtual DOM, so suffers from the same performance issues as AngularJS.</source>
          <target state="translated">더 나은 성능. Riot 은 가상 DOM을 사용하지 않고 &lt;a href=&quot;http://riotjs.com/compare/#virtual-dom-vs-expressions-binding&quot;&gt;DOM 트리를 통과&lt;/a&gt; 하므로 AngularJS와 동일한 성능 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ae2c0a84c2ea1d6b5e9539d414cc3dd5fd955525" translate="yes" xml:space="preserve">
          <source>Beyond a console log, we could do anything here we wish. We could even &lt;em&gt;not&lt;/em&gt; return the real value if we wanted to. This is what makes Proxies so powerful for creating APIs.</source>
          <target state="translated">콘솔 로그 외에 우리가 원하는 것은 무엇이든 할 수 있습니다. 우리 가 원하면 실제 값을 반환 할 수도 &lt;em&gt;없습니다&lt;/em&gt; . 이것이 프록시를 API 생성에 매우 강력하게 만드는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="009817effc0ffc4d86c347b50db0aff9a2aea858" translate="yes" xml:space="preserve">
          <source>Beyond the &lt;code&gt;scoped&lt;/code&gt; attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the &lt;code&gt;button&lt;/code&gt;, &lt;code&gt;btn&lt;/code&gt;, or &lt;code&gt;icon&lt;/code&gt; class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. &lt;code&gt;ButtonClose-icon&lt;/code&gt;) can provide some protection.</source>
          <target state="translated">&lt;code&gt;scoped&lt;/code&gt; 속성 외에도 고유 클래스 이름을 사용하면 타사 CSS가 자신의 HTML에 적용되지 않도록 할 수 있습니다. 예를 들어, 많은 프로젝트는 &lt;code&gt;button&lt;/code&gt; , &lt;code&gt;btn&lt;/code&gt; 또는 &lt;code&gt;icon&lt;/code&gt; 클래스 이름을 사용하므로 BEM과 같은 전략을 사용하지 않더라도 앱별 및 / 또는 구성 요소 별 접두사 (예 : &lt;code&gt;ButtonClose-icon&lt;/code&gt; )를 추가하면 일부 보호 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="515a429282336e463c99dec820735d887010c8f4" translate="yes" xml:space="preserve">
          <source>Bind the &lt;code&gt;value&lt;/code&gt; attribute to a &lt;code&gt;value&lt;/code&gt; prop</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 속성을 &lt;code&gt;value&lt;/code&gt; prop에 바인딩</target>
        </trans-unit>
        <trans-unit id="9f3bcad3e4efb73a51f1a6c02686685ac122961f" translate="yes" xml:space="preserve">
          <source>Bind the &lt;code&gt;value&lt;/code&gt; attribute to the &lt;code&gt;modelValue&lt;/code&gt; prop</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 속성을 &lt;code&gt;modelValue&lt;/code&gt; prop에 바인드하십시오.</target>
        </trans-unit>
        <trans-unit id="6580d0d46a0e41a64a6ba66b0193a84a7e1f821c" translate="yes" xml:space="preserve">
          <source>Binding HTML Classes</source>
          <target state="translated">HTML 클래스 바인딩</target>
        </trans-unit>
        <trans-unit id="6ee002dad41000728304505b221bb8c5fb147e3d" translate="yes" xml:space="preserve">
          <source>Binding Inline Styles</source>
          <target state="translated">인라인 스타일 바인딩</target>
        </trans-unit>
        <trans-unit id="f1ee008a1926025b19fdd56f5373aa3a7d9318ac" translate="yes" xml:space="preserve">
          <source>Binding Native Events to Components</source>
          <target state="translated">컴포넌트에 네이티브 이벤트 바인딩</target>
        </trans-unit>
        <trans-unit id="537f5b14e1b4cdf2b7f2e09f194e7c0864d30d5c" translate="yes" xml:space="preserve">
          <source>Binding expression</source>
          <target state="translated">결합 식</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="f2e3f71b1d3e19f2e9daec1ac68138e7180590dc" translate="yes" xml:space="preserve">
          <source>Both React and Vue are exceptionally and similarly fast, so speed is unlikely to be a deciding factor in choosing between them. For specific metrics though, check out this &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;3rd party benchmark&lt;/a&gt;, which focuses on raw render/update performance with very simple component trees.</source>
          <target state="translated">React와 Vue는 예외적으로 비슷하고 빠르기 때문에 속도를 선택하는 데 결정적인 요소는 아닙니다. 특정 메트릭에 대해서는이 간단한 &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;타사 벤치 마크를&lt;/a&gt; 확인하십시오.이 벤치 마크 는 매우 간단한 컴포넌트 트리를 사용하여 원시 렌더링 / 업데이트 성능에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="2e1f44731f0d8bd48449467011ad127d990bba49" translate="yes" xml:space="preserve">
          <source>Both Vuex 1.0 and 2.0:</source>
          <target state="translated">Vuex 1.0과 2.0 :</target>
        </trans-unit>
        <trans-unit id="17a36c9d72454994e76feb1d172501d1710cbea3" translate="yes" xml:space="preserve">
          <source>Both callbacks will receive a debugger event which contains information on the dependency in question. It is recommended to place a &lt;code&gt;debugger&lt;/code&gt; statement in these callbacks to interactively inspect the dependency:</source>
          <target state="translated">두 콜백 모두 해당 종속성에 대한 정보가 포함 된 디버거 이벤트를 수신합니다. 종속성을 대화식으로 검사하려면 이러한 콜백에 &lt;code&gt;debugger&lt;/code&gt; 문 을 배치하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8281ab3deb811a80b50de14c008ad41be7252410" translate="yes" xml:space="preserve">
          <source>Both frameworks are exceptionally fast, with very similar metrics on benchmarks. You can &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;browse specific metrics&lt;/a&gt; for a more granular comparison, but speed is unlikely to be a deciding factor.</source>
          <target state="translated">두 프레임 워크 모두 벤치 마크에서 매우 유사한 메트릭으로 매우 빠릅니다. 보다 세부적인 비교를 위해 &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;특정 메트릭&lt;/a&gt; 을 찾아 볼 수 있지만 속도가 결정적인 요소는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1f688a06e547b5c3a43787858bd62f64749948d7" translate="yes" xml:space="preserve">
          <source>Bower</source>
          <target state="translated">Bower</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">브레이킹 체인지</target>
        </trans-unit>
        <trans-unit id="b870bd9f96d89dded8ea0d87740c482adb729a24" translate="yes" xml:space="preserve">
          <source>Bringing Designs to Life</source>
          <target state="translated">생생한 디자인</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="9e171a4486bb0f587cd37fe2753caa9f12125e40" translate="yes" xml:space="preserve">
          <source>Browserify + vueify</source>
          <target state="translated">Browserify + vueify</target>
        </trans-unit>
        <trans-unit id="c258b04191cb6bda4f50b74112945bab9f2e97a3" translate="yes" xml:space="preserve">
          <source>Browserify + vueify (opens new window)</source>
          <target state="translated">Browserify + vueify (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="9573e2ae84ff104c9fe89518fb7780ffa4eb8a83" translate="yes" xml:space="preserve">
          <source>Buffering the callback not only improves performance but also helps to ensure data consistency. The watchers won't be triggered until the code performing the data updates has finished.</source>
          <target state="translated">콜백을 버퍼링하면 성능이 향상 될뿐만 아니라 데이터 일관성을 보장하는 데 도움이됩니다. 감시자는 데이터 업데이트를 수행하는 코드가 완료 될 때까지 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eb0e71df375fcecff87eff0451b2781fcf64793" translate="yes" xml:space="preserve">
          <source>Building with rollup</source>
          <target state="translated">롤업으로 빌드</target>
        </trans-unit>
        <trans-unit id="34e1fd3d1854d4d8ca0be8b74bcfe2caf4bb9209" translate="yes" xml:space="preserve">
          <source>Built-In Components</source>
          <target state="translated">내장 부품</target>
        </trans-unit>
        <trans-unit id="162a059b43b2eb2bd569ff7fb65fbf91817157e2" translate="yes" xml:space="preserve">
          <source>Built-In Directives</source>
          <target state="translated">내장 지시어</target>
        </trans-unit>
        <trans-unit id="a8f47abf8ffa59d09613aa3f7f6e2688d3011aba" translate="yes" xml:space="preserve">
          <source>Built-In Text Filters &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">내장 텍스트 필터가 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6408bfefa5794bb4225a8f01f57427e9c8517b2c" translate="yes" xml:space="preserve">
          <source>Built-in Components</source>
          <target state="translated">내장 구성 요소</target>
        </trans-unit>
        <trans-unit id="9c4dc1b45e6084c850d989f2c78a6b12f0cec61a" translate="yes" xml:space="preserve">
          <source>Built-in Components - keep-alive</source>
          <target state="translated">내장 구성 요소-연결 유지</target>
        </trans-unit>
        <trans-unit id="41b78508b841d9407084d6b260bac2accd739e91" translate="yes" xml:space="preserve">
          <source>Bundling &lt;code&gt;umd&lt;/code&gt; and &lt;code&gt;cjs&lt;/code&gt; modules</source>
          <target state="translated">&lt;code&gt;umd&lt;/code&gt; 및 &lt;code&gt;cjs&lt;/code&gt; 모듈 번들링</target>
        </trans-unit>
        <trans-unit id="4d99e91ce27c1a20488a6c7225bd6ea5ba914485" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, not being part of &lt;code&gt;$attrs&lt;/code&gt;, will still be applied to the component's root element:</source>
          <target state="translated">그러나 &lt;code&gt;$attrs&lt;/code&gt; 일부가 아닌 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 은 구성 요소의 루트 요소에 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="778c689652e96bcb2a87cf734267e7b5bb2b87d5" translate="yes" xml:space="preserve">
          <source>But a key difference to lifecycle hooks is that &lt;code&gt;watch()&lt;/code&gt; and &lt;code&gt;watchEffect()&lt;/code&gt; effects are run &lt;em&gt;before&lt;/em&gt; the DOM is mounted or updated so the template ref hasn't been updated when the watcher runs the effect:</source>
          <target state="translated">그러나 수명주기 후크의 주요 차이점은 &lt;code&gt;watch()&lt;/code&gt; 및 &lt;code&gt;watchEffect()&lt;/code&gt; 효과는 DOM이 탑재되거나 업데이트 &lt;em&gt;되기 전에&lt;/em&gt; 실행 되므로 감시자가 효과를 실행할 때 템플릿 참조가 업데이트되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9382d146fcef9840c5aeec093e3c39405d284d11" translate="yes" xml:space="preserve">
          <source>But if we provide content:</source>
          <target state="translated">그러나 콘텐츠를 제공하는 경우 :</target>
        </trans-unit>
        <trans-unit id="6bc24e1b15b8172ffcabfcd993bddbbe5af96753" translate="yes" xml:space="preserve">
          <source>But in Webpack 3 and earlier, you&amp;rsquo;ll need to use &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt;:</source>
          <target state="translated">그러나 Webpack 3 이하에서는 &lt;a href=&quot;https://webpack.js.org/plugins/define-plugin/&quot;&gt;DefinePlugin&lt;/a&gt; 을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ae153969b9942e56a9bac5d741bc625281e374" translate="yes" xml:space="preserve">
          <source>But sometimes we may want to bind the value to a dynamic property on the Vue instance. We can use &lt;code&gt;v-bind&lt;/code&gt; to achieve that. In addition, using &lt;code&gt;v-bind&lt;/code&gt; allows us to bind the input value to non-string values.</source>
          <target state="translated">그러나 때로는 Vue 인스턴스의 동적 속성에 값을 바인딩하려고 할 수 있습니다. &lt;code&gt;v-bind&lt;/code&gt; 를 사용 하여이를 달성 할 수 있습니다 . 또한 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하면 입력 값을 문자열이 아닌 값에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="135f8d741a28fbe7b3289fd3c1f0c18c78d43ac1" translate="yes" xml:space="preserve">
          <source>But sometimes we may want to bind the value to a dynamic property on the current active instance. We can use &lt;code&gt;v-bind&lt;/code&gt; to achieve that. In addition, using &lt;code&gt;v-bind&lt;/code&gt; allows us to bind the input value to non-string values.</source>
          <target state="translated">그러나 때때로 우리는 현재 활성 인스턴스의 동적 속성에 값을 바인딩하고 싶을 수 있습니다. 이를 위해 &lt;code&gt;v-bind&lt;/code&gt; 를 사용할 수 있습니다 . 또한 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하면 입력 값을 문자열이 아닌 값에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e176e9a97a3c4f462daaed936a731baf80a8b9" translate="yes" xml:space="preserve">
          <source>But they&amp;rsquo;ll &lt;strong&gt;never&lt;/strong&gt; contain global state (e.g. from a Vuex store).</source>
          <target state="translated">그러나 Vuex 스토어와 같은 글로벌 상태 는 &lt;strong&gt;절대&lt;/strong&gt; 포함 &lt;strong&gt;하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d2be99648e0270067cfd4ea7ff6118214ee09c04" translate="yes" xml:space="preserve">
          <source>But they'll &lt;strong&gt;never&lt;/strong&gt; contain global state (e.g. from a Vuex store).</source>
          <target state="translated">그러나 그들은 글로벌 상태를 포함 &lt;strong&gt;하지 않을&lt;/strong&gt; 것입니다 (예 : Vuex 스토어에서).</target>
        </trans-unit>
        <trans-unit id="0c16b65bff1266df40cbfea717a355fbbb3865b2" translate="yes" xml:space="preserve">
          <source>But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let&amp;rsquo;s modify the component definition to make it accept a &lt;a href=&quot;guide/components#Props&quot;&gt;prop&lt;/a&gt;:</source>
          <target state="translated">그러나 이것은 모든 할 일에 대해 동일한 텍스트를 렌더링하므로 매우 흥미롭지는 않습니다. 부모 범위의 데이터를 자식 구성 요소로 전달할 수 있어야합니다. &lt;a href=&quot;guide/components#Props&quot;&gt;소품을&lt;/a&gt; 받도록 컴포넌트 정의를 수정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="da9e62f83884bf77592584e86673c4aa3c5ad180" translate="yes" xml:space="preserve">
          <source>But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let's modify the component definition to make it accept a &lt;a href=&quot;guide/component-basics#passing-data-to-child-components-with-props&quot;&gt;prop&lt;/a&gt;:</source>
          <target state="translated">그러나 이것은 모든 할일에 대해 동일한 텍스트를 렌더링 할 것입니다. 이는 매우 흥미롭지 않습니다. 부모 범위의 데이터를 자식 구성 요소로 전달할 수 있어야합니다. &lt;a href=&quot;guide/component-basics#passing-data-to-child-components-with-props&quot;&gt;prop을&lt;/a&gt; 받아들이도록 컴포넌트 정의를 수정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="1bed9e060b62bc5b202b91abfa9120f37ce0dbd3" translate="yes" xml:space="preserve">
          <source>But what if you&amp;rsquo;ve never had to deal with manual DOM manipulation, nor are you using or testing async components in your app? Or, what if, for whatever reason, you prefer to use the good old &lt;code&gt;window.setTimeout()&lt;/code&gt; instead? In such a case, the code for &lt;code&gt;nextTick()&lt;/code&gt; will become dead code &amp;ndash; that is, code that&amp;rsquo;s written but never used. And dead code is hardly a good thing, especially in our client-side context where every kilobyte matters.</source>
          <target state="translated">그러나 수동 DOM 조작을 처리 할 필요가 없었거나 앱에서 비동기 구성 요소를 사용하거나 테스트하지 않았다면 어떨까요? 또는 어떤 이유로 든 좋은 오래된 &lt;code&gt;window.setTimeout()&lt;/code&gt; 대신 사용하는 것을 선호한다면 어떨까요? 이 경우 &lt;code&gt;nextTick()&lt;/code&gt; 대한 코드는 작성되었지만 사용되지 않은 코드 인 데드 코드가됩니다. 특히 모든 킬로바이트가 중요한 클라이언트 측 컨텍스트에서는 데드 코드가 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="503d46db37b0db45db898aabed77244252918ca2" translate="yes" xml:space="preserve">
          <source>Buttons</source>
          <target state="translated">Buttons</target>
        </trans-unit>
        <trans-unit id="4fb52dff7f27988a090ba79f9b505246472be393" translate="yes" xml:space="preserve">
          <source>By communicating with JavaScript transitions through data attributes, it&amp;rsquo;s also possible to stagger transitions in a list:</source>
          <target state="translated">데이터 속성을 통해 JavaScript 전이와 통신함으로써 목록에서 전이를 스 태거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c0af65beecfe33c66777c92406d04df7381e281" translate="yes" xml:space="preserve">
          <source>By communicating with JavaScript transitions through data attributes, it's also possible to stagger transitions in a list:</source>
          <target state="translated">데이터 속성을 통해 JavaScript 전환과 통신함으로써 목록에서 전환을 엇갈리게 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3dccd1ce12af3efb78877a8e764628049c9bb78" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;v-model&lt;/code&gt; on a component uses &lt;code&gt;modelValue&lt;/code&gt; as the prop and &lt;code&gt;update:modelValue&lt;/code&gt; as the event. We can modify these names passing an argument to &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="translated">기본적 으로 구성 요소의 &lt;code&gt;v-model&lt;/code&gt; 은 &lt;code&gt;modelValue&lt;/code&gt; 를 소품으로 사용하고 &lt;code&gt;update:modelValue&lt;/code&gt; 를 이벤트로 사용합니다. &lt;code&gt;v-model&lt;/code&gt; 에 인수를 전달하여 이러한 이름을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ffc52d15241fcde204b3749994637baf6b9f1a2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;v-model&lt;/code&gt; on a component uses &lt;code&gt;value&lt;/code&gt; as the prop and &lt;code&gt;input&lt;/code&gt; as the event, but some input types such as checkboxes and radio buttons may want to use the &lt;code&gt;value&lt;/code&gt; attribute for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value&quot;&gt;different purpose&lt;/a&gt;. Using the &lt;code&gt;model&lt;/code&gt; option can avoid a conflict in such cases:</source>
          <target state="translated">기본적 으로 구성 요소의 &lt;code&gt;v-model&lt;/code&gt; 은 &lt;code&gt;value&lt;/code&gt; 을 소품으로 사용하고 &lt;code&gt;input&lt;/code&gt; 을 이벤트로 사용하지만 확인란 및 라디오 버튼과 같은 일부 입력 유형 은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value&quot;&gt;다른 용도로 &lt;/a&gt; &lt;code&gt;value&lt;/code&gt; 속성 을 사용할 수 있습니다 . 이러한 경우 &lt;code&gt;model&lt;/code&gt; 옵션을 사용하면 충돌을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad90607d4c0404c9faa13f5fee7b87b35f56269" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;v-model&lt;/code&gt; syncs the input with the data after each &lt;code&gt;input&lt;/code&gt; event (with the exception of IME composition as &lt;a href=&quot;#vmodel-ime-tip&quot;&gt;stated above&lt;/a&gt;). You can add the &lt;code&gt;lazy&lt;/code&gt; modifier to instead sync after &lt;code&gt;change&lt;/code&gt; events:</source>
          <target state="translated">기본적으로 &lt;code&gt;v-model&lt;/code&gt; 은 각 &lt;code&gt;input&lt;/code&gt; 이벤트 후 데이터와 입력을 동기화합니다 ( &lt;a href=&quot;#vmodel-ime-tip&quot;&gt;위에서 언급 한&lt;/a&gt; IME 구성 제외 ). &lt;code&gt;change&lt;/code&gt; 이벤트 후에 대신 동기화 하도록 &lt;code&gt;lazy&lt;/code&gt; 수정자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c148f99afa31c3b0b4175f568b49a103e6ad0ecc" translate="yes" xml:space="preserve">
          <source>By default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/bh8fLeds/&quot;&gt;unintended consequences&lt;/a&gt; if these elements should not actually be considered the same.</source>
          <target state="translated">기본적으로 Vue는 가능한 효율적으로 DOM을 업데이트합니다. 즉, 동일한 유형의 요소를 전환 할 때 기존 요소를 제거하고 대신 새 요소를 추가하는 대신 기존 요소를 패치합니다. 이러한 요소를 실제로 동일하게 간주하지 않으면 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/bh8fLeds/&quot;&gt;의도하지 않은 결과가&lt;/a&gt; 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a77e6be69803dd9706b337a72081315320a15961" translate="yes" xml:space="preserve">
          <source>By default, all errors are still sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt; if it is defined, so that these errors can still be reported to an analytics service in a single place.</source>
          <target state="translated">기본적으로 모든 오류는 글로벌 &lt;code&gt;config.errorHandler&lt;/code&gt; 가 정의 된 경우 여전히 글로벌 config.errorHandler로 전송 되므로 이러한 오류는 여전히 한 곳에서 분석 서비스에보고 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eb7b2304afd77120627ce6f92ed137e52761194" translate="yes" xml:space="preserve">
          <source>By default, it doesn't render a wrapper element, but you can specify an element to be rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">기본적으로 래퍼 요소를 렌더링하지 않지만 &lt;code&gt;tag&lt;/code&gt; 속성 으로 렌더링 할 요소를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4e0baa8d481eef87a57457f5454fbd1de21191f" translate="yes" xml:space="preserve">
          <source>By default, parent scope attribute bindings that are not recognized as props will &quot;fallthrough&quot;. This means that when we have a single-root component, these bindings will be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting &lt;code&gt;inheritAttrs&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, this default behavior can be disabled. The attributes are available via the &lt;code&gt;$attrs&lt;/code&gt; instance property and can be explicitly bound to a non-root element using &lt;code&gt;v-bind&lt;/code&gt;.</source>
          <target state="translated">기본적으로 소품으로 인식되지 않는 상위 범위 속성 바인딩은 &quot;폴 스루&quot;됩니다. 즉, 단일 루트 구성 요소가있을 때 이러한 바인딩이 일반 HTML 속성으로 자식 구성 요소의 루트 요소에 적용됩니다. 대상 요소 또는 다른 구성 요소를 래핑하는 구성 요소를 제작할 때 항상 원하는 동작이 아닐 수 있습니다. &lt;code&gt;inheritAttrs&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하면이 기본 동작을 비활성화 할 수 있습니다. 속성은 &lt;code&gt;$attrs&lt;/code&gt; 인스턴스 속성을 통해 사용할 수 있으며 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하여 루트가 아닌 요소에 명시 적으로 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83e8efbea67d6157fcddcb4edcfa1b49f5be94c6" translate="yes" xml:space="preserve">
          <source>By default, parent scope attribute bindings that are not recognized as props will &amp;ldquo;fallthrough&amp;rdquo; and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting &lt;code&gt;inheritAttrs&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, this default behavior can be disabled. The attributes are available via the &lt;code&gt;$attrs&lt;/code&gt; instance property (also new in 2.4) and can be explicitly bound to a non-root element using &lt;code&gt;v-bind&lt;/code&gt;.</source>
          <target state="translated">기본적으로 props로 인식되지 않는 부모 범위 특성 바인딩은&amp;ldquo;fallfall&amp;rdquo;되며 자식 구성 요소의 루트 요소에 일반 HTML 특성으로 적용됩니다. 대상 요소 또는 다른 구성 요소를 랩핑하는 구성 요소를 작성할 때 이것이 항상 원하는 동작은 아닙니다. &lt;code&gt;inheritAttrs&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하면이 기본 동작을 비활성화 할 수 있습니다. 속성은 &lt;code&gt;$attrs&lt;/code&gt; 인스턴스 속성 (2.4의 새로운 기능)을 통해 사용 가능하며 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하여 루트가 아닌 요소에 명시 적으로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbd6959db2d24ce79d7dca446bb49d40906058ca" translate="yes" xml:space="preserve">
          <source>By default, this will use the transitions specified for entering and leaving. If you&amp;rsquo;d like however, you can also specify custom CSS classes:</source>
          <target state="translated">기본적으로 이것은 출입을 위해 지정된 전환을 사용합니다. 그러나 원하는 경우 사용자 정의 CSS 클래스를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df95deadef4c40290cd6ba28c4884617b82a5f1a" translate="yes" xml:space="preserve">
          <source>By doing so, this will help you avoid conflicts with current and future HTML elements.</source>
          <target state="translated">이렇게하면 현재 및 향후 HTML 요소와의 충돌을 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="524e3e94154f70bc5cd238efc984b56537e51616" translate="yes" xml:space="preserve">
          <source>By iterating over a computed property instead, like this:</source>
          <target state="translated">대신 다음과 같이 계산 된 속성을 반복하여 :</target>
        </trans-unit>
        <trans-unit id="3ad894f28d9c6e6c159aaf52a61131fa7ae0cb56" translate="yes" xml:space="preserve">
          <source>By leveraging the ability to target a particular prop and event as we learned before with &lt;a href=&quot;#v-model-arguments&quot;&gt;&lt;code&gt;v-model&lt;/code&gt; arguments&lt;/a&gt;, we can now create multiple v-model bindings on a single component instance.</source>
          <target state="translated">이전에 &lt;a href=&quot;#v-model-arguments&quot;&gt; &lt;code&gt;v-model&lt;/code&gt; 인수로&lt;/a&gt; 배운 특정 소품 및 이벤트를 대상으로하는 기능을 활용하여 이제 단일 구성 요소 인스턴스에 여러 v-model 바인딩을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffde0f5ffc23d749b1907e603465a412357ed88f" translate="yes" xml:space="preserve">
          <source>By moving the &lt;code&gt;v-if&lt;/code&gt; to a container element, we&amp;rsquo;re no longer checking &lt;code&gt;shouldShowUsers&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; user in the list. Instead, we check it once and don&amp;rsquo;t even evaluate the &lt;code&gt;v-for&lt;/code&gt; if &lt;code&gt;shouldShowUsers&lt;/code&gt; is false.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; 를 컨테이너 요소 로 이동하면 더 이상 목록의 &lt;em&gt;모든&lt;/em&gt; 사용자에 대해 &lt;code&gt;shouldShowUsers&lt;/code&gt; 를 확인하지 않습니다 . 대신, 우리는 한 번 확인하고 &lt;code&gt;shouldShowUsers&lt;/code&gt; 가 false 인지 &lt;code&gt;v-for&lt;/code&gt; 도 평가하지 않습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c5c485332147fd438327cdd4bf55f716394baf76" translate="yes" xml:space="preserve">
          <source>By now, your app should be fully migrated. If you&amp;rsquo;re still hungry for more though, you can read the rest of this page - or dive in to the new and improved guide from &lt;a href=&quot;../index&quot;&gt;the beginning&lt;/a&gt;. Many parts will be skimmable, since you&amp;rsquo;re already familiar with the core concepts.</source>
          <target state="translated">이제 앱이 완전히 마이그레이션되었습니다. 그래도 여전히 배가 고픈 경우이 페이지의 나머지 부분을 읽거나 &lt;a href=&quot;../index&quot;&gt;처음부터&lt;/a&gt; 개선 된 새 가이드로 넘어갈 수 있습니다. 이미 핵심 개념에 익숙하기 때문에 많은 부품을 훑어 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4b0275ee1b88f92d43018837d550c5c16046c1" translate="yes" xml:space="preserve">
          <source>By passing &lt;code&gt;context.data&lt;/code&gt; as the second argument to &lt;code&gt;createElement&lt;/code&gt;, we are passing down any attributes or event listeners used on &lt;code&gt;my-functional-button&lt;/code&gt;. It&amp;rsquo;s so transparent, in fact, that events don&amp;rsquo;t even require the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">전달하여 &lt;code&gt;context.data&lt;/code&gt; 을 두 번째 인수로 &lt;code&gt;createElement&lt;/code&gt; 와 , 우리는에 사용되는 모든 속성이나 이벤트 리스너 아래로 전달하는 &lt;code&gt;my-functional-button&lt;/code&gt; . 사실 이벤트에 &lt;code&gt;.native&lt;/code&gt; 한정자가 필요하지 않은 것은 매우 투명 합니다.</target>
        </trans-unit>
        <trans-unit id="6094ad2d93aaa124480262cfc40c0e785b224a79" translate="yes" xml:space="preserve">
          <source>By setting the &lt;code&gt;inheritAttrs&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;, you can control to apply to other elements attributes to use the component's &lt;code&gt;$attrs&lt;/code&gt; property, which includes all attributes not included to component &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;emits&lt;/code&gt; properties (e.g., &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;style&lt;/code&gt;, &lt;code&gt;v-on&lt;/code&gt; listeners, etc.).</source>
          <target state="translated">설정에 따라 &lt;code&gt;inheritAttrs&lt;/code&gt; 의 에 옵션 &lt;code&gt;false&lt;/code&gt; , 다른 요소에 적용 할 제어 할 수 있습니다하면 구성 요소의 사용 특성을 &lt;code&gt;$attrs&lt;/code&gt; 구성 요소에 포함되지 않은 모든 속성을 포함 재산, &lt;code&gt;props&lt;/code&gt; 과 &lt;code&gt;emits&lt;/code&gt; 특성 (예를 들어, &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;style&lt;/code&gt; , &lt;code&gt;v-on&lt;/code&gt; 청취자 등 .).</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb704231be479daeb04b503bb4d54f57efe5578f" translate="yes" xml:space="preserve">
          <source>CSP environments</source>
          <target state="translated">CSP 환경</target>
        </trans-unit>
        <trans-unit id="9020d263f8a3f425dedb8420905b7b42c9734f4a" translate="yes" xml:space="preserve">
          <source>CSS Animations</source>
          <target state="translated">CSS 애니메이션</target>
        </trans-unit>
        <trans-unit id="f266fe7a0113efe52607c4f4f3b4ebbbb3f47585" translate="yes" xml:space="preserve">
          <source>CSS Transitions</source>
          <target state="translated">CSS 전환</target>
        </trans-unit>
        <trans-unit id="3d05a3291c02bd89bd73ec03f20f2ea4a4303e79" translate="yes" xml:space="preserve">
          <source>CSS animations are applied in the same way as CSS transitions, the difference being that &lt;code&gt;v-enter-from&lt;/code&gt; is not removed immediately after the element is inserted, but on an &lt;code&gt;animationend&lt;/code&gt; event.</source>
          <target state="translated">CSS 애니메이션은 CSS 전환과 동일한 방식으로 적용됩니다. 차이점 은 요소가 삽입 된 직후에 &lt;code&gt;v-enter-from&lt;/code&gt; 이 제거되지 않고 &lt;code&gt;animationend&lt;/code&gt; 이벤트 에서 제거 된다는 점 입니다.</target>
        </trans-unit>
        <trans-unit id="48d8f8e4d0c0e93f13e2c87ea6bb5cd7957207dc" translate="yes" xml:space="preserve">
          <source>CSS animations are applied in the same way as CSS transitions, the difference being that &lt;code&gt;v-enter&lt;/code&gt; is not removed immediately after the element is inserted, but on an &lt;code&gt;animationend&lt;/code&gt; event.</source>
          <target state="translated">CSS 애니메이션은 CSS 전환과 같은 방식으로 적용됩니다. 차이점은 &lt;code&gt;v-enter&lt;/code&gt; 는 요소를 삽입 한 직후가 아니라 &lt;code&gt;animationend&lt;/code&gt; 이벤트 에서 제거 된다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bbb794d199e71c2cd267a0ceec4bc830f0994805" translate="yes" xml:space="preserve">
          <source>CSS transition classes will be applied to inner elements and not to the group/container itself.</source>
          <target state="translated">CSS 전환 클래스는 그룹 / 컨테이너 자체가 아닌 내부 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d236fbcb9274aa5cc57d61418439c052a90749f" translate="yes" xml:space="preserve">
          <source>Caching invalidation of computed properties will be removed in future major versions of Vue. Replace any uncached computed properties with methods, which will have the same result.</source>
          <target state="translated">Vue의 향후 주요 버전에서는 계산 된 속성의 캐싱 무효화가 제거됩니다. 캐시되지 않은 계산 된 속성을 메서드로 바꾸면 결과가 같습니다.</target>
        </trans-unit>
        <trans-unit id="8985f48d62f9f073d646c6404b51e6fb553d8fe5" translate="yes" xml:space="preserve">
          <source>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</source>
          <target state="translated">Vue 인스턴스가 파괴 된 후 호출됩니다. 이 후크가 호출되면 Vue 인스턴스의 모든 지시문이 바인드 해제되고 모든 이벤트 리스너가 제거되었으며 모든 하위 Vue 인스턴스도 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="f58210a3703af4dcf510c60774520a04e7fe687f" translate="yes" xml:space="preserve">
          <source>Called after a component instance has been unmounted. When this hook is called, all directives of the component instance have been unbound, all event listeners have been removed, and all child component instance have also been unmounted.</source>
          <target state="translated">구성 요소 인스턴스가 마운트 해제 된 후 호출됩니다. 이 후크가 호출되면 구성 요소 인스턴스의 모든 지시문이 바인딩 해제되고 모든 이벤트 리스너가 제거되며 모든 하위 구성 요소 인스턴스도 마운트 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3530cfac5196f790d3069acb16fe440211703006" translate="yes" xml:space="preserve">
          <source>Called after a data change causes the virtual DOM to be re-rendered and patched.</source>
          <target state="translated">데이터 변경 후 호출하면 가상 DOM이 다시 렌더링되고 패치됩니다.</target>
        </trans-unit>
        <trans-unit id="83312d8e8dc6f9113cf6c95f0e2c09dfcb5c36f5" translate="yes" xml:space="preserve">
          <source>Called after the instance has been mounted, where &lt;code&gt;el&lt;/code&gt; is replaced by the newly created &lt;code&gt;vm.$el&lt;/code&gt;. If the root instance is mounted to an in-document element, &lt;code&gt;vm.$el&lt;/code&gt; will also be in-document when &lt;code&gt;mounted&lt;/code&gt; is called.</source>
          <target state="translated">인스턴스가 마운트 된 후 호출되며 여기서 &lt;code&gt;el&lt;/code&gt; 은 새로 작성된 &lt;code&gt;vm.$el&lt;/code&gt; 로 대체됩니다 . 루트 인스턴스가 문서 내 요소에 &lt;code&gt;mounted&lt;/code&gt; 경우 mount 가 호출 될 때 &lt;code&gt;vm.$el&lt;/code&gt; 도 문서 내에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e3939dd4be4ae98c83ade35b985dcf3f579ac5a" translate="yes" xml:space="preserve">
          <source>Called after the instance has been mounted, where element, passed to &lt;code&gt;Vue.createApp({}).mount()&lt;/code&gt; is replaced by the newly created &lt;code&gt;vm.$el&lt;/code&gt;. If the root instance is mounted to an in-document element, &lt;code&gt;vm.$el&lt;/code&gt; will also be in-document when &lt;code&gt;mounted&lt;/code&gt; is called.</source>
          <target state="translated">인스턴스가 마운트 된 후 호출되며 &lt;code&gt;Vue.createApp({}).mount()&lt;/code&gt; 전달 된 요소 가 새로 생성 된 &lt;code&gt;vm.$el&lt;/code&gt; 로 대체됩니다 . 루트 인스턴스가 문서 내 요소에 &lt;code&gt;mounted&lt;/code&gt; 경우 mount 가 호출 될 때 &lt;code&gt;vm.$el&lt;/code&gt; 도 문서에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bad46ae4298e45721b7951c1b6f0d32995c3e16" translate="yes" xml:space="preserve">
          <source>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</source>
          <target state="translated">Vue 인스턴스가 파괴되기 직전에 호출됩니다. 이 단계에서 인스턴스는 여전히 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4f342a060a1575bc5ee55fb162118e0f1465d10b" translate="yes" xml:space="preserve">
          <source>Called right before a component instance is unmounted. At this stage the instance is still fully functional.</source>
          <target state="translated">구성 요소 인스턴스가 마운트 해제되기 직전에 호출됩니다. 이 단계에서 인스턴스는 여전히 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="85ce8dc6482495b2e5f1c136e19210920f78ae5e" translate="yes" xml:space="preserve">
          <source>Called right before the mounting begins: the &lt;code&gt;render&lt;/code&gt; function is about to be called for the first time.</source>
          <target state="translated">마운트가 시작되기 직전에 호출됩니다 : &lt;code&gt;render&lt;/code&gt; 함수가 처음으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc1b25df593503e17062f1c3e2653b22c66f3a2" translate="yes" xml:space="preserve">
          <source>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the &lt;code&gt;$el&lt;/code&gt; property will not be available yet.</source>
          <target state="translated">인스턴스가 생성 된 후 동 기적으로 호출됩니다. 이 단계에서 인스턴스는 옵션 처리를 완료했습니다. 즉, 데이터 관찰, 계산 된 속성, 메서드, 감시 / 이벤트 콜백이 설정되었습니다. 그러나 탑재 단계가 시작되지 않았으며 &lt;code&gt;$el&lt;/code&gt; 속성을 아직 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="feed33b8752c111f08079dce1a2159650ebe5342" translate="yes" xml:space="preserve">
          <source>Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.</source>
          <target state="translated">인스턴스가 초기화 된 직후, 데이터 관찰 및 이벤트 / 감시자 설정 전에 동 기적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="19ba77af716508606cffcc73e06106d60b7aff0b" translate="yes" xml:space="preserve">
          <source>Called when a kept-alive component is activated.</source>
          <target state="translated">연결 유지 구성 요소가 활성화되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="03356ab312d39995a07fe8884dd2e46052f7f905" translate="yes" xml:space="preserve">
          <source>Called when a kept-alive component is deactivated.</source>
          <target state="translated">연결 유지 구성 요소가 비활성화되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="22a22dd33b29826fd113758eeb92c36b05d2429c" translate="yes" xml:space="preserve">
          <source>Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return &lt;code&gt;false&lt;/code&gt; to stop the error from propagating further.</source>
          <target state="translated">하위 구성 요소의 오류가 캡처 될 때 호출됩니다. 후크는 오류, 오류를 트리거 한 구성 요소 인스턴스 및 오류가 캡처 된 위치에 대한 정보를 포함하는 문자열의 세 가지 인수를받습니다. 오류가 더 이상 전파되지 않도록 후크가 &lt;code&gt;false&lt;/code&gt; 를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33743d1acc9255573c610e6cc615ee541354bead" translate="yes" xml:space="preserve">
          <source>Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.</source>
          <target state="translated">DOM이 패치되기 전에 데이터가 변경 될 때 호출됩니다. 업데이트 전에 기존 DOM에 액세스하는 것이 좋습니다 (예 : 수동으로 추가 된 이벤트 리스너 제거).</target>
        </trans-unit>
        <trans-unit id="9021d36c3e5014b5da313593c77c66a65d241e45" translate="yes" xml:space="preserve">
          <source>Called when virtual DOM re-render is tracked. The hook receives a &lt;code&gt;debugger event&lt;/code&gt; as an argument. This event tells you what operation tracked the component and the target object and key of that operation.</source>
          <target state="translated">가상 DOM 다시 렌더링이 추적 될 때 호출됩니다. 후크는 &lt;code&gt;debugger event&lt;/code&gt; 를 인수로 받습니다 . 이 이벤트는 구성 요소를 추적 한 작업과 해당 작업의 대상 개체 및 키를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8029aea220cd2187f52cb0913abf5897650fc243" translate="yes" xml:space="preserve">
          <source>Called when virtual DOM re-render is triggered.Similarly to &lt;a href=&quot;#rendertracked&quot;&gt;&lt;code&gt;renderTracked&lt;/code&gt;&lt;/a&gt;, receives a &lt;code&gt;debugger event&lt;/code&gt; as an argument. This event tells you what operation triggered the re-rendering and the target object and key of that operation.</source>
          <target state="translated">virtual DOM re-render가 트리거 될 때 호출됩니다. &lt;a href=&quot;#rendertracked&quot;&gt; &lt;code&gt;renderTracked&lt;/code&gt; &lt;/a&gt; 와 유사하게 &lt;code&gt;debugger event&lt;/code&gt; 를 인수로 받습니다 . 이 이벤트는 다시 렌더링을 트리거 한 작업과 해당 작업의 대상 개체 및 키를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="562dc0066f29b343ef11a66c1ecdd24f9d679e27" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;Vue.nextTick()&lt;/code&gt; directly will now result in the infamous &lt;code&gt;undefined is not a function&lt;/code&gt; error.</source>
          <target state="translated">&lt;code&gt;Vue.nextTick()&lt;/code&gt; 직접 호출 하면 이제 악명 높은 &lt;code&gt;undefined is not a function&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e76369e54689d34ed6832055839f17e97e3305a1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;createApp&lt;/code&gt; returns an &lt;em&gt;app instance&lt;/em&gt;, a new concept in Vue 3.</source>
          <target state="translated">&lt;code&gt;createApp&lt;/code&gt; 을 호출 하면 Vue 3의 새로운 개념 인 &lt;em&gt;앱 인스턴스가&lt;/em&gt; 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddb834e4a45df0ee715d3fb6cc2f40440d2fe13" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;createApp&lt;/code&gt; returns an application instance. This instance provides an application context. The entire component tree mounted by the application instance share the same context, which provides the configurations that were previously &quot;global&quot; in Vue 2.x.</source>
          <target state="translated">&lt;code&gt;createApp&lt;/code&gt; 을 호출 하면 애플리케이션 인스턴스가 반환됩니다. 이 인스턴스는 애플리케이션 컨텍스트를 제공합니다. 애플리케이션 인스턴스에 의해 마운트 된 전체 컴포넌트 트리는 Vue 2.x에서 이전에 &quot;글로벌&quot;이었던 구성을 제공하는 동일한 컨텍스트를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="619f81ece4b63c5e2811c2933d49ac7b77880aa1" translate="yes" xml:space="preserve">
          <source>Can be used to create a &lt;a href=&quot;#ref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; for a property on a source reactive object. The ref can then be passed around, retaining the reactive connection to its source property.</source>
          <target state="translated">소스 반응 객체의 속성에 대한 &lt;a href=&quot;#ref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용할 수 있습니다 . 그런 다음 참조를 전달하여 소스 속성에 대한 반응 적 연결을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6574e5ecc3a3bd47aa3511d3f60ad67226d38c4f" translate="yes" xml:space="preserve">
          <source>Can we start translating Vue 3 docs?</source>
          <target state="translated">Vue 3 문서 번역을 시작할 수 있나요?</target>
        </trans-unit>
        <trans-unit id="7477cd38d4344d15574b60c13a9eb98dab7d0740" translate="yes" xml:space="preserve">
          <source>Capacitor</source>
          <target state="translated">Capacitor</target>
        </trans-unit>
        <trans-unit id="f782fc54f40b51ab4c51fe8fd45e9bc55b3c677e" translate="yes" xml:space="preserve">
          <source>Capacitor + Vue.js Guide (opens new window)</source>
          <target state="translated">Capacitor + Vue.js 가이드 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="8f1335b59b2aae3343d1240b464bee8030a93df4" translate="yes" xml:space="preserve">
          <source>Cases like this no longer work:</source>
          <target state="translated">이와 같은 경우 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47ba6a256935c5ee569450f66c777bc4a457173d" translate="yes" xml:space="preserve">
          <source>Causes a component to be stateless (no &lt;code&gt;data&lt;/code&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). They are only a &lt;code&gt;render&lt;/code&gt; function that returns virtual nodes making them much cheaper to render.</source>
          <target state="translated">구성 요소가 상태 비 저장 ( &lt;code&gt;data&lt;/code&gt; 없음 ) 및 인스턴스 비 저장 ( &lt;code&gt;this&lt;/code&gt; 컨텍스트 없음) 이되도록 합니다. 가상 노드를 반환하여 렌더링 비용이 훨씬 저렴한 &lt;code&gt;render&lt;/code&gt; 기능 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="5ebc2730b36d1280bae0438aa104f84b488a7c75" translate="yes" xml:space="preserve">
          <source>Change &lt;code&gt;'Enter'&lt;/code&gt; to the appropriate &lt;a href=&quot;http://keycode.info/&quot;&gt;key (opens new window)&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;'Enter'&lt;/code&gt; 를 적절한 &lt;a href=&quot;http://keycode.info/&quot;&gt;키로&lt;/a&gt; 변경 하십시오 (새 창에서 열림).</target>
        </trans-unit>
        <trans-unit id="128bbe4c1a2eec75b3a48d52a04dc381d50f549c" translate="yes" xml:space="preserve">
          <source>Change Detection Caveats</source>
          <target state="translated">변경 감지주의 사항</target>
        </trans-unit>
        <trans-unit id="6eb0b309f52e02a06d25d6308587fb00dd8402ca" translate="yes" xml:space="preserve">
          <source>Change Detection Caveats in Vue 2</source>
          <target state="translated">Vue 2의 변경 감지주의 사항</target>
        </trans-unit>
        <trans-unit id="509127db0a40f3b6808e38c534337564d2f67912" translate="yes" xml:space="preserve">
          <source>Change all non-&lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tags with &lt;code&gt;is&lt;/code&gt; usage to &lt;code&gt;&amp;lt;component is=&quot;...&quot;&amp;gt;&lt;/code&gt; (for SFC templates) or &lt;code&gt;v-is&lt;/code&gt; (for in-DOM templates).</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 사용 이있는 모든 비 &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; 태그 를 &lt;code&gt;&amp;lt;component is=&quot;...&quot;&amp;gt;&lt;/code&gt; (SFC 템플릿의 경우) 또는 &lt;code&gt;v-is&lt;/code&gt; (in-DOM 템플릿의 경우)로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e72c9cb74aa03a1204d264e75dd17b9f2ce6bddb" translate="yes" xml:space="preserve">
          <source>Change the plain text interpolation delimiters.</source>
          <target state="translated">일반 텍스트 보간 구분 기호를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="573d848a7ecec863b6a0bce1a32b354b232cdfdb" translate="yes" xml:space="preserve">
          <source>Changing transform does not trigger any geometry changes or painting, which is very good. This means that the operation can likely be carried out by the compositor thread with the help of the GPU.</source>
          <target state="translated">변형을 변경해도 지오메트리 변경이나 페인팅이 트리거되지는 않으므로 매우 좋습니다. 이는 GPU의 도움으로 컴포 지터 스레드에서 작업을 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2406ae964529e03a8ff9e23d92e1842c1977cd4c" translate="yes" xml:space="preserve">
          <source>Cheap Static Components with &lt;code&gt;v-once&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-once&lt;/code&gt; 를 사용한 저렴한 정적 구성 요소</target>
        </trans-unit>
        <trans-unit id="55780f6f22cfb5a725f801fb55d3e7c32385ae95" translate="yes" xml:space="preserve">
          <source>Check it out for yourself by entering some text in the input, then pressing the toggle button:</source>
          <target state="translated">입력에 텍스트를 입력 한 다음 토글 버튼을 눌러 직접 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0f6c8ac8246de31ef35c527dece9d833e22be8cc" translate="yes" xml:space="preserve">
          <source>Check out more details on &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; in the &lt;a href=&quot;../api/built-in-components#keep-alive&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/built-in-components#keep-alive&quot;&gt;API 참조&lt;/a&gt; 에서 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 에 대한 자세한 내용을 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="3c33724c45fb8e747d255d9b041a54c4aa78fe4e" translate="yes" xml:space="preserve">
          <source>Check out more details on &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; in the &lt;a href=&quot;../api/index#keep-alive&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/index#keep-alive&quot;&gt;API 참조 서 &lt;/a&gt; &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 에 대한 자세한 내용을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a314c9435a72544be3b81bd0835c5613b16b38f1" translate="yes" xml:space="preserve">
          <source>Check out the following links from WebAim to understand from users:</source>
          <target state="translated">WebAim에서 다음 링크를 확인하여 사용자로부터 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="f531b7f4e1cce7c6b104a7b3cf21fe76b655e01f" translate="yes" xml:space="preserve">
          <source>Check out the result below:</source>
          <target state="translated">아래 결과를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d66c3d0758e71b315e012814dc35df62cfab9d2" translate="yes" xml:space="preserve">
          <source>Checkbox</source>
          <target state="translated">Checkbox</target>
        </trans-unit>
        <trans-unit id="5f8a921707d34fb3fa42912dc08856389f5f8ffe" translate="yes" xml:space="preserve">
          <source>Checkout &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;awesome-vue (opens new window)&lt;/a&gt; for a huge collection of community-contributed plugins and libraries.</source>
          <target state="translated">체크 아웃 &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;멋진-VUE (새 창을 엽니 다)&lt;/a&gt; 사회 공헌 플러그인 및 라이브러리의 거대한 수집.</target>
        </trans-unit>
        <trans-unit id="a8729bc4793abbf031b32f50c70e97b14a84f1c2" translate="yes" xml:space="preserve">
          <source>Checkout &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;awesome-vue&lt;/a&gt; for a huge collection of community-contributed plugins and libraries.</source>
          <target state="translated">체크 아웃 &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;멋진-VUE을&lt;/a&gt; 지역 사회에 기여 플러그인 및 라이브러리의 거대한 컬렉션.</target>
        </trans-unit>
        <trans-unit id="a14872eb994dfe874db41c024324cdf1ab1568d9" translate="yes" xml:space="preserve">
          <source>Checkout the &lt;a href=&quot;https://www.w3.org/WAI/planning-and-managing/&quot;&gt;Planning and managing web accessibility guide (opens new window)&lt;/a&gt; provided by &lt;a href=&quot;https://www.w3.org/&quot;&gt;World Wide Web Consortium (W3C) (opens new window)&lt;/a&gt;</source>
          <target state="translated">체크 아웃 &lt;a href=&quot;https://www.w3.org/WAI/planning-and-managing/&quot;&gt;계획 및 관리 웹 접근성 가이드 (새 창을 엽니 다)&lt;/a&gt; 에서 제공하는 &lt;a href=&quot;https://www.w3.org/&quot;&gt;세계를 와이드 웹 컨소시엄 (W3C)의 (새 창을 엽니 다)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e03267b20aefeb614af397a801ccc297114d51" translate="yes" xml:space="preserve">
          <source>Checks if a value is a ref object.</source>
          <target state="translated">값이 참조 객체인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9aa0f67fa4e85299374a8388f79045a306f5fce8" translate="yes" xml:space="preserve">
          <source>Checks if an object is a proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;#reactive&quot;&gt; &lt;code&gt;reactive&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; 의해 생성 된 프록시인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8e54e6ec2ae429669251cd513dd0143bfdb92e93" translate="yes" xml:space="preserve">
          <source>Checks if an object is a reactive proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 리 액티브 프록시에서 생성 된 &lt;a href=&quot;#reactive&quot;&gt; &lt;code&gt;reactive&lt;/code&gt; &lt;/a&gt; 액티브 프록시인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="844483535ed4096fb32362348689389d101b44bd" translate="yes" xml:space="preserve">
          <source>Checks if an object is a readonly proxy created by &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 readonly에 의해 생성 된 &lt;a href=&quot;#readonly&quot;&gt; &lt;code&gt;readonly&lt;/code&gt; &lt;/a&gt; 전용 프록시인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3f332ccc08e1b0498df223620c8d4cf1fb1be840" translate="yes" xml:space="preserve">
          <source>Child Component Refs</source>
          <target state="translated">하위 구성 요소 참조</target>
        </trans-unit>
        <trans-unit id="c79d8afe80046d191e62a92ede507cdd889b5dfe" translate="yes" xml:space="preserve">
          <source>Children VNodes, built using &lt;code&gt;h()&lt;/code&gt;, or using strings to get &quot;text VNodes&quot; or an object with slots. Optional</source>
          <target state="translated">&lt;code&gt;h()&lt;/code&gt; 사용하여 빌드 하거나 문자열을 사용하여 &quot;text VNodes&quot;또는 슬롯이있는 객체를 가져 오는 하위 VNode입니다. 선택 과목</target>
        </trans-unit>
        <trans-unit id="4b102a4abe624392b6fec86da9cebfeccf82f9d1" translate="yes" xml:space="preserve">
          <source>Children of the same common parent must have &lt;strong&gt;unique keys&lt;/strong&gt;. Duplicate keys will cause render errors.</source>
          <target state="translated">동일한 공통 부모의 자식에는 &lt;strong&gt;고유 키&lt;/strong&gt; 가 있어야 &lt;strong&gt;합니다&lt;/strong&gt; . 키가 중복되면 렌더링 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="563daee3495a2143d46025d2fbef55812a25188e" translate="yes" xml:space="preserve">
          <source>Choosing Your Framework</source>
          <target state="translated">프레임 워크 선택</target>
        </trans-unit>
        <trans-unit id="a87ecde35ab8afd2df96443b4dd36523bac9a282" translate="yes" xml:space="preserve">
          <source>ChromeVox (opens new window)</source>
          <target state="translated">ChromeVox (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="26d10419c85d39f36202cd562489c0cca977e3fc" translate="yes" xml:space="preserve">
          <source>Circular References</source>
          <target state="translated">원형 참조</target>
        </trans-unit>
        <trans-unit id="c024d09d54f06a3a36aeb2331ad06e01744fb502" translate="yes" xml:space="preserve">
          <source>Circular References Between Components</source>
          <target state="translated">구성 요소 간 순환 참조</target>
        </trans-unit>
        <trans-unit id="dca0daa7ecaa93a4cfed75a4c1810768b7e08768" translate="yes" xml:space="preserve">
          <source>Class and Style Bindings</source>
          <target state="translated">클래스 및 스타일 바인딩</target>
        </trans-unit>
        <trans-unit id="9a74b2e08183e9c12dbab6f2ce8267f763f44cf6" translate="yes" xml:space="preserve">
          <source>Class-Style Vue Components</source>
          <target state="translated">클래스 스타일 Vue 구성 요소</target>
        </trans-unit>
        <trans-unit id="623133c0885a8356a6c58a7d4470391a17d8590a" translate="yes" xml:space="preserve">
          <source>Class-based Animations &amp;amp; Transitions</source>
          <target state="translated">클래스 기반 애니메이션 및 전환</target>
        </trans-unit>
        <trans-unit id="9d591ca7c10ad619dc6206d37ac2017aefefbb31" translate="yes" xml:space="preserve">
          <source>Code Blocks</source>
          <target state="translated">코드 블록</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="180a8b1b8c249023344c634b171d7a150f6b48ba" translate="yes" xml:space="preserve">
          <source>Coercing &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;'false'&lt;/code&gt; instead of removing the attribute</source>
          <target state="translated">속성을 제거하는 대신 &lt;code&gt;false&lt;/code&gt; 를 &lt;code&gt;'false'&lt;/code&gt; 로 강제 변환</target>
        </trans-unit>
        <trans-unit id="7f9920f50b8c1ff7d236873c280fc6143d350a43" translate="yes" xml:space="preserve">
          <source>Coercion for boolean attributes is left untouched.</source>
          <target state="translated">부울 속성에 대한 강제는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="15cd7581d0836866a847df9eba4b6be6631a6fb2" translate="yes" xml:space="preserve">
          <source>Coffee &lt;em&gt;with&lt;/em&gt; milk</source>
          <target state="translated">우유 &lt;em&gt;와&lt;/em&gt; 커피</target>
        </trans-unit>
        <trans-unit id="fe558721007912eba90c128085c5ee8f72c25e54" translate="yes" xml:space="preserve">
          <source>Cognitive Load Theory (opens new window)</source>
          <target state="translated">인지 부하 이론 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="e633c5c61f9f679ab238ff8e33e64261d9e9bd1e" translate="yes" xml:space="preserve">
          <source>Cognitive capacity is &lt;strong&gt;depleted faster&lt;/strong&gt; by complex sentences, having to learn more than one concept at a time, and abstract examples that don't directly relate to a user's work.</source>
          <target state="translated">인지 능력은 복잡한 문장, 한 번에 하나 이상의 개념을 배워야하며 사용자의 작업과 직접 관련이없는 추상적 인 예에 의해 &lt;strong&gt;더 빨리 고갈&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd383d9bc02ad74fa637d37cce23e0fc2d6c1ba2" translate="yes" xml:space="preserve">
          <source>Cognitive capacity is &lt;strong&gt;depleted more slowly&lt;/strong&gt; when we help them feel consistently smart, powerful, and curious. Breaking things down into digestible pieces and minding the flow of the document can help keep them in this state.</source>
          <target state="translated">그들이 지속적으로 똑똑하고 강력하며 호기심을 느끼도록 도울 때인 지 능력은 &lt;strong&gt;더 느리게 고갈&lt;/strong&gt; 됩니다. 내용을 소화 가능한 조각으로 나누고 문서의 흐름을 염두에두면 이러한 상태를 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95022fc2fc355ca901608262dcf92c67246fda3" translate="yes" xml:space="preserve">
          <source>Collection of form-associated elements</source>
          <target state="translated">양식 관련 요소 모음</target>
        </trans-unit>
        <trans-unit id="65abb53aeb61cfaf549701197c45b35fe463c211" translate="yes" xml:space="preserve">
          <source>Collection of links suitable for use when navigating the document or related documents</source>
          <target state="translated">문서 또는 관련 문서를 탐색 할 때 사용하기에 적합한 링크 모음</target>
        </trans-unit>
        <trans-unit id="81414ed4e3da0285def5560fcce55ad97ab7e09f" translate="yes" xml:space="preserve">
          <source>Color Oracle (opens new window)</source>
          <target state="translated">컬러 오라클 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="6a7a83b6c99114d999934704c2b29180d7f7cddf" translate="yes" xml:space="preserve">
          <source>Color Tools</source>
          <target state="translated">색상 도구</target>
        </trans-unit>
        <trans-unit id="60ab98e816b665374e5d86f770d68ddf06088636" translate="yes" xml:space="preserve">
          <source>Combined with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API&quot;&gt;History API (opens new window)&lt;/a&gt;, you can build a very basic but fully-functional client-side router. To see that in practice, check out &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example&quot;&gt;this example app (opens new window)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API&quot;&gt;History API (새 창에서 열림)&lt;/a&gt; 와 결합 하면 매우 기본적이지만 완전한 기능을 갖춘 클라이언트 측 라우터를 구축 할 수 있습니다. 실제로 확인하려면 &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example&quot;&gt;이 예제 앱을&lt;/a&gt; 확인하십시오 (새 창에서 열림) .</target>
        </trans-unit>
        <trans-unit id="c974ead90c104908ea0a8c2bb04898917e9588c6" translate="yes" xml:space="preserve">
          <source>Combined with the HTML5 History API, you can build a very basic but fully-functional client-side router. To see that in practice, check out &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example&quot;&gt;this example app&lt;/a&gt;.</source>
          <target state="translated">HTML5 히스토리 API와 결합하여 매우 기본이지만 완전한 기능을 갖춘 클라이언트 측 라우터를 구축 할 수 있습니다. 실제로이 &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example&quot;&gt;예제 앱을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="377dd01e05316c6519d98a0022d6976f8e76be87" translate="yes" xml:space="preserve">
          <source>CommonJS</source>
          <target state="translated">CommonJS</target>
        </trans-unit>
        <trans-unit id="a6efa3f8b6925bf806e313da9f1695177c2a8032" translate="yes" xml:space="preserve">
          <source>CommonJS and ES Module builds also preserve raw checks for &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.</source>
          <target state="translated">CommonJS 및 ES 모듈 빌드는 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 에 대한 원시 검사도 보존 하여 실행해야하는 모드를 결정합니다. Vue가 실행될 모드를 제어하려면 적절한 번 들러 구성을 사용하여 이러한 환경 변수를 대체해야합니다. &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 교체 문자열 리터럴이있는 .NODE_ENV를 사용하면 UglifyJS 와 같은 축소 기에서 개발 전용 코드 블록을 완전히 삭제하여 최종 파일 크기를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d99e960f2123bbfd6a9677c2fb76958c2fd6c3b7" translate="yes" xml:space="preserve">
          <source>CommonJS and ES Module builds are intended for bundlers, therefore we don&amp;rsquo;t provide minified versions for them. You will be responsible for minifying the final bundle yourself.</source>
          <target state="translated">CommonJS 및 ES 모듈 빌드는 번 들러를위한 것이므로 축소 버전을 제공하지 않습니다. 최종 번들을 직접 축소 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea8787d5b12c9aec27fd3469864538cd711d9cd2" translate="yes" xml:space="preserve">
          <source>CommonJS modules</source>
          <target state="translated">CommonJS 모듈</target>
        </trans-unit>
        <trans-unit id="47ae95c9a99cc6068bff28fb5953623d412455de" translate="yes" xml:space="preserve">
          <source>CommonJS modules (opens new window)</source>
          <target state="translated">CommonJS 모듈 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="3a7cebf073bfeeaff43bd8b053c41db9e6bdb45c" translate="yes" xml:space="preserve">
          <source>Compared to &lt;a href=&quot;#watcheffect&quot;&gt;watchEffect&lt;/a&gt;, &lt;code&gt;watch&lt;/code&gt; allows us to:</source>
          <target state="translated">비교 &lt;a href=&quot;#watcheffect&quot;&gt;watchEffect&lt;/a&gt; , &lt;code&gt;watch&lt;/code&gt; 우리를 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7d5aca44c6d2486f8156b913b06eeb239921e213" translate="yes" xml:space="preserve">
          <source>Comparison between 2.x &amp;amp; 3.x behavior</source>
          <target state="translated">2.x 및 3.x 동작 비교</target>
        </trans-unit>
        <trans-unit id="7f6b8eeaf74802fbeaa7657791100a5b37f51bfb" translate="yes" xml:space="preserve">
          <source>Comparison with Other Frameworks</source>
          <target state="translated">다른 프레임 워크와 비교</target>
        </trans-unit>
        <trans-unit id="5d57c5330d10b55140b0ca441a4e01cd9cdaa363" translate="yes" xml:space="preserve">
          <source>Compatibility Note</source>
          <target state="translated">호환성 노트</target>
        </trans-unit>
        <trans-unit id="077aef20ba3929d7790595b2e4f8807f31cf16a3" translate="yes" xml:space="preserve">
          <source>Compilation Scope</source>
          <target state="translated">컴파일 범위</target>
        </trans-unit>
        <trans-unit id="8b872f9c0b449f8445c95b2c8e455da91a06a8ed" translate="yes" xml:space="preserve">
          <source>Compiles a template string into a render function. &lt;strong&gt;Only available in the full build.&lt;/strong&gt;</source>
          <target state="translated">템플릿 문자열을 렌더링 함수로 컴파일합니다. &lt;strong&gt;전체 빌드에서만 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33f10f0dbd2f59e5fcb0c550db57268475dcd088" translate="yes" xml:space="preserve">
          <source>Complete Example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="6de04754eaf2ce0a0b86e33e3cf6b7710d77fb59" translate="yes" xml:space="preserve">
          <source>Complete syntax highlighting</source>
          <target state="translated">완전한 구문 강조</target>
        </trans-unit>
        <trans-unit id="a3adb5fa70b6ceeca6ba20925fd752909cc7d083" translate="yes" xml:space="preserve">
          <source>Complete syntax highlighting (opens new window)</source>
          <target state="translated">완전한 구문 강조 표시 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="558f46627cddb51db9b48cf5dcc7c099216cf9b4" translate="yes" xml:space="preserve">
          <source>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</source>
          <target state="translated">VM을 완전히 파괴하십시오. 다른 기존 vms와의 연결을 정리하고 모든 지시문을 바인드 해제하고 모든 이벤트 리스너를 끄십시오.</target>
        </trans-unit>
        <trans-unit id="60b812cb2013aa4e729edf7ad740fb109d1d148d" translate="yes" xml:space="preserve">
          <source>Complex expressions in your templates make them less declarative. We should strive to describe &lt;em&gt;what&lt;/em&gt; should appear, not &lt;em&gt;how&lt;/em&gt; we&amp;rsquo;re computing that value. Computed properties and methods also allow the code to be reused.</source>
          <target state="translated">템플릿의 복잡한 표현은 덜 선언적입니다. 우리는 &lt;em&gt;어떻게&lt;/em&gt; 우리가 그 가치를 계산 &lt;em&gt;하는지&lt;/em&gt; 가 아니라 &lt;em&gt;무엇이&lt;/em&gt; 나타나야 &lt;em&gt;하는지를&lt;/em&gt; 설명하려고 노력해야 합니다. 계산 된 속성 및 메서드를 통해 코드를 재사용 할 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6ea587468c4ec32d2f1887fb0a3ec352fc003ce" translate="yes" xml:space="preserve">
          <source>Complex expressions in your templates make them less declarative. We should strive to describe &lt;em&gt;what&lt;/em&gt; should appear, not &lt;em&gt;how&lt;/em&gt; we're computing that value. Computed properties and methods also allow the code to be reused.</source>
          <target state="translated">템플릿의 복잡한 표현식은 덜 선언적입니다. 우리는 그 가치를 &lt;em&gt;어떻게&lt;/em&gt; 계산 &lt;em&gt;하는지&lt;/em&gt; 가 아니라 &lt;em&gt;무엇이&lt;/em&gt; 나타나야 &lt;em&gt;하는지&lt;/em&gt; 설명하려고 노력해야 합니다. 계산 된 속성 및 메서드를 사용하면 코드를 다시 사용할 수도 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f564777ac40c723997c5eed12787c64f393c6531" translate="yes" xml:space="preserve">
          <source>Complexity</source>
          <target state="translated">Complexity</target>
        </trans-unit>
        <trans-unit id="a887f5d5cafcf13fc06727c3d798f2974765ab16" translate="yes" xml:space="preserve">
          <source>Component Instance Properties</source>
          <target state="translated">구성 요소 인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="a4cfb70bd503715674d13134e96b7c51983b3fec" translate="yes" xml:space="preserve">
          <source>Component Names</source>
          <target state="translated">구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="2299d18631ea2d15a7f23fd390e4ec138046f219" translate="yes" xml:space="preserve">
          <source>Component Registration</source>
          <target state="translated">구성 요소 등록</target>
        </trans-unit>
        <trans-unit id="2dbce043918d35d9470549bbaa4939fb679a4bf3" translate="yes" xml:space="preserve">
          <source>Component Testing</source>
          <target state="translated">구성 요소 테스트</target>
        </trans-unit>
        <trans-unit id="76dbbe8a930e0a69d5d347fb2b8857c7f5d041c2" translate="yes" xml:space="preserve">
          <source>Component data</source>
          <target state="translated">구성 요소 데이터</target>
        </trans-unit>
        <trans-unit id="07fa6f82748552fa6959798fe84402715f519155" translate="yes" xml:space="preserve">
          <source>Component data &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">구성 요소 데이터 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="64bc268ef382bae5f88f2c24682efcc3dd8d542d" translate="yes" xml:space="preserve">
          <source>Component events should now be declared with the &lt;code&gt;emits&lt;/code&gt; option</source>
          <target state="translated">이제 &lt;code&gt;emits&lt;/code&gt; 옵션을 사용하여 구성 요소 이벤트를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9005720e38400bff72f424ff551489a82d1f4c9" translate="yes" xml:space="preserve">
          <source>Component files</source>
          <target state="translated">구성 요소 파일</target>
        </trans-unit>
        <trans-unit id="c206757423c2c2602ec849d9038c631cc34cd0b7" translate="yes" xml:space="preserve">
          <source>Component files &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">구성 요소 파일을 &lt;sup&gt;강력히 권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05782a5202992289472cb0adc5836d14fe8b6fa5" translate="yes" xml:space="preserve">
          <source>Component name casing in JS/JSX</source>
          <target state="translated">JS / JSX의 구성 요소 이름 케이스</target>
        </trans-unit>
        <trans-unit id="8d58e990dc1ea08678461d19736c9b83a1f066ef" translate="yes" xml:space="preserve">
          <source>Component name casing in JS/JSX &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">JS / JSX의 구성 요소 이름 케이스를 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f05bdbf09514c1b53e40160337200dfc490f992d" translate="yes" xml:space="preserve">
          <source>Component name casing in templates</source>
          <target state="translated">템플릿의 구성 요소 이름 케이스</target>
        </trans-unit>
        <trans-unit id="1e18a489bfacb69f08dfc8d90630a5d062c2d2f7" translate="yes" xml:space="preserve">
          <source>Component name casing in templates &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">템플릿의 구성 요소 이름 케이스를 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="629cc2db9c759e3cc55d230b3df6ceeaea9a0092" translate="yes" xml:space="preserve">
          <source>Component root nodes</source>
          <target state="translated">컴포넌트 루트 노드</target>
        </trans-unit>
        <trans-unit id="a123d7f78d70c0b6001f7359d734ea29890190d1" translate="yes" xml:space="preserve">
          <source>Component style scoping</source>
          <target state="translated">컴포넌트 스타일 범위</target>
        </trans-unit>
        <trans-unit id="567ca8f77c3219302641a1a6b3cbf6b6345370dd" translate="yes" xml:space="preserve">
          <source>Component style scoping &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">구성 요소 스타일 범위 지정 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7bbaeb30b003b383abf66a05fbb65d25d9b1335d" translate="yes" xml:space="preserve">
          <source>Component-Scoped CSS</source>
          <target state="translated">컴포넌트 범위의 CSS</target>
        </trans-unit>
        <trans-unit id="6bd90fa3ceed4851dbf609ff767a5e21884509aa" translate="yes" xml:space="preserve">
          <source>Component-scoped CSS</source>
          <target state="translated">컴포넌트 범위의 CSS</target>
        </trans-unit>
        <trans-unit id="8d0cf1a050de42b443ac925117ffdf995c1b67b0" translate="yes" xml:space="preserve">
          <source>Component-scoped CSS (opens new window)</source>
          <target state="translated">구성 요소 범위 CSS (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="84cc863bd6ebde8b18b087a1a41708311c44c9c8" translate="yes" xml:space="preserve">
          <source>Component/instance options order</source>
          <target state="translated">구성 요소 / 인스턴스 옵션 순서</target>
        </trans-unit>
        <trans-unit id="f99f2514ac8da860e451570040ac9cb079725a4d" translate="yes" xml:space="preserve">
          <source>Component/instance options order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">구성 요소 / 인스턴스 옵션 주문 &lt;sup&gt;권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="630acc980e704e87c41531a9bf0ab1c959379bd2" translate="yes" xml:space="preserve">
          <source>Components - &lt;code&gt;.sync&lt;/code&gt; Modifier</source>
          <target state="translated">구성 요소 &lt;code&gt;.sync&lt;/code&gt; 수정 자</target>
        </trans-unit>
        <trans-unit id="d697039b56319687b789c001bdf552b6a593e277" translate="yes" xml:space="preserve">
          <source>Components - Cheap Static Components with &lt;code&gt;v-once&lt;/code&gt;</source>
          <target state="translated">구성 요소 &lt;code&gt;v-once&lt;/code&gt; 사용한 저렴한 정적 구성 요소</target>
        </trans-unit>
        <trans-unit id="d625a365fe460c7ab04d19527319878856813a39" translate="yes" xml:space="preserve">
          <source>Components - Custom Events</source>
          <target state="translated">구성 요소-맞춤 이벤트</target>
        </trans-unit>
        <trans-unit id="69cc86f0e375b71a83275042d25019bde0a799a9" translate="yes" xml:space="preserve">
          <source>Components - Form Input Components using Custom Events</source>
          <target state="translated">구성 요소-사용자 정의 이벤트를 사용하는 양식 입력 구성 요소</target>
        </trans-unit>
        <trans-unit id="ed808ded769fe1e869b0b0eb75743c5cb99a86fd" translate="yes" xml:space="preserve">
          <source>Components - Props</source>
          <target state="translated">구성 요소-소품</target>
        </trans-unit>
        <trans-unit id="10badeeb0b180e6f4fa46f1b15d0aa67f6c92fd6" translate="yes" xml:space="preserve">
          <source>Components - Slots</source>
          <target state="translated">구성 요소-슬롯</target>
        </trans-unit>
        <trans-unit id="6a8337b74e1a1b3b9d6b1d47003c0d53d7467618" translate="yes" xml:space="preserve">
          <source>Components Basics</source>
          <target state="translated">구성 요소 기본 사항</target>
        </trans-unit>
        <trans-unit id="210b093c9d529435bd265dfba160e9bc0cc42380" translate="yes" xml:space="preserve">
          <source>Components Created by Functions</source>
          <target state="translated">함수에 의해 생성 된 구성 요소</target>
        </trans-unit>
        <trans-unit id="51a0fec9dace472c37dae5a959b04b6a0009286c" translate="yes" xml:space="preserve">
          <source>Components are reusable Vue instances with a name: in this case, &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt;. We can use this component as a custom element inside a root Vue instance created with &lt;code&gt;new Vue&lt;/code&gt;:</source>
          <target state="translated">컴포넌트는 이름이 다음과 같은 재사용 가능한 Vue 인스턴스입니다 (이 경우 &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; ) . 이 컴포넌트를 &lt;code&gt;new Vue&lt;/code&gt; 로 생성 된 루트 Vue 인스턴스 내에서 사용자 지정 요소로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bfc01b12f5156b43de8ec8a935476f6411110b7" translate="yes" xml:space="preserve">
          <source>Components are reusable instances with a name: in this case, &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt;. We can use this component as a custom element inside a root instance:</source>
          <target state="translated">구성 요소는 이름이있는 재사용 가능한 인스턴스입니다 (이 경우 &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; ) . 이 구성 요소를 루트 인스턴스 내에서 사용자 정의 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe22238a07bd729b9368a1ce01069d211a98d786" translate="yes" xml:space="preserve">
          <source>Components can be reused as many times as you want:</source>
          <target state="translated">구성 요소는 원하는 횟수만큼 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b8c94b116d43a888484c937f13d55f1ba3fd31e" translate="yes" xml:space="preserve">
          <source>Components can recursively invoke themselves in their own template. However, they can only do so with the &lt;code&gt;name&lt;/code&gt; option:</source>
          <target state="translated">컴포넌트는 자체 템플릿에서 재귀 적으로 호출 할 수 있습니다. 그러나 &lt;code&gt;name&lt;/code&gt; 옵션으로 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="751b8b7146d51c067716448a26cd434906e1c55f" translate="yes" xml:space="preserve">
          <source>Components can specify requirements for its props, such as the types you&amp;rsquo;ve already seen. If a requirement isn&amp;rsquo;t met, Vue will warn you in the browser&amp;rsquo;s JavaScript console. This is especially useful when developing a component that&amp;rsquo;s intended to be used by others.</source>
          <target state="translated">컴포넌트는 이미 본 유형과 같은 소품에 대한 요구 사항을 지정할 수 있습니다. 요구 사항이 충족되지 않으면 Vue가 브라우저의 JavaScript 콘솔에서 경고합니다. 이것은 다른 사람이 사용하도록 구성 요소를 개발할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bd42b95624c88531a1bf42404c11ffe1d832492b" translate="yes" xml:space="preserve">
          <source>Components can specify requirements for their props, such as the types you've already seen. If a requirement isn't met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that's intended to be used by others.</source>
          <target state="translated">구성 요소는 이미 본 유형과 같은 소품에 대한 요구 사항을 지정할 수 있습니다. 요구 사항이 충족되지 않으면 Vue가 브라우저의 JavaScript 콘솔에서 경고합니다. 이것은 다른 사람들이 사용하도록 의도 된 구성 요소를 개발할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2fee40168c1a374ccf26caec6fd7fe0c040bc31c" translate="yes" xml:space="preserve">
          <source>Components now always replace the element they&amp;rsquo;re bound to. To simulate the behavior of &lt;code&gt;replace: false&lt;/code&gt;, you can wrap your root component with an element similar to the one you&amp;rsquo;re replacing. For example:</source>
          <target state="translated">구성 요소는 항상 바인딩 된 요소를 대체합니다. &lt;code&gt;replace: false&lt;/code&gt; 의 동작을 시뮬레이션하려면 루트 구성 요소를 바꾸려는 요소와 유사한 요소로 래핑 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2e6a0f1ecf6c973ca47ca7186c80185b6b96f21" translate="yes" xml:space="preserve">
          <source>Components that self-close communicate that they not only have no content, but are &lt;strong&gt;meant&lt;/strong&gt; to have no content. It&amp;rsquo;s the difference between a blank page in a book and one labeled &amp;ldquo;This page intentionally left blank.&amp;rdquo; Your code is also cleaner without the unnecessary closing tag.</source>
          <target state="translated">자체 닫기 구성 요소는 컨텐츠가 없을뿐 아니라 컨텐츠가 없음을 &lt;strong&gt;의미&lt;/strong&gt; 합니다. 책의 빈 페이지와 '이 페이지는 의도적으로 비워 두었습니다.'라고 표시된 페이지의 차이점입니다. 불필요한 닫는 태그가 없어도 코드가 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="2e223bc7b893df797c91c9e1ab13b87188f6c0b5" translate="yes" xml:space="preserve">
          <source>Components that self-close communicate that they not only have no content, but are &lt;strong&gt;meant&lt;/strong&gt; to have no content. It's the difference between a blank page in a book and one labeled &quot;This page intentionally left blank.&quot; Your code is also cleaner without the unnecessary closing tag.</source>
          <target state="translated">자체적으로 닫히는 구성 요소는 콘텐츠가 없을뿐만 아니라 콘텐츠가 &lt;strong&gt;없다는 것을 의미&lt;/strong&gt; 합니다. 책의 빈 페이지와 &quot;이 페이지는 의도적으로 비워 두었습니다.&quot;라는 레이블이 붙은 페이지의 차이입니다. 불필요한 닫는 태그가 없어도 코드가 더 깔끔해집니다.</target>
        </trans-unit>
        <trans-unit id="660d87cb56480f4244feeffc6da7619b7edbffc0" translate="yes" xml:space="preserve">
          <source>Composing with Components</source>
          <target state="translated">컴포넌트로 구성</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="612f6427c9092a5834602047d990b4384c86915b" translate="yes" xml:space="preserve">
          <source>Composition API</source>
          <target state="translated">구성 API</target>
        </trans-unit>
        <trans-unit id="e75064cf3469567a0906eb3d0680b3f68039ca5b" translate="yes" xml:space="preserve">
          <source>Composition API Provide / Inject</source>
          <target state="translated">구성 API 제공 / 주입</target>
        </trans-unit>
        <trans-unit id="033df9e53f3c41d998764183ce8c3889a5f1ff4c" translate="yes" xml:space="preserve">
          <source>Composition API template refs do not have special handling when used inside &lt;code&gt;v-for&lt;/code&gt;. Instead, use function refs to perform custom handling:</source>
          <target state="translated">컴포지션 API 템플릿 참조는 &lt;code&gt;v-for&lt;/code&gt; 내부에서 사용될 때 특별한 처리가 없습니다 . 대신 함수 참조를 사용하여 사용자 정의 처리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bc04ee3668d9ea0faa68ca105b627ca813d5edea" translate="yes" xml:space="preserve">
          <source>Computed Caching vs Methods</source>
          <target state="translated">컴퓨팅 캐싱 및 방법</target>
        </trans-unit>
        <trans-unit id="70bd86bd3f0d5ae194697eb2880e50cca80f426b" translate="yes" xml:space="preserve">
          <source>Computed Properties</source>
          <target state="translated">계산 된 속성</target>
        </trans-unit>
        <trans-unit id="8e13d4ac07b657d278dceef0e18d67d34114bf52" translate="yes" xml:space="preserve">
          <source>Computed Properties and Watchers</source>
          <target state="translated">계산 된 속성 및 감시자</target>
        </trans-unit>
        <trans-unit id="c1a9203aa3517f44a8e435470ea368b59319cf82" translate="yes" xml:space="preserve">
          <source>Computed Setter</source>
          <target state="translated">컴퓨팅 세터</target>
        </trans-unit>
        <trans-unit id="1e06c887f10122986c04ecdd1ab9dfd4d7865a38" translate="yes" xml:space="preserve">
          <source>Computed and Watch</source>
          <target state="translated">계산 및 시청</target>
        </trans-unit>
        <trans-unit id="7fd08b54e68d5ba648c3e2cd7b54a13866ac8eb9" translate="yes" xml:space="preserve">
          <source>Computed and watch</source>
          <target state="translated">계산 및 시청</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">계산 된 속성</target>
        </trans-unit>
        <trans-unit id="5727316a77d42c90873eecef08909f47ad335bba" translate="yes" xml:space="preserve">
          <source>Computed properties are by default getter-only, but you can also provide a setter when you need it:</source>
          <target state="translated">계산 된 속성은 기본적으로 getter 전용이지만 필요할 때 setter를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d67cf72a16ce6f7e7fef0d1c238d2dcd768988" translate="yes" xml:space="preserve">
          <source>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance&amp;rsquo;s scope (i.e. not reactive), the computed property will &lt;strong&gt;not&lt;/strong&gt; be updated.</source>
          <target state="translated">계산 된 속성은 캐시되며 반응 종속성 변경시에만 다시 계산됩니다. 특정 종속성이 인스턴스 범위를 벗어나면 (즉, 반응하지 않음) 계산 된 속성이 업데이트 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c890f6dc666bb9c2f3556ce3254daf383ff8b029" translate="yes" xml:space="preserve">
          <source>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance's scope (i.e. not reactive), the computed property will &lt;strong&gt;not&lt;/strong&gt; be updated.</source>
          <target state="translated">계산 된 속성은 캐시되고 반응 종속성 변경시에만 다시 계산됩니다. 특정 종속성이 인스턴스의 범위를 벗어난 경우 (즉, 반응이 아님) 계산 된 속성이 업데이트 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ba6cb9fc6557b5cec7e768c24fd8980831e819b3" translate="yes" xml:space="preserve">
          <source>Computed properties to be mixed into the Vue instance. All getters and setters have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Vue 인스턴스에 혼합 될 계산 된 속성입니다. 모든 getter 및 setter는 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 Vue 인스턴스에 자동으로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="48ab0d8dbe646465af24fe2f47bcf4a51645bc7c" translate="yes" xml:space="preserve">
          <source>Computed properties to be mixed into the component instance. All getters and setters have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the component instance.</source>
          <target state="translated">구성 요소 인스턴스에 혼합 될 계산 된 속성입니다. 모든 getter 및 setter는 &lt;code&gt;this&lt;/code&gt; 컨텍스트를 구성 요소 인스턴스에 자동으로 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="65f0837bea1fdaf6e388e36e0ab193471bd627ad" translate="yes" xml:space="preserve">
          <source>Computed values</source>
          <target state="translated">계산 된 값</target>
        </trans-unit>
        <trans-unit id="4e3e85efcd1f25e0bcf9f469bc4672d0184a12ae" translate="yes" xml:space="preserve">
          <source>Computed values will automatically infer the type from returned value</source>
          <target state="translated">계산 된 값은 반환 된 값에서 자동으로 유형을 유추합니다</target>
        </trans-unit>
        <trans-unit id="5cf24801a2b491e5ed7c286c67cc4ec735dfe0bf" translate="yes" xml:space="preserve">
          <source>Computed vs Watched Property</source>
          <target state="translated">계산 된 속성과 관찰 된 속성</target>
        </trans-unit>
        <trans-unit id="e0c81be5eacbe33990b3264613af44e7e00436e7" translate="yes" xml:space="preserve">
          <source>Conditional Groups with &lt;code&gt;v-if&lt;/code&gt; on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 &lt;code&gt;v-if&lt;/code&gt; 가있는 조건부 그룹</target>
        </trans-unit>
        <trans-unit id="ea9a4bba446372af01e0eb85f26e0ec3d5f7469e" translate="yes" xml:space="preserve">
          <source>Conditional Rendering</source>
          <target state="translated">조건부 렌더링</target>
        </trans-unit>
        <trans-unit id="6281861540d03adef45443a41dbce83bfb9f4b5a" translate="yes" xml:space="preserve">
          <source>Conditional display (using &lt;code&gt;v-show&lt;/code&gt;)</source>
          <target state="translated">조건부 디스플레이 ( &lt;code&gt;v-show&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="58a327cee7af8b8174524170058798f55fcb2a26" translate="yes" xml:space="preserve">
          <source>Conditional rendering (using &lt;code&gt;v-if&lt;/code&gt;)</source>
          <target state="translated">조건부 렌더링 ( &lt;code&gt;v-if&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="c0ffe0e0a9f1b16c5eadc124528b283345b2eb8a" translate="yes" xml:space="preserve">
          <source>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, its content will be extracted as the conditional block.</source>
          <target state="translated">표현식 값의 진실성을 기반으로 요소를 조건부로 렌더링합니다. 토글 중에 요소 및 포함 된 지시문 / 구성 요소가 삭제되고 재구성됩니다. 요소가 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소 인 경우 해당 컨텐츠는 조건부 블록으로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a6d3bea1f126fba65a513b23bf60879adf5de8" translate="yes" xml:space="preserve">
          <source>Conditionals and Loops</source>
          <target state="translated">조건부 및 루프</target>
        </trans-unit>
        <trans-unit id="78d3e47c861a9d35861af2b80ffb69e1e64a09e1" translate="yes" xml:space="preserve">
          <source>Configure whether to allow &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; inspection. This option&amp;rsquo;s default value is &lt;code&gt;true&lt;/code&gt; in development builds and &lt;code&gt;false&lt;/code&gt; in production builds. You can set it to &lt;code&gt;true&lt;/code&gt; to enable inspection for production builds.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt; 검사 허용 여부를 구성하십시오 . 이 옵션의 기본값은 &lt;code&gt;true&lt;/code&gt; 개발 빌드와의 &lt;code&gt;false&lt;/code&gt; 생산에 빌드. 프로덕션 빌드를 검사 할 수 있도록 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a7a2cde18508fcdbc0eef0dc1900b96e726cb25" translate="yes" xml:space="preserve">
          <source>Configuring Rollup</source>
          <target state="translated">롤업 구성</target>
        </trans-unit>
        <trans-unit id="cc9fd0a5445b2c11f24138c5f6f959d6d31fb4e7" translate="yes" xml:space="preserve">
          <source>Configuring package.json</source>
          <target state="translated">package.json 구성</target>
        </trans-unit>
        <trans-unit id="5da9329f786cfa741c2201c8a027d69ba27a5fd4" translate="yes" xml:space="preserve">
          <source>Consequently, Vue will now add all event listeners that are &lt;em&gt;not&lt;/em&gt; defined as component-emitted events in the child as native event listeners to the child's root element (unless &lt;code&gt;inheritAttrs: false&lt;/code&gt; has been set in the child's options).</source>
          <target state="translated">결과적으로 Vue는 이제 자식의 구성 요소에서 생성 한 이벤트로 정의 &lt;em&gt;되지 않은&lt;/em&gt; 모든 이벤트 리스너를 자식의 루트 요소에 네이티브 이벤트 리스너로 추가합니다 ( 자녀의 옵션에 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 가 설정 되지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="4a2971bfedbb04df6c46ea48b59bc226c1e09690" translate="yes" xml:space="preserve">
          <source>Consider the following HTML structure.</source>
          <target state="translated">다음 HTML 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="aecda5716105c1bacff201d8cbf7ce49204ec9e3" translate="yes" xml:space="preserve">
          <source>Contains a hyphen (i.e., has multiple words connected with the hyphen symbol)</source>
          <target state="translated">하이픈 포함 (예 : 하이픈 기호로 연결된 여러 단어 포함)</target>
        </trans-unit>
        <trans-unit id="2d5245043aebcf4a49be946c4f6e0eb2145a5b9e" translate="yes" xml:space="preserve">
          <source>Contains hard-coded prod/dev branches, and the prod build is pre-minified. Use the &lt;code&gt;*.prod.js&lt;/code&gt; files for production.</source>
          <target state="translated">하드 코딩 된 prod / dev 브랜치를 포함하며 prod 빌드는 미리 축소됩니다. 프로덕션 에는 &lt;code&gt;*.prod.js&lt;/code&gt; 파일을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="445aad4957c1feec85e04d68a340464226aefa88" translate="yes" xml:space="preserve">
          <source>Contains parent-scope &lt;code&gt;v-on&lt;/code&gt; event listeners (without &lt;code&gt;.native&lt;/code&gt; modifiers). This can be passed down to an inner component via &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; - useful when creating transparent wrapper components.</source>
          <target state="translated">부모 범위 &lt;code&gt;v-on&lt;/code&gt; 이벤트 리스너를 포함합니다 ( &lt;code&gt;.native&lt;/code&gt; 수정 자 없음). 이것은 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; 를 통해 내부 구성 요소로 전달 될 수 있습니다 . 투명한 래퍼 구성 요소를 만들 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7afa3dae881ae74558506ce0892c24e74624d285" translate="yes" xml:space="preserve">
          <source>Contains parent-scope attribute bindings (except for &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;) that are not recognized (and extracted) as props. When a component doesn&amp;rsquo;t have any declared props, this essentially contains all parent-scope bindings (except for &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;), and can be passed down to an inner component via &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; - useful when creating higher-order components.</source>
          <target state="translated">소품으로 인식 및 추출되지 않은 부모 범위 속성 바인딩 ( &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 제외)이 포함되어 있습니다 . 구성 요소가 선언 된 모든 소품을 가지고 있지 않는 경우,이 본질적으로 (을 제외한 모든 부모 범위 바인딩을 포함 &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;style&lt;/code&gt; )을 통해 내부 구성 요소에 아래로 전달 될 수있는 &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; - 유용 높은 만들 때 주문 구성 요소.</target>
        </trans-unit>
        <trans-unit id="40e4af351f17e12f8ec670fbb7ac5c3f97a6e0de" translate="yes" xml:space="preserve">
          <source>Contains parent-scope attribute bindings and events that are not recognized (and extracted) as component &lt;a href=&quot;options-data#props&quot;&gt;props&lt;/a&gt; or &lt;a href=&quot;options-data#emits&quot;&gt;custom events&lt;/a&gt;. When a component doesn't have any declared props or custom events, this essentially contains all parent-scope bindings, and can be passed down to an inner component via &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; - useful when creating higher-order components.</source>
          <target state="translated">컴포넌트 &lt;a href=&quot;options-data#props&quot;&gt;props&lt;/a&gt; 또는 &lt;a href=&quot;options-data#emits&quot;&gt;사용자 정의 이벤트&lt;/a&gt; 로 인식 (추출)되지 않는 상위 범위 속성 바인딩 및 이벤트를 포함 합니다 . 구성 요소에 선언 된 props 또는 사용자 정의 이벤트가없는 경우 기본적으로 모든 부모 범위 바인딩이 포함되며 &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt; 를 통해 내부 구성 요소로 전달할 수 있습니다 . 이는 고차 구성 요소를 만들 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="59495b7ca0f2a9b72ff075971da46a0a4c80ab3d" translate="yes" xml:space="preserve">
          <source>Content Distribution with Slots</source>
          <target state="translated">슬롯이있는 컨텐츠 배포</target>
        </trans-unit>
        <trans-unit id="ca3d2dc1d907b17312d85e3f062534361d8e0f00" translate="yes" xml:space="preserve">
          <source>Content inserted via named &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; no longer preserves the &lt;code&gt;slot&lt;/code&gt; attribute. Use a wrapper element to style them, or for advanced use cases, modify the inserted content programmatically using &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">명명 된 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 을 통해 삽입 된 컨텐츠는 더 이상 &lt;code&gt;slot&lt;/code&gt; 속성을 유지하지 않습니다 . 랩퍼 요소를 사용하여 스타일을 지정하거나 고급 사용 사례의 경우 &lt;a href=&quot;render-function&quot;&gt;렌더링 함수를&lt;/a&gt; 사용하여 프로그래밍 방식으로 삽입 된 컨텐츠를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5eb91b0829532e5438126543dc42de53e0dd9b3" translate="yes" xml:space="preserve">
          <source>Content that is relevant and that users will likely want to navigate to. Label must be provided for this element</source>
          <target state="translated">관련성이 있고 사용자가 탐색하기를 원하는 콘텐츠입니다. 이 요소에 대한 레이블을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="57d31c2eb33df9234757a4d517416148a5a9edf8" translate="yes" xml:space="preserve">
          <source>Contribute Code</source>
          <target state="translated">기여 코드</target>
        </trans-unit>
        <trans-unit id="2d82a4b27a4b305690d5ac612046a955778a9fa5" translate="yes" xml:space="preserve">
          <source>Contributing</source>
          <target state="translated">Contributing</target>
        </trans-unit>
        <trans-unit id="7d0d4a0cab34f47e91912629a442a10056ba6924" translate="yes" xml:space="preserve">
          <source>Controlling Reusable Elements with &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 재사용 가능한 요소 제어</target>
        </trans-unit>
        <trans-unit id="5d62c87737211740fe0f51a9aec4aaf2fdb68d5a" translate="yes" xml:space="preserve">
          <source>Controlling Updates</source>
          <target state="translated">업데이트 제어</target>
        </trans-unit>
        <trans-unit id="be274b2406040eb23ad4f18793d576d72de70ae6" translate="yes" xml:space="preserve">
          <source>Converts a reactive object to a plain object where each property of the resulting object is a &lt;a href=&quot;#ref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; pointing to the corresponding property of the original object.</source>
          <target state="translated">반응 객체를 결과 객체의 각 속성 이 원래 객체의 해당 속성을 가리키는 &lt;a href=&quot;#ref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 일반 객체로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2abf3f548706125bce97eab08626d8b83f998bed" translate="yes" xml:space="preserve">
          <source>Create a &amp;ldquo;subclass&amp;rdquo; of the base Vue constructor. The argument should be an object containing component options.</source>
          <target state="translated">기본 Vue 생성자의 &quot;하위 클래스&quot;를 만듭니다. 인수는 구성 요소 옵션을 포함하는 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7b636affe4316b21cee1c56f29df138a02ece0fc" translate="yes" xml:space="preserve">
          <source>Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.</source>
          <target state="translated">양식 입력 요소 또는 컴포넌트에 양방향 바인딩을 작성하십시오. 자세한 사용법 및 기타 참고 사항은 아래 링크 된 가이드 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0c287c473866392ca7f05f478d1a331b3f94512" translate="yes" xml:space="preserve">
          <source>Creates a customized ref with explicit control over its dependency tracking and updates triggering. It expects a factory function, which receives &lt;code&gt;track&lt;/code&gt; and &lt;code&gt;trigger&lt;/code&gt; functions as arguments and should return an object with &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="translated">종속성 추적 및 업데이트 트리거를 명시 적으로 제어하여 사용자 지정 참조를 만듭니다. &lt;code&gt;track&lt;/code&gt; 및 &lt;code&gt;trigger&lt;/code&gt; 함수를 인수로 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 로 객체를 반환해야하는 팩토리 함수 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c070dd7a22a2b8ac3a00dcf394b9bb42e3c57bde" translate="yes" xml:space="preserve">
          <source>Creates a proxy that makes its own properties readonly, but does not perform deep readonly conversion of nested objects (exposes raw values).</source>
          <target state="translated">고유 한 속성을 읽기 전용으로 만들지 만 중첩 된 개체의 깊은 읽기 전용 변환을 수행하지 않는 프록시를 만듭니다 (원시 값 노출).</target>
        </trans-unit>
        <trans-unit id="4933d249c0a06046a33a8545daaf20ea767fd2f1" translate="yes" xml:space="preserve">
          <source>Creates a reactive proxy that tracks reactivity of its own properties but does not perform deep reactive conversion of nested objects (exposes raw values).</source>
          <target state="translated">자체 속성의 반응성을 추적하지만 중첩 된 개체의 심층 반응 변환을 수행하지 않는 반응 프록시를 만듭니다 (원시 값 노출).</target>
        </trans-unit>
        <trans-unit id="a7230afa88e0fe715580041eaaf4db18b0013f1f" translate="yes" xml:space="preserve">
          <source>Creates a ref that tracks its own &lt;code&gt;.value&lt;/code&gt; mutation but doesn't make its value reactive.</source>
          <target state="translated">자체 &lt;code&gt;.value&lt;/code&gt; 변형 을 추적 하지만 값을 반응 적으로 만들지 않는 참조를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b8031eb92d36dd3258280a447c01dfb377169882" translate="yes" xml:space="preserve">
          <source>Creates an async component that will be loaded only when it's necessary.</source>
          <target state="translated">필요할 때만로드되는 비동기 구성 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="86d4b0d54af8d43a7ebdd772c249685559cfc2cb" translate="yes" xml:space="preserve">
          <source>Creating Component VNodes</source>
          <target state="translated">구성 요소 VNode 생성</target>
        </trans-unit>
        <trans-unit id="4955ca6021637be97028e5001914e72d9453df79" translate="yes" xml:space="preserve">
          <source>Creating Standalone Reactive Values as &lt;code&gt;refs&lt;/code&gt;</source>
          <target state="translated">독립형 반응성 값을 생성 &lt;code&gt;refs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="411f67b2d6caf45fc0664fef6e8ad77135abe64b" translate="yes" xml:space="preserve">
          <source>Creating Vue components allows us to extract repeatable parts of the interface coupled with its functionality into reusable pieces of code. This alone can get our application pretty far in terms of maintainability and flexibility. However, our collective experience has proved that this alone might not be enough, especially when your application is getting really big &amp;ndash; think several hundred components. When dealing with such large applications, sharing and reusing code becomes especially important.</source>
          <target state="translated">Vue 컴포넌트를 생성하면 기능과 결합 된 인터페이스의 반복 가능한 부분을 재사용 가능한 코드 조각으로 추출 할 수 있습니다. 이것만으로도 유지 관리 및 유연성 측면에서 우리의 응용 프로그램을 상당히 멀리 얻을 수 있습니다. 그러나 우리의 집단적 경험은 이것만으로는 충분하지 않을 수 있다는 것을 증명했습니다. 특히 여러분의 응용 프로그램이 정말 커질 때 수백 개의 구성 요소를 생각해보십시오. 이러한 대규모 애플리케이션을 다룰 때 코드 공유 및 재사용이 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e4428591f6bfdcff9018444de4e4b2c12acd1b20" translate="yes" xml:space="preserve">
          <source>Creating a Vue Instance</source>
          <target state="translated">Vue 인스턴스 만들기</target>
        </trans-unit>
        <trans-unit id="b009a01dd1e99b8b973c753ee1657cd37b2e183e" translate="yes" xml:space="preserve">
          <source>Creating an Application Instance</source>
          <target state="translated">애플리케이션 인스턴스 생성</target>
        </trans-unit>
        <trans-unit id="a0bad3e2293e6592628213507af5552ae02f3d37" translate="yes" xml:space="preserve">
          <source>Cross-browser testing</source>
          <target state="translated">브라우저 간 테스트</target>
        </trans-unit>
        <trans-unit id="3fa68b43cccf63727634ad0b61db7f38266f6488" translate="yes" xml:space="preserve">
          <source>Currently in Beta - Vuex and Router integration is still WIP</source>
          <target state="translated">현재 베타 버전-Vuex 및 라우터 통합은 여전히 ​​WIP입니다.</target>
        </trans-unit>
        <trans-unit id="e25a5433a4b0677aa872e250bb371466ff37cbdf" translate="yes" xml:space="preserve">
          <source>Custom Directives</source>
          <target state="translated">사용자 지정 지시어</target>
        </trans-unit>
        <trans-unit id="b2605830095ea9664e9b6b0e78b2dfce357336ca" translate="yes" xml:space="preserve">
          <source>Custom Directives &lt;sup&gt;simplified&lt;/sup&gt;</source>
          <target state="translated">사용자 지정 지시문 &lt;sup&gt;단순화&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="27e4c05b913f36d7873e62728e841a2e8ed91851" translate="yes" xml:space="preserve">
          <source>Custom Elements</source>
          <target state="translated">맞춤 요소</target>
        </trans-unit>
        <trans-unit id="12ac1d58b77838fd4a14634c8694773b2b55bb59" translate="yes" xml:space="preserve">
          <source>Custom Elements Interop</source>
          <target state="translated">맞춤 요소 Interop</target>
        </trans-unit>
        <trans-unit id="30f552fb7d2523e7c921d75d7494408388c644e4" translate="yes" xml:space="preserve">
          <source>Custom Events</source>
          <target state="translated">맞춤 이벤트</target>
        </trans-unit>
        <trans-unit id="b7921e476147d86cf859de06a785218c56f57833" translate="yes" xml:space="preserve">
          <source>Custom Option Merge Strategies</source>
          <target state="translated">사용자 정의 옵션 병합 전략</target>
        </trans-unit>
        <trans-unit id="45b3b47d95e376c23eb2bf9a7026857086058e80" translate="yes" xml:space="preserve">
          <source>Custom Transition Classes</source>
          <target state="translated">커스텀 트랜지션 클래스</target>
        </trans-unit>
        <trans-unit id="6342d2a1e7f2a3e93125d66fe5182864e99353a0" translate="yes" xml:space="preserve">
          <source>Custom component events</source>
          <target state="translated">사용자 컴포넌트 이벤트</target>
        </trans-unit>
        <trans-unit id="8d940b69d17b752557bab9827083a1a33173114f" translate="yes" xml:space="preserve">
          <source>Custom directive API changed to align with component lifecycle</source>
          <target state="translated">구성 요소 수명주기에 맞게 변경된 사용자 지정 지시문 API</target>
        </trans-unit>
        <trans-unit id="0181fa719d3be2888b2c81fe56540b5c47984363" translate="yes" xml:space="preserve">
          <source>Custom elements whitelisting is now performed during template compilation</source>
          <target state="translated">이제 템플릿 컴파일 중에 맞춤 요소 허용 목록이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="87204d79f0d85c763f871e11f9645cfcdbf30541" translate="yes" xml:space="preserve">
          <source>Custom events can also be used to create custom inputs that work with &lt;code&gt;v-model&lt;/code&gt;. Remember that:</source>
          <target state="translated">사용자 정의 이벤트는 &lt;code&gt;v-model&lt;/code&gt; 과 함께 작동하는 사용자 정의 입력을 작성하는 데 사용될 수도 있습니다 . 기억:</target>
        </trans-unit>
        <trans-unit id="34e532f7f85fc6e1566da2ed31f40f937a3a6670" translate="yes" xml:space="preserve">
          <source>Custom renderers can pass in the platform specific types like this:</source>
          <target state="translated">커스텀 렌더러는 다음과 같은 플랫폼 특정 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c39a207e283bc7bdcf96aa4cc5abcb84d2d6a23" translate="yes" xml:space="preserve">
          <source>Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation &lt;a href=&quot;../guide/components-props#Prop-Validation&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">prop 값을 유일한 인수로 사용하는 사용자 정의 유효성 검증기 함수. 비 프로덕션 환경에서이 함수가 잘못된 값을 반환하면 (예 : 유효성 검사 실패) 콘솔 경고가 발생합니다. 소품 검증에 대한 자세한 내용은 &lt;a href=&quot;../guide/components-props#Prop-Validation&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b163c0684317e077358b18b7072cf5ff3ed1dd23" translate="yes" xml:space="preserve">
          <source>Customized Built-in Elements</source>
          <target state="translated">맞춤형 내장 요소</target>
        </trans-unit>
        <trans-unit id="9482d884bbaefa018603b26f6945593b108f36a4" translate="yes" xml:space="preserve">
          <source>Customizing Component &lt;code&gt;v-model&lt;/code&gt;</source>
          <target state="translated">구성 요소 &lt;code&gt;v-model&lt;/code&gt; 사용자 정의</target>
        </trans-unit>
        <trans-unit id="d993ba3453092fb751f5b03754015ef413312eb8" translate="yes" xml:space="preserve">
          <source>Cypress Testing Library (opens new window)</source>
          <target state="translated">Cypress 테스트 라이브러리 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="05d40faf4376654187131af4e62a05bff963bb93" translate="yes" xml:space="preserve">
          <source>Cypress' Official Website (opens new window)</source>
          <target state="translated">Cypress의 공식 웹 사이트 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="bfed62014c1ae52446eebdc7c0230e3d1992ba8d" translate="yes" xml:space="preserve">
          <source>Cypress.io</source>
          <target state="translated">Cypress.io</target>
        </trans-unit>
        <trans-unit id="dca25f7239978714a47ef1b0f58c66760865b273" translate="yes" xml:space="preserve">
          <source>Cypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.</source>
          <target state="translated">Cypress.io는 개발자가 일류 개발자 경험을 제공하면서 애플리케이션을 안정적으로 테스트 할 수 있도록하여 개발자 생산성을 향상시키는 것을 목표로하는 테스트 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="61f6f421ef32670498c220ee8ee339df076a5ad9" translate="yes" xml:space="preserve">
          <source>DOM</source>
          <target state="translated">DOM</target>
        </trans-unit>
        <trans-unit id="06a565f3773a61c8641dff267c8ded6bcd9b3f9c" translate="yes" xml:space="preserve">
          <source>DOM Template Parsing Caveats</source>
          <target state="translated">DOM 템플릿 파싱주의 사항</target>
        </trans-unit>
        <trans-unit id="b51cca4b51fb1200a40ecaa657030eabf6191260" translate="yes" xml:space="preserve">
          <source>DOM-Focused Instance Methods</source>
          <target state="translated">DOM 중심의 인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="e5e429bcc9c2e4a41a3c7a4d96203be6cb273b11" translate="yes" xml:space="preserve">
          <source>Data</source>
          <target state="translated">Data</target>
        </trans-unit>
        <trans-unit id="1b5526b4e58b1155390d6513a29a1da140c24070" translate="yes" xml:space="preserve">
          <source>Data Binding Syntax - interpolations</source>
          <target state="translated">데이터 바인딩 구문-보간</target>
        </trans-unit>
        <trans-unit id="0d8eeff8c2ab8a6c656c195c4b8389d3f6b2bf7d" translate="yes" xml:space="preserve">
          <source>Data Option</source>
          <target state="translated">데이터 옵션</target>
        </trans-unit>
        <trans-unit id="ed2029b7397dab2ae925d537c8d34a1486d691af" translate="yes" xml:space="preserve">
          <source>Data Properties</source>
          <target state="translated">데이터 속성</target>
        </trans-unit>
        <trans-unit id="3b383971471f26d7fe0ced26f2256208b2163fc2" translate="yes" xml:space="preserve">
          <source>Data Properties and Methods</source>
          <target state="translated">데이터 속성 및 방법</target>
        </trans-unit>
        <trans-unit id="77366f440a2b74b929dfbae3704e0ee470afe05e" translate="yes" xml:space="preserve">
          <source>Data and Methods</source>
          <target state="translated">데이터 및 방법</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="2feee70bbca629f658947940a904eb85951db366" translate="yes" xml:space="preserve">
          <source>Debouncing and Throttling</source>
          <target state="translated">디 바운싱 및 스로틀 링</target>
        </trans-unit>
        <trans-unit id="3dbd5db7967ac1aa2137f6c5db041d637cd7562b" translate="yes" xml:space="preserve">
          <source>Debouncing is used to limit how often we execute Ajax requests and other expensive operations. Vue&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt; attribute parameter for &lt;code&gt;v-model&lt;/code&gt; made this easy for very simple cases, but it actually debounced &lt;strong&gt;state updates&lt;/strong&gt; rather than the expensive operations themselves. It&amp;rsquo;s a subtle difference, but it comes with limitations as an application grows.</source>
          <target state="translated">Debouncing은 Ajax 요청 및 기타 비싼 작업을 얼마나 자주 실행하는지 제한하는 데 사용됩니다. &lt;code&gt;v-model&lt;/code&gt; 대한 Vue의 &lt;code&gt;debounce&lt;/code&gt; 속성 매개 변수는 매우 간단한 경우에 이것을 쉽게 만들었지 만 실제로 는 비싼 작업 자체보다는 &lt;strong&gt;상태 업데이트를&lt;/strong&gt; 거부 했습니다. 미묘한 차이이지만 응용 프로그램이 증가함에 따라 한계가 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2b400be160585ef7d6a1e0a5c8cd2d26e163dfb" translate="yes" xml:space="preserve">
          <source>Declarative Rendering</source>
          <target state="translated">선언적 렌더링</target>
        </trans-unit>
        <trans-unit id="60326be113e84d326e32fb44f3563b6652a74f33" translate="yes" xml:space="preserve">
          <source>Declaring Reactive Properties</source>
          <target state="translated">반응성 속성 선언</target>
        </trans-unit>
        <trans-unit id="b991967e09501eb4e1f3d99f121090c22493ce55" translate="yes" xml:space="preserve">
          <source>Declaring Reactive State</source>
          <target state="translated">반응 상태 선언</target>
        </trans-unit>
        <trans-unit id="19119a0240ee87794f1539cc386759e6432b0af1" translate="yes" xml:space="preserve">
          <source>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you&amp;rsquo;ve changed some data to wait for the DOM update.</source>
          <target state="translated">다음 DOM 업데이트주기 후에 실행될 콜백을 연기하십시오. DOM 업데이트를 기다리도록 일부 데이터를 변경 한 직후에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="db1b7ad7e26590367943109c215c7f0efee9147c" translate="yes" xml:space="preserve">
          <source>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you&amp;rsquo;ve changed some data to wait for the DOM update. This is the same as the global &lt;code&gt;Vue.nextTick&lt;/code&gt;, except that the callback&amp;rsquo;s &lt;code&gt;this&lt;/code&gt; context is automatically bound to the instance calling this method.</source>
          <target state="translated">다음 DOM 업데이트주기 후에 실행될 콜백을 연기하십시오. DOM 업데이트를 기다리도록 일부 데이터를 변경 한 직후에 사용하십시오. 이는 글로벌과 동일 &lt;code&gt;Vue.nextTick&lt;/code&gt; 콜백의 것을 제외하고, &lt;code&gt;this&lt;/code&gt; 상황이 자동으로이 메서드를 호출 인스턴스에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c7ccb121dbbd7c9fece3e6131d5cff3243ae8699" translate="yes" xml:space="preserve">
          <source>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update. This is the same as the global &lt;code&gt;nextTick&lt;/code&gt;, except that the callback's &lt;code&gt;this&lt;/code&gt; context is automatically bound to the instance calling this method.</source>
          <target state="translated">다음 DOM 업데이트주기 후에 콜백이 실행되도록 연기합니다. DOM 업데이트를 기다리기 위해 일부 데이터를 변경 한 후 즉시 사용하십시오. 콜백의 &lt;code&gt;this&lt;/code&gt; 컨텍스트가이 메서드를 호출하는 인스턴스에 자동으로 바인딩 된다는 점을 제외 하면 전역 &lt;code&gt;nextTick&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3aeedfa2bb6af21a6c240454b04a9d9a6077d201" translate="yes" xml:space="preserve">
          <source>Define custom key alias(es) for &lt;code&gt;v-on&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 에 대한 사용자 정의 키 별명을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="07cb7b03644814ccec1bd1576e0cdc6073329f9f" translate="yes" xml:space="preserve">
          <source>Define custom merging strategies for options.</source>
          <target state="translated">옵션에 대한 사용자 정의 병합 전략을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="80ef2f78a56b3bfe4204b710a675b829c1df038e" translate="yes" xml:space="preserve">
          <source>Define merging strategies for custom options.</source>
          <target state="translated">사용자 지정 옵션에 대한 병합 전략을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f14e2bbf870e3072284518da52bbf318ef3de3e0" translate="yes" xml:space="preserve">
          <source>Define your own property (e.g. &lt;code&gt;isLoading&lt;/code&gt;), then update the loading state in a watcher on the route. For example, if fetching data with &lt;a href=&quot;https://github.com/mzabriskie/axios&quot;&gt;axios&lt;/a&gt;:</source>
          <target state="translated">자신의 속성 (예 : &lt;code&gt;isLoading&lt;/code&gt; )을 정의한 다음 경로의 감시자에서로드 상태를 업데이트하십시오. 예를 들어, &lt;a href=&quot;https://github.com/mzabriskie/axios&quot;&gt;axios로&lt;/a&gt; 데이터를 가져 오는 경우 :</target>
        </trans-unit>
        <trans-unit id="7886c9ac31585e7059a2a594d6d51d9f8af55bc5" translate="yes" xml:space="preserve">
          <source>Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.</source>
          <target state="translated">소품이 필요한지 정의합니다. 프로덕션 환경이 아닌 경우이 값이 정확하고 소품이 전달되지 않으면 콘솔 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f660541954298ae4692655fe04409c666828aee7" translate="yes" xml:space="preserve">
          <source>Defining Custom Events</source>
          <target state="translated">사용자 지정 이벤트 정의</target>
        </trans-unit>
        <trans-unit id="08b68ef2f3f8abfa471302b3c718577183f35986" translate="yes" xml:space="preserve">
          <source>Defining Vue components</source>
          <target state="translated">Vue 구성 요소 정의</target>
        </trans-unit>
        <trans-unit id="f936e16929c240786ce41c438c9b0e7d0bceebd5" translate="yes" xml:space="preserve">
          <source>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</source>
          <target state="translated">객체의 속성을 삭제합니다. 오브젝트가 반응적인 경우 삭제가보기 업데이트를 트리거하는지 확인하십시오. 이것은 Vue가 속성 삭제를 감지 할 수 없다는 한계를 극복하기 위해 주로 사용되지만 거의 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="76d431baebcb16ff7fcbe15aee82bb0cf4ad4582" translate="yes" xml:space="preserve">
          <source>Denote named slots or slots that expect to receive props.</source>
          <target state="translated">소품을받을 것으로 예상되는 명명 된 슬롯 또는 슬롯을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="93f478066632597368c3515b0d26e59c8236ff92" translate="yes" xml:space="preserve">
          <source>Denote the &quot;else block&quot; for &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; chain.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; 또는 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else-if&lt;/code&gt; 체인의 경우 &quot;else 블록&quot;을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="842c5903404ce876959dab4568e7002718d1057e" translate="yes" xml:space="preserve">
          <source>Denote the &quot;else if block&quot; for &lt;code&gt;v-if&lt;/code&gt;. Can be chained.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; 의 &quot;else if 블록&quot;을 나타냅니다 . 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="142ea1eba23cdbbe5b68040400be1739264c9e4d" translate="yes" xml:space="preserve">
          <source>Denote the &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt; or a &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; chain.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; 또는 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else-if&lt;/code&gt; 체인 의 &quot;else 블록&quot;을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f2c984aaadf58ba802aed56b64dabd2310e7a5b4" translate="yes" xml:space="preserve">
          <source>Denote the &amp;ldquo;else if block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;. Can be chained.</source>
          <target state="translated">&lt;code&gt;v-if&lt;/code&gt; 의 경우 &quot;else if block&quot;을 나타냅니다 . 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aefbe2f210572802298b2ad0347dc9e423d2690" translate="yes" xml:space="preserve">
          <source>Dependency Injection</source>
          <target state="translated">의존성 주입</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="7c1f42119bffd331221f02c2d7e0adb0b031df05" translate="yes" xml:space="preserve">
          <source>Deprecated Syntax</source>
          <target state="translated">더 이상 사용되지 않는 구문</target>
        </trans-unit>
        <trans-unit id="b8b597e25923a72a33f925de08f51f4c3f2f4683" translate="yes" xml:space="preserve">
          <source>Designing Interface Animation: Improving the User Experience Through Animation by Val Head (opens new window)</source>
          <target state="translated">인터페이스 애니메이션 디자인 : Val Head의 애니메이션을 통한 사용자 경험 개선 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="70cb89b8a232577c2f9306ba29cded197a4a54b2" translate="yes" xml:space="preserve">
          <source>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component or HTML element using the &lt;code&gt;ref&lt;/code&gt; attribute. For example:</source>
          <target state="translated">소품과 이벤트가 있음에도 불구하고 때때로 JavaScript에서 하위 구성 요소에 직접 액세스해야하는 경우도 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이를 위해 &lt;code&gt;ref&lt;/code&gt; 속성을 사용하여 하위 구성 요소 또는 HTML 요소에 참조 ID를 할당 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bada1251cc0e33b470722abe048401582aa8546" translate="yes" xml:space="preserve">
          <source>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the &lt;code&gt;ref&lt;/code&gt; attribute. For example:</source>
          <target state="translated">소품과 이벤트가 있음에도 불구하고 때로는 JavaScript에서 하위 구성 요소에 직접 액세스해야 할 수도 있습니다. 이를 위해 &lt;code&gt;ref&lt;/code&gt; 속성을 사용하여 하위 구성 요소에 참조 ID를 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="782db185d4f61f49501293ed0db6a1f0a217a3f3" translate="yes" xml:space="preserve">
          <source>Destructuring Reactive State</source>
          <target state="translated">반응 상태 분해</target>
        </trans-unit>
        <trans-unit id="70b76287eafaba59f37405af3f173f6bfc44551a" translate="yes" xml:space="preserve">
          <source>Destructuring Slot Props</source>
          <target state="translated">슬롯 소품 정리</target>
        </trans-unit>
        <trans-unit id="d33367ca6cf4485c4124cbc1ce9096200b2e9086" translate="yes" xml:space="preserve">
          <source>Detailed &lt;a href=&quot;../guide/component-props#prop-validation&quot;&gt;prop definitions&lt;/a&gt; have two advantages:</source>
          <target state="translated">세부 &lt;a href=&quot;../guide/component-props#prop-validation&quot;&gt;소품 정의&lt;/a&gt; 에는 두 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c5a7fcb4118b23681170020a3bb0920d2f9716" translate="yes" xml:space="preserve">
          <source>Detailed &lt;a href=&quot;../guide/components#Prop-Validation&quot;&gt;prop definitions&lt;/a&gt; have two advantages:</source>
          <target state="translated">자세한 &lt;a href=&quot;../guide/components#Prop-Validation&quot;&gt;소품 정의&lt;/a&gt; 에는 두 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca6b2f29bf0e683cffc5bfdaa2638ab6df0be0b" translate="yes" xml:space="preserve">
          <source>Detailed Explanation</source>
          <target state="translated">상해</target>
        </trans-unit>
        <trans-unit id="8c8c6abfff91f498dd73acf58f1980babfbb7e18" translate="yes" xml:space="preserve">
          <source>Detailed release notes for each version are available on &lt;a href=&quot;https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md&quot;&gt;GitHub (opens new window)&lt;/a&gt;.</source>
          <target state="translated">각 버전에 대한 자세한 릴리스 정보는 &lt;a href=&quot;https://github.com/vuejs/vue-next/blob/master/CHANGELOG.md&quot;&gt;GitHub (새 창에서 열림)에서 확인할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8399fc7ad135cd736adc13fe440302a07e98cb7" translate="yes" xml:space="preserve">
          <source>Detailed release notes for each version are available on &lt;a href=&quot;https://github.com/vuejs/vue/releases&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">각 버전에 대한 자세한 릴리스 노트는 &lt;a href=&quot;https://github.com/vuejs/vue/releases&quot;&gt;GitHub에서&lt;/a&gt; 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7196ead84389ddc7b01ef77358862d251c7d4e76" translate="yes" xml:space="preserve">
          <source>Detect when there&amp;rsquo;s a change in one of the values</source>
          <target state="translated">값 중 하나에 변화가있을 때 감지</target>
        </trans-unit>
        <trans-unit id="40d9b9f619dbd27ad649a2fb2ed512704a8498dc" translate="yes" xml:space="preserve">
          <source>Dev Build</source>
          <target state="translated">개발 빌드</target>
        </trans-unit>
        <trans-unit id="de71895c6b8731341df7953e5cac6cc720d4cb3b" translate="yes" xml:space="preserve">
          <source>Development Tooling</source>
          <target state="translated">개발 툴링</target>
        </trans-unit>
        <trans-unit id="f1a6305cd34006d48f89c6b7c5b39e442c279bfb" translate="yes" xml:space="preserve">
          <source>Development vs. Production Mode</source>
          <target state="translated">개발 대 생산 모드</target>
        </trans-unit>
        <trans-unit id="e61f7a6aab9b9601861b94c2e17708a31a26f4cc" translate="yes" xml:space="preserve">
          <source>Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.</source>
          <target state="translated">개발 / 제작 모드는 UMD 빌드를 위해 하드 코딩되어 있습니다. 축소되지 않은 파일은 개발 용이고 축소 된 파일은 프로덕션 용입니다.</target>
        </trans-unit>
        <trans-unit id="7d86b227a33c0960526dea72d977c72dc74b8edb" translate="yes" xml:space="preserve">
          <source>Devtools Extension</source>
          <target state="translated">Devtools 확장</target>
        </trans-unit>
        <trans-unit id="3757cf237017d813bd35da8ec2305e895f14c3e4" translate="yes" xml:space="preserve">
          <source>Direct &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; Include</source>
          <target state="translated">직접 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="7df8abc29de3933d7d9cb30da57cfccb911c13db" translate="yes" xml:space="preserve">
          <source>Directive &lt;code&gt;.literal&lt;/code&gt; Modifier &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">지시문 &lt;code&gt;.literal&lt;/code&gt; 수정자가 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="e43c9c257ed4992f826362fcfbba8afdcac1c199" translate="yes" xml:space="preserve">
          <source>Directive Hook Arguments</source>
          <target state="translated">지시문 훅 인수</target>
        </trans-unit>
        <trans-unit id="c938d0aef00011b5a0279e01e206aed9f7ccae05" translate="yes" xml:space="preserve">
          <source>Directive arguments can be dynamic. For example, in &lt;code&gt;v-mydirective:[argument]=&quot;value&quot;&lt;/code&gt;, the &lt;code&gt;argument&lt;/code&gt; can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.</source>
          <target state="translated">지시 인수는 동적 일 수 있습니다. 예를 들면, &lt;code&gt;v-mydirective:[argument]=&quot;value&quot;&lt;/code&gt; 의 &lt;code&gt;argument&lt;/code&gt; 우리의 컴포넌트 인스턴스의 데이터 특성에 기초하여 갱신 될 수있다! 이를 통해 우리의 맞춤형 지시문은 응용 프로그램 전체에서 유연하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9140a9a668b6efa44837f17d5c5e3b23c0db39a7" translate="yes" xml:space="preserve">
          <source>Directive hooks are passed these arguments:</source>
          <target state="translated">지시문 후크에는 다음과 같은 인수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e6fc39cf25b0647f518bb1e791fb59f8693b3eb7" translate="yes" xml:space="preserve">
          <source>Directive shorthands</source>
          <target state="translated">지시문 속기</target>
        </trans-unit>
        <trans-unit id="958118e04c69e4b161491ee2580e2daa1c385c27" translate="yes" xml:space="preserve">
          <source>Directive shorthands &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">지시어 속기 &lt;sup&gt;추천&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="bbf08b3308f7275e0fc1351c6311f5b2f30fe055" translate="yes" xml:space="preserve">
          <source>Directives are special attributes with the &lt;code&gt;v-&lt;/code&gt; prefix. Directive attribute values are expected to be &lt;strong&gt;a single JavaScript expression&lt;/strong&gt; (with the exception of &lt;code&gt;v-for&lt;/code&gt; and &lt;code&gt;v-on&lt;/code&gt;, which will be discussed later). A directive's job is to reactively apply side effects to the DOM when the value of its expression changes. Let's review the example we saw in the introduction:</source>
          <target state="translated">지시문은 &lt;code&gt;v-&lt;/code&gt; 접두사 가있는 특수 속성입니다 . 지시어 속성 값은 &lt;strong&gt;단일 JavaScript 표현식&lt;/strong&gt; 이 될 것으로 예상됩니다 ( &lt;code&gt;v-for&lt;/code&gt; 및 &lt;code&gt;v-on&lt;/code&gt; 제외 , 나중에 논의 됨). 디렉티브의 역할은 표현식의 값이 변경 될 때 DOM에 부작용을 반응 적으로 적용하는 것입니다. 소개에서 본 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f6e02b52dce787224483306678d9a7ff2c5ac4ac" translate="yes" xml:space="preserve">
          <source>Directives are special attributes with the &lt;code&gt;v-&lt;/code&gt; prefix. Directive attribute values are expected to be &lt;strong&gt;a single JavaScript expression&lt;/strong&gt; (with the exception of &lt;code&gt;v-for&lt;/code&gt;, which will be discussed later). A directive&amp;rsquo;s job is to reactively apply side effects to the DOM when the value of its expression changes. Let&amp;rsquo;s review the example we saw in the introduction:</source>
          <target state="translated">지시문은 &lt;code&gt;v-&lt;/code&gt; 접두사 가있는 특수 속성입니다 . 지시어 속성 값은 &lt;strong&gt;단일 JavaScript 표현식&lt;/strong&gt; 이 될 것으로 예상됩니다 ( &lt;code&gt;v-for&lt;/code&gt; 제외 ). 지시문의 작업은 표현식의 값이 변경 될 때 부작용을 DOM에 반응 적으로 적용하는 것입니다. 소개에서 본 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5a7b078f6fffb64c05ef05bc651ea0230372543a" translate="yes" xml:space="preserve">
          <source>Directives have a greatly reduced scope of responsibility: they are now only used for applying low-level direct DOM manipulations. In most cases, you should prefer using components as the main code-reuse abstraction.</source>
          <target state="translated">지시문의 책임 범위가 크게 줄어 들었습니다. 이제는 수준이 낮은 직접 DOM 조작을 적용하는 데만 사용됩니다. 대부분의 경우 컴포넌트를 기본 코드 재사용 추상화로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2dcce90e911d0ed7e63b677b61fb05cc3faa8cba" translate="yes" xml:space="preserve">
          <source>Directives no longer have instances. This means there&amp;rsquo;s no more &lt;code&gt;this&lt;/code&gt; inside directive hooks. Instead, they receive everything they might need as arguments. If you really must persist state across hooks, you can do so on &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">지시어에는 더 이상 인스턴스가 없습니다. 이 방법 더 이상 없다 &lt;code&gt;this&lt;/code&gt; 내부 지침 후크. 대신, 그들은 필요한 모든 것을 인수로받습니다. 후크를 통해 상태를 유지해야하는 경우 &lt;code&gt;el&lt;/code&gt; 에서 그렇게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cc37d7c35424d61187e77c350659717ee6b0343" translate="yes" xml:space="preserve">
          <source>Directives vs Components</source>
          <target state="translated">지시어와 컴포넌트</target>
        </trans-unit>
        <trans-unit id="3f2cbb04f6567d1c007d0aaa5f77666916f9bcd2" translate="yes" xml:space="preserve">
          <source>Disabling Attribute Inheritance</source>
          <target state="translated">속성 상속 비활성화</target>
        </trans-unit>
        <trans-unit id="049073ae5b4c1db3b9ba9bb2b124a4b230f0bde4" translate="yes" xml:space="preserve">
          <source>Displaying Filtered/Sorted Results</source>
          <target state="translated">필터링 / 정렬 결과 표시</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="ac6ff62697994870ebaa8d684240bfd25604394a" translate="yes" xml:space="preserve">
          <source>Documentation (opens new window)</source>
          <target state="translated">문서 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="1ffc621eb894131131ce9c901ec0e437bd93e94a" translate="yes" xml:space="preserve">
          <source>Documentation Style Guide</source>
          <target state="translated">문서 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="73d96ce1397576b2063aaf6598fc7978ae441092" translate="yes" xml:space="preserve">
          <source>Does not ship minified builds (to be done together with the rest of the code after bundling)</source>
          <target state="translated">축소 된 빌드를 제공하지 않음 (번들링 후 나머지 코드와 함께 수행)</target>
        </trans-unit>
        <trans-unit id="2c0716893bee6ef8d6281c2112819d7145534f22" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t skip headings within a section</source>
          <target state="translated">섹션 내에서 제목을 건너 뛰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fad728fefe77763a68e26de84f3520b2b68a4c03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; on an options property or callback, such as &lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt; or &lt;code&gt;vm.$watch('a', newValue =&amp;gt; this.myMethod())&lt;/code&gt;. Since an arrow function doesn&amp;rsquo;t have a &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as &lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt; or &lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt;.</source>
          <target state="translated">옵션 속성 또는 콜백에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수&lt;/a&gt; 를 사용하지 마십시오 ( 예 &lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt; 또는 &lt;code&gt;vm.$watch('a', newValue =&amp;gt; this.myMethod())&lt;/code&gt; . 화살표의 기능은 가지고 있지 않기 때문에 &lt;code&gt;this&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 다른 변수로 취급 어휘 종종 같은 오류의 결과로 발견 범위까지 부모를 통해 조회 할 것이다 &lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt; 또는 &lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890db44609fe3c70adc2fb62237a57c309abca15" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;code&gt;.passive&lt;/code&gt; and &lt;code&gt;.prevent&lt;/code&gt; together, because &lt;code&gt;.prevent&lt;/code&gt; will be ignored and your browser will probably show you a warning. Remember, &lt;code&gt;.passive&lt;/code&gt; communicates to the browser that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want to prevent the event&amp;rsquo;s default behavior.</source>
          <target state="translated">&lt;code&gt;.prevent&lt;/code&gt; 가 무시되고 브라우저에 경고 메시지가 표시 되므로 &lt;code&gt;.passive&lt;/code&gt; 와 &lt;code&gt;.prevent&lt;/code&gt; 를 함께 사용하지 마십시오 . 기억 &lt;code&gt;.passive&lt;/code&gt; 당신이하는 브라우저와 통신을 &lt;em&gt;하지 않는&lt;/em&gt; 경우의 기본 동작을 방지하고자합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51f362101e6fb54f133e70f730ec6b0fa1f7594b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use non-primitive values like objects and arrays as &lt;code&gt;v-for&lt;/code&gt; keys. Use string or numeric values instead.</source>
          <target state="translated">객체 및 배열과 같은 기본이 아닌 값을 &lt;code&gt;v-for&lt;/code&gt; 키로 사용하지 마십시오 . 대신 문자열 또는 숫자 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4930e1ee5f8ecba58c1ab6aba1024cb6e3381c1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the minified version during development. You will miss out on all the nice warnings for common mistakes!</source>
          <target state="translated">개발 중에 축소 된 버전을 사용하지 마십시오. 일반적인 실수에 대한 모든 좋은 경고를 놓칠 것입니다!</target>
        </trans-unit>
        <trans-unit id="d7fbda43e75d1b10a371270ae2b01769500c90ae" translate="yes" xml:space="preserve">
          <source>Don't use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions (opens new window)&lt;/a&gt; on an options property or callback, such as &lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt; or &lt;code&gt;vm.$watch('a', newValue =&amp;gt; this.myMethod())&lt;/code&gt;. Since an arrow function doesn't have a &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as &lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt; or &lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt;.</source>
          <target state="translated">다음 과 같은 옵션 속성 또는 콜백에 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수 (새 창 &lt;/a&gt; &lt;code&gt;created: () =&amp;gt; console.log(this.a)&lt;/code&gt; 사용하지 마십시오 . () =&amp;gt; console.log (this.a) 또는 &lt;code&gt;vm.$watch('a', newValue =&amp;gt; this.myMethod())&lt;/code&gt; . 화살표의 기능은 가지고 있지 않기 때문에 &lt;code&gt;this&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 다른 변수로 취급 어휘 종종 같은 오류의 결과로 발견 범위까지 부모를 통해 조회 할 것이다 &lt;code&gt;Uncaught TypeError: Cannot read property of undefined&lt;/code&gt; 또는 &lt;code&gt;Uncaught TypeError: this.myMethod is not a function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f96f4db5aa68bf6acbbd85ad761ab64e7b916a53" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;.passive&lt;/code&gt; and &lt;code&gt;.prevent&lt;/code&gt; together, because &lt;code&gt;.prevent&lt;/code&gt; will be ignored and your browser will probably show you a warning. Remember, &lt;code&gt;.passive&lt;/code&gt; communicates to the browser that you &lt;em&gt;don't&lt;/em&gt; want to prevent the event's default behavior.</source>
          <target state="translated">&lt;code&gt;.passive&lt;/code&gt; 와 &lt;code&gt;.prevent&lt;/code&gt; 를 함께 사용하지 마십시오. &lt;code&gt;.prevent&lt;/code&gt; 가 무시되고 브라우저가 경고를 표시 할 수 있기 때문 입니다. 기억 &lt;code&gt;.passive&lt;/code&gt; 당신이하는 브라우저와 통신을 &lt;em&gt;하지 않는&lt;/em&gt; 경우의 기본 동작을 방지하고자합니다.</target>
        </trans-unit>
        <trans-unit id="dd04470f249ed3d037f0088edb94d3de201bc5ad" translate="yes" xml:space="preserve">
          <source>Don't use non-primitive values like objects and arrays as &lt;code&gt;v-for&lt;/code&gt; keys. Use string or numeric values instead.</source>
          <target state="translated">객체 및 배열과 같은 원시 값이 아닌 값을 &lt;code&gt;v-for&lt;/code&gt; 키로 사용하지 마십시오 . 대신 문자열 또는 숫자 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4c2b87efdc39bb54d70cdd883a06174f29493668" translate="yes" xml:space="preserve">
          <source>Done! Now whenever we call &lt;code&gt;getUserRepositories&lt;/code&gt;, &lt;code&gt;repositories&lt;/code&gt; will be mutated and the view will be updated to reflect the change. Our component should now look like this:</source>
          <target state="translated">끝난! 우리가 전화 할 때마다 지금 &lt;code&gt;getUserRepositories&lt;/code&gt; 을 , &lt;code&gt;repositories&lt;/code&gt; 변이되고보기는 변경 사항을 반영하기 위해 업데이트됩니다. 이제 구성 요소는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7ebf978596d7d20a23e0ca4773390efae1bd8f2f" translate="yes" xml:space="preserve">
          <source>Drop the internal concept of enumerated attributes and treat those attributes the same as normal non-boolean attributes</source>
          <target state="translated">열거 된 속성의 내부 개념을 삭제하고 해당 속성을 일반 부울이 아닌 속성과 동일하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="899e054cc75954e4159c5ebdaef25856dd086605" translate="yes" xml:space="preserve">
          <source>Due to limitations in JavaScript, Vue &lt;strong&gt;cannot&lt;/strong&gt; detect the following changes to an array:</source>
          <target state="translated">JavaScript의 제한으로 인해 Vue &lt;strong&gt;는&lt;/strong&gt; 다음과 같은 배열 변경을 감지 &lt;strong&gt;할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe183c25e6e529dd240aa96c35cead7959acbe8" translate="yes" xml:space="preserve">
          <source>Due to limitations in JavaScript, there are types of changes that Vue &lt;strong&gt;cannot detect&lt;/strong&gt;. However, there are ways to circumvent them to preserve reactivity.</source>
          <target state="translated">JavaScript의 제한으로 인해 Vue &lt;strong&gt;가 감지 할 수없는&lt;/strong&gt; 변경 유형이 &lt;strong&gt;있습니다&lt;/strong&gt; . 그러나 반응성을 보존하기 위해이를 우회하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f5a54ddfeaab0b34c48e32ca40adb365a291a09" translate="yes" xml:space="preserve">
          <source>Due to the limitations of modern JavaScript (and the abandonment of &lt;code&gt;Object.observe&lt;/code&gt;), Vue &lt;strong&gt;cannot detect property addition or deletion&lt;/strong&gt;. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the &lt;code&gt;data&lt;/code&gt; object in order for Vue to convert it and make it reactive. For example:</source>
          <target state="translated">최신 JavaScript의 제한 사항 (및 &lt;code&gt;Object.observe&lt;/code&gt; 의 포기)으로 인해 Vue &lt;strong&gt;는 속성 추가 또는 삭제를 감지 할 수 없습니다&lt;/strong&gt; . Vue는 인스턴스 초기화 중에 getter / setter 변환 프로세스를 수행하므로 Vue가 &lt;code&gt;data&lt;/code&gt; 를 변환하고 반응 적으로 만들 려면 데이터 객체에 속성이 있어야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d1e3bcfb2991be45c08d600c135d8a8f3bd979e" translate="yes" xml:space="preserve">
          <source>Duplicate Slots &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">중복 슬롯 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1e4dfad1a692a8e9e499aa601a49c4ba4f904e1a" translate="yes" xml:space="preserve">
          <source>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app&amp;rsquo;s payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.</source>
          <target state="translated">개발 중에 Vue는 일반적인 오류와 함정에 도움이되는 많은 경고를 제공합니다. 그러나 이러한 경고 문자열은 프로덕션 환경에서 쓸모 없게되고 앱의 페이로드 크기를 크게합니다. 또한 이러한 경고 검사 중 일부는 생산 모드에서 피할 수있는 런타임 비용이 적습니다.</target>
        </trans-unit>
        <trans-unit id="696bbe5fe1ccdfc46b1ddd6068eaa01ef847587e" translate="yes" xml:space="preserve">
          <source>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app's payload size. In addition, some of these warning checks have small runtime costs that can be avoided in &lt;a href=&quot;https://cli.vuejs.org/guide/mode-and-env.html#modes&quot;&gt;production mode (opens new window)&lt;/a&gt;.</source>
          <target state="translated">개발 중에 Vue는 일반적인 오류와 함정에 도움이되는 많은 경고를 제공합니다. 그러나 이러한 경고 문자열은 프로덕션에서 쓸모가 없어지고 앱의 페이로드 크기가 커집니다. 또한 이러한 경고 확인 중 일부는 &lt;a href=&quot;https://cli.vuejs.org/guide/mode-and-env.html#modes&quot;&gt;프로덕션 모드&lt;/a&gt; 에서 피할 수있는 런타임 비용이 적습니다 (새 창 열기) .</target>
        </trans-unit>
        <trans-unit id="4e0b4d06e01f37d245996f44cf8aad221df6bb37" translate="yes" xml:space="preserve">
          <source>Dynamic &amp;amp; Async Components</source>
          <target state="translated">동적 및 비동기 구성 요소</target>
        </trans-unit>
        <trans-unit id="0f29650484d14962fd70996d94d073f31ddb540c" translate="yes" xml:space="preserve">
          <source>Dynamic Argument Expression Constraints</source>
          <target state="translated">동적 인수 표현 제약</target>
        </trans-unit>
        <trans-unit id="af1ad0c6ae30fa7a85fac894f37497e0cf2dad3b" translate="yes" xml:space="preserve">
          <source>Dynamic Argument Value Constraints</source>
          <target state="translated">동적 인수 값 제약</target>
        </trans-unit>
        <trans-unit id="9b7f2a051af6ba64581ce902392478aec9152664" translate="yes" xml:space="preserve">
          <source>Dynamic Arguments</source>
          <target state="translated">동적 인수</target>
        </trans-unit>
        <trans-unit id="a5fdad1da0c422ddbaedc42b6d8523a19935dd4a" translate="yes" xml:space="preserve">
          <source>Dynamic Components</source>
          <target state="translated">동적 구성 요소</target>
        </trans-unit>
        <trans-unit id="7ed8c346bc4125aae72e6d3a54d7f6262905126a" translate="yes" xml:space="preserve">
          <source>Dynamic Components - keep-alive</source>
          <target state="translated">동적 구성 요소-연결 유지</target>
        </trans-unit>
        <trans-unit id="2e89d09ae3e7f52e90bcd127eb7b2618655d7afd" translate="yes" xml:space="preserve">
          <source>Dynamic Components with &lt;code&gt;keep-alive&lt;/code&gt;</source>
          <target state="translated">연결 &lt;code&gt;keep-alive&lt;/code&gt; 동적 구성 요소</target>
        </trans-unit>
        <trans-unit id="7e034c49c5cb1c629752968fa9c7831a78d808e9" translate="yes" xml:space="preserve">
          <source>Dynamic Directive Arguments</source>
          <target state="translated">동적 지시 인수</target>
        </trans-unit>
        <trans-unit id="c5efbfd95e89a2e200767862226b5ea05b0c65cd" translate="yes" xml:space="preserve">
          <source>Dynamic Slot Names</source>
          <target state="translated">동적 슬롯 이름</target>
        </trans-unit>
        <trans-unit id="fc384df95a2eb5e6d4806d3eac83c68c6146e347" translate="yes" xml:space="preserve">
          <source>Dynamic State Transitions</source>
          <target state="translated">동적 상태 전환</target>
        </trans-unit>
        <trans-unit id="352ceca6fc1e262f140d46e933114b56fb3111ba" translate="yes" xml:space="preserve">
          <source>Dynamic Transitions</source>
          <target state="translated">동적 전환</target>
        </trans-unit>
        <trans-unit id="93ee8b48e893e0a24c554d34149c5732350f19ef" translate="yes" xml:space="preserve">
          <source>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:</source>
          <target state="translated">공백 및 따옴표와 같은 특정 문자는 HTML 속성 이름 내에서 유효하지 않기 때문에 동적 인수 표현식에는 구문 제약 조건이 있습니다. 예를 들어, 다음은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="066b5692f75eaf85a9eb86ad0ec5f4a812ee3640" translate="yes" xml:space="preserve">
          <source>Dynamic arguments are expected to evaluate to a string, with the exception of &lt;code&gt;null&lt;/code&gt;. The special value &lt;code&gt;null&lt;/code&gt; can be used to explicitly remove the binding. Any other non-string value will trigger a warning.</source>
          <target state="translated">동적 인수는 &lt;code&gt;null&lt;/code&gt; 을 제외하고 문자열로 평가됩니다 . 특수 값 &lt;code&gt;null&lt;/code&gt; 을 사용하여 바인딩을 명시 적으로 제거 할 수 있습니다. 문자열이 아닌 다른 값은 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="76813c002463cb6cd3d5aaacd8c77a0fdc2e1c18" translate="yes" xml:space="preserve">
          <source>Dynamic components</source>
          <target state="translated">동적 구성 요소</target>
        </trans-unit>
        <trans-unit id="8ca3e70bb28937f01555d17d146f8ddb5c4ff9fe" translate="yes" xml:space="preserve">
          <source>Dynamic options rendered with &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 로 렌더링 된 동적 옵션 :</target>
        </trans-unit>
        <trans-unit id="c7c226cd4979c15617282ce978af491363f417bc" translate="yes" xml:space="preserve">
          <source>Dynamically bind one or more attributes, or a component prop to an expression.</source>
          <target state="translated">하나 이상의 속성 또는 구성 요소 소품을 표현식에 동적으로 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="0442aa5284cbc2dfc4cab6c4fe3840defc7b4ea0" translate="yes" xml:space="preserve">
          <source>Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks (opens new window)&lt;/a&gt;. Only use &lt;code&gt;v-html&lt;/code&gt; on trusted content and &lt;strong&gt;never&lt;/strong&gt; on user-provided content.</source>
          <target state="translated">웹 사이트에서 임의의 HTML을 동적으로 렌더링하는 것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS 공격으로&lt;/a&gt; 쉽게 이어질 수 있기 때문에 매우 위험 할 수 있습니다 (새 창에서 열림) . 신뢰할 수있는 콘텐츠 에만 &lt;code&gt;v-html&lt;/code&gt; 을 사용 하고 사용자가 제공 한 콘텐츠에는 사용 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="05eb141560fc4fbe23b15082a0866f326cc413ad" translate="yes" xml:space="preserve">
          <source>Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks&lt;/a&gt;. Only use &lt;code&gt;v-html&lt;/code&gt; on trusted content and &lt;strong&gt;never&lt;/strong&gt; on user-provided content.</source>
          <target state="translated">웹 사이트에서 임의의 HTML을 동적으로 렌더링하면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS 공격을&lt;/a&gt; 쉽게 일으킬 수 있으므로 매우 위험 할 수 있습니다 . 신뢰할 수있는 콘텐츠 에만 &lt;code&gt;v-html&lt;/code&gt; 을 사용 하고 사용자가 제공 한 콘텐츠에는 사용 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f049d4b099529eb9f51af91aefc1c6c925d53b06" translate="yes" xml:space="preserve">
          <source>Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS vulnerabilities (opens new window)&lt;/a&gt;. Only use HTML interpolation on trusted content and &lt;strong&gt;never&lt;/strong&gt; on user-provided content</source>
          <target state="translated">웹 사이트에서 임의의 HTML을 동적으로 렌더링하는 것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS 취약성 (새 창에서 열림)으로&lt;/a&gt; 쉽게 이어질 수 있기 때문에 매우 위험 할 수 있습니다 . 신뢰할 수있는 콘텐츠에만 HTML 보간을 사용 하고 사용자가 제공 한 콘텐츠에는 사용 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="eedbb4031c5d446b94624d3a0f6602aec8d6dfb3" translate="yes" xml:space="preserve">
          <source>Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS vulnerabilities&lt;/a&gt;. Only use HTML interpolation on trusted content and &lt;strong&gt;never&lt;/strong&gt; on user-provided content.</source>
          <target state="translated">웹 사이트에서 임의의 HTML을 동적으로 렌더링하면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS 취약점으로&lt;/a&gt; 쉽게 이어질 수 있으므로 매우 위험 할 수 있습니다 . 신뢰할 수있는 내용에만 HTML 보간을 사용 하고 사용자가 제공 한 내용에는 사용 &lt;strong&gt;하지 마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7307a1f2056f78ceb4b076d712f210b93d116ffe" translate="yes" xml:space="preserve">
          <source>ES Module (for browsers)</source>
          <target state="translated">ES 모듈 (브라우저 용)</target>
        </trans-unit>
        <trans-unit id="f93896ed5a340e7e28d51a91add020b4ca5af3b6" translate="yes" xml:space="preserve">
          <source>ES Module (for bundlers)</source>
          <target state="translated">ES 모듈 (번들용)</target>
        </trans-unit>
        <trans-unit id="9522be7f22cdc09d3c22d90d688472548ef56bd2" translate="yes" xml:space="preserve">
          <source>ESM for browsers (2.6+ only): intended for direct imports in modern browsers via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">브라우저 용 ESM (2.6+ 만 해당) : &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; 을 통해 최신 브라우저에서 직접 가져 오기 위해 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="e27c262b3d9b3eb1c6c28300b45d4a73dc87aab5" translate="yes" xml:space="preserve">
          <source>ESM for bundlers: intended for use with modern bundlers like &lt;a href=&quot;https://webpack.js.org&quot;&gt;webpack 2&lt;/a&gt; or &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt;. ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform &amp;ldquo;tree-shaking&amp;rdquo; and eliminate unused code from your final bundle. The default file for these bundlers (&lt;code&gt;pkg.module&lt;/code&gt;) is the Runtime only ES Module build (&lt;code&gt;vue.runtime.esm.js&lt;/code&gt;).</source>
          <target state="translated">번 &lt;a href=&quot;https://webpack.js.org&quot;&gt;들러&lt;/a&gt; 용 ESM : webpack 2 또는 &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup&lt;/a&gt; 과 같은 최신 번 들러 와 함께 사용하도록 설계되었습니다 . ESM 형식은 정적으로 분석 가능하도록 설계되어 번 들러는이를 활용하여 &quot;트리 쉐이킹&quot;을 수행하고 최종 번들에서 사용하지 않는 코드를 제거 할 수 있습니다. 이러한 번 &lt;code&gt;pkg.module&lt;/code&gt; ( pkg.module ) 의 기본 파일 은 런타임 전용 ES 모듈 빌드 ( &lt;code&gt;vue.runtime.esm.js&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="52584925c7fd5eeb8c70a3598a16ad94fa3bb4e3" translate="yes" xml:space="preserve">
          <source>Each Vue instance goes through a series of initialization steps when it&amp;rsquo;s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called &lt;strong&gt;lifecycle hooks&lt;/strong&gt;, giving users the opportunity to add their own code at specific stages.</source>
          <target state="translated">각 Vue 인스턴스는 생성 될 때 일련의 초기화 단계를 거칩니다. 예를 들어 데이터 관찰을 설정하고 템플릿을 컴파일하며 인스턴스를 DOM에 마운트하고 데이터가 변경 될 때 DOM을 업데이트해야합니다. 또한 &lt;strong&gt;수명주기 후크&lt;/strong&gt; ( &lt;strong&gt;lifecycle hooks&lt;/strong&gt; ) 라는 기능을 실행 하여 특정 단계에서 사용자 고유의 코드를 추가 할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f844c10dd70c768cf2bf38b007fb2a959576b4df" translate="yes" xml:space="preserve">
          <source>Each component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called &lt;strong&gt;lifecycle hooks&lt;/strong&gt;, giving users the opportunity to add their own code at specific stages.</source>
          <target state="translated">각 구성 요소 인스턴스는 생성 될 때 일련의 초기화 단계를 거칩니다. 예를 들어 데이터 관찰을 설정하고, 템플릿을 컴파일하고, 인스턴스를 DOM에 마운트하고, 데이터가 변경되면 DOM을 업데이트해야합니다. 그 과정에서 &lt;strong&gt;라이프 사이클 후크&lt;/strong&gt; 라는 함수도 실행 하여 사용자에게 특정 단계에서 자신의 코드를 추가 할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="070a771ffcf9809ce4a1e745aaa34080282a6569" translate="yes" xml:space="preserve">
          <source>Each component will have its own component instance, &lt;code&gt;vm&lt;/code&gt;. For some components, such as &lt;code&gt;TodoItem&lt;/code&gt;, there will likely be multiple instances rendered at any one time. All of the component instances in this application will share the same application instance.</source>
          <target state="translated">각 구성 요소에는 자체 구성 요소 인스턴스 인 &lt;code&gt;vm&lt;/code&gt; 이 있습니다. &lt;code&gt;TodoItem&lt;/code&gt; 과 같은 일부 구성 요소의 경우 한 번에 여러 인스턴스가 렌더링 될 수 있습니다. 이 응용 프로그램의 모든 구성 요소 인스턴스는 동일한 응용 프로그램 인스턴스를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="aef59e39a699d63f068d528d22840960fd7a9c06" translate="yes" xml:space="preserve">
          <source>Each directive itself is an array, which allows for up to 4 indexes to be defined as seen in the following examples.</source>
          <target state="translated">각 지시문 자체는 배열이며, 다음 예제와 같이 최대 4 개의 인덱스를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28bd397f4561c35505d212db27ec40f65917cd37" translate="yes" xml:space="preserve">
          <source>Each of these classes will be prefixed with the name of the transition. Here the &lt;code&gt;v-&lt;/code&gt; prefix is the default when you use a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; element with no name. If you use &lt;code&gt;&amp;lt;transition name=&quot;my-transition&quot;&amp;gt;&lt;/code&gt; for example, then the &lt;code&gt;v-enter-from&lt;/code&gt; class would instead be &lt;code&gt;my-transition-enter-from&lt;/code&gt;.</source>
          <target state="translated">이러한 각 클래스에는 전환 이름이 접두사로 붙습니다. 여기서 &lt;code&gt;v-&lt;/code&gt; 접두사는 이름없이 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 요소 를 사용할 때 기본값 입니다. 당신이 사용하는 경우 &lt;code&gt;&amp;lt;transition name=&quot;my-transition&quot;&amp;gt;&lt;/code&gt; 예를 들어, 다음 &lt;code&gt;v-enter-from&lt;/code&gt; 클래스 대신 것 &lt;code&gt;my-transition-enter-from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5088616c301da75dcaf436fbc5bf3ddd9acb337" translate="yes" xml:space="preserve">
          <source>Each of these classes will be prefixed with the name of the transition. Here the &lt;code&gt;v-&lt;/code&gt; prefix is the default when you use a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; element with no name. If you use &lt;code&gt;&amp;lt;transition name=&quot;my-transition&quot;&amp;gt;&lt;/code&gt; for example, then the &lt;code&gt;v-enter&lt;/code&gt; class would instead be &lt;code&gt;my-transition-enter&lt;/code&gt;.</source>
          <target state="translated">이러한 각 클래스에는 전환 이름이 접두어로 붙습니다. 여기서 &lt;code&gt;v-&lt;/code&gt; 접두어는 이름없이 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 요소 를 사용할 때의 기본값 입니다. 당신이 사용하는 경우 &lt;code&gt;&amp;lt;transition name=&quot;my-transition&quot;&amp;gt;&lt;/code&gt; 예를 들어, 다음 &lt;code&gt;v-enter&lt;/code&gt; 클래스는 아닌 것 &lt;code&gt;my-transition-enter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b371d4e1733e62ca62794f7bec2f77283f6e80ba" translate="yes" xml:space="preserve">
          <source>Each v-model will sync to a different prop, without the need for extra options in the component:</source>
          <target state="translated">각 v- 모델은 구성 요소에 추가 옵션이 필요없이 다른 소품에 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="dee4a64f803260cddd26d319b0307ed277c813e3" translate="yes" xml:space="preserve">
          <source>Earlier in the guide we met &lt;code&gt;data&lt;/code&gt; properties. Properties defined in &lt;code&gt;data&lt;/code&gt; are exposed via the component instance:</source>
          <target state="translated">가이드의 앞부분에서 &lt;code&gt;data&lt;/code&gt; 속성 을 만났습니다 . &lt;code&gt;data&lt;/code&gt; 정의 된 속성 은 구성 요소 인스턴스를 통해 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="1cc96a01bcbcfb5be49b49faff41c9c72edfc787" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned creating a component for blog posts. The problem is, that component won&amp;rsquo;t be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That&amp;rsquo;s where props come in.</source>
          <target state="translated">이전에는 블로그 게시물을위한 컴포넌트 작성에 대해 언급했습니다. 문제는 표시하려는 특정 게시물의 제목 및 내용과 같이 데이터를 전달할 수 없으면 해당 구성 요소가 유용하지 않다는 것입니다. 그것이 소품이 들어오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="34624a05553566caa2e535bc9c4e20073a2b229a" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned creating a component for blog posts. The problem is, that component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.</source>
          <target state="translated">앞서 블로그 게시물에 대한 구성 요소 생성에 대해 언급했습니다. 문제는 표시하려는 특정 게시물의 제목 및 내용과 같은 데이터를 전달할 수 없으면 해당 구성 요소가 유용하지 않다는 것입니다. 그것이 소품이 들어오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="0d70bd765f3f2ae985e4c821b7603710f7eb9df8" translate="yes" xml:space="preserve">
          <source>Earlier, we used the &lt;code&gt;is&lt;/code&gt; attribute to switch between components in a tabbed interface:</source>
          <target state="translated">이전에는 &lt;code&gt;is&lt;/code&gt; 특성을 사용하여 탭 인터페이스에서 구성 요소 간을 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="4fa6dd6e776a6034da7ff016fc47682b3462032b" translate="yes" xml:space="preserve">
          <source>Earlier, when we described &lt;a href=&quot;#Accessing-the-Parent-Component-Instance&quot;&gt;Accessing the Parent Component Instance&lt;/a&gt;, we showed an example like this:</source>
          <target state="translated">이전에 &lt;a href=&quot;#Accessing-the-Parent-Component-Instance&quot;&gt;부모 컴포넌트 인스턴스 액세스&lt;/a&gt; 를 설명 할 때 다음 과 같은 예를 보여주었습니다.</target>
        </trans-unit>
        <trans-unit id="0c8709a43f69a8c12f45e58b4bcdf5a46f1ca867" translate="yes" xml:space="preserve">
          <source>Easing</source>
          <target state="translated">Easing</target>
        </trans-unit>
        <trans-unit id="c11b131e1281216643c45f8d59e25bd4095fa0c7" translate="yes" xml:space="preserve">
          <source>Easing can also convey the quality of material being animated. Take this pen for example, which ball do you think is hard and which is soft?</source>
          <target state="translated">Easing은 애니메이션되는 재질의 품질을 전달할 수도 있습니다. 예를 들어이 펜을 예로 들면, 어떤 공이 딱딱하고 어느 것이 부드럽다 고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="cce3dcf34382e28f59d8bb830af82d7b473fb7cd" translate="yes" xml:space="preserve">
          <source>Easing is an important way to convey depth in an animation. One of the most common mistakes newcomers to animation make is to use &lt;code&gt;ease-in&lt;/code&gt; for entrances, and &lt;code&gt;ease-out&lt;/code&gt; for exits. You'll actually need the opposite.</source>
          <target state="translated">이징은 애니메이션에서 깊이를 전달하는 중요한 방법입니다. 애니메이션 메이크업에 가장 일반적인 실수 이민자 중 하나는 사용하는 것입니다 &lt;code&gt;ease-in&lt;/code&gt; 입구 등에 대한 &lt;code&gt;ease-out&lt;/code&gt; 종료합니다. 실제로 그 반대가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1edea9dcec8fdda290d18e0690115beef47ed21b" translate="yes" xml:space="preserve">
          <source>Edge Case: Accessing the component instance</source>
          <target state="translated">Edge Case : 구성 요소 인스턴스 액세스</target>
        </trans-unit>
        <trans-unit id="1fc33fec143cab8fa565a8b5fcd84caddf5b2bb9" translate="yes" xml:space="preserve">
          <source>Editor Support</source>
          <target state="translated">편집자 지원</target>
        </trans-unit>
        <trans-unit id="4b30b2bc161838680b0573ae6f73a2c886f0328b" translate="yes" xml:space="preserve">
          <source>Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.</source>
          <target state="translated">PascalCase는 JavaScript에서도 사용되므로 편집기에서 템플릿의 구성 요소 이름을 자동 완성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eced484380a1d78d5cbc37dc8d3f4ad07aa5d4fc" translate="yes" xml:space="preserve">
          <source>Effect Flush Timing</source>
          <target state="translated">효과 플러시 타이밍</target>
        </trans-unit>
        <trans-unit id="aa08e2485ebe2fac169d5b9e3e17c69b91b28316" translate="yes" xml:space="preserve">
          <source>Either way, the rendered HTML will be:</source>
          <target state="translated">어느 쪽이든 렌더링 된 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7394b6d08c5d50c4cc4b81306a613af47e801496" translate="yes" xml:space="preserve">
          <source>Element &amp;amp; Component Access</source>
          <target state="translated">요소 및 구성 요소 액세스</target>
        </trans-unit>
        <trans-unit id="f191399212a6a5144845ff3f2688976048435b58" translate="yes" xml:space="preserve">
          <source>Element attribute order</source>
          <target state="translated">요소 속성 순서</target>
        </trans-unit>
        <trans-unit id="3ec26bbfb700738f9bd4fc6d76fb545baff31bf3" translate="yes" xml:space="preserve">
          <source>Element attribute order &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">요소 속성 순서 &lt;sup&gt;권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="38a3522441dc0300f0d181dd880463460906d3e2" translate="yes" xml:space="preserve">
          <source>Element selectors with &lt;code&gt;scoped&lt;/code&gt;&lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;사용 &lt;/sup&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;sup&gt;가 신중한&lt;/sup&gt; 요소 선택기&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d8f887f6e247da0f16c9fed78985cfcac7e019d8" translate="yes" xml:space="preserve">
          <source>Element selectors with scoped</source>
          <target state="translated">범위가 지정된 요소 선택기</target>
        </trans-unit>
        <trans-unit id="0409f80dbf4550276ef2e4c40543a602bf7ee4bd" translate="yes" xml:space="preserve">
          <source>Elements inside are &lt;strong&gt;always required&lt;/strong&gt; to have a unique &lt;code&gt;key&lt;/code&gt; attribute.</source>
          <target state="translated">내부 요소는 &lt;strong&gt;항상&lt;/strong&gt; 고유 한 &lt;code&gt;key&lt;/code&gt; 속성 을 가져야 합니다.</target>
        </trans-unit>
        <trans-unit id="20632bc30721b7b1111cc82ebfe4420e4ad7d5d8" translate="yes" xml:space="preserve">
          <source>Ember</source>
          <target state="translated">Ember</target>
        </trans-unit>
        <trans-unit id="49ee02a23a5aeffc39970d4d10f070a81e08bfb8" translate="yes" xml:space="preserve">
          <source>Ember is a full-featured framework that is designed to be highly opinionated. It provides a lot of established conventions and once you are familiar enough with them, it can make you very productive. However, it also means the learning curve is high and flexibility suffers. It&amp;rsquo;s a trade-off when you try to pick between an opinionated framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom but also requires you to make more architectural decisions.</source>
          <target state="translated">Ember는 모든 기능을 갖춘 프레임 워크로 높은 평가를 받도록 설계되었습니다. 그것은 많은 확립 된 규약을 제공하며 일단 익숙해지면 매우 생산적 일 수 있습니다. 그러나 이는 학습 곡선이 높고 유연성이 떨어지는 것을 의미합니다. 의견이 많은 프레임 워크와 느슨하게 결합 된 도구 세트가있는 라이브러리 중에서 선택하려고 할 때의 절충점입니다. 후자는 더 많은 자유를 주지만 더 많은 건축 결정을 내려야합니다.</target>
        </trans-unit>
        <trans-unit id="7f2075366a3ad701c910a4b63536fde145d17259" translate="yes" xml:space="preserve">
          <source>Emits Component Option</source>
          <target state="translated">구성 요소 옵션 방출</target>
        </trans-unit>
        <trans-unit id="93091940817fa7264ca6d95063d577fc792a80ec" translate="yes" xml:space="preserve">
          <source>Emitted events can be defined on the component via the &lt;code&gt;emits&lt;/code&gt; option.</source>
          <target state="translated">생성 된 이벤트는 &lt;code&gt;emits&lt;/code&gt; 옵션을 통해 구성 요소에서 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1a14ce6850f52c29f8d348ff00f11f8c193143a" translate="yes" xml:space="preserve">
          <source>Emitting a Value With an Event</source>
          <target state="translated">이벤트를 통한 가치 창출</target>
        </trans-unit>
        <trans-unit id="2ffac68868af36726216abf1444b14e8a9e81831" translate="yes" xml:space="preserve">
          <source>Empty lines in component/instance options</source>
          <target state="translated">구성 요소 / 인스턴스 옵션의 빈 줄</target>
        </trans-unit>
        <trans-unit id="9a357c242d606aa776379e9ccc339c2a981402c3" translate="yes" xml:space="preserve">
          <source>Empty lines in component/instance options &lt;sup&gt;recommended&lt;/sup&gt;</source>
          <target state="translated">구성 요소 / 인스턴스 옵션의 빈 줄 &lt;sup&gt;권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8ee41235587ef6409243b8bd8e160000cdcd84b5" translate="yes" xml:space="preserve">
          <source>End-To-End (E2E) Testing</source>
          <target state="translated">종단 간 (E2E) 테스트</target>
        </trans-unit>
        <trans-unit id="ee3ab185c054c769936b8846001ef9585660ef8c" translate="yes" xml:space="preserve">
          <source>End-to-End (E2E) Testing</source>
          <target state="translated">종단 간 (E2E) 테스트</target>
        </trans-unit>
        <trans-unit id="02fa56bf2aec8f972abe7e127660086ebe1b8cde" translate="yes" xml:space="preserve">
          <source>Enter &amp;amp; Leave Transitions</source>
          <target state="translated">전환 입력 및 나가기</target>
        </trans-unit>
        <trans-unit id="395f296fb0a847870529140564672614d41b49c6" translate="yes" xml:space="preserve">
          <source>Enter/Leave &amp;amp; List Transitions</source>
          <target state="translated">전환 입력 / 탈퇴 및 목록</target>
        </trans-unit>
        <trans-unit id="bc2abe829e2abd8d4f740341cf1ba45dc9699567" translate="yes" xml:space="preserve">
          <source>Enumerated attributes</source>
          <target state="translated">열거 된 속성</target>
        </trans-unit>
        <trans-unit id="4cb2742b90eb0c79a4443668baa30aaa153719fb" translate="yes" xml:space="preserve">
          <source>Equivalent in Handler</source>
          <target state="translated">핸들러와 동등</target>
        </trans-unit>
        <trans-unit id="ebeb508551163eb9757c0825e75655933550427a" translate="yes" xml:space="preserve">
          <source>Error tracking services &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;Sentry (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://docs.bugsnag.com/platforms/browsers/vue/&quot;&gt;Bugsnag (opens new window)&lt;/a&gt; provide official integrations using this option.</source>
          <target state="translated">오류 추적 서비스 &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;Sentry (새 창에서 열림)&lt;/a&gt; 및 &lt;a href=&quot;https://docs.bugsnag.com/platforms/browsers/vue/&quot;&gt;Bugsnag (새 창에서 열림)&lt;/a&gt; 는이 옵션을 사용하여 공식 통합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="524a185d655c3874eab06bc5b9c40d5ae39a5e05" translate="yes" xml:space="preserve">
          <source>Error tracking services &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;Sentry&lt;/a&gt; and &lt;a href=&quot;https://docs.bugsnag.com/platforms/browsers/vue/&quot;&gt;Bugsnag&lt;/a&gt; provide official integrations using this option.</source>
          <target state="translated">오류 추적 서비스 &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;Sentry&lt;/a&gt; 및 &lt;a href=&quot;https://docs.bugsnag.com/platforms/browsers/vue/&quot;&gt;Bugsnag&lt;/a&gt; 는이 옵션을 사용하여 공식 통합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="042066b2dcd642eda405d028a70108b2e923cf25" translate="yes" xml:space="preserve">
          <source>Especially when the template version is so concise in comparison:</source>
          <target state="translated">특히 템플릿 버전이 매우 간결한 경우 :</target>
        </trans-unit>
        <trans-unit id="5a9a0a3787d6b474b295c63ce86d1775a4c674ca" translate="yes" xml:space="preserve">
          <source>Especially when the template version is so simple in comparison:</source>
          <target state="translated">특히 템플릿 버전이 비교가 간단 할 때 :</target>
        </trans-unit>
        <trans-unit id="11d8dc595f327555e20a54381be565d9f67e4750" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:</source>
          <target state="translated">단일 파일 구성 요소의 아이디어가 마음에 들지 않더라도 JavaScript와 CSS를 별도의 파일로 분리하여 핫 리로드 및 사전 컴파일 기능을 계속 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c489a98648b0e015c22e4ee5956483e682bd07e5" translate="yes" xml:space="preserve">
          <source>Even if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:</source>
          <target state="translated">단일 파일 구성 요소에 대한 아이디어가 마음에 들지 않더라도 JavaScript와 CSS를 별도의 파일로 분리하여 핫 리로딩 및 사전 컴파일 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c88ca6177858fca8d783f12c88be433e0d8d66" translate="yes" xml:space="preserve">
          <source>Event &amp;amp; Key Modifiers</source>
          <target state="translated">이벤트 및 키 수정 자</target>
        </trans-unit>
        <trans-unit id="47439ca5ded64f9ae2fef50d130387798195a012" translate="yes" xml:space="preserve">
          <source>Event Handling</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="66526f44818cc6ab396a919c3fd5d840f2645ce8" translate="yes" xml:space="preserve">
          <source>Event Modifiers</source>
          <target state="translated">이벤트 수정 자</target>
        </trans-unit>
        <trans-unit id="ed4d874df84489b3b2e3acc9c685b0095bc84604" translate="yes" xml:space="preserve">
          <source>Event Names</source>
          <target state="translated">이벤트 이름</target>
        </trans-unit>
        <trans-unit id="9c5d0d985690ad3e0c9d1c4401af74dc7d869c98" translate="yes" xml:space="preserve">
          <source>Event listeners passed to a component with &lt;code&gt;v-on&lt;/code&gt; are by default only triggered by emitting an event with &lt;code&gt;this.$emit&lt;/code&gt;. To add a native DOM listener to the child component's root element instead, the &lt;code&gt;.native&lt;/code&gt; modifier can be used:</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 을 사용하여 구성 요소에 전달 된 이벤트 리스너는 기본적으로 &lt;code&gt;this.$emit&lt;/code&gt; 하여 이벤트를 생성하여 트리거됩니다 . 대신 기본 DOM 리스너를 하위 구성 요소의 루트 요소에 추가하려면 &lt;code&gt;.native&lt;/code&gt; 수정자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="fe344110e73a74f72736069ed919c062c627ec74" translate="yes" xml:space="preserve">
          <source>Events API</source>
          <target state="translated">이벤트 API</target>
        </trans-unit>
        <trans-unit id="f1bd4a5e00f70096b890c8158b83721fa0f918d8" translate="yes" xml:space="preserve">
          <source>Events listed in the &lt;code&gt;emits&lt;/code&gt; option &lt;strong&gt;will not&lt;/strong&gt; be inherited by the root element of the component and also will be excluded from the &lt;code&gt;$attrs&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;emits&lt;/code&gt; 옵션에 나열된 이벤트 는 구성 요소의 루트 요소에 상속 &lt;strong&gt;되지 않으며 &lt;/strong&gt; &lt;code&gt;$attrs&lt;/code&gt; 속성 에서도 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f969057791b49962cda3666b3c119536c2fb909" translate="yes" xml:space="preserve">
          <source>Every Vue application exposes a &lt;code&gt;config&lt;/code&gt; object that contains the configuration settings for that application:</source>
          <target state="translated">모든 뷰 응용 프로그램은 노출 &lt;code&gt;config&lt;/code&gt; 해당 응용 프로그램에 대한 구성 설정이 포함 된 개체를 :</target>
        </trans-unit>
        <trans-unit id="5f219021b57e774d36f65324ba3a594e9e20460b" translate="yes" xml:space="preserve">
          <source>Every Vue application starts by creating a new &lt;strong&gt;Vue instance&lt;/strong&gt; with the &lt;code&gt;Vue&lt;/code&gt; function:</source>
          <target state="translated">모든 Vue 응용 프로그램은 &lt;code&gt;Vue&lt;/code&gt; 기능을 사용하여 새 &lt;strong&gt;Vue 인스턴스&lt;/strong&gt; 를 만들어 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="ae26b762f751c6c35419b55a02819589a8ee631b" translate="yes" xml:space="preserve">
          <source>Every Vue application starts by creating a new &lt;strong&gt;application instance&lt;/strong&gt; with the &lt;code&gt;createApp&lt;/code&gt; function:</source>
          <target state="translated">모든 Vue 애플리케이션은 &lt;code&gt;createApp&lt;/code&gt; 함수 로 새 &lt;strong&gt;애플리케이션 인스턴스&lt;/strong&gt; 를 만드는 것으로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="bf667a90a613e55245c46fdd192636568d154701" translate="yes" xml:space="preserve">
          <source>Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.</source>
          <target state="translated">양방향 필터의 숨겨진 동작 대신 라이프 사이클 후크 및 DOM 이벤트를 사용하여 입력의 모든 측면이보다 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="5fab82007b286c11875b1e8300f0b68eda4d7671" translate="yes" xml:space="preserve">
          <source>Every component instance has a corresponding &lt;strong&gt;watcher&lt;/strong&gt; instance, which records any properties &amp;ldquo;touched&amp;rdquo; during the component&amp;rsquo;s render as dependencies. Later on when a dependency&amp;rsquo;s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.</source>
          <target state="translated">모든 구성 요소 인스턴스에는 해당 &lt;strong&gt;감시자&lt;/strong&gt; 인스턴스가 있으며 구성 요소를 렌더링하는 동안 &quot;터치 된&quot;속성을 종속성으로 기록합니다. 나중에 종속성 설정자가 트리거되면 감시자에게 알리고 구성 요소가 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1f58c5b0e6e51b131bbdadfe2b61e38d44bc490b" translate="yes" xml:space="preserve">
          <source>Every component instance has a corresponding watcher instance, which records any properties &quot;touched&quot; during the component&amp;rsquo;s render as dependencies. Later on when a dependency&amp;rsquo;s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.</source>
          <target state="translated">모든 구성 요소 인스턴스에는 해당 감시자 인스턴스가 있으며,이 인스턴스는 구성 요소가 종속성으로 렌더링되는 동안 &quot;만든&quot;속성을 기록합니다. 나중에 종속성의 setter가 트리거되면 감시자에게 알리고 구성 요소가 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="cde90b98b8ca342aa109a11b8cb6f107489aabdb" translate="yes" xml:space="preserve">
          <source>Every component must have exactly one root element. Fragment instances are no longer allowed. If you have a template like this:</source>
          <target state="translated">모든 구성 요소에는 정확히 하나의 루트 요소가 있어야합니다. 조각 인스턴스는 더 이상 허용되지 않습니다. 다음과 같은 템플릿이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="f8f19e423bd95ddb0403144073cc789ba522dcdc" translate="yes" xml:space="preserve">
          <source>Every element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).</source>
          <target state="translated">모든 요소는 노드입니다. 모든 텍스트는 노드입니다. 의견조차 노드입니다! 노드는 페이지의 일부일뿐입니다. 가계도에서와 같이 각 노드에는 자식이있을 수 있습니다 (즉, 각 조각에는 다른 조각이 포함될 수 있음).</target>
        </trans-unit>
        <trans-unit id="9e907bd3543ad266c43cecb301beded8579af45c" translate="yes" xml:space="preserve">
          <source>Every element is a node. Every piece of text is a node. Even comments are nodes! Each node can have children (i.e. each node can contain other nodes).</source>
          <target state="translated">모든 요소는 노드입니다. 모든 텍스트는 노드입니다. 댓글도 노드입니다! 각 노드는 자식을 가질 수 있습니다 (즉, 각 노드는 다른 노드를 포함 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="cc8033faba44f959c9968ac919456fbe10586a80" translate="yes" xml:space="preserve">
          <source>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.</source>
          <target state="translated">부모 템플릿의 모든 것은 부모 범위에서 컴파일됩니다. 자식 템플릿의 모든 것이 자식 범위에서 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="f28c7ab27a6c42cfb1e4176122b33e862331bc81" translate="yes" xml:space="preserve">
          <source>Everything the component needs is passed through &lt;code&gt;context&lt;/code&gt;, which is an object containing:</source>
          <target state="translated">컴포넌트가 필요로하는 모든 것은 &lt;code&gt;context&lt;/code&gt; 를 통해 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3eb3a95fccd918b90c7eb487502d9a5258dea10d" translate="yes" xml:space="preserve">
          <source>Example Sandbox</source>
          <target state="translated">샌드 박스 예</target>
        </trans-unit>
        <trans-unit id="fb1212d6a38581615658d5e1b1169c2c2adba652" translate="yes" xml:space="preserve">
          <source>Example presenting a large component where its &lt;strong&gt;logical concerns&lt;/strong&gt; are grouped by colors.</source>
          <target state="translated">&lt;strong&gt;논리적 관심사&lt;/strong&gt; 가 색상별로 그룹화 된 대형 구성 요소를 표시하는 예 입니다.</target>
        </trans-unit>
        <trans-unit id="5f7ffd28663412a882c9589ff007aec37002c932" translate="yes" xml:space="preserve">
          <source>Example using a custom ref to implement debounce with &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="translated">사용자 지정 참조를 사용하여 &lt;code&gt;v-model&lt;/code&gt; 로 디 바운스를 구현하는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2496516972db533e6486a9f97812cf5fc0c76746" translate="yes" xml:space="preserve">
          <source>Execute any effects tied to a &lt;a href=&quot;#shallowref&quot;&gt;&lt;code&gt;shallowRef&lt;/code&gt;&lt;/a&gt; manually.</source>
          <target state="translated">&lt;a href=&quot;#shallowref&quot;&gt; &lt;code&gt;shallowRef&lt;/code&gt; 에&lt;/a&gt; 연결된 모든 이펙트를 수동으로 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="65341af747d8e24b0243ebd3e3e4ac148ee5268b" translate="yes" xml:space="preserve">
          <source>Existing event hubs can be replaced by using an external library implementing the event emitter interface, for example &lt;a href=&quot;https://github.com/developit/mitt&quot;&gt;mitt (opens new window)&lt;/a&gt; or &lt;a href=&quot;https://github.com/scottcorgan/tiny-emitter&quot;&gt;tiny-emitter (opens new window)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/developit/mitt&quot;&gt;mitt (새 창 열기)&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/scottcorgan/tiny-emitter&quot;&gt;tiny-emitter ( &lt;/a&gt;새 창 열기) 와 같이 이벤트 이미 터 인터페이스를 구현하는 외부 라이브러리를 사용하여 기존 이벤트 허브를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b412ed401fdddea0ef09de5790b10445ea1013a" translate="yes" xml:space="preserve">
          <source>Explanation of Different Builds</source>
          <target state="translated">다른 빌드의 설명</target>
        </trans-unit>
        <trans-unit id="b102c653c316a0c798b1c3b5d245b2fd99221969" translate="yes" xml:space="preserve">
          <source>Explicit Transition Durations</source>
          <target state="translated">명시 적 전환 기간</target>
        </trans-unit>
        <trans-unit id="9e029b3ce910aca10a7cb3465603fd3468549648" translate="yes" xml:space="preserve">
          <source>Explicitly setting the labels with a matching id is better supported by assistive technology.</source>
          <target state="translated">일치하는 ID로 레이블을 명시 적으로 설정하는 것은 보조 기술에서 더 잘 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3a49021ed3d45b568f8768a63c1ebc20e5852fd1" translate="yes" xml:space="preserve">
          <source>Explore the Ecosystem</source>
          <target state="translated">생태계 탐험</target>
        </trans-unit>
        <trans-unit id="9f62a44e4c752c760f987ea515f7893e2af42d0d" translate="yes" xml:space="preserve">
          <source>Extracting Component CSS</source>
          <target state="translated">컴포넌트 CSS 추출</target>
        </trans-unit>
        <trans-unit id="7ff5fe45d5c4ecd39cd3017ab29652c40d320ddd" translate="yes" xml:space="preserve">
          <source>Extracting the shared data into an external object and using it as a property in &lt;code&gt;data&lt;/code&gt;</source>
          <target state="translated">공유 데이터를 외부 객체로 추출하여 데이터의 속성으로 &lt;code&gt;data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="ed87d8d2be60461f51035b723d16617e8c329991" translate="yes" xml:space="preserve">
          <source>Fallback Content</source>
          <target state="translated">대체 콘텐츠</target>
        </trans-unit>
        <trans-unit id="637b5afd0ee9009017980cec7702d491b3d006ed" translate="yes" xml:space="preserve">
          <source>Faster feedback loops</source>
          <target state="translated">더 빠른 피드백 루프</target>
        </trans-unit>
        <trans-unit id="d6b87cce5450b7dd3407b09f150d94a3859e60d9" translate="yes" xml:space="preserve">
          <source>Feel free to inspect this element in Chrome DevTools to see how the accessible name has changed:</source>
          <target state="translated">Chrome DevTools에서이 요소를 검사하여 액세스 가능한 이름이 어떻게 변경되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec1383e48d82f723351a7c7d7e095874e0cced0" translate="yes" xml:space="preserve">
          <source>Filter Argument Syntax &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">필터 인수 구문이 &lt;sup&gt;변경되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="3d415c5493f34087904e62a37f4a30b2feec7d32" translate="yes" xml:space="preserve">
          <source>Filtering repositories using a &lt;code&gt;filters&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; 개체를 사용하여 저장소 필터링</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="8f48c7c02d00eef6501d151792b08bf6adbfe470" translate="yes" xml:space="preserve">
          <source>Filters Outside Text Interpolations &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">텍스트 보간 외부 필터 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="5b3db50a9ea6f4f7c392840edf49099c7ed86b69" translate="yes" xml:space="preserve">
          <source>Filters are JavaScript functions, therefore they can take arguments:</source>
          <target state="translated">필터는 JavaScript 함수이므로 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2ea7d12f78a74ada3b3ff8b68370632078d1768" translate="yes" xml:space="preserve">
          <source>Filters are removed from Vue 3.0 and no longer supported.</source>
          <target state="translated">필터는 Vue 3.0에서 제거되었으며 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cf9da6ef24cfde47da11ec9725f0bf350874d59" translate="yes" xml:space="preserve">
          <source>Filters can be chained:</source>
          <target state="translated">필터를 연결할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4c3505be6bb67c8eae9065c68ab17a4aa210b176" translate="yes" xml:space="preserve">
          <source>Filters can now only be used inside text interpolations (&lt;code&gt;{{ }}&lt;/code&gt; tags). In the past we&amp;rsquo;ve found using filters within directives such as &lt;code&gt;v-model&lt;/code&gt;, &lt;code&gt;v-on&lt;/code&gt;, etc led to more complexity than convenience. For list filtering on &lt;code&gt;v-for&lt;/code&gt;, it&amp;rsquo;s also better to move that logic into JavaScript as computed properties, so that it can be reused throughout your component.</source>
          <target state="translated">텍스트 보간 ( &lt;code&gt;{{ }}&lt;/code&gt; 태그) 내에서만 필터를 사용할 수 있습니다 . 과거에는 &lt;code&gt;v-model&lt;/code&gt; , &lt;code&gt;v-on&lt;/code&gt; 등과 같은 지시문 내에서 필터를 사용하는 것이 편리함보다 더 복잡하다는 것을 알았 습니다. &lt;code&gt;v-for&lt;/code&gt; 의 목록 필터링 의 경우 해당 로직을 계산 된 속성으로 JavaScript로 이동하여 구성 요소 전체에서 재사용 할 수 있도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e9d1aa6ff2a07e10c7656873ff1308d497c903c4" translate="yes" xml:space="preserve">
          <source>Filters&amp;rsquo; syntax for arguments now better aligns with JavaScript function invocation. So instead of taking space-delimited arguments:</source>
          <target state="translated">인수에 대한 필터의 구문은 이제 JavaScript 함수 호출에 더 잘 맞습니다. 따라서 공백으로 구분 된 인수를 사용하는 대신 :</target>
        </trans-unit>
        <trans-unit id="60a606af2a6e34be36c3e018e84d36f4ebabe677" translate="yes" xml:space="preserve">
          <source>Finally, Vue offers a &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;CLI project generator&lt;/a&gt; that makes it trivially easy to start a new project by featuring an interactive project scaffolding wizard. You can even use it to &lt;a href=&quot;https://cli.vuejs.org/guide/prototyping.html#instant-prototyping&quot;&gt;instant prototyping&lt;/a&gt; a component. React is also making strides in this area with &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;, but it currently has a few limitations:</source>
          <target state="translated">마지막으로 Vue는 대화 형 프로젝트 스캐 폴딩 마법사를 통해 새 프로젝트를 쉽게 시작할 수 있는 &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;CLI 프로젝트 생성기&lt;/a&gt; 를 제공합니다 . 컴포넌트 를 &lt;a href=&quot;https://cli.vuejs.org/guide/prototyping.html#instant-prototyping&quot;&gt;즉시 프로토 타이핑&lt;/a&gt; 하는 데 사용할 수도 있습니다 . React는 &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt; 을 사용 하여이 분야에서 진전을 이루고 있지만 현재 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="46a09a60c55f421db2df0617afc361af95839d24" translate="yes" xml:space="preserve">
          <source>Finally, although not as deeply integrated with TypeScript as Angular is, Vue also offers &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/types&quot;&gt;official typings&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;official decorator&lt;/a&gt; for those who wish to use TypeScript with Vue. We are also actively collaborating with the TypeScript and VSCode teams at Microsoft to improve the TS/IDE experience for Vue + TS users.</source>
          <target state="translated">마지막으로, Angular만큼 TypeScript와 긴밀하게 통합되어 있지는 않지만 Vue는 Vue와 함께 TypeScript 를 사용하려는 사람들을 위해 &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/types&quot;&gt;공식 타이핑&lt;/a&gt; 과 &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;공식 데코레이터&lt;/a&gt; 를 제공합니다 . 또한 Vue + TS 사용자를위한 TS / IDE 환경을 개선하기 위해 Microsoft의 TypeScript 및 VSCode 팀과 적극적으로 협력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79cb78954e7e44144e4d9f932c4ed497c0e092c" translate="yes" xml:space="preserve">
          <source>Finally, the ultimate way of creating dynamic transitions is through components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.</source>
          <target state="translated">마지막으로, 동적 전환을 생성하는 궁극적 인 방법은 사용할 전환의 특성을 변경하기 위해 소품을받는 구성 요소를 사용하는 것입니다. 그것은 치즈 소리처럼 들릴지 모르지만 유일한 한계는 실제로 당신의 상상력입니다.</target>
        </trans-unit>
        <trans-unit id="37c0d9ec017af7750457fd12b30573593351cb92" translate="yes" xml:space="preserve">
          <source>Finally, we also set new values when something changes. For this, we&amp;rsquo;re going to set the changes on our new proxy, by triggering those changes:</source>
          <target state="translated">마지막으로 무언가 변경 될 때 새로운 가치를 설정합니다. 이를 위해 변경 사항을 트리거하여 새 프록시에 대한 변경 사항을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bd629e0efb64b70aab47100a21cf0079768c4205" translate="yes" xml:space="preserve">
          <source>Finally, we recommend using &lt;code&gt;readonly&lt;/code&gt; on provided property if you want to ensure that the data passed through &lt;code&gt;provide&lt;/code&gt; cannot be mutated by the injected component.</source>
          <target state="translated">마지막으로, &lt;code&gt;provide&lt;/code&gt; 를 통해 전달 된 데이터 가 삽입 된 구성 요소에 의해 변경 될 수 없도록하려면 제공된 속성에 &lt;code&gt;readonly&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1d1f211e525b965795b5c0f10446e200361802de" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ve split rules into four categories:</source>
          <target state="translated">마지막으로 규칙을 4 가지 범주로 나누었습니다.</target>
        </trans-unit>
        <trans-unit id="7ff01be10fa4fb37fd9ccbbd64d66226e70b2e06" translate="yes" xml:space="preserve">
          <source>Finally, we've split rules into four categories:</source>
          <target state="translated">마지막으로 규칙을 네 가지 범주로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="8df6522b764714298af67043305bc157b86e4057" translate="yes" xml:space="preserve">
          <source>First class debugging experience</source>
          <target state="translated">일류 디버깅 경험</target>
        </trans-unit>
        <trans-unit id="d8218b5728f1181661ae50ea61998b028df2e5e8" translate="yes" xml:space="preserve">
          <source>First-class error reporting</source>
          <target state="translated">일류 오류보고</target>
        </trans-unit>
        <trans-unit id="1ef8e6da45d2dd081d16f57b855fc793cd8acd72" translate="yes" xml:space="preserve">
          <source>Flexibility</source>
          <target state="translated">Flexibility</target>
        </trans-unit>
        <trans-unit id="000fcaf84aefc0e5054690f42482aa2d4e0bf254" translate="yes" xml:space="preserve">
          <source>Flexibility and Modularity</source>
          <target state="translated">유연성과 모듈성</target>
        </trans-unit>
        <trans-unit id="2779f06c409cec032239a657c3bbc855d548df21" translate="yes" xml:space="preserve">
          <source>Focus Indicator (opens new window)</source>
          <target state="translated">초점 표시기 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="c3f8916cb57f294932ab02cd58093fd47cf551bc" translate="yes" xml:space="preserve">
          <source>For &quot;&lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L20&quot;&gt;enumerated attributes (opens new window)&lt;/a&gt;&quot; (currently &lt;code&gt;contenteditable&lt;/code&gt;, &lt;code&gt;draggable&lt;/code&gt; and &lt;code&gt;spellcheck&lt;/code&gt;), Vue tries to &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L24-L31&quot;&gt;coerce (opens new window)&lt;/a&gt; them to string (with special treatment for &lt;code&gt;contenteditable&lt;/code&gt; for now, to fix &lt;a href=&quot;https://github.com/vuejs/vue/issues/9397&quot;&gt;vuejs/vue#9397 (opens new window)&lt;/a&gt;).</source>
          <target state="translated">&quot; &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L20&quot;&gt;enumerated attributes (opens new window)&lt;/a&gt; &quot;(현재 &lt;code&gt;contenteditable&lt;/code&gt; , &lt;code&gt;draggable&lt;/code&gt; 및 &lt;code&gt;spellcheck&lt;/code&gt; )의 경우, Vue는 문자열 로 &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L24-L31&quot;&gt;강제 (새 창 &lt;/a&gt;&lt;a href=&quot;https://github.com/vuejs/vue/issues/9397&quot;&gt;열기)를 시도합니다 (&lt;/a&gt; 현재 는 &lt;code&gt;contenteditable&lt;/code&gt; 에 대한 특수 처리를 사용 하여 vuejs / vue # 9397 을 수정합니다 (새로 열림). 창) ).</target>
        </trans-unit>
        <trans-unit id="c8bab112e2dcdb90fe96ea6c858a1d56a1deb2dd" translate="yes" xml:space="preserve">
          <source>For &quot;&lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L33-L40&quot;&gt;boolean attributes (opens new window)&lt;/a&gt;&quot; and &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L44-L46&quot;&gt;xlinks (opens new window)&lt;/a&gt;, Vue removes them if they are &quot;falsy&quot; (&lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L52-L54&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; (opens new window)&lt;/a&gt;) and adds them otherwise (see &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L66-L77&quot;&gt;here (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L81-L85&quot;&gt;here (opens new window)&lt;/a&gt;).</source>
          <target state="translated">&quot; &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L33-L40&quot;&gt;부울 속성 (새 창 열림)&lt;/a&gt; &quot;및 &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L44-L46&quot;&gt;xlinks (새 창 열림)의&lt;/a&gt; 경우 Vue는 &quot;거짓&quot;( &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L52-L54&quot;&gt; &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; (새 창 열림)&lt;/a&gt; ) 이면 이를 제거 하고 그렇지 않은 경우 추가합니다 ( &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L66-L77&quot;&gt;여기&lt;/a&gt; 참조 (새 창 열림). ) 및 &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L81-L85&quot;&gt;여기 (새 창에서 열림)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f8c2c9fae14cfd0036093a8ba717ff818a80888" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;v-model&lt;/code&gt; bindings with arguments, the generated prop name will be &lt;code&gt;arg + &quot;Modifiers&quot;&lt;/code&gt;:</source>
          <target state="translated">들어 &lt;code&gt;v-model&lt;/code&gt; 인수 바인딩, 생성 된 소품 이름이 될 것입니다 &lt;code&gt;arg + &quot;Modifiers&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="513df0e04c650fcde5059f934aba58711aa740db" translate="yes" xml:space="preserve">
          <source>For Advanced Users</source>
          <target state="translated">고급 사용자</target>
        </trans-unit>
        <trans-unit id="57e68e2eeefaf2c306eda048b28ddfe9395d0e60" translate="yes" xml:space="preserve">
          <source>For Arrays</source>
          <target state="translated">어레 이용</target>
        </trans-unit>
        <trans-unit id="be6156399a4dcfb1f701b32b420e46b955bdac9f" translate="yes" xml:space="preserve">
          <source>For Chrome: &lt;a href=&quot;https://chrome.google.com/webstore/detail/vuejs-devtools/ljjemllljcmogpfapbkkighbhhppjdbg?hl=en&quot;&gt;Install from Chrome web store (opens new window)&lt;/a&gt;</source>
          <target state="translated">Chrome의 경우 : &lt;a href=&quot;https://chrome.google.com/webstore/detail/vuejs-devtools/ljjemllljcmogpfapbkkighbhhppjdbg?hl=en&quot;&gt;Chrome 웹 스토어에서 설치 (새 창에서 열림)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e57b250e17fb6ad360318dfccc7e5d9eee33e77" translate="yes" xml:space="preserve">
          <source>For ES modules builds, since they are used with bundlers, and in most cases a CLI or boilerplate would have configured the production env properly, this tip will no longer show up.</source>
          <target state="translated">ES 모듈 빌드의 경우 번 들러와 함께 사용되며 대부분의 경우 CLI 또는 상용구가 프로덕션 환경을 올바르게 구성 했으므로이 팁은 더 이상 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9f9ba9cf5ee9accdef1e63daf2a42d27c90c7cc" translate="yes" xml:space="preserve">
          <source>For Firefox: &lt;a href=&quot;https://github.com/vuejs/vue-devtools/releases/tag/v6.0.0-beta.2&quot;&gt;Download the signed extension (opens new window)&lt;/a&gt; (&lt;code&gt;.xpi&lt;/code&gt; file under Assets)</source>
          <target state="translated">Firefox의 경우 : &lt;a href=&quot;https://github.com/vuejs/vue-devtools/releases/tag/v6.0.0-beta.2&quot;&gt;서명 된 확장명 다운로드 (새 창에서 열림)&lt;/a&gt; ( 자산 아래의 &lt;code&gt;.xpi&lt;/code&gt; 파일)</target>
        </trans-unit>
        <trans-unit id="f0245eb6057c94ca797bfcb5840104243c1ad57d" translate="yes" xml:space="preserve">
          <source>For Objects</source>
          <target state="translated">개체 용</target>
        </trans-unit>
        <trans-unit id="b0e4f5457a37e486d2a0a58b81ae37fc208be3a7" translate="yes" xml:space="preserve">
          <source>For Server-Side Rendering</source>
          <target state="translated">서버 측 렌더링 용</target>
        </trans-unit>
        <trans-unit id="ede6b61362681370234fd0807f315c01a9c3b55b" translate="yes" xml:space="preserve">
          <source>For UMD / browser builds, it should try the global Vue.h first and fallback to require calls</source>
          <target state="translated">UMD / 브라우저 빌드의 경우 먼저 전역 Vue.h를 시도하고 호출을 요구하도록 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="0371195d5c5dd41a7b29d242b361064f37dcabe5" translate="yes" xml:space="preserve">
          <source>For Users New to Module Build Systems in JavaScript</source>
          <target state="translated">JavaScript로 모듈 빌드 시스템을 처음 사용하는 사용자</target>
        </trans-unit>
        <trans-unit id="718b4e7e8a44ecd43677096c7f8db3165c1ec6a0" translate="yes" xml:space="preserve">
          <source>For Vue 3, you should use Vue CLI v4.5 available on &lt;code&gt;npm&lt;/code&gt; as &lt;code&gt;@vue/cli&lt;/code&gt;. To upgrade, you need to reinstall the latest version of &lt;code&gt;@vue/cli&lt;/code&gt; globally:</source>
          <target state="translated">Vue 3의 경우 &lt;code&gt;npm&lt;/code&gt; 에서 사용할 수있는 Vue CLI v4.5 를 &lt;code&gt;@vue/cli&lt;/code&gt; 로 사용해야합니다 . 업그레이드하려면 최신 버전의 &lt;code&gt;@vue/cli&lt;/code&gt; 전역으로 다시 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a2a099d8208018e5e4f7f52f337e07b0c674c8c" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, read on!</source>
          <target state="translated">더 자세한 설명을 보려면 계속 읽으십시오!</target>
        </trans-unit>
        <trans-unit id="6ab11db25aabad67fcc64bd1db7fd9a5258467bd" translate="yes" xml:space="preserve">
          <source>For a very naive implementation, you could do something like this:</source>
          <target state="translated">매우 순진한 구현의 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d777c95a03d6fa9b89974643955ab4811c190d7" translate="yes" xml:space="preserve">
          <source>For additional information on Vue 3 compatibility with libraries and plugins, be sure to check out &lt;a href=&quot;https://github.com/vuejs/awesome-vue/issues/3544&quot;&gt;this issue in awesome-vue (opens new window)&lt;/a&gt;.</source>
          <target state="translated">라이브러리 및 플러그인과의 Vue 3 호환성에 대한 추가 정보 &lt;a href=&quot;https://github.com/vuejs/awesome-vue/issues/3544&quot;&gt;는 awesome-vue (새 창에서 열림)에서이 문제&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e29beb2ae5e0f698f91f0ecbcfec5993eb68011" translate="yes" xml:space="preserve">
          <source>For advanced usage, &lt;code&gt;defineAsyncComponent&lt;/code&gt; can accept an object:</source>
          <target state="translated">고급 사용을 위해 &lt;code&gt;defineAsyncComponent&lt;/code&gt; 는 객체를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97aed23a831fb46aa5f822991920ad494f56b3c0" translate="yes" xml:space="preserve">
          <source>For all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:</source>
          <target state="translated">다른 모든 이벤트 및 키 수정 자의 경우 핸들러에서 이벤트 메소드를 사용할 수 있으므로 독점 접 두부가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f3aad46dd2709802f268b9031aeeaba2bf6051b" translate="yes" xml:space="preserve">
          <source>For all other event and key modifiers, no special API is necessary, because we can use event methods in the handler:</source>
          <target state="translated">다른 모든 이벤트 및 키 수정 자의 경우 처리기에서 이벤트 메서드를 사용할 수 있으므로 특별한 API가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="803f1468c60b4330634ef60069135d9e19060a49" translate="yes" xml:space="preserve">
          <source>For basic usage, &lt;code&gt;defineAsyncComponent&lt;/code&gt; can accept a factory function returning a &lt;code&gt;Promise&lt;/code&gt;. Promise's &lt;code&gt;resolve&lt;/code&gt; callback should be called when you have retrieved your component definition from the server. You can also call &lt;code&gt;reject(reason)&lt;/code&gt; to indicate the load has failed.</source>
          <target state="translated">기본 사용을 위해 &lt;code&gt;defineAsyncComponent&lt;/code&gt; 는 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 팩토리 함수를 허용 할 수 있습니다 . Promise의 &lt;code&gt;resolve&lt;/code&gt; 콜백은 서버에서 구성 요소 정의를 검색 할 때 호출되어야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 또한 &lt;code&gt;reject(reason)&lt;/code&gt; 를 호출 하여로드가 실패했음을 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dff0c6ef3cf57166e528a89cffe753c0d3fa987f" translate="yes" xml:space="preserve">
          <source>For both &lt;code&gt;'pre'&lt;/code&gt; and &lt;code&gt;'post'&lt;/code&gt;, the callback is buffered using a queue. The callback will only be added to the queue once, even if the watched value changes multiple times. The interim values will be skipped and won't be passed to the callback.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;'pre'&lt;/code&gt; 및 &lt;code&gt;'post'&lt;/code&gt; 의 콜백 큐를 이용하여 버퍼링된다. 감시 된 값이 여러 번 변경 되더라도 콜백은 대기열에 한 번만 추가됩니다. 중간 값은 건너 뛰고 콜백으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbebb8f239a5dfb57c0a332c0934586334f987d9" translate="yes" xml:space="preserve">
          <source>For component VNodes, we need to pass the children to &lt;code&gt;h&lt;/code&gt; as an object rather than an array. Each property is used to populate the slot of the same name:</source>
          <target state="translated">컴포넌트 VNode의 경우 배열이 아닌 객체 로 &lt;code&gt;h&lt;/code&gt; 에 자식을 전달해야합니다 . 각 속성은 동일한 이름의 슬롯을 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="779e284ebce8750bc72e00eb9f800bbf1cc46623" translate="yes" xml:space="preserve">
          <source>For components that re-emit native events to their parent, this would now lead to two events being fired:</source>
          <target state="translated">네이티브 이벤트를 부모에게 다시 내보내는 구성 요소의 경우 이제 두 개의 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6efe27c4aa1b7fa683d5db36ecd5da2d9eeeb411" translate="yes" xml:space="preserve">
          <source>For components using &lt;a href=&quot;../guide/migration/fragments&quot;&gt;fragments&lt;/a&gt;, &lt;code&gt;$el&lt;/code&gt; will be the placeholder DOM node that Vue uses to keep track of the component's position in the DOM. It is recommended to use &lt;a href=&quot;../guide/component-template-refs&quot;&gt;template refs&lt;/a&gt; for direct access to DOM elements instead of relying on &lt;code&gt;$el&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/migration/fragments&quot;&gt;fragments를&lt;/a&gt; 사용하는 구성 요소의 경우 &lt;code&gt;$el&lt;/code&gt; 은 Vue가 DOM에서 구성 요소의 위치를 ​​추적하는 데 사용하는 자리 표시 자 DOM 노드입니다. &lt;code&gt;$el&lt;/code&gt; 에 의존하는 대신 DOM 요소에 직접 액세스하기 위해 &lt;a href=&quot;../guide/component-template-refs&quot;&gt;템플릿 참조&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4b301f643b1a2e6c5a62541c73173f461ea6ebb3" translate="yes" xml:space="preserve">
          <source>For consistency with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;HTML5 History API&lt;/a&gt;, &lt;code&gt;router.go&lt;/code&gt; is now only used for &lt;a href=&quot;https://router.vuejs.org/en/essentials/navigation.html#routergon&quot;&gt;back/forward navigation&lt;/a&gt;, while &lt;a href=&quot;https://router.vuejs.org/en/essentials/navigation.html#routerpushlocation&quot;&gt;&lt;code&gt;router.push&lt;/code&gt;&lt;/a&gt; is used to navigate to a specific page.</source>
          <target state="translated">와 일관성을 유지하기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API&quot;&gt;HTML5 역사 API&lt;/a&gt; , &lt;code&gt;router.go&lt;/code&gt; 는 이제 사용됩니다 &lt;a href=&quot;https://router.vuejs.org/en/essentials/navigation.html#routergon&quot;&gt;뒤로 / 앞으로 탐색&lt;/a&gt; 하면서, &lt;a href=&quot;https://router.vuejs.org/en/essentials/navigation.html#routerpushlocation&quot;&gt; &lt;code&gt;router.push&lt;/code&gt; 가&lt;/a&gt; 특정 페이지로 이동하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa88c3e3f83cba4c66c8e3440df1665f6102ca8" translate="yes" xml:space="preserve">
          <source>For convenience, we had a shorthand for this pattern with the .sync modifier:</source>
          <target state="translated">편의를 위해 .sync 수정자를 사용하여이 패턴에 대한 속기를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="e4fb9ce3028e6861311988b9b290536a7aa92d89" translate="yes" xml:space="preserve">
          <source>For convenience, we offer a shorthand for this pattern with the &lt;code&gt;.sync&lt;/code&gt; modifier:</source>
          <target state="translated">편의를 위해 &lt;code&gt;.sync&lt;/code&gt; 수정자를 사용 하여이 패턴을 간단히 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="e77949a3d7974a151900b4714219c740fd012a6b" translate="yes" xml:space="preserve">
          <source>For detailed usage of the &lt;code&gt;key&lt;/code&gt; attribute, please see the &lt;a href=&quot;../api/index#key&quot;&gt;&lt;code&gt;key&lt;/code&gt; API documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 속성 의 자세한 사용법은 &lt;a href=&quot;../api/index#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; API 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ac69828d942f56edd16a36a4b394123c8c2cccd" translate="yes" xml:space="preserve">
          <source>For detailed usage of the &lt;code&gt;key&lt;/code&gt; attribute, please see the &lt;a href=&quot;../api/special-attributes#key&quot;&gt;&lt;code&gt;key&lt;/code&gt; API documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 속성 의 자세한 사용법은 &lt;a href=&quot;../api/special-attributes#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; API 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53e32fc40d0970eb330b3e2f44d962408b263fdc" translate="yes" xml:space="preserve">
          <source>For detailed usage, follow the links in the description above.</source>
          <target state="translated">자세한 사용법은 위 설명의 링크를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="9e8a5dedf29d4ff26e04aa95eadb4a541741862d" translate="yes" xml:space="preserve">
          <source>For detailed usage, see the guide section linked below.</source>
          <target state="translated">자세한 사용법은 아래 링크 된 가이드 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a01dbce6f8cbf32482f5a5af8815f8901fe3e070" translate="yes" xml:space="preserve">
          <source>For developing Vue applications with TypeScript, we strongly recommend using &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code (opens new window)&lt;/a&gt;, which provides great out-of-the-box support for TypeScript. If you are using &lt;a href=&quot;single-file-component&quot;&gt;single-file components&lt;/a&gt; (SFCs), get the awesome &lt;a href=&quot;https://github.com/vuejs/vetur&quot;&gt;Vetur extension (opens new window)&lt;/a&gt;, which provides TypeScript inference inside SFCs and many other great features.</source>
          <target state="translated">TypeScript로 Vue 애플리케이션을 개발하려면 TypeScript에 대한 뛰어난 기본 지원을 제공 하는 &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code (새 창에서 열림)를&lt;/a&gt; 사용하는 것이 좋습니다 . 당신이 사용하는 경우 &lt;a href=&quot;single-file-component&quot;&gt;하나의 파일 구성 요소&lt;/a&gt; (된 SFC)를, 멋진 얻을 &lt;a href=&quot;https://github.com/vuejs/vetur&quot;&gt;Vetur 확장 (새 창을 엽니 다)&lt;/a&gt; 된 SFC 및 다른 많은 훌륭한 기능을 내부에 타이프 라이터 추론을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d591ea61c249ea3002f6d233030ffe8ea7141373" translate="yes" xml:space="preserve">
          <source>For developing Vue applications with TypeScript, we strongly recommend using &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;, which provides great out-of-the-box support for TypeScript. If you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt; (SFCs), get the awesome &lt;a href=&quot;https://github.com/vuejs/vetur&quot;&gt;Vetur extension&lt;/a&gt;, which provides TypeScript inference inside SFCs and many other great features.</source>
          <target state="translated">TypeScript를 사용하여 Vue 응용 프로그램을 개발 하려면 TypeScript를 즉시 지원 하는 &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code를&lt;/a&gt; 사용하는 것이 좋습니다 . 당신이 사용하는 경우 &lt;a href=&quot;single-file-components&quot;&gt;하나의 파일 구성 요소&lt;/a&gt; (된 SFC)를, 멋진 얻을 &lt;a href=&quot;https://github.com/vuejs/vetur&quot;&gt;Vetur 확장&lt;/a&gt; 된 SFC 및 다른 많은 훌륭한 기능을 내부에 타이프 라이터 추론을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce547ebd7ed5e161168f7c5cbe5f9c281811052a" translate="yes" xml:space="preserve">
          <source>For direct use via &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; in the browser, exposes the Vue global.</source>
          <target state="translated">브라우저에서 &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; 를 통해 직접 사용하기 위해 Vue 전역을 노출합니다.</target>
        </trans-unit>
        <trans-unit id="6e2d4bb9e3f6cebb3a8e3663cfdc894fd475b817" translate="yes" xml:space="preserve">
          <source>For each of Vue&amp;rsquo;s built-in text filters, we go through how you can replace them below. The example code could exist in custom helper functions, methods, or computed properties.</source>
          <target state="translated">Vue의 내장 텍스트 필터 각각에 대해 아래에서 필터를 교체하는 방법을 살펴 봅니다. 예제 코드는 사용자 지정 도우미 함수, 메서드 또는 계산 된 속성에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0fc95b5d9a1e01b79eaa28bc87c877b0bf6da5a" translate="yes" xml:space="preserve">
          <source>For each property in the &lt;code&gt;components&lt;/code&gt; object, the key will be the name of the custom element, while the value will contain the options object for the component.</source>
          <target state="translated">&lt;code&gt;components&lt;/code&gt; 개체의 각 속성에 대해 키는 사용자 지정 요소의 이름이되고 값은 구성 요소의 옵션 개체를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ee5b4a54e529a0035e69d76c3d750875a601f600" translate="yes" xml:space="preserve">
          <source>For enumerated attributes, in addition to the falsy values above, the string &lt;code&gt;&quot;false&quot;&lt;/code&gt; will also render as &lt;code&gt;attr=&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">열거 된 속성의 경우 위의 잘못된 값 외에도 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 문자열 은 &lt;code&gt;attr=&quot;false&quot;&lt;/code&gt; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1bcf675514ed1428c0f255af215d2d1ec106163" translate="yes" xml:space="preserve">
          <source>For example, data objects undergo a recursive merge, with the component&amp;rsquo;s data taking priority in cases of conflicts.</source>
          <target state="translated">예를 들어, 데이터 개체는 재귀 병합을 수행하며 충돌시 구성 요소의 데이터가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f454b48a7b55c534212425c552b6421fd112242f" translate="yes" xml:space="preserve">
          <source>For example, data objects undergo a recursive merge, with the component's data taking priority in cases of conflicts.</source>
          <target state="translated">예를 들어, 데이터 개체는 충돌 발생시 구성 요소의 데이터가 우선하는 재귀 적 병합을 거치게됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1795f687a93352c0cb8a15ee527697b28a4807" translate="yes" xml:space="preserve">
          <source>For example, for runtime-dom, HostNode would be the DOM &lt;code&gt;Node&lt;/code&gt; interface and HostElement would be the DOM &lt;code&gt;Element&lt;/code&gt; interface.</source>
          <target state="translated">예를 들어 runtime-dom의 경우 HostNode는 DOM &lt;code&gt;Node&lt;/code&gt; 인터페이스이고 HostElement는 DOM &lt;code&gt;Element&lt;/code&gt; 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="ca1edc05a6e0814bdd62fe4bce5259a290dfcdac" translate="yes" xml:space="preserve">
          <source>For example, if we have a hierarchy like this:</source>
          <target state="translated">예를 들어 다음과 같은 계층이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="28c56dda15d57727da077449f7a2809409324f47" translate="yes" xml:space="preserve">
          <source>For example, if we only need to support component names then &lt;code&gt;resolveComponent&lt;/code&gt; can be used instead.</source>
          <target state="translated">예를 들어, 컴포넌트 이름 만 지원해야하는 경우 &lt;code&gt;resolveComponent&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2f158836607b874466f2b27900abd2a49b107c" translate="yes" xml:space="preserve">
          <source>For example, if you declare this component:</source>
          <target state="translated">예를 들어,이 컴포넌트를 선언 한 경우 :</target>
        </trans-unit>
        <trans-unit id="7c30d3d0dc65ec8b44e08ea442bb32aa047a5282" translate="yes" xml:space="preserve">
          <source>For example, imagine we&amp;rsquo;re using a 3rd-party &lt;code&gt;bootstrap-date-input&lt;/code&gt; component with a Bootstrap plugin that requires a &lt;code&gt;data-date-picker&lt;/code&gt; attribute on the &lt;code&gt;input&lt;/code&gt;. We can add this attribute to our component instance:</source>
          <target state="translated">예를 들어, 우리는 제 3 자 사용하고 상상 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 이가 필요 플러그인 부트 스트랩과 구성 요소를 &lt;code&gt;data-date-picker&lt;/code&gt; 온 속성 &lt;code&gt;input&lt;/code&gt; . 이 속성을 컴포넌트 인스턴스에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cf609657ca18f9e34acd27701d2bf97355f335" translate="yes" xml:space="preserve">
          <source>For example, in the event we needed to change the user's location, we would ideally do this inside of our &lt;code&gt;MyMap&lt;/code&gt; component.</source>
          <target state="translated">예를 들어 사용자의 위치를 ​​변경 &lt;code&gt;MyMap&lt;/code&gt; 구성 요소 내에서이 작업을 수행하는 것이 이상적 입니다.</target>
        </trans-unit>
        <trans-unit id="029230d9057a5f295142155955df8324550cebca" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say we have a todo app structured like this:</source>
          <target state="translated">예를 들어, 다음과 같이 구조화 된 할 일 앱이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8536684fa38a02049e92f9af5a854917903e5346" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;../api/index#created&quot;&gt;&lt;code&gt;created&lt;/code&gt;&lt;/a&gt; hook can be used to run code after an instance is created:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;../api/index#created&quot;&gt; &lt;code&gt;created&lt;/code&gt; &lt;/a&gt; 후크는 인스턴스가 작성된 후 코드를 실행하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb502cd75e1acf7da048633ff080a77e6e39f8aa" translate="yes" xml:space="preserve">
          <source>For example, the &lt;a href=&quot;../api/options-lifecycle-hooks#created&quot;&gt;created&lt;/a&gt; hook can be used to run code after an instance is created:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../api/options-lifecycle-hooks#created&quot;&gt;생성 된&lt;/a&gt; 후크를 사용하여 인스턴스가 생성 된 후 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87b2246eacf304bd868b9fc71ba48be665c366f" translate="yes" xml:space="preserve">
          <source>For example, to declare an instance property &lt;code&gt;$myProperty&lt;/code&gt; with type &lt;code&gt;string&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;string&lt;/code&gt; 유형으로 인스턴스 특성 &lt;code&gt;$myProperty&lt;/code&gt; 를 선언하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="445caef62f32ef2f86bdab4d539a720263922705" translate="yes" xml:space="preserve">
          <source>For example, we are implementing a &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component that contains the layout and filtering logic for a list:</source>
          <target state="translated">예를 들어, &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 의 레이아웃과 필터링 로직을 포함 하는 &amp;lt;todo-list&amp;gt; 컴포넌트를 구현하고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4d05ff2114716cc4c8c9e00ea69f85bbc1eee8be" translate="yes" xml:space="preserve">
          <source>For example, we have a component, containing a list of todo-items.</source>
          <target state="translated">예를 들어, 할 일 목록을 포함하는 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="edf3e4e5c406d4604815a254998324f3c9550355" translate="yes" xml:space="preserve">
          <source>For example, when you set &lt;code&gt;vm.someData = 'new value'&lt;/code&gt;, the component will not re-render immediately. It will update in the next &quot;tick&quot;, when the queue is flushed. Most of the time we don't need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a &quot;data-driven&quot; fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use &lt;code&gt;Vue.nextTick(callback)&lt;/code&gt; immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</source>
          <target state="translated">예를 들어 &lt;code&gt;vm.someData = 'new value'&lt;/code&gt; 를 설정하면 구성 요소가 즉시 다시 렌더링되지 않습니다. 큐가 플러시 될 때 다음 &quot;틱&quot;에서 업데이트됩니다. 대부분의 경우 우리는 이것에 대해 신경 쓸 필요가 없지만 업데이트 후 DOM 상태에 의존하는 작업을 수행하려는 경우 까다로울 수 있습니다. Vue.js는 일반적으로 개발자가 &quot;데이터 중심&quot;방식으로 생각하고 DOM을 직접 만지지 않도록 권장하지만 때로는 손을 더럽힐 필요가있을 수 있습니다. 데이터 변경 후 Vue.js가 DOM 업데이트를 완료 할 때까지 기다리려면 데이터 변경 직후 &lt;code&gt;Vue.nextTick(callback)&lt;/code&gt; 사용할 수 있습니다 . 콜백은 DOM이 업데이트 된 후에 호출됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c2f769cc15514daf831c7f8ba5ba411ef20e0ad" translate="yes" xml:space="preserve">
          <source>For example, when you set &lt;code&gt;vm.someData = 'new value'&lt;/code&gt;, the component will not re-render immediately. It will update in the next &amp;ldquo;tick&amp;rdquo;, when the queue is flushed. Most of the time we don&amp;rsquo;t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a &amp;ldquo;data-driven&amp;rdquo; fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use &lt;code&gt;Vue.nextTick(callback)&lt;/code&gt; immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</source>
          <target state="translated">예를 들어, &lt;code&gt;vm.someData = 'new value'&lt;/code&gt; 를 설정하면 구성 요소가 즉시 다시 렌더링되지 않습니다. 대기열이 비워지면 다음 &quot;틱&quot;에 업데이트됩니다. 대부분의 경우 우리는 이것에 신경 쓸 필요가 없지만 업데이트 후 DOM 상태에 의존하는 것을 원할 때 까다로울 수 있습니다. Vue.js는 일반적으로 개발자가 &quot;데이터 중심&quot;방식으로 생각하고 DOM을 직접 만지지 않도록 권장하지만 때로는 손을 더럽히는 것이 필요할 수 있습니다. Vue.js가 데이터 변경 후 DOM 업데이트를 완료 할 때까지 기다리 려면 데이터가 변경된 직후 &lt;code&gt;Vue.nextTick(callback)&lt;/code&gt; 사용할 수 있습니다 . 콜백은 DOM이 업데이트 된 후에 호출됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2dcdf7e5cfb578dd7fa577b7951c9147ef8d1fe" translate="yes" xml:space="preserve">
          <source>For example, you can update:</source>
          <target state="translated">예를 들어 다음을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171a4fb0d839fa35fc9ac0ce10d7a2647f1246d9" translate="yes" xml:space="preserve">
          <source>For example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.</source>
          <target state="translated">예를 들어, 일반적으로 탐색 링크, 블로그 게시물 등의 다른 구성 요소를 포함하는 헤더, 사이드 바 및 컨텐츠 영역의 구성 요소가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1124ebc3941a3ca5df3709bda4cfc6da4f05ab94" translate="yes" xml:space="preserve">
          <source>For languages that require an &lt;a href=&quot;https://en.wikipedia.org/wiki/Input_method&quot;&gt;IME (opens new window)&lt;/a&gt; (Chinese, Japanese, Korean etc.), you'll notice that &lt;code&gt;v-model&lt;/code&gt; doesn't get updated during IME composition. If you want to respond to these updates as well, use an &lt;code&gt;input&lt;/code&gt; event listener and &lt;code&gt;value&lt;/code&gt; binding instead of using &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Input_method&quot;&gt;IME&lt;/a&gt; 가 필요한 언어 (새 창에서 열림) (중국어, 일본어, 한국어 등)의 경우 IME 작성 중에 &lt;code&gt;v-model&lt;/code&gt; 이 업데이트되지 않음을 알 수 있습니다. 이러한 업데이트에도 응답하려면 &lt;code&gt;v-model&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;input&lt;/code&gt; 이벤트 리스너 및 &lt;code&gt;value&lt;/code&gt; 바인딩을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8353bc6674b8324b5a5898cec0a2b4d4a90528a5" translate="yes" xml:space="preserve">
          <source>For languages that require an &lt;a href=&quot;https://en.wikipedia.org/wiki/Input_method&quot;&gt;IME&lt;/a&gt; (Chinese, Japanese, Korean etc.), you&amp;rsquo;ll notice that &lt;code&gt;v-model&lt;/code&gt; doesn&amp;rsquo;t get updated during IME composition. If you want to cater for these updates as well, use &lt;code&gt;input&lt;/code&gt; event instead.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Input_method&quot;&gt;IME&lt;/a&gt; (중국어, 일본어, 한국어 등) 가 필요한 언어의 경우 IME 구성 중에 &lt;code&gt;v-model&lt;/code&gt; 이 업데이트되지 않습니다. 이러한 업데이트도 제공하려면 &lt;code&gt;input&lt;/code&gt; 이벤트를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d953af41887caa68a9981e2a5dc5d2318ad53ee4" translate="yes" xml:space="preserve">
          <source>For large applications, both Vue and React offer robust routing solutions. The React community has also been very innovative in terms of state management solutions (e.g. Flux/Redux). These state management patterns and &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;even Redux itself&lt;/a&gt; can be easily integrated into Vue applications. In fact, Vue has even taken this model a step further with &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;, an Elm-inspired state management solution that integrates deeply into Vue that we think offers a superior development experience.</source>
          <target state="translated">대규모 애플리케이션의 경우 Vue와 React는 모두 강력한 라우팅 솔루션을 제공합니다. React 커뮤니티는 상태 관리 솔루션 (예 : Flux / Redux) 측면에서 매우 혁신적입니다. 이러한 상태 관리 패턴과 &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;Redux 자체도&lt;/a&gt; Vue 응용 프로그램에 쉽게 통합 될 수 있습니다. 실제로 Vue는이 모델을 Elm에서 영감을 얻은 상태 관리 솔루션 인 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 와 한 단계 더 발전시켜 Vue에 깊이 통합되어 우수한 개발 경험을 제공한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="6748b6e8c6539d47295af7dc062e5bff8197423c" translate="yes" xml:space="preserve">
          <source>For many developers who have been working with HTML, templates feel more natural to read and write. The preference itself can be somewhat subjective, but if it makes the developer more productive then the benefit is objective.</source>
          <target state="translated">HTML로 작업 한 많은 개발자에게 템플릿은보다 자연스럽게 읽고 쓸 수 있습니다. 선호 자체는 다소 주관적 일 수 있지만, 개발자의 생산성을 높이면 이점이 객관적입니다.</target>
        </trans-unit>
        <trans-unit id="c8cb637b08cd5c9d7169914db39b5c3dc3a54054" translate="yes" xml:space="preserve">
          <source>For module builds, the import should be left alone and be handled by the end user bundler</source>
          <target state="translated">모듈 빌드의 경우 가져 오기는 그대로두고 최종 사용자 번 들러에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d4c638dd5e8b5570dde21fbec275e7f2b3ed8c8" translate="yes" xml:space="preserve">
          <source>For more details on &lt;code&gt;watch&lt;/code&gt;, refer to our &lt;a href=&quot;composition-api-introduction&quot;&gt;in-depth guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;composition-api-introduction&quot;&gt;심층 가이드를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="7a27102ee6324e0ad5def7a29a297eba250292b3" translate="yes" xml:space="preserve">
          <source>For more details, refer to the documentation on &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;Dynamic Components&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;동적 구성 요소&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="628f37126cb037b7ed4ef4cf22c76a0b062364d7" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;the plugins docs&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md&quot;&gt;은 플러그인 docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1462c5eafd2a7f66683a9728a59128baa07aa8ef" translate="yes" xml:space="preserve">
          <source>For more details, see the links below.</source>
          <target state="translated">자세한 내용은 아래 링크를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecef75fdd902dc21fadbfaa29bd9b19def442996" translate="yes" xml:space="preserve">
          <source>For more in-depth information on unit testing in Vue, check out &lt;a href=&quot;https://vue-test-utils.vuejs.org/&quot;&gt;Vue Test Utils&lt;/a&gt; and our cookbook entry about &lt;a href=&quot;https://vuejs.org/v2/cookbook/unit-testing-vue-components.html&quot;&gt;unit testing vue components&lt;/a&gt;.</source>
          <target state="translated">Vue의 단위 테스트에 대한 자세한 내용은 &lt;a href=&quot;https://vue-test-utils.vuejs.org/&quot;&gt;Vue Test Utils&lt;/a&gt; 및 &lt;a href=&quot;https://vuejs.org/v2/cookbook/unit-testing-vue-components.html&quot;&gt;단위 테스트 &lt;/a&gt;Vue 구성 요소에 대한 요리 책 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53baa97136ecbf363dd942ff2575f1cf1c86b4d2" translate="yes" xml:space="preserve">
          <source>For more information about &lt;code&gt;flush&lt;/code&gt; see &lt;a href=&quot;../guide/reactivity-computed-watchers#effect-flush-timing&quot;&gt;Effect Flush Timing&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 대한 자세한 내용 은 &lt;a href=&quot;../guide/reactivity-computed-watchers#effect-flush-timing&quot;&gt;이펙트 플러시 타이밍을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="38681452a27aebcb4665026071ce86a6fdec9b86" translate="yes" xml:space="preserve">
          <source>For more information on how &lt;code&gt;setup()&lt;/code&gt; works, see our &lt;a href=&quot;../composition-api-introduction&quot;&gt;Composition API Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; 작동 방식 에 대한 자세한 내용은 &lt;a href=&quot;../composition-api-introduction&quot;&gt;Composition API 가이드를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="e2e70aeae99701094005cb5633e64567ece3826e" translate="yes" xml:space="preserve">
          <source>For more information on how attribute inheritance works, see &lt;a href=&quot;../component-attrs&quot;&gt;Non-Prop Attributes&lt;/a&gt;.</source>
          <target state="translated">속성 상속이 작동하는 방법에 대한 자세한 내용은 &lt;a href=&quot;../component-attrs&quot;&gt;Non-Prop Attributes를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d46b838e3ff799dbe5d93d0a5f38a2bb2ddef5d" translate="yes" xml:space="preserve">
          <source>For more information on the new &lt;code&gt;v-model&lt;/code&gt; syntax, see:</source>
          <target state="translated">새로운 &lt;code&gt;v-model&lt;/code&gt; 구문 에 대한 자세한 내용 은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad3da4ff72cbdb9b1f4f97add5f67c1fb233f9a" translate="yes" xml:space="preserve">
          <source>For more information on the usage of async components, see:</source>
          <target state="translated">비동기 구성 요소 사용에 대한 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="536883fd2260e1bd1beb314e51c0ac7037106dfa" translate="yes" xml:space="preserve">
          <source>For more information on the usage of the new functional components and the changes to render functions in general, see:</source>
          <target state="translated">새로운 기능 구성 요소의 사용법과 일반적으로 기능을 렌더링하기위한 변경 사항에 대한 자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c3c359e7659000f494e038fbf4590d86581b0892" translate="yes" xml:space="preserve">
          <source>For more information on this, please read the &lt;a href=&quot;../../api/options-data#emits&quot;&gt;API documentation for this feature&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용 &lt;a href=&quot;../../api/options-data#emits&quot;&gt;은이 기능에 대한 API 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e12cb821a984871364b6d35bee2e2d40be993d5f" translate="yes" xml:space="preserve">
          <source>For more information, read on!</source>
          <target state="translated">자세한 내용은 계속 읽어보세요!</target>
        </trans-unit>
        <trans-unit id="4bb0198cb8cce89766664ade9b3c4e2538d0d93d" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0008-render-function-api-change.md#context-free-vnodes&quot;&gt;The Render Function Api Change RFC (opens new window)&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0008-render-function-api-change.md#context-free-vnodes&quot;&gt;The Render Function Api Change RFC (opens new window)를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a2e95661b48b511251e25b504cdd0211c50e8b" translate="yes" xml:space="preserve">
          <source>For more on how JSX maps to JavaScript, see the &lt;a href=&quot;https://github.com/vuejs/jsx#installation&quot;&gt;usage docs&lt;/a&gt;.</source>
          <target state="translated">JSX가 JavaScript에 맵핑되는 방법에 대한 자세한 정보는 &lt;a href=&quot;https://github.com/vuejs/jsx#installation&quot;&gt;사용법 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="306b5d71d63506d1b50cc3b91e3432c31824e4b9" translate="yes" xml:space="preserve">
          <source>For more on how JSX maps to JavaScript, see the &lt;a href=&quot;https://github.com/vuejs/jsx-next#installation&quot;&gt;usage docs (opens new window)&lt;/a&gt;.</source>
          <target state="translated">JSX가 JavaScript에 매핑되는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/vuejs/jsx-next#installation&quot;&gt;사용법 문서 (새 창에서 열림)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e41c2b329c905a4640c7495f0532f24ec2ebd4c" translate="yes" xml:space="preserve">
          <source>For more on the advantages of this strategy, see &lt;a href=&quot;#debounce-Param-Attribute-for-v-model-removed&quot;&gt;the example here with &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 전략의 장점에 대한 자세한 내용 &lt;a href=&quot;#debounce-Param-Attribute-for-v-model-removed&quot;&gt;은 여기에서 &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25b70aa7a4e5c440a926c6e391e7d79fda4e4edb" translate="yes" xml:space="preserve">
          <source>For most Single Page Applications, it&amp;rsquo;s recommended to use the officially-supported &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router library&lt;/a&gt;. For more details, see vue-router&amp;rsquo;s &lt;a href=&quot;https://router.vuejs.org/&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">대부분의 단일 페이지 응용 프로그램의 경우 공식적으로 지원되는 &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router 라이브러리&lt;/a&gt; 를 사용하는 것이 좋습니다 . 자세한 내용은 vue-router &lt;a href=&quot;https://router.vuejs.org/&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b6b38ec8129680b2d7815658416e8aae9ea6dc6" translate="yes" xml:space="preserve">
          <source>For most Single Page Applications, it's recommended to use the officially-supported &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router library (opens new window)&lt;/a&gt;. For more details, see vue-router's &lt;a href=&quot;https://next.router.vuejs.org/&quot;&gt;documentation (opens new window)&lt;/a&gt;.</source>
          <target state="translated">대부분의 단일 페이지 애플리케이션의 경우 공식적으로 지원되는 &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;vue-router 라이브러리 (새 창에서 열림)&lt;/a&gt; 를 사용하는 것이 좋습니다 . 자세한 내용은 vue-router의 &lt;a href=&quot;https://next.router.vuejs.org/&quot;&gt;설명서 (새 창에서 열림)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b3557fe91b413f4d536e3e8b778c8dcb8073525" translate="yes" xml:space="preserve">
          <source>For most attributes, the value provided to the component will replace the value set by the component. So for example, passing &lt;code&gt;type=&quot;text&quot;&lt;/code&gt; will replace &lt;code&gt;type=&quot;date&quot;&lt;/code&gt; and probably break it! Fortunately, the &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; attributes are a little smarter, so both values are merged, making the final value: &lt;code&gt;form-control date-picker-theme-dark&lt;/code&gt;.</source>
          <target state="translated">대부분의 속성에서 구성 요소에 제공된 값은 구성 요소에서 설정 한 값을 대체합니다. 예를 들어, &lt;code&gt;type=&quot;text&quot;&lt;/code&gt; 를 전달 하면 &lt;code&gt;type=&quot;date&quot;&lt;/code&gt; 가 바뀌고 아마 깨질 것입니다! 다행히도, &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;style&lt;/code&gt; : 속성은 두 값이 최종 값 만들기, 병합, 그래서 조금 영리 &lt;code&gt;form-control date-picker-theme-dark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a837c87177ecd8e4cd4beb19f8c23e72ed9b09" translate="yes" xml:space="preserve">
          <source>For most object-based options, you can use the same strategy used by &lt;code&gt;methods&lt;/code&gt;:</source>
          <target state="translated">대부분의 객체 기반 옵션의 경우 &lt;code&gt;methods&lt;/code&gt; 사용하는 것과 동일한 전략을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ff9670878879c74838bc30c8f8bfa6747549843" translate="yes" xml:space="preserve">
          <source>For non-boolean attributes, Vue will stop removing them if they are &lt;code&gt;false&lt;/code&gt; and coerce them to &lt;code&gt;'false'&lt;/code&gt; instead.</source>
          <target state="translated">부울이 아닌 속성의 경우 Vue는 해당 속성이 &lt;code&gt;false&lt;/code&gt; 이면 제거를 중지 하고 대신 &lt;code&gt;'false'&lt;/code&gt; 로 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="251b61258856c24886a8806ada332b57726c8a90" translate="yes" xml:space="preserve">
          <source>For other attributes, we remove &quot;falsy&quot; values (&lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;) and set other values as-is (see &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L92-L113&quot;&gt;here (opens new window)&lt;/a&gt;).</source>
          <target state="translated">다른 속성의 경우 &quot;거짓&quot;값 ( &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )을 제거하고 다른 값을있는 그대로 설정합니다 ( &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/runtime/modules/attrs.js#L92-L113&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 (새 창에서 열림) ).</target>
        </trans-unit>
        <trans-unit id="4e0dfedd4cc8e8370f219ab6a1f3f4a19c41fd4e" translate="yes" xml:space="preserve">
          <source>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions.</source>
          <target state="translated">프로덕션의 경우 특정 버전 번호에 연결하고 최신 버전에서 예상치 못한 손상을 방지하기 위해 빌드하는 것이 좋습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="079fe21cc823d55812a634a8c119ed4491fd69e2" translate="yes" xml:space="preserve">
          <source>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:</source>
          <target state="translated">프로덕션의 경우 특정 버전 번호에 연결하고 최신 버전에서 예기치 않은 손상을 피하기 위해 빌드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bfe0d3e18701e6d75a26a86522437e9ae637b2e5" translate="yes" xml:space="preserve">
          <source>For prototyping or learning purposes, you can use the latest version with:</source>
          <target state="translated">시제품 제작 또는 학습 목적으로 최신 버전을 다음과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5495fda2474f4c57808bc121708bd27a76751c59" translate="yes" xml:space="preserve">
          <source>For radio, checkbox and select options, the &lt;code&gt;v-model&lt;/code&gt; binding values are usually static strings (or booleans for checkbox):</source>
          <target state="translated">라디오, 확인란 및 선택 옵션의 경우 &lt;code&gt;v-model&lt;/code&gt; 바인딩 값은 일반적으로 정적 문자열 (또는 확인란의 경우 부울)입니다.</target>
        </trans-unit>
        <trans-unit id="54ac8bccd12f18241dd4cff24f2f7aa494f8a547" translate="yes" xml:space="preserve">
          <source>For simple UI transitions, meaning from just one state to another with no intermediary states, it's common to use timings between 0.1s and 0.4s, and most folks find that &lt;em&gt;0.25s&lt;/em&gt; tends to be a sweet spot. Can you use that timing for everything? No, not really. If you have something that needs to move a greater distance or has more steps or state changes, 0.25s is not going to work as well and you will have to be much more intentional, and the timing will need to be more unique. That doesn't mean you can't have nice defaults that you repeat within your application, though.</source>
          <target state="translated">단순한 UI 전환의 경우 (중간 상태가없는 한 상태에서 다른 상태로) &lt;em&gt;0.1 초에서 0.4 초&lt;/em&gt; 사이의 타이밍을 사용하는 것이 일반적이며 대부분의 사람들은 &lt;em&gt;0.25 초가 최적의 지점 인&lt;/em&gt; 경향이 있음을 발견합니다. 그 타이밍을 모든 것에 사용할 수 있습니까? 아니 정말. 더 먼 거리를 이동해야하거나 더 많은 단계 또는 상태 변경이 필요한 무언가가있는 경우 0.25 초도 작동하지 않을 것이며 훨씬 더 의도적이어야하며 타이밍이 더 독특해야합니다. 그렇다고 애플리케이션 내에서 반복하는 멋진 기본값을 가질 수 없다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="eb997724620d308a038b97161b8c378aba0da047" translate="yes" xml:space="preserve">
          <source>For simplicity, &lt;code&gt;v-el&lt;/code&gt; and &lt;code&gt;v-ref&lt;/code&gt; have been merged into the &lt;code&gt;ref&lt;/code&gt; attribute, accessible on a component instance via &lt;code&gt;$refs&lt;/code&gt;. That means &lt;code&gt;v-el:my-element&lt;/code&gt; would become &lt;code&gt;ref=&quot;myElement&quot;&lt;/code&gt; and &lt;code&gt;v-ref:my-component&lt;/code&gt; would become &lt;code&gt;ref=&quot;myComponent&quot;&lt;/code&gt;. When used on a normal element, the &lt;code&gt;ref&lt;/code&gt; will be the DOM element, and when used on a component, the &lt;code&gt;ref&lt;/code&gt; will be the component instance.</source>
          <target state="translated">단순화를 위해 &lt;code&gt;v-el&lt;/code&gt; 및 &lt;code&gt;v-ref&lt;/code&gt; 는 &lt;code&gt;$refs&lt;/code&gt; 를 통해 구성 요소 인스턴스에서 액세스 할 수 있는 &lt;code&gt;ref&lt;/code&gt; 속성 으로 병합되었습니다 . 이는 &lt;code&gt;v-el:my-element&lt;/code&gt; 가 &lt;code&gt;ref=&quot;myElement&quot;&lt;/code&gt; 가 되고 &lt;code&gt;v-ref:my-component&lt;/code&gt; 가 &lt;code&gt;ref=&quot;myComponent&quot;&lt;/code&gt; 가 됨을 의미 합니다. 일반 요소에서 사용될 경우 &lt;code&gt;ref&lt;/code&gt; 는 DOM 요소가되고 구성 요소에서 사용될 때 &lt;code&gt;ref&lt;/code&gt; 는 구성 요소 인스턴스가됩니다.</target>
        </trans-unit>
        <trans-unit id="e76e7f48f467e821b972221e9f61c5c2ee71e6e9" translate="yes" xml:space="preserve">
          <source>For some attribute/element pairs, Vue is always using the corresponding IDL attribute (property): &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L11-L18&quot;&gt;like &lt;code&gt;value&lt;/code&gt; of &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt;, etc (opens new window)&lt;/a&gt;.</source>
          <target state="translated">몇몇 속성 / 요소 쌍, 뷰는 항상 대응 IDL 속성 (속성)를 이용되어 &lt;a href=&quot;https://github.com/vuejs/vue/blob/bad3c326a3f8b8e0d3bcf07917dc0adf97c32351/src/platforms/web/util/attrs.js#L11-L18&quot;&gt;추천 &lt;code&gt;value&lt;/code&gt; 의 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt; 등 (새로운 윈도우를 연다)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc84ef6ae335396a13ddb8d1d5c433bb865da784" translate="yes" xml:space="preserve">
          <source>For such cases, we can use the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; pair. Parent components can serve as dependency provider for all its children, regardless how deep the component hierarchy is. This feature works on two parts: parent component has a &lt;code&gt;provide&lt;/code&gt; option to provide data and child component has an &lt;code&gt;inject&lt;/code&gt; option to start using this data.</source>
          <target state="translated">이러한 경우 &lt;code&gt;provide&lt;/code&gt; 및 &lt;code&gt;inject&lt;/code&gt; 쌍을 사용할 수 있습니다 . 부모 구성 요소는 구성 요소 계층 구조의 깊이에 관계없이 모든 자식에 대한 종속성 공급자 역할을 할 수 있습니다. 이 기능은 두 부분에서 작동합니다. 상위 구성 요소에는 데이터를 제공 하는 &lt;code&gt;provide&lt;/code&gt; 옵션이 있고 하위 구성 요소에는 이 데이터 사용을 시작 하는 &lt;code&gt;inject&lt;/code&gt; 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2a3066945dc05ec1aac7c250f3d7947f3b1e0b5" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;.passive&lt;/code&gt;, &lt;code&gt;.capture&lt;/code&gt; and &lt;code&gt;.once&lt;/code&gt; event modifiers, Vue offers prefixes that can be used with &lt;code&gt;on&lt;/code&gt;:</source>
          <target state="translated">를 들어 &lt;code&gt;.passive&lt;/code&gt; , &lt;code&gt;.capture&lt;/code&gt; 및 &lt;code&gt;.once&lt;/code&gt; 함께 사용할 수있는 이벤트 수정, 뷰 제공 접두사 &lt;code&gt;on&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4e719f060c037bd683606bea572e1d5bb08e920e" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;.passive&lt;/code&gt;, &lt;code&gt;.capture&lt;/code&gt;, and &lt;code&gt;.once&lt;/code&gt; event modifiers, they can be concatenated after the event name using camel case.</source>
          <target state="translated">를 들어 &lt;code&gt;.passive&lt;/code&gt; , &lt;code&gt;.capture&lt;/code&gt; 및 &lt;code&gt;.once&lt;/code&gt; 이벤트 수정, 그들은 낙타 케이스를 사용하여 이벤트 이름 다음에 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f75221fb27ca7d747fd5afe72b749aa8a5d218f" translate="yes" xml:space="preserve">
          <source>For the HTML above, you decide you want this component interface:</source>
          <target state="translated">위 HTML의 경우이 구성 요소 인터페이스를 원하는 것으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="58f64ac9d01eaada8c5b4d73c9742574b3650194" translate="yes" xml:space="preserve">
          <source>For the most part, we also avoid suggestions about JavaScript or HTML in general. We don&amp;rsquo;t mind whether you use semicolons or trailing commas. We don&amp;rsquo;t mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we&amp;rsquo;ve found that a particular pattern is helpful in the context of Vue.</source>
          <target state="translated">대부분의 경우 일반적으로 JavaScript 또는 HTML에 대한 제안을 피합니다. 세미콜론 또는 후행 쉼표를 사용하는지 여부는 중요하지 않습니다. HTML이 속성 값에 작은 따옴표 또는 큰 따옴표를 사용하는지 여부는 중요하지 않습니다. 그러나 Vue의 맥락에서 특정 패턴이 도움이된다는 것을 발견 한 예외도 있습니다.</target>
        </trans-unit>
        <trans-unit id="028ebb25464ebec8b20c053a3b3a36adc8dad6ef" translate="yes" xml:space="preserve">
          <source>For the most part, we also avoid suggestions about JavaScript or HTML in general. We don't mind whether you use semicolons or trailing commas. We don't mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we've found that a particular pattern is helpful in the context of Vue.</source>
          <target state="translated">대부분의 경우 일반적으로 JavaScript 또는 HTML에 대한 제안을 피합니다. 세미콜론을 사용하든 후행 쉼표를 사용하든 상관 없습니다. HTML이 속성 값에 작은 따옴표를 사용하는지 큰 따옴표를 사용하는지 상관하지 않습니다. 그러나 Vue의 맥락에서 특정 패턴이 도움이된다는 것을 발견 한 몇 가지 예외가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="25c81923e98cd7ec07a97be7558b6cf3f7038dd7" translate="yes" xml:space="preserve">
          <source>For these cases, the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element has a special attribute, &lt;code&gt;name&lt;/code&gt;, which can be used to assign a unique ID to different slots so you can determine where content should be rendered:</source>
          <target state="translated">이러한 경우 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에는 콘텐츠를 렌더링 할 위치를 결정할 수 있도록 다른 슬롯에 고유 ID를 할당하는 데 사용할 수 있는 특수 속성 &lt;code&gt;name&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="382333fc9a3981c853d256439249bf9dd8adac77" translate="yes" xml:space="preserve">
          <source>For these cases, the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element has a special attribute, &lt;code&gt;name&lt;/code&gt;, which can be used to define additional slots:</source>
          <target state="translated">이러한 경우 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에는 추가 속성 을 정의하는 데 사용할 수 있는 특수 속성 인 &lt;code&gt;name&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab05d6a03f13ecf11e09f8cd4a8521c92789cf2" translate="yes" xml:space="preserve">
          <source>For these reasons, we recommend you &lt;strong&gt;always use kebab-case for event names&lt;/strong&gt;.</source>
          <target state="translated">이러한 이유로 &lt;strong&gt;항상 이벤트 이름으로 케밥 케이스를 사용하는&lt;/strong&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7422d6b54df4734e87a03b347852584179acad85" translate="yes" xml:space="preserve">
          <source>For this component, &lt;code&gt;children&lt;/code&gt; will give you both paragraphs, &lt;code&gt;slots().default&lt;/code&gt; will give you only the second, and &lt;code&gt;slots().foo&lt;/code&gt; will give you only the first. Having both &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;slots()&lt;/code&gt; therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along &lt;code&gt;children&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소의 경우 &lt;code&gt;children&lt;/code&gt; 는 두 단락을 모두 제공하고 &lt;code&gt;slots().default&lt;/code&gt; 는 두 번째 만 제공하고 &lt;code&gt;slots().foo&lt;/code&gt; 는 첫 번째 만 제공합니다. 따라서 &lt;code&gt;children&lt;/code&gt; 및 &lt;code&gt;slots()&lt;/code&gt; 를 모두 사용하면이 구성 요소가 슬롯 시스템에 대해 알고 있는지 여부 또는 &lt;code&gt;children&lt;/code&gt; 을 따라 전달하여 해당 구성 요소를 다른 구성 요소에 위임 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="642f0a872b130e87234ba2ea02cd0acd1f89f0f7" translate="yes" xml:space="preserve">
          <source>For this to actually work though, the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; inside the component must:</source>
          <target state="translated">이것이 실제로 작동 하려면 구성 요소 내부의 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 이 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="7067621097f331cfbfd9c61c3f4e1bba268f1f7f" translate="yes" xml:space="preserve">
          <source>For those using &lt;code&gt;keyCode&lt;/code&gt; in their codebase, we recommend converting them to their kebab-cased named equivalents.</source>
          <target state="translated">코드베이스에서 &lt;code&gt;keyCode&lt;/code&gt; 를 사용하는 사람들 의 경우 케밥 케이스에 해당하는 이름의 등가물로 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c8d3cdea2ca7baa200cc6c2ffdec5ca079874264" translate="yes" xml:space="preserve">
          <source>For usage via native ES modules imports (in browser via &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">네이티브 ES 모듈 가져 오기 ( &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; 를 통해 브라우저에서 사용)를 통해 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="870759f6d46b7c078c81edc1954a4567215df1a3" translate="yes" xml:space="preserve">
          <source>For use in Node.js server-side rendering via &lt;code&gt;require()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; 를 통한 Node.js 서버 측 렌더링에서 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="fd55d066931ba01f4f5e712cf3141c92316f8a02" translate="yes" xml:space="preserve">
          <source>For use with bundlers like &lt;code&gt;webpack&lt;/code&gt;, &lt;code&gt;rollup&lt;/code&gt; and &lt;code&gt;parcel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;webpack&lt;/code&gt; , &lt;code&gt;rollup&lt;/code&gt; 및 &lt;code&gt;parcel&lt;/code&gt; 과 같은 번 들러 와 함께 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="3f92adb4391d3d5a7fa7daa29cb0cd3d55eab859" translate="yes" xml:space="preserve">
          <source>For users relying on the deep merge behavior from mixins, we recommend refactoring your code to avoid such reliance altogether, since deep merges from mixins are very implicit and can make the code logic more difficult to understand and debug.</source>
          <target state="translated">믹스 인의 딥 머지 동작에 의존하는 사용자의 경우 믹스 인의 딥 머지가 매우 암시적이고 코드 로직을 이해하고 디버그하기 더 어렵게 만들 수 있으므로 이러한 의존성을 완전히 피하기 위해 코드를 리팩토링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7a35f2ca9829aa883fba906d90a1506c724cac8" translate="yes" xml:space="preserve">
          <source>For users relying on the object declaration, we recommend:</source>
          <target state="translated">객체 선언에 의존하는 사용자의 경우 다음을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="f49d376a6de7473873ecab8b0255bfe983f0a381" translate="yes" xml:space="preserve">
          <source>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</source>
          <target state="translated">Vue 인스턴스를 다시 렌더링하도록합니다. 모든 하위 구성 요소에는 영향을주지 않으며 슬롯 내용이 삽입 된 인스턴스 자체 및 하위 구성 요소에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2f2577b76f5c89e67164242a6f4fffe0a8d9b0c6" translate="yes" xml:space="preserve">
          <source>Force the component instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</source>
          <target state="translated">구성 요소 인스턴스를 강제로 다시 렌더링합니다. 모든 하위 구성 요소에는 영향을주지 않으며 슬롯 내용이 삽입 된 인스턴스 자체와 하위 구성 요소에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c6a1921854dd7346d5793a7190ade36dcd65a3ec" translate="yes" xml:space="preserve">
          <source>Forcing an Update</source>
          <target state="translated">업데이트 강제</target>
        </trans-unit>
        <trans-unit id="3598258735d9462e35c71955d2aad478ee96de66" translate="yes" xml:space="preserve">
          <source>Form Input Bindings</source>
          <target state="translated">양식 입력 바인딩</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="ea24491e797fa1205ee5f52da7150a0c400a5c95" translate="yes" xml:space="preserve">
          <source>Fortunately, if you&amp;rsquo;re using Webpack (or &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI 3+&lt;/a&gt;, which uses Webpack internally), you can use &lt;code&gt;require.context&lt;/code&gt; to globally register only these very common base components. Here&amp;rsquo;s an example of the code you might use to globally import base components in your app&amp;rsquo;s entry file (e.g. &lt;code&gt;src/main.js&lt;/code&gt;):</source>
          <target state="translated">다행히도 Webpack (또는 내부적으로 Webpack을 사용하는 &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;Vue CLI 3+&lt;/a&gt; )을 사용하는 경우 &lt;code&gt;require.context&lt;/code&gt; 를 사용 하여 이러한 매우 일반적인 기본 구성 요소 만 전체적으로 등록 할 수 있습니다 . 다음은 앱의 엔트리 파일 (예 : &lt;code&gt;src/main.js&lt;/code&gt; ) 에서 기본 구성 요소를 전체적으로 가져 오는 데 사용할 수있는 코드의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f4f1f7855db809feec9483f80786171f3900b2c2" translate="yes" xml:space="preserve">
          <source>Fortunately, since the new directives are much simpler, you can master them more easily. Read the new &lt;a href=&quot;custom-directive&quot;&gt;Custom Directives guide&lt;/a&gt; to learn more.</source>
          <target state="translated">다행히도 새로운 지시문이 훨씬 단순하기 때문에 더 쉽게 지시 할 수 있습니다. 자세한 내용은 새로운 &lt;a href=&quot;custom-directive&quot;&gt;Custom Directives 안내서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="4fd9ae517465a40e53760a54f6bec333ee06dca1" translate="yes" xml:space="preserve">
          <source>Fortunately, this task is made very simple by Vue&amp;rsquo;s custom &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">다행히도이 작업은 Vue의 사용자 정의 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소에 의해 매우 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="c91f2670059f0276f8d6d89ac974fb50d086e473" translate="yes" xml:space="preserve">
          <source>Fragment Instances &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">조각 인스턴스가 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d45089940ca38bf48726ea01710791bffa1dee6e" translate="yes" xml:space="preserve">
          <source>Fragments</source>
          <target state="translated">Fragments</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="f5d06aefcec385ad7ff6c62157c32259ce1a6caf" translate="yes" xml:space="preserve">
          <source>From CDN or without a Bundler</source>
          <target state="translated">CDN에서 또는 번 들러없이</target>
        </trans-unit>
        <trans-unit id="b4642923d899cbc5ab62815e12de0271d6f2fa99" translate="yes" xml:space="preserve">
          <source>From a &lt;code&gt;provide&lt;/code&gt;/&lt;code&gt;inject&lt;/code&gt; perspective, the application can be thought of as the root-level ancestor, with the root component as its only child.</source>
          <target state="translated">A는에서 &lt;code&gt;provide&lt;/code&gt; / &lt;code&gt;inject&lt;/code&gt; 관점, 응용 프로그램은 유일한 자식으로 루트 구성 요소, 루트 수준의 조상으로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="178ebb713b9cc3628fd4bcdf9a3650661449516a" translate="yes" xml:space="preserve">
          <source>From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</source>
          <target state="translated">보안 관점에서 신뢰할 수있는 Vue 템플릿 만 사용해야합니다. 사용자 생성 컨텐츠를 템플릿으로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9c1467ca8f0b364bc76e51d96247151aff4bf125" translate="yes" xml:space="preserve">
          <source>From the next page on, we'll use the shorthand in our examples, as that's the most common usage for Vue developers.</source>
          <target state="translated">다음 페이지에서는 Vue 개발자에게 가장 일반적인 사용법이므로 예제에서 속기를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb0a1c225bd8748f6348154b46c2de2332edb8a4" translate="yes" xml:space="preserve">
          <source>Full-word component names</source>
          <target state="translated">전체 단어 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="3aa0c3eb248b1e714e0b69b9e72c94f2ab3623af" translate="yes" xml:space="preserve">
          <source>Full-word component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">전체 단어 구성 요소 이름을 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="c1c714fa2e5c3d3a4ea2ec4e1e55c1e860e21631" translate="yes" xml:space="preserve">
          <source>Function Shorthand</source>
          <target state="translated">속기 기능</target>
        </trans-unit>
        <trans-unit id="d66736d35977604554e47b985518c7ca79eb37e3" translate="yes" xml:space="preserve">
          <source>Functional Components</source>
          <target state="translated">기능성 부품</target>
        </trans-unit>
        <trans-unit id="96b26a9809ce22c81fe36a4f50e6626696dc9755" translate="yes" xml:space="preserve">
          <source>Functional Images</source>
          <target state="translated">기능성 이미지</target>
        </trans-unit>
        <trans-unit id="f3455d04f7b99aaa4edea48a05fcdacfa7f01090" translate="yes" xml:space="preserve">
          <source>Functional components can only be created using a plain function</source>
          <target state="translated">기능적 구성 요소는 일반 함수를 사용해서 만 생성 할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="ca23386e71140d24b5ccfb5fed4ead2166b6d7dd" translate="yes" xml:space="preserve">
          <source>Functional components can only be created using a plain function that receives &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt; (i.e., &lt;code&gt;slots&lt;/code&gt;, &lt;code&gt;attrs&lt;/code&gt;, &lt;code&gt;emit&lt;/code&gt;)</source>
          <target state="translated">기능적 구성 요소는 &lt;code&gt;props&lt;/code&gt; 및 &lt;code&gt;context&lt;/code&gt; (예 : &lt;code&gt;slots&lt;/code&gt; , &lt;code&gt;attrs&lt;/code&gt; , &lt;code&gt;emit&lt;/code&gt; ) 를 수신하는 일반 함수를 사용해서 만 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37459d26665e23e74f757aae407f678185f79975" translate="yes" xml:space="preserve">
          <source>Functional components, however, require you to explicitly define this behavior:</source>
          <target state="translated">그러나 기능적 구성 요소는이 동작을 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 읽기</target>
        </trans-unit>
        <trans-unit id="00a61bd33b146f5097972a45bc611701e6893138" translate="yes" xml:space="preserve">
          <source>Furthermore, there&amp;rsquo;s another feature Proxies offer us. Rather than just returning the value like this: &lt;code&gt;target[prop]&lt;/code&gt;, we could take this a step further and use a feature called &lt;code&gt;Reflect&lt;/code&gt;, which allows us to do proper &lt;code&gt;this&lt;/code&gt; binding. It looks like this:</source>
          <target state="translated">또한 프록시가 제공하는 또 다른 기능이 있습니다. 오히려 바로이 같은 값을 반환보다 : &lt;code&gt;target[prop]&lt;/code&gt; , 우리는 더이 단계를 가지고라는 기능을 사용할 수 있습니다 &lt;code&gt;Reflect&lt;/code&gt; 우리가 제대로 수행 할 수 있습니다, &lt;code&gt;this&lt;/code&gt; 바인딩을. 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="686299f7711a328af7f7ede481ecd878f135b9f6" translate="yes" xml:space="preserve">
          <source>Generally speaking, &lt;code&gt;v-if&lt;/code&gt; has higher toggle costs while &lt;code&gt;v-show&lt;/code&gt; has higher initial render costs. So prefer &lt;code&gt;v-show&lt;/code&gt; if you need to toggle something very often, and prefer &lt;code&gt;v-if&lt;/code&gt; if the condition is unlikely to change at runtime.</source>
          <target state="translated">일반적으로 &lt;code&gt;v-if&lt;/code&gt; 는 전환 비용이 높고 &lt;code&gt;v-show&lt;/code&gt; 는 초기 렌더링 비용이 높습니다. 따라서 자주 전환해야 할 경우 &lt;code&gt;v-show&lt;/code&gt; 를 선호 하고 런타임에 조건이 변경되지 않을 경우 &lt;code&gt;v-if&lt;/code&gt; 를 선호 하십시오.</target>
        </trans-unit>
        <trans-unit id="54c5f98c2534a5664e54bdf67174809b2a27c8a3" translate="yes" xml:space="preserve">
          <source>Get Support</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="56838e716d916a8f84179a277a8f61383a4d8ff1" translate="yes" xml:space="preserve">
          <source>Get the Chrome Extension (opens new window)</source>
          <target state="translated">Chrome 확장 프로그램 다운로드 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="c4abb192008124d36b56bb6371f66e847e75589d" translate="yes" xml:space="preserve">
          <source>Get the Firefox Addon (opens new window)</source>
          <target state="translated">Firefox Addon 다운로드 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="1ec9d1dc51ac0809678c9ec59c779548f5b4c755" translate="yes" xml:space="preserve">
          <source>Get the standalone Electron app (opens new window)</source>
          <target state="translated">독립형 Electron 앱 다운로드 (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="b9157644be6cdf74f67e41a7df493f2e72e89d4e" translate="yes" xml:space="preserve">
          <source>Getting repositories from a presumedly external API for that user name and refreshing it whenever the user changes</source>
          <target state="translated">해당 사용자 이름에 대해 아마도 외부 API에서 저장소를 가져오고 사용자가 변경 될 때마다 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="5c4ff491f120f9f77d6aec67cf1c1a5aec7a86ca" translate="yes" xml:space="preserve">
          <source>GitHub (opens new window)</source>
          <target state="translated">GitHub (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="4687f4eea959b8d3a7678579930ba86b60298a4b" translate="yes" xml:space="preserve">
          <source>Global API</source>
          <target state="translated">글로벌 API</target>
        </trans-unit>
        <trans-unit id="9c2bad2cea69725d1e181e1b8b68e50c0e0677bb" translate="yes" xml:space="preserve">
          <source>Global API Treeshaking</source>
          <target state="translated">글로벌 API 트리 쉐이킹</target>
        </trans-unit>
        <trans-unit id="d99de9060d9d291cf15a1d729547287918e216dc" translate="yes" xml:space="preserve">
          <source>Global Config</source>
          <target state="translated">글로벌 구성</target>
        </trans-unit>
        <trans-unit id="547f82d236a59c0ef25ec787ae007217c314dc24" translate="yes" xml:space="preserve">
          <source>Global Filters</source>
          <target state="translated">글로벌 필터</target>
        </trans-unit>
        <trans-unit id="a87e1f8386cdfab8951563f9287ce245995f5751" translate="yes" xml:space="preserve">
          <source>Global Mixin</source>
          <target state="translated">글로벌 믹스 인</target>
        </trans-unit>
        <trans-unit id="12acfdfcb7281091faacdbe76162537707d677a4" translate="yes" xml:space="preserve">
          <source>Global Registration</source>
          <target state="translated">글로벌 등록</target>
        </trans-unit>
        <trans-unit id="163847eea99fcc7224e4af66d098a5cc860a81a0" translate="yes" xml:space="preserve">
          <source>Global Vue API is changed to use an application instance</source>
          <target state="translated">Global Vue API가 애플리케이션 인스턴스를 사용하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="81aa990181e866f19d507616169f29872b576378" translate="yes" xml:space="preserve">
          <source>Global and internal APIs have been restructured to be tree-shakable</source>
          <target state="translated">글로벌 및 내부 API가 트리 쉐이킹 가능하도록 재구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="808b46b8dcb3c8b68f9280a9b70cf36df1ff8d8d" translate="yes" xml:space="preserve">
          <source>Global builds are not &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD (opens new window)&lt;/a&gt; builds. They are built as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFEs (opens new window)&lt;/a&gt; and are only meant for direct use via &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">글로벌 빌드는 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD (새 창에서 열림)&lt;/a&gt; 빌드가 아닙니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/IIFE&quot;&gt;IIFE (새 창에서 열림)&lt;/a&gt; 로 빌드되었으며 &lt;code&gt;&amp;lt;script src=&quot;...&quot;&amp;gt;&lt;/code&gt; 를 통해 직접 사용하기위한 용도로만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3851c26eb150b1ec81c4c0fb518dc3a2c3de854" translate="yes" xml:space="preserve">
          <source>Global configuration makes it difficult to share the same copy of Vue between multiple &quot;apps&quot; on the same page, but with different global configurations.</source>
          <target state="translated">전역 구성은 동일한 페이지에있는 여러 &quot;앱&quot;간에 동일한 Vue 사본을 공유하기 어렵지만 전역 구성은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ca0c9680d30aa516862873fbaa7f725be08e92d" translate="yes" xml:space="preserve">
          <source>Global configuration makes it easy to accidentally pollute other test cases during testing. Users need to carefully store original global configuration and restore it after each test (e.g. resetting &lt;code&gt;Vue.config.errorHandler&lt;/code&gt;). Some APIs like &lt;code&gt;Vue.use&lt;/code&gt; and &lt;code&gt;Vue.mixin&lt;/code&gt; don't even have a way to revert their effects. This makes tests involving plugins particularly tricky. In fact, vue-test-utils has to implement a special API &lt;code&gt;createLocalVue&lt;/code&gt; to deal with this:</source>
          <target state="translated">글로벌 구성을 사용하면 테스트 중에 실수로 다른 테스트 케이스를 쉽게 오염시킬 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 사용자는 원래 전역 구성을 신중하게 저장하고 각 테스트 후에 복원해야합니다 (예 : &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 재설정 ). &lt;code&gt;Vue.use&lt;/code&gt; 및 &lt;code&gt;Vue.mixin&lt;/code&gt; 과 같은 일부 API 에는 효과를 되돌릴 수있는 방법도 없습니다. 이로 인해 플러그인과 관련된 테스트가 특히 까다로워집니다. 실제로 vue-test-utils는이를 처리하기 위해 특별한 API &lt;code&gt;createLocalVue&lt;/code&gt; 를 구현 해야합니다.</target>
        </trans-unit>
        <trans-unit id="d23476cf27dc98d9e3173cbdb68ad4566d7bbe61" translate="yes" xml:space="preserve">
          <source>Global registration often isn&amp;rsquo;t ideal. For example, if you&amp;rsquo;re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">글로벌 등록은 종종 이상적이지 않습니다. 예를 들어 Webpack과 같은 빌드 시스템을 사용하는 경우 모든 구성 요소를 전체적으로 등록하면 구성 요소 사용을 중단하더라도 최종 빌드에 해당 구성 요소가 계속 포함될 수 있습니다. 이것은 사용자가 다운로드해야하는 JavaScript의 양을 불필요하게 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="37ea5973c3a2644655b6a96aa3352df9a45d716a" translate="yes" xml:space="preserve">
          <source>Global registration often isn't ideal. For example, if you're using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</source>
          <target state="translated">글로벌 등록은 종종 이상적이지 않습니다. 예를 들어 Webpack과 같은 빌드 시스템을 사용하는 경우 모든 구성 요소를 전역 적으로 등록하면 구성 요소 사용을 중지하더라도 최종 빌드에 계속 포함될 수 있습니다. 이로 인해 사용자가 다운로드해야하는 JavaScript의 양이 불필요하게 증가합니다.</target>
        </trans-unit>
        <trans-unit id="e2b51a4acf3ac2ad46709058f4a65e88a724bd55" translate="yes" xml:space="preserve">
          <source>Global state management</source>
          <target state="translated">글로벌 상태 관리</target>
        </trans-unit>
        <trans-unit id="f3a3ea30b8a5c7b620242522b576fd9fc064c881" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any component within the app.</source>
          <target state="translated">전역 적으로 등록 된 구성 요소는 앱 내 모든 구성 요소의 템플릿에서 사용할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="d2cdbb9287a2eee1e29278ad1a52afa18af50490" translate="yes" xml:space="preserve">
          <source>Globally registered components can be used in the template of any root Vue instance (&lt;code&gt;new Vue&lt;/code&gt;) created afterwards &amp;ndash; and even inside all subcomponents of that Vue instance&amp;rsquo;s component tree.</source>
          <target state="translated">이후에 생성 된 루트 Vue 인스턴스 ( &lt;code&gt;new Vue&lt;/code&gt; ) 의 템플릿 과 해당 Vue 인스턴스 구성 요소 트리의 모든 하위 구성 요소 내 에서 전역 적으로 등록 된 구성 요소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d53a8dc9787d0f1938039b6b2df16c89e2967b1" translate="yes" xml:space="preserve">
          <source>Go ahead and enter &lt;code&gt;app3.seen = false&lt;/code&gt; in the console. You should see the message disappear.</source>
          <target state="translated">콘솔에 &lt;code&gt;app3.seen = false&lt;/code&gt; 를 입력하십시오 . 메시지가 사라지는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61dedcf053ff33692baacbf7789c5d7195d9acbe" translate="yes" xml:space="preserve">
          <source>Good</source>
          <target state="translated">Good</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="69bb404ef61342527a97e3471c79974d9c78d193" translate="yes" xml:space="preserve">
          <source>Group of Lines</source>
          <target state="translated">라인 그룹</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="e5ec1b56265caf2664a953b65cb3f8f644817218" translate="yes" xml:space="preserve">
          <source>Guide: Dynamic &amp;amp; Async Components</source>
          <target state="translated">가이드 : 동적 및 비동기 구성 요소</target>
        </trans-unit>
        <trans-unit id="5f2dd938f61dd340f569fabf697c6ec2bb6dee7c" translate="yes" xml:space="preserve">
          <source>Guide: Render Functions</source>
          <target state="translated">가이드 : 렌더 함수</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="613dffa8c694c4b79227626375484864e1cbb5bc" translate="yes" xml:space="preserve">
          <source>HTML &amp;amp; CSS</source>
          <target state="translated">HTML 및 CSS</target>
        </trans-unit>
        <trans-unit id="ecb5ae374f41987062d1edb5a439c141fbcfee47" translate="yes" xml:space="preserve">
          <source>HTML Interpolation &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">HTML 보간 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="61152bedc285b45e3443132c85b9e9eab87b1c71" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you&amp;rsquo;re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">HTML 속성 이름은 대소 문자를 구분하지 않으므로 브라우저는 대문자를 소문자로 해석합니다. 즉, DOM 내 템플릿을 사용하는 경우 camelCased 소품 이름은 케밥으로 묶인 (하이픈으로 구분) 등가물을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b39bff9af267e6abbb868e9a12d409c07e11dc31" translate="yes" xml:space="preserve">
          <source>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you're using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</source>
          <target state="translated">HTML 속성 이름은 대소 문자를 구분하지 않으므로 브라우저는 모든 대문자를 소문자로 해석합니다. 즉, DOM 내 템플릿을 사용할 때 camelCased 소품 이름은 케밥으로 구분 된 (하이픈으로 구분 된) 해당 항목을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="206317f92c61c3721e7b0ef393e74b50f2adc608" translate="yes" xml:space="preserve">
          <source>HTML elements,</source>
          <target state="translated">HTML 요소</target>
        </trans-unit>
        <trans-unit id="b7d20a95e49462d14a4c08f7dda3686750b36c96" translate="yes" xml:space="preserve">
          <source>HTML interpolation has been &lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt;removed in favor of &lt;code&gt;v-html&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#HTML-Interpolation-removed&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt; 을 위해 HTML 보간이 제거 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0b1c56685d95ab775546bda4c6e1ef23eea39b81" translate="yes" xml:space="preserve">
          <source>HTML interpolations (&lt;code&gt;{{{ foo }}}&lt;/code&gt;) have been removed in favor of the &lt;a href=&quot;../api/index#v-html&quot;&gt;&lt;code&gt;v-html&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-html&quot;&gt; &lt;code&gt;v-html&lt;/code&gt; &lt;/a&gt; 지시문 을 위해 HTML 보간 ( &lt;code&gt;{{{ foo }}}&lt;/code&gt; )이 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9222f90ca7bef5ec077522a045ce26798b1f94f0" translate="yes" xml:space="preserve">
          <source>HTML output</source>
          <target state="translated">HTML 출력</target>
        </trans-unit>
        <trans-unit id="ec5f7d68ba95b6c2f0128818861a5fb3a7ce41b3" translate="yes" xml:space="preserve">
          <source>HTML&amp;rsquo;s built-in input types won&amp;rsquo;t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">HTML의 내장 입력 유형이 항상 귀하의 요구를 충족시키는 것은 아닙니다. 다행히 Vue 구성 요소를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 입력을 작성할 수 있습니다. 이 입력은 &lt;code&gt;v-model&lt;/code&gt; 에서도 작동 합니다 ! 자세한 내용 은 구성 요소 안내서에서 &lt;a href=&quot;components#Using-v-model-on-Components&quot;&gt;사용자 정의 입력&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="fb690270c76e2db47a970e06f86e7a3a5883a88a" translate="yes" xml:space="preserve">
          <source>HTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with &lt;code&gt;v-model&lt;/code&gt;! To learn more, read about &lt;a href=&quot;component-basics#using-v-model-on-components&quot;&gt;custom inputs&lt;/a&gt; in the Components guide.</source>
          <target state="translated">HTML의 내장 입력 유형이 항상 사용자의 요구를 충족하지는 않습니다. 다행히 Vue 구성 요소를 사용하면 완전히 사용자 정의 된 동작으로 재사용 가능한 입력을 구축 할 수 있습니다. 이러한 입력은 &lt;code&gt;v-model&lt;/code&gt; 에서도 작동 합니다 ! 자세한 내용 은 구성 요소 가이드에서 &lt;a href=&quot;component-basics#using-v-model-on-components&quot;&gt;사용자 지정 입력&lt;/a&gt; 에 대해 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="69b83e92529f5151314d046d862c4a9c77d93516" translate="yes" xml:space="preserve">
          <source>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue&amp;rsquo;s reactivity features.</source>
          <target state="translated">HTML 기반 템플릿을 사용하면 기존 애플리케이션을 점진적으로 마이그레이션하여 Vue의 반응성 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b80c438bdbf48deb660589d7261f0c7c9b951b" translate="yes" xml:space="preserve">
          <source>Handling &lt;code&gt;v-model&lt;/code&gt; modifiers</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 수정 자 처리</target>
        </trans-unit>
        <trans-unit id="5e6fab8d8bdb45dbc0c724b264884e741a1423d5" translate="yes" xml:space="preserve">
          <source>Handling Edge Cases</source>
          <target state="translated">엣지 케이스 취급</target>
        </trans-unit>
        <trans-unit id="0c27db799f42037e36231e8871e3549a290cef26" translate="yes" xml:space="preserve">
          <source>Handling Loading State</source>
          <target state="translated">로딩 상태 처리</target>
        </trans-unit>
        <trans-unit id="f70e7e4e8994ebaac734eaf505f7cb87f5015b0f" translate="yes" xml:space="preserve">
          <source>Handling User Input</source>
          <target state="translated">사용자 입력 처리</target>
        </trans-unit>
        <trans-unit id="61c9f84499bec9bde043fc021c98456103f86820" translate="yes" xml:space="preserve">
          <source>Hardware Acceleration</source>
          <target state="translated">하드웨어 가속</target>
        </trans-unit>
        <trans-unit id="553c9fd444b729d939071ffd415fb951213f90a4" translate="yes" xml:space="preserve">
          <source>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</source>
          <target state="translated">해시 뱅은 더 이상 Google이 URL을 크롤링하는 데 필요하지 않으므로 더 이상 해시 전략의 기본값 (또는 옵션)이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9f228bc8902ad4164e90bc20dd028fb5c8497a4c" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;props&lt;/code&gt; as a separate argument makes it easier to type it individually without messing up the types of other properties on the context. It also makes it possible to keep a consistent signature across &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;render&lt;/code&gt; and plain functional components with TSX support.</source>
          <target state="translated">갖는 &lt;code&gt;props&lt;/code&gt; 별도의 인수로하면 쉽게 문맥에 다른 속성의 유형을 엉망으로하지 않고 개별적으로 입력 할 수 있습니다. 또한 TSX 지원을 통해 &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;render&lt;/code&gt; 및 일반 기능 구성 요소 에서 일관된 서명을 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e07493b672fce8fe42c311e7616e88f54ce8244" translate="yes" xml:space="preserve">
          <source>Having a wrapper object around any value allows us to safely pass it across our whole app without worrying about losing its reactivity somewhere along the way.</source>
          <target state="translated">어떤 값이든 래퍼 객체를 사용하면 어딘가에서 반응성을 잃어 버릴 염려없이 전체 앱에 안전하게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d68b23680238f325efc34072a89db096cd1404" translate="yes" xml:space="preserve">
          <source>Having this validator extracted out, we&amp;rsquo;ve also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it&amp;rsquo;s actually impossible for users to enter anything wrong, similar to what the browser&amp;rsquo;s native number input tries to do.</source>
          <target state="translated">이 유효성 검사기를 추출한 후 더욱 안정적인 솔루션에보다 편안하게 구축했습니다. 상태 문제가 제거되었으며 실제로 브라우저의 기본 숫자 입력과 비슷한 방식으로 사용자가 잘못 입력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4f75e97b23c45e2b51b6b59566b0c63957b9ec2" translate="yes" xml:space="preserve">
          <source>HeadingMap (opens new window)</source>
          <target state="translated">HeadingMap (새 창에서 열림)</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="5d3e638fd34dc7467faa0ba823b8497588b5815b" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;attributeName&lt;/code&gt; 은 JavaScript 표현식으로 동적으로 평가되며 평가 된 값이 인수의 최종 값으로 사용됩니다. 예를 들어 Vue 인스턴스에 값이 &lt;code&gt;&quot;href&quot;&lt;/code&gt; 인 데이터 속성 &lt;code&gt;attributeName&lt;/code&gt; 이있는 경우이 바인딩은 &lt;code&gt;v-bind:href&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1d6eb28f6d668d58fcb816e70ad43f719a0fc8d8" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;attributeName&lt;/code&gt; will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your component instance has a data property, &lt;code&gt;attributeName&lt;/code&gt;, whose value is &lt;code&gt;&quot;href&quot;&lt;/code&gt;, then this binding will be equivalent to &lt;code&gt;v-bind:href&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;attributeName&lt;/code&gt; 은 JavaScript 표현식으로 동적으로 평가되고 평가 된 값은 인수의 최종 값으로 사용됩니다. 예를 들어 구성 요소 인스턴스에 값이 &lt;code&gt;&quot;href&quot;&lt;/code&gt; 인 데이터 속성 &lt;code&gt;attributeName&lt;/code&gt; 이있는 경우이 바인딩은 &lt;code&gt;v-bind:href&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="89a97b67c98ddcf2e842f6272379190e542a3a62" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;filterA&lt;/code&gt; is defined as a function taking three arguments. The value of &lt;code&gt;message&lt;/code&gt; will be passed into the first argument. The plain string &lt;code&gt;'arg1'&lt;/code&gt; will be passed into the &lt;code&gt;filterA&lt;/code&gt; as its second argument, and the value of expression &lt;code&gt;arg2&lt;/code&gt; will be evaluated and passed in as the third argument.</source>
          <target state="translated">여기서 &lt;code&gt;filterA&lt;/code&gt; 는 세 개의 인수를 취하는 함수로 정의됩니다. &lt;code&gt;message&lt;/code&gt; 값은 첫 번째 인수로 전달됩니다. 일반 문자열 &lt;code&gt;'arg1'&lt;/code&gt; 은 두 번째 인수로 &lt;code&gt;filterA&lt;/code&gt; 에 전달되고 &lt;code&gt;arg2&lt;/code&gt; 표현식의 값은 세 번째 인수로 평가 및 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b533c1b3a997459bdeab6c6103d2b8341430c012" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">여기 &lt;code&gt;href&lt;/code&gt; 는 &lt;code&gt;v-bind&lt;/code&gt; 지시문에 요소의 &lt;code&gt;href&lt;/code&gt; 속성을 &lt;code&gt;url&lt;/code&gt; 표현식의 값에 바인딩하도록 지시 하는 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="6ffd9aa49c21f1783d7611e5655d91a18b44be91" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;href&lt;/code&gt; is the argument, which tells the &lt;code&gt;v-bind&lt;/code&gt; directive to bind the element's &lt;code&gt;href&lt;/code&gt; attribute to the value of the expression &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;href&lt;/code&gt; 는 인수로, &lt;code&gt;v-bind&lt;/code&gt; 지시문이 요소의 &lt;code&gt;href&lt;/code&gt; 속성을 &lt;code&gt;url&lt;/code&gt; 표현식의 값에 바인딩하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="e8a2ad49522f0c5140bd579d6e3f6cc63de82a9e" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; can be omitted as it is implied:</source>
          <target state="translated">여기에서 &lt;code&gt;slot=&quot;default&quot;&lt;/code&gt; 는 암시 적으로 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ca790739e416685bfae690f4058212d4fda89a" translate="yes" xml:space="preserve">
          <source>Here is a high level overview of what has changed:</source>
          <target state="translated">다음은 변경된 사항에 대한 높은 수준의 개요입니다.</target>
        </trans-unit>
        <trans-unit id="f9d9edba5ad2d5d46534df4318d376f41d57f939" translate="yes" xml:space="preserve">
          <source>Here is a high level summary of the changes:</source>
          <target state="translated">다음은 변경 사항에 대한 높은 수준의 요약입니다.</target>
        </trans-unit>
        <trans-unit id="f0256c11a8b0470c358ede8196463daf684ea765" translate="yes" xml:space="preserve">
          <source>Here is a quick summary of what has changed:</source>
          <target state="translated">변경된 사항에 대한 간략한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9a9ea85b2164c893f9e78fffe543d952249311e" translate="yes" xml:space="preserve">
          <source>Here is the code used for a bounce in CSS (example from animate.css):</source>
          <target state="translated">다음은 CSS에서 반송에 사용되는 코드입니다 (animate.css의 예).</target>
        </trans-unit>
        <trans-unit id="a5a992eb5c40fb541d26012305484c0906879154" translate="yes" xml:space="preserve">
          <source>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</source>
          <target state="translated">여기서 인수는 수신 할 이벤트 이름입니다. 이벤트 처리에 대해 더 자세히 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f407b88178ffc4e03f9f78c8af7c050fb1a05bb8" translate="yes" xml:space="preserve">
          <source>Here we are encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you are seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &amp;ldquo;keep this element&amp;rsquo;s &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the Vue instance.&amp;rdquo;</source>
          <target state="translated">여기서 우리는 새로운 무언가를 만나고 있습니다. 보고있는 &lt;code&gt;v-bind&lt;/code&gt; 속성을 &lt;strong&gt;지시문&lt;/strong&gt; 이라고합니다 . 지시문 앞에 &lt;code&gt;v-&lt;/code&gt; 가 붙은 특수 속성임을 나타 내기 위해 v- 접두사가 붙습니다. 추측 할 수 있듯이 렌더링 된 DOM에 특별한 반응 동작을 적용합니다. 여기서는 기본적으로 &quot; Vue 인스턴스 의 &lt;code&gt;message&lt;/code&gt; 속성을 사용 하여이 요소의 &lt;code&gt;title&lt;/code&gt; 속성을 최신 상태로 유지하십시오&quot;라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="751e0a91c130034762d460cc66491b330e126c1a" translate="yes" xml:space="preserve">
          <source>Here we are exposing &lt;code&gt;root&lt;/code&gt; on the render context and binding it to the div as its ref via &lt;code&gt;ref=&quot;root&quot;&lt;/code&gt;. In the Virtual DOM patching algorithm, if a VNode's &lt;code&gt;ref&lt;/code&gt; key corresponds to a ref on the render context, the VNode's corresponding element or component instance will be assigned to the value of that ref. This is performed during the Virtual DOM mount / patch process, so template refs will only get assigned values after the initial render.</source>
          <target state="translated">여기서 우리는 렌더 컨텍스트에 &lt;code&gt;root&lt;/code&gt; 를 노출 하고 &lt;code&gt;ref=&quot;root&quot;&lt;/code&gt; 를 통해 참조 로 div에 바인딩합니다 . 가상 DOM 패치 알고리즘에서 VNode의 &lt;code&gt;ref&lt;/code&gt; 키가 렌더링 컨텍스트의 참조에 해당하면 VNode의 해당 요소 또는 구성 요소 인스턴스가 해당 참조의 값에 할당됩니다. 이는 Virtual DOM 마운트 / 패치 프로세스 중에 수행되므로 템플릿 참조는 초기 렌더링 이후에만 할당 된 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d0ddeabf229b343098143b62cc31c65937b8d157" translate="yes" xml:space="preserve">
          <source>Here we are specifying:</source>
          <target state="translated">여기서 우리는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="389a149e837ebef6fef4f3100295dd0e225f2c13" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;publishedBooksMessage&lt;/code&gt;.</source>
          <target state="translated">여기에서 계산 된 속성 &lt;code&gt;publishedBooksMessage&lt;/code&gt; 를 선언했습니다 .</target>
        </trans-unit>
        <trans-unit id="20439924cb310f6e6ebea9dce4e509745f1d1bb0" translate="yes" xml:space="preserve">
          <source>Here we have declared a computed property &lt;code&gt;reversedMessage&lt;/code&gt;. The function we provided will be used as the getter function for the property &lt;code&gt;vm.reversedMessage&lt;/code&gt;:</source>
          <target state="translated">여기에서 계산 된 속성 &lt;code&gt;reversedMessage&lt;/code&gt; 를 선언했습니다 . 우리가 제공 한 함수는 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 속성의 getter 함수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dd6b17922e8d61f4cd1713d4453ed7746270179" translate="yes" xml:space="preserve">
          <source>Here we're encountering something new. The &lt;code&gt;v-bind&lt;/code&gt; attribute you're seeing is called a &lt;strong&gt;directive&lt;/strong&gt;. Directives are prefixed with &lt;code&gt;v-&lt;/code&gt; to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here we are basically saying &quot;&lt;em&gt;keep this element's &lt;code&gt;title&lt;/code&gt; attribute up-to-date with the &lt;code&gt;message&lt;/code&gt; property on the current active instance.&lt;/em&gt;&quot;</source>
          <target state="translated">여기서 우리는 새로운 것을 만나고 있습니다. 보고있는 &lt;code&gt;v-bind&lt;/code&gt; 속성을 &lt;strong&gt;지시문&lt;/strong&gt; 이라고합니다 . 지시문은 Vue에서 제공하는 특수 속성임을 나타 내기 위해 &lt;code&gt;v-&lt;/code&gt; 접두어가 붙으며 , 짐작할 수 있듯이 렌더링 된 DOM에 특수 반응 동작을 적용합니다. 여기서 우리는 기본적으로 &quot; &lt;em&gt;현재 활성 인스턴스 &lt;/em&gt;&lt;em&gt;의 &lt;/em&gt;&lt;em&gt; &lt;code&gt;message&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 속성을 사용 &lt;/em&gt;&lt;em&gt;하여이 요소의 &lt;code&gt;title&lt;/code&gt; 속성을 최신 상태로 유지 합니다.&lt;/em&gt; &quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="2a306f3c88f48a02cdfb6f3ef97fd1e95920c1df" translate="yes" xml:space="preserve">
          <source>Here you have two options:</source>
          <target state="translated">여기에는 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41a58605aec4adfd7f18a1d980084fe022c01384" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a complete example of a simple todo list:</source>
          <target state="translated">간단한 할 일 목록의 전체 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6deaab1ac1757bb576b7c7fb31ce01f23836233" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a &lt;code&gt;smart-list&lt;/code&gt; component that delegates to more specific components, depending on the props passed to it:</source>
          <target state="translated">다음은 전달 된 소품에 따라보다 구체적인 구성 요소를 위임 하는 &lt;code&gt;smart-list&lt;/code&gt; 구성 요소 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8edc36b060f6cabd0970dde81f8964d59b6e1225" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a Vue component:</source>
          <target state="translated">Vue 구성 요소의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b31be59658661ba4e66f41944f3554b7a0be5398" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of a file we&amp;rsquo;ll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Hello.vue&lt;/code&gt; 라는 파일의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8301786be0047e93079236c79b42b00ad3cb2b07" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this:</source>
          <target state="translated">이에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b33ffef562696923d8035d66d6b00e446f9c5cd6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example using a template component:</source>
          <target state="translated">템플릿 구성 요소를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99ff339aed17c551cb54d5842ca9646f53c8ed64" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example with all of these modifiers used together:</source>
          <target state="translated">다음은 이러한 수정자가 모두 함께 사용 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="18a91a386128ffc554ca249fb0825499466cf9d3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">다음은 간결성을 위해 접두사 CSS 규칙을 생략 한 예입니다.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7ffc75a586e32509010b20213e0f4e623c0e848" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s that in action:</source>
          <target state="translated">그 행동은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af595ae1ee864db6e76a481669408e7e92ac1f80" translate="yes" xml:space="preserve">
          <source>Here's a complete example of a simple todo list:</source>
          <target state="translated">다음은 간단한 할 일 목록의 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="688263e087f6601926476dfa2106a42e01380fe3" translate="yes" xml:space="preserve">
          <source>Here's an example of a Vue component:</source>
          <target state="translated">다음은 Vue 구성 요소의 예입니다.</target>
        </trans-unit>
        <trans-unit id="22f8d41844c86dba38f5f9baf04f9bae49d99522" translate="yes" xml:space="preserve">
          <source>Here's an example of a file we'll call &lt;code&gt;Hello.vue&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;Hello.vue&lt;/code&gt; 라고 부르는 파일의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="db86228ab3e54e78f7884e3efc24acce9a5c3687" translate="yes" xml:space="preserve">
          <source>Here's an example using a template component:</source>
          <target state="translated">다음은 템플릿 구성 요소를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d1fd1a6d8a5163d813f71f2f63b54d29f44ba7da" translate="yes" xml:space="preserve">
          <source>Here's an example with all of these modifiers used together:</source>
          <target state="translated">다음은 이러한 모든 수정자를 함께 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="bbab897511ec130afe4d250a68f265050a7f57c4" translate="yes" xml:space="preserve">
          <source>Here's an example, omitting prefixed CSS rules for the sake of brevity:</source>
          <target state="translated">다음은 간결함을 위해 접두사가 붙은 CSS 규칙을 생략 한 예입니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="261472f9fef16d300b7f853b7d429bbbc35678f0" translate="yes" xml:space="preserve">
          <source>Here's that in action:</source>
          <target state="translated">그 행동은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a829483e3b314613758a5a663c73e6905d5701b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;slot-scope&lt;/code&gt; declares the received props object as the &lt;code&gt;slotProps&lt;/code&gt; variable, and makes it available inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; scope. You can name &lt;code&gt;slotProps&lt;/code&gt; anything you like similar to naming function arguments in JavaScript.</source>
          <target state="translated">여기서 &lt;code&gt;slot-scope&lt;/code&gt; 는 수신 된 props 객체를 &lt;code&gt;slotProps&lt;/code&gt; 변수 로 선언 하고 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 범위 내에서 사용할 수있게합니다 . JavaScript에서 함수 인수 이름 지정과 비슷한 것을 원하는 이름으로 &lt;code&gt;slotProps&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07c4f8866b982390147ee4436ece672dc4814fe6" translate="yes" xml:space="preserve">
          <source>Here, in the initial setup for this element, the directive binds a style by passing in a value, that can be updated to different values through the application.</source>
          <target state="translated">여기에서이 요소의 초기 설정에서 지시문은 응용 프로그램을 통해 다른 값으로 업데이트 할 수있는 값을 전달하여 스타일을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="4b2563c09ff007a4f9ec50612961f789811e49c4" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;computed&lt;/code&gt; function returns a &lt;em&gt;read-only&lt;/em&gt;&lt;strong&gt;Reactive Reference&lt;/strong&gt; to the output of the getter-like callback passed as the first argument to &lt;code&gt;computed&lt;/code&gt;. In order to access the &lt;strong&gt;value&lt;/strong&gt; of the newly-created computed variable, we need to use the &lt;code&gt;.value&lt;/code&gt; property just like with &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">여기서, &lt;code&gt;computed&lt;/code&gt; 함수 반환 &lt;em&gt;판독 전용 &lt;/em&gt;&lt;strong&gt;대하여 반응성이 참조&lt;/strong&gt; 하는 첫 번째 인수로서 건네 게터 같은 콜백의 출력으로 &lt;code&gt;computed&lt;/code&gt; . 새로 생성 된 계산 변수 의 &lt;strong&gt;값&lt;/strong&gt; 에 액세스하려면 &lt;code&gt;ref&lt;/code&gt; 와 마찬가지로 &lt;code&gt;.value&lt;/code&gt; 속성 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f68e5bf516c14d7636dc7e787f07b009104eba6f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;v-if&lt;/code&gt; directive would remove/insert the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element based on the truthiness of the value of the expression &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">여기서, &lt;code&gt;v-if&lt;/code&gt; 지시자 제거 할 / 삽입 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 식의 값에 기초하여 요소 truthiness &lt;code&gt;seen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74a0401e1c560ba1c5afee6af3517146ff6e91b7" translate="yes" xml:space="preserve">
          <source>Hiding Content</source>
          <target state="translated">콘텐츠 숨기기</target>
        </trans-unit>
        <trans-unit id="8e26e3e40dfd6774d32a14ec704c7c19bb0bf799" translate="yes" xml:space="preserve">
          <source>Hook Functions</source>
          <target state="translated">후크 기능</target>
        </trans-unit>
        <trans-unit id="d2bdd950b4b524b4faf0540c42b846e440d3ebd2" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component&amp;rsquo;s own hooks.</source>
          <target state="translated">이름이 같은 후크 함수는 배열로 병합되어 모든 함수가 호출됩니다. 컴포넌트 자체 후크 &lt;strong&gt;전에&lt;/strong&gt; 믹스 인 후크가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ba6a1895ad3d6fa940a4eef923c87acb24c09ba" translate="yes" xml:space="preserve">
          <source>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called &lt;strong&gt;before&lt;/strong&gt; the component's own hooks.</source>
          <target state="translated">이름이 같은 후크 함수는 배열로 병합되어 모두 호출됩니다. Mixin 후크는 구성 요소의 자체 후크 &lt;strong&gt;보다 먼저&lt;/strong&gt; 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="25b88ba8ec9795f83800a7ac6636b4adef402300" translate="yes" xml:space="preserve">
          <source>Hook inside &lt;code&gt;setup&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 내부 연결</target>
        </trans-unit>
        <trans-unit id="6edd974a79e43316d687690ff92842aac0f5cdd0" translate="yes" xml:space="preserve">
          <source>Hooks for components entering and leaving the DOM, in both CSS and JS, using the built-in &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">내장 된 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 구성 요소를 사용하여 CSS와 JS 모두에서 DOM에 들어오고 나가는 구성 요소에 대한 후크 .</target>
        </trans-unit>
        <trans-unit id="dedbb35ca38d565066cd84144d4ad177f2ccb3b9" translate="yes" xml:space="preserve">
          <source>Hooks for when multiple elements are updating in position, with FLIP techniques applied under the hood to increase performance, using the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 구성 요소를 사용하여 성능을 높이기 위해 후드 아래에 적용된 FLIP 기술과 함께 여러 요소가 제자리에서 업데이트되는 경우 후크 .</target>
        </trans-unit>
        <trans-unit id="06de93ef38b56bf88492fb8c2be6c9fc093d78d1" translate="yes" xml:space="preserve">
          <source>HostElement</source>
          <target state="translated">HostElement</target>
        </trans-unit>
        <trans-unit id="d3c93caab229d0146d8642adf5eff4a71a0f8cab" translate="yes" xml:space="preserve">
          <source>HostNode</source>
          <target state="translated">HostNode</target>
        </trans-unit>
        <trans-unit id="656dedbf5301c31ed9bdf32f2a451638643101f3" translate="yes" xml:space="preserve">
          <source>How Changes Are Tracked</source>
          <target state="translated">변경 사항을 추적하는 방법</target>
        </trans-unit>
        <trans-unit id="256f6c2fbc2e1f1e87f183792e2b1c68e14ed4ee" translate="yes" xml:space="preserve">
          <source>How Vue Tracks These Changes</source>
          <target state="translated">Vue가 이러한 변경 사항을 추적하는 방법</target>
        </trans-unit>
        <trans-unit id="0ff257949771d060d1777c575c6a95991e5e90cc" translate="yes" xml:space="preserve">
          <source>How can I get involved with translations?</source>
          <target state="translated">번역에 참여하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="a056aea1f6dc2d57c44eacd2de4c8078611a80e1" translate="yes" xml:space="preserve">
          <source>How long will it take to migrate a Vue 1.x app to 2.0?</source>
          <target state="translated">Vue 1.x 앱을 2.0으로 마이그레이션하는 데 얼마나 걸립니까?</target>
        </trans-unit>
        <trans-unit id="a173386c8ab0ffd650a7e5d8b6fb73ce6260ce4e" translate="yes" xml:space="preserve">
          <source>How many times you get distracted and start playing with a cool new feature. 😉 Not judging, it also happened to us while building 2.0!</source>
          <target state="translated">산만하고 멋진 새 기능으로 게임을 시작하는 횟수입니다. 😉 판단하지 않고 2.0을 구축하는 동안 우리에게도 일어났습니다!</target>
        </trans-unit>
        <trans-unit id="5b51fcd95b1bb4c1d0a2feadea82b32351c13de4" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;inline-template&lt;/code&gt; makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the &lt;code&gt;template&lt;/code&gt; option or in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element in a &lt;code&gt;.vue&lt;/code&gt; file.</source>
          <target state="translated">그러나 &lt;code&gt;inline-template&lt;/code&gt; 은 템플릿 의 범위를 추론하기 어렵게 만듭니다. 모범 사례로 &lt;code&gt;template&lt;/code&gt; 옵션 또는 &lt;code&gt;.vue&lt;/code&gt; 파일 의 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 사용하여 구성 요소 내부에서 템플릿을 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7effd8de3ec227dd5f0f5288ef466720ca7ad205" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;props&lt;/code&gt; are reactive, you &lt;strong&gt;cannot use ES6 destructuring&lt;/strong&gt; because it will remove props reactivity.</source>
          <target state="translated">그러나 &lt;code&gt;props&lt;/code&gt; 는 반응 적이기 때문에 props 의 반응성 을 제거하므로 &lt;strong&gt;ES6 destructuring을 사용할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="824570cd815ecf580931f34e5f29506440b103be" translate="yes" xml:space="preserve">
          <source>However, do NOT destructure the &lt;code&gt;props&lt;/code&gt; object, as it will lose reactivity:</source>
          <target state="translated">그러나 반응도를 잃을 수 있으므로 &lt;code&gt;props&lt;/code&gt; 객체를 구조화 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="42d602a14282520e03f05621c18e657389b28401" translate="yes" xml:space="preserve">
          <source>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt;, &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt;, and &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt;.</source>
          <target state="translated">그러나 이것조차도 범위가 지정된 슬롯이 할 수있는 표면을 거의 긁지 않습니다. 실제 유효하고 범위가 지정된 슬롯 사용의 예를 보려면 &lt;a href=&quot;https://github.com/Akryum/vue-virtual-scroller&quot;&gt;Vue Virtual Scroller&lt;/a&gt; , &lt;a href=&quot;https://github.com/posva/vue-promised&quot;&gt;Vue Promised&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/LinusBorg/portal-vue&quot;&gt;Portal Vue&lt;/a&gt; 와 같은 라이브러리를 찾아 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e377ccc91063a19e1128087c043b05ac14bc27fd" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;Vue.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="translated">그러나 &lt;code&gt;Vue.component&lt;/code&gt; 를 통해 전역 구성 요소 정의 &lt;strong&gt;만&lt;/strong&gt; 사용하는 응용 프로그램의 경우 대신 케밥 케이스를 권장합니다. 그 이유는 다음과 같습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
