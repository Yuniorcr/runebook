<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="3018c9188b3b3d4a23f0075a78973fd85df51141" translate="yes" xml:space="preserve">
          <source>However, for applications that use &lt;strong&gt;only&lt;/strong&gt; global component definitions via &lt;code&gt;app.component&lt;/code&gt;, we recommend kebab-case instead. The reasons are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e85fdd91d6f41600c13668283501481ec58917" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;re requiring/importing components using a &lt;strong&gt;module system&lt;/strong&gt;, e.g. via Webpack or Browserify, you&amp;rsquo;ll get an error:</source>
          <target state="translated">그러나 Webpack 또는 Browserify와 같은 &lt;strong&gt;모듈 시스템을&lt;/strong&gt; 사용하여 구성 요소를 요구하거나 가져 오는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="002e68a8e4165cd18ac4324c9c1241124753edbf" translate="yes" xml:space="preserve">
          <source>However, if you&amp;rsquo;ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 위의 사항을 배제하고 수동으로 강제 업데이트해야하는 매우 드문 상황에 처한 경우 &lt;a href=&quot;../api/index#vm-forceUpdate&quot;&gt; &lt;code&gt;$forceUpdate&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d036c8bdba9e735ef24169304153c34c8f3b798" translate="yes" xml:space="preserve">
          <source>However, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with &lt;a href=&quot;../api/instance-methods#forceupdate&quot;&gt;&lt;code&gt;$forceUpdate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3610b4f1219dad3d7eab3e3d1d0df611f8efc2" translate="yes" xml:space="preserve">
          <source>However, in Vue 3, the performance of stateful components has improved to the point that the difference is negligible. In addition, stateful components now also include the ability to return multiple root nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317d1532f6f3ac08090592a8fdf8e37b997ac4a2" translate="yes" xml:space="preserve">
          <source>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a &lt;code&gt;type&lt;/code&gt; attribute, with a value of either &lt;code&gt;animation&lt;/code&gt; or &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">그러나 경우에 따라 Vue에 의해 트리거되는 CSS 애니메이션 및 호버에 대한 CSS 전환 효과와 같은 동일한 요소에 둘 다 원할 수 있습니다. 이 경우 Vue가 신경 쓰고 자하는 &lt;code&gt;type&lt;/code&gt; &lt;code&gt;animation&lt;/code&gt; 또는 &lt;code&gt;transition&lt;/code&gt; 값으로 유형 속성 에서 명시 적으로 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88b48c81e2c3197a6ab15508375bec7eb9392d39" translate="yes" xml:space="preserve">
          <source>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</source>
          <target state="translated">그러나 다른 지시문과 마찬가지로 속기는 인수가 제공 될 때만 사용할 수 있습니다. 이는 다음 구문이 유효하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e607f87fc1472f8d762256cb7690621e8b2099d" translate="yes" xml:space="preserve">
          <source>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you&amp;rsquo;d be better off going with Vue instead, since using Angular without TypeScript can be challenging.</source>
          <target state="translated">그러나 모든 사람이 TypeScript를 사용하려는 것은 아닙니다. 많은 소규모 사용 사례에서 유형 시스템을 도입하면 생산성 향상보다 더 많은 오버 헤드가 발생할 수 있습니다. 이러한 경우 TypeScript없이 Angular를 사용하는 것이 어려울 수 있으므로 Vue를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73e089bb95641b06647f01ce72a8df5b24a857f3" translate="yes" xml:space="preserve">
          <source>However, sometimes a part of a component's template belongs to this component logically, while from a technical point of view, it would be preferable to move this part of the template somewhere else in the DOM, outside of the Vue app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a38a0e30cb26490e5f05809a78f3a4c9e4964e" translate="yes" xml:space="preserve">
          <source>However, that level of flexibility is usually not required. It's often possible to replace &lt;code&gt;resolveDynamicComponent&lt;/code&gt; with a more direct alternative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8343c1410b44b823f35ff99f46fde41c340d0f" translate="yes" xml:space="preserve">
          <source>However, there are downsides to dependency injection. It couples components in your application to the way they&amp;rsquo;re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;using &lt;code&gt;$root&lt;/code&gt;&lt;/a&gt; for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that&amp;rsquo;s a good sign that you probably need a real state management solution like &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; instead.</source>
          <target state="translated">그러나 의존성 주입에는 단점이 있습니다. 응용 프로그램의 구성 요소를 현재 구성되어있는 방식으로 연결하므로 리팩토링이 더 어려워집니다. 제공된 속성도 반응하지 않습니다. 중앙 데이터 저장소를 생성하기 위해이를 &lt;a href=&quot;#Accessing-the-Root-Instance&quot;&gt;사용 &lt;code&gt;$root&lt;/code&gt; &lt;/a&gt; 하면 동일한 목적으로 $ root 를 사용하는 것만 큼 ​​좋지 않습니다 . 공유하려는 속성이 일반적인 것이 아니라 앱에 고유하거나 조상 내부에서 제공된 데이터를 업데이트하려는 경우 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 와 같은 실제 상태 관리 솔루션이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a5d7767d7e276c46e20eda1a815bca70a1441e7" translate="yes" xml:space="preserve">
          <source>However, there are times where we need to update the data inside of the component where the data is injected. In this scenario, we recommend providing a method that is responsible for mutating the reactive property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eff740b8e2a37ddfa14b1eb95316301f5907a17" translate="yes" xml:space="preserve">
          <source>However, this approach is potentially problematic for components that are reused because they'll all share the same debounced function. To keep the component instances independent from each other, we can add the debounced function in the &lt;code&gt;created&lt;/code&gt; lifecycle hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484afbd80ed598ca9c40608f3d779c450b8063ca" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That&amp;rsquo;s why it&amp;rsquo;s also possible to use the object syntax inside array syntax:</source>
          <target state="translated">그러나 여러 개의 조건부 클래스가있는 경우이 방법이 다소 장황 할 수 있습니다. 따라서 배열 구문 내에서 객체 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85cd8c9d4719bfdd0176caad9283969d3ff23830" translate="yes" xml:space="preserve">
          <source>However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226b6257bd14a41b418cc2a3219aded857a502c5" translate="yes" xml:space="preserve">
          <source>However, this won&amp;rsquo;t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="translated">그러나 구성 요소는 자체 범위를 분리하기 때문에 데이터를 구성 요소에 자동으로 전달하지 않습니다. 반복 된 데이터를 컴포넌트에 전달하려면 props도 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc101cca76508ab598f5b4b585c1e6780fad8310" translate="yes" xml:space="preserve">
          <source>However, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0c334fd910aa57b2a33967cd21852214b1f058" translate="yes" xml:space="preserve">
          <source>However, this won't work if we try to provide some component instance property here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004b32fe588f88c41b42b4992994b442c861a69c" translate="yes" xml:space="preserve">
          <source>However, watching a reactive object or array will always return a reference to the current value of that object for both the current and previous value of the state. To fully watch deeply nested objects and arrays, a deep copy of values may be required. This can be achieved with a utility such as &lt;a href=&quot;https://lodash.com/docs/4.17.15#cloneDeep&quot;&gt;lodash.cloneDeep (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beda99dc2b127dc999f5b7cc2a4cd360648f73d" translate="yes" xml:space="preserve">
          <source>However, when communicating between distant descendants/ancestors, &lt;code&gt;$emit&lt;/code&gt; won&amp;rsquo;t help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</source>
          <target state="translated">그러나 먼 자손 / 조상 사이의 의사 소통을 할 때는 &lt;code&gt;$emit&lt;/code&gt; 이 도움이되지 않습니다. 대신 가장 간단한 업그레이드는 중앙 집중식 이벤트 허브를 사용하는 것입니다. 이것은 컴포넌트 트리의 어느 위치에 있더라도 컴포넌트 사이에서, 심지어 형제 사이에서도 통신 할 수있는 추가 이점을 제공합니다! Vue 인스턴스는 이벤트 이미 터 인터페이스를 구현하므로 실제로이 목적으로 빈 Vue 인스턴스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6f9aa6296c86949de208bc5300b04f5bbd8e693" translate="yes" xml:space="preserve">
          <source>However, when using the composition API to explicitly create reactive objects, the best practice is to never hold a reference to the original raw object and only work with the reactive version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1f757f908ed45ae57de4307c1068e94a1b0cef" translate="yes" xml:space="preserve">
          <source>However, you can still wrap default slot content in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; if you wish to be explicit:</source>
          <target state="translated">그러나 명시 적으로 나타내려면 여전히 기본 슬롯 컨텐츠를 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 랩핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29e3b3dcfde111c535bca8f3776cc120ca6d19c2" translate="yes" xml:space="preserve">
          <source>Hybrid-App Development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7fc3d6b914325c881febd71fbf6f3338aea8b7" translate="yes" xml:space="preserve">
          <source>I hope that right now, you&amp;rsquo;re reading this sentence in your preferred language. If not, would you like to help us get there?</source>
          <target state="translated">현재이 문장을 원하는 언어로 읽고 있기를 바랍니다. 그렇지 않은 경우, 우리가 거기에 도착하는 데 도움을 원하십니까?</target>
        </trans-unit>
        <trans-unit id="b957c41023281a182ae498da3fc29d81076e5bc0" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;m glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven&amp;rsquo;t changed. It&amp;rsquo;s long because we like to offer very detailed explanations and include a lot of examples. Rest assured, &lt;strong&gt;this is not something you have to read from top to bottom!&lt;/strong&gt;</source>
          <target state="translated">물어봐서 기뻐요! 내 대답은 아니오 야. API의 약 90 %가 동일하며 핵심 개념은 변경되지 않았습니다. 우리는 매우 자세한 설명을 제공하고 많은 예제를 포함하기 때문에 오래 걸립니다. 안심하십시오, &lt;strong&gt;이것은 위에서 아래로 읽어야 할 것이 아닙니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7cc4427647cd69fcbdf57ea287139ca162e4fbe9" translate="yes" xml:space="preserve">
          <source>IDE Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615578cf02895b5ceadb54ba5821d7c10372fcdc" translate="yes" xml:space="preserve">
          <source>IDL attr &amp;amp; value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb8f6c14252759cd8673c61a24376d32e17b93a" translate="yes" xml:space="preserve">
          <source>Icons</source>
          <target state="translated">Icons</target>
        </trans-unit>
        <trans-unit id="31aa3a07a8b9c23bb9e5b73c71b5e12fcbbbc57f" translate="yes" xml:space="preserve">
          <source>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3507f10505e91a18afb212ac7e9aa0befd70ebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt;&amp;lsquo;s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;navigation-link&amp;gt;&lt;/code&gt; 의 서식 않았다 &lt;strong&gt;하지&lt;/strong&gt; 포함 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소는 삭제된다 개폐 태그 사이에 제공된 콘텐츠.</target>
        </trans-unit>
        <trans-unit id="74b581a78f3cd91716bbaddac8b29eb9776b03b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; contains a Vue component, it will remain a logical child component of the &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt;'s parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b06f1fcb96eb40ac85f5cac5c66c2b155891fcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;todo-button&amp;gt;&lt;/code&gt;'s template did &lt;strong&gt;not&lt;/strong&gt; contain a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element, any content provided between its opening and closing tag would be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201ba7f76ed37c8b5c2f564825de9c9ebb281704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;config.isCustomElement&lt;/code&gt; is assigned to when using a runtime-only build, a warning will be emitted instructing the user to pass the option in the build setup instead;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4775d5880e56a64ce430a67fd93821ff5271a8f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;elementOrSelector&lt;/code&gt; argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</source>
          <target state="translated">경우 &lt;code&gt;elementOrSelector&lt;/code&gt; 의 인수가 제공되지 템플릿은 오프 문서 요소로 렌더링 될 것입니다, 당신은 문서에 직접 삽입하는 기본 DOM API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b1be49ac332b8febaafa2d94f48398afa699acf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flush&lt;/code&gt; is set to &lt;code&gt;'sync'&lt;/code&gt;, the callback will be called synchronously, as soon as the value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6814c905755d5d0673271362491140f9bfec32ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isButtonDisabled&lt;/code&gt; has the value of &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;, the &lt;code&gt;disabled&lt;/code&gt; attribute will not even be included in the rendered &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">경우 &lt;code&gt;isButtonDisabled&lt;/code&gt; 이 값 갖는 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 상기 &lt;code&gt;disabled&lt;/code&gt; 특성에도 표현에 포함되지 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 엘리먼트.</target>
        </trans-unit>
        <trans-unit id="fe1c53b1161887bd5b64d08a53a8b025bd8d8769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object can be accessed in the component's template, as well as the properties of the &lt;code&gt;props&lt;/code&gt; passed into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72354f5499649f8d82fce993f6a021a2603b963e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup&lt;/code&gt; returns an object, the properties on the object will be merged on to the render context for the component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eb06e2e36786f2679f43f6de53626bf2d00da9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;title&lt;/code&gt; is an optional prop, it could be missing from &lt;code&gt;props&lt;/code&gt;. In that case, &lt;code&gt;toRefs&lt;/code&gt; won't create a ref for &lt;code&gt;title&lt;/code&gt;. Instead you'd need to use &lt;code&gt;toRef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb91108b05984da997ff690270396ce3ba6ac45" translate="yes" xml:space="preserve">
          <source>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</source>
          <target state="translated">Vue 2로 업그레이드하면 Vuex 및 Vue 라우터도 업그레이드해야합니까?</target>
        </trans-unit>
        <trans-unit id="af93e3aeb163599bea53f782e2751ff74ad451b7" translate="yes" xml:space="preserve">
          <source>If Vue didn&amp;rsquo;t have this rule, clicking on one button would affect the data of &lt;em&gt;all other instances&lt;/em&gt;, like below:</source>
          <target state="translated">Vue에이 규칙이없는 경우 하나의 버튼을 클릭하면 아래와 같이 &lt;em&gt;다른 모든 인스턴스&lt;/em&gt; 의 데이터에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="b7586f731f0b07604a55b0bff8fa3025687fb239" translate="yes" xml:space="preserve">
          <source>If a Vue instance didn&amp;rsquo;t receive the &lt;code&gt;el&lt;/code&gt; option at instantiation, it will be in &amp;ldquo;unmounted&amp;rdquo; state, without an associated DOM element. &lt;code&gt;vm.$mount()&lt;/code&gt; can be used to manually start the mounting of an unmounted Vue instance.</source>
          <target state="translated">Vue 인스턴스가 인스턴스화시 &lt;code&gt;el&lt;/code&gt; 옵션을받지 못한 경우 연관된 DOM 요소없이 &quot;마운트 해제&quot;상태가됩니다. &lt;code&gt;vm.$mount()&lt;/code&gt; 를 사용하여 마운트 해제 된 Vue 인스턴스 마운트를 수동으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5c5a2c7610113711661bfb46b69f9a5e5ddb79" translate="yes" xml:space="preserve">
          <source>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</source>
          <target state="translated">구성 요소가 단일 상위 구성 요소의 컨텍스트에서만 의미가있는 경우 해당 관계는 해당 이름으로 분명해야합니다. 편집기는 일반적으로 파일을 사전 순으로 구성하기 때문에 이러한 관련 파일도 서로 옆에 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d6080ced28d2ad5267aab8c60cb9e3ee41fcc9d3" translate="yes" xml:space="preserve">
          <source>If a component receives slots from its parent, they can be passed on directly to a child component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed6b31ac8ff605e55f7cdbf21aabd756efc8bb1" translate="yes" xml:space="preserve">
          <source>If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5928a9e5cf47cbe7b8911ef9b07fba741c7d9aa" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component&amp;rsquo;s render, it will be passed to the global &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration&lt;/a&gt; for Vue.</source>
          <target state="translated">구성 요소를 렌더링하는 동안 런타임 오류가 발생하면 전역 &lt;code&gt;Vue.config.errorHandler&lt;/code&gt; 구성 함수 (설정된 경우)에 전달됩니다 . Vue &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;의 공식 통합&lt;/a&gt; 을 제공 하는 &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry&lt;/a&gt; 와 같은 오류 추적 서비스와 함께이 후크를 활용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="642e3ac102c57674c11d312a80ed33358ce20b95" translate="yes" xml:space="preserve">
          <source>If a runtime error occurs during a component's render, it will be passed to the global &lt;code&gt;app.config.errorHandler&lt;/code&gt; config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like &lt;a href=&quot;https://sentry.io&quot;&gt;Sentry (opens new window)&lt;/a&gt;, which provides &lt;a href=&quot;https://sentry.io/for/vue/&quot;&gt;an official integration (opens new window)&lt;/a&gt; for Vue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec559a16f0238f7c29fe23c19c2dec1b891987a" translate="yes" xml:space="preserve">
          <source>If an object is assigned as a ref's value, the object is made deeply reactive by the &lt;a href=&quot;basic-reactivity#reactive&quot;&gt;reactive&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08aa6aa203690ff56afb57ae212ba05b4f6c10ba" translate="yes" xml:space="preserve">
          <source>If both event and callback are given, remove the listener for that specific callback only.</source>
          <target state="translated">이벤트와 콜백이 모두 제공된 경우 해당 특정 콜백에 대한 리스너 만 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="94a6cbe6ca363d5ecbd722fc5378a6b8f28c5053" translate="yes" xml:space="preserve">
          <source>If instead, your intent is to conditionally skip execution of the loop, you can place the &lt;code&gt;v-if&lt;/code&gt; on a wrapper element (or &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/a&gt;). For example:</source>
          <target state="translated">대신, 루프 실행을 조건부로 건너 뛰려는 &lt;code&gt;v-if&lt;/code&gt; 래퍼 요소 (또는 &lt;a href=&quot;conditional#Conditional-Groups-with-v-if-on-lt-template-gt&quot;&gt; &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/a&gt; ) 에 v-if 를 배치 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d9bd5e8b2424d69b89a9acc464902a1ecc6350" translate="yes" xml:space="preserve">
          <source>If it needs to be injected from a property with a different name, use &lt;code&gt;from&lt;/code&gt; to denote the source property:</source>
          <target state="translated">다른 이름을 가진 속성에서 주입해야하는 경우 &lt;code&gt;from&lt;/code&gt; 을 사용하여 소스 속성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f0caf8a9ac2bcc9fe7de24b53400b7eedb0a1ea6" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component&amp;rsquo;s inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="translated">구성 요소의 상속 체인 또는 상위 체인에 여러 &lt;code&gt;errorCaptured&lt;/code&gt; 후크가있는 경우 모두 동일한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f4ae8d54b54e963413f7f1cfbf43652de62cd55" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;errorCaptured&lt;/code&gt; hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa43e0b6fd3244a15d3b9a3afc829c3468152d" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;render&lt;/code&gt; function nor &lt;code&gt;template&lt;/code&gt; option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 함수 나 &lt;code&gt;template&lt;/code&gt; 옵션이 없으면 마운트 DOM 요소의 DOM 내 HTML이 템플릿으로 추출됩니다. 이 경우 Vue의 Runtime + Compiler 빌드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b01e73de7162db0cb72a3eeafeeb2620b8021a4" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue&amp;rsquo;s concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="translated">CSS 전환 / 애니메이션이 감지되지 않고 JavaScript 후크가 제공되지 않으면 삽입 및 / 또는 제거를위한 DOM 작업이 다음 프레임에서 즉시 실행됩니다 (참고 : 이는 Vue의 &lt;code&gt;nextTick&lt;/code&gt; 개념과 다른 브라우저 애니메이션 프레임입니다 ).</target>
        </trans-unit>
        <trans-unit id="b064733da54289be43813af974ffc4066d5f06c7" translate="yes" xml:space="preserve">
          <source>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue's concept of &lt;code&gt;nextTick&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc33fe28ba69d339fb37eab66ba597ee9dc10b1" translate="yes" xml:space="preserve">
          <source>If no arguments are provided, remove all event listeners;</source>
          <target state="translated">인수가 제공되지 않으면 모든 이벤트 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="91aba20875e905d73638256716c23f9b7b43a58d" translate="yes" xml:space="preserve">
          <source>If only the event is provided, remove all listeners for that event;</source>
          <target state="translated">이벤트 만 제공되는 경우 해당 이벤트에 대한 모든 리스너를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="575587717723913920c46177080895c689efec3d" translate="yes" xml:space="preserve">
          <source>If render function is present in the Vue option, the template will be ignored.</source>
          <target state="translated">Vue 옵션에 렌더링 기능이있는 경우 템플릿이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85fd7702f7debf176df5e9e28d28b4d2f2479f88" translate="yes" xml:space="preserve">
          <source>If required, a deep clone of the original object can be obtained by passing &lt;code&gt;vm.$data&lt;/code&gt; through &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 &lt;code&gt;JSON.parse(JSON.stringify(...))&lt;/code&gt; 통해 &lt;code&gt;vm.$data&lt;/code&gt; 를 전달하여 원본 객체의 딥 클론을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21380cb2235ba519b963494fea54adad9607a338" translate="yes" xml:space="preserve">
          <source>If so, please feel free to fork the repo for &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;these docs&lt;/a&gt; or for any other officially maintained documentation, then start translating. Once you&amp;rsquo;ve made some progress, open an issue or pull request in the main repo and we&amp;rsquo;ll put out a call for more contributors to help you out.</source>
          <target state="translated">그렇다면 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/&quot;&gt;이 문서&lt;/a&gt; 나 공식적으로 유지 관리되는 다른 문서의 경우 리포지토리를 포크하여 번역을 시작하십시오. 진전이 이루어지면 메인 리포지토리에서 이슈를 열거 나 풀 요청을하면 더 많은 기고자를 도와 줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3b0a88772445b0201a5544af343a6bd0d139fcc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errorCaptured&lt;/code&gt; hook itself throws an error, both this error and the original captured error are sent to the global &lt;code&gt;config.errorHandler&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;errorCaptured&lt;/code&gt; 의 후크 자체가 오류가 발생,이 오류 원래 촬영 된 오류는 모두 글로벌로 전송됩니다 &lt;code&gt;config.errorHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="009579549300fafa52dbcc22a4317c4e5cd4cffe" translate="yes" xml:space="preserve">
          <source>If the VNode is always an HTML element then we can pass its name directly to &lt;code&gt;h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20828a01491d3d176994e014e8243f15e5cec364" translate="yes" xml:space="preserve">
          <source>If the bound value is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; then the attribute will not be included on the rendered element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7303cbac97656642d551545dc4e5cababd70308f" translate="yes" xml:space="preserve">
          <source>If the component is a functional component, the render function also receives an extra argument &lt;code&gt;context&lt;/code&gt;, which provides access to contextual data since functional components are instance-less.</source>
          <target state="translated">구성 요소가 기능적 구성 요소 인 경우, 렌더링 함수는 추가 인수 &lt;code&gt;context&lt;/code&gt; 를 수신하여 기능적 구성 요소가 인스턴스가 없으므로 컨텍스트 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778a0693bfbcff846a92b8e406613e51b0ccd2e7" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &quot;unselected&quot; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e1040d1b4539c4a4df0fdf98d510e6cb4c6439" translate="yes" xml:space="preserve">
          <source>If the initial value of your &lt;code&gt;v-model&lt;/code&gt; expression does not match any of the options, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element will render in an &amp;ldquo;unselected&amp;rdquo; state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 표현식 의 초기 값이 옵션과 일치하지 않으면 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소가 &quot;선택되지 않은&quot;상태로 렌더링됩니다. iOS에서는 iOS가 변경 이벤트를 시작하지 않기 때문에 사용자가 첫 번째 항목을 선택할 수 없습니다. 따라서 위의 예에서와 같이 비활성화 된 옵션에 빈 값을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e40b666fff5068ba41fcb1fb1d0acd4ce7a992d8" translate="yes" xml:space="preserve">
          <source>If the methods &lt;code&gt;toTitleDate&lt;/code&gt; or &lt;code&gt;formatDate&lt;/code&gt; access any reactive data then it will be tracked as a rendering dependency, just as if it had been used in the template directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c148d9a336221fd54485bc5ad61e9a1e229c73a" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a &lt;code&gt;querySelector&lt;/code&gt; and use the selected element's innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be14640de0939678c1a24bad38088404e2ca8c9" translate="yes" xml:space="preserve">
          <source>If the string starts with &lt;code&gt;#&lt;/code&gt; it will be used as a querySelector and use the selected element&amp;rsquo;s innerHTML as the template string. This allows the use of the common &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; trick to include templates.</source>
          <target state="translated">문자열이 &lt;code&gt;#&lt;/code&gt; 으로 시작 하면 querySelector로 사용되고 선택된 요소의 innerHTML을 템플릿 문자열로 사용합니다. 이를 통해 일반적인 &lt;code&gt;&amp;lt;script type=&quot;x-template&quot;&amp;gt;&lt;/code&gt; 트릭을 사용하여 템플릿을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e2a9dfaa380a0de81081767f202693968ef8fc" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="translated">전이 컴포넌트가 &lt;a href=&quot;#JavaScript-Hooks&quot;&gt;JavaScript 후크를&lt;/a&gt; 제공 한 경우 이러한 후크는 적절한 타이밍에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2ecd8a7c716c95da925d56a24dbff68dbe3cb732" translate="yes" xml:space="preserve">
          <source>If the transition component provided &lt;a href=&quot;#javascript-hooks&quot;&gt;JavaScript hooks&lt;/a&gt;, these hooks will be called at appropriate timings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db2c73fe7d859c72406458c11b699f22e3d0c62" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0743f97ca671f5c9ea8b899455cd80afbfe69b8a" translate="yes" xml:space="preserve">
          <source>If the type of the generic is unknown, it's recommended to cast &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b75b60aea9cf846f97bdc9f59bd5b35161f3f" translate="yes" xml:space="preserve">
          <source>If there are no props then the children can usually be passed as the second argument. In cases where that would be ambiguous, &lt;code&gt;null&lt;/code&gt; can be passed as the second argument to keep the children as the third argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bebbf9e60227c2180beccfec6669351ce887915" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly easy&lt;/a&gt;. Here&amp;rsquo;s a &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;complete example&lt;/a&gt; using Page.js.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director&lt;/a&gt; 와 같이 사용하려는 타사 라우터가있는 경우 통합도 &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs&quot;&gt;비슷&lt;/a&gt; 합니다. 다음은 Page.js &lt;a href=&quot;https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs&quot;&gt;를&lt;/a&gt; 사용한 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="4a4deb4463100ef774d066f03629b21cdc02fb26" translate="yes" xml:space="preserve">
          <source>If there's a 3rd-party router you prefer to use, such as &lt;a href=&quot;https://github.com/visionmedia/page.js&quot;&gt;Page.js (opens new window)&lt;/a&gt; or &lt;a href=&quot;https://github.com/flatiron/director&quot;&gt;Director (opens new window)&lt;/a&gt;, integration is &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/compare/master...pagejs&quot;&gt;similarly straightforward (opens new window)&lt;/a&gt;. Here's a &lt;a href=&quot;https://github.com/phanan/vue-3.0-simple-routing-example/tree/pagejs&quot;&gt;complete example (opens new window)&lt;/a&gt; using Page.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c1c9810ed91033d943c8c7395ef1ff554427a5" translate="yes" xml:space="preserve">
          <source>If this component received an &lt;code&gt;id&lt;/code&gt; attribute and a &lt;code&gt;v-on:close&lt;/code&gt; listener, the &lt;code&gt;$attrs&lt;/code&gt; object will now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403bdf723c083d8b2ccede629d30e16d178e61fd" translate="yes" xml:space="preserve">
          <source>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call &lt;code&gt;vm.$mount()&lt;/code&gt; to manually start the compilation.</source>
          <target state="translated">이 옵션을 인스턴스화 할 때 사용할 수있는 경우 인스턴스는 즉시 컴파일에 들어갑니다. 그렇지 않으면 사용자가 컴파일을 수동으로 시작하기 위해 &lt;code&gt;vm.$mount()&lt;/code&gt; 를 명시 적으로 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="31295f224ed5601010e4bf662145dc4776218b9c" translate="yes" xml:space="preserve">
          <source>If using a build step: pass the &lt;code&gt;isCustomElement&lt;/code&gt; option to the Vue template compiler. If using &lt;code&gt;vue-loader&lt;/code&gt;, this should be passed via &lt;code&gt;vue-loader&lt;/code&gt;'s &lt;code&gt;compilerOptions&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a7080e683c7a64c86aa780d504104684e2c8cf" translate="yes" xml:space="preserve">
          <source>If using on-the-fly template compilation, pass it via &lt;code&gt;app.config.isCustomElement&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330f73efd7b8fa6913e10b944928e9083afdfa3e" translate="yes" xml:space="preserve">
          <source>If using string keys or non-typed symbols, the type of the injected value will need to be explicitly declared:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cd39cc6503370abf981fdea53d1f2a726cdba6" translate="yes" xml:space="preserve">
          <source>If we need to resolve a component by name then we can call &lt;code&gt;resolveComponent&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8df13c30163597104a70bd9ea70be42706e226" translate="yes" xml:space="preserve">
          <source>If we need to update the list items, we do so in JavaScript, using the reactivity we mentioned earlier. We then make all the changes to the JavaScript copy, the virtual DOM, and perform a diff between this and the actual DOM. Only then do we make our updates to just what has changed. The Virtual DOM allows us to make performant updates to our UIs!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46541c29071775d267576f2d4f8b07035cf486fe" translate="yes" xml:space="preserve">
          <source>If we update the first value, the sum is not adjusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf205117227a86a1eb58ae18d3718adb780a6c9" translate="yes" xml:space="preserve">
          <source>If we want to add a custom element defined outside of Vue (e.g. using the Web Components API), we need to 'instruct' Vue to treat it as a custom element. Let's use the following template as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fcea7a8afcf7157ecc5757dd89328f51812842" translate="yes" xml:space="preserve">
          <source>If we want to pass the length of todo-items directly to &lt;code&gt;TodoListStatistics&lt;/code&gt;, we would pass the prop down the hierarchy: &lt;code&gt;TodoList&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListFooter&lt;/code&gt; -&amp;gt; &lt;code&gt;TodoListStatistics&lt;/code&gt;. With provide/inject approach, we can do this directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb928534fcb45cb1f88d282a370e12143b6fe8" translate="yes" xml:space="preserve">
          <source>If we wanted to change prop or event names to something different, we would need to add a &lt;code&gt;model&lt;/code&gt; option to &lt;code&gt;ChildComponent&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150e823a3a8131b7c978145134a1ff444cb639e" translate="yes" xml:space="preserve">
          <source>If we were to apply these states to a transition, it would look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498688a211069d7a5c4191f5c3fef214e9f67f92" translate="yes" xml:space="preserve">
          <source>If we're writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2fb212b41d06f075a5186ea4df933d818c54bc" translate="yes" xml:space="preserve">
          <source>If you already have the &lt;code&gt;tag&lt;/code&gt; prop defined in your Vue 2 code, like in the example above, everything will work as before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916a06724e966c52ae5b3afbcb15fb0a47533851" translate="yes" xml:space="preserve">
          <source>If you also want to apply a transition on the initial render of a node, you can add the &lt;code&gt;appear&lt;/code&gt; attribute:</source>
          <target state="translated">노드의 초기 렌더링에 전환을 적용하려는 경우 &lt;code&gt;appear&lt;/code&gt; 속성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ec74309d0b36ccc7bac1396b5fe53120fd641ab" translate="yes" xml:space="preserve">
          <source>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; and &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt;). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar &lt;code&gt;style&lt;/code&gt; tags in &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;.</source>
          <target state="translated">CSS-in-JS의 팬이라면 널리 사용되는 많은 CSS-in-JS 라이브러리는 Vue (예 : &lt;a href=&quot;https://github.com/styled-components/vue-styled-components&quot;&gt;styled-components-vue&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/egoist/vue-emotion&quot;&gt;vue-emotion&lt;/a&gt; )를 지원합니다. 여기서 React와 Vue의 주요 차이점은 Vue의 기본 스타일 지정 방법은 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 에서 더 친숙한 &lt;code&gt;style&lt;/code&gt; 태그를 사용 한다는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="8905225615c521ffb76784bc94d7b858597c4fa8" translate="yes" xml:space="preserve">
          <source>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the &lt;a href=&quot;guide/comparison&quot;&gt;Comparison with Other Frameworks&lt;/a&gt;.</source>
          <target state="translated">숙련 된 프론트 엔드 개발자이고 Vue가 다른 라이브러리 / 프레임 워크와 비교하는 방법을 알고 싶다면 &lt;a href=&quot;guide/comparison&quot;&gt;다른 프레임 워크와 비교를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbcbc82a190068637d910f1c319db9b6e1926788" translate="yes" xml:space="preserve">
          <source>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</source>
          <target state="translated">대규모 프로젝트를 개발 중이거나 다른 개발자와 협력하거나 때로는 타사 HTML / CSS (예 : Auth0)를 포함하는 경우 일관된 범위 지정을 사용하면 스타일이 의도 한 구성 요소에만 스타일을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40ab587db89fe2bdc56b68cb15d14ec1f64b7eb" translate="yes" xml:space="preserve">
          <source>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also &lt;a href=&quot;render-function&quot;&gt;directly write render functions&lt;/a&gt; instead of templates, with optional JSX support.</source>
          <target state="translated">Virtual DOM 개념에 익숙하고 JavaScript의 강력한 기능을 선호하는 경우 선택적 JSX 지원을 통해 템플릿 대신 &lt;a href=&quot;render-function&quot;&gt;렌더링 함수&lt;/a&gt; 를 직접 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e11ad49faa82bff233bacdfdaea43495b37d7cb" translate="yes" xml:space="preserve">
          <source>If you are relying on this override functionality for &lt;code&gt;v-bind&lt;/code&gt;, we currently recommend ensuring that your &lt;code&gt;v-bind&lt;/code&gt; attribute is defined before individual properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f259b9cb4dd6eabd10bd96771a986250a3f5c4" translate="yes" xml:space="preserve">
          <source>If you are using Vue 2.x and below, you may be interested in some of the change detection caveats that exist for those versions, &lt;a href=&quot;change-detection&quot;&gt;explored in more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa108116f2ee5b4db44f6418ab708557dafa0b" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader (opens new window)&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c8aaaa2941143cf085fd81f80dc6fc001828e4" translate="yes" xml:space="preserve">
          <source>If you are using Webpack, and prefer separating JavaScript and template files, you can use &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader&lt;/a&gt;, which also transforms the template files into JavaScript render functions during the build step.</source>
          <target state="translated">Webpack을 사용하고 JavaScript와 템플릿 파일을 분리하는 것을 선호하는 경우 &lt;a href=&quot;https://github.com/ktsn/vue-template-loader&quot;&gt;vue-template-loader를&lt;/a&gt; 사용 하면 빌드 단계에서 템플릿 파일을 JavaScript 렌더링 함수로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b51a0d95775f6901a19eb4a518eb8294d6f3dd90" translate="yes" xml:space="preserve">
          <source>If you are using a custom Webpack configuration &lt;code&gt;ts-loader&lt;/code&gt; needs to be configured to parse &lt;code&gt;&amp;lt;script lang=&quot;ts&quot;&amp;gt;&lt;/code&gt; blocks in &lt;code&gt;.vue&lt;/code&gt; files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9339c27c9dc6e2ed60dd362c87632e60f6c3e6b" translate="yes" xml:space="preserve">
          <source>If you are using filters that were globally registered and then used throughout your app, it's likely not convenient to replace them with computed properties or methods in each individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89858e35b068365a82039534b03f306fb0a1b8c0" translate="yes" xml:space="preserve">
          <source>If you are using native ES Modules, there is also an ES Modules compatible build:</source>
          <target state="translated">기본 ES 모듈을 사용하는 경우 ES 모듈 호환 빌드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f554b9ea3847cd26d76c47af993f74bd496cd6f0" translate="yes" xml:space="preserve">
          <source>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use &lt;code&gt;data.attrs&lt;/code&gt; to pass along any HTML attributes and &lt;code&gt;listeners&lt;/code&gt;&lt;em&gt;(the alias for &lt;code&gt;data.on&lt;/code&gt;)&lt;/em&gt; to pass along any event listeners.</source>
          <target state="translated">템플리트 기반 기능 구성 요소를 사용하는 경우 속성 및 리스너를 수동으로 추가해야합니다. 개별 컨텍스트 컨텐츠에 액세스 할 수 있으므로 &lt;code&gt;data.attrs&lt;/code&gt; 를 사용 하여 HTML 속성 및 &lt;code&gt;listeners&lt;/code&gt; &lt;em&gt;( &lt;code&gt;data.on&lt;/code&gt; 의 별명 )&lt;/em&gt; 를 전달하여 이벤트 리스너를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f0f868039c608a8992e0ecad40e6cc8c9afaa6c" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (&lt;code&gt;vue.min.js&lt;/code&gt;) for production. Both versions can be found in the &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="translated">전체 빌드를 사용하는 경우 (예 : 빌드 도구없이 스크립트 태그를 통해 Vue를 직접 포함하는 경우 ) 프로덕션에 축소 버전 ( &lt;code&gt;vue.min.js&lt;/code&gt; ) 을 사용해야합니다 . 두 버전 모두 &lt;a href=&quot;installation#Direct-lt-script-gt-Include&quot;&gt;설치 안내서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4b189cf522ce6e29c54b33668d5386275afda1" translate="yes" xml:space="preserve">
          <source>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version for production. This can be found in the &lt;a href=&quot;../installation#cdn&quot;&gt;Installation guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b60cd1fba6c46a688fbdbb235e044cb83c5b7b5" translate="yes" xml:space="preserve">
          <source>If you are using third party plugins such as &lt;code&gt;Vuex&lt;/code&gt; or &lt;code&gt;Vue Router&lt;/code&gt;, always check the documentation to know what that particular plugin expects to receive as a second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e4fd881ce2746ee5cbf62bd67517fc2f4914a1" translate="yes" xml:space="preserve">
          <source>If you bundle your app with webpack with &lt;code&gt;target: 'node'&lt;/code&gt; and properly externalize &lt;code&gt;vue&lt;/code&gt;, this is the build that will be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b2fe8b591e825c2bd65db72f8f115e0c3a56502" translate="yes" xml:space="preserve">
          <source>If you didn't have one defined &lt;em&gt;and&lt;/em&gt; your styling or other behaviors relied on the presence of the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; root element to work properly, simply add &lt;code&gt;tag=&quot;span&quot;&lt;/code&gt; to the &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb198153df2b83a6a3a26e2ebd225100fb4f2173" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want a component to automatically inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component's options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b251e43cfeb3150b9ce15a72f34811cb195e1d1" translate="yes" xml:space="preserve">
          <source>If you do &lt;strong&gt;not&lt;/strong&gt; want the root element of a component to inherit attributes, you can set &lt;code&gt;inheritAttrs: false&lt;/code&gt; in the component&amp;rsquo;s options. For example:</source>
          <target state="translated">구성 요소의 루트 요소가 속성을 상속 하지 &lt;strong&gt;않도록&lt;/strong&gt; 하려면 구성 요소 옵션에서 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 를 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83b896d00583e6604507095ce6adcb8923125b4d" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn&amp;rsquo;t exist.</source>
          <target state="translated">data 옵션에서 &lt;code&gt;message&lt;/code&gt; 를 선언하지 않으면 Vue는 렌더링 함수가 존재하지 않는 속성에 액세스하려고한다는 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="16f2472fe4831b78a6cfd9861a2ec950de0ec835" translate="yes" xml:space="preserve">
          <source>If you don't declare &lt;code&gt;message&lt;/code&gt; in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b8f4debe19961ca67a65010685320784bdc244" translate="yes" xml:space="preserve">
          <source>If you find type inference or member completion isn&amp;rsquo;t working, annotating certain methods may help address these problems. Using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option will help find many of these unannotated methods.</source>
          <target state="translated">유형 유추 나 멤버 완성이 작동하지 않는 경우 특정 방법에 주석을 달면 이러한 문제를 해결하는 데 도움이 될 수 있습니다. &lt;code&gt;--noImplicitAny&lt;/code&gt; 옵션을 사용하면 주석이없는 많은 메소드를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c99d9927ea3c8d31465469a680b0264760b24597" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you&amp;rsquo;ve made a mistake somewhere.</source>
          <target state="translated">Vue에서 99.99 %의 사례를 강제로 업데이트해야하는 경우 어딘가에 실수를 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="69e34e7997217094f6f692152e0f58e36b5ef7b7" translate="yes" xml:space="preserve">
          <source>If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere. For example, you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt; property added after component creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a282623f6bdd7b021ecb4c856f00a4975082becf" translate="yes" xml:space="preserve">
          <source>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to &lt;a href=&quot;render-function#Functional-Components&quot;&gt;functional components&lt;/a&gt;. They must be in a plain JS/JSX file (rather than in a &lt;code&gt;.vue&lt;/code&gt; file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</source>
          <target state="translated">앱의 성능에 중요한 부분에서 부분을 사용하는 경우 &lt;a href=&quot;render-function#Functional-Components&quot;&gt;기능적 구성 요소로&lt;/a&gt; 업그레이드해야 합니다 . 파일은 &lt;code&gt;.vue&lt;/code&gt; 파일이 아닌 일반 JS / JSX 파일에 있어야하며 부분과 같이 상태 비 저장 및 인스턴스가 없어야합니다 . 렌더링 속도가 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a40b516039aedc82e1c9170530033902c12726ed" translate="yes" xml:space="preserve">
          <source>If you have a complex type or interface, you can cast it using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions&quot;&gt;type assertion (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6790c4d625e03a0db14e824c77f7252c8ac6b22" translate="yes" xml:space="preserve">
          <source>If you have any questions on how you can get more involved with your local Vue community, reach out at &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt;!</source>
          <target state="translated">지역 Vue 커뮤니티에 더 많이 참여할 수있는 방법에 대한 질문이 있으면 &lt;a href=&quot;https://www.twitter.com/vuejs_events&quot;&gt;@Vuejs_Events&lt;/a&gt; 에 문의하십시오 !</target>
        </trans-unit>
        <trans-unit id="065d3201caaa2141d71da739cdfc7e30446a0749" translate="yes" xml:space="preserve">
          <source>If you have any tests, run them and see what still fails. If you don&amp;rsquo;t have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</source>
          <target state="translated">테스트가있는 경우 테스트를 실행하고 여전히 실패한 것을 확인하십시오. 테스트가없는 경우 브라우저에서 앱을 열고 탐색 할 때 경고 나 오류가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="96e155ed303418e4faa49bd76ee26339a7c63a25" translate="yes" xml:space="preserve">
          <source>If you inspect this element in your chrome developer tools and open the Accessibility tab inside the Elements tab, you will see how the input gets its name from the label:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6b5852b50da5bcf815176a6c34db9a40804fe5" translate="yes" xml:space="preserve">
          <source>If you need multiple aliases, you can also use an array syntax:</source>
          <target state="translated">여러 개의 별칭이 필요한 경우 배열 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86c834af1858680fe5ab3f3504c46895d429410" translate="yes" xml:space="preserve">
          <source>If you need to add new routes after the router has been instantiated, you can replace the router&amp;rsquo;s matcher with a new one that includes the route you&amp;rsquo;d like to add:</source>
          <target state="translated">라우터를 인스턴스화 한 후 새 경로를 추가해야하는 경우 라우터의 일치자를 추가하려는 경로가 포함 된 새 경로로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddaed66412f9035c897a73c53b95d7b75a77f86c" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the &lt;code&gt;template&lt;/code&gt; option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="translated">클라이언트에서 템플릿을 컴파일해야하는 경우 (예 : 문자열을 &lt;code&gt;template&lt;/code&gt; 옵션에 전달하거나 DOM 내부 HTML을 템플릿으로 사용하여 요소에 마운트) 컴파일러와 전체 빌드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ff7acc8749dfed6e4ff7f305eea543f1d2a84302" translate="yes" xml:space="preserve">
          <source>If you need to compile templates on the client (e.g. passing a string to the template option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c99f87095091faefdae01d0f1c8e79606b30cab" translate="yes" xml:space="preserve">
          <source>If you need to destructure your props, you can do this by utilizing the &lt;a href=&quot;reactivity-fundamentals#destructuring-reactive-state&quot;&gt;toRefs&lt;/a&gt; inside of the &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48f8167c0a23ab61df4005f4d4a72ae2eb587c" translate="yes" xml:space="preserve">
          <source>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</source>
          <target state="translated">앱을 시작할 때 프로그래밍 방식으로 경로를 생성해야하는 경우, 동적으로 정의를 경로 배열로 푸시하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c75b905774715058912c0cd6cc8289b46519b9fd" translate="yes" xml:space="preserve">
          <source>If you need to stagger list transitions, you can control timing by setting and accessing a &lt;code&gt;data-index&lt;/code&gt; (or similar attribute) on an element. See &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;an example here&lt;/a&gt;.</source>
          <target state="translated">목록 전환을 스 태거해야하는 경우 요소 에서 &lt;code&gt;data-index&lt;/code&gt; (또는 유사한 속성)을 설정하고 액세스하여 타이밍을 제어 할 수 있습니다 . &lt;a href=&quot;transitions#Staggering-List-Transitions&quot;&gt;예를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f36db052506affc289d8cbab07f304cc42b2cfc" translate="yes" xml:space="preserve">
          <source>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</source>
          <target state="translated">매우 간단한 라우팅 만 필요하고 모든 기능을 갖춘 라우터 라이브러리를 사용하지 않으려면 다음과 같이 페이지 수준 구성 요소를 동적으로 렌더링하면됩니다.</target>
        </trans-unit>
        <trans-unit id="83934613eeb1fab05cbec23a2b6576ef65c9de74" translate="yes" xml:space="preserve">
          <source>If you open up your JavaScript console again and enter &lt;code&gt;app2.message = 'some new message'&lt;/code&gt;, you&amp;rsquo;ll once again see that the bound HTML - in this case the &lt;code&gt;title&lt;/code&gt; attribute - has been updated.</source>
          <target state="translated">JavaScript 콘솔을 다시 열고 &lt;code&gt;app2.message = 'some new message'&lt;/code&gt; 입력 하면 바인딩 된 HTML (이 경우 &lt;code&gt;title&lt;/code&gt; 속성)이 업데이트되었음을 다시 한 번 보게 됩니다.</target>
        </trans-unit>
        <trans-unit id="aee69dbd3a0e9f50e62e6f6016f428f6608cc1d0" translate="yes" xml:space="preserve">
          <source>If you prefer a class-based API when declaring components, you can use the officially maintained &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; decorator:</source>
          <target state="translated">컴포넌트를 선언 할 때 클래스 기반 API를 선호하는 경우 공식적으로 유지 관리되는 &lt;a href=&quot;https://github.com/vuejs/vue-class-component&quot;&gt;vue-class-component&lt;/a&gt; 데코레이터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75403d1bbcd622140e98147df81237f72e89afbb" translate="yes" xml:space="preserve">
          <source>If you prefer something more interactive, you can also check out &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;this tutorial series on Scrimba&lt;/a&gt;, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</source>
          <target state="translated">더 대화 형을 선호하는 경우 &lt;a href=&quot;https://scrimba.com/playlist/pXKqta&quot;&gt;Scrimba에서이 자습서 시리즈를&lt;/a&gt; 확인 하여 언제든지 일시 중지하고 재생할 수있는 스크린 캐스트 및 코드 놀이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="026a80f81fcc351d7fe1000884a4c6e0166e6fc9" translate="yes" xml:space="preserve">
          <source>If you put the number two in the first cell, and the number 3 in the second and asked for the SUM, the spreadsheet would give it to you. No surprises there. But if you update that first number, the SUM automagically updates too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1803a0174123ec0c71857041cc2fd5b41d4ca83" translate="yes" xml:space="preserve">
          <source>If you really need to override another &lt;code&gt;!important&lt;/code&gt;, you must use the string syntax:</source>
          <target state="translated">다른 &lt;code&gt;!important&lt;/code&gt; 를 재정의해야하는 경우 문자열 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b3464a0443a4fd3675c6560f46c9a5c23720d5" translate="yes" xml:space="preserve">
          <source>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</source>
          <target state="translated">동일한 요소 / 구성 요소를 여러 번 복제하려는 경우 팩토리 기능을 사용하면됩니다. 예를 들어, 다음 렌더링 기능은 20 개의 동일한 단락을 렌더링하는 완벽하게 유효한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="82b8fa8fd3b7f04299490484030ca94869913190" translate="yes" xml:space="preserve">
          <source>If you rely on watching array mutations, add the &lt;code&gt;deep&lt;/code&gt; property to ensure that your callback is triggered correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035e11da3a8ba14dbdb2e0af739ac5d197d754c9" translate="yes" xml:space="preserve">
          <source>If you still want to call an unwatch function inside the callback, you should check its availability first:</source>
          <target state="translated">콜백 내에서 감시 해제 기능을 계속 호출하려면 먼저 가용성을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e745791f30101cac58a2b81a7963801c737409a8" translate="yes" xml:space="preserve">
          <source>If you try this in your template however, Vue will show an error, explaining that &lt;strong&gt;every component must have a single root element&lt;/strong&gt;. You can fix this error by wrapping the template in a parent element, such as:</source>
          <target state="translated">그러나 템플릿 에서이 작업을 시도하면 Vue에 &lt;strong&gt;모든 구성 요소에 단일 루트 요소가 있어야&lt;/strong&gt; 한다는 오류가 표시됩니다 . 다음과 같은 부모 요소로 템플릿을 줄임으로써이 오류를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14259c72550c39ee6e4f5a0f4cc02294d8e66215" translate="yes" xml:space="preserve">
          <source>If you use a module bundle like webpack, this may cause Vue&amp;rsquo;s source code to be bundled into the plugin, and more often than not that&amp;rsquo;s not what you'd expect. A common practice to prevent this from happening is to configure the module bundler to exclude Vue from the final bundle. In webpack's case, you can use the &lt;a href=&quot;https://webpack.js.org/configuration/externals/&quot;&gt;&lt;code&gt;externals&lt;/code&gt; (opens new window)&lt;/a&gt; configuration option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867330159a7ddc38fc78ddc898cba459aac34c10" translate="yes" xml:space="preserve">
          <source>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</source>
          <target state="translated">웹 구성 요소와 같은 템플릿에서 Vue가 아닌 사용자 정의 요소를 사용하는 경우 PascalCase는 Vue 구성 요소가 명확하게 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="60f8e15ea64a01da65a785bd3977a29768fe4144" translate="yes" xml:space="preserve">
          <source>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</source>
          <target state="translated">소품을 강제로 사용하려면 대신 소품을 기반으로 로컬 계산 값을 설정하십시오. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="ec0a06cc0af41c0df81514c72a42baf2a7b4e3e2" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;this simple todo app&lt;/a&gt; on CodeSandbox.</source>
          <target state="translated">바로 들어가서 단일 파일 구성 요소로 게임을 시작하려면 CodeSandbox &lt;a href=&quot;https://codesandbox.io/s/o29j95wx9&quot;&gt;에서이 간단한 할 일 앱&lt;/a&gt; 을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="19c4d2e8e9b44f23f256752921c6f56b3515e01e" translate="yes" xml:space="preserve">
          <source>If you want to dive right in and start playing with single-file components, check out &lt;a href=&quot;https://codesandbox.io/s/vue-todo-list-app-with-single-file-component-vzkl3?file=/src/App.vue&quot;&gt;this simple todo app (opens new window)&lt;/a&gt; on CodeSandbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221bedd32adb2426b2b5127135897cde8d509422" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46daea4d2cc73e0262635e93ef739858416c1a90" translate="yes" xml:space="preserve">
          <source>If you want to pass all the properties of an object as props, you can use &lt;code&gt;v-bind&lt;/code&gt; without an argument (&lt;code&gt;v-bind&lt;/code&gt; instead of &lt;code&gt;v-bind:prop-name&lt;/code&gt;). For example, given a &lt;code&gt;post&lt;/code&gt; object:</source>
          <target state="translated">당신이 소품 같은 객체의 속성이 모두 통과 할 경우 사용할 수있는 &lt;code&gt;v-bind&lt;/code&gt; (인수없이 &lt;code&gt;v-bind&lt;/code&gt; 대신 &lt;code&gt;v-bind:prop-name&lt;/code&gt; ). 예를 들어, &lt;code&gt;post&lt;/code&gt; 오브젝트가 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="caa62e4207841b276f4bf69747cc49086ed59533" translate="yes" xml:space="preserve">
          <source>If you want to register a directive locally instead, components also accept a &lt;code&gt;directives&lt;/code&gt; option:</source>
          <target state="translated">지시문을 로컬에 대신 등록하려는 경우 구성 요소는 &lt;code&gt;directives&lt;/code&gt; 옵션 도 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a5c60bce10cae3d5303941aa3e57ed099d7e4435" translate="yes" xml:space="preserve">
          <source>If you want user input to be automatically typecast as a number, you can add the &lt;code&gt;number&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt; managed inputs:</source>
          <target state="translated">사용자 입력을 자동으로 숫자로 타입 캐스트 하려면 &lt;code&gt;v-model&lt;/code&gt; 관리 입력에 &lt;code&gt;number&lt;/code&gt; 수정자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a16d061cc634d4f68b39e327bf7521b345a10fa" translate="yes" xml:space="preserve">
          <source>If you want whitespace from user input to be trimmed automatically, you can add the &lt;code&gt;trim&lt;/code&gt; modifier to your &lt;code&gt;v-model&lt;/code&gt;-managed inputs:</source>
          <target state="translated">사용자 입력의 공백이 자동으로 트리밍되도록하려면 &lt;code&gt;trim&lt;/code&gt; 수정자를 &lt;code&gt;v-model&lt;/code&gt; 관리 입력에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e01c628ccff4f037b351b0e994f9073ee50cc8" translate="yes" xml:space="preserve">
          <source>If you were previously relying on &lt;code&gt;vm.$watch&lt;/code&gt; to do something with the DOM after a component updates, you can instead do so in the &lt;code&gt;updated&lt;/code&gt; lifecycle hook.</source>
          <target state="translated">이전에 구성 요소 업데이트 후 DOM으로 작업을 수행하기 위해 &lt;code&gt;vm.$watch&lt;/code&gt; 에 의존 한 경우 &lt;code&gt;updated&lt;/code&gt; 수명주기 후크 에서 대신 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43daed9c097353737805c1bf2ab9ef52cfa52fb5" translate="yes" xml:space="preserve">
          <source>If you wish to hardware-accelerate an element, you can apply any of these properties (not all are necessary, only one):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ac65f465dd8ab501455462ff8cb0ee50716d0" translate="yes" xml:space="preserve">
          <source>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</source>
          <target state="translated">목록에서 클래스를 조건부로 토글하려면 3 항 표현식으로 클래스를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba4a4286bcc04db765fc3867dbf7ddb1a48e9be" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to learn more about Vue before diving in, we created a video walking through the core principles and a sample project.</source>
          <target state="translated">다이빙하기 전에 Vue에 대해 더 자세히 알고 싶다면 핵심 원칙과 샘플 프로젝트를 안내하는 비디오를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="8bdbab444a3ccfd0f249abc5bdb15834f654b882" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a &lt;strong&gt;Browserify&lt;/strong&gt; user that would like to use async components, its creator has unfortunately &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;made it clear&lt;/a&gt; that async loading &amp;ldquo;is not something that Browserify will ever support.&amp;rdquo; Officially, at least. The Browserify community has found &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;some workarounds&lt;/a&gt;, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</source>
          <target state="translated">비동기 구성 요소를 사용하려는 &lt;strong&gt;Browserify&lt;/strong&gt; 사용자 인 경우 불행히도 작성자는 비동기로드가 &quot;Browserify가 지원하지 않는 것&quot;임을 &lt;a href=&quot;https://github.com/substack/node-browserify/issues/58#issuecomment-21978224&quot;&gt;분명히&lt;/a&gt; 했습니다. 적어도 공식적으로는 Browserify 커뮤니티는 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/620&quot;&gt;몇 가지 해결 방법&lt;/a&gt; 을 찾았 으며 이는 기존의 복잡한 응용 프로그램에 도움이 될 수 있습니다. 다른 모든 시나리오의 경우 내장 된 일류 비동기 지원을 위해 Webpack을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="edcc3ba94bcb1cfdcb2e9c17bd2ce8899e7c55b1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it&amp;rsquo;s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="translated">React에서 오신다면, vuex 가 해당 생태계에서 가장 널리 사용되는 Flux 구현 인 &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux&lt;/a&gt; 와 어떻게 비교되는지 궁금 할 것 입니다. Redux는 실제로 뷰 레이어와 무관하므로 &lt;a href=&quot;https://yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;간단한 바인딩을&lt;/a&gt; 통해 Vue와 함께 쉽게 사용할 수 있습니다 . Vuex는 점에서 차이가 &lt;em&gt;알고&lt;/em&gt; 그것은 뷰 응용 프로그램에 있습니다. 이를 통해 Vue와 더 잘 통합되어보다 직관적 인 API와 개선 된 개발 경험을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac6cff90ff8235cb92a798958233e09ce65f41ef" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not careful, recursive components can also lead to infinite loops:</source>
          <target state="translated">조심하지 않으면 재귀 적 구성 요소가 무한 루프로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31dfe6cb288a0519fc0e0e9ea5786682c1441d3d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; / &lt;code&gt;require&lt;/code&gt; 모듈 시스템을 사용하지 않는 경우 ,이 섹션을 건너 뛸 수 있습니다. 당신이 있다면, 우리는 당신을 위해 몇 가지 특별한 지침과 팁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cd1a70ae99b09e3c3ad5742cdad75a7a51ef4df" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not yet familiar with Vue&amp;rsquo;s components, you can skip this for now.</source>
          <target state="translated">아직 Vue의 구성 요소에 익숙하지 않다면 지금은 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc717a96a6a10a9a99af5efe59b5bba0e6a070d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re still here, then it&amp;rsquo;s likely you&amp;rsquo;re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="translated">여전히 여기 있다면 Babel 및 Webpack과 같은 모듈 시스템을 사용하고있을 가능성이 있습니다. 이 경우 각 구성 요소를 자체 파일에 포함하여 구성 &lt;code&gt;components&lt;/code&gt; 디렉토리를 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea196c4500fb63b55d56b5fae7f497c03397f1ba" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing a lot of &lt;code&gt;render&lt;/code&gt; functions, it might feel painful to write something like this:</source>
          <target state="translated">많은 &lt;code&gt;render&lt;/code&gt; 함수를 작성하는 경우 다음과 같이 작성하는 것이 고통 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609a6f861acf12bf2b5f3b2a6f3ec765be8efafd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve ever had to manually manipulate DOM in Vue, you might have come across this pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ecc2bc675d03a98476e9bf350d5918a55d45a0" translate="yes" xml:space="preserve">
          <source>If you're coming from React, you may be wondering how vuex compares to &lt;a href=&quot;https://github.com/reactjs/redux&quot;&gt;redux (opens new window)&lt;/a&gt;, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via &lt;a href=&quot;https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;amp;p=1&quot;&gt;simple bindings (opens new window)&lt;/a&gt;. Vuex is different in that it &lt;em&gt;knows&lt;/em&gt; it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4383a33376cb43b8f9f3a34ad4ebc3a22a32fdbb" translate="yes" xml:space="preserve">
          <source>If you're not using a module system with &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d391b26209861300899a2add1af08ef09f4194f8" translate="yes" xml:space="preserve">
          <source>If you're not yet familiar with Vue's components, you can skip this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913e0a49efe5be77ae2656044ce4cc773b612ae8" translate="yes" xml:space="preserve">
          <source>If you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a &lt;code&gt;components&lt;/code&gt; directory, with each component in its own file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f123dacf3d9e21f599eddd3ec553d8bc240c00ee" translate="yes" xml:space="preserve">
          <source>If you're using a &lt;a href=&quot;../installation#cdn&quot;&gt;CDN&lt;/a&gt; build of Vue then &lt;code&gt;createApp&lt;/code&gt; is exposed via the global &lt;code&gt;Vue&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256d7614924d2b75c2300fd933e837e95c0b7657" translate="yes" xml:space="preserve">
          <source>If your component has multiple root elements, you would need to define which component will receive this class. You can do this using &lt;code&gt;$attrs&lt;/code&gt; component property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e55f976e59b49199d2ea7af9a5149f956c1e601" translate="yes" xml:space="preserve">
          <source>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</source>
          <target state="translated">지시문에 여러 값이 필요한 경우 JavaScript 객체 리터럴을 전달할 수도 있습니다. 지시문은 유효한 JavaScript 식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242aaacd829f9f99856dd2793dfdfc9507666410" translate="yes" xml:space="preserve">
          <source>If your module bundler of choice happens to be &lt;a href=&quot;https://rollupjs.org/&quot;&gt;Rollup (opens new window)&lt;/a&gt;, you basically get the same effect for free, as by default Rollup will treat absolute module IDs (&lt;code&gt;'vue'&lt;/code&gt; in our case) as external dependencies and not include them in the final bundle. During bundling though, it might emit a &lt;a href=&quot;https://rollupjs.org/guide/en/#warning-treating-module-as-external-dependency&quot;&gt;&amp;ldquo;Treating vue as external dependency&amp;rdquo; (opens new window)&lt;/a&gt; warning, which can be suppressed with the &lt;code&gt;external&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a721aa3beb5717086550f15e05596fdcd9ca355" translate="yes" xml:space="preserve">
          <source>If your plugin relies on an affected Vue 2.x global API, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8119918563dea634ba032ddd3981c094251dbb90" translate="yes" xml:space="preserve">
          <source>Imagine the case where we have a standalone primitive value (for example, a string) and we want to make it reactive. Of course, we could make an object with a single property equal to our string, and pass it to &lt;code&gt;reactive&lt;/code&gt;. Vue has a method that will do the same for us - it's a &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40dacaf019bddc14aed2d0fa2773dee73842cf" translate="yes" xml:space="preserve">
          <source>Imagine this is the template for &lt;code&gt;bootstrap-date-input&lt;/code&gt;:</source>
          <target state="translated">이것이 &lt;code&gt;bootstrap-date-input&lt;/code&gt; 의 템플릿이라고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a9cca298c2ad31236d51c99a03c78bea9e1757" translate="yes" xml:space="preserve">
          <source>Implementation-wise &lt;code&gt;defineComponent&lt;/code&gt; does nothing but return the object passed to it. However, in terms of typing, the returned value has a synthetic type of a constructor for manual render function, TSX and IDE tooling support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224c21757ea8bf64841521a52786c7584cd3070c" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication</source>
          <target state="translated">암시 적 부모-자식 의사 소통</target>
        </trans-unit>
        <trans-unit id="55330d37bd375d0971edbec4ed65271fd1ecea19" translate="yes" xml:space="preserve">
          <source>Implicit parent-child communication &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;주의해서&lt;/sup&gt; 암시적인 부모-자식 의사 소통 &lt;sup&gt;사용&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="28826b0d2e02701105ec50963d8f7e90554a6576" translate="yes" xml:space="preserve">
          <source>Import it as a &lt;a href=&quot;#cdn&quot;&gt;CDN package&lt;/a&gt; on the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9992581d590be676f25bb4ed76a8393ef92057e" translate="yes" xml:space="preserve">
          <source>Imported dependencies are also esm-bundler builds and will in turn import their dependencies (e.g. @vue/runtime-core imports @vue/reactivity)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="836e63c09fd6ddabcf1825ec759e9e296d10a1ec" translate="yes" xml:space="preserve">
          <source>Imports dependencies (e.g. &lt;code&gt;@vue/runtime-core&lt;/code&gt;, &lt;code&gt;@vue/runtime-compiler&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5200b178a45fe7d68a514c32e5d600863251de0" translate="yes" xml:space="preserve">
          <source>In 2.2 we introduced the &lt;code&gt;model&lt;/code&gt; component option that allows the component to customize the prop and event to use for &lt;code&gt;v-model&lt;/code&gt;. However, this still only allowed a single &lt;code&gt;v-model&lt;/code&gt; to be used on the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff0737239eca41b60241cc75c9ed0aa10e7cf12" translate="yes" xml:space="preserve">
          <source>In 2.2.0+ and above, &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; will fire for all nested components inside a &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; tree.</source>
          <target state="translated">2.2.0+ 이상에서 &lt;code&gt;activated&lt;/code&gt; 및 &lt;code&gt;deactivated&lt;/code&gt; 는 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 트리 내부의 모든 중첩 구성 요소에 대해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b549760aeed2ab9d1d4db1c8e2a9ad9c0ecadc86" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is &lt;code&gt;undefined&lt;/code&gt;, captured errors will be logged with &lt;code&gt;console.error&lt;/code&gt; instead of crashing the app.</source>
          <target state="translated">2.2.0+에서이 후크는 구성 요소 수명주기 후크의 오류도 캡처합니다. 또한이 후크가 &lt;code&gt;undefined&lt;/code&gt; 않으면 캡처 된 오류가 앱 을 &lt;code&gt;console.error&lt;/code&gt; 대신 console.error 와 함께 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="999b4c5d77cbbc3bee12f8c040b08340523086be" translate="yes" xml:space="preserve">
          <source>In 2.2.0+, when using &lt;code&gt;v-for&lt;/code&gt; with a component, a &lt;a href=&quot;list#key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt; is now required.</source>
          <target state="translated">2.2.0 이상에서는 구성 요소와 함께 &lt;code&gt;v-for&lt;/code&gt; 를 사용할 때 &lt;a href=&quot;list#key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ecaafff83b9fcb93b3e419ce8a4773d634c3148b" translate="yes" xml:space="preserve">
          <source>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</source>
          <target state="translated">2.4.0 이상에서이 후크는 Vue 사용자 정의 이벤트 핸들러에 발생한 오류를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="edef70fc2b7c008af4bf42ee31332936b525d0f1" translate="yes" xml:space="preserve">
          <source>In 2.5.0+ injections can be optional with default value:</source>
          <target state="translated">2.5.0 이상에서 주입은 기본값으로 선택적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8a8ed5d2d9e4a1e1eed10aaf95fe05167d5fd5" translate="yes" xml:space="preserve">
          <source>In 2.5.0+, if you are using &lt;a href=&quot;single-file-components&quot;&gt;single-file components&lt;/a&gt;, template-based functional components can be declared with:</source>
          <target state="translated">2.5.0 이상에서 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소를&lt;/a&gt; 사용하는 경우 다음을 사용하여 템플릿 기반 기능 구성 요소를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98c67c0761e7da9c00c57d35a0738163cb924a2e" translate="yes" xml:space="preserve">
          <source>In 2.6+, &lt;code&gt;v-for&lt;/code&gt; can also work on values that implement the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt;, including native &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;. However, it should be noted that Vue 2.x currently does not support reactivity on &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; values, so cannot automatically detect changes.</source>
          <target state="translated">2.6 이상에서 &lt;code&gt;v-for&lt;/code&gt; 는 기본 &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 등 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol&quot;&gt;Iterable Protocol&lt;/a&gt; 을 구현하는 값에 대해서도 작업 할 수 있습니다 . 그러나 Vue 2.x는 현재 &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 값 에 대한 반응성을 지원하지 않으므로 변경 사항을 자동으로 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5553d76d7cbc80714e9fa7174eeef5474643a592" translate="yes" xml:space="preserve">
          <source>In 2.6.0+, this hook also captures errors thrown inside &lt;code&gt;v-on&lt;/code&gt; DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</source>
          <target state="translated">2.6.0 이상에서이 후크는 &lt;code&gt;v-on&lt;/code&gt; DOM 리스너 에서 발생한 오류를 캡처합니다 . 또한 해당 후크 또는 처리기 중 하나가 Promise 체인 (예 : 비동기 함수)을 반환하면 해당 Promise 체인의 오류도 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5b65e8c99e14e1d3d5fad411cf67fa65a409639e" translate="yes" xml:space="preserve">
          <source>In 2.6.0, we introduced a new unified syntax (the &lt;code&gt;v-slot&lt;/code&gt; directive) for named and scoped slots. It replaces the &lt;code&gt;slot&lt;/code&gt; and &lt;code&gt;slot-scope&lt;/code&gt; attributes, which are now deprecated, but have &lt;em&gt;not&lt;/em&gt; been removed and are still documented &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;here&lt;/a&gt;. The rationale for introducing the new syntax is described in this &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">2.6.0에서는 명명 된 슬롯과 범위가 지정된 슬롯에 대한 새로운 통합 구문 ( &lt;code&gt;v-slot&lt;/code&gt; 지시문)이 도입되었습니다. 현재 사용되지 않지만 제거 &lt;em&gt;되지 않았&lt;/em&gt; 으며 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;여기에&lt;/a&gt; 문서화되어 있는 &lt;code&gt;slot&lt;/code&gt; 및 &lt;code&gt;slot-scope&lt;/code&gt; 속성을 대체합니다 . 새로운 구문을 소개하는 근거는이 &lt;a href=&quot;https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md&quot;&gt;RFC에&lt;/a&gt; 설명되어 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="256728aff9fb16c0f4d2df842f2c3e5ad55c5e9b" translate="yes" xml:space="preserve">
          <source>In 2.x, &lt;code&gt;domProps&lt;/code&gt; contained a nested list within the VNode props:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ccc8617c6c0b63bdc2bf15b8a89fb2407da706" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue instance could be used to trigger handlers attached imperatively via the event emitter API (&lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt;). This was used to create &lt;em&gt;event hubs&lt;/em&gt; to create global event listeners used across the whole application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dd1fdaef79b3831922864fd8d39f0ad9deb676" translate="yes" xml:space="preserve">
          <source>In 2.x, Vue provided the &lt;code&gt;inline-template&lt;/code&gt; attribute on child components to use its inner content as its template instead of treating it as distributed content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2328f43db77fe0efd8f47e998984f47eac46ba" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could access direct child components of the current instance with &lt;code&gt;this.$children&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec9424ae231a6fda6ed873b7a8e6ae8e39088d9d" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could define the &lt;code&gt;data&lt;/code&gt; option with either an &lt;code&gt;object&lt;/code&gt; or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41dd71f6a7a373cd112dab134b7ff3db3d648f20" translate="yes" xml:space="preserve">
          <source>In 2.x, developers could use filters in order to apply common text formatting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7063d13de2f5ae058926813bdf953c4a105676c" translate="yes" xml:space="preserve">
          <source>In 2.x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the individual property would always overwrite bindings in the &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea559fa1a9771817cc8e8333085080656e09848" translate="yes" xml:space="preserve">
          <source>In 2.x, invalid values were coerced to &lt;code&gt;'true'&lt;/code&gt; for enumerated attributes. This was usually unintended and unlikely to be relied upon on a large scale. In 3.x &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;'true'&lt;/code&gt; should be explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69daab13ee1934deef652bdaaf6f2e3de088df88" translate="yes" xml:space="preserve">
          <source>In 2.x, multi-root components were not supported and would emit a warning when a user accidentally created one. As a result, many components are wrapped in a single &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in order to fix this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd9ee258c65347ba2ff8b78a2b85cee0fc8e414" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function automatically received arguments such as &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d01321951def977b78828f17cb248ccea9ad7" translate="yes" xml:space="preserve">
          <source>In 2.x, the &lt;code&gt;render&lt;/code&gt; function would automatically receive the &lt;code&gt;h&lt;/code&gt; function (which is a conventional alias for &lt;code&gt;createElement&lt;/code&gt;) as an argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9729a27f715ad913ceb2a7d973c83313e4f3c50f" translate="yes" xml:space="preserve">
          <source>In 2.x, using a &lt;code&gt;v-model&lt;/code&gt; on a component was an equivalent of passing a &lt;code&gt;value&lt;/code&gt; prop and emitting an &lt;code&gt;input&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46afcbced92e335f7123d55a58b836b7295afd1d" translate="yes" xml:space="preserve">
          <source>In 2.x, we had the following strategies for coercing &lt;code&gt;v-bind&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5a25ed12428fc14990ccb2e9c191fa49adb981" translate="yes" xml:space="preserve">
          <source>In 2.x, when a component has been registered, the render function would work well when passing the component's name as a string to the first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe8f6026316d3a73f1bd42ee8c89d43dee6ad5b" translate="yes" xml:space="preserve">
          <source>In 2.x, when using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; on the same element, &lt;code&gt;v-for&lt;/code&gt; would take precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2fe7a68d07b5928c0025bf237e90e00d49b1ff" translate="yes" xml:space="preserve">
          <source>In 3.0, the result will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d272f52a84ee8fe9eda14c5af6c7e7e9aea55cf" translate="yes" xml:space="preserve">
          <source>In 3.0, we are limiting Vue's special treatment of the &lt;code&gt;is&lt;/code&gt; prop to the &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03706ae0b18cf04d0e1184566cc22dd43bd8796" translate="yes" xml:space="preserve">
          <source>In 3.x &lt;code&gt;v-model&lt;/code&gt; on the custom component is an equivalent of passing a &lt;code&gt;modelValue&lt;/code&gt; prop and emitting an &lt;code&gt;update:modelValue&lt;/code&gt; event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaffa537c62e5c878c892ad624027bd74bf34114" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;h&lt;/code&gt; is now globally imported instead of being automatically passed as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cbfb34fe6f9b877113b6bdc0dd73e927141d87" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; should be used to explicitly remove an attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bef6847fad523068826498b632dcae11c29c52" translate="yes" xml:space="preserve">
          <source>In 3.x, &lt;code&gt;v-if&lt;/code&gt; will always have the higher precedence than &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c1b7ac08bfa5b7cc8606dcd35f2331e4abc8e3" translate="yes" xml:space="preserve">
          <source>In 3.x, components now can have multiple root nodes! However, this does require developers to explicitly define where attributes should be distributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af3acd686b51e5d6705eac439e47596866c1ce8" translate="yes" xml:space="preserve">
          <source>In 3.x, filters are removed and no longer supported. Instead, we recommend replacing them with method calls or computed properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53eba82a86ea2e9f0b2f6f6cfedb74733b2d04f" translate="yes" xml:space="preserve">
          <source>In 3.x, since the &lt;code&gt;render&lt;/code&gt; function no longer receives any arguments, it will primarily be used inside of the &lt;code&gt;setup()&lt;/code&gt; function. This has the added benefit of gaining access to reactive state and functions declared in scope, as well as the arguments passed to &lt;code&gt;setup()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46410326ff00ce7f5b9a576648a6b047f922589a" translate="yes" xml:space="preserve">
          <source>In 3.x, slots are defined as children of the current node as an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a39c3c93b98afd50fbd7886344976a75f0114a1" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;$children&lt;/code&gt; property is removed and no longer supported. Instead, if you need to access a child component instance, we recommend using &lt;a href=&quot;../component-template-refs#template-refs&quot;&gt;$refs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4eb8d2b66bb84443ed0a747129452a3b8f78766" translate="yes" xml:space="preserve">
          <source>In 3.x, the &lt;code&gt;data&lt;/code&gt; option has been standardized to only accept a &lt;code&gt;function&lt;/code&gt; that returns an &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0577d8ad30ab5a25ec81d48069dddfe6636d8797" translate="yes" xml:space="preserve">
          <source>In 3.x, the entire VNode props structure is flattened. Using the example from above, here is what it would look like now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c698a95795682a639eda0b4dab592ffcd0ccbfd" translate="yes" xml:space="preserve">
          <source>In 3.x, the performance difference between stateful and functional components has been drastically reduced and will be insignificant in most use cases. As a result, the migration path for developers using &lt;code&gt;functional&lt;/code&gt; on SFCs is to remove the attribute and rename all references of &lt;code&gt;props&lt;/code&gt; to &lt;code&gt;$props&lt;/code&gt; and &lt;code&gt;attrs&lt;/code&gt; to &lt;code&gt;$attrs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b6c70c99847e99bd40a423d7f7e30f14d0d1e" translate="yes" xml:space="preserve">
          <source>In 3.x, with VNodes being context-free, we can no longer use a string ID to implicitly lookup registered components. Instead, we need to use an imported &lt;code&gt;resolveComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1649eb8974b30107ef48d872705e3f78ccfacc0f" translate="yes" xml:space="preserve">
          <source>In 3x, if an element has both &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; and an identical individual property defined, the order of how the bindings are declared determines how they are merged. In other words, rather than assuming developers want the individual property to always override what is defined in the &lt;code&gt;object&lt;/code&gt;, developers now have more control over the desired merging behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feb4596eedd196dbf2408c8aca99b22823b66c2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue's template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efb26c55b50e56d58b23c52bfa3f35fba3a9ae3" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;, &lt;code&gt;scoped&lt;/code&gt; styles will not apply to content inside &lt;code&gt;v-html&lt;/code&gt;, because that HTML is not processed by Vue&amp;rsquo;s template compiler. If you want to target &lt;code&gt;v-html&lt;/code&gt; content with scoped CSS, you can instead use &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt; or an additional, global &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element with a manual scoping strategy such as BEM.</source>
          <target state="translated">에서 &lt;a href=&quot;../guide/single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; , &lt;code&gt;scoped&lt;/code&gt; 스타일 컨텐츠 내부에 적용되지 않습니다 &lt;code&gt;v-html&lt;/code&gt; 이 HTML이 뷰의 템플릿 컴파일러에 의해 처리되지 않기 때문에. 범위가 지정된 CSS로 &lt;code&gt;v-html&lt;/code&gt; 컨텐츠 를 대상으로 하려면 대신 BEM과 같은 수동 범위 지정 전략과 함께 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; 또는 추가 전역 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8d376f7dee4247b96adc0876ef4edbaf45e20c" translate="yes" xml:space="preserve">
          <source>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</source>
          <target state="translated">JavaScript에서 PascalCase는 클래스 및 프로토 타입 생성자, 기본적으로 고유 한 인스턴스를 가질 수있는 모든 규칙입니다. Vue 구성 요소에도 인스턴스가 있으므로 PascalCase도 사용하는 것이 좋습니다. 또한 JSX (및 템플릿)에서 PascalCase를 사용하면 코드를 읽는 사람이 구성 요소와 HTML 요소를보다 쉽게 ​​구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6aff66522249011aa1aa6c3f9299f8a6a28ad8" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it&amp;rsquo;s much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="translated">JavaScript에서는 여러 줄에 걸쳐 여러 속성을 가진 객체를 분할하는 것이 읽기 쉬운 규칙이기 때문에 좋은 규칙으로 널리 알려져 있습니다. 우리 템플릿과 &lt;a href=&quot;../guide/render-function#JSX&quot;&gt;JSX도&lt;/a&gt; 같은 고려 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="c13d73a2ddf37e7463ec10f8ded7afc62e432e0e" translate="yes" xml:space="preserve">
          <source>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and &lt;a href=&quot;../guide/render-function#jsx&quot;&gt;JSX&lt;/a&gt; deserve the same consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1511320f9fca1ecdb726d3628235620054c333a" translate="yes" xml:space="preserve">
          <source>In Object-based syntax, the value of each property can either be &lt;code&gt;null&lt;/code&gt; or a validator function. The validation function will receive the additional arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call. For example, if &lt;code&gt;this.$emit('foo', 1)&lt;/code&gt; is called, the corresponding validator for &lt;code&gt;foo&lt;/code&gt; will receive the argument &lt;code&gt;1&lt;/code&gt;. The validator function should return a boolean to indicate whether the event arguments are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2913db7ffdacc418eed127754b210542e820db" translate="yes" xml:space="preserve">
          <source>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</source>
          <target state="translated">Polymer에서 팀은 성능을 보상하기 위해 데이터 바인딩 시스템을 매우 제한적으로 만들었습니다. 예를 들어, Polymer 템플리트에서 지원되는 유일한 표현식은 부울 부정 및 단일 메소드 호출입니다. 계산 된 속성 구현도 매우 유연하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b180ff4b776b13afecd7e06c14be26a036f40513" translate="yes" xml:space="preserve">
          <source>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</source>
          <target state="translated">React에서 모든 컴포넌트는 JavaScript 내에서 작동하는 선언적인 XML 유사 구문 인 JSX를 사용하여 렌더링 함수 내에서 UI를 표현합니다.</target>
        </trans-unit>
        <trans-unit id="0c74e086bdc4e1b0963bd8e65da5a6cf41a27ae4" translate="yes" xml:space="preserve">
          <source>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</source>
          <target state="translated">React에서 모든 것은 JavaScript 일뿐입니다. JSX를 통해 HTML 구조가 표현 될뿐만 아니라 최근 트렌드는 CSS 관리를 JavaScript 내부에도 적용하는 경향이 있습니다. 이 접근 방식에는 고유 한 이점이 있지만 모든 개발자에게 가치가없는 것처럼 보이는 다양한 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01224b36d0e229721ad0a27e329111636e12ad4" translate="yes" xml:space="preserve">
          <source>In React, when a component&amp;rsquo;s state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use &lt;code&gt;PureComponent&lt;/code&gt; or implement &lt;code&gt;shouldComponentUpdate&lt;/code&gt; whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; assumes the entire sub tree&amp;rsquo;s render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</source>
          <target state="translated">React에서 구성 요소의 상태가 변경되면 해당 구성 요소에서 루트로 시작하여 전체 구성 요소 서브 트리의 다시 렌더링을 트리거합니다. 하위 컴포넌트를 불필요하게 다시 렌더링하지 않으려면 가능하면 &lt;code&gt;PureComponent&lt;/code&gt; 를 사용 하거나 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 구현 해야합니다 . 상태 변경을보다 최적화하기 위해 변경 불가능한 데이터 구조를 사용해야 할 수도 있습니다. 그러나 &lt;code&gt;PureComponent/shouldComponentUpdate&lt;/code&gt; 는 전체 서브 트리의 렌더 출력이 현재 컴포넌트의 prop에 의해 결정된다고 가정 하기 때문에 어떤 경우에는 그러한 최적화에 의존하지 않을 수 있습니다 . 그렇지 않은 경우 이러한 최적화로 인해 DOM 상태가 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cfb65095765445c51ed3990754a7aea8c4e09af" translate="yes" xml:space="preserve">
          <source>In Vue 2 we recommended working around with these restrictions by using the &lt;code&gt;is&lt;/code&gt; prop on a native tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d17b0d924f04ce8ace3de17c7feceb2d55c631" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt;, like other custom components, needed a root element, which by default was a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; but was customizable via the &lt;code&gt;tag&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eee5e53bb1e22d2f1df0e9f8eff653441f88183" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;Vue.prototype&lt;/code&gt; was commonly used to add properties that would be accessible in all components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623539054d5afbfeafa88a7593570669aa7a26b8" translate="yes" xml:space="preserve">
          <source>In Vue 2, &lt;code&gt;keyCodes&lt;/code&gt; were supported as a way to modify a &lt;code&gt;v-on&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="714deb450dd9f768ce9fb1850ea76c03a9c0b8ff" translate="yes" xml:space="preserve">
          <source>In Vue 2, custom directives were created by using the hooks listed below to target an element&amp;rsquo;s lifecycle, all of which are optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427f3cc45180bf04421bacb75902b51bf88d889a" translate="yes" xml:space="preserve">
          <source>In Vue 2, functional components had two primary use cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4027dc7058f32b3afa9b989de298f0e1274c6387" translate="yes" xml:space="preserve">
          <source>In Vue 2, mixins were the primary tool to abstract parts of component logic into reusable chunks. However, they have a few issues:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49b054972b109d8d92e090576574f314196d960" translate="yes" xml:space="preserve">
          <source>In Vue 2, the component instance had to be accessed through the &lt;code&gt;vnode&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71cf60ceefe843452e7ace61c7f5d7fb5a10e2c5" translate="yes" xml:space="preserve">
          <source>In Vue 2, using the &lt;code&gt;ref&lt;/code&gt; attribute inside &lt;code&gt;v-for&lt;/code&gt; will populate the corresponding &lt;code&gt;$refs&lt;/code&gt; property with an array of refs. This behavior becomes ambiguous and inefficient when there are nested &lt;code&gt;v-for&lt;/code&gt;s present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a36b69d1b9520442812684a11396300f78b7ba" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can access attributes passed to your components with &lt;code&gt;this.$attrs&lt;/code&gt;, and event listeners with &lt;code&gt;this.$listeners&lt;/code&gt;. In combination with &lt;code&gt;inheritAttrs: false&lt;/code&gt;, they allow the developer to apply these attributes and listeners to some other element instead of the root element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d3795b44e395241dad3f754562828449a79603" translate="yes" xml:space="preserve">
          <source>In Vue 2, you can define the props that a component receives, but you can't declare which events it can emit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850444a28d2f3a6b68ecd836b4765b12b999a6f4" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, &lt;code&gt;Vue.observable&lt;/code&gt; directly mutates the object passed to it, so that it is equivalent to the object returned, as &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;demonstrated here&lt;/a&gt;. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by &lt;code&gt;Vue.observable&lt;/code&gt;, rather than the object originally passed to it.</source>
          <target state="translated">Vue 2.x에서 &lt;code&gt;Vue.observable&lt;/code&gt; 은 전달 된 객체를 직접 변경하여 &lt;a href=&quot;../guide/instance#Data-and-Methods&quot;&gt;여기&lt;/a&gt; 에 표시된대로 반환 된 객체와 동일합니다 . Vue 3.x에서는 리 액티브 프록시가 대신 반환되어 직접 변경되면 원래 오브젝트는 리 액티브하지 않습니다. 따라서 향후 호환성을 위해 원래 전달 된 객체가 아니라 &lt;code&gt;Vue.observable&lt;/code&gt; 에서 반환 한 객체를 항상 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="04a1b8d86ca382e0241c1abe50e3ee3fb8996f94" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag could not have a &lt;code&gt;key&lt;/code&gt;. Instead, you could place the &lt;code&gt;key&lt;/code&gt;s on each of its children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cb196394bb87ca2a8e06b2510d6358e84a7776" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, application root container's &lt;code&gt;outerHTML&lt;/code&gt; is replaced with root component template (or eventually compiled to a template, if root component has no template/render option). Vue 3.x now uses application container's &lt;code&gt;innerHTML&lt;/code&gt; instead - this means the container itself is no longer considered part of the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ecd8d4cc17aab927b205f633e4d33dda883445" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, it was recommended to use &lt;code&gt;key&lt;/code&gt;s on &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt; branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d36ea70a8bf1cfdc715d58ac1911e3fd754fa1" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, the resulting &lt;code&gt;$data&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61abdd8d6816689fd4d5efd6b7f0f6d0421fa89e" translate="yes" xml:space="preserve">
          <source>In Vue 2.x, whitelisting tags as custom elements was done via &lt;code&gt;Vue.config.ignoredElements&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a2d802b261d3390a36b39b1e88da6952ae1bfe" translate="yes" xml:space="preserve">
          <source>In Vue 3's virtual DOM, event listeners are now just attributes, prefixed with &lt;code&gt;on&lt;/code&gt;, and as such are part of the &lt;code&gt;$attrs&lt;/code&gt; object, so &lt;code&gt;$listeners&lt;/code&gt; has been removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8ffd46210564bab462dab866e0a61658c85fd" translate="yes" xml:space="preserve">
          <source>In Vue 3, APIs that globally mutate Vue's behavior are now moved to application instances created by the new &lt;code&gt;createApp&lt;/code&gt; method. In addition, their effects are now scoped to that specific application's instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724f98bfd4825d659b3ef73bec24c9d1b1bd8450" translate="yes" xml:space="preserve">
          <source>In Vue 3, components now have official support for multi-root node components, i.e., fragments!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3d29f7ef97ea630c136e861259ef7779f3f469" translate="yes" xml:space="preserve">
          <source>In Vue 3, however, we&amp;rsquo;ve created a more cohesive API for custom directives. As you can see, they differ greatly from our component lifecycle methods even though we&amp;rsquo;re hooking into similar events. We&amp;rsquo;ve now unified them like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6331f262fcf12a91763745c6aeed71d9b733b3c" translate="yes" xml:space="preserve">
          <source>In Vue 3, such usage will no longer automatically create an array in &lt;code&gt;$refs&lt;/code&gt;. To retrieve multiple refs from a single binding, bind &lt;code&gt;ref&lt;/code&gt; to a function which provides more flexibility (this is a new feature):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ecfbda9c9364a4d1cfde77270eb84b68591725" translate="yes" xml:space="preserve">
          <source>In Vue 3, the check of whether an element is a component or not has been moved to the template compilation phase, therefore this config option is only respected when using the runtime compiler. If you are using the runtime-only build, &lt;code&gt;isCustomElement&lt;/code&gt; must be passed to &lt;code&gt;@vue/compiler-dom&lt;/code&gt; in the build setup instead - for example, via the &lt;a href=&quot;https://vue-loader.vuejs.org/options.html#compileroptions&quot;&gt;&lt;code&gt;compilerOptions&lt;/code&gt; option in vue-loader (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b845930e81b44f047a329d5c6204f7f931bd74" translate="yes" xml:space="preserve">
          <source>In Vue 3, the global and internal APIs have been restructured with tree-shaking support in mind. As a result, the global APIs can now only be accessed as named exports for the ES Modules build. For example, our previous snippets should now look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24e9367bc712cd5e99e214445d49ec8f87dc977" translate="yes" xml:space="preserve">
          <source>In Vue 3, the instance is now part of the &lt;code&gt;binding&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73645e0f3791358bf3f0d6ad20122b90a31ffd47" translate="yes" xml:space="preserve">
          <source>In Vue 3, we have &lt;a href=&quot;fragments&quot;&gt;fragment support&lt;/a&gt;, so components no longer &lt;em&gt;need&lt;/em&gt; a root node. Consequently, &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; no longer renders one by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7bdcdf994f4cc1a00dd74f8f22ad2f859a405b" translate="yes" xml:space="preserve">
          <source>In Vue 3, you&amp;rsquo;ll have to import it explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2bc8b0bef1be017e069553012e806d6ad3eeb6" translate="yes" xml:space="preserve">
          <source>In Vue 3.0 we can make any variable reactive anywhere with a new &lt;code&gt;ref&lt;/code&gt; function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1261249a8779a24fb5636b8856b66bfb7e4d50aa" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &quot;use production build&quot; tip will only show up when using the &quot;dev + full build&quot; (the build that includes the runtime compiler and has warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9927c60d35977a34e50e99413e889e84532170" translate="yes" xml:space="preserve">
          <source>In Vue 3.x, the &lt;code&gt;key&lt;/code&gt; should be placed on the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed32cf518158ed818bb81f6b262961d6f11529c" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</source>
          <target state="translated">Vue에서 구성 요소는 기본적으로 사전 정의 된 옵션이있는 Vue 인스턴스입니다. Vue에 컴포넌트를 등록하는 것은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="9c55128700791de0665f1315237d38efdb9e6612" translate="yes" xml:space="preserve">
          <source>In Vue, a component is essentially an instance with pre-defined options. Registering a component in Vue is straightforward: we create a component object as we did with &lt;code&gt;App&lt;/code&gt; objects and we define it in parent's &lt;code&gt;components&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640123531948ef3b9eb7980eb088b64ca536081b" translate="yes" xml:space="preserve">
          <source>In Vue, a component&amp;rsquo;s dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have &lt;code&gt;shouldComponentUpdate&lt;/code&gt; automatically implemented for you, without the nested component caveats.</source>
          <target state="translated">Vue에서는 렌더링 중에 구성 요소의 종속성이 자동으로 추적되므로 시스템은 상태가 변경 될 때 실제로 어떤 구성 요소를 다시 렌더링해야하는지 정확하게 알고 있습니다. 각 구성 요소는 중첩 된 구성 요소 경고없이 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 가 자동으로 구현 된 것으로 간주 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18335155b76d4fad8194e8bdec133a87f6304254" translate="yes" xml:space="preserve">
          <source>In Vue, we also have &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt; and even &lt;a href=&quot;render-function#JSX&quot;&gt;support JSX&lt;/a&gt;, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</source>
          <target state="translated">Vue에는 &lt;a href=&quot;render-function&quot;&gt;렌더링 기능이&lt;/a&gt; 있으며 &lt;a href=&quot;render-function#JSX&quot;&gt;JSX&lt;/a&gt; 도 지원 하기 때문에 때로는 그 힘이 필요하기 때문입니다. 그러나 기본 경험으로 우리는 더 간단한 대안으로 템플릿을 제공합니다. 유효한 모든 HTML도 유효한 Vue 템플릿이므로 고유 한 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="030d10ad2ba05486f4deb446ef11d5e04ed0a4f7" translate="yes" xml:space="preserve">
          <source>In Webpack 4+, you can use the &lt;code&gt;mode&lt;/code&gt; option:</source>
          <target state="translated">Webpack 4+에서는 &lt;code&gt;mode&lt;/code&gt; 옵션을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d4f0bbfd3f2e8bb6462aabfac3883c560be6e8a5" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/component-basics&quot;&gt;later in the guide&lt;/a&gt;, but here's an (imaginary) example of what an app's template might look like with components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316b5f68fcb7371b1ffc1163190a5aa5dbe2b1f0" translate="yes" xml:space="preserve">
          <source>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components &lt;a href=&quot;guide/components&quot;&gt;later in the guide&lt;/a&gt;, but here&amp;rsquo;s an (imaginary) example of what an app&amp;rsquo;s template might look like with components:</source>
          <target state="translated">대규모 응용 프로그램에서는 전체 응용 프로그램을 구성 요소로 나누어 개발을 관리 할 수 ​​있어야합니다. &lt;a href=&quot;guide/components&quot;&gt;이 가이드의 뒷부분에서&lt;/a&gt; 구성 요소에 대해 더 많이 이야기 할 것입니다 . 그러나 다음 은 구성 요소 에서 앱 템플릿이 어떻게 보이는지에 대한 가상의 예입니다.</target>
        </trans-unit>
        <trans-unit id="cce007380584fe599b155e880cbf38a37b8c5865" translate="yes" xml:space="preserve">
          <source>In a template it can be useful to use a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag to hold a &lt;code&gt;v-if&lt;/code&gt; or &lt;code&gt;v-for&lt;/code&gt; directive. When migrating to a &lt;code&gt;render&lt;/code&gt; function, the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag is no longer required and can be discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d1075c896ee6a04f422ac930836698aaea2b0a" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you&amp;rsquo;ll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">그러나 일반적인 앱에서는 &lt;code&gt;data&lt;/code&gt; 여러 개의 게시물이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0341aaa53b971cc7f7cd6eab8ea717e277b0a1" translate="yes" xml:space="preserve">
          <source>In a typical app, however, you'll likely have an array of posts in &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8dde57e2c8045db642f017abe87ff72fbc20c" translate="yes" xml:space="preserve">
          <source>In addition to 2.x hard-coded &lt;code&gt;v-model&lt;/code&gt; modifiers like &lt;code&gt;.trim&lt;/code&gt;, now 3.x supports custom modifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4e2e50a87f6ed41c151d22eff006d5759a7c9c" translate="yes" xml:space="preserve">
          <source>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with &lt;code&gt;$&lt;/code&gt; to differentiate them from user-defined properties. For example:</source>
          <target state="translated">Vue 인스턴스는 데이터 속성 외에도 여러 가지 유용한 인스턴스 속성 및 메서드를 제공합니다. 사용자 정의 속성 과 구별하기 위해 앞에 접두사 &lt;code&gt;$&lt;/code&gt; 가 붙습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30b7afc0333bb298c35216e487d1e9e77e4192ca" translate="yes" xml:space="preserve">
          <source>In addition to public APIs, many of the internal components/helpers are now exported as named exports as well. This allows the compiler to output code that only imports features when they are used. For example the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80219b5bbf693b189078749f367546bbbcf16aa2" translate="yes" xml:space="preserve">
          <source>In addition to text interpolation, we can also bind element attributes like this:</source>
          <target state="translated">텍스트 보간 외에도 다음과 같은 요소 속성을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5994728cbddc196dcd0ef1858badc921029a1e1" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;watch&lt;/code&gt; 옵션 외에도 명령형 &lt;a href=&quot;../api/index#vm-watch&quot;&gt;vm. $ watch API&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5150e3e352b277b1ba1aa7eeef457bb44d050905" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;watch&lt;/code&gt; option, you can also use the imperative &lt;a href=&quot;../api/instance-methods#watch&quot;&gt;vm.$watch API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32faab7e104e620749fb0ceef10880dd5beb4c" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (&lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="translated">Vue는 기본 제공되는 지시문 ( &lt;code&gt;v-model&lt;/code&gt; 및 &lt;code&gt;v-show&lt;/code&gt; ) 외에도 고유 한 사용자 지정 지시문을 등록 할 수 있습니다. Vue 2.0에서 코드 재사용 및 추상화의 기본 형식은 구성 요소입니다. 그러나 일반 요소에 대한 저수준 DOM 액세스가 필요한 경우가있을 수 있으며이 경우 사용자 지정 지시문이 여전히 유용합니다. 예를 들어 다음과 같은 입력 요소에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0565e3d1e3c82f3b31c0ab6ec47170e5dc305765" translate="yes" xml:space="preserve">
          <source>In addition to the default set of directives shipped in core (like &lt;code&gt;v-model&lt;/code&gt; or &lt;code&gt;v-show&lt;/code&gt;), Vue also allows you to register your own custom directives. Note that in Vue, the primary form of code reuse and abstraction is components - however, there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d28a8c09a6baf609edfa9fc404ef67e9134cea0" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;type&lt;/code&gt; can also be a custom constructor function and the assertion will be made with an &lt;code&gt;instanceof&lt;/code&gt; check. For example, given the following constructor function exists:</source>
          <target state="translated">또한 &lt;code&gt;type&lt;/code&gt; 은 사용자 정의 생성자 함수일 수 있으며 &lt;code&gt;instanceof&lt;/code&gt; 확인 으로 어설 션이 수행됩니다 . 예를 들어, 다음과 같은 생성자 함수가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a858e091d2bb7c6e47ea11f2b98a3648f57a8e3b" translate="yes" xml:space="preserve">
          <source>In addition, each instance/component can still own and manage its own private state:</source>
          <target state="translated">또한 각 인스턴스 / 컴포넌트는 여전히 자체 프라이빗 상태를 소유하고 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9ca0d32bcd7721be259373df69a9266664877b" translate="yes" xml:space="preserve">
          <source>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should &lt;strong&gt;not&lt;/strong&gt; attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</source>
          <target state="translated">또한 부모 구성 요소가 업데이트 될 때마다 자식 구성 요소의 모든 소품이 최신 값으로 새로 고쳐집니다. 즉 , 하위 구성 요소 내에서 소품을 변경하려고 시도 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 그렇게하면 Vue가 콘솔에서 경고합니다.</target>
        </trans-unit>
        <trans-unit id="b81d142d3c922310cfbb8a89684dac0a487a2272" translate="yes" xml:space="preserve">
          <source>In addition, rather than implicitly provide &lt;code&gt;h&lt;/code&gt; in a &lt;code&gt;render&lt;/code&gt; function, &lt;code&gt;h&lt;/code&gt; is now imported globally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85215d9d308bd40086a0e1662ab21ebbec8c5c6d" translate="yes" xml:space="preserve">
          <source>In addition, since the &lt;code&gt;createApp&lt;/code&gt; method returns the application instance itself, you can chain other methods after it which can be found in the following sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65713f74baf60786834c58f72d45052056f1fa2d" translate="yes" xml:space="preserve">
          <source>In addition, unlike 2.x, the loader function no longer receives the &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must always return a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21451e63b33f7fd3f9f0613a2eed3c9fd082315c" translate="yes" xml:space="preserve">
          <source>In addition, when &lt;code&gt;data()&lt;/code&gt; from a component and its mixins or extends base are merged, the merge is now performed &lt;em&gt;shallowly&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3636deb3b0c4953ecaa1f52798bd8dc37c3b5533" translate="yes" xml:space="preserve">
          <source>In addition, when referencing scoped slots, they could be referenced using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5985a88954adf2a60500ab64ac8c41d6f599d628" translate="yes" xml:space="preserve">
          <source>In addition, you could define your own aliases via the global &lt;code&gt;config.keyCodes&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbcc3158e141581bb6b942a272d46856d1b275a" translate="yes" xml:space="preserve">
          <source>In case you haven&amp;rsquo;t noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &amp;ldquo;tick&amp;rdquo;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="translated">아직 눈치 채지 못한 경우 Vue는 DOM 업데이트를 &lt;strong&gt;비동기 적으로&lt;/strong&gt; 수행합니다 . 데이터 변경이 관찰 될 때마다 큐를 열고 동일한 이벤트 루프에서 발생하는 모든 데이터 변경을 버퍼링합니다. 동일한 감시자가 여러 번 트리거되면 대기열에 한 번만 푸시됩니다. 이 버퍼 중복 제거는 불필요한 계산 및 DOM 조작을 피하는 데 중요합니다. 그런 다음 다음 이벤트 루프 &quot;틱&quot;에서 Vue는 큐를 비우고 실제 (이미 중복 제거 된) 작업을 수행합니다. 내부적으로 Vue는 비동기 대기열을 위해 기본 &lt;code&gt;Promise.then&lt;/code&gt; , &lt;code&gt;MutationObserver&lt;/code&gt; 및 &lt;code&gt;setImmediate&lt;/code&gt; 를 시도 하고 &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt; 폴백 합니다 .</target>
        </trans-unit>
        <trans-unit id="613464b2036a68a6ebb2b0e396760bb7f079d24b" translate="yes" xml:space="preserve">
          <source>In case you haven't noticed yet, Vue performs DOM updates &lt;strong&gt;asynchronously&lt;/strong&gt;. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &quot;tick&quot;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native &lt;code&gt;Promise.then&lt;/code&gt;, &lt;code&gt;MutationObserver&lt;/code&gt;, and &lt;code&gt;setImmediate&lt;/code&gt; for the asynchronous queuing and falls back to &lt;code&gt;setTimeout(fn, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cd65af0c1ac7f1a471b3ebe14997d44c5a24c9" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader (opens new window)&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs (opens new window)&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;webpack learning academy (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaebcaa832cc872ee62580c8ab1928e2e9c98159" translate="yes" xml:space="preserve">
          <source>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader&lt;/a&gt;. To learn more about webpack itself, check out &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;their official docs&lt;/a&gt; and &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy&lt;/a&gt;.</source>
          <target state="translated">처음부터 자체 빌드 설정을 선호하는 경우 &lt;a href=&quot;https://vue-loader.vuejs.org&quot;&gt;vue-loader를 사용&lt;/a&gt; 하여 웹팩을 수동으로 구성해야합니다 . 웹팩 자체에 대한 자세한 내용은 &lt;a href=&quot;https://webpack.js.org/configuration/&quot;&gt;공식 문서&lt;/a&gt; 및 &lt;a href=&quot;https://webpack.academy/p/the-core-concepts&quot;&gt;Webpack Academy를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="14c7c4ad32435f4b7855ae564fc2ea7c8c969cd8" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component&amp;rsquo;s tags can be used as the slot&amp;rsquo;s template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="translated">위와 같은 경우 기본 슬롯 &lt;em&gt;만&lt;/em&gt; 콘텐츠로 제공되는 경우 구성 요소의 태그를 슬롯의 템플릿으로 사용할 수 있습니다. 이를 통해 컴포넌트에서 &lt;code&gt;v-slot&lt;/code&gt; 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afdc559a28e8fc0df8af77b29c0a99f33040dfa0" translate="yes" xml:space="preserve">
          <source>In cases like above, when &lt;em&gt;only&lt;/em&gt; the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use &lt;code&gt;v-slot&lt;/code&gt; directly on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa7f570dcb37787dd83b543d84d7b6f36311f16" translate="yes" xml:space="preserve">
          <source>In cases like this, we can mark components as &lt;code&gt;functional&lt;/code&gt;, which means that they&amp;rsquo;re stateless (no &lt;a href=&quot;../api/index#Options-Data&quot;&gt;reactive data&lt;/a&gt;) and instanceless (no &lt;code&gt;this&lt;/code&gt; context). A &lt;strong&gt;functional component&lt;/strong&gt; looks like this:</source>
          <target state="translated">이와 같은 경우 구성 요소를 &lt;code&gt;functional&lt;/code&gt; 표시 할 수 있습니다. 즉, 구성 요소 는 상태 비 저장 ( &lt;a href=&quot;../api/index#Options-Data&quot;&gt;반응 형 데이터&lt;/a&gt; 없음 ) 및 인스턴스 비 저장 ( &lt;code&gt;this&lt;/code&gt; 컨텍스트 없음 )을 의미합니다. &lt;strong&gt;기능 컴포넌트&lt;/strong&gt; 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="fa13d1c0d73e56359fd93a07fd88a5c686b9d9da" translate="yes" xml:space="preserve">
          <source>In cases where a component is only used once, the debouncing can be applied directly within &lt;code&gt;methods&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afbf4c975278f424bbb47c6b13d6c21a3be2dbb" translate="yes" xml:space="preserve">
          <source>In cases where a watcher effect needs to be re-run &lt;strong&gt;after&lt;/strong&gt; component updates (i.e. when working with &lt;a href=&quot;composition-api-template-refs#watching-template-refs&quot;&gt;Template Refs&lt;/a&gt;), we can pass an additional &lt;code&gt;options&lt;/code&gt; object with the &lt;code&gt;flush&lt;/code&gt; option (default is &lt;code&gt;'pre'&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115593cdb5e7c5bc03b8752b74312ce66ca58e0" translate="yes" xml:space="preserve">
          <source>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</source>
          <target state="translated">커밋 된 코드에서 prop 정의는 최소한 유형을 지정하여 항상 가능한 한 상세해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bfd4fed8d270a9c14023eb29a927d5b4c0ecab4" translate="yes" xml:space="preserve">
          <source>In comparison, &lt;code&gt;v-show&lt;/code&gt; is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</source>
          <target state="translated">이에 비해 &lt;code&gt;v-show&lt;/code&gt; 는 훨씬 간단합니다. CSS 기반 토글을 사용하면 요소는 항상 초기 조건에 관계없이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d22711c22222a7cebea6f132a3ff7ea151c0f818" translate="yes" xml:space="preserve">
          <source>In comparison, a method invocation will &lt;strong&gt;always&lt;/strong&gt; run the function whenever a re-render happens.</source>
          <target state="translated">반면에, 메소드 호출은 다시 렌더링 할 때마다 &lt;strong&gt;항상&lt;/strong&gt; 함수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bb1736ea3b5962d2582e096afba361a049ac9d2c" translate="yes" xml:space="preserve">
          <source>In components that use &lt;code&gt;inheritAttrs: false&lt;/code&gt;, make sure that styling still works as intended. If you previously relied on the special behavior of &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt;, some visuals might be broken as these attributes might now be applied to another element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f3fad6ea47761ecb752634045422b5f91f5f10" translate="yes" xml:space="preserve">
          <source>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</source>
          <target state="translated">개발 과정에서 구성 요소에 형식이 잘못된 소품이 제공되면 Vue에서 경고를 표시하여 잠재적 인 오류 원인을 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8c437a03d6e7a0e6f5698507548a4d93c2d7fe" translate="yes" xml:space="preserve">
          <source>In every subcomponent of a &lt;code&gt;new Vue&lt;/code&gt; instance, this root instance can be accessed with the &lt;code&gt;$root&lt;/code&gt; property. For example, in this root instance:</source>
          <target state="translated">&lt;code&gt;new Vue&lt;/code&gt; 인스턴스 의 모든 하위 구성 요소 에서이 루트 인스턴스는 &lt;code&gt;$root&lt;/code&gt; 속성 으로 액세스 할 수 있습니다 . 예를 들어이 루트 인스턴스에서</target>
        </trans-unit>
        <trans-unit id="097d80c1c9662de13d79de78efe60775b83d52ef" translate="yes" xml:space="preserve">
          <source>In fact, you can think of dependency injection as sort of &amp;ldquo;long-range props&amp;rdquo;, except:</source>
          <target state="translated">실제로 의존성 주입은 다음을 제외하고 일종의 &quot;장거리 소품&quot;으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc506457177d40f6c274f20bb75f39f6557a677" translate="yes" xml:space="preserve">
          <source>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here&amp;rsquo;s how you can replace Vue&amp;rsquo;s built-in directive filters:</source>
          <target state="translated">일반적으로 평범한 JavaScript로 무언가를 달성 할 수있을 때마다 동일한 관심사를 처리하기 위해 필터와 같은 특수 구문을 도입하지 않기를 원합니다. Vue의 내장 지시문 필터를 교체하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae9ee797c12050e7d3af19214520a26751de6044" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it&amp;rsquo;s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</source>
          <target state="translated">큰 응용 프로그램에서는 응용 프로그램을 더 작은 청크로 나누고 필요할 때만 서버에서 구성 요소를로드해야합니다. Vue를 사용하면 구성 요소 정의를 비동기식으로 해결하는 팩토리 함수로 구성 요소를 정의 할 수 있습니다. Vue는 컴포넌트를 렌더링해야 할 때만 팩토리 기능을 트리거하고 향후 다시 렌더링을 위해 결과를 캐시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e1a8f47d0de2c3d5f962fb51601c60c71a4205c" translate="yes" xml:space="preserve">
          <source>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that possible, Vue has a &lt;code&gt;defineAsyncComponent&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447ec0f63a19e47502450736e07a06c1647bfe27" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;Vue.component&lt;/code&gt;, followed by &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="translated">많은 Vue 프로젝트에서 &lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 전역 구성 요소를 정의한 다음 &lt;code&gt;new Vue({ el: '#container' })&lt;/code&gt; 를 사용하여 모든 페이지 본문의 컨테이너 요소를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="46c352f653c2ccd99c8d1eeb1bac3b46074aed40" translate="yes" xml:space="preserve">
          <source>In many Vue projects, global components will be defined using &lt;code&gt;app.component()&lt;/code&gt;, followed by &lt;code&gt;app.mount('#app')&lt;/code&gt; to target a container element in the body of every page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ccc949f90a192c185068356f4f8dd5029eb128" translate="yes" xml:space="preserve">
          <source>In many cases though, you&amp;rsquo;ll still run into strange behavior (e.g. &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; rounds up to &lt;code&gt;0.04&lt;/code&gt;, but &lt;code&gt;0.045&lt;/code&gt; rounds down to &lt;code&gt;0.04&lt;/code&gt;). To work around these issues, you can use the &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt;&lt;code&gt;accounting&lt;/code&gt;&lt;/a&gt; library to more reliably format currencies.</source>
          <target state="translated">그러나 많은 경우 여전히 이상한 동작이 발생합니다 (예 : &lt;code&gt;0.035.toFixed(2)&lt;/code&gt; 는 &lt;code&gt;0.04&lt;/code&gt; 로 반올림 하지만 &lt;code&gt;0.045&lt;/code&gt; 는 &lt;code&gt;0.04&lt;/code&gt; 로 반올림 ). 이러한 문제를 해결하기 위해 &lt;a href=&quot;http://openexchangerates.github.io/accounting.js/&quot;&gt; &lt;code&gt;accounting&lt;/code&gt; &lt;/a&gt; 라이브러리를 사용하여 통화를보다 안정적으로 형식화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c390053bb2e4d5c93dcd01989be3871147f8ba8c" translate="yes" xml:space="preserve">
          <source>In many cases, you may want the same behavior on &lt;code&gt;bind&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, but don&amp;rsquo;t care about the other hooks. For example:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;bind&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 에서 동일한 동작을 원할 수 있지만 다른 후크는 신경 쓰지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a111823d1c021115efbe8d836af1c2f184002aa1" translate="yes" xml:space="preserve">
          <source>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt; event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</source>
          <target state="translated">대부분의 경우 Vue는 전환이 완료된 시점을 자동으로 파악할 수 있습니다. 기본적으로 Vue는 루트 전환 요소 에서 첫 번째 &lt;code&gt;transitionend&lt;/code&gt; 또는 &lt;code&gt;animationend&lt;/code&gt; 이벤트를 기다립니다 . 그러나 이것은 항상 바람직하지는 않습니다. 예를 들어, 중첩 된 내부 요소 중 일부가 루트 전환 요소보다 지연된 전환 또는 더 긴 전환 지속 시간을 갖는 안무 전환 전이 시퀀스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bb963c73fa00775099a6347ea2baa7e2a3e2c72" translate="yes" xml:space="preserve">
          <source>In most cases, it&amp;rsquo;s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</source>
          <target state="translated">대부분의 경우 다른 구성 요소 인스턴스에 도달하거나 DOM 요소를 수동으로 조작하지 않는 것이 가장 좋습니다. 그러나 적절한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c86a77b0b04c3ca150f69dd5331a352786535a" translate="yes" xml:space="preserve">
          <source>In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</source>
          <target state="translated">대부분의 경우 부모에 도달하면 특히 부모 데이터를 변경하는 경우 응용 프로그램을 디버깅하고 이해하기가 더 어려워집니다. 나중에 그 성분을 볼 때, 그 돌연변이가 어디서 왔는지 알아내는 것은 매우 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="d68b5e8d96b9910b923cbe675afd9e3c75b80ac2" translate="yes" xml:space="preserve">
          <source>In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419bd771510d306d9921bc5eb07cb10e9cc4094a" translate="yes" xml:space="preserve">
          <source>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</source>
          <target state="translated">자연 영어에서는 형용사 및 기타 설명자가 일반적으로 명사 앞에 표시되지만 예외에는 커넥터 단어가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5c5a11b792a6a6c3c9dbe85b25f28ab2feb0a79" translate="yes" xml:space="preserve">
          <source>In normal use cases you shouldn&amp;rsquo;t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;.</source>
          <target state="translated">일반적인 사용 사례에서는이 메소드를 직접 호출하지 않아도됩니다. &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-for&lt;/code&gt; 를 사용하여 데이터 기반 방식으로 하위 구성 요소의 수명주기를 제어하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9689e82d55bf91d0bdb0a6e4890e0cb8c481ba5f" translate="yes" xml:space="preserve">
          <source>In order to be more explicit and legible, we have now renamed these initial state classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7967705f3df6230388a8007a18675ebf06f8935f" translate="yes" xml:space="preserve">
          <source>In order to better understand how to create your own Vue.js plugins, we will create a very simplified version of a plugin that displays &lt;code&gt;i18n&lt;/code&gt; ready strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f3b2527a93cc83ec0b5cf78ef1f46a48fed02f" translate="yes" xml:space="preserve">
          <source>In other cases, it returns a stop handle which can be called to explicitly stop the watcher:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3930e2dc2ac43f310bce905c8d03f08738173196" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;ref&lt;/code&gt; creates a &lt;strong&gt;Reactive Reference&lt;/strong&gt; to our value. The concept of working with &lt;strong&gt;References&lt;/strong&gt; will be used often throughout the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26030f8aadd2fe6b946e53d81af4d02ba1edcf5f" translate="yes" xml:space="preserve">
          <source>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b63ec681a094ed6d524d075cda699de0092770" translate="yes" xml:space="preserve">
          <source>In other words, you &lt;strong&gt;will not have access&lt;/strong&gt; to the following component options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d273535df632e4e8ae9260566c4f2451d604b5c" translate="yes" xml:space="preserve">
          <source>In our case, let&amp;rsquo;s make that point the &lt;code&gt;tree-folder&lt;/code&gt; component. We know the child that creates the paradox is the &lt;code&gt;tree-folder-contents&lt;/code&gt; component, so we&amp;rsquo;ll wait until the &lt;code&gt;beforeCreate&lt;/code&gt; lifecycle hook to register it:</source>
          <target state="translated">우리의 경우, 그 지점을 &lt;code&gt;tree-folder&lt;/code&gt; 컴포넌트로 만들어 봅시다 . 우리는 역설을 만드는 자식이 &lt;code&gt;tree-folder-contents&lt;/code&gt; 구성 요소 라는 것을 알고 있으므로 그것을 등록하기 위해 &lt;code&gt;beforeCreate&lt;/code&gt; 수명주기 후크를 기다릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fc49bd00753f672db39f74244a5be9e57229d11" translate="yes" xml:space="preserve">
          <source>In our experience, it&amp;rsquo;s better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn&amp;rsquo;t necessary, you can make a conscious exception.</source>
          <target state="translated">경험상 &lt;em&gt;항상&lt;/em&gt; 고유 키를 추가하는 것이 좋습니다 . 따라서 귀하와 귀하의 팀은 이러한 경우에 대해 걱정할 필요가 없습니다. 그런 다음 객체 불일치가 필요하지 않은 드문 성능 중심 시나리오에서는 의식적인 예외를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78698544f2ebea81bf74621176fba4067b232946" translate="yes" xml:space="preserve">
          <source>In our experience, it's better to &lt;em&gt;always&lt;/em&gt; add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa9363da25541b78e6af0972c3f9bb895597ac0" translate="yes" xml:space="preserve">
          <source>In previous example, you may want the same behavior on &lt;code&gt;mounted&lt;/code&gt; and &lt;code&gt;updated&lt;/code&gt;, but don't care about the other hooks. You can do it by passing the callback to directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da1d060c31fa0a41ee9f1ab266ae7cb095dc2c" translate="yes" xml:space="preserve">
          <source>In situations where computed properties are not feasible (e.g. inside nested &lt;code&gt;v-for&lt;/code&gt; loops), you can use a method:</source>
          <target state="translated">계산 된 속성을 사용할 수없는 상황 (예 : 중첩 된 &lt;code&gt;v-for&lt;/code&gt; 루프 내부 )에서는 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3807437f4c73a9a48f84e425ea613aac544cc0" translate="yes" xml:space="preserve">
          <source>In some cases, we may need &amp;ldquo;two-way binding&amp;rdquo; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</source>
          <target state="translated">경우에 따라 소품에&amp;ldquo;양방향 바인딩&amp;rdquo;이 필요할 수 있습니다. 불행하게도, 진정한 양방향 바인딩은 유지 관리 문제를 일으킬 수 있습니다. 하위 구성 요소는 부모와 자식 모두에서 그 돌연변이의 원인이 분명하지 않으면 서 부모를 돌연변이시킬 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d3a61aecf34702fc3ac15dbd55af0193cd0d21b7" translate="yes" xml:space="preserve">
          <source>In some cases, we might need &quot;two-way binding&quot; for a prop (sometimes in addition to existing &lt;code&gt;v-model&lt;/code&gt; for the different prop). To do so, we recommended emitting events in the pattern of &lt;code&gt;update:myPropName&lt;/code&gt;. For example, for &lt;code&gt;ChildComponent&lt;/code&gt; from the previous example with the &lt;code&gt;title&lt;/code&gt; prop, we could communicate the intent of assigning a new value with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1940a94800d8a762af2d6a0c31713ae2122b98c5" translate="yes" xml:space="preserve">
          <source>In such cases you can specify an explicit transition duration (in milliseconds) using the &lt;code&gt;duration&lt;/code&gt; prop on the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">이러한 경우 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 구성 요소 의 &lt;code&gt;duration&lt;/code&gt; prop를 사용하여 명시적인 전환 지속 시간 (밀리 초)을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a26c3605ae94474098786b85b0faf6c2e5c873c" translate="yes" xml:space="preserve">
          <source>In terms of what has changed, at a high level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7b8e5881c6c604581549ecd2e87a6d5a150d11" translate="yes" xml:space="preserve">
          <source>In that case, the &lt;code&gt;.native&lt;/code&gt; listener in the parent would silently break. There would be no errors, but the &lt;code&gt;onFocus&lt;/code&gt; handler wouldn&amp;rsquo;t be called when we expected it to.</source>
          <target state="translated">이 경우 부모 의 &lt;code&gt;.native&lt;/code&gt; 리스너가 자동으로 중단됩니다. 오류는 없지만 예상 할 때 &lt;code&gt;onFocus&lt;/code&gt; 핸들러가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c963edc9ad3f82196cbef815577797afa016c7d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the NPM package&lt;/a&gt; you will find many different builds of Vue.js. Here&amp;rsquo;s an overview of the difference between them:</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/dist/&quot;&gt;NPM 패키지&lt;/a&gt; 의 &lt;code&gt;dist/&lt;/code&gt; 디렉토리 에는 Vue.js의 다양한 빌드가 있습니다. 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="096cc70c4fb5904b4142f8704ac2119fe695246e" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue@3.0.2/dist/&quot;&gt;&lt;code&gt;dist/&lt;/code&gt; directory of the npm package (opens new window)&lt;/a&gt; you will find many different builds of Vue.js. Here is an overview of which &lt;code&gt;dist&lt;/code&gt; file should be used depending on the use-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f40ffd220cc5bc553599168b68b9a1d61abb356" translate="yes" xml:space="preserve">
          <source>In the above example, the handler will only be called if &lt;code&gt;$event.key&lt;/code&gt; is equal to &lt;code&gt;'PageDown'&lt;/code&gt;.</source>
          <target state="translated">위 예제에서 &lt;code&gt;$event.key&lt;/code&gt; 가 &lt;code&gt;'PageDown'&lt;/code&gt; 인 경우에만 핸들러가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3446d8a02b83d478e2220ffc2e826c8e079f0f9" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4792c37807464f6bc3e88fc7e7650b64df280b7d" translate="yes" xml:space="preserve">
          <source>In the case of boolean attributes, where their mere existence implies &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;v-bind&lt;/code&gt; works a little differently. In this example:</source>
          <target state="translated">그들의 단순한 존재가 의미하는 부울 속성의 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;v-bind&lt;/code&gt; 약간 다르게 작동합니다. 이 예에서 :</target>
        </trans-unit>
        <trans-unit id="bb18b983202c7fe25cd6f2bdde9cc28d610f7cf0" translate="yes" xml:space="preserve">
          <source>In the console, enter &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt;. You should see a new item appended to the list.</source>
          <target state="translated">콘솔에서 &lt;code&gt;app4.todos.push({ text: 'New item' })&lt;/code&gt; . 목록에 새 항목이 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="baf8e367f46b7e0b83ce3e0f831c56fb3167cb4c" translate="yes" xml:space="preserve">
          <source>In the event we need to define the status of the date-picker component via a &lt;code&gt;data-status&lt;/code&gt; property, it will be applied to the root node (i.e., &lt;code&gt;div.date-picker&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95310bafe87b1cd719e23dc5ad106b31232edbf5" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;currentTabComponent&lt;/code&gt; can contain either:</source>
          <target state="translated">위의 예에서 &lt;code&gt;currentTabComponent&lt;/code&gt; 는 다음 중 하나를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04b574a39526af2226086b101aac912fd89cf7c" translate="yes" xml:space="preserve">
          <source>In the example above, either &lt;code&gt;appear&lt;/code&gt; attribute or &lt;code&gt;v-on:appear&lt;/code&gt; hook will cause an appear transition.</source>
          <target state="translated">위의 예에서 &lt;code&gt;appear&lt;/code&gt; 속성 또는 &lt;code&gt;v-on:appear&lt;/code&gt; 훅은 모양 전환을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="483be1a650754b9854fa661d0a114900f298cd73" translate="yes" xml:space="preserve">
          <source>In the example above, if we change the list of &lt;code&gt;todos&lt;/code&gt;, this change won't be reflected in the injected &lt;code&gt;todoLength&lt;/code&gt; property. This is because &lt;code&gt;provide/inject&lt;/code&gt; bindings are &lt;em&gt;not&lt;/em&gt; reactive by default. We can change this behavior by passing a &lt;code&gt;ref&lt;/code&gt; property or &lt;code&gt;reactive&lt;/code&gt; object to &lt;code&gt;provide&lt;/code&gt;. In our case, if we wanted to react to changes in the ancestor component, we would need to assign a Composition API &lt;code&gt;computed&lt;/code&gt; property to our provided &lt;code&gt;todoLength&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2def93c9e7b3255befa3e7efa09f860a33357348" translate="yes" xml:space="preserve">
          <source>In the example above, the method &lt;code&gt;increment&lt;/code&gt; will be called when the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a3df45a50f5bfc852f235683adae371735692a" translate="yes" xml:space="preserve">
          <source>In the future, you can consult the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API reference&lt;/a&gt; for a full list of instance properties and methods.</source>
          <target state="translated">나중에 인스턴스 속성 및 메서드의 전체 목록을 보려면 &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;API 참조&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="61e01a36c0b76503c82d3b378dd53c34675f6cd7" translate="yes" xml:space="preserve">
          <source>In the parent, we can support this feature by adding a &lt;code&gt;postFontSize&lt;/code&gt; data property:</source>
          <target state="translated">부모에서 &lt;code&gt;postFontSize&lt;/code&gt; 데이터 속성 을 추가하여이 기능을 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd63d2b019faa52d4307ffd579cbe3aabbbc0774" translate="yes" xml:space="preserve">
          <source>In the two examples above, we happen to pass string values, but &lt;em&gt;any&lt;/em&gt; type of value can actually be passed to a prop.</source>
          <target state="translated">위의 두 예제에서 문자열 값을 전달하지만 실제로는 &lt;em&gt;모든&lt;/em&gt; 유형의 값을 소품에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd9b704f820476ed2050280cb293d51fab68d129" translate="yes" xml:space="preserve">
          <source>In these cases, you can also use the &lt;code&gt;key&lt;/code&gt; attribute to transition between different states of the same element. Instead of using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-else&lt;/code&gt;, the above example could be rewritten as:</source>
          <target state="translated">이 경우 &lt;code&gt;key&lt;/code&gt; 속성을 사용 하여 동일한 요소의 여러 상태 간을 전환 할 수도 있습니다 . &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-else&lt;/code&gt; 를 사용하는 대신 위 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270ed3979fc2c798270823f8c8f6f6d7b3c0fe7a" translate="yes" xml:space="preserve">
          <source>In these cases, you can define your components as plain JavaScript objects:</source>
          <target state="translated">이 경우 구성 요소를 일반 JavaScript 객체로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba09958fde7b27bfaf33999c7469e63cc8666df2" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;change&lt;/code&gt; event listener is passed from the parent component to the child and it will be triggered on native &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;code&gt;change&lt;/code&gt; event. We won't need to emit an event from the &lt;code&gt;date-picker&lt;/code&gt; explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3f7f2ff8f42344402992b4038b21897eb06f33" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;filterA&lt;/code&gt;, defined with a single argument, will receive the value of &lt;code&gt;message&lt;/code&gt;, and then the &lt;code&gt;filterB&lt;/code&gt; function will be called with the result of &lt;code&gt;filterA&lt;/code&gt; passed into &lt;code&gt;filterB&lt;/code&gt;&amp;lsquo;s single argument.</source>
          <target state="translated">이 경우, &lt;code&gt;filterA&lt;/code&gt; 하나의 인자로 정의 된, 값 수신처 &lt;code&gt;message&lt;/code&gt; 하고 &lt;code&gt;filterB&lt;/code&gt; 된 함수의 결과를 호출한다 &lt;code&gt;filterA&lt;/code&gt; 로 전달 &lt;code&gt;filterB&lt;/code&gt; 의 단일 인자.</target>
        </trans-unit>
        <trans-unit id="b094d0f631f3cc4f6960b2f03d3f031dd3ba5545" translate="yes" xml:space="preserve">
          <source>In this case, child component will expect a &lt;code&gt;title&lt;/code&gt; prop and emits &lt;code&gt;update:title&lt;/code&gt; event to sync:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87475fd1d00b371cef287b525052f62f24411b8f" translate="yes" xml:space="preserve">
          <source>In this case, even when &lt;code&gt;child-component&lt;/code&gt; is rendered in the different place, it will remain a child of &lt;code&gt;parent-component&lt;/code&gt; and will receive a &lt;code&gt;name&lt;/code&gt; prop from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f8bfe75335d793eeba7a8a459bb7388dddda84" translate="yes" xml:space="preserve">
          <source>In this case, two different values for &lt;code&gt;class&lt;/code&gt; are defined:</source>
          <target state="translated">이 경우 &lt;code&gt;class&lt;/code&gt; 에 대해 서로 다른 두 가지 값 이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="35bd1cc27abd4ba52e44235a43fbbdc36c5c6e07" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API) and sets a condition for performing this operation. None of that would be possible with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a41e15d26b4745e4e15ab1dd537dc8ed976bef4" translate="yes" xml:space="preserve">
          <source>In this case, using the &lt;code&gt;watch&lt;/code&gt; option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</source>
          <target state="translated">이 경우 &lt;code&gt;watch&lt;/code&gt; 옵션을 사용하면 비동기 작업 (API에 액세스)을 수행하고 해당 작업을 수행하는 빈도를 제한하며 최종 답변을 얻을 때까지 중개 상태를 설정할 수 있습니다. 그 중 어느 것도 계산 된 속성으로는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c77863cfdbda9f76e5977da8ad51a7454c3913a0" translate="yes" xml:space="preserve">
          <source>In this component, all descendants of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; needed access to a &lt;code&gt;getMap&lt;/code&gt; method, in order to know which map to interact with. Unfortunately, using the &lt;code&gt;$parent&lt;/code&gt; property didn&amp;rsquo;t scale well to more deeply nested components. That&amp;rsquo;s where dependency injection can be useful, using two new instance options: &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소에서 상호 작용할지도를 알기 위해 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; 의 모든 자손이 &lt;code&gt;getMap&lt;/code&gt; 메소드에 액세스해야했습니다 . 불행히도 &lt;code&gt;$parent&lt;/code&gt; 속성을 사용하면 더 깊이 중첩 된 구성 요소로 확장되지 않았습니다. 여기에서 두 가지 새로운 인스턴스 옵션 인 &lt;code&gt;provide&lt;/code&gt; 및 &lt;code&gt;inject&lt;/code&gt; 를 사용하여 종속성 주입이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f4bcb81fce1b99e6d7bcbd862cd7e2191686fff" translate="yes" xml:space="preserve">
          <source>In this example, we are creating animation through the use of interpolation, attached to the mouse movement. The CSS transition is applied to the element as well, to let the element know what kind of easing to use while it's updating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c32991080d62b6805604f45e74c2b9dbeebfae" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ve chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="translated">이 예에서는 모든 슬롯 소품 &lt;code&gt;slotProps&lt;/code&gt; 가 포함 된 객체의 이름을 지정 했지만 원하는 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16da33edc850538e8b64bc474cfc99b18b1ed65" translate="yes" xml:space="preserve">
          <source>In this example, we've chosen to name the object containing all our slot props &lt;code&gt;slotProps&lt;/code&gt;, but you can use any name you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe86abd2c9033c394d4520eeee5520850f8fc84" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;&amp;lsquo;s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;eventName&lt;/code&gt; 값이 &lt;code&gt;&quot;focus&quot;&lt;/code&gt; 인 경우 &lt;code&gt;v-on:[eventName]&lt;/code&gt; 은 &lt;code&gt;v-on:focus&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3ee4d6d04f3346c2de61ff6305b7eecf8246b8e0" translate="yes" xml:space="preserve">
          <source>In this example, when &lt;code&gt;eventName&lt;/code&gt;'s value is &lt;code&gt;&quot;focus&quot;&lt;/code&gt;, &lt;code&gt;v-on:[eventName]&lt;/code&gt; will be equivalent to &lt;code&gt;v-on:focus&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="301b4eda5dbc41617be06964e971e23018f19d78" translate="yes" xml:space="preserve">
          <source>In this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e78735239ecbe7e73bb9d8e2936f204860e9c" translate="yes" xml:space="preserve">
          <source>In this next section, we'll go over some web animation and transitions basics, and link off to some resources for further exploration. If you're already familiar with web animation and how those principles might work with some of Vue's directives, feel free to skip this next section. For anyone else looking to learn a little more about web animation basics before diving in, read on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b90fada6407b38a0e73129e45014412d2857eb5" translate="yes" xml:space="preserve">
          <source>In this, any change to &lt;code&gt;todos.length&lt;/code&gt; will be reflected correctly in the components, where &lt;code&gt;todoLength&lt;/code&gt; is injected. Read more about &lt;code&gt;computed&lt;/code&gt; in the &lt;a href=&quot;reactivity-computed-watchers#computed-values&quot;&gt;Computed and Watch section&lt;/a&gt; and &lt;code&gt;reactive&lt;/code&gt; provide/inject in the &lt;a href=&quot;composition-api-provide-inject#reactivity&quot;&gt;Composition API section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83141900cc37f0045fe7fc8eeac34df78525c24e" translate="yes" xml:space="preserve">
          <source>In v2.1.8, we introduced &lt;code&gt;v-enter-to&lt;/code&gt; to address the timing gap between enter/leave transitions. However, for backward compatibility, the &lt;code&gt;v-enter&lt;/code&gt; name was untouched:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a932790edae9a805888ba88043f905fae94eda92" translate="yes" xml:space="preserve">
          <source>In-browser Sandbox on &lt;a href=&quot;https://v3.vue.new&quot;&gt;CodeSandbox (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18af7a938545bae476e6597aaaf4d9729f2bb10a" translate="yes" xml:space="preserve">
          <source>In-browser playground on &lt;a href=&quot;https://codepen.io/yyx990803/pen/OJNoaZL&quot;&gt;Codepen (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b54df78801726764e7a6e4a3da6b7ab270929d" translate="yes" xml:space="preserve">
          <source>In-browser template compilation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb555d4f2dd9b0c24bb7bd03390992336ca209c" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example, if we have an object with a nested array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f426e265453130f5824fc7740883c382b44aac" translate="yes" xml:space="preserve">
          <source>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</source>
          <target state="translated">템플릿 내 표현은 매우 편리하지만 간단한 작업을위한 것입니다. 템플릿에 너무 많은 논리를 넣으면 부풀어지고 유지하기가 어려울 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14f1365ed8291193e8cace94a5ade677414a902d" translate="yes" xml:space="preserve">
          <source>Individual nodes</source>
          <target state="translated">개별 노드</target>
        </trans-unit>
        <trans-unit id="8a0e39acb1c9c6d6a7975a0cc9ac25b374494a2e" translate="yes" xml:space="preserve">
          <source>Information about the parent document: footnotes/copyrights/links to privacy statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7754e67b3434e8bddbe642373114506a298fbefb" translate="yes" xml:space="preserve">
          <source>Information and the operation of user interface must be understandable to all users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ac95bcfcaea7ee52c78bc13557436b1b7e8b9e" translate="yes" xml:space="preserve">
          <source>Information for React Developers</source>
          <target state="translated">반응 개발자를위한 정보</target>
        </trans-unit>
        <trans-unit id="f7fe66c9daa7dc6cfca9b6a287a3553348c8c87d" translate="yes" xml:space="preserve">
          <source>Injecting a property into the root component, with a value provided by the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bfac40439f515d418c73435ab088df8607873d" translate="yes" xml:space="preserve">
          <source>Injections can be optional with default value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55df74fbab3d4d77132f63aeb4395de7ec9a282" translate="yes" xml:space="preserve">
          <source>Inline Template Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44289ee2d1bd2c3982f79cb3d372150789f0e39" translate="yes" xml:space="preserve">
          <source>Inline Templates</source>
          <target state="translated">인라인 템플릿</target>
        </trans-unit>
        <trans-unit id="b59e8ce6b81b97e1c066f696c45f14d51b2387b4" translate="yes" xml:space="preserve">
          <source>Inline templates attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351cce80f83cbfe40944664026f6d9aab7cb539" translate="yes" xml:space="preserve">
          <source>Inlines all Vue core internal packages - i.e. it's a single file with no dependencies on other files. This means you must import everything from this file and this file only to ensure you are getting the same instance of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef635bdfe6ae64380c953e554f1a2566d43a6f8" translate="yes" xml:space="preserve">
          <source>Input fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a0f79f1797a1db2dda5bb9c7106c3808038d31" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;v-for&lt;/code&gt; blocks we have full access to parent scope properties. &lt;code&gt;v-for&lt;/code&gt; also supports an optional second argument for the index of the current item.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 블록 내부에서는 부모 범위 속성에 대한 모든 액세스 권한이 있습니다. &lt;code&gt;v-for&lt;/code&gt; 는 현재 항목의 인덱스에 대한 선택적 두 번째 인수도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="916038a23e13909a2f75bbe445827872088c10bc" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df082a453d9989c585680725b67df591a35ff7cd" translate="yes" xml:space="preserve">
          <source>Install a Vue.js plugin. If the plugin is an Object, it must expose an &lt;code&gt;install&lt;/code&gt; method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</source>
          <target state="translated">Vue.js 플러그인을 설치하십시오. 플러그인이 Object 인 경우 &lt;code&gt;install&lt;/code&gt; 방법을 공개해야합니다 . 함수 자체 인 경우 설치 방법으로 처리됩니다. 설치 방법은 Vue를 인수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a20feef8f2799f45b48c087bb1f2c9b59bf8bd" translate="yes" xml:space="preserve">
          <source>Install it using &lt;a href=&quot;#npm&quot;&gt;npm&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d6d358674017f8697b8b19f7ff45ce7429f3312b" translate="yes" xml:space="preserve">
          <source>Installing Rollup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cfe08fef21bde292ada7bf7c0aed2cb8221c4a" translate="yes" xml:space="preserve">
          <source>Instance DOM Options</source>
          <target state="translated">인스턴스 DOM 옵션</target>
        </trans-unit>
        <trans-unit id="ff364c35cc3bd1adde1c021645e9ea7d4cfa6d27" translate="yes" xml:space="preserve">
          <source>Instance Lifecycle Hooks</source>
          <target state="translated">인스턴스 수명주기 후크</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973fbc314de18d3a6034820e1c145f308866aa0a" translate="yes" xml:space="preserve">
          <source>Instance Methods / Data</source>
          <target state="translated">인스턴스 메소드 / 데이터</target>
        </trans-unit>
        <trans-unit id="072a5ac49177533e4f02b944ecefcab1e2a8405f" translate="yes" xml:space="preserve">
          <source>Instance Methods / Events</source>
          <target state="translated">인스턴스 메소드 / 이벤트</target>
        </trans-unit>
        <trans-unit id="217d7335931d2bbee9b9778f9ae71c201b5b2ba6" translate="yes" xml:space="preserve">
          <source>Instance Methods / Lifecycle</source>
          <target state="translated">인스턴스 메소드 / 라이프 사이클</target>
        </trans-unit>
        <trans-unit id="227bff69876b172aeee6752f9b003b6b9627ce6c" translate="yes" xml:space="preserve">
          <source>Instance Properties</source>
          <target state="translated">인스턴스 속성</target>
        </trans-unit>
        <trans-unit id="8e111ccced14747a0574e33ed0b08f79642573af" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;author.books&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;publishedBooksMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f963982241acc7a523f3640f34c5d31eeeb04c" translate="yes" xml:space="preserve">
          <source>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that &lt;strong&gt;computed properties are cached based on their reactive dependencies.&lt;/strong&gt; A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as &lt;code&gt;message&lt;/code&gt; has not changed, multiple access to the &lt;code&gt;reversedMessage&lt;/code&gt; computed property will immediately return the previously computed result without having to run the function again.</source>
          <target state="translated">계산 된 속성 대신 메서드와 동일한 기능을 정의 할 수 있습니다. 결과적으로 두 가지 접근 방식은 실제로 동일합니다. 그러나 차이점은 &lt;strong&gt;계산 된 속성이 반응성 종속성에 따라 캐시&lt;/strong&gt; 된다는 것 &lt;strong&gt;입니다. &lt;/strong&gt;계산 된 속성은 일부 반응성 종속성이 변경된 경우에만 다시 평가됩니다. 이는 &lt;code&gt;message&lt;/code&gt; 가 변경되지 않는 한 &lt;code&gt;reversedMessage&lt;/code&gt; 계산 속성에 여러 번 액세스 하면 함수를 다시 실행할 필요없이 이전에 계산 된 결과를 즉시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b07b3bfde3c37c88bc87409ab0932e79deaf1" translate="yes" xml:space="preserve">
          <source>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</source>
          <target state="translated">메소드 이름에 직접 바인딩하는 대신 인라인 JavaScript 명령문에서 메소드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8cfda798ff1c2483b2312e929e673f1a5762a04" translate="yes" xml:space="preserve">
          <source>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding &lt;code&gt;todo&lt;/code&gt; as a slot prop:</source>
          <target state="translated">각 할 일에 대한 내용을 하드 코딩하는 대신 모든 할 일을 슬롯으로 만든 다음 할 &lt;code&gt;todo&lt;/code&gt; 을 슬롯 소품으로 바인딩하여 부모 구성 요소가 제어하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b69ebfba064bf598fe0cf47768da6d783b96402" translate="yes" xml:space="preserve">
          <source>Instead of using filters, we recommend replacing them with computed properties or methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7ba8338e1ddfeb030dce1f2c4b233f9f6e562c" translate="yes" xml:space="preserve">
          <source>Instead of using this interface to watch events emitted by the store itself (e.g. &lt;code&gt;store.on('mutation', callback)&lt;/code&gt;), a new method &lt;code&gt;store.subscribe&lt;/code&gt; is introduced. Typical usage inside a plugin would be:</source>
          <target state="translated">이 인터페이스를 사용하여 상점 자체에서 생성 된 이벤트 (예 : &lt;code&gt;store.on('mutation', callback)&lt;/code&gt; )를 보는 대신 새로운 메소드 &lt;code&gt;store.subscribe&lt;/code&gt; 가 도입되었습니다. 플러그인 내부의 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="c45f60db0ef01bd679b8e4fcc3944f81d86bbcba" translate="yes" xml:space="preserve">
          <source>Instead, &lt;strong&gt;a component&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; option must be a function&lt;/strong&gt;, so that each instance can maintain an independent copy of the returned data object:</source>
          <target state="translated">대신, 각 인스턴스가 반환 된 데이터 객체의 독립적 인 복사본을 유지할 수 있도록 &lt;strong&gt;구성 요소의 &lt;code&gt;data&lt;/code&gt; 옵션은 function이어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="de7d48ff36cd012d479333deddf79964e9f6ef8d" translate="yes" xml:space="preserve">
          <source>Instead, retrieve reactive data directly.</source>
          <target state="translated">대신, 반응성 데이터를 직접 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3f19e4bbba14c8cf11229dc99c18e65e5c769ff2" translate="yes" xml:space="preserve">
          <source>Instead, we recommend combining the two prefixes into &lt;code&gt;$_&lt;/code&gt;, as a convention for user-defined private properties that guarantee no conflicts with Vue.</source>
          <target state="translated">대신 Vue와의 충돌을 보장하지 않는 사용자 정의 개인 속성의 규칙 으로 두 개의 접두사를 &lt;code&gt;$_&lt;/code&gt; 로 결합하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c287d7ed2127cbc1824f61b424108dfdd71928ca" translate="yes" xml:space="preserve">
          <source>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</source>
          <target state="translated">대신 각 구성 요소 인스턴스가 자체 데이터 만 관리하기를 원합니다. 이를 위해서는 각 인스턴스가 고유 한 데이터 객체를 생성해야합니다. JavaScript에서 이것은 객체를 함수로 반환하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b563c3c711449585b436481ceb793428c3903f" translate="yes" xml:space="preserve">
          <source>Instead, you can make your global filters available to all components through &lt;a href=&quot;../../api/application-config#globalproperties&quot;&gt;globalProperties&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0cc627a5064aba30be950b8ad2481ae6f54dff" translate="yes" xml:space="preserve">
          <source>Instead, you must always specify the name of the slot if you wish to use the shorthand:</source>
          <target state="translated">대신 속기를 사용하려면 항상 슬롯 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8afed2c977a300920d4774ed7aaf9deb5512321" translate="yes" xml:space="preserve">
          <source>Instead, you should use an array of &lt;strong&gt;objects&lt;/strong&gt; so that &lt;code&gt;v-model&lt;/code&gt; can update the field on the object. For example:</source>
          <target state="translated">대신 &lt;code&gt;v-model&lt;/code&gt; 이 객체의 필드를 업데이트 할 수 있도록 &lt;strong&gt;객체&lt;/strong&gt; 배열을 사용해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="379c57f76110aace6f90c62a627b81f0dbbb50b8" translate="yes" xml:space="preserve">
          <source>Integrating 3rd-Party Routers</source>
          <target state="translated">타사 라우터 통합</target>
        </trans-unit>
        <trans-unit id="17e18e17ef79745c1f295aa1481626993cd060bc" translate="yes" xml:space="preserve">
          <source>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</source>
          <target state="translated">흥미롭게도 Angular와 Vue가 이러한 AngularJS 문제를 해결하는 방법에는 몇 가지 유사점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dbe2588887c00092f294adc50297fc9daf034b" translate="yes" xml:space="preserve">
          <source>Interface forms, controls, and navigation are operable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd4997099c9dd515cd8fce4f842d086b138a78e" translate="yes" xml:space="preserve">
          <source>Internal Helpers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a02ab300dc1e2d3aba3bbbb2499900bcfcafa6b5" translate="yes" xml:space="preserve">
          <source>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</source>
          <target state="translated">내부적으로 범위가 지정된 슬롯은 슬롯 내용을 단일 인수로 전달 된 함수로 래핑하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="8c3512fba6689d1150362df7589fdd0259a7670c" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas (&lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt;) won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="translated">텍스트 영역 ( &lt;code&gt;&amp;lt;textarea&amp;gt;{{text}}&amp;lt;/textarea&amp;gt;&lt;/code&gt; )의 보간 이 작동하지 않습니다. 대신 &lt;code&gt;v-model&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="722656fd1f60b606e49464736f37b7a9d40935be" translate="yes" xml:space="preserve">
          <source>Interpolation on textareas won't work. Use &lt;code&gt;v-model&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ebae54b757a56e2bc6baaef1874a08b06640a9" translate="yes" xml:space="preserve">
          <source>Interpolation within Attributes &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">속성 내 보간 &lt;sup&gt;제거&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="fb6efaa267240ec6e8121cc0f552cf518066ff57" translate="yes" xml:space="preserve">
          <source>Interpolation within attributes is no longer valid. For example:</source>
          <target state="translated">속성 내 보간이 더 이상 유효하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10efc8300e4de32a0bfa767fd16f85f0fca31378" translate="yes" xml:space="preserve">
          <source>Interpolations</source>
          <target state="translated">Interpolations</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="9ac25b7dbef348b38cd7447ba00e5e06fcb8b0d0" translate="yes" xml:space="preserve">
          <source>It also automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52da9e9435184a9a9be23be1c62462bd7a0b062b" translate="yes" xml:space="preserve">
          <source>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</source>
          <target state="translated">또한 디자이너와 경험이 부족한 개발자가 코드베이스를 구문 분석하고 기여하는 것이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="a407600c5553a0b6afce3b2e7009380cff190cf2" translate="yes" xml:space="preserve">
          <source>It also makes it possible to use values other than &lt;code&gt;'true'&lt;/code&gt; and &lt;code&gt;'false'&lt;/code&gt;, or even keywords yet to come, for attributes like &lt;code&gt;contenteditable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50744937982614ead76f6bef3b2eb792cfd3c531" translate="yes" xml:space="preserve">
          <source>It also returns &lt;code&gt;true&lt;/code&gt; if the proxy is created by &lt;a href=&quot;#readonly&quot;&gt;&lt;code&gt;readonly&lt;/code&gt;&lt;/a&gt;, but is wrapping another proxy created by &lt;a href=&quot;#reactive&quot;&gt;&lt;code&gt;reactive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242a4787e446f757f3ac8fde1ce7050c81ebb1cc" translate="yes" xml:space="preserve">
          <source>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</source>
          <target state="translated">또한 요소 / 구성 요소를 재사용하는 대신 강제로 교체하는 데 사용할 수도 있습니다. 다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf94cb95d2a6204ed6e671a125bae5746aa13ec0" translate="yes" xml:space="preserve">
          <source>It cannot generate projects from user-built &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;presets&lt;/a&gt;, which can be especially useful for enterprise environments with pre-established conventions.</source>
          <target state="translated">사용자가 만든 &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#presets&quot;&gt;사전 설정&lt;/a&gt; 에서 프로젝트를 생성 할 수 없으며 이는 사전 설정된 규칙이있는 엔터프라이즈 환경에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="37750b9b71f6bf6ac1b868dd8c8eae2a17dab1cf" translate="yes" xml:space="preserve">
          <source>It depends on a few factors:</source>
          <target state="translated">몇 가지 요인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="70b676c863532ffe7d78b42611fe7b4038b9d1dc" translate="yes" xml:space="preserve">
          <source>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;plugins&lt;/a&gt;.</source>
          <target state="translated">Vue CLI는 &lt;a href=&quot;https://cli.vuejs.org/guide/plugins-and-presets.html#plugins&quot;&gt;플러그인을&lt;/a&gt; 통해 확장 할 수있는 업그레이드 가능한 런타임 종속성 위에서 실행되는 동안 프로젝트 생성 중에는 구성을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="240dd640eed272f9ee3a7566a0beee5ed35abc4a" translate="yes" xml:space="preserve">
          <source>It generally takes more time to navigate through nested sub-directories, than scrolling through a single &lt;code&gt;components&lt;/code&gt; directory.</source>
          <target state="translated">일반적으로 단일 &lt;code&gt;components&lt;/code&gt; 디렉토리를 스크롤하는 것보다 중첩 된 하위 디렉토리를 탐색하는 데 시간이 더 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="338465a67b58e6eaa9650c8e5d83c288832f2b5a" translate="yes" xml:space="preserve">
          <source>It is a common practice for plugin authors to install the plugins automatically in their UMD builds using &lt;code&gt;Vue.use&lt;/code&gt;. For instance, this is how the official &lt;code&gt;vue-router&lt;/code&gt; plugin installs itself in a browser environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f753667cec6acdcb632b79682184c7b7b2e7aa" translate="yes" xml:space="preserve">
          <source>It is a very common need to call &lt;code&gt;event.preventDefault()&lt;/code&gt; or &lt;code&gt;event.stopPropagation()&lt;/code&gt; inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</source>
          <target state="translated">이벤트 핸들러 내에서 &lt;code&gt;event.preventDefault()&lt;/code&gt; 또는 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 을 호출하는 것이 매우 일반적 입니다. 비록 우리가 메소드 내에서 이것을 쉽게 할 수 있지만, 메소드가 DOM 이벤트 세부 사항을 다루지 않고 데이터 로직에 관한 것일 수 있다면 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b9b82ff6a9ecc8371804166f686dd29269fd8e00" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &quot;else block&quot; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8708ee403dc8bba50752b03a6d6d4b4352acb0" translate="yes" xml:space="preserve">
          <source>It is also possible to add an &amp;ldquo;else block&amp;rdquo; with &lt;code&gt;v-else&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;v-else&lt;/code&gt; 와 함께 &quot;else 블록&quot;을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2528b05b485478cec60d8b3a4617e597495c046e" translate="yes" xml:space="preserve">
          <source>It is also possible to call a method directly from a template. As we'll see shortly, it's usually better to use a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; instead. However, using a method can be useful in scenarios where computed properties aren't a viable option. You can call a method anywhere that a template supports JavaScript expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821ab047e92b1bb797a359c27dd615c7dcb8237f" translate="yes" xml:space="preserve">
          <source>It is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11aad10ac88ab1f4f9941c1804dfd826b7419eb" translate="yes" xml:space="preserve">
          <source>It is best to provide all the information the user needs to fill out forms outside any inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c0231656f976858a53174ef4b684db8fe6384f" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you document all of the events emitted by each of your components using &lt;code&gt;emits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e03924ee6970dca117928a311e1533f2014100" translate="yes" xml:space="preserve">
          <source>It is no longer supported to have &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;s with the same name in the same template. When a slot is rendered it is &amp;ldquo;used up&amp;rdquo; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</source>
          <target state="translated">같은 템플릿에 같은 이름 을 가진 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 이 더 이상 지원되지 않습니다 . 슬롯이 렌더링 될 때 슬롯은 &quot;사용&quot;되며 동일한 렌더링 트리의 다른 곳에서는 렌더링 할 수 없습니다. 동일한 컨텐츠를 여러 위치에 렌더링해야하는 경우 해당 컨텐츠를 소품으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d9093e211b6a6e41ed8691587734eee35acd8952" translate="yes" xml:space="preserve">
          <source>It is now prohibited to replace a component instance&amp;rsquo;s root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</source>
          <target state="translated">이제 구성 요소 인스턴스의 루트 $ data를 교체 할 수 없습니다. 이것은 반응성 시스템에서 일부 경우를 방지하고 구성 요소 상태를보다 예측 가능하게 만듭니다 (특히 유형 점검 시스템에서).</target>
        </trans-unit>
        <trans-unit id="7ae415c6af2657c64c911e26e414175ec588acbe" translate="yes" xml:space="preserve">
          <source>It is often a good idea to bind to a style object directly so that the template is cleaner:</source>
          <target state="translated">템플릿이 더 깔끔해 지도록 스타일 객체에 직접 바인딩하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1576748fb05ab8ce1c2e6c48f332f0a5704cb1b7" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the raw &lt;code&gt;data&lt;/code&gt; object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</source>
          <target state="translated">Vue 응용 프로그램에서 진실의 원천은 원시 &lt;code&gt;data&lt;/code&gt; 객체 라는 것을 간과하는 경우가 많습니다 . Vue 인스턴스는 액세스 권한 만 프록시입니다. 따라서 여러 인스턴스가 공유해야하는 상태가있는 경우 ID로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc0742430bf64e7ed852fa2fe5b348a0bbd7e7ff" translate="yes" xml:space="preserve">
          <source>It is often overlooked that the source of truth in Vue applications is the reactive &lt;code&gt;data&lt;/code&gt; object - a component instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can use a &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; method to make an object reactive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5941b8bede80f37fd666d64ae0a8585594d8e00a" translate="yes" xml:space="preserve">
          <source>It is possible to add a new property directly to the component instance without including it in &lt;code&gt;data&lt;/code&gt;. However, because this property isn't backed by the reactive &lt;code&gt;$data&lt;/code&gt; object, it won't automatically be tracked by &lt;a href=&quot;reactivity&quot;&gt;Vue's reactivity system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37285a48f031be7bbbf86e2ffcd3313292517a4b" translate="yes" xml:space="preserve">
          <source>It is recommended to avoid using both on the same element due to the syntax ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751efadc9528a2e4327d95ba9475fe587b4ec316" translate="yes" xml:space="preserve">
          <source>It is recommended to define all emitted events in order to better document how a component should work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c09ac650c82070b83c3fbdfde0270b1b2629a2" translate="yes" xml:space="preserve">
          <source>It is recommended to provide a &lt;code&gt;key&lt;/code&gt; attribute with &lt;code&gt;v-for&lt;/code&gt; whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</source>
          <target state="translated">반복 된 DOM 컨텐츠가 단순하지 않거나 성능 향상을 위해 기본 동작에 의도적으로 의존하지 않는 한 가능하면 &lt;code&gt;v-for&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 속성 을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9f05d3baca3585e87a234c817a735dc07843bbe4" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode (opens new window)&lt;/a&gt; with our official extension &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=octref.vetur&quot;&gt;Vetur (opens new window)&lt;/a&gt;, which provides comprehensive IDE support for Vue 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7779dc053f2ed486b907c53be703697ec71f15b" translate="yes" xml:space="preserve">
          <source>It is recommended to use landmark HTML elements with redundant landmark role attributes in order to maximize compatibility with legacy &lt;a href=&quot;https://caniuse.com/#feat=html5semantic&quot;&gt;browsers that don&amp;rsquo;t support HTML5 semantic elements (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158301256c28a9020989b897a8c306e76ca398cb" translate="yes" xml:space="preserve">
          <source>It mostly works well, but the delayed state updates can cause strange behavior. For example, click on the &lt;code&gt;Result&lt;/code&gt; tab and try entering &lt;code&gt;9.999&lt;/code&gt; into one of those inputs. When the input loses focus, its value will update to &lt;code&gt;$10.00&lt;/code&gt;. When looking at the calculated total however, you&amp;rsquo;ll see that &lt;code&gt;9.999&lt;/code&gt; is what&amp;rsquo;s stored in our data. The version of reality that the user sees is out of sync!</source>
          <target state="translated">대부분 잘 작동하지만 지연된 상태 업데이트로 인해 이상한 동작이 발생할 수 있습니다. 예를 들어 &lt;code&gt;Result&lt;/code&gt; 탭을 클릭하고 해당 입력 중 하나에 &lt;code&gt;9.999&lt;/code&gt; 를 입력하십시오. 입력에 포커스가 없으면 값이 &lt;code&gt;$10.00&lt;/code&gt; 업데이트됩니다 . 그러나 계산 된 총계를 보면 &lt;code&gt;9.999&lt;/code&gt; 가 데이터에 저장되어 있음을 알 수 있습니다. 사용자가 보는 현실의 버전이 동기화되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="5c7b220831f2244cc3f3b0618d0e11be1b6ee123" translate="yes" xml:space="preserve">
          <source>It only offers a single template that assumes you&amp;rsquo;re building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</source>
          <target state="translated">Vue는 다양한 목적과 빌드 시스템을위한 광범위한 기본 옵션을 제공하는 반면, 단일 페이지 애플리케이션을 구축한다고 가정하는 단일 템플릿 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d429d77b592d7a12031c03e84167b80ce44e01ac" translate="yes" xml:space="preserve">
          <source>It requires saving the &lt;code&gt;picker&lt;/code&gt; to the component instance, when it&amp;rsquo;s possible that only lifecycle hooks need access to it. This isn&amp;rsquo;t terrible, but it could be considered clutter.</source>
          <target state="translated">수명주기 후크 만 액세스 할 수있는 경우 &lt;code&gt;picker&lt;/code&gt; 를 컴포넌트 인스턴스에 저장 해야합니다. 이것은 끔찍하지는 않지만 혼란으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4498754208578dfe241aa59ce513436b21cdefe3" translate="yes" xml:space="preserve">
          <source>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c27ec712f1c3f7f2e2036cb2ee97cb69409b690" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;these limitations do &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6375c65084a2fbe49aa4574ab7168511258809" translate="yes" xml:space="preserve">
          <source>It should be noted that &lt;strong&gt;this limitation does &lt;em&gt;not&lt;/em&gt; apply if you are using string templates from one of the following sources&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;다음 소스 중 하나에서 문자열 템플리트를 사용&lt;/strong&gt; 하는 &lt;strong&gt;경우이 제한 사항이 적용 되지 &lt;em&gt;않습니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="59833298d090a415397bceadf5ff0bd3a66b0de9" translate="yes" xml:space="preserve">
          <source>It will render:</source>
          <target state="translated">렌더링됩니다 :</target>
        </trans-unit>
        <trans-unit id="13566b680265d72cb595dc1be3858a3b3f978e1f" translate="yes" xml:space="preserve">
          <source>It would be much nicer if we could collocate code related to the same logical concern. And this is exactly what the Composition API enables us to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8131a6805d411d3c8871b6a4ec5d84d6d47f8b3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually possible to transition between any number of elements, either by using multiple &lt;code&gt;v-if&lt;/code&gt;s or binding a single element to a dynamic property. For example:</source>
          <target state="translated">실제로 여러 &lt;code&gt;v-if&lt;/code&gt; 를 사용 하거나 단일 요소를 동적 속성에 바인딩 하여 여러 요소 간을 전환 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f0eec334e7b1ca80024f1af665b1bef3cd4f2a0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also a good idea to explicitly add &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="translated">Vue가 CSS 감지를 건너 뛸 수 있도록 JavaScript 전용 전환 에 &lt;code&gt;v-bind:css=&quot;false&quot;&lt;/code&gt; 를 명시 적으로 추가하는 것도 좋습니다 . 또한 CSS 규칙이 실수로 전환을 방해하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="ea8bac071f56eff3c599037448c4745e3f78f107" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common for an app to be organized into a tree of nested components:</source>
          <target state="translated">앱이 중첩 된 구성 요소 트리로 구성되는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="529381524bf490d0fa30c365c3a6643e1ab87406" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="translated">HTML 템플릿을 스키밍하여 JS 코드 내에서 핸들러 함수 구현을보다 쉽게 ​​찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb4d6d25e874e731b1a5bd3fcf3592c111ac7d3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to toggle the presence of an element, too:</source>
          <target state="translated">요소의 존재를 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a1b4e2622ff4412a28418661a05714360fa046" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project&amp;rsquo;s needs are very simple and you never need to &amp;ldquo;eject&amp;rdquo; to customize your build process, you&amp;rsquo;ll be able to update it as a dependency. You can read more about the &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;differing philosophy here&lt;/a&gt;.</source>
          <target state="translated">이러한 제한 사항 중 상당수는 create-react-app 팀이 의도적으로 디자인 한 결정이며 이점이 있다는 점에 유의해야합니다. 예를 들어, 프로젝트의 요구가 매우 단순하고 빌드 프로세스를 사용자 정의하기 위해 &quot;배출&quot;할 필요가 없다면 프로젝트를 종속성으로 업데이트 할 수 있습니다. &lt;a href=&quot;https://github.com/facebookincubator/create-react-app#philosophy&quot;&gt;다른 철학&lt;/a&gt; 에 대한 자세한 내용은 여기를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eba37741216bb34acb503b7bccb11a46196d44f7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="translated">액션에서 원래 상태 객체를 절대 바꾸지 말아야한다는 점에 유의해야합니다. 구성 요소와 상점은 돌연변이를 관찰하기 위해 동일한 객체에 대한 참조를 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="471a1dd215ec1df9cced88727c09d955351467bb" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="translated">전역 구성 요소가 JavaScript에서 참조되는 경우는 거의 없으므로 JavaScript 규칙을 따르는 것이 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dbbee3b3142d705f32e4ea9a33d016015abd4b0" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to wrap the entire contents in a new element, like this:</source>
          <target state="translated">다음과 같이 전체 내용을 새 요소로 묶는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb69fc29789fe29cf276273312bfe243527744c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can use &lt;code&gt;$emit&lt;/code&gt;&amp;lsquo;s 2nd parameter to provide this value:</source>
          <target state="translated">이벤트와 함께 특정 값을 생성하는 것이 유용한 경우가 있습니다. 예를 들어, &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소가 텍스트를 얼마나 크게 확대 할 것인지를 담당 할 수 있습니다. 이 경우 &lt;code&gt;$emit&lt;/code&gt; 의 두 번째 매개 변수를 사용하여이 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8852ff75403c297afd1a8a3cdb0552cf73fe06bf" translate="yes" xml:space="preserve">
          <source>It's actually possible to transition between any number of elements, either by using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt; or binding a single element to a dynamic property. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad47c16fba81b79a86241bf8888fad85c94ce363" translate="yes" xml:space="preserve">
          <source>It's common for an app to be organized into a tree of nested components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af319375896cfcb2ac29299a5aeee693d621695" translate="yes" xml:space="preserve">
          <source>It's easier to locate the handler function implementations within your JS code by skimming the HTML template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17ba0c11ce9ca8328a5aebef189aaa88d9ead34" translate="yes" xml:space="preserve">
          <source>It's easy to toggle the presence of an element, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5cd7c29493393f218043384194d7b5510c8dde1" translate="yes" xml:space="preserve">
          <source>It's generally recommended to keep directives independent of the component instance they are used in. Accessing the instance from within a custom directive is often a sign that the directive should rather be a component itself. However, there are situations where this actually makes sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f29b81017a607c886e9905a378f2d9bd55f8c75" translate="yes" xml:space="preserve">
          <source>It's important to note the runtime config only affects runtime template compilation - it won't affect pre-compiled templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd4ae770137b3e9b3a6d876b8827f3129a2fcc" translate="yes" xml:space="preserve">
          <source>It's much more common for a component to use &lt;code&gt;props&lt;/code&gt; than the other properties, and very often a component uses only &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aebac3eeeb53ba07a891673ff03acf90d6ccc73e" translate="yes" xml:space="preserve">
          <source>It's now much clearer what the difference between these states is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a696ed981dd37807dbf8cb59239f76cfd4a209" translate="yes" xml:space="preserve">
          <source>It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320f04e4adc498746e8285c25d0174bb0a242c0d" translate="yes" xml:space="preserve">
          <source>It's sometimes useful to emit a specific value with an event. For example, we may want the &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component to be in charge of how much to enlarge the text by. In those cases, we can pass a second parameter to &lt;code&gt;$emit&lt;/code&gt; to provide this value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7d46141f064bc144bcd65cad47e0b1500c6ec5" translate="yes" xml:space="preserve">
          <source>Iteration &amp;amp; Communication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab84ddacf62192827bb778b54f0d73df28c81a56" translate="yes" xml:space="preserve">
          <source>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51cc248e464b2aea646387386136d3ee2f3468fd" translate="yes" xml:space="preserve">
          <source>JAWS (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="acc00892c117ef61e4f9ab3d9331cb95e0f00caa" translate="yes" xml:space="preserve">
          <source>JSX vs Templates</source>
          <target state="translated">JSX 대 템플릿</target>
        </trans-unit>
        <trans-unit id="48785657daead33de8f57e1fb9950e0b74a5ba21" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6da78717be0e5457a235494d2556f25b2595f3" translate="yes" xml:space="preserve">
          <source>JavaScript Hooks</source>
          <target state="translated">자바 스크립트 훅</target>
        </trans-unit>
        <trans-unit id="6cea98e1f2bba3a82d53ff16b1849c803f2e2665" translate="yes" xml:space="preserve">
          <source>JavaScript doesn&amp;rsquo;t usually work like this -- If we were to write something comparable in JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bdc615d0b1e25db680b5ea62ca160d5e24612e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s native &lt;code&gt;.filter&lt;/code&gt; can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</source>
          <target state="translated">계산 된 속성 내에서 JavaScript의 모든 기능에 액세스 할 수 있으므로 JavaScript의 기본 &lt;code&gt;.filter&lt;/code&gt; 는 훨씬 더 복잡한 필터링 작업을 관리 할 수도 있습니다. 예를 들어, 모든 활성 사용자를 찾으려고 대소 문자를 구분하여 이름과 이메일을 모두 일치 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c7afff3f789cd350ad5ef2e0ccd58b4b677f1d64" translate="yes" xml:space="preserve">
          <source>Jest</source>
          <target state="translated">Jest</target>
        </trans-unit>
        <trans-unit id="a46d5413cffceb72c83f4112df056475b52ee003" translate="yes" xml:space="preserve">
          <source>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4bdcf0feb91c266b9ddb8530b4392dc9b7e35e" translate="yes" xml:space="preserve">
          <source>Join the Vue.js Community!</source>
          <target state="translated">Vue.js 커뮤니티에 가입하십시오!</target>
        </trans-unit>
        <trans-unit id="b05d0122984642cf7090c52ffdac8dd94d5f6d18" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;resolveDynamicComponent&lt;/code&gt; supports passing a component name, an HTML element name, or a component options object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b48b329205efd9bbd9fce3544a036c29c0a8fa" translate="yes" xml:space="preserve">
          <source>Just like all other properties of the component instance, the &lt;code&gt;methods&lt;/code&gt; are accessible from within the component's template. Inside a template they are most commonly used as event listeners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa1596972789e18182ccfc21abdfcfd9e0ff36e" translate="yes" xml:space="preserve">
          <source>Just like how we set up a watcher on the &lt;code&gt;user&lt;/code&gt; property inside our component using the &lt;code&gt;watch&lt;/code&gt; option, we can do the same using the &lt;code&gt;watch&lt;/code&gt; function imported from Vue. It accepts 3 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cbea5eb9c474841bbd881e5ab4ec7c34f644ee" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it&amp;rsquo;s often useful to be able to pass content to a component, like this:</source>
          <target state="translated">HTML 요소와 마찬가지로 다음과 같이 콘텐츠를 구성 요소에 전달할 수있는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98b5180199c5ab496bb93100cd4afe9c3a4168f" translate="yes" xml:space="preserve">
          <source>Just like with HTML elements, it's often useful to be able to pass content to a component, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027fca0ba6266bff1583f80f2ced47d62346398f" translate="yes" xml:space="preserve">
          <source>Just to support relatively little markup in a template:</source>
          <target state="translated">템플릿에서 상대적으로 적은 마크 업을 지원하려면 :</target>
        </trans-unit>
        <trans-unit id="ba65d86ead17c56d628584a8788a419c56876378" translate="yes" xml:space="preserve">
          <source>Keep in mind that we've only scratched the surface of Composition API and what it allows us to do. To learn more about it, refer to the in-depth guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66c8dcebdd2226f233aec952c13c29103045708" translate="yes" xml:space="preserve">
          <source>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; component and when &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; appears within that, it should only render markers that fall within that region:</source>
          <target state="translated">그러나이 패턴으로 제작 된 구성 요소는 여전히 취약합니다. 예를 들어 새로운 &lt;code&gt;&amp;lt;google-map-region&amp;gt;&lt;/code&gt; 구성 요소를 추가하고 그 안에 &lt;code&gt;&amp;lt;google-map-markers&amp;gt;&lt;/code&gt; 가 표시되면 해당 지역 내에있는 마커 만 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="467e7f276ee2b9a2f53b3949e288efde8bd26ea9" translate="yes" xml:space="preserve">
          <source>Key Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da44efd57019ab966f7e6f60ef152a26f453f56" translate="yes" xml:space="preserve">
          <source>Key Codes</source>
          <target state="translated">키 코드</target>
        </trans-unit>
        <trans-unit id="c2970ed4e4bcc1bc09ed400bc881c877da7aa156" translate="yes" xml:space="preserve">
          <source>Key Modifiers</source>
          <target state="translated">키 수정 자</target>
        </trans-unit>
        <trans-unit id="6c5f93229012cbadeede1c515b6352e435db9e2b" translate="yes" xml:space="preserve">
          <source>KeyCode Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3436c44b271fc9f4ddc4a5694abe70d414be31" translate="yes" xml:space="preserve">
          <source>Keyed &lt;code&gt;v-for&lt;/code&gt;&lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">키 입력 &lt;code&gt;v-for&lt;/code&gt; &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c75c97df0a3fadad8262ee8e7d09b174b5374e8e" translate="yes" xml:space="preserve">
          <source>Keyed v-for</source>
          <target state="translated">키형 v-for</target>
        </trans-unit>
        <trans-unit id="9cf20628a323dc6f8efd78ac79c3f26ce8cbd3a6" translate="yes" xml:space="preserve">
          <source>Keys:</source>
          <target state="translated">Keys:</target>
        </trans-unit>
        <trans-unit id="bb23b6faea770d3a5e16178dbc59584678b24aa0" translate="yes" xml:space="preserve">
          <source>Knockout</source>
          <target state="translated">Knockout</target>
        </trans-unit>
        <trans-unit id="bc0968409752cc62e7fa235b2d725b7b8c2c6eb5" translate="yes" xml:space="preserve">
          <source>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue&amp;rsquo;s. Its &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;browser support&lt;/a&gt; is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</source>
          <target state="translated">녹아웃은 MVVM 및 종속성 추적 공간의 선구자였으며 반응성 시스템은 Vue와 매우 유사합니다. 자사의 &lt;a href=&quot;http://knockoutjs.com/documentation/browser-support.html&quot;&gt;브라우저 지원은&lt;/a&gt; IE6에 대한 지원 다시와는 않습니다 모든 것을 고려도 매우 인상적입니다! 반면 Vue는 IE9 + 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="e61cef41ba854e90306988f5c1e5bd34137d6595" translate="yes" xml:space="preserve">
          <source>Labels are typically placed on top or to the left of the form fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24edb29b6ba5554a247bb7953f4370fb8f7aae0" translate="yes" xml:space="preserve">
          <source>Landmark Purpose</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626b6c1d454d11a862220dbe8b7b34d0bcd6de9d" translate="yes" xml:space="preserve">
          <source>Landmarks</source>
          <target state="translated">Landmarks</target>
        </trans-unit>
        <trans-unit id="ec1be2a3865871adce929dfefc2959c96918a558" translate="yes" xml:space="preserve">
          <source>Landmarks provide programmatic access to sections within an application. Users who rely on assistive technology can navigate to each section of the application and skip over content. You can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles&quot;&gt;ARIA roles (opens new window)&lt;/a&gt; to help you achieve this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d8aa2835fc3129b6920d079159549c156fa63c" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex&lt;/a&gt;: our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging&lt;/a&gt;.</source>
          <target state="translated">많은 응용 프로그램에 분산 된 여러 상태 조각과 그 사이의 상호 작용으로 인해 대규모 응용 프로그램이 복잡해질 수 있습니다. 이 문제를 해결하기 위해 Vue는 자체 Elm에서 영감을받은 상태 관리 라이브러리 인 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;vuex를&lt;/a&gt; 제공합니다 . 또한 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools에&lt;/a&gt; 통합되어 &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;시간 이동 디버깅에&lt;/a&gt; 대한 제로 설정 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="af32dbeca45c38e1ab5bbca67861fc2b513411a7" translate="yes" xml:space="preserve">
          <source>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers &lt;a href=&quot;https://next.vuex.vuejs.org/&quot;&gt;Vuex (opens new window)&lt;/a&gt;, our own Elm-inspired state management library. It even integrates into &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;vue-devtools (opens new window)&lt;/a&gt;, providing zero-setup access to &lt;a href=&quot;https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif&quot;&gt;time travel debugging (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72406d3bbbb2f67e5c1e70370160f257ae0ba129" translate="yes" xml:space="preserve">
          <source>Lastly, the styling in Vue&amp;rsquo;s single-file components is very flexible. Through &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader&lt;/a&gt;, you can use any preprocessor, post-processor, and even deep integration with &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS Modules&lt;/a&gt; &amp;ndash; all within the &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">마지막으로 Vue의 단일 파일 구성 요소의 스타일은 매우 유연합니다. &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;vue-loader를&lt;/a&gt; 통해 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 요소 내에서 모든 전 처리기, 후 처리기 및 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; 과의 긴밀한 통합을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c1e35e7e7dfbb463a1648c90eafb0e342703312" translate="yes" xml:space="preserve">
          <source>Latest stable version: 2.6.10</source>
          <target state="translated">최신 안정 버전 : 2.6.10</target>
        </trans-unit>
        <trans-unit id="25f41560444b01511b3f085284b9287b245c68e3" translate="yes" xml:space="preserve">
          <source>Latest version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc4535d8b22b1a2065eb7b3e8da9f8806324bc4" translate="yes" xml:space="preserve">
          <source>Learn how to use teleport with a free lesson on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0c59519c5e2b5fe13b0f7ff4bf498d719b4a7e" translate="yes" xml:space="preserve">
          <source>Learn more about dependency injection in &lt;a href=&quot;../api/index#provide-inject&quot;&gt;the API doc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/index#provide-inject&quot;&gt;API doc&lt;/a&gt; 에서 의존성 주입에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="13b64b875178e4752802d8b808be11083d0726fa" translate="yes" xml:space="preserve">
          <source>Learning Curve</source>
          <target state="translated">학습 곡선</target>
        </trans-unit>
        <trans-unit id="c8de89461bb526135e97877a49d087c4f8f53917" translate="yes" xml:space="preserve">
          <source>Leaves prod/dev branches with &lt;code&gt;process.env.NODE_ENV guards&lt;/code&gt; (must be replaced by bundler)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fa6a52f9f95d2228d742b21a7f9256e534287a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add &lt;code&gt;setup&lt;/code&gt; to our component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d915f196841018fe83a9580c35cc5af5850df5c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add it to our &lt;code&gt;setup&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccfd80d1c7d66dca3a0e6fc501777ae369d0d15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s dive into a simple example where a &lt;code&gt;render&lt;/code&gt; function would be practical. Say you want to generate anchored headings:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 기능이 유용한 간단한 예제를 살펴 보겠습니다 . 고정 된 표제를 생성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="17834c351c272bdff2a7fbc013f9102fea710211" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s imagine that in our app, we have a view to show a list of repositories of a certain user. On top of that, we want to apply search and filter capabilities. Our component handling this view could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97599b335f4e992e78c12be5dd024497eba4df8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move our search functionality into &lt;code&gt;setup&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae601ac39b42a0ce2f774ed4c117e44fb796a7c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a list of todos:</source>
          <target state="translated">할 일 목록이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="a0a681ce0e5b2dc3f8e587da2d3c87e6868974b2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="translated">고정 위치를 사용하여 페이지에 요소를 고정 할 수있는 사용자 지정 지시문을 만들고 싶다고 가정 해 보겠습니다. 다음과 같이 값이 수직 위치를 픽셀 단위로 업데이트하는 사용자 지정 지시문을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a858d496553eddcff13ca95af4e5a9c35dff1f6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you&amp;rsquo;re building a file directory tree, like in Finder or File Explorer. You might have a &lt;code&gt;tree-folder&lt;/code&gt; component with this template:</source>
          <target state="translated">Finder 또는 File Explorer와 같은 파일 디렉토리 트리를 작성한다고 가정 해 봅시다. 이 템플릿이 있는 &lt;code&gt;tree-folder&lt;/code&gt; 구성 요소 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c99d3d3fdfa8bd3e1baa14373a303cb25022aea" translate="yes" xml:space="preserve">
          <source>Let's assume that we want to rewrite the following code, which contains a &lt;code&gt;MyMap&lt;/code&gt; component that provides a &lt;code&gt;MyMarker&lt;/code&gt; component with the user's location, using the Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad199543d13fb602b1787ea12617af19cdac14b3" translate="yes" xml:space="preserve">
          <source>Let's begin by setting up the plugin object. It is recommended to create it in a separate file and export it, as shown below to keep the logic contained and separate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a4107dc8befffcdc08d9bfc4c038af7438f2a1" translate="yes" xml:space="preserve">
          <source>Let's create an example custom modifier, &lt;code&gt;capitalize&lt;/code&gt;, that capitalizes the first letter of the string provided by the &lt;code&gt;v-model&lt;/code&gt; binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efaf7a4338ac2db9e77c15bcbe109038634f1e0" translate="yes" xml:space="preserve">
          <source>Let's dive deeper into how each argument can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965ee87d9a7fdfe5a2fefa407fc1fd4f95ef4d94" translate="yes" xml:space="preserve">
          <source>Let's dive into an example where a &lt;code&gt;render()&lt;/code&gt; function would be practical. Say we want to generate anchored headings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042f68db1406bc20e0022ac27f2ee63637a48856" translate="yes" xml:space="preserve">
          <source>Let's look at this search field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3b719b12c1068d11a2e6d04fa1b3077e20bd35b" translate="yes" xml:space="preserve">
          <source>Let's modify our &lt;code&gt;modal-button&lt;/code&gt; to use &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; and tell Vue &quot;&lt;strong&gt;teleport&lt;/strong&gt; this HTML &lt;strong&gt;to&lt;/strong&gt; the &quot;&lt;strong&gt;body&lt;/strong&gt;&quot; tag&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098aabc545a2bc27663da4a434b6c0b7fe35c63e" translate="yes" xml:space="preserve">
          <source>Let's say you have a list of todos:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3669759690ca7d10550e7dab45e8ba8a6d06189" translate="yes" xml:space="preserve">
          <source>Let's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16967b5d529c071e7c31b4b0d1d25c9f1bdbe5b1" translate="yes" xml:space="preserve">
          <source>Let's take a look at &lt;code&gt;modal-button&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67530659cbfc12250ac15b4825a7142987ed4730" translate="yes" xml:space="preserve">
          <source>Library Authors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="963a6d001df804654ef3a7108a4f994e4ad3043d" translate="yes" xml:space="preserve">
          <source>Lifecycle Diagram</source>
          <target state="translated">라이프 사이클 다이어그램</target>
        </trans-unit>
        <trans-unit id="2404fc2fb7f08994c22ba2e88d94f0289f80699e" translate="yes" xml:space="preserve">
          <source>Lifecycle Events (in the order they are called)</source>
          <target state="translated">수명주기 이벤트 (호출 된 순서대로)</target>
        </trans-unit>
        <trans-unit id="e15c95b3b57b4bc9945881310c2f7fa52f895a6d" translate="yes" xml:space="preserve">
          <source>Lifecycle Hook Registration Inside &lt;code&gt;setup&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">수명주기 후크</target>
        </trans-unit>
        <trans-unit id="37857eb2e2aa8efab7a0ac716f62d18f83e34871" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76af71af244f2f6db8f83760d5be272f79f446b" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks can be registered with directly-imported &lt;code&gt;onX&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260f808c2d6d1ca9299afb5f45b0231a77889ebf" translate="yes" xml:space="preserve">
          <source>Lighthouse (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47cbdd94a999f599791f292c086fca7922c6de4" translate="yes" xml:space="preserve">
          <source>Like components and props, event names provide an automatic case transformation. If you emit an event from the child component in camel case, you will be able to add a kebab-cased listener in the parent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aded01a7c9673b7fc6a79a471f805a19e31546" translate="yes" xml:space="preserve">
          <source>Likewise for &lt;code&gt;altKey&lt;/code&gt;, &lt;code&gt;shiftKey&lt;/code&gt;, and &lt;code&gt;metaKey&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df77b1e0de2b6983ce6696ce595e7de4eec752e" translate="yes" xml:space="preserve">
          <source>Line Highlighting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="34959794ca38ca0b2f99ab6b512cce0bcb1574fd" translate="yes" xml:space="preserve">
          <source>List Entering/Leaving Transitions</source>
          <target state="translated">진입 / 출발 전환 목록</target>
        </trans-unit>
        <trans-unit id="ec66c1c1aadebafa9aea3a9e5e78a70374186e6e" translate="yes" xml:space="preserve">
          <source>List Move Transitions</source>
          <target state="translated">목록 이동 전환</target>
        </trans-unit>
        <trans-unit id="97c5ac00feef7e4e4dea6fbc37427502208da0a0" translate="yes" xml:space="preserve">
          <source>List Rendering</source>
          <target state="translated">리스트 렌더링</target>
        </trans-unit>
        <trans-unit id="7a1568935f8a040f0ddeb7118a253e76a0ba1ee0" translate="yes" xml:space="preserve">
          <source>List Rendering - &lt;code&gt;v-for&lt;/code&gt; with &lt;code&gt;v-if&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b44b03037bd0f155ca305c63ebd74b1d0758424" translate="yes" xml:space="preserve">
          <source>List Rendering - Displaying Filtered/Sorted Results</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014a81574bf11dd8c3a37e832221bd011f6da627" translate="yes" xml:space="preserve">
          <source>List Rendering: Maintaining State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a9aa57e0afea8cd99a3f75a8c6d3489f047106" translate="yes" xml:space="preserve">
          <source>List Transitions</source>
          <target state="translated">전환 목록</target>
        </trans-unit>
        <trans-unit id="78b30713ef8e682cdf6d1254269a44a2a34f3330" translate="yes" xml:space="preserve">
          <source>Listen for a custom event on the current vm. Events can be triggered by &lt;code&gt;vm.$emit&lt;/code&gt;. The callback will receive all the additional arguments passed into these event-triggering methods.</source>
          <target state="translated">현재 VM에서 사용자 지정 이벤트를 수신합니다. &lt;code&gt;vm.$emit&lt;/code&gt; 이벤트를 트리거 할 수 있습니다 . 콜백은 이러한 이벤트 트리거링 메소드에 전달 된 모든 추가 인수를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="e49f77d4075cf41a76ef9beacb50d0f6b9aefcc0" translate="yes" xml:space="preserve">
          <source>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</source>
          <target state="translated">맞춤 이벤트를 수신하지만 한 번만 들어보세요. 리스너는 처음 트리거되면 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="43e6ad0a03b8b1a9446a11f0e19551c8b4dc800d" translate="yes" xml:space="preserve">
          <source>Listen for an event only once with &lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$once(eventName, eventHandler)&lt;/code&gt; 번만 이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="696df6abce8abb54e8cd9a4d788b6b19b808783e" translate="yes" xml:space="preserve">
          <source>Listen for an event with &lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$on(eventName, eventHandler)&lt;/code&gt; 이벤트 수신</target>
        </trans-unit>
        <trans-unit id="2a358a8843be76d3c49082380039fa0679262430" translate="yes" xml:space="preserve">
          <source>Listening for Native Events on Components with &lt;code&gt;v-on&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 이&lt;sup&gt;변경된&lt;/sup&gt; 구성 요소에서 기본 이벤트 수신&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6d24ce075567f8634478a57941ae0b0eecc75979" translate="yes" xml:space="preserve">
          <source>Listening to Child Components Events</source>
          <target state="translated">자식 구성 요소 이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="4068e29f0d00dd78b6cb63522d95b7fd8466fe66" translate="yes" xml:space="preserve">
          <source>Listening to Events</source>
          <target state="translated">이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="a5bab41dbcd17d889c6e2f819506e9dcf076f282" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &quot;my-event&quot; is emitted on the child):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="454c823d312bb21fb3768d64892637753b93fb76" translate="yes" xml:space="preserve">
          <source>Listening to custom events on a child component (the handler is called when &amp;ldquo;my-event&amp;rdquo; is emitted on the child):</source>
          <target state="translated">자식 구성 요소에서 사용자 지정 이벤트 듣기 (핸들러에서 &quot;my-event&quot;가 생성되면 핸들러가 호출 됨) :</target>
        </trans-unit>
        <trans-unit id="8631bfe9aed59c0e3f179ac4e96195bbc6860960" translate="yes" xml:space="preserve">
          <source>Listening to the kebab-cased version will have no effect:</source>
          <target state="translated">케밥 케이스 버전을 듣는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6674c82db55a9741fe74df825e79591da8cece35" translate="yes" xml:space="preserve">
          <source>Loader function does not inherently receive &lt;code&gt;resolve&lt;/code&gt; and &lt;code&gt;reject&lt;/code&gt; arguments and must return a Promise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba43e280bc7445e5b4f1d1db31b10f615d04d7e1" translate="yes" xml:space="preserve">
          <source>Local Registration</source>
          <target state="translated">지역 등록</target>
        </trans-unit>
        <trans-unit id="5aa492ab1eff8abbb7c26a1b8e7859024fe0d373" translate="yes" xml:space="preserve">
          <source>Local Registration in a Module System</source>
          <target state="translated">모듈 시스템에서 로컬 등록</target>
        </trans-unit>
        <trans-unit id="c21bde3b85066869a4def12bbecd2597d5f1d6cf" translate="yes" xml:space="preserve">
          <source>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</source>
          <target state="translated">로직은 이제 프리젠 테이션 레이어와 분리되어 유지 보수 (논리의 변경 / 확장)가 훨씬 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="972ab90613dd62fd50f5c7d4e44d82a2703fc0da" translate="yes" xml:space="preserve">
          <source>MAGic (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9061dc1c4c01489f1dced5faf2e16a1e14bb1c24" translate="yes" xml:space="preserve">
          <source>Magnifier (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba90cc7a29b593100819375e54c2166bf952ca3" translate="yes" xml:space="preserve">
          <source>Maintaining State</source>
          <target state="translated">유지 상태</target>
        </trans-unit>
        <trans-unit id="b0f21a5d13bd1abc123a654d0af01af3751372ba" translate="yes" xml:space="preserve">
          <source>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an &lt;code&gt;Unknown custom element&lt;/code&gt;, assuming that you forgot to register a global component or misspelled a component name.</source>
          <target state="translated">Vue가 Vue 외부에 정의 된 사용자 정의 요소를 무시하도록하십시오 (예 : 웹 컴포넌트 API 사용). 그렇지 않으면 전역 구성 요소 등록을 잊었거나 구성 요소 이름의 철자가 틀렸다는 가정하에 &lt;code&gt;Unknown custom element&lt;/code&gt; 에 대한 경고가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="40cc7de2e3efbc03590e2caf3615a6df24defc19" translate="yes" xml:space="preserve">
          <source>Make an object reactive. Internally, Vue uses this on the object returned by the &lt;code&gt;data&lt;/code&gt; function.</source>
          <target state="translated">반응 형 객체를 만듭니다. 내부적으로 Vue는 &lt;code&gt;data&lt;/code&gt; 함수가 반환 한 객체에서 이것을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7801d7d110e57ae1f3c6effb3b2240aea5dc9f4f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;script&lt;/code&gt; part of the component has TypeScript set as a language:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca710d6ed72907ab1882247d85dafbe4c288636" translate="yes" xml:space="preserve">
          <source>Make sure to read about &lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;the different builds of Vue&lt;/a&gt; and use the &lt;strong&gt;production&lt;br/&gt; version&lt;/strong&gt; in your published site, replacing &lt;code&gt;vue.js&lt;/code&gt; with &lt;code&gt;vue.min.js&lt;/code&gt;. This is a smaller build optimized for speed instead of development experience.</source>
          <target state="translated">&lt;a href=&quot;#Explanation-of-Different-Builds&quot;&gt;vue의 다른 빌드에&lt;/a&gt; 대해 읽고 &lt;code&gt;vue.js&lt;/code&gt; 를 &lt;code&gt;vue.min.js&lt;/code&gt; 로 바꾸어 게시 된 사이트에서 &lt;strong&gt;프로덕션 &lt;br/&gt;버전&lt;/strong&gt; 을 사용하십시오 . 개발 경험 대신 속도에 최적화 된 더 작은 빌드입니다.</target>
        </trans-unit>
        <trans-unit id="e3c022bac6422a256a8effaab478918265d7cabe" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let&amp;rsquo;s do this with the animated integer from our earlier example:</source>
          <target state="translated">많은 상태 전환을 관리하면 Vue 인스턴스 또는 구성 요소의 복잡성이 빠르게 증가 할 수 있습니다. 다행히 많은 애니메이션을 전용 하위 구성 요소로 추출 할 수 있습니다. 이전 예제의 애니메이션 정수를 사용하여이 작업을 수행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="6d84634068387565bc44457e74c1fb936b41ea6b" translate="yes" xml:space="preserve">
          <source>Managing many state transitions can quickly increase the complexity of a component instance. Fortunately, many animations can be extracted out into dedicated child components. Let's do this with the animated integer from our earlier example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3bd17fad3bf74f92a5f858b73034ae0e335d8b" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;global event bus&lt;/a&gt; can be convenient for very simple cases, but are not appropriate for most applications. Vuex offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes.</source>
          <target state="translated">&lt;code&gt;this.$root&lt;/code&gt; 및 / 또는 &lt;a href=&quot;../guide/migration#dispatch-and-broadcast-replaced&quot;&gt;전역 이벤트 버스를&lt;/a&gt; 사용하여 상태를 관리 하는 것은 매우 간단한 경우에 편리 할 수 ​​있지만 대부분의 응용 프로그램에는 적합하지 않습니다. Vuex는 상태를 관리하기위한 중앙 위치뿐만 아니라 상태 변경을 구성, 추적 및 디버깅하기위한 도구도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="345f632fb618327d0737b3e43648e569b92b65d3" translate="yes" xml:space="preserve">
          <source>Managing state on &lt;code&gt;this.$root&lt;/code&gt; and/or using a global event bus can be convenient for very simple cases, but it is not appropriate for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ce6aa2bb23c0ea42fa8eff08fdeb57d8d46f86" translate="yes" xml:space="preserve">
          <source>Manipulate children, props, or data before passing them on to a child component</source>
          <target state="translated">자식, 소품 또는 데이터를 자식 구성 요소로 전달하기 전에 조작</target>
        </trans-unit>
        <trans-unit id="ef483ab0b23465192e501c234b66b1aaf6d75a30" translate="yes" xml:space="preserve">
          <source>Many JS libraries like GreenSock will assume you want hardware acceleration and will apply them by default, so you do not need to set them manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94450504feac5b15b4e2b00b870ff24df0d15b30" translate="yes" xml:space="preserve">
          <source>Many files with similar names, making rapid file switching in code editors more difficult.</source>
          <target state="translated">이름이 비슷한 파일이 많기 때문에 코드 편집기에서 파일을 빠르게 전환하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e9845a3a28b614ba4d1f3f00fed1ceb01c5a0858" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor&amp;rsquo;s sidebar.</source>
          <target state="translated">중첩 된 하위 디렉토리가 많으므로 편집기의 사이드 바에서 구성 요소를 찾아 보는 시간이 길어집니다.</target>
        </trans-unit>
        <trans-unit id="16185e750a239f48af50dd807d021ebe27373d96" translate="yes" xml:space="preserve">
          <source>Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871f71bb96ca0bb4e5791c4ef660e24c2c568ffe" translate="yes" xml:space="preserve">
          <source>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt; and they tend to be used very frequently across your components.</source>
          <target state="translated">대부분의 구성 요소는 비교적 일반적이며 입력 또는 단추와 같은 요소 만 래핑 할 수 있습니다. 때때로 이러한 &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;구성 요소&lt;/a&gt; 를 기본 구성 요소라고 하며 구성 요소 전체에서 매우 자주 사용되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3f90d76037526451c4d4d6a19af05a35509fe8a" translate="yes" xml:space="preserve">
          <source>Mapping an Array to Elements with &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 를 사용하여 배열을 요소에 매핑</target>
        </trans-unit>
        <trans-unit id="985fac5003727ca9f43295099936da1f418deb05" translate="yes" xml:space="preserve">
          <source>Marks an object so that it will never be converted to a proxy. Returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f03a6d54b8b6514c9c14a1dc9c7ad30c6d8ce6b1" translate="yes" xml:space="preserve">
          <source>Meta Instance Methods</source>
          <target state="translated">메타 인스턴스 메소드</target>
        </trans-unit>
        <trans-unit id="2f4694e23c9582e9a5db1045c363b51dfc44e4fe" translate="yes" xml:space="preserve">
          <source>Method Event Handlers</source>
          <target state="translated">메소드 이벤트 핸들러</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="d7d319f93f2d93a0aa10747398e65d855aff93ad" translate="yes" xml:space="preserve">
          <source>Methods called from a template should not have any side effects, such as changing data or triggering asynchronous processes. If you find yourself tempted to do that you should probably use a &lt;a href=&quot;instance#lifecycle-hooks&quot;&gt;lifecycle hook&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7695e9b47d9ba02cf1af67839a1c5a56784566b4" translate="yes" xml:space="preserve">
          <source>Methods in Inline Handlers</source>
          <target state="translated">인라인 핸들러의 메소드</target>
        </trans-unit>
        <trans-unit id="d1290d394bc9cbc272b779c93460593c97002ca1" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the Vue instance.</source>
          <target state="translated">Vue 인스턴스에 혼합 할 메소드입니다. VM 인스턴스에서 이러한 메소드에 직접 액세스하거나 지시문 표현식에 사용할 수 있습니다. 모든 메소드는 &lt;code&gt;this&lt;/code&gt; 컨텍스트가 Vue 인스턴스에 자동으로 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="6fde24be2acb622eb42db4cc92f8e9d97e13fc25" translate="yes" xml:space="preserve">
          <source>Methods to be mixed into the component instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their &lt;code&gt;this&lt;/code&gt; context automatically bound to the component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431ecb390fd9ca8c90c7d10a3d2d7c57e8f24d12" translate="yes" xml:space="preserve">
          <source>Middlewares &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">미들웨어 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a7c29497fcc9380f26664db064158964ed034b2e" translate="yes" xml:space="preserve">
          <source>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</source>
          <target state="translated">미들웨어는 플러그인으로 대체됩니다. 플러그인은 상점을 유일한 인수로 수신하고 상점에서 돌연변이 이벤트를 청취 할 수있는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a6b3e991aad9c53aed3b0912de764a87bdc4c052" translate="yes" xml:space="preserve">
          <source>Migration Strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3452a9ee78ce898468e14c739e9cdea57d03f0" translate="yes" xml:space="preserve">
          <source>Migration from Vue 1.x</source>
          <target state="translated">Vue 1.x에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="33235c234b4d4ff968729d9a75b61daade922a4c" translate="yes" xml:space="preserve">
          <source>Migration from Vue Router 0.7.x</source>
          <target state="translated">Vue Router 0.7.x에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="85c2e4a1b81a8d15a3bcd89e26321a5e8bae795c" translate="yes" xml:space="preserve">
          <source>Migration from Vuex 0.6.x to 1.0</source>
          <target state="translated">Vuex 0.6.x에서 1.0으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="27e6c208056129d07214b4839a815039f22c4fbb" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt; includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7041841fb6a16a593419ba9210aa34bce92e8" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$attrs&lt;/code&gt;includes &lt;code&gt;class&lt;/code&gt; &amp;amp; &lt;code&gt;style&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c410c172a6db22b44797723b74a9f97cbe8cbd47" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;$listeners&lt;/code&gt; removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635802e8d697afd466dea0285928d4c2564eeacf" translate="yes" xml:space="preserve">
          <source>Migration guide - &lt;code&gt;.native&lt;/code&gt; modifier removed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0b41dde0e20543a039acd14df0e338cbee9d6" translate="yes" xml:space="preserve">
          <source>Migration guide - Changes in the Render Functions API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5be8322a9bb8f637fd7d36053e4e1060c3e536" translate="yes" xml:space="preserve">
          <source>Migration guide - New Emits Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2363ce7759901b489bcaeaac53540d1809dbe21" translate="yes" xml:space="preserve">
          <source>Migration: Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a893ece8e469a3ca3d935c49f41d08d04b75ecc" translate="yes" xml:space="preserve">
          <source>Misc</source>
          <target state="translated">Misc</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="01468459ec2045f5366f9299c5e3667f7a39c98e" translate="yes" xml:space="preserve">
          <source>Mixin Merge Behavior Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ce9269c79d7b84814a50d956fd29f09b1efb47" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component&amp;rsquo;s own hooks.</source>
          <target state="translated">믹스 인 후크는 제공된 순서대로 호출되며 구성 요소 자체 후크보다 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="696c1c53029e4a11c64d6af9a07cc08ca71e59d3" translate="yes" xml:space="preserve">
          <source>Mixin hooks are called in the order they are provided, and called before the component's own hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="06fc764968134bc875ae2b80299dfa521ccaf9ca" translate="yes" xml:space="preserve">
          <source>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &amp;ldquo;mixed&amp;rdquo; into the component&amp;rsquo;s own options.</source>
          <target state="translated">Mixin은 Vue 구성 요소에 재사용 가능한 기능을 배포하는 유연한 방법입니다. mixin 객체는 모든 컴포넌트 옵션을 포함 할 수 있습니다. 컴포넌트가 믹스 인을 사용하면 믹스 인의 모든 옵션이 컴포넌트 자체 옵션에 &quot;혼합&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="41c21dcea103087b7aa285323c1c82e7014cf7e0" translate="yes" xml:space="preserve">
          <source>Mixins are conflict-prone: Since properties from each feature are merged into the same component, you still have to know about every other feature to avoid property name conflicts and for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f849d0cf8da656a7c4361043b523a5ce2e1fc1e" translate="yes" xml:space="preserve">
          <source>Mixins distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &quot;mixed&quot; into the component's own options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049a096df6b896be6526afb4fccc301157e04515" translate="yes" xml:space="preserve">
          <source>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you&amp;rsquo;re using that combination and are enjoying it, jumping into Vue is probably the next logical step.</source>
          <target state="translated">MobX는 React 커뮤니티에서 인기를 얻었으며 실제로 Vue와 거의 동일한 반응성 시스템을 사용합니다. 제한된 범위에서 React + MobX 워크 플로는 더 장황한 Vue로 생각할 수 있으므로 해당 조합을 사용하고 즐기고 있다면 Vue로 점프하는 것이 다음 논리적 단계 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="814d5c9075ac58da08deb4e3d88f6089a78f380d" translate="yes" xml:space="preserve">
          <source>Mocha</source>
          <target state="translated">Mocha</target>
        </trans-unit>
        <trans-unit id="20716d7589116671fbeb6c4a74532bdfef915478" translate="yes" xml:space="preserve">
          <source>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f243cbe64caef0641a9876a4078a94f8defc16" translate="yes" xml:space="preserve">
          <source>Modifier Keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91de419c6a3b3cf41aa4545caf2eb8b01499b085" translate="yes" xml:space="preserve">
          <source>Modifier(s)</source>
          <target state="translated">Modifier(s)</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="c78835db37c935d808d9977de5814282ad48b4f6" translate="yes" xml:space="preserve">
          <source>Modifiers Keys:</source>
          <target state="translated">수정 자 키 :</target>
        </trans-unit>
        <trans-unit id="42425619360ca471965f2dfefff097e5132ba384" translate="yes" xml:space="preserve">
          <source>Modifiers added to a component &lt;code&gt;v-model&lt;/code&gt; will be provided to the component via the &lt;code&gt;modelModifiers&lt;/code&gt; prop. In the below example, we have created a component that contains a &lt;code&gt;modelModifiers&lt;/code&gt; prop that defaults to an empty object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9674aab8b56f915029a2d1e586af8120c00891" translate="yes" xml:space="preserve">
          <source>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the &lt;code&gt;.prevent&lt;/code&gt; modifier tells the &lt;code&gt;v-on&lt;/code&gt; directive to call &lt;code&gt;event.preventDefault()&lt;/code&gt; on the triggered event:</source>
          <target state="translated">수정자는 점으로 표시된 특수한 접미사로, 지시문이 특별한 방식으로 바인딩되어야 함을 나타냅니다. 예를 들어, &lt;code&gt;.prevent&lt;/code&gt; 수정자는 &lt;code&gt;v-on&lt;/code&gt; 지시문에 트리거 된 이벤트에서 &lt;code&gt;event.preventDefault()&lt;/code&gt; 를 호출 하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="8c585db7d0122a15a54cf6c6876ffe8cc3e86e63" translate="yes" xml:space="preserve">
          <source>Module Systems</source>
          <target state="translated">모듈 시스템</target>
        </trans-unit>
        <trans-unit id="2333c18157c24df8052238f52f365426ca0dbb73" translate="yes" xml:space="preserve">
          <source>Module bundlers like &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack (opens new window)&lt;/a&gt; support &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree-shaking (opens new window)&lt;/a&gt;, which is a fancy term for &amp;ldquo;dead code elimination.&amp;rdquo; Unfortunately, due to how the code is written in previous Vue versions, global APIs like &lt;code&gt;Vue.nextTick()&lt;/code&gt; are not tree-shakeable and will be included in the final bundle regardless of where they are actually used or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d2bd6abfd4bb67af5f7cf3bcc6c49be04098be" translate="yes" xml:space="preserve">
          <source>More mature tooling support. Vue provides official support for &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify&lt;/a&gt;, while Riot relies on community support for build system integration.</source>
          <target state="translated">보다 성숙한 툴링 지원. Vue는 &lt;a href=&quot;https://github.com/vuejs/vue-loader&quot;&gt;webpack&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/vuejs/vueify&quot;&gt;Browserify에&lt;/a&gt; 대한 공식 지원을 제공 하는 반면 Riot은 빌드 시스템 통합에 대한 커뮤니티 지원에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="bd951adc5c3182ed45f637e554b6230120cad548" translate="yes" xml:space="preserve">
          <source>Most of the methods exposed by the application instance return that same instance, allowing for chaining:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51829624f8ae979b2184273f19ad9bb547f0cb2e" translate="yes" xml:space="preserve">
          <source>Most of the time when developing a third-party library we want to build it in a way that allows the consumers of the library to &lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree shake (opens new window)&lt;/a&gt; it. To enable tree-shaking we need to build &lt;code&gt;esm&lt;/code&gt; modules. Since webpack and, in turn, vue-cli do not support building &lt;code&gt;esm&lt;/code&gt; modules we need to rely on &lt;a href=&quot;https://rollupjs.org/&quot;&gt;rollup (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd700564f82afc8781e8c7bd3517f4f9cfa75b4" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI (opens new window)&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac57078adf5d9e220c754f33e3cab2a4c61f61d" translate="yes" xml:space="preserve">
          <source>Most of the tips below are enabled by default if you are using &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI&lt;/a&gt;. This section is only relevant if you are using a custom build setup.</source>
          <target state="translated">&lt;a href=&quot;https://cli.vuejs.org&quot;&gt;Vue CLI를&lt;/a&gt; 사용하는 경우 아래 팁 대부분이 기본적으로 활성화되어 있습니다 . 이 섹션은 사용자 정의 빌드 설정을 사용하는 경우에만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e26a19f206db5f80980c1565b38336a5204a51f" translate="yes" xml:space="preserve">
          <source>Most of the use cases for &lt;code&gt;inline-template&lt;/code&gt; assumes a no-build-tool setup, where all templates are written directly inside the HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6e88abb4082a25af5cddfc16c8063e7092c245" translate="yes" xml:space="preserve">
          <source>Most use cases of mutating a prop can be replaced by one of these options:</source>
          <target state="translated">소품을 변경하는 대부분의 사용 사례는 다음 옵션 중 하나로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c94530449d59bc0026f72f09d5cab721902ce23" translate="yes" xml:space="preserve">
          <source>Mounting App Instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f67e8c3b01357d6a48d990b7305e54d0bf81af" translate="yes" xml:space="preserve">
          <source>Mounts a root component of the application instance on the provided DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6138bafcc1d5e10b1c4ef89a77bfaf9ad800f1" translate="yes" xml:space="preserve">
          <source>Mouse Button Modifiers</source>
          <target state="translated">마우스 버튼 수정 자</target>
        </trans-unit>
        <trans-unit id="6a5aa2d48e5943f597c67e02c2fd245883968d95" translate="yes" xml:space="preserve">
          <source>Much better, isn&amp;rsquo;t it?</source>
          <target state="translated">훨씬 낫지 않습니까?</target>
        </trans-unit>
        <trans-unit id="47ce4ea06250a3aebfb8fdef175fa9bb75c62c5f" translate="yes" xml:space="preserve">
          <source>Much better, isn't it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f57c7776187e52ab80734a4cd047017fdbc252" translate="yes" xml:space="preserve">
          <source>Much like a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; tag, a &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag is only required in templates as a syntactical placeholder and should be discarded when migrating to a &lt;code&gt;render&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62651fa8a2e7b83b1b472f6394d7ec9c1b77f13" translate="yes" xml:space="preserve">
          <source>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a &lt;code&gt;v-slot&lt;/code&gt; directive into a component, like the &lt;code&gt;Hello world!&lt;/code&gt; inside of &lt;code&gt;anchored-heading&lt;/code&gt;, those children are stored on the component instance at &lt;code&gt;$slots.default&lt;/code&gt;. If you haven&amp;rsquo;t already, &lt;strong&gt;it&amp;rsquo;s recommended to read through the &lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;instance properties API&lt;/a&gt; before diving into render functions.&lt;/strong&gt;</source>
          <target state="translated">훨씬 간단합니다! 일종의. 코드는 짧지 만 Vue 인스턴스 속성에 대해 더 잘 알고 있어야합니다. 이 경우 &lt;code&gt;v-slot&lt;/code&gt; 지시문이 없는 자식을 &lt;code&gt;Hello world!&lt;/code&gt; 와 같은 구성 요소로 전달할 때 알아야합니다 ! &lt;code&gt;anchored-heading&lt;/code&gt; 내부 에서 해당 하위 항목은 구성 요소 인스턴스의 &lt;code&gt;$slots.default&lt;/code&gt; 에 저장됩니다 . 아직 작성하지 않은 경우 &lt;strong&gt;렌더 함수에 들어가기 전에 &lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;../api/index#Instance-Properties&quot;&gt;인스턴스 특성 API&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt; 를 읽는 것이 좋습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae7fd6f6c6f4ea4c4eacb2f56da39f0b2fb1a420" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements</source>
          <target state="translated">다중 속성 요소</target>
        </trans-unit>
        <trans-unit id="ceea8f5866781984f4ad8f3e46247846aa62fb94" translate="yes" xml:space="preserve">
          <source>Multi-attribute elements &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">다중 속성 요소를 &lt;sup&gt;적극 권장&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c74c369ff94e794c799780bff5d5ea7fad8ef38a" translate="yes" xml:space="preserve">
          <source>Multi-word component names</source>
          <target state="translated">여러 단어로 된 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="d3d1a8c17e83b5f0002fdfe859df802f2669490e" translate="yes" xml:space="preserve">
          <source>Multi-word component names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">여러 단어로 구성 요소 이름 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0f05bd0026ab6ceb1bb040af8f4b0c24c530607d" translate="yes" xml:space="preserve">
          <source>Multiline text</source>
          <target state="translated">여러 줄 문자</target>
        </trans-unit>
        <trans-unit id="9a85758f90e2757c68d0fceaab52f21c4531a196" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;v-model&lt;/code&gt; bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4871212ed8d1d6698fc58f7b90833df012ebc65c" translate="yes" xml:space="preserve">
          <source>Multiple Event Handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df30563657ae4c69b0249bc2ce91dacff84cf5a3" translate="yes" xml:space="preserve">
          <source>Multiple Sections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6620aef040214a72d3c2e57f8f5384fa762cf0c" translate="yes" xml:space="preserve">
          <source>Multiple Values</source>
          <target state="translated">여러 값</target>
        </trans-unit>
        <trans-unit id="e7051b9f8df86c845f6fca692b6b3cadd5b8a10a" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same Array:</source>
          <target state="translated">동일한 배열에 바인딩 된 여러 확인란 :</target>
        </trans-unit>
        <trans-unit id="ec5f3b4f279a5fac1d619ddd625a66c322263084" translate="yes" xml:space="preserve">
          <source>Multiple checkboxes, bound to the same array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb517cb00682f4c08a606d69d3a2147fe97738f" translate="yes" xml:space="preserve">
          <source>Multiple nodes where only 1 is rendered at a time</source>
          <target state="translated">한 번에 1 만 렌더링되는 여러 노드</target>
        </trans-unit>
        <trans-unit id="e6e9d08847648f1f24b432d66915720d2a3cd5b3" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to Array):</source>
          <target state="translated">다중 선택 (배열에 바인딩) :</target>
        </trans-unit>
        <trans-unit id="ba3eb3692fb6af84e61cce398babaf5e0445cbe0" translate="yes" xml:space="preserve">
          <source>Multiple select (bound to array):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0467cdaf45c60b95eca56ed7e05421c4b98185" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/directives#v-bind&quot;&gt;&lt;code&gt;v-bind&lt;/code&gt; directive&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646b4dd27caf266ac22f395b2a33613ba629a308" translate="yes" xml:space="preserve">
          <source>Mustaches cannot be used inside HTML attributes. Instead, use a &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind directive&lt;/a&gt;:</source>
          <target state="translated">HTML 속성 내에서 콧수염을 사용할 수 없습니다. 대신 &lt;a href=&quot;../api/index#v-bind&quot;&gt;v-bind 지시문을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678c5ab9e821362e494de6bbb3ed5d891d1e67f1" translate="yes" xml:space="preserve">
          <source>Mutating Reactive Properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1ceb98e8d45e6f84a7b372d2bc5ecdc0a979de1" translate="yes" xml:space="preserve">
          <source>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component&amp;rsquo;s local changes will be overwritten.</source>
          <target state="translated">소품을 로컬로 변경하는 것은 이제 반 패턴으로 간주됩니다. 예를 들어 소품을 선언 한 다음 컴포넌트에서 &lt;code&gt;this.myProp = 'someOtherValue'&lt;/code&gt; 를 설정 하십시오. 새로운 렌더링 메커니즘으로 인해 상위 컴포넌트가 다시 렌더링 될 때마다 하위 컴포넌트의 로컬 변경 사항을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="0acccbc6d162746eb3fb69dff7df3fa404b932c2" translate="yes" xml:space="preserve">
          <source>Mutation Methods</source>
          <target state="translated">돌연변이 방법</target>
        </trans-unit>
        <trans-unit id="5f08c22f9167f78491a6ca2175a2bc368b8504f7" translate="yes" xml:space="preserve">
          <source>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;concat()&lt;/code&gt; and &lt;code&gt;slice()&lt;/code&gt;, which do not mutate the original array but &lt;strong&gt;always return a new array&lt;/strong&gt;. When working with non-mutating methods, you can replace the old array with the new one:</source>
          <target state="translated">이름에서 알 수 있듯이 변경 방법은 호출 된 원래 배열을 변경합니다. 이에 비해 원래 배열을 변경하지 않고 &lt;strong&gt;항상 새 배열을 반환하는&lt;/strong&gt; 변경되지 않는 메소드 (예 : &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;concat()&lt;/code&gt; 및 &lt;code&gt;slice()&lt;/code&gt; 있습니다. 비 돌연변이 분석법으로 작업 할 때 기존 배열을 새로운 배열로 교체 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="5d35915fe00d2c128685549b04a6a30f49020050" translate="yes" xml:space="preserve">
          <source>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;. Vue also provides accompanying tools for authoring &lt;a href=&quot;single-file-components&quot;&gt;Single File Components&lt;/a&gt;.</source>
          <target state="translated">Vue로 대규모 응용 프로그램을 구축 할 때 NPM이 권장되는 설치 방법입니다. &lt;a href=&quot;https://webpack.js.org/&quot;&gt;Webpack&lt;/a&gt; 또는 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 모듈 번 들러 와 잘 어울립니다 . Vue는 &lt;a href=&quot;single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 를 작성하기위한 도구도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="69a28f26a2d6401b08eedd57c6a1a5681efe2332" translate="yes" xml:space="preserve">
          <source>NVDA (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39674384c8d92e5f7a36d0d3f3e397a2e95cfa07" translate="yes" xml:space="preserve">
          <source>Name Casing</source>
          <target state="translated">이름 케이싱</target>
        </trans-unit>
        <trans-unit id="0ab2cdaecd6bb74527ceec8c7c8e94dbe4ba99ce" translate="yes" xml:space="preserve">
          <source>Name conflicts (e.g. multiple &lt;code&gt;ButtonDelete.vue&lt;/code&gt; components) make it more difficult to quickly navigate to a specific component in a code editor.</source>
          <target state="translated">이름 충돌 (예 : 여러 &lt;code&gt;ButtonDelete.vue&lt;/code&gt; 구성 요소)을 사용하면 코드 편집기에서 특정 구성 요소를 빠르게 탐색하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="7a6baafc30ef8e96b10f64b5ae02d071b89f11b7" translate="yes" xml:space="preserve">
          <source>Named Slots</source>
          <target state="translated">명명 된 슬롯</target>
        </trans-unit>
        <trans-unit id="ad1343c1fa843d537b321f552fb2d9e3249973f3" translate="yes" xml:space="preserve">
          <source>Named Slots Shorthand</source>
          <target state="translated">명명 된 슬롯 속기</target>
        </trans-unit>
        <trans-unit id="eb77d0a7e3904d77f8e4a7c84a101f0e60e5b947" translate="yes" xml:space="preserve">
          <source>Named Slots with the &lt;code&gt;slot&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; 속성 이있는 명명 된 슬롯</target>
        </trans-unit>
        <trans-unit id="8e9a0bbd092de06c02318f4224dc00dd0e597d4b" translate="yes" xml:space="preserve">
          <source>Native Rendering</source>
          <target state="translated">기본 렌더링</target>
        </trans-unit>
        <trans-unit id="26068455a90075c00bf4839b741d52af3487813b" translate="yes" xml:space="preserve">
          <source>NativeScript</source>
          <target state="translated">NativeScript</target>
        </trans-unit>
        <trans-unit id="1877cf043460c0f80e9625a96954e7851b08330d" translate="yes" xml:space="preserve">
          <source>NativeScript + Vue.js Guide (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f940a2947c24bf59462a669f4fe8ca87501b7ae3" translate="yes" xml:space="preserve">
          <source>NerdeFocus (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826fdcb80bf0630de536146d505abc527b2a01df" translate="yes" xml:space="preserve">
          <source>Nest headings in their ranking order: &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248d641e1dd50d8e9bc4a5ff4268e7392bab4e5d" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper method that explicitly defines async components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1f77c5995cd9dac2e37e8101252626e5271812" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+</source>
          <target state="translated">2.1.0 이상의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="2ebe6a1174c620d032840e985bebc14e9c813501" translate="yes" xml:space="preserve">
          <source>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don&amp;rsquo;t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</source>
          <target state="translated">2.1.0+의 새로운 기능 : 콜백이 제공되지 않고 Promise가 실행 환경에서 지원되는 경우 Promise를 반환합니다. Vue에는 Promise polyfill이 제공되지 않으므로 Promises를 기본적으로 지원하지 않는 브라우저를 대상으로하는 경우 (IE를 보면) polyfill을 직접 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="a23469cb28697e68c77d280bbb32f3803b532a34" translate="yes" xml:space="preserve">
          <source>New in 2.1.4+</source>
          <target state="translated">2.1.4+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="6c6aade3e6584c7a8b32cab964c7a674d3b07efd" translate="yes" xml:space="preserve">
          <source>New in 2.2.0</source>
          <target state="translated">2.2.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="0f9f45aff79e86f97a647ac660d1cac6b64f6ae9" translate="yes" xml:space="preserve">
          <source>New in 2.2.0+</source>
          <target state="translated">2.2.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="0222464ccf0d40a3f2619ea19d32c2ebca8e8947" translate="yes" xml:space="preserve">
          <source>New in 2.3.0+</source>
          <target state="translated">2.3.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="b02f6830ecc8383c4879860f5a1da68ddd041c03" translate="yes" xml:space="preserve">
          <source>New in 2.4.0+</source>
          <target state="translated">2.4.0 이상의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="50e01eb5f080e39b850973e99d037d430ae13836" translate="yes" xml:space="preserve">
          <source>New in 2.5.0+</source>
          <target state="translated">2.5.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="053c4407e09eb77d114f51a7a8bc3d31c0dc62de" translate="yes" xml:space="preserve">
          <source>New in 2.6.0+</source>
          <target state="translated">2.6.0+의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="be41335dc7a0ff9171513e80c9b33fbd4144bd7a" translate="yes" xml:space="preserve">
          <source>New to Vue.js? Check out our &lt;a href=&quot;../../index&quot;&gt;Essentials Guide&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1bc63fa69d5b8906a90d616cc23894236797b1" translate="yes" xml:space="preserve">
          <source>Nightwatch's Official Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce8836503e7153aa1a402805b5adb8e46245b8f" translate="yes" xml:space="preserve">
          <source>Nightwatch.js</source>
          <target state="translated">Nightwatch.js</target>
        </trans-unit>
        <trans-unit id="7fa11e6f2aa3af114b0e34eb2cd5e3891fde04fd" translate="yes" xml:space="preserve">
          <source>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c463bc393dd8ee82390da1c8679bbb86e610abe" translate="yes" xml:space="preserve">
          <source>No longer necessary, since warnings come with stack traces by default now.</source>
          <target state="translated">경고는 현재 기본적으로 스택 추적과 함께 제공되므로 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66c6e5d0b724903ee1ff6e6099b203d955086d1a" translate="yes" xml:space="preserve">
          <source>No real use. If you do happen to rely on this feature somehow and aren&amp;rsquo;t sure how to work around it, post on &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;the forum&lt;/a&gt; for ideas.</source>
          <target state="translated">실제 사용하지 않습니다. 어떻게 든이 기능에 의존하고 해결 방법을 잘 모를 경우 &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;포럼&lt;/a&gt; 에서 아이디어를 게시 하십시오 .</target>
        </trans-unit>
        <trans-unit id="499b8c29716c6bc9380fa29ea0c868d469132ef2" translate="yes" xml:space="preserve">
          <source>Nodes, Trees, and the Virtual DOM</source>
          <target state="translated">노드, 트리 및 가상 DOM</target>
        </trans-unit>
        <trans-unit id="67dbd82660f093394a26b3ae3623994010f0c69e" translate="yes" xml:space="preserve">
          <source>Non-Prop Attributes</source>
          <target state="translated">비영리 속성</target>
        </trans-unit>
        <trans-unit id="3a775c24cf85519f3493a1f3184bcda0bc6bbbc5" translate="yes" xml:space="preserve">
          <source>Non-flux state management</source>
          <target state="translated">비 플럭스 상태 관리</target>
        </trans-unit>
        <trans-unit id="7d2d13e9ec1357ce0a1972e320ea404789b39c3f" translate="yes" xml:space="preserve">
          <source>Non-flux state management &lt;sup&gt;use with caution&lt;/sup&gt;</source>
          <target state="translated">비유동 상태 관리 &lt;sup&gt;사용에주의&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7522eb1254b40f819eb00d0f412303761a8a0ac4" translate="yes" xml:space="preserve">
          <source>Not needed*</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63d0df42b260685a2a9914a2f95611f71b33e28" translate="yes" xml:space="preserve">
          <source>Notable New Features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54aa04fe9a9673dccd2cdb7588ee890d8cbf364d" translate="yes" xml:space="preserve">
          <source>Note every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;strong&gt;uniquely keyed&lt;/strong&gt; for the animations to work properly.</source>
          <target state="translated">애니메이션이 제대로 작동하려면 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 의 모든 자식에 &lt;strong&gt;고유 한 키가&lt;/strong&gt; 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ca49da0909b8a4408a3a2c4586e5b1467d69929a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../api/refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are &lt;a href=&quot;reactivity-fundamentals#ref-unwrapping&quot;&gt;automatically unwrapped&lt;/a&gt; when accessed in the template so you shouldn't use &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc23cd0cef0d3813fd341bfd31bf6563a5bf5c6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;refs-api#ref&quot;&gt;refs&lt;/a&gt; returned from &lt;code&gt;setup&lt;/code&gt; are automatically unwrapped when accessed in the template so there's no need for &lt;code&gt;.value&lt;/code&gt; in templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d9b9321e6ff665ab2980ef004ad4d70ee364dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires the components being switched between to all have names, either using the &lt;code&gt;name&lt;/code&gt; option on a component, or through local/global registration.</source>
          <target state="translated">참고 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 구성 요소를 필요는 사용하거나, 이름 모두 사이가 전환되는 &lt;code&gt;name&lt;/code&gt; 구성 요소에 대한 옵션을, 또는 로컬 / 글로벌 등록을 통해.</target>
        </trans-unit>
        <trans-unit id="f371b641eda948d758990f934853de8872ee227f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;inheritAttrs: false&lt;/code&gt; option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;style&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; bindings.</source>
          <target state="translated">참고 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 옵션은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 영향 &lt;code&gt;style&lt;/code&gt; 과 &lt;code&gt;class&lt;/code&gt; 바인딩.</target>
        </trans-unit>
        <trans-unit id="4865cbc834beecb2b610f666cf562d7362926a15" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;mounted&lt;/code&gt; 않습니다 &lt;strong&gt;되지&lt;/strong&gt; 도 있었다 모든 하위 구성 요소가 장착 된 것을 보장합니다. 당신이 전체 뷰가 렌더링 될 때까지 대기 할 경우 사용할 수있는 &lt;a href=&quot;#vm-nextTick&quot;&gt;VM을 $ nextTick의.&lt;/a&gt; 의 내부 &lt;code&gt;mounted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb05a4351598578542e96c7b1ebb606ca8a12371" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;mounted&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;mounted&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1b05ebbda7e5b2744c6d248de2032ac1d216f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; is not supported on &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;, so if you need to open a link in a new tab, you have to use &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">참고 &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; 이 지원되지 않습니다 &lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt; , 그래서 당신은 새 탭에서 링크를 열 필요가 있다면, 당신은 사용할 필요가 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e4d9853311324c1062785017be6c36f8e6cda485" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;#vm-nextTick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;updated&lt;/code&gt; 않습니다 &lt;strong&gt;없습니다&lt;/strong&gt; 모든 하위 구성 요소는 재 렌더링 된 것을 보장합니다. 전체보기가 다시 렌더링 될 때까지 기다리려면 &lt;code&gt;updated&lt;/code&gt; 내부에서 &lt;a href=&quot;#vm-nextTick&quot;&gt;vm. $ nextTick을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="736452a7cde671c4028bd0f51d1cfa315c95c76a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;updated&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use &lt;a href=&quot;instance-methods#nexttick&quot;&gt;vm.$nextTick&lt;/a&gt; inside of &lt;code&gt;updated&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111be77d17fe6743b1bb02879c8402ce1acfd03" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-bind&lt;/code&gt; with the &lt;code&gt;.sync&lt;/code&gt; modifier does &lt;strong&gt;not&lt;/strong&gt; work with expressions (e.g. &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; is invalid). Instead, you must only provide the name of the property you want to bind, similar to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">하는 것으로 &lt;code&gt;v-bind&lt;/code&gt; 와 &lt;code&gt;.sync&lt;/code&gt; 인 수정이 수행 &lt;strong&gt;되지&lt;/strong&gt; 표정으로 작업 (예 : &lt;code&gt;v-bind:title.sync=&amp;rdquo;doc.title + &amp;lsquo;!&amp;rsquo;&amp;rdquo;&lt;/code&gt; 무효). 대신 &lt;code&gt;v-model&lt;/code&gt; 과 유사하게 바인딩하려는 속성의 이름 만 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="771a269b6d8c0e9ec3e7216d190b9a4d937f48ce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;v-show&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, nor does it work with &lt;code&gt;v-else&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;v-show&lt;/code&gt; 지원하지 않는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 않으며이 함께 작동합니까 &lt;code&gt;v-else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b9184088f073256f499eaedf7653670276bb736" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;you should not use an arrow function to define a watcher&lt;/em&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d9068c552bdf157869d707a68e7ff8a3725d0e" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;one exception&lt;/a&gt;), unlike the deprecated &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;&lt;code&gt;slot&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;strong&gt; &lt;code&gt;v-slot&lt;/code&gt; 만을 추가 할 수있는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; &lt;/strong&gt; (함께 &lt;a href=&quot;#Abbreviated-Syntax-for-Lone-Default-Slots&quot;&gt;하나 개의 예외&lt;/a&gt; ), 중단 된 달리 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt; &lt;code&gt;slot&lt;/code&gt; 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da6d6a25d31f792c92e4d4f94e109dce6aa1ce03" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;&lt;code&gt;v-slot&lt;/code&gt; can only be added to a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;&lt;/strong&gt; (with &lt;a href=&quot;#abbreviated-syntax-for-lone-default-slots&quot;&gt;one exception&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dcb74ada7f4cc1814737bb17df3646b8395ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you&amp;rsquo;d have to use:</source>
          <target state="translated">참고 &lt;strong&gt;로컬로 등록 된 구성 요소가 &lt;em&gt;되지&lt;/em&gt; 도 하위 구성 요소에서 사용할 수&lt;/strong&gt; . 예를 들어, &lt;code&gt;ComponentA&lt;/code&gt; 에서 &lt;code&gt;ComponentB&lt;/code&gt; 를 사용할 수있게하려면 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf48dec89b052e2c67a866740d5df77b8220622a" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;locally registered components are &lt;em&gt;not&lt;/em&gt; also available in subcomponents&lt;/strong&gt;. For example, if you wanted &lt;code&gt;ComponentA&lt;/code&gt; to be available in &lt;code&gt;ComponentB&lt;/code&gt;, you'd have to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8881ac4ac19e2ded818c92290bbcf16a14c24745" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="translated">참고 &lt;strong&gt;이 방법을 정의하는 화살표 기능을 사용하지 말아야합니다&lt;/strong&gt; (예 : &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같이 뷰 인스턴스를하지 않습니다 &lt;code&gt;this.a&lt;/code&gt; 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641353cb3566fc5149312b741e1f12c37e6b249c" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a method&lt;/strong&gt; (e.g. &lt;code&gt;plus: () =&amp;gt; this.a++&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the component instance as you expect and &lt;code&gt;this.a&lt;/code&gt; will be undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835968cbd8027db3d9ca26ddf24e18c1f5c52040" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;you should not use an arrow function to define a watcher&lt;/strong&gt; (e.g. &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt;). The reason is arrow functions bind the parent context, so &lt;code&gt;this&lt;/code&gt; will not be the Vue instance as you expect and &lt;code&gt;this.updateAutocomplete&lt;/code&gt; will be undefined.</source>
          <target state="translated">참고 &lt;strong&gt;당신이 감시자 정의 화살표 기능을 사용하지 말아야합니다&lt;/strong&gt; (예 &lt;code&gt;searchQuery: newValue =&amp;gt; this.updateAutocomplete(newValue)&lt;/code&gt; ). 그래서 그 이유는, 기능 바인드 부모 컨텍스트 화살표입니다 &lt;code&gt;this&lt;/code&gt; 예상과 같이 뷰 인스턴스를하지 않습니다 &lt;code&gt;this.updateAutocomplete&lt;/code&gt; 이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae4a42d86a3cca81f57342eb0f1aed6f05d0e695" translate="yes" xml:space="preserve">
          <source>Note that Vue&amp;rsquo;s event system is different from the browser&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt;. Though they work similarly, &lt;code&gt;$emit&lt;/code&gt;, &lt;code&gt;$on&lt;/code&gt;, and &lt;code&gt;$off&lt;/code&gt; are &lt;strong&gt;not&lt;/strong&gt; aliases for &lt;code&gt;dispatchEvent&lt;/code&gt;, &lt;code&gt;addEventListener&lt;/code&gt;, and &lt;code&gt;removeEventListener&lt;/code&gt;.</source>
          <target state="translated">Vue의 이벤트 시스템은 브라우저의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget&quot;&gt;EventTarget API&lt;/a&gt; 와 다릅니다 . 비슷하게 작동하지만 &lt;code&gt;$emit&lt;/code&gt; , &lt;code&gt;$on&lt;/code&gt; 및 &lt;code&gt;$off&lt;/code&gt; 는 &lt;code&gt;dispatchEvent&lt;/code&gt; , &lt;code&gt;addEventListener&lt;/code&gt; 및 &lt;code&gt;removeEventListener&lt;/code&gt; 의 별명 이 &lt;strong&gt;아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="081986e34f15d320aaefef70aa73f69abdde7609" translate="yes" xml:space="preserve">
          <source>Note that all native HTML and SVG tags don't need to be matched in this function - Vue parser performs this check automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34975db8bc1ca3043980cfeb4c62b733ac3c9bed" translate="yes" xml:space="preserve">
          <source>Note that every child in a &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; must be &lt;a href=&quot;special-attributes#key&quot;&gt;&lt;strong&gt;uniquely keyed&lt;/strong&gt;&lt;/a&gt; for the animations to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4518368215428ba1ec224631fb3c0691204e72" translate="yes" xml:space="preserve">
          <source>Note that for other directives (e.g. &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-show&lt;/code&gt;), JavaScript&amp;rsquo;s normal truthiness still applies.</source>
          <target state="translated">다른 지시어 (예 : &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-show&lt;/code&gt; )의 경우 JavaScript의 일반적인 정확성이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="59c87a2470ce03d315d2bf588709c8b05af9d942" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">계산 된 속성과 함께 화살표 함수를 사용하는 경우 &lt;code&gt;this&lt;/code&gt; 구성 요소의 인스턴스가 아니지만 함수의 첫 번째 인수로 인스턴스에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e9ff50c8f4d3af5530daf6166e647efccff678" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with a computed property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ac594b131a812ccc4dec6f17d0ccc6f38ab19e" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won&amp;rsquo;t be the component&amp;rsquo;s instance, but you can still access the instance as the function&amp;rsquo;s first argument:</source>
          <target state="translated">당신이 함께 화살표 기능을 사용하는 경우주의 &lt;code&gt;data&lt;/code&gt; 속성 &lt;code&gt;this&lt;/code&gt; 구성 요소의 인스턴스가되지 않습니다,하지만 당신은 여전히 함수의 첫 번째 인수로 인스턴스를 액세스 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b844a1894b3639cf8e6947f52c1732f36fa3f2ea" translate="yes" xml:space="preserve">
          <source>Note that if you use an arrow function with the &lt;code&gt;data&lt;/code&gt; property, &lt;code&gt;this&lt;/code&gt; won't be the component's instance, but you can still access the instance as the function's first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92212320fc7b39925a58ec2e6b387152eda8b23" translate="yes" xml:space="preserve">
          <source>Note that in ES2015+, placing a variable name like &lt;code&gt;ComponentA&lt;/code&gt; inside an object is shorthand for &lt;code&gt;ComponentA: ComponentA&lt;/code&gt;, meaning the name of the variable is both:</source>
          <target state="translated">ES2015 +에서 &lt;code&gt;ComponentA&lt;/code&gt; 와 같은 변수 이름을 객체 안에 배치하는 것은 &lt;code&gt;ComponentA: ComponentA&lt;/code&gt; 축약 형입니다 . 이는 변수 이름이 둘 다임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="38d7decb45ee1373ac91755a507d8307efe29952" translate="yes" xml:space="preserve">
          <source>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</source>
          <target state="translated">이 방법에서는 DOM을 건드리지 않고 앱 상태를 업데이트합니다. 모든 DOM 조작은 Vue에 의해 처리되며 사용자가 작성한 코드는 기본 논리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="d39c5b6e21dbfd1407f27da7320c3009d1f4fce3" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="translated">그것의 것을 참고 &lt;strong&gt;하지&lt;/strong&gt; 사용하는 것이 좋습니다 &lt;code&gt;v-if&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 함께. 자세한 내용은 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;스타일 가이드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="faa9c0503d39b650734e81c8480f148f8158dc6a" translate="yes" xml:space="preserve">
          <source>Note that it's &lt;strong&gt;not&lt;/strong&gt; recommended to use &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together. Refer to &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9bca625b5e998dd62bb4f93dc90d8caa850ab" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won&amp;rsquo;t trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone. If you do want such behaviour, use the &lt;code&gt;keyCode&lt;/code&gt; for &lt;code&gt;ctrl&lt;/code&gt; instead: &lt;code&gt;keyup.17&lt;/code&gt;.</source>
          <target state="translated">수정 자 키는 일반 키와 다르며 &lt;code&gt;keyup&lt;/code&gt; 이벤트 와 함께 사용 하는 경우 이벤트가 생성 될 때 눌러야합니다. 즉, &lt;code&gt;keyup.ctrl&lt;/code&gt; 은 &lt;code&gt;ctrl&lt;/code&gt; 키를 누른 상태에서 키를 놓은 경우에만 트리거됩니다 . &lt;code&gt;ctrl&lt;/code&gt; 키를 단독으로 놓으면 트리거되지 않습니다 . 이러한 동작을 원하면 &lt;code&gt;ctrl&lt;/code&gt; 대신 &lt;code&gt;keyup.17&lt;/code&gt; 키 &lt;code&gt;keyCode&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a575c0c184061dc0e5bebafa17e97ed49b8df32d" translate="yes" xml:space="preserve">
          <source>Note that modifier keys are different from regular keys and when used with &lt;code&gt;keyup&lt;/code&gt; events, they have to be pressed when the event is emitted. In other words, &lt;code&gt;keyup.ctrl&lt;/code&gt; will only trigger if you release a key while holding down &lt;code&gt;ctrl&lt;/code&gt;. It won't trigger if you release the &lt;code&gt;ctrl&lt;/code&gt; key alone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782e93758e1a8da260782325b450852c804d73f2" translate="yes" xml:space="preserve">
          <source>Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component &lt;strong&gt;will&lt;/strong&gt; affect parent state.</source>
          <target state="translated">자바 스크립트의 객체와 배열이 소품은 아이 컴퍼넌트 내부의 객체 또는 배열 자체를 돌연변이 배열이나 객체, 그래서 경우, 참조에 의해 전달되는 것을 참고 &lt;strong&gt;한다&lt;/strong&gt; 부모의 상태에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="3151ecc6011010f2ef8540f5f9ad70909763b9e7" translate="yes" xml:space="preserve">
          <source>Note that props are validated &lt;strong&gt;before&lt;/strong&gt; a component instance is created, so instance properties (e.g. &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, etc) will not be available inside &lt;code&gt;default&lt;/code&gt; or &lt;code&gt;validator&lt;/code&gt; functions.</source>
          <target state="translated">소품은 컴포넌트 인스턴스가 생성 &lt;strong&gt;되기 전에&lt;/strong&gt; 확인 되므로 인스턴스 속성 (예 : &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;computed&lt;/code&gt; 등)은 &lt;code&gt;default&lt;/code&gt; 또는 &lt;code&gt;validator&lt;/code&gt; 함수 내에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="84136e18c6c864e905f34757af495e8cd152f729" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; elements are still efficiently re-used, because they don&amp;rsquo;t have &lt;code&gt;key&lt;/code&gt; attributes.</source>
          <target state="translated">있습니다 &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 가 없기 때문에 요소를 효율적으로 여전히이-재사용 &lt;code&gt;key&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="8c6f6de9e542ddf567ea5a5cf5a2069dcc0d7d80" translate="yes" xml:space="preserve">
          <source>Note that the abbreviated syntax for default slot &lt;strong&gt;cannot&lt;/strong&gt; be mixed with named slots, as it would lead to scope ambiguity:</source>
          <target state="translated">기본 슬롯에 대한 약식 구문은 범위 모호성을 초래할 &lt;strong&gt;수&lt;/strong&gt; 있으므로 명명 된 슬롯과 혼합 될 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d9393e6c94f522abc9f4a9fa2054455519ccc108" translate="yes" xml:space="preserve">
          <source>Note that the same merge strategies are used in &lt;code&gt;Vue.extend()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vue.extend()&lt;/code&gt; 에서 동일한 병합 전략이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b19b165a75219255a66fd8c95f88d1f25d66fca4" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won&amp;rsquo;t be able to unwatch the given property on the first callback call.</source>
          <target state="translated">함께합니다 &lt;code&gt;immediate&lt;/code&gt; 옵션 첫 번째 콜백 호출에 지정된 속성을 주시 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7894715668a9552d744e1da5cfc8208dcef0a9e" translate="yes" xml:space="preserve">
          <source>Note that with &lt;code&gt;immediate&lt;/code&gt; option you won't be able to unwatch the given property on the first callback call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d1222c87974bff7446442d086ef17e96241dd6" translate="yes" xml:space="preserve">
          <source>Note that with this approach, you can only use methods, not computed properties, as the latter only make sense when defined in the context of an individual component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e5eb4daa67f823465bf8f428dfecbb3f5135d5" translate="yes" xml:space="preserve">
          <source>Note that you have to include &lt;code&gt;strict: true&lt;/code&gt; (or at least &lt;code&gt;noImplicitThis: true&lt;/code&gt; which is a part of &lt;code&gt;strict&lt;/code&gt; flag) to leverage type checking of &lt;code&gt;this&lt;/code&gt; in component methods otherwise it is always treated as &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">참고 포함해야한다는 &lt;code&gt;strict: true&lt;/code&gt; (또는 적어도 &lt;code&gt;noImplicitThis: true&lt;/code&gt; 의 일부 &lt;code&gt;strict&lt;/code&gt; 플래그)의 활용 유형 검사에 &lt;code&gt;this&lt;/code&gt; 그렇지 않으면 항상로 처리됩니다 컴포넌트 메소드에서 &lt;code&gt;any&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="3c9f11f51925aec7450ae0935dd3b229a967e2c1" translate="yes" xml:space="preserve">
          <source>Note that you must use &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0+ if you wish to use the above syntax for route components.</source>
          <target state="translated">라우트 구성 요소에 위의 구문을 사용 하려면 &lt;a href=&quot;https://github.com/vuejs/vue-router&quot;&gt;Vue Router&lt;/a&gt; 2.4.0 이상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9a477d195904adab9bde1cc82c2b08801e6b422" translate="yes" xml:space="preserve">
          <source>Note that you still have to declare the &lt;code&gt;checked&lt;/code&gt; prop in component&amp;rsquo;s &lt;code&gt;props&lt;/code&gt; option.</source>
          <target state="translated">구성 요소의 &lt;code&gt;props&lt;/code&gt; 옵션 에서 &lt;code&gt;checked&lt;/code&gt; prop 을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea28128f17211fcef9f44807c81be52f215e0561" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; attribute. This is necessary in DOM templates, because only an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is valid inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;. It does the same thing as &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt;, but works around a potential browser parsing error. See &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; to learn more.</source>
          <target state="translated">&lt;code&gt;is=&quot;todo-item&quot;&lt;/code&gt; 속성에 유의하십시오 . &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 내에서는 &amp;lt; &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 만 유효 하므로 이는 DOM 템플리트에서 필요 합니다 . 이 같은 일을 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 하지만, 잠재적 브라우저 구문 분석 오류 주위에 작동합니다. 자세한 내용은 &lt;a href=&quot;components#DOM-Template-Parsing-Caveats&quot;&gt;DOM 템플릿 구문 분석을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd73b9ea52e1db8097dc7a516386c176573e1dbe" translate="yes" xml:space="preserve">
          <source>Note this &lt;code&gt;props&lt;/code&gt; object is reactive - i.e. it is updated when new props are passed in, and can be observed and reacted upon using &lt;code&gt;watchEffect&lt;/code&gt; or &lt;code&gt;watch&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056476ec0b830039894a5b3089419b4a5d60c537" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is designed for the case where it has one direct child component that is being toggled. It does not work if you have &lt;code&gt;v-for&lt;/code&gt; inside it. When there are multiple conditional children, as above, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; requires that only one child is rendered at a time.</source>
          <target state="translated">참고, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 이 전환되고 하나 직접 아이 컴퍼넌트가있는 경우를 위해 설계되었습니다. 내부에 &lt;code&gt;v-for&lt;/code&gt; 가 있으면 작동하지 않습니다 . 위와 같이 여러 조건부 자식이있는 경우 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 에서는 한 번에 하나의 자식 만 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="da58435f34b35b1887295eb16c900d592e7442c7" translate="yes" xml:space="preserve">
          <source>Note: In 3.x, slots can be rendered as the root with native &lt;a href=&quot;fragments&quot;&gt;fragments&lt;/a&gt; support!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d29dd3fc2d4ef6a6ce13aedfe8172fb47b148bd" translate="yes" xml:space="preserve">
          <source>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="translated">참고 : Macintosh 키보드에서 meta는 명령 키 (⌘)입니다. Windows 키보드에서 meta는 Windows 키 (⊞)입니다. Sun Microsystems 키보드에서 메타는 솔리드 다이아몬드 (◆)로 표시됩니다. 특정 키보드, 특히 Knight 키보드, 우주 생도 키보드와 같은 MIT 및 Lisp 머신 키보드 및 후속 키보드에서 메타는 &quot;META&quot;로 표시됩니다. Symbolics 키보드에서 메타는 &quot;META&quot;또는 &quot;Meta&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9028e9d05d6a455c1974133f7e5293ddabaa337b" translate="yes" xml:space="preserve">
          <source>Note: in versions before 2.3.0, the &lt;code&gt;props&lt;/code&gt; option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the &lt;code&gt;props&lt;/code&gt; option and all attributes found on the component node will be implicitly extracted as props.</source>
          <target state="translated">참고 : 2.3.0 이전 버전 에서는 기능 구성 요소에서 소품을 허용 하려면 &lt;code&gt;props&lt;/code&gt; 옵션이 필요합니다. 2.3.0 이상에서는 &lt;code&gt;props&lt;/code&gt; 옵션을 생략 할 수 있으며 구성 요소 노드에있는 모든 속성은 내재적으로 props로 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="334bf93841cedfd326dcac54017cd67d04bd2494" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down a reactive object, properties on that object do remain reactive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a9d4709f41005aebf7f630aea0e9e8dcba6214" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;inject&lt;/code&gt; bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</source>
          <target state="translated">참고 : &lt;code&gt;provide&lt;/code&gt; 및 &lt;code&gt;inject&lt;/code&gt; 바인딩은 반응하지 않습니다. 이것은 의도적 인 것입니다. 그러나 관찰 된 객체를 전달하면 해당 객체의 속성이 계속 반응합니다.</target>
        </trans-unit>
        <trans-unit id="0908b002b159b7c5ec7a450ce89576a7ca8ba515" translate="yes" xml:space="preserve">
          <source>Note: the beta channel may conflict with the stable version of devtools so you may need to temporarily disable the stable version for the beta channel to work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458f74037e32ee6cfbdde797c11bd7a73de43a01" translate="yes" xml:space="preserve">
          <source>Note: this option does &lt;strong&gt;not&lt;/strong&gt; affect &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; bindings.</source>
          <target state="translated">참고 :이 옵션은 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 바인딩에 영향을 미치지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="08b75004d7b0e0a6d3825e3c52c9e938d2e8a019" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6381b17960004aa9578834992d92eb41037168d9" translate="yes" xml:space="preserve">
          <source>Note: this section only affects cases where Vue templates are directly written in the page's HTML. When using in-DOM templates, the template is subject to native HTML parsing rules. Some HTML elements, such as &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; have restrictions on what elements can appear inside them, and some elements such as &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; can only appear inside certain other elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0598de4737485dd16187bee300278ba69862eb70" translate="yes" xml:space="preserve">
          <source>Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn&amp;rsquo;t keep a copy of the pre-mutate value.</source>
          <target state="translated">참고 : Object 또는 Array를 교체하지 않고 변경하면 이전 값은 동일한 Object / Array를 참조하므로 새 값과 동일합니다. Vue는 사전 돌연변이 값의 사본을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b91291f0de6e06db99bb183c76dabbf60ffa395f" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store&amp;rsquo;s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we&amp;rsquo;ll also have a log of what happened leading up to the bug.</source>
          <target state="translated">상점의 상태를 변경하는 모든 조치는 상점 자체에 있습니다. 이러한 유형의 중앙 집중식 상태 관리를 통해 어떤 유형의 돌연변이가 발생하고 어떻게 발생하는지 쉽게 이해할 수 있습니다. 이제 무언가 잘못되면 버그로 이어진 일에 대한 로그도 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="571333a47c31bbee3623511f092d63b988f1b343" translate="yes" xml:space="preserve">
          <source>Notice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd794a6843de7d3ad1a1df1f2c8c06559b41eae" translate="yes" xml:space="preserve">
          <source>Notice how you can include &lt;code&gt;autocomplete='on'&lt;/code&gt; on the form element and it will apply to all inputs in your form. You can also set different &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete&quot;&gt;values for autocomplete attribute (opens new window)&lt;/a&gt; for each input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73647a8d9626dfeb015e786688a6df3934b4f805" translate="yes" xml:space="preserve">
          <source>Notice that this will move the actual DOM nodes instead of being destroyed and recreated, and it will keep any component instances alive as well. All stateful HTML elements (i.e. a playing video) will keep their state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc1f6f3474e7672908319c7bc94aae61f59580d" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That&amp;rsquo;s because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="translated">버튼을 클릭 할 때 각 버튼은 자체의 개별 &lt;code&gt;count&lt;/code&gt; 유지합니다 . 구성 요소를 사용할 때마다 새 구성 요소 &lt;strong&gt;인스턴스&lt;/strong&gt; 가 생성되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6d30d0e0ff05d60e422be32271f1e21965033ef6" translate="yes" xml:space="preserve">
          <source>Notice that when clicking on the buttons, each one maintains its own, separate &lt;code&gt;count&lt;/code&gt;. That's because each time you use a component, a new &lt;strong&gt;instance&lt;/strong&gt; of it is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc80ae205fd608099bd57a38126221c490c9a421" translate="yes" xml:space="preserve">
          <source>Notice that when the component's &lt;code&gt;created&lt;/code&gt; lifecycle hook triggers, the &lt;code&gt;modelModifiers&lt;/code&gt; prop contains &lt;code&gt;capitalize&lt;/code&gt; and its value is &lt;code&gt;true&lt;/code&gt; - due to it being set on the &lt;code&gt;v-model&lt;/code&gt; binding &lt;code&gt;v-model.capitalize=&quot;myText&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777758140398dbba4754b09995581bb165f2d561" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;v-model&lt;/code&gt; should work perfectly with this component:</source>
          <target state="translated">이제 &lt;code&gt;v-model&lt;/code&gt; 은이 구성 요소와 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f41ecd46e8d6d6bb70e920ed57d983ae6565a184" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;&amp;lsquo;s template.</source>
          <target state="translated">이제 모두 &lt;code&gt;ComponentA&lt;/code&gt; 및 &lt;code&gt;ComponentC&lt;/code&gt; 은 내부에 사용할 수 있습니다 &lt;code&gt;ComponentB&lt;/code&gt; 의 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="d88909194979ead139b391709a958720c86553b7" translate="yes" xml:space="preserve">
          <source>Now both &lt;code&gt;ComponentA&lt;/code&gt; and &lt;code&gt;ComponentC&lt;/code&gt; can be used inside &lt;code&gt;ComponentB&lt;/code&gt;'s template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caffa3b79738c5125111f76c75b50ac902d4aecd" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64af1694b13df77b316f8c73909dd8b963af9613" translate="yes" xml:space="preserve">
          <source>Now everything inside the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; elements will be passed to the corresponding slots. Any content not wrapped in a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; using &lt;code&gt;v-slot&lt;/code&gt; is assumed to be for the default slot.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소 내부의 모든 것이 해당 슬롯으로 전달됩니다. &lt;code&gt;v-slot&lt;/code&gt; 사용하여 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 래핑되지 않은 내용 은 기본 슬롯에 대한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3e4140c0dde663257b36afdec9358a935995f01d" translate="yes" xml:space="preserve">
          <source>Now in Vue 3, all functional components are created with a plain function. In other words, there is no need to define the &lt;code&gt;{ functional: true }&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0f458e8cae4f3622f936273f3e1139e34d7a7b" translate="yes" xml:space="preserve">
          <source>Now in the component where you&amp;rsquo;ve defined this &lt;code&gt;ref&lt;/code&gt;, you can use:</source>
          <target state="translated">이제이 &lt;code&gt;ref&lt;/code&gt; 를 정의한 컴포넌트에서 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c100aabba7af200c0826cfd9a4189752cd557e" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="translated">이제 깊은 다이빙을 할 시간입니다! Vue의 가장 두드러진 특징 중 하나는 눈에 거슬리지 않는 반응성 시스템입니다. 모델은 단순한 JavaScript 객체입니다. 수정하면보기가 업데이트됩니다. 상태 관리를 간단하고 직관적으로 만들 수 있지만 일반적인 문제를 피하기 위해 어떻게 작동하는지 이해하는 것도 중요합니다. 이 섹션에서는 Vue의 반응성 시스템에 대한 하위 수준의 세부 사항에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="416cefac38d5a91dc03601ff2321b1747824eafd" translate="yes" xml:space="preserve">
          <source>Now it&amp;rsquo;s time to take a deep dive! One of Vue&amp;rsquo;s most distinct features is the unobtrusive reactivity system. Models are proxied JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it&amp;rsquo;s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue&amp;rsquo;s reactivity system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6e6c5e29a0011ecf92b2b3f2e105991af96fc7" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add a button to enlarge the text right before the content of every post:</source>
          <target state="translated">이제 모든 게시물의 내용 바로 앞에 텍스트를 확대하는 버튼을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="27f3edc7f43414bdb880e462618cc2a4be655f49" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example, transitioning entering and leaving using the same CSS classes we&amp;rsquo;ve used previously:</source>
          <target state="translated">이제 예제와 함께 이전에 사용한 것과 동일한 CSS 클래스를 사용하여 들어오고 나가는 과정을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="dd26b2548ee21e904e0d33fa95d291ffe37c263c" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s dive into an example. Here&amp;rsquo;s a JavaScript transition using Velocity.js:</source>
          <target state="translated">이제 예를 들어 보자. Velocity.js를 사용한 JavaScript 전환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88e72442353d1cc70a649bbfb7fde5fcd5a0942a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s start with extracting the first logical concern (marked as &quot;1&quot; in the original snippet).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db457f96df4f0407b03b33810d84f20e49792e2d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="translated">이제 on / off 버튼의 전환을 &lt;code&gt;out-in&lt;/code&gt; 으로 업데이트합시다 :</target>
        </trans-unit>
        <trans-unit id="61d7e41c0d0afefd3a6e0b42734a3aa3ca5ebe0d" translate="yes" xml:space="preserve">
          <source>Now let's add a button to enlarge the text right before the content of every post:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56027a462aa3978a9b96d4374ca36d15fa649ef8" translate="yes" xml:space="preserve">
          <source>Now let's build the directive that accomplishes this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f599733aef531ac3cec8a9e1bc4b342515b0f147" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example, transitioning entering and leaving using the same CSS classes we've used previously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3324adaea061622687d6176489328922e25a0701" translate="yes" xml:space="preserve">
          <source>Now let's dive into an example. Here's a JavaScript transition using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f77a5a07be37fa843c2b64e4b6651919be0542c" translate="yes" xml:space="preserve">
          <source>Now let's extend our directive logic to recalculate the distance to pin on component update:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b244b43642c6b5693f8cc0207f277488e09d82e" translate="yes" xml:space="preserve">
          <source>Now let's update the transition for our on/off buttons with &lt;code&gt;out-in&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b586c00a91f7688367b4cacd0212bee0c1ca54f" translate="yes" xml:space="preserve">
          <source>Now that the custom directive lifecycle hooks mirror those of the components themselves, they become easier to reason about and remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aacb98515307b9797f4efe520f56ffcc9d7f5e" translate="yes" xml:space="preserve">
          <source>Now that we have our prop set up, we can check the &lt;code&gt;modelModifiers&lt;/code&gt; object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; element fires an &lt;code&gt;input&lt;/code&gt; event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf65b7d19a965e9b08bfa030c0b0ce8f415f6a3" translate="yes" xml:space="preserve">
          <source>Now that we know how watchers are updating the components, you might ask how those changes eventually make it to the DOM! Perhaps you&amp;rsquo;ve heard of the Virtual DOM before, many frameworks including Vue use this paradigm to make sure our interfaces reflect the changes we&amp;rsquo;re updating in JavaScript effectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f0e4739b10c5c53576af812b04069f5b1133df" translate="yes" xml:space="preserve">
          <source>Now that we know the &lt;strong&gt;why&lt;/strong&gt; we can get to the &lt;strong&gt;how&lt;/strong&gt;. To start working with the Composition API we first need a place where we can actually use it. In a Vue component, we call this place the &lt;code&gt;setup&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850bba741090a632ab041dbea9329ab10babf270" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; component is a &lt;strong&gt;fully transparent wrapper&lt;/strong&gt;, meaning it can be used exactly like a normal &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element: all the same attributes and listeners will work, without the &lt;code&gt;.native&lt;/code&gt; modifier.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 컴포넌트는 &lt;strong&gt;완전히 투명한 래퍼입니다&lt;/strong&gt; . 즉, 일반 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 와 똑같이 사용할 수 있습니다 . &lt;code&gt;.native&lt;/code&gt; 수정 자 없이 동일한 속성과 리스너가 모두 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5577e953820ec1b24aed02306173d947e4a546b7" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;focus&lt;/code&gt; directive will be available in both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; instances and their descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d4814b929f161b38b9f934ab2aa6a05b1be4d4" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it&amp;rsquo;s not rendered. See &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;this fiddle&lt;/a&gt; for the complete code.</source>
          <target state="translated">이제 &lt;em&gt;게시물&lt;/em&gt; 탭은 렌더링되지 않더라도 상태 (선택한 게시물)를 유지합니다. 전체 코드는 &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/Lp20op9o/&quot;&gt;이 바이올린&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa9b9e0ccefb495f319a6491a7e676d9dacfb2b2" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;Posts&lt;/em&gt; tab maintains its state (the selected post) even when it's not rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a866376561d170695076f998d16ef29475c4851" translate="yes" xml:space="preserve">
          <source>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</source>
          <target state="translated">이제 토글 할 때마다 해당 입력이 처음부터 렌더링됩니다. 직접 참조하십시오 :</target>
        </trans-unit>
        <trans-unit id="0c9d8ea18bd7c1be0ebb6900315a3a7aaedea656" translate="yes" xml:space="preserve">
          <source>Now we can compose multiple states with these child components. It's exciting- we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue's &lt;a href=&quot;transitions-enterleave&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5237d0862d1e32d66a1238befdcec2a1cee4d6bd" translate="yes" xml:space="preserve">
          <source>Now we can pass the todo into each repeated component using &lt;code&gt;v-bind&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;v-bind&lt;/code&gt; 를 사용하여 할 일을 반복되는 각 구성 요소에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac2bcabccc1a40d27783fa177eb9745afd5270c" translate="yes" xml:space="preserve">
          <source>Now we get:</source>
          <target state="translated">이제 우리는 :</target>
        </trans-unit>
        <trans-unit id="3ca602ef2620d2d54650ef4ef89bcc645f4b53a2" translate="yes" xml:space="preserve">
          <source>Now we need to react to the changes made to the &lt;code&gt;user&lt;/code&gt; prop. For that we will use the standalone &lt;code&gt;watch&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923823ddc53818b43f37e1756295008b20a5e569" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll answer both what the community can do for you and what you can do for the community.</source>
          <target state="translated">이제 우리는 커뮤니티가 당신을 위해 할 수있는 것과 커뮤니티를 위해 할 수있는 것에 대해 대답 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="65acc113a97fb20c77fd8e66d6b9e5577e37c2d1" translate="yes" xml:space="preserve">
          <source>Now when using &lt;code&gt;v-model&lt;/code&gt; on this component:</source>
          <target state="translated">이제이 컴포넌트에서 &lt;code&gt;v-model&lt;/code&gt; 을 사용할 때 :</target>
        </trans-unit>
        <trans-unit id="248dcb3a91e49c1782db9a10e1b75d0c45f374c4" translate="yes" xml:space="preserve">
          <source>Now when we use &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; in a parent component, providing no content for the slot:</source>
          <target state="translated">이제 상위 컴포넌트에서 &lt;code&gt;&amp;lt;submit-button&amp;gt;&lt;/code&gt; 을 사용하여 슬롯에 대한 컨텐츠를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a992bbc0f49c4600f1fce407f7a3883535b20007" translate="yes" xml:space="preserve">
          <source>Now when we use the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; component, we can optionally define an alternative &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; for todo items, but with access to data from the child:</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 컴포넌트를 사용할 때 선택적 으로 todo 항목에 대한 대체 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 을 정의 할 수 있지만 자식의 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6ac744ac13f4f3529e5b95ada6cc236397759d" translate="yes" xml:space="preserve">
          <source>Now when you run &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt;, the setter will be invoked and &lt;code&gt;vm.firstName&lt;/code&gt; and &lt;code&gt;vm.lastName&lt;/code&gt; will be updated accordingly.</source>
          <target state="translated">이제 &lt;code&gt;vm.fullName = 'John Doe'&lt;/code&gt; 를 실행 하면 setter가 호출되고 &lt;code&gt;vm.firstName&lt;/code&gt; 및 &lt;code&gt;vm.lastName&lt;/code&gt; 이 그에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="99a7fc3db6e58b44e0a648173eebd65a414924c6" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;appA&lt;/code&gt; and &lt;code&gt;appB&lt;/code&gt; will update their views automatically. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95a512db9f39a3a016016301d2d32cc53d1129b" translate="yes" xml:space="preserve">
          <source>Now whenever &lt;code&gt;sourceOfTruth&lt;/code&gt; is mutated, both &lt;code&gt;vmA&lt;/code&gt; and &lt;code&gt;vmB&lt;/code&gt; will update their views automatically. Subcomponents within each of these instances would also have access via &lt;code&gt;this.$root.$data&lt;/code&gt;. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</source>
          <target state="translated">때마다 이제 &lt;code&gt;sourceOfTruth&lt;/code&gt; 가 변이되어, 모두 &lt;code&gt;vmA&lt;/code&gt; 및 &lt;code&gt;vmB&lt;/code&gt; 자동으로 자신의 견해를 업데이트합니다. 이러한 각 인스턴스 내의 하위 구성 요소도 &lt;code&gt;this.$root.$data&lt;/code&gt; 를 통해 액세스 할 수 있습니다 . 우리에게는 지금 진실의 단일 소스가 있지만 디버깅은 악몽이 될 것입니다. 추적없이 데이터의 일부를 앱의 어느 부분에서나 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a99cd123681e2aa2af5f62113a3388dd485458" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component&amp;rsquo;s template:</source>
          <target state="translated">이제 다른 구성 요소의 템플리트에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a045cd84f5be21505ce08157ae51e1f45c687302" translate="yes" xml:space="preserve">
          <source>Now you can compose it in another component's template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1476c1cb56c53ca2f243a141ad4a636da2115a2b" translate="yes" xml:space="preserve">
          <source>Now, if anything changes in either property, the &lt;code&gt;MyMarker&lt;/code&gt; component will automatically be updated as well!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93161c9554bdbf350b67c1c62a2064b5a47aa2d" translate="yes" xml:space="preserve">
          <source>Now, in Vue 3, since functional components are defined as pure functions, async components definitions need to be explicitly defined by wrapping it in a new &lt;code&gt;defineAsyncComponent&lt;/code&gt; helper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cafea5f9fea2834964a51ae219c94edcf43d7b" translate="yes" xml:space="preserve">
          <source>Now, whenever a new property is added to &lt;code&gt;post&lt;/code&gt; objects, it will automatically be available inside &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 새 객체 가 &lt;code&gt;post&lt;/code&gt; 객체에 추가 될 때마다 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 내에서 자동으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="1249f1b2253683fc003ea8f094caa69928eaf837" translate="yes" xml:space="preserve">
          <source>Nuxt.js</source>
          <target state="translated">Nuxt.js</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="86580d14a7ddf3bcd41cb5bf79f5c784db2009b3" translate="yes" xml:space="preserve">
          <source>Object Change Detection Caveats</source>
          <target state="translated">객체 변경 감지주의 사항</target>
        </trans-unit>
        <trans-unit id="bff5a67a67ce40c0fd925410f2eb22f8e622ed24" translate="yes" xml:space="preserve">
          <source>Object Literals</source>
          <target state="translated">객체 리터럴</target>
        </trans-unit>
        <trans-unit id="68654e143c9a95a12dddf5b994152ad350c30fec" translate="yes" xml:space="preserve">
          <source>Object Syntax</source>
          <target state="translated">객체 구문</target>
        </trans-unit>
        <trans-unit id="955b2e0aa5e53a4916bce29cbfdc2fd4cc269476" translate="yes" xml:space="preserve">
          <source>Official Declaration in NPM Packages</source>
          <target state="translated">NPM 패키지의 공식 선언</target>
        </trans-unit>
        <trans-unit id="e0d4eccd8c718c1a4aa53fa3e4adb3463704c6c3" translate="yes" xml:space="preserve">
          <source>Official Flux-Like Implementation</source>
          <target state="translated">공식 플럭스 유사 구현</target>
        </trans-unit>
        <trans-unit id="253fefc301bfd7132218b7557a6391250b616a46" translate="yes" xml:space="preserve">
          <source>Official Jest Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e814049718b1d932cec7462837ebe879f922b" translate="yes" xml:space="preserve">
          <source>Official Mocha Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41ddeb6775e329516c16fc6584211bbddf25a44" translate="yes" xml:space="preserve">
          <source>Official Router</source>
          <target state="translated">공식 라우터</target>
        </trans-unit>
        <trans-unit id="25d0bd72df27202461d0c5f9c7e08418ec21f91d" translate="yes" xml:space="preserve">
          <source>Official Vue 2 CLI Plugin - Jest (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b102013e2e4e3b2a122cd90521f7abb18b815e29" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Cypress Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4283002bfc2991c088ab89cd2443eafba975ab6b" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Nightwatch Plugin (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e38d4cb7819fb2b7ca582192edc9ff4825e473e" translate="yes" xml:space="preserve">
          <source>Official Vue CLI Plugin - Mocha (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5bc6dab6176b349e0ef77df3008fa9ea3cb2b1" translate="yes" xml:space="preserve">
          <source>Official Vue Test Utils Documentation (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e4e38b0d8be787a92f6532c519c8963542cb77" translate="yes" xml:space="preserve">
          <source>Official Vue Testing Library Website (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fafe60967df029303e74079e269747316a51820" translate="yes" xml:space="preserve">
          <source>Ok, so far, we&amp;rsquo;re just wrapping that object and returning it. Cool, but not that useful yet. But watch this, we can also intercept this object while we wrap it in the Proxy. This interception is called a trap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5c4c2f29b26dd8b70d7595e8bde56c7c36488" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit an &lt;code&gt;update:modelValue&lt;/code&gt; event with the new value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ad6876beffc882a2da696718cda5f0b89ad0ed" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;input&lt;/code&gt;, emit its own custom &lt;code&gt;input&lt;/code&gt; event with the new value</source>
          <target state="translated">에 &lt;code&gt;input&lt;/code&gt; , 자신의 사용자 정의 방출 &lt;code&gt;input&lt;/code&gt; 새 값으로 이벤트를</target>
        </trans-unit>
        <trans-unit id="8353eb035df2b7f6ca17019debdf96a3f22eb88a" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;setup()&lt;/code&gt; function, you don't need to pass a typing to &lt;code&gt;props&lt;/code&gt; parameter as it will infer types from &lt;code&gt;props&lt;/code&gt; component option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf41ca9bc7d54b6c5ac4b857c3027240934a3189" translate="yes" xml:space="preserve">
          <source>On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled &amp;ldquo;META&amp;rdquo;. On Symbolics keyboards, meta is labeled &amp;ldquo;META&amp;rdquo; or &amp;ldquo;Meta&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d04e03632e4eea5ab7fbb011f47571b7d133e29" translate="yes" xml:space="preserve">
          <source>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</source>
          <target state="translated">더 높은 수준에서 컴포넌트를 프리젠 테이션 카테고리와 논리 카테고리로 분류 할 수 있습니다. 프리젠 테이션 컴포넌트에 템플리트를 사용하고 논리 컴포넌트에 렌더링 함수 / JSX를 사용하는 것이 좋습니다. 이러한 구성 요소의 비율은 작성하는 앱 유형에 따라 다르지만 일반적으로 프레젠테이션 구성 요소가 훨씬 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="6c3d3824299b5122ad70d07d38a8fd8a0336c35b" translate="yes" xml:space="preserve">
          <source>On conditional branches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfd81e3f5a0816680f9b8987dee9ab76e3a2d2b" translate="yes" xml:space="preserve">
          <source>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or &lt;a href=&quot;class-and-style&quot;&gt;intelligently merging with&lt;/a&gt; any existing attributes of the same name.</source>
          <target state="translated">일반 컴포넌트에서 props로 정의되지 않은 속성은 컴포넌트의 루트 요소에 자동으로 추가되어 동일한 이름의 기존 속성 &lt;a href=&quot;class-and-style&quot;&gt;과&lt;/a&gt; 대체되거나 지능적으로 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="115970ef5ff2b56182595889250a6ca56011969e" translate="yes" xml:space="preserve">
          <source>On root Vue instances (i.e. instances created with &lt;code&gt;new Vue({ ... })&lt;/code&gt;), you must use &lt;code&gt;propsData&lt;/code&gt; instead of &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">루트 Vue 인스턴스 (예 : &lt;code&gt;new Vue({ ... })&lt;/code&gt; 작성된 인스턴스 )에서는 &lt;code&gt;props&lt;/code&gt; 대신 &lt;code&gt;propsData&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6cc2844f3ba73496715d5d711c0cabc37d43bc1d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;$refs&lt;/code&gt; are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue&amp;rsquo;s data-driven view model.</source>
          <target state="translated">반면, &lt;code&gt;$refs&lt;/code&gt; 는 주로 JavaScript에서 프로그래밍 방식으로 액세스하도록 설계되었습니다. 템플릿 자체에 의존하지 않는 것이 좋습니다. 즉, 인스턴스 자체에 속하지 않는 상태를 의미하기 때문입니다. 이것은 Vue의 데이터 중심 뷰 모델을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="b540e34dd34eb0880938f77efa7424968025eadc" translate="yes" xml:space="preserve">
          <source>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; or &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt;, your templates will be precompiled into &lt;code&gt;render&lt;/code&gt; functions which work perfectly in CSP environments.</source>
          <target state="translated">반면에 런타임 전용 빌드는 CSP와 완전히 호환됩니다. &lt;a href=&quot;https://github.com/vuejs-templates/webpack-simple&quot;&gt;Webpack + vue-loader&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/vuejs-templates/browserify-simple&quot;&gt;Browserify + vueify&lt;/a&gt; 와 함께 런타임 전용 빌드를 사용할 경우 템플릿은 CSP 환경에서 완벽하게 작동하는 &lt;code&gt;render&lt;/code&gt; 함수 로 사전 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d767e2d19bb7e35a75d58e381e3d41454c0c3f2" translate="yes" xml:space="preserve">
          <source>On this page, we&amp;rsquo;ll only cover entering, leaving, and list transitions, but you can see the next section for &lt;a href=&quot;transitioning-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="translated">이 페이지에서는 전환 입력, 탈퇴 및 목록 만 다루지 만 &lt;a href=&quot;transitioning-state&quot;&gt;상태 전환 관리를&lt;/a&gt; 위한 다음 섹션을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4cdb09dd5b26c91e66320cefa8ce757b9de6879" translate="yes" xml:space="preserve">
          <source>On this page, we'll only cover entering, and leaving, but you can see the next sections for &lt;a href=&quot;transitions-list&quot;&gt;list transitions&lt;/a&gt; and &lt;a href=&quot;transitions-state&quot;&gt;managing state transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eb05f4d4e96c1234bdb668f4b2f5b554eed08a" translate="yes" xml:space="preserve">
          <source>Once a prop is registered, you can pass data to it as a custom attribute, like this:</source>
          <target state="translated">소품이 등록되면 다음과 같이 사용자 정의 속성으로 데이터를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e7a62de13ea6daf472e90fd22d2267995fceed" translate="yes" xml:space="preserve">
          <source>Once a user changes route, bring focus back to the skip link. This can be achieved by calling focus to the &lt;code&gt;ref&lt;/code&gt; provided below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66af394c02eb313b263b2c4b24ed3c50b4c07c98" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it&amp;rsquo;s simply not necessary unless you actually notice slow rendering &amp;ndash; plus, it could cause a lot of confusion later. For example, imagine another developer who&amp;rsquo;s not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn&amp;rsquo;t updating correctly.</source>
          <target state="translated">다시이 패턴을 과도하게 사용하지 마십시오. 정적 콘텐츠를 많이 렌더링해야하는 드문 경우에는 편리하지만 실제로 렌더링 속도가 느려지지 않는 한 필요하지 않습니다. 나중에 혼란을 일으킬 수 있습니다. 예를 들어, &lt;code&gt;v-once&lt;/code&gt; 에 익숙하지 않거나 템플릿에서 간단하게 놓친 다른 개발자를 상상해보십시오 . 템플릿이 올바르게 업데이트되지 않는 이유를 파악하는 데 몇 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74c60c8736c1be5dff55d13ab945f687b554058" translate="yes" xml:space="preserve">
          <source>Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering - plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with &lt;code&gt;v-once&lt;/code&gt; or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167f3f5ddd7e9428d499efaab9f381bdb3ed2c55" translate="yes" xml:space="preserve">
          <source>Once from &lt;code&gt;$emit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c922783f828b42530826b639b30161731661fae" translate="yes" xml:space="preserve">
          <source>Once from a native event listener applied to the root element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60427c06e75efde50ce039ae0b452cc000ae7ef8" translate="yes" xml:space="preserve">
          <source>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</source>
          <target state="translated">일단 관찰되면 더 이상 루트 데이터 오브젝트에 반응성 특성을 추가 할 수 없습니다. 따라서 인스턴스를 만들기 전에 모든 루트 수준 반응 속성을 미리 선언하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8b9b74226ba51585f69fe08ce0443127353058d" translate="yes" xml:space="preserve">
          <source>Once the file is created we will need to open it with our editor of choice and add the following code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decb1a1fde9ee9b3e759b559bcf2ede344d13377" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you&amp;rsquo;ve just digested, we recommend coming back to read the full guide on &lt;a href=&quot;components-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="translated">방금 요약 한 지식에 익숙해지면 &lt;a href=&quot;components-dynamic-async&quot;&gt;동적 및 비동기 구성 요소&lt;/a&gt; 에 대한 전체 안내서와 사이드 바의 심층 구성 요소 섹션에있는 다른 페이지를 다시 읽어 보시기 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="60acc179819cc9885eb67653fbd8f4d03d08954a" translate="yes" xml:space="preserve">
          <source>Once you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on &lt;a href=&quot;component-dynamic-async&quot;&gt;Dynamic &amp;amp; Async Components&lt;/a&gt;, as well as the other pages in the Components In-Depth section of the sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50329c826448bbda1ee5ce8c2c416fac8c003a3" translate="yes" xml:space="preserve">
          <source>One important note is that these FLIP transitions do not work with elements set to &lt;code&gt;display: inline&lt;/code&gt;. As an alternative, you can use &lt;code&gt;display: inline-block&lt;/code&gt; or place elements in a flex context.</source>
          <target state="translated">한 가지 중요한 참고 사항은 이러한 FLIP 전환이 &lt;code&gt;display: inline&lt;/code&gt; 설정된 요소에서 작동하지 않는다는 것입니다 . 대안으로 &lt;code&gt;display: inline-block&lt;/code&gt; 하거나 플렉스 컨텍스트에 요소를 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15a19c04bf3761da4954cadebd24295dde2b8675" translate="yes" xml:space="preserve">
          <source>One important thing to note is that &lt;strong&gt;separation of concerns is not equal to separation of file types.&lt;/strong&gt; In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</source>
          <target state="translated">주의해야 할 중요한 사항은 &lt;strong&gt;우려 분리가 파일 유형 분리와 같지 않다는 것입니다. &lt;/strong&gt;현대의 UI 개발에서 우리는 코드베이스를 서로 얽히는 3 개의 거대한 레이어로 나누는 대신 느슨하게 결합 된 컴포넌트로 나누고 구성하는 것이 훨씬 더 합리적이라는 것을 알았습니다. 구성 요소 내에서 템플릿, 논리 및 스타일이 본질적으로 결합되어 있으며이를 배치하면 실제로 구성 요소를보다 응집력 있고 유지 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c093743cd92f3eef8061e180eeec927b862729" translate="yes" xml:space="preserve">
          <source>One of the issues with placeholders is that they don't meet the &lt;a href=&quot;https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html&quot;&gt;color contrast criteria (opens new window)&lt;/a&gt; by default; fixing the color contrast makes the placeholder look like pre-populated data in the input fields. Looking at the following example, you can see that the Last Name placeholder which meets the color contrast criteria looks like pre-populated data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba41464fb51dc3d17291a7984b07e3ead107d6cd" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here&amp;rsquo;s an example:</source>
          <target state="translated">가장 일반적인 전환 유형 중 하나는 CSS 전환을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3084514831f9a3660901b496859b78c114ded95" translate="yes" xml:space="preserve">
          <source>One of the most common transition types uses CSS transitions. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b71ee323d52ac501596f9b35d6767689ddb4ebc" translate="yes" xml:space="preserve">
          <source>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt;listen to an &lt;code&gt;$emit&lt;/code&gt; from a child with &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt;. This allows you to keep the convenience of events with added explicitness.</source>
          <target state="translated">이러한 방법의 가장 일반적인 용도 중 하나는 부모와 직계 자녀 사이의 의사 소통입니다. 이 경우 실제로 &lt;a href=&quot;components#Form-Input-Components-using-Custom-Events&quot;&gt; &lt;code&gt;v-on&lt;/code&gt; 을&lt;/a&gt; 가진 자식 의 &lt;code&gt;$emit&lt;/code&gt; 을 들을 수 있습니다 . 이를 통해 명시 성이 추가 된 이벤트의 편의를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f582da9a59b59f7794fc88389aa5092b1a4c440b" translate="yes" xml:space="preserve">
          <source>One of the most important pieces of accessibility is making sure that design can support accessible implementation. Design should consider not only color contrast, font selection, text sizing, and language, but also how the content is structured in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5441c2b16e737c07dfa65dd03fc760dc9068959" translate="yes" xml:space="preserve">
          <source>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1aa62162a2a83d170cfdbdcd416abaeb0b419" translate="yes" xml:space="preserve">
          <source>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70774a581a1c775647bf86a829f4e0651d0e222a" translate="yes" xml:space="preserve">
          <source>One or More Named Parameters &lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">하나 이상의 명명 된 매개 변수가 &lt;sup&gt;변경됨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4e3d2bc9560217cd384652200da10fbf0bdb8e0b" translate="yes" xml:space="preserve">
          <source>One thing to note: similar to how &lt;code&gt;v-bind:class&lt;/code&gt; and &lt;code&gt;v-bind:style&lt;/code&gt; have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as &lt;code&gt;innerHTML&lt;/code&gt; (this would replace the &lt;code&gt;v-html&lt;/code&gt; directive):</source>
          <target state="translated">한 가지 주목할 점 : &lt;code&gt;v-bind:class&lt;/code&gt; 및 &lt;code&gt;v-bind:style&lt;/code&gt; 이 템플릿에서 특별한 처리 를하는 방식과 유사하게 VNode 데이터 객체에 자체 최상위 필드가 있습니다. 이 객체를 사용하면 &lt;code&gt;innerHTML&lt;/code&gt; 과 같은 DOM 속성뿐만 아니라 일반 HTML 속성도 바인딩 할 수 있습니다 ( &lt;code&gt;v-html&lt;/code&gt; 지시문을 대체 함 ).</target>
        </trans-unit>
        <trans-unit id="0d00cba8d56cb34c07366778b058997e1e6be989" translate="yes" xml:space="preserve">
          <source>One time bindings (&lt;code&gt;{{* foo }}&lt;/code&gt;) have been replaced by the new &lt;a href=&quot;../api/index#v-once&quot;&gt;&lt;code&gt;v-once&lt;/code&gt; directive&lt;/a&gt;.</source>
          <target state="translated">한 번의 바인딩 ( &lt;code&gt;{{* foo }}&lt;/code&gt; )이 새로운 &lt;a href=&quot;../api/index#v-once&quot;&gt; &lt;code&gt;v-once&lt;/code&gt; 지시문&lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b15ca056f8f4ec061aff57aa3f191e7c02753b7c" translate="yes" xml:space="preserve">
          <source>One way to share configurations e.g. components or directives among apps is to create a factory function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a0ca5f17117a2d79de1ddff5f7c2037c280f5f" translate="yes" xml:space="preserve">
          <source>One-Time Bindings &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">일회성 바인딩 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="6a82bece6c6f4d9547ea740b83ea3c0446063eb1" translate="yes" xml:space="preserve">
          <source>One-Way Data Flow</source>
          <target state="translated">단방향 데이터 흐름</target>
        </trans-unit>
        <trans-unit id="545c63628a39318763f613482d1fbb98218b985f" translate="yes" xml:space="preserve">
          <source>Only UMD builds are available from Bower.</source>
          <target state="translated">Bower는 UMD 빌드 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb58a0b3374e0000a3d5235d1868b2071496402" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so if you&amp;rsquo;re updating Vue, you&amp;rsquo;ll have to update Vue Router as well. That&amp;rsquo;s why we&amp;rsquo;ve included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue Router docs&lt;/a&gt;.</source>
          <target state="translated">Vue Router 2 만 Vue 2와 호환되므로 Vue를 업데이트하는 경우 Vue Router도 업데이트해야합니다. 이것이 주요 문서에서 마이그레이션 경로에 대한 세부 정보를 여기에 포함시킨 이유입니다. 새로운 Vue 라우터 사용에 대한 전체 안내서는 &lt;a href=&quot;https://router.vuejs.org/en/&quot;&gt;Vue 라우터 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83950822db2f31bcab4a982049e8a2377ef9aa81" translate="yes" xml:space="preserve">
          <source>Only Vue Router 2 is compatible with Vue 2, so yes, you&amp;rsquo;ll have to follow the &lt;a href=&quot;migration-vue-router&quot;&gt;migration path for Vue Router&lt;/a&gt; as well. Fortunately, most applications don&amp;rsquo;t have a lot of router code, so this likely won&amp;rsquo;t take more than an hour.</source>
          <target state="translated">Vue Router 2 만 Vue 2와 호환되므로 &lt;a href=&quot;migration-vue-router&quot;&gt;Vue Router&lt;/a&gt; 의 마이그레이션 경로 를 따라야합니다 . 다행히도 대부분의 응용 프로그램에는 많은 라우터 코드가 없으므로 1 시간 이상 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cbd6f69ac9f00bc6cc9a5cada50b773f8b9b204" translate="yes" xml:space="preserve">
          <source>Only in 2.2.0+: Also works with Array + index.</source>
          <target state="translated">2.2.0+에서만 : Array + index 와도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1c17fd71b6108eae91a98b2783d1ada7a72eca67" translate="yes" xml:space="preserve">
          <source>Opacity behaves similarly. Thus, they are ideal candidates for movement on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c41eb847c8622b8581eed87c208351ff18e6769" translate="yes" xml:space="preserve">
          <source>Operable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caec8acecc60ba151e62b5850f83574dfd99c0d7" translate="yes" xml:space="preserve">
          <source>Optimal compatibility with the Vue ecosystem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95478f28e516ba5806445048a3c04633ee9620d8" translate="yes" xml:space="preserve">
          <source>Optimization Efforts</source>
          <target state="translated">최적화 노력</target>
        </trans-unit>
        <trans-unit id="e4b9f85b5d7b01dca8287331249e33d3c5156887" translate="yes" xml:space="preserve">
          <source>Option #1: Use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6301bb50d7829f5c1bc253cc74ede56ad6a957e0" translate="yes" xml:space="preserve">
          <source>Option #2: Default Slot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780c075090673488095ee8c24e310c188ceb0e25" translate="yes" xml:space="preserve">
          <source>Option Merging</source>
          <target state="translated">옵션 병합</target>
        </trans-unit>
        <trans-unit id="f674131a41d74d291985eeac34569e45a2796480" translate="yes" xml:space="preserve">
          <source>Optional configuration options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b239efa2fca3d9404779824c96746803cb0ac3" translate="yes" xml:space="preserve">
          <source>Options / Assets</source>
          <target state="translated">옵션 / 자산</target>
        </trans-unit>
        <trans-unit id="a8322b7d3e6ea2843e0f110827e9f381192e83db" translate="yes" xml:space="preserve">
          <source>Options / Composition</source>
          <target state="translated">옵션 / 구성</target>
        </trans-unit>
        <trans-unit id="23f8ac645a29b2a587df1e001744b1d9555b758c" translate="yes" xml:space="preserve">
          <source>Options / DOM</source>
          <target state="translated">옵션 / DOM</target>
        </trans-unit>
        <trans-unit id="7e61ca3b6c7817347db226ad3551cc64c2d446f7" translate="yes" xml:space="preserve">
          <source>Options / Data</source>
          <target state="translated">옵션 / 데이터</target>
        </trans-unit>
        <trans-unit id="83461f255e0b700d1fc468a6266119fa610f9019" translate="yes" xml:space="preserve">
          <source>Options / Lifecycle Hooks</source>
          <target state="translated">옵션 / 라이프 사이클 후크</target>
        </trans-unit>
        <trans-unit id="7d2f97ccdee65e286d78a496a5ee8cd549c930ee" translate="yes" xml:space="preserve">
          <source>Options / Misc</source>
          <target state="translated">옵션 / 기타</target>
        </trans-unit>
        <trans-unit id="b30e44ad585ea6e546f21a0445864b10944795c8" translate="yes" xml:space="preserve">
          <source>Options / Misc - inheritAttrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474ba12c459599d7f3d05d19597c94aa345c6ae6" translate="yes" xml:space="preserve">
          <source>Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65a7777ad439fc6385d6da8d4c12a4f89868164" translate="yes" xml:space="preserve">
          <source>Options such as &lt;code&gt;acceptStatement&lt;/code&gt;, &lt;code&gt;deep&lt;/code&gt;, &lt;code&gt;priority&lt;/code&gt;, etc have all been removed. To replace &lt;code&gt;twoWay&lt;/code&gt; directives, see &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;this example&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;acceptStatement&lt;/code&gt; , &lt;code&gt;deep&lt;/code&gt; , &lt;code&gt;priority&lt;/code&gt; 등과 같은 옵션 이 모두 제거되었습니다. &lt;code&gt;twoWay&lt;/code&gt; 지시문 을 바꾸려면 &lt;a href=&quot;#Two-Way-Filters-replaced&quot;&gt;이 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="268262a68726a842a9214f48a664175ac456e7a4" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component&amp;rsquo;s options will take priority when there are conflicting keys in these objects:</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; , &lt;code&gt;components&lt;/code&gt; 및 &lt;code&gt;directives&lt;/code&gt; 과 같은 오브젝트 값을 예상하는 옵션 은 동일한 오브젝트로 병합됩니다. 이러한 객체에 충돌하는 키가있는 경우 구성 요소 옵션이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="2cf7aafc0cf21a0635200b597f31b1c9a97361eb" translate="yes" xml:space="preserve">
          <source>Options that expect object values, for example &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;components&lt;/code&gt; and &lt;code&gt;directives&lt;/code&gt;, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cccb1cf88b26495b712b582b1851dcc7cb203e2" translate="yes" xml:space="preserve">
          <source>Or a &lt;code&gt;setup&lt;/code&gt; function, function name will be used as component name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8a33817f19f064f5e6cf9b1efc94083145cda9" translate="yes" xml:space="preserve">
          <source>Or a data/computed property:</source>
          <target state="translated">또는 데이터 / 계산 속성 :</target>
        </trans-unit>
        <trans-unit id="60f24c4199344a7f41d53a7637411a2eabdf966c" translate="yes" xml:space="preserve">
          <source>Or a render function:</source>
          <target state="translated">또는 렌더링 기능 :</target>
        </trans-unit>
        <trans-unit id="023f1403c5535c7569fdca6e12645578c310b4c5" translate="yes" xml:space="preserve">
          <source>Or alternatively, you could use Webpack&amp;rsquo;s asynchronous &lt;code&gt;import&lt;/code&gt; when you register the component locally:</source>
          <target state="translated">또는 구성 요소를 로컬로 등록 할 때 Webpack의 비동기 &lt;code&gt;import&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45c03a2813f8f4d2212c4aad0f6ca1365bfc8c76" translate="yes" xml:space="preserve">
          <source>Or better yet, pass removal methods an index:</source>
          <target state="translated">또는 더 나은 방법으로 제거 방법에 색인을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="7655b19551e9be2b132e49ba50a30e1355a9890c" translate="yes" xml:space="preserve">
          <source>Or even other components:</source>
          <target state="translated">또는 다른 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="03b6295d62d0a9f390c82c14d8335ae12a8dffb8" translate="yes" xml:space="preserve">
          <source>Or if &lt;code&gt;myElement&lt;/code&gt; is the last child:</source>
          <target state="translated">또는 &lt;code&gt;myElement&lt;/code&gt; 가 마지막 자식 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a001bd7723a1c2e569009fd7dcd66c9ec91d9d8c" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="translated">또는 Babel 및 Webpack과 같은 ES2015 모듈을 사용하는 경우 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b481ed2ba5dbbc7e0f7386d267111e8bdfabf1ae" translate="yes" xml:space="preserve">
          <source>Or if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8ab6aa568615f78c04477ef62787486065b5dc" translate="yes" xml:space="preserve">
          <source>Or in a render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4959514a6e663f87294927771d85f57df1ba3c86" translate="yes" xml:space="preserve">
          <source>Or with Yarn:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f03f9044ac60a104f95613db5b63ecc9c3a137" translate="yes" xml:space="preserve">
          <source>Or with a render function:</source>
          <target state="translated">또는 렌더링 함수를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="7f55d71b1414a39798d6cca5dd9a4e4bcb171abc" translate="yes" xml:space="preserve">
          <source>Or with component methods:</source>
          <target state="translated">또는 구성 요소 방법으로 :</target>
        </trans-unit>
        <trans-unit id="af14db0c16953bef3557a6e30a1aace5e18d1edd" translate="yes" xml:space="preserve">
          <source>Or, for the more advanced component syntax with options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e16431e1f0d282812696aa421107f6f8ecec16e" translate="yes" xml:space="preserve">
          <source>Or, for those who preferred the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; in a single-file component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d7bb6d9a77fedd188db250f7b0d093aca38d2" translate="yes" xml:space="preserve">
          <source>Or, if the event handler is a method:</source>
          <target state="translated">또는 이벤트 핸들러가 메소드 인 경우 :</target>
        </trans-unit>
        <trans-unit id="283f8ac5294276aa36ea18c510c09f047be7a9ce" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;re using the runtime-only build of Vue:</source>
          <target state="translated">또는 런타임 전용 Vue 빌드를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1ce87eef2b959ce134a14284177345e12a8eb332" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve been unit-testing an application involving &lt;a href=&quot;../component-dynamic-async&quot;&gt;async components&lt;/a&gt;, chances are you&amp;rsquo;ve written something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dd049e1164508d70fdffd3fa7096495d134200" translate="yes" xml:space="preserve">
          <source>Or, the &lt;code&gt;slot&lt;/code&gt; attribute can also be used directly on a normal element:</source>
          <target state="translated">또는 &lt;code&gt;slot&lt;/code&gt; 속성을 일반 요소에서 직접 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab1ce11bd9c8abf32d55c7982f3dae620e8cb0a" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c548ba963676210f5bfb2bdd1152c86a09840f88" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify (opens new window)&lt;/a&gt; with Gulp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda804a2c09c29b8cf6a5a0b90c532b90ce7782e" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Grunt and &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt-browserify&lt;/a&gt;:</source>
          <target state="translated">또는 Grunt 및 &lt;a href=&quot;https://github.com/jmreidy/grunt-browserify&quot;&gt;grunt- &lt;/a&gt;&lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;browserify&lt;/a&gt; 와 함께 envify 사용 :</target>
        </trans-unit>
        <trans-unit id="4a6aaeff2cbead89c1f4935f438fab6a604b15ba" translate="yes" xml:space="preserve">
          <source>Or, using &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; with Gulp:</source>
          <target state="translated">또는 Gulp와 함께 &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;envify&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="f1956be0d3870d999ee378a0178cc016dd3ada0f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;@click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;@click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dde4fa7292ce9cc3269b98cdb60ec01006edb1f" translate="yes" xml:space="preserve">
          <source>Order matters when using modifiers because the relevant code is generated in the same order. Therefore using &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; will prevent &lt;strong&gt;all clicks&lt;/strong&gt; while &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; will only prevent clicks on the element itself.</source>
          <target state="translated">관련 코드가 동일한 순서로 생성되므로 수정자를 사용할 때 순서가 중요합니다. 따라서 &lt;code&gt;v-on:click.prevent.self&lt;/code&gt; 를 사용하면 &lt;strong&gt;모든 클릭&lt;/strong&gt; 이 차단 되고 &lt;code&gt;v-on:click.self.prevent&lt;/code&gt; 는 요소 자체의 클릭 만 방지합니다.</target>
        </trans-unit>
        <trans-unit id="39e64d7abff6f773ffb6cbec098e4c76feffd596" translate="yes" xml:space="preserve">
          <source>Order of words in component names</source>
          <target state="translated">구성 요소 이름의 단어 순서</target>
        </trans-unit>
        <trans-unit id="4ca3deef66606ab2cc6dd3240ad8a0d842c161e3" translate="yes" xml:space="preserve">
          <source>Order of words in component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">구성 요소 이름의 단어 순서를 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="519255ae1f74ffc5ddd29979295c7572f048ad81" translate="yes" xml:space="preserve">
          <source>Organization</source>
          <target state="translated">Organization</target>
        </trans-unit>
        <trans-unit id="ce2a84f2c2447c5ea7220c9144eb3ca335437fca" translate="yes" xml:space="preserve">
          <source>Organizing Components</source>
          <target state="translated">구성 요소 구성</target>
        </trans-unit>
        <trans-unit id="c5c0f6920c95f31314076af49b17314ea73698db" translate="yes" xml:space="preserve">
          <source>Organizing Transitions into Components</source>
          <target state="translated">구성 요소로 전환 구성</target>
        </trans-unit>
        <trans-unit id="360d7d42956f7872b9ede3cea3c30a3ba0acec02" translate="yes" xml:space="preserve">
          <source>Organizing logics with component's options (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;computed&lt;/code&gt;, &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;watch&lt;/code&gt;) works in most cases. However, when our components get bigger, the list of &lt;strong&gt;logical concerns&lt;/strong&gt; also grows. This can lead to components that are hard to read and understand, especially for people who didn't write them in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba799c410addb3c357f8f4ace9cc3fe6bde69ff" translate="yes" xml:space="preserve">
          <source>Other Examples</source>
          <target state="translated">다른 예</target>
        </trans-unit>
        <trans-unit id="c3d0ce766708c752c9789d75994b0abdc210827b" translate="yes" xml:space="preserve">
          <source>Other Helpful Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f144ccf73f0c206f299610267139c1512e90bc" translate="yes" xml:space="preserve">
          <source>Other Minor Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12ddde082114607d0effddf28c1425f7adad67d" translate="yes" xml:space="preserve">
          <source>Other Projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8096cf3d3237b4ba8c7121f2a65c1398f3cfa1d7" translate="yes" xml:space="preserve">
          <source>Other non-boolean attrs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8975bed11b093ad4d25765fbdba52b25cdf43ca" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;Code of Conduct&lt;/a&gt; is a guide to make it easier to enrich all of us and the technical communities in which we participate.</source>
          <target state="translated">우리 &lt;a href=&quot;https://vuejs.org/coc&quot;&gt;의 행동 강령&lt;/a&gt; 은 우리 모두와 우리가 참여하는 기술 커뮤니티를 더욱 풍요롭게 해주는 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="e13c5dab7f9b9edcb291ceb3ccaa49cace4cfdc4" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases.</source>
          <target state="translated">우리의 맞춤형 지시문은 이제 몇 가지 다른 사용 사례를 지원할 수있을 정도로 유연합니다.</target>
        </trans-unit>
        <trans-unit id="6914ca8cedbdd86cdefec4f8279bb23f3c749797" translate="yes" xml:space="preserve">
          <source>Our custom directive is now flexible enough to support a few different use cases. To make it even more dynamic, we can also allow to modify a bound value. Let's create an additional property &lt;code&gt;pinPadding&lt;/code&gt; and bind it to the &lt;code&gt;&amp;lt;input type=&quot;range&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f52ec20ab2f8bf7b37f62b547cb8e20c076916" translate="yes" xml:space="preserve">
          <source>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</source>
          <target state="translated">설정 코드는 정리 코드와 별도로 유지되므로 설정 한 내용을 프로그래밍 방식으로 정리하기가 더 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="238d7a51a5c3679447b882c1766791e18087ee23" translate="yes" xml:space="preserve">
          <source>Over time though, Knockout development has slowed and it&amp;rsquo;s begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it&amp;rsquo;s a very common use case, the interface for passing children to a component feels a little clunky compared to &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&amp;rsquo;s&lt;/a&gt;.</source>
          <target state="translated">그러나 시간이 지남에 따라 녹아웃 개발 속도가 느려지고 나이가 조금 들기 시작했습니다. 예를 들어, 구성 요소 시스템에는 전체 수명주기 후크가 없으며 매우 일반적인 사용 사례이지만 구성 요소에 자식을 전달하기위한 인터페이스는 &lt;a href=&quot;components#Content-Distribution-with-Slots&quot;&gt;Vue&lt;/a&gt; 와 비교할 때 약간 복잡 합니다.</target>
        </trans-unit>
        <trans-unit id="801ee7630523d9225a5832eb0b586c416639bcdd" translate="yes" xml:space="preserve">
          <source>Overall this removes the need for a whole class of performance optimizations from the developer&amp;rsquo;s plate, and allows them to focus more on building the app itself as it scales.</source>
          <target state="translated">전반적으로 이것은 개발자의 판에서 전체 성능 최적화 클래스의 필요성을 제거하고 앱이 확장 될 때 앱 자체를 빌드하는 데 더 집중할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="9ddaaee77cc1ce72a49a759b344df34d9c4b8e47" translate="yes" xml:space="preserve">
          <source>Parcel</source>
          <target state="translated">Parcel</target>
        </trans-unit>
        <trans-unit id="33422ae8d86c599fdf8a4eca4a9f0b44c416cdcc" translate="yes" xml:space="preserve">
          <source>Partials have been removed in favor of more explicit data flow between components, using props. Unless you&amp;rsquo;re using a partial in a performance-critical area, the recommendation is to use a &lt;a href=&quot;components&quot;&gt;normal component&lt;/a&gt; instead. If you were dynamically binding the &lt;code&gt;name&lt;/code&gt; of a partial, you can use a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;.</source>
          <target state="translated">소품을 사용하여 구성 요소 간의보다 명확한 데이터 흐름을 위해 일부가 제거되었습니다. 성능이 중요한 영역에서 부분을 사용하지 않는 한 &lt;a href=&quot;components&quot;&gt;일반 구성 요소를&lt;/a&gt; 대신 사용하는 것이 좋습니다 . 부분 의 &lt;code&gt;name&lt;/code&gt; 을 동적으로 바인딩하는 경우 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;동적 구성 요소를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="338863b7eee72484e07f62862d08e6032c44cc9e" translate="yes" xml:space="preserve">
          <source>PascalCase has a few advantages over kebab-case:</source>
          <target state="translated">PascalCase는 케밥 케이스에 비해 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="548d3885edc6e4335d13093c595410a7b884affc" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it&amp;rsquo;s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="translated">PascalCase는 가능한 경우 JS (X) 및 템플릿의 구성 요소를 참조하는 방식과 일치하므로 코드 편집기의 자동 완성과 함께 가장 잘 작동합니다. 그러나 대소 문자가 혼합 된 파일 이름은 대소 문자를 구분하지 않는 파일 시스템에서 문제를 일으킬 수 있으므로 케밥 케이스도 완벽하게 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="030bc27225285970757d5743a8972ff008b358d3" translate="yes" xml:space="preserve">
          <source>PascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a196eac2c28fafbe4d9187661633bcbf6027ce5" translate="yes" xml:space="preserve">
          <source>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</source>
          <target state="translated">소품을 만드는 동안 소품을 전달하십시오. 이는 단위 테스트를보다 쉽게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b15f86774ec499f2e12e99cefb07c19682388f39" translate="yes" xml:space="preserve">
          <source>Passing Attributes and Events to Child Elements/Components</source>
          <target state="translated">자식 요소 / 구성 요소에 특성 및 이벤트 전달</target>
        </trans-unit>
        <trans-unit id="2d887895f60f5b27f1b6d8b4caca996b7ba1b2ec" translate="yes" xml:space="preserve">
          <source>Passing Data to Child Components with Props</source>
          <target state="translated">소품으로 데이터를 자식 구성 요소에 전달</target>
        </trans-unit>
        <trans-unit id="433763659eeaa495cbff9aab4fe004119a2898a6" translate="yes" xml:space="preserve">
          <source>Passing Static or Dynamic Props</source>
          <target state="translated">정적 또는 동적 소품 전달</target>
        </trans-unit>
        <trans-unit id="69be14b609ea17960c4d679c5eac924f94c81a81" translate="yes" xml:space="preserve">
          <source>Passing a Boolean</source>
          <target state="translated">부울 전달</target>
        </trans-unit>
        <trans-unit id="d0fe306e90e1b3d68f9dfb33a59e5241fa360572" translate="yes" xml:space="preserve">
          <source>Passing a Number</source>
          <target state="translated">숫자 전달</target>
        </trans-unit>
        <trans-unit id="7c0a78154538069738bcf2cc5806f8c67f3744ba" translate="yes" xml:space="preserve">
          <source>Passing an Array</source>
          <target state="translated">배열 전달</target>
        </trans-unit>
        <trans-unit id="acf0b569b0457811ee77b0ce38bc6a81b61b14f2" translate="yes" xml:space="preserve">
          <source>Passing an Object</source>
          <target state="translated">객체 전달</target>
        </trans-unit>
        <trans-unit id="d7c9bb0f37131e5505011ab717b8002aabd88b14" translate="yes" xml:space="preserve">
          <source>Passing in &lt;code&gt;immediate: true&lt;/code&gt; in the option will trigger the callback immediately with the current value of the expression:</source>
          <target state="translated">&lt;code&gt;immediate: true&lt;/code&gt; 전달 : 옵션에서 true 는 표현식의 현재 값으로 즉시 콜백을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="035acdf774e378174fd9c2b1135b63f7dfac1cf3" translate="yes" xml:space="preserve">
          <source>Passing the Properties of an Object</source>
          <target state="translated">객체의 속성 전달</target>
        </trans-unit>
        <trans-unit id="c6e21e8099f57238a0c9760ebd07a5a614584331" translate="yes" xml:space="preserve">
          <source>People need to feel safe asking questions when contributing/reviewing content. Here's how you can do that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e116a18efa00a0e0767d89a0a941c40133b88a" translate="yes" xml:space="preserve">
          <source>Perceivable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf952b12947766273332fa80b06a64c003fbf12" translate="yes" xml:space="preserve">
          <source>Perform the side effect lazily;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="93bd1b9f8459e0acda65f78340bb55e6188adccd" translate="yes" xml:space="preserve">
          <source>Performance gains from 2.x for functional components are now negligible in 3.x, so we recommend just using stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c141d90b1516060d8a91d0883b728d5ba2fca7a4" translate="yes" xml:space="preserve">
          <source>Performance-wise, Vue outperforms Ember &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;by a fair margin&lt;/a&gt;, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</source>
          <target state="translated">성능 현명한, 뷰 성능이 뛰어 엠버 &lt;a href=&quot;https://stefankrause.net/js-frameworks-benchmark8/table.html&quot;&gt;공정의 차이로&lt;/a&gt; 도 엠버 3.x에서의 최신 희미한 빛의 엔진 업데이트 후, Vue는 자동으로 업데이트를 일괄 처리하지만 Ember에서는 성능이 중요한 상황에서 실행 루프를 수동으로 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed212fa164b940b935ec0a25b32878a0917c7268" translate="yes" xml:space="preserve">
          <source>Placeholder</source>
          <target state="translated">Placeholder</target>
        </trans-unit>
        <trans-unit id="11275f5de90c26fd6cc8ef9a7af920c6f1101f2b" translate="yes" xml:space="preserve">
          <source>Please note we used &lt;code&gt;model-value&lt;/code&gt; with kebab-case here because we are working with in-DOM templates. You can find a detailed explanation on kebab-cased vs camelCased attributes in the &lt;a href=&quot;#dom-template-parsing-caveats&quot;&gt;DOM Template Parsing Caveats&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ba11f36689ab7bebcb8bac7bb946785fdc5fcf" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode class declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js&quot;&gt;VNode 클래스 선언을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac81e979c05bfcd7c0a62185f40c627cb4bf8d0e" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer package documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer&quot;&gt;vue-server-renderer 패키지 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dadf730922f5cc0e3cc5b34354923331bd7cd59" translate="yes" xml:space="preserve">
          <source>Plugin users will now be able to &lt;code&gt;inject['i18n']&lt;/code&gt; into their components and access the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="a39e5a3d43de88abead0db5ad2318b757a0d742a" translate="yes" xml:space="preserve">
          <source>Plugins also allow us to use &lt;code&gt;inject&lt;/code&gt; to provide a function or attribute to the plugin's users. For example, we can allow the application to have access to the &lt;code&gt;options&lt;/code&gt; parameter to be able to use the translations object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd12b92cd6c82b740fa6a101861368f2df9e451" translate="yes" xml:space="preserve">
          <source>Plugins are self-contained code that usually add global-level functionality to Vue. It is either an &lt;code&gt;object&lt;/code&gt; that exposes an &lt;code&gt;install()&lt;/code&gt; method, or a &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec26164bdb69a59c55861e3e8bf8c2338afa489" translate="yes" xml:space="preserve">
          <source>Plugins may add to Vue&amp;rsquo;s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there&amp;rsquo;s a TypeScript feature to augment existing types called &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;module augmentation&lt;/a&gt;.</source>
          <target state="translated">플러그인은 Vue의 글로벌 / 인스턴스 속성 및 컴포넌트 옵션에 추가 될 수 있습니다. 이 경우 TypeScript에서 플러그인을 컴파일하려면 형식 선언이 필요합니다. 다행히 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation&quot;&gt;모듈 확대 기능&lt;/a&gt; 이라는 기존 유형을 보강하는 TypeScript 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a77c0e9519023f6d3be8c4d42d0b610cd78973f1" translate="yes" xml:space="preserve">
          <source>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</source>
          <target state="translated">플러그인은 일반적으로 Vue에 글로벌 수준의 기능을 추가합니다. 플러그인에 대해 엄격하게 정의 된 범위는 없습니다. 일반적으로 여러 유형의 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b444c9bbd597a6dbe29c3f8f817d1db7e6559dd" translate="yes" xml:space="preserve">
          <source>Polymer</source>
          <target state="translated">Polymer</target>
        </trans-unit>
        <trans-unit id="48e622aad7a867a5952bf32f2af768cae8dc7ee2" translate="yes" xml:space="preserve">
          <source>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue&amp;rsquo;s components can be loosely compared to Polymer&amp;rsquo;s custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don&amp;rsquo;t support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</source>
          <target state="translated">Polymer는 Google이 후원하는 또 다른 프로젝트이며 실제로 Vue의 영감의 원천이었습니다. Vue의 컴포넌트는 Polymer의 커스텀 엘리먼트와 느슨하게 비교 될 수 있으며 둘 다 매우 유사한 개발 스타일을 제공합니다. 가장 큰 차이점은 Polymer가 최신 웹 구성 요소 기능을 기반으로하며 기본적으로 해당 기능을 지원하지 않는 브라우저에서 성능이 저하되지 않는 사소한 폴리 필이 필요하다는 것입니다. 대조적으로 Vue는 IE9까지의 종속성이나 폴리 필없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e3ed11ed8d0e10e94e25f6a0c663996776050be2" translate="yes" xml:space="preserve">
          <source>Pre-Compiling Templates</source>
          <target state="translated">사전 컴파일 템플릿</target>
        </trans-unit>
        <trans-unit id="15730848aa8545d4e8c4a13694b301ad43855149" translate="yes" xml:space="preserve">
          <source>Preact and Other React-Like Libraries</source>
          <target state="translated">사전 및 기타 반응 형 라이브러리</target>
        </trans-unit>
        <trans-unit id="8329b838710df96576166a6b1eb910a04281650a" translate="yes" xml:space="preserve">
          <source>Precautions</source>
          <target state="translated">Precautions</target>
        </trans-unit>
        <trans-unit id="13b722a113ea767b74d7b7af219e735b33c584e7" translate="yes" xml:space="preserve">
          <source>Prefer class selectors over element selectors in &lt;code&gt;scoped&lt;/code&gt; styles, because large numbers of element selectors are slow.</source>
          <target state="translated">많은 수의 요소 선택기가 느리기 때문에 &lt;code&gt;scoped&lt;/code&gt; 스타일의 요소 선택자보다 클래스 선택자를 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="0862f2579db5a3bc1211bb13bd8e3d71a3009a33" translate="yes" xml:space="preserve">
          <source>Pretty cool, right?</source>
          <target state="translated">멋지다?</target>
        </trans-unit>
        <trans-unit id="1f991a95af1936160af34e1fab9584d14813afc2" translate="yes" xml:space="preserve">
          <source>Prevent Mutating Reactive Objects with &lt;code&gt;readonly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28e5e120a6410b8fa39239f3e826f7cc472afd9" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-el&lt;/code&gt;/&lt;code&gt;v-ref&lt;/code&gt; combined with &lt;code&gt;v-for&lt;/code&gt; would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same &lt;code&gt;ref&lt;/code&gt;:</source>
          <target state="translated">이전에는 &lt;code&gt;v-el&lt;/code&gt; / &lt;code&gt;v-ref&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 를 결합 하면 각 항목에 고유 한 이름을 지정할 수있는 방법이 없었기 때문에 요소 / 구성 요소 배열이 생성되었습니다. 당신은 여전히 각 항목에 동일한 제공하여이 동작을 달성 할 수있는 &lt;code&gt;ref&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d470a2a77dc4521dc133ec45eef2767f713b0387" translate="yes" xml:space="preserve">
          <source>Previously, &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; would have &lt;code&gt;number&lt;/code&gt; starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</source>
          <target state="translated">이전 &lt;code&gt;v-for=&quot;number in 10&quot;&lt;/code&gt; 것이다 &lt;code&gt;number&lt;/code&gt; 0에서 시작하여 9에서 끝나는 지금은 1에서 시작하고 끝나는 10시.</target>
        </trans-unit>
        <trans-unit id="23b9c4376379f9e662432b9880582c302a480f64" translate="yes" xml:space="preserve">
          <source>Previously, async components were created by simply defining a component as a function that returned a promise, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1140ac9954dc5a38cef519f604f5c32be573d951" translate="yes" xml:space="preserve">
          <source>Primarily used to preserve component state or avoid re-rendering.</source>
          <target state="translated">주로 구성 요소 상태를 유지하거나 다시 렌더링하지 않도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcdf83698ed6217a7ad9789255b8e995292e5ef5" translate="yes" xml:space="preserve">
          <source>Prime heading: title of the page</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="54685256c4d8355200332707df1e1ca7c0e02261" translate="yes" xml:space="preserve">
          <source>Priority A Rules: Essential (Error Prevention)</source>
          <target state="translated">우선 순위 A 규칙 : 필수 (오류 방지)</target>
        </trans-unit>
        <trans-unit id="5e8b1025d5987c3729d2b01eada46b2522bba9e3" translate="yes" xml:space="preserve">
          <source>Priority A: Essential</source>
          <target state="translated">우선 순위 A : 필수</target>
        </trans-unit>
        <trans-unit id="387f936830407167742df6ab963bfa0088949c5b" translate="yes" xml:space="preserve">
          <source>Priority B Rules: Strongly Recommended (Improving Readability)</source>
          <target state="translated">우선 순위 B 규칙 : 강력 추천 (가독성 향상)</target>
        </trans-unit>
        <trans-unit id="736596242b03557a18a34e5f65ea6a2b562cbebd" translate="yes" xml:space="preserve">
          <source>Priority B: Strongly Recommended</source>
          <target state="translated">우선 순위 B : 강력 추천</target>
        </trans-unit>
        <trans-unit id="bdd836597207d18ba5b3d19036238a4cd88fa60f" translate="yes" xml:space="preserve">
          <source>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</source>
          <target state="translated">우선 순위 C 규칙 : 권장 (임의 선택 및 최소화 오버 헤드 최소화)</target>
        </trans-unit>
        <trans-unit id="2974ce185c92ec782a626e16a8514e803539b365" translate="yes" xml:space="preserve">
          <source>Priority C: Recommended</source>
          <target state="translated">우선 순위 C : 권장</target>
        </trans-unit>
        <trans-unit id="47bd70395bb96139b28544a3748794466e50c29a" translate="yes" xml:space="preserve">
          <source>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</source>
          <target state="translated">우선 순위 D 규칙 :주의해서 사용 (잠재적으로 위험한 패턴)</target>
        </trans-unit>
        <trans-unit id="94fef0d8e8f642d6dc69557c9f10b185198cefc4" translate="yes" xml:space="preserve">
          <source>Priority D: Use with Caution</source>
          <target state="translated">우선 순위 D :주의해서 사용</target>
        </trans-unit>
        <trans-unit id="f5cd87102ef90d5553f07151bd4bd9dd0bc22e76" translate="yes" xml:space="preserve">
          <source>Private property names</source>
          <target state="translated">개인 재산 이름</target>
        </trans-unit>
        <trans-unit id="190351e7c1964109dd0d07bb44b4406d321887f5" translate="yes" xml:space="preserve">
          <source>Private property names &lt;sup&gt;essential&lt;/sup&gt;</source>
          <target state="translated">개인 재산 이름 &lt;sup&gt;필수&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">문제 해결됨!</target>
        </trans-unit>
        <trans-unit id="c5c5063b096172b05347461de69b1892f161c926" translate="yes" xml:space="preserve">
          <source>Production Deployment</source>
          <target state="translated">생산 배포</target>
        </trans-unit>
        <trans-unit id="24b510d5213c71d3e2ce9940d48c8b9fa3d13829" translate="yes" xml:space="preserve">
          <source>Programmatic Event Listeners</source>
          <target state="translated">프로그래밍 방식 이벤트 리스너</target>
        </trans-unit>
        <trans-unit id="6ac41420921db4b82a6fc5a064c1c845ef1ef7bc" translate="yes" xml:space="preserve">
          <source>Programmatic Navigation</source>
          <target state="translated">프로그래밍 방식 탐색</target>
        </trans-unit>
        <trans-unit id="476b867d91093b69a7500380688c889567822c8b" translate="yes" xml:space="preserve">
          <source>Programmatically choose one of several other components to delegate to</source>
          <target state="translated">프로그래밍 할 다른 여러 구성 요소 중 하나를 프로그래밍 방식으로 선택</target>
        </trans-unit>
        <trans-unit id="f6f4da8d93e88a08220e03b7810451d3ba540a34" translate="yes" xml:space="preserve">
          <source>Project</source>
          <target state="translated">Project</target>
        </trans-unit>
        <trans-unit id="ee3cf99bb774be8991c68e2bbfef328b2095ab6c" translate="yes" xml:space="preserve">
          <source>Project Creation</source>
          <target state="translated">프로젝트 생성</target>
        </trans-unit>
        <trans-unit id="cf8dbc35f90ca7fe4e3262afb2f4d8617ccb053f" translate="yes" xml:space="preserve">
          <source>Prop Casing (camelCase vs kebab-case)</source>
          <target state="translated">프롭 케이싱 (낙타 케이스 대 케밥 케이스)</target>
        </trans-unit>
        <trans-unit id="1c763ccd366cdd65c783dc8f22bc1a65ff00cadb" translate="yes" xml:space="preserve">
          <source>Prop Mutation &lt;sup&gt;deprecated&lt;/sup&gt;</source>
          <target state="translated">Prop Mutation &lt;sup&gt;지원 중단&lt;/sup&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
