<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="vue">
    <body>
      <group id="vue">
        <trans-unit id="be3c142060e44ba8c62b670b8883bcca7cd5a4cc" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read &lt;a href=&quot;component-provide-inject&quot;&gt;Provide / Inject&lt;/a&gt;, &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt;, and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b0a231c686d6b708f4d2d26c98389f653ba04e" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have already read the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API Introduction&lt;/a&gt; and &lt;a href=&quot;reactivity-fundamentals&quot;&gt;Reactivity Fundamentals&lt;/a&gt;. Read that first if you are new to Composition API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a1f77be28de1f8cd112541c8e445f32b88426b" translate="yes" xml:space="preserve">
          <source>This guide is primarily for users with prior Vue 2 experience who want to learn about the new features and changes in Vue 3. &lt;strong&gt;This is not something you have to read from top to bottom before trying out Vue 3.&lt;/strong&gt; While it looks like a lot has changed, a lot of what you know and love about Vue is still the same; but we wanted to be as thorough as possible and provide detailed explanations and examples for every documented change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029497cad2c3a227399525b3094cb469885f9f59" translate="yes" xml:space="preserve">
          <source>This guide will provide an overview of different design elements that are available for your use in creating documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d8b5af0048a10c4665e00dd894160ce4940650" translate="yes" xml:space="preserve">
          <source>This has been replaced with a &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt;&lt;code&gt;scrollBehavior&lt;/code&gt; option&lt;/a&gt; that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</source>
          <target state="translated">이 기능은 함수를 허용 하는 &lt;a href=&quot;https://router.vuejs.org/en/advanced/scroll-behavior.html&quot;&gt; &lt;code&gt;scrollBehavior&lt;/code&gt; 옵션&lt;/a&gt; 으로 대체 되었으므로 경로마다 스크롤 동작을 완전히 사용자 정의 할 수 있습니다. 이것은 많은 새로운 가능성을 열어 주지만 다음과 같은 오래된 행동을 재현합니다.</target>
        </trans-unit>
        <trans-unit id="f10052c0b9e092f83c38d6274c0a1d795d171aa8" translate="yes" xml:space="preserve">
          <source>This has been reworked as a &lt;a href=&quot;../api/index#delimiters&quot;&gt;component-level option&lt;/a&gt;. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</source>
          <target state="translated">이것은 &lt;a href=&quot;../api/index#delimiters&quot;&gt;컴포넌트 레벨 옵션&lt;/a&gt; 으로 재 작업되었습니다 . 이를 통해 타사 구성 요소를 손상시키지 않고 앱 내에서 대체 구분 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="898f8bcaeb338ce5f524c8f533de606d8f44d3a0" translate="yes" xml:space="preserve">
          <source>This has quickly gotten out of hand. That&amp;rsquo;s why to provide context information to descendent components arbitrarily deep, we instead recommend &lt;a href=&quot;#Dependency-Injection&quot;&gt;dependency injection&lt;/a&gt;.</source>
          <target state="translated">이것은 빨리 손을 go습니다. 따라서 하위 구성 요소에 컨텍스트 정보를 임의로 제공하는 대신 &lt;a href=&quot;#Dependency-Injection&quot;&gt;종속성 삽입을&lt;/a&gt; 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="7999999aa4a7bfbcc499f10673ce25fba6720104" translate="yes" xml:space="preserve">
          <source>This has two potential issues:</source>
          <target state="translated">여기에는 두 가지 잠재적 인 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="963611d5d3d89faff52fcf7b4bfcf0767cf6c914" translate="yes" xml:space="preserve">
          <source>This helps you to more quickly find a component when you need to edit it or review how to use it.</source>
          <target state="translated">이를 통해 구성 요소를 편집하거나 사용 방법을 검토해야 할 때 구성 요소를 더 빨리 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="890a52b4154ab564b050c448a049340ff861abb4" translate="yes" xml:space="preserve">
          <source>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</source>
          <target state="translated">이렇게 모듈화 된 기능이 향상되어 Vue 2로 쉽게 마이그레이션 할 수있을뿐만 아니라 통화 구문 분석 및 서식을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436f872e6df27f11a6bfa0004df035d1ba2d2bdf" translate="yes" xml:space="preserve">
          <source>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; component with more complex template and logic without affecting the parent app.</source>
          <target state="translated">이것은 고안된 예이지만 우리는 앱을 두 개의 작은 단위로 분리했으며 자식은 props 인터페이스를 통해 부모와 상당히 분리되어 있습니다. 이제 상위 앱에 영향을주지 않고보다 복잡한 템플릿과 로직으로 &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; 구성 요소를 더욱 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0656ba279b49d46a5cdfd7935d734273e07a9de6" translate="yes" xml:space="preserve">
          <source>This is a great tip to remember!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e19f220c4bd03c63d74d3c19c553f790da9b66d" translate="yes" xml:space="preserve">
          <source>This is a low-level internal API change and does not affect most developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1103f0107c054609536e73ad83ba83989e32a52e" translate="yes" xml:space="preserve">
          <source>This is definitely the most difficult page in the guide to write, but we do feel it&amp;rsquo;s important. Odds are, you&amp;rsquo;ve had problems you tried to solve and you&amp;rsquo;ve used another library to solve them. You&amp;rsquo;re here because you want to know if Vue can solve your specific problems better. That&amp;rsquo;s what we hope to answer for you.</source>
          <target state="translated">이 안내서는 작성하기에 가장 어려운 페이지이지만 확실히 중요하다고 생각합니다. 문제는 해결하려고했던 문제가 있고 다른 라이브러리를 사용하여 해결 한 것입니다. Vue가 특정 문제를 더 잘 해결할 수 있는지 알고 싶기 때문에 여기에 있습니다. 그것이 우리가 당신을 위해 대답하기를 희망하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac302dcb2061f99b9d2af5d1c922a8db1ee40057" translate="yes" xml:space="preserve">
          <source>This is especially important because of &lt;a href=&quot;v-on-native-modifier-removed&quot;&gt;the removal of the &lt;code&gt;.native&lt;/code&gt; modifier&lt;/a&gt;. Any listeners for events that aren't declared with &lt;code&gt;emits&lt;/code&gt; will now be included in the component's &lt;code&gt;$attrs&lt;/code&gt;, which by default will be bound to the component's root node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e75c804038e58ba6a3277c3614a92aeb116d1c9" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on route definitions&lt;/a&gt;. So for example, you will update:</source>
          <target state="translated">이것은 이제 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;경로 정의에&lt;/a&gt; 대한 옵션입니다 . 예를 들어 다음을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="50fa440286db22b789b949c9a5abab1c06513e69" translate="yes" xml:space="preserve">
          <source>This is now an &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;option on the definition for the route&lt;/a&gt; you&amp;rsquo;d like to alias to. So for example, you will update:</source>
          <target state="translated">이것은 이제 별칭을 지정할 &lt;a href=&quot;https://router.vuejs.org/en/essentials/redirect-and-alias.html&quot;&gt;경로의 정의에 대한 옵션입니다&lt;/a&gt; . 예를 들어 다음을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="56cbae9ff95e4616e32a9cc520227cb6feaa2c74" translate="yes" xml:space="preserve">
          <source>This is often useful, because even with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt;, the value of HTML input elements always returns a string. If the value cannot be parsed with &lt;code&gt;parseFloat()&lt;/code&gt;, then the original value is returned.</source>
          <target state="translated">&lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 인 경우에도 HTML 입력 요소의 값은 항상 문자열을 반환 하므로 유용 합니다. &lt;code&gt;parseFloat()&lt;/code&gt; 값을 구문 분석 할 수없는 경우 원래 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a70c72c5011c169a2c1648b6eacd7fc7b9c7fc32" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute (opens new window)&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules (opens new window)&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM (opens new window)&lt;/a&gt;, or another library/convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff9fb25dfd7792976ece7fcf3da5a64a5e24732" translate="yes" xml:space="preserve">
          <source>This is only relevant for &lt;a href=&quot;../guide/single-file-components&quot;&gt;single-file components&lt;/a&gt;. It does &lt;em&gt;not&lt;/em&gt; require that the &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt;&lt;code&gt;scoped&lt;/code&gt; attribute&lt;/a&gt; be used. Scoping could be through &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS modules&lt;/a&gt;, a class-based strategy such as &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt;, or another library/convention.</source>
          <target state="translated">이것은 &lt;a href=&quot;../guide/single-file-components&quot;&gt;단일 파일 구성 요소&lt;/a&gt; 에만 관련이 있습니다. &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/scoped-css.html&quot;&gt; &lt;code&gt;scoped&lt;/code&gt; &lt;/a&gt; 속성 을 사용할 필요 는 &lt;em&gt;없습니다&lt;/em&gt; . 범위 지정은 &lt;a href=&quot;https://vue-loader.vuejs.org/en/features/css-modules.html&quot;&gt;CSS 모듈&lt;/a&gt; , &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt; 과 같은 클래스 기반 전략 또는 다른 라이브러리 / 컨벤션을 통해 이루어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ecbb65364f0fdf669d68bae076b4de3385cb21" translate="yes" xml:space="preserve">
          <source>This is our starting point, except it's not working yet because our &lt;code&gt;repositories&lt;/code&gt; variable is not reactive. This means from a user's perspective, the repository list would remain empty. Let's fix that!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc711e31ffaf8ca030cc8750019aa32c295521fa" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;mixins&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;mixins&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="55d606ea96e61ab331639ff4a07074c626da1c5c" translate="yes" xml:space="preserve">
          <source>This is something to be cautious of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1427909eab695a82c73616bf6ca58eaea604e27" translate="yes" xml:space="preserve">
          <source>This is something we do not recommend. Use at your own risk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88701949f327d90fdaf4b1fc05d4c2989b12c90a" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.delete&lt;/code&gt;.</source>
          <target state="translated">이것은 글로벌 &lt;code&gt;Vue.delete&lt;/code&gt; 의 &lt;strong&gt;별명&lt;/strong&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7cdad8ed28d3f01ce5f9bf60ef04514b89cb1a36" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;alias&lt;/strong&gt; of the global &lt;code&gt;Vue.set&lt;/code&gt;.</source>
          <target state="translated">이것은 글로벌 &lt;code&gt;Vue.set&lt;/code&gt; 의 &lt;strong&gt;별명&lt;/strong&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="834201b2fb84fb7b9e921e1c6e4ca406e0641f68" translate="yes" xml:space="preserve">
          <source>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to &lt;code&gt;v-model&lt;/code&gt;.</source>
          <target state="translated">이는 더 낮은 수준의 비용이지만 &lt;code&gt;v-model&lt;/code&gt; 과 비교하여 상호 작용 세부 정보를 훨씬 더 많이 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e3405a7d34055c0dba177a68cd0d783f73f679e" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add custom attributes and directives.</source>
          <target state="translated">구성 요소 옵션에 권장되는 기본 순서입니다. 그것들은 카테고리로 나뉘어 있으므로 사용자 정의 속성과 지시문을 추가 할 위치를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0efd0e005041f4d6aacd45e88dd9d81bd95f535" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They&amp;rsquo;re split into categories, so you&amp;rsquo;ll know where to add new properties from plugins.</source>
          <target state="translated">구성 요소 옵션에 권장되는 기본 순서입니다. 그것들은 카테고리로 나뉘어 있으므로 플러그인에서 새 속성을 추가 할 위치를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a7f1cb949f47a835f88db5681466149b0c54598" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f223c43426961a4fb3c1457dda5eadb68ad78" translate="yes" xml:space="preserve">
          <source>This is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10f048c28db476791d645c8e86e33a10cf5fe82" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it&amp;rsquo;s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don&amp;rsquo;t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="translated">Vue 특정 코드의 공식 스타일 가이드입니다. 프로젝트에서 Vue를 사용하는 경우 오류, 자전거 타기 및 안티 패턴을 피하기위한 훌륭한 참고 자료입니다. 그러나 우리는 어떤 스타일 가이드가 모든 팀이나 프로젝트에 이상적이라고 생각하지 않으므로 과거 경험, 주변 기술 스택 및 개인 가치에 따라 신중한 편차가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="260db489520475eb4d9d940e59e1b8c6d90f9b1c" translate="yes" xml:space="preserve">
          <source>This is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dc851eaa2d4a0946dac12cbc41fef4c40d2c4e" translate="yes" xml:space="preserve">
          <source>This is the very essence of Vue's reactivity system. When you return an object from &lt;code&gt;data()&lt;/code&gt; in a component, it is internally made reactive by &lt;code&gt;reactive()&lt;/code&gt;. The template is compiled into a &lt;a href=&quot;render-function&quot;&gt;render function&lt;/a&gt; that makes use of these reactive properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae6e4af70b8947160604a318d2c8290aa71604" translate="yes" xml:space="preserve">
          <source>This is what an example looks like in action:</source>
          <target state="translated">다음은 실제로 사용되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="86ed47f21689beea18108b3f71c70d7446716f52" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t always desirable though, so Vue offers a way for you to say, &amp;ldquo;These two elements are completely separate - don&amp;rsquo;t re-use them.&amp;rdquo; Add a &lt;code&gt;key&lt;/code&gt; attribute with unique values:</source>
          <target state="translated">그러나 이것이 항상 바람직한 것은 아니기 때문에 Vue는&amp;ldquo;이 두 요소는 완전히 분리되어 재사용하지 마십시오&amp;rdquo;라고 말할 수있는 방법을 제공합니다. 고유 한 값 으로 &lt;code&gt;key&lt;/code&gt; 속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6310262b7c83dfb01581e044a227be964f646d9" translate="yes" xml:space="preserve">
          <source>This isn&amp;rsquo;t recommended, as it results in:</source>
          <target state="translated">다음과 같은 결과로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82d553ff76c7a0d3860ad174bd983d0f26df9bc2" translate="yes" xml:space="preserve">
          <source>This isn't recommended, as it results in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6cde4441aa77022965104cf28c119fa672b5f2" translate="yes" xml:space="preserve">
          <source>This makes it possible to use &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; on multiple conditional children:</source>
          <target state="translated">이를 통해 여러 조건부 하위에서 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6a89a509e1a13dc277b1946145eb663eb6a0bc1" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don&amp;rsquo;t have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="translated">이렇게하면 사람이 읽을 수있는 클래스 이름을 사용하여 내부 스타일을 재정의하는 것이 더 쉬워 지지만 특정 성이 너무 크지는 않지만 여전히 충돌을 일으킬 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6039ba72679e27c3de3fe59517757185e2ef8639" translate="yes" xml:space="preserve">
          <source>This makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5bca688970af00ecf6916734fc1be51e2996ec" translate="yes" xml:space="preserve">
          <source>This may be useful when you want to, for example, programmatically focus this input on component mount:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbccff00d4246ffaab0d554ac15f4da6d514888" translate="yes" xml:space="preserve">
          <source>This means you &lt;strong&gt;can&lt;/strong&gt; install/import these deps individually without ending up with different instances of these dependencies, but you must make sure they all resolve to the same version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df7db840cfd9d37352281ab6a0b379ab7ce5543" translate="yes" xml:space="preserve">
          <source>This method has to be called before calling &lt;code&gt;new Vue()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new Vue()&lt;/code&gt; 호출하기 전에이 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0ddd876bb6fb1b94f32ad08f1b3a4e6d7b7cb98" translate="yes" xml:space="preserve">
          <source>This method should not be confused with the &lt;a href=&quot;options-composition#provide-inject&quot;&gt;provide component option&lt;/a&gt; or the &lt;a href=&quot;composition-api#provide-inject&quot;&gt;provide function&lt;/a&gt; in the composition API. While those are also part of the same &lt;code&gt;provide&lt;/code&gt;/&lt;code&gt;inject&lt;/code&gt; mechanism, they are used to configure values provided by a component rather than an application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbaf50c98606e0673b924b093900524e24db8aeb" translate="yes" xml:space="preserve">
          <source>This might be helpful when we have an HTML element with &lt;code&gt;change&lt;/code&gt; event as a root element of &lt;code&gt;date-picker&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90aee8ca6c8b63ccbcb1d903920d255bfac3961" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP (opens new window)&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e730d7896b6b323bd3f0e7b2da6d31281de59f5f" translate="yes" xml:space="preserve">
          <source>This might seem like magic, but under the hood, Vue is using an animation technique called &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; to smoothly transition elements from their old position to their new position using transforms.</source>
          <target state="translated">이것은 마술처럼 보이지만 Vue는 &lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP&lt;/a&gt; 라는 애니메이션 기법을 사용하여 변환을 사용하여 요소를 이전 위치에서 새 위치로 부드럽게 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ab8d674415749229910a074d53ea9c4b24dec081" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser&amp;rsquo;s JavaScript console if they pass the wrong type. You&amp;rsquo;ll learn much more about &lt;a href=&quot;#Prop-Validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="translated">이것은 구성 요소를 문서화 할뿐만 아니라 잘못된 유형을 전달하면 브라우저의 JavaScript 콘솔에서 사용자에게 경고합니다. 이 페이지 아래에서 &lt;a href=&quot;#Prop-Validation&quot;&gt;유형 확인 및 기타 소품 검증&lt;/a&gt; 에 대해 더 자세히 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eede98c99888e9e8fb70ceb48eb9cdf213e42e5" translate="yes" xml:space="preserve">
          <source>This not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about &lt;a href=&quot;#prop-validation&quot;&gt;type checks and other prop validations&lt;/a&gt; further down this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de9e673c8caad296afdff84c173090ed0754386" translate="yes" xml:space="preserve">
          <source>This option is no longer necessary now that Vue&amp;rsquo;s transition system has explicit &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt;&lt;code&gt;appear&lt;/code&gt; transition control&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 뷰의 전환 시스템이 명시가 가지고있는 지금은 더 이상 필요하지 않습니다 &lt;a href=&quot;transitions#Transitions-on-Initial-Render&quot;&gt; &lt;code&gt;appear&lt;/code&gt; 전환 제어&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dda8e2bba6581f8fe39ba87ae1f467605782e672" translate="yes" xml:space="preserve">
          <source>This page applies only to Vue 2.x and below, and assumes you've already read the &lt;a href=&quot;reactivity&quot;&gt;Reactivity Section&lt;/a&gt;. Please read that section first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550e8beaeefdf603cb020b147e312a77724aa11b" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;ve already read the &lt;a href=&quot;components&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="translated">이 페이지에서는 &lt;a href=&quot;components&quot;&gt;구성 요소 기본 사항을&lt;/a&gt; 이미 읽었다 고 가정합니다 . 구성 요소를 처음 사용하는 경우 먼저 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="2f257c4f8981d39250383dd3af755f3faa35ddba" translate="yes" xml:space="preserve">
          <source>This page assumes you've already read the &lt;a href=&quot;component-basics&quot;&gt;Components Basics&lt;/a&gt;. Read that first if you are new to components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e672f7510e855eb83e9a420fd1aab887fa1937" translate="yes" xml:space="preserve">
          <source>This page is not required reading in order to learn how to use Vue well, but it provides more information, should you be curious how rendering works under the hood.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9eda44994bfc72fde4d3d3f83007e54ed25512" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React&amp;rsquo;s context feature.</source>
          <target state="translated">이 옵션 쌍은 함께 사용되어 동일한 상위 체인에있는 한 상위 계층 구성 요소가 구성 요소 계층 구조의 깊이에 관계없이 모든 하위 항목에 대한 종속성 인젝터 역할을 할 수 있습니다. React에 익숙하다면 이는 React의 컨텍스트 기능과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2a14bf9014246214857ff883acbf4909435d0e01" translate="yes" xml:space="preserve">
          <source>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's &lt;code&gt;context&lt;/code&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bf50ff4f4ae88a62c8e8c96ac99d754acfb794" translate="yes" xml:space="preserve">
          <source>This passes each property in the &lt;code&gt;doc&lt;/code&gt; object (e.g. &lt;code&gt;title&lt;/code&gt;) as an individual prop, then adds &lt;code&gt;v-on&lt;/code&gt; update listeners for each one.</source>
          <target state="translated">이는 &lt;code&gt;doc&lt;/code&gt; 객체의 각 속성 (예 : &lt;code&gt;title&lt;/code&gt; )을 개별 소품으로 전달한 다음 각각에 대한 &lt;code&gt;v-on&lt;/code&gt; 업데이트 리스너를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="557b609a0af0bc72cafc6f2a31afd4730c396e50" translate="yes" xml:space="preserve">
          <source>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</source>
          <target state="translated">이 패턴을 사용하면 실제로 루트에있는 요소를 신경 쓰지 않고도 원시 HTML 요소와 같은 기본 구성 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbad2c9cdad7376672474e37751ceab152ea3ed1" translate="yes" xml:space="preserve">
          <source>This pattern can serve as a replacement for &lt;code&gt;$dispatch&lt;/code&gt; and &lt;code&gt;$broadcast&lt;/code&gt; in simple scenarios, but for more complex cases, it&amp;rsquo;s recommended to use a dedicated state management layer such as &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 간단한 시나리오에서 &lt;code&gt;$dispatch&lt;/code&gt; 및 &lt;code&gt;$broadcast&lt;/code&gt; 를 대체 할 수 있지만보다 복잡한 경우 &lt;a href=&quot;https://github.com/vuejs/vuex&quot;&gt;Vuex&lt;/a&gt; 와 같은 전용 상태 관리 계층을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3bcacf748b9af6a54554db3c2d36be4ed02362a9" translate="yes" xml:space="preserve">
          <source>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5586c0722db91f034d221a64e55d5829bf071baf" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c88f592f793e32dd9e76308d4a6ba8bd42fb51" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;component-basics&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cba143bcc5fd060440f37e2cac40aebf229b0f3" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;components&quot;&gt;구성 요소에&lt;/a&gt; 대한 지식이 있다고 가정합니다 . 건너 뛰고 나중에 다시 오십시오.</target>
        </trans-unit>
        <trans-unit id="d97537d143e717763c891d635c44d8f795dd0407" translate="yes" xml:space="preserve">
          <source>This section assumes knowledge of &lt;a href=&quot;components&quot;&gt;Vue Components&lt;/a&gt;. Feel free to skip it and come back later.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;components&quot;&gt;Vue 구성 요소에&lt;/a&gt; 대한 지식이 있다고 가정합니다 . 건너 뛰고 나중에 다시 오십시오.</target>
        </trans-unit>
        <trans-unit id="fb5b15406f75921e192409d91ff1b17d27fd994a" translate="yes" xml:space="preserve">
          <source>This section contains the search functionality for the application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3b7709525d03239edb056d669680878e9735ae" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;../guide/single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd61b2e32ea112a3e4dcdeb333fabe9dfc18a2f7" translate="yes" xml:space="preserve">
          <source>This section uses &lt;a href=&quot;single-file-component&quot;&gt;single-file component&lt;/a&gt; syntax for code examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f775635fcd735f353cd0996d158644d66269c8fe" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; and makes outputting &lt;code&gt;aria-*&lt;/code&gt; attributes easier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df51509bdf6631bdbd029391b7a92d14a5f11a4f" translate="yes" xml:space="preserve">
          <source>This solves the inconsistency between normal non-boolean attributes and &amp;ldquo;enumerated attributes&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34f69dcd5eb3d4acee6efe3176754e358fc43d6" translate="yes" xml:space="preserve">
          <source>This template doesn't feel great. It's not only verbose, but we're duplicating &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; for every heading level. And when we add the anchor element, we have to again duplicate it in every &lt;code&gt;v-if/v-else-if&lt;/code&gt; branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2671e140fbe7037587dd494d52b8c4c16af6fa" translate="yes" xml:space="preserve">
          <source>This term comes up in programming quite a bit these days, but what do people mean when they say it? Reactivity is a programming paradigm that allows us to adjust to changes in a declarative manner. The canonical example that people usually show, because it&amp;rsquo;s a great one, is an Excel spreadsheet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da345bd2efafe0aab297aeb02da75f10e9617d3e" translate="yes" xml:space="preserve">
          <source>This will allow you to check all the events that a component emits and optionally &lt;a href=&quot;component-custom-events#validate-emitted-events&quot;&gt;validate them&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cf660900b36fb7082d6da4112e034f7880c495" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but &lt;code&gt;activeClass&lt;/code&gt; will only be applied when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b9ed84f139c1b6b2a23ad5d5ae02e8e0087d2f" translate="yes" xml:space="preserve">
          <source>This will always apply &lt;code&gt;errorClass&lt;/code&gt;, but will only apply &lt;code&gt;activeClass&lt;/code&gt; when &lt;code&gt;isActive&lt;/code&gt; is truthy.</source>
          <target state="translated">이것은 항상 &lt;code&gt;errorClass&lt;/code&gt; 를 적용 하지만 &lt;code&gt;isActive&lt;/code&gt; 가 true 인 경우 에만 &lt;code&gt;activeClass&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="c7c41413208280e0438efd8becdf4788ac79009e" translate="yes" xml:space="preserve">
          <source>This will be a new top-level option in the Vue CLI config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821e5689d374e0b8784257f0965bfa2f10466c3" translate="yes" xml:space="preserve">
          <source>This will lead to issues when using components with elements that have such restrictions. For example:</source>
          <target state="translated">이러한 제한이있는 요소가있는 구성 요소를 사용할 때 문제가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="049aecf164473e3032284f57bc6b9b045f4cb629" translate="yes" xml:space="preserve">
          <source>This will no longer work:</source>
          <target state="translated">더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2666e307d1675c13748bab8a1f1fd08d861b57f6" translate="yes" xml:space="preserve">
          <source>This will only render the last value in the array which the browser supports. In this example, it will render &lt;code&gt;display: flex&lt;/code&gt; for browsers that support the unprefixed version of flexbox.</source>
          <target state="translated">브라우저가 지원하는 배열의 마지막 값만 렌더링합니다. 이 예제에서는 접두사가없는 버전의 flexbox를 지원하는 브라우저의 경우 &lt;code&gt;display: flex&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5c6bceae6f976ba05296ec0765f401478684d036" translate="yes" xml:space="preserve">
          <source>This will render the same result. We can also bind to a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt; that returns an object. This is a common and powerful pattern:</source>
          <target state="translated">동일한 결과가 렌더링됩니다. 객체를 반환하는 &lt;a href=&quot;computed&quot;&gt;계산 된 속성에&lt;/a&gt; 바인딩 할 수도 있습니다 . 이것은 일반적이고 강력한 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d7b864922bd15ed63c01468766857939d0bedd4b" translate="yes" xml:space="preserve">
          <source>This will tell webpack to treat the Vue module as an external library and not bundle it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526567b8517e99354a6d4a7125884ed748c75aee" translate="yes" xml:space="preserve">
          <source>This works well, but there&amp;rsquo;s one caveat to be aware of:</source>
          <target state="translated">이것은 잘 작동하지만, 알아야 할 한 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f50c9fec60cfa63ed8f8710f68526faca79202" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here&amp;rsquo;s where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="translated">이것은 페이지 상단에서 200px 요소를 고정시킵니다. 그러나 맨 위 대신 왼쪽에서 요소를 고정해야 할 때 시나리오가 발생하면 어떻게됩니까? 구성 요소 인스턴스별로 업데이트 할 수있는 동적 인수가 매우 유용한 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e3f2385e5295eb0996806c6e44de1cd3bf29c86" translate="yes" xml:space="preserve">
          <source>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af979b8150c4855a484c40f48bb6c2a78e8cf7" translate="yes" xml:space="preserve">
          <source>Though the &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component can be wonderful for components entering and leaving, you can also activate an animation without mounting a component, by adding a conditional class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9de901ca4a37c13bd513536f6104058a8ebeab4" translate="yes" xml:space="preserve">
          <source>Though this provided some convenience in terms of root instances having a shared state, this has led to confusion due to the fact that its only possible on the root instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e255605141c6fd6ae34a1f00f4a710389219fe6" translate="yes" xml:space="preserve">
          <source>Though you can achieve great effects for simple animation with the two handles the cubic-bezier ease offers, JavaScript allows multiple handles, and therefore, allows for much more variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3296891d857a3b88e24b3a8f562ed3941e52be8" translate="yes" xml:space="preserve">
          <source>Though you might have seen labels wrapping the input fields like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071bdcdc5a765649d86527bc55dbc0b17011d91" translate="yes" xml:space="preserve">
          <source>Thus allowing the parent component to focus the input inside &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; with:</source>
          <target state="translated">따라서 상위 컴포넌트가 다음을 사용하여 &lt;code&gt;&amp;lt;base-input&amp;gt;&lt;/code&gt; 내부의 입력에 초점을 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b83fd8c5087d08e03db371955b52edd99734c1" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names</source>
          <target state="translated">단단히 결합 된 구성 요소 이름</target>
        </trans-unit>
        <trans-unit id="257e6044f44501278b17551ce75788f6ca913a8d" translate="yes" xml:space="preserve">
          <source>Tightly coupled component names &lt;sup&gt;strongly recommended&lt;/sup&gt;</source>
          <target state="translated">밀접하게 결합 된 구성 요소 이름을 &lt;sup&gt;적극 권장합니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="098024dc5537ca3623978ac7c0a6140ce39062b8" translate="yes" xml:space="preserve">
          <source>Timing</source>
          <target state="translated">Timing</target>
        </trans-unit>
        <trans-unit id="40b635fbbc82098772ee7e3177e62a9c14ea2014" translate="yes" xml:space="preserve">
          <source>Tips, Callouts, Alerts, and Line Highlights</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881f5e312126d5e8ea790db899552b0144c3c571" translate="yes" xml:space="preserve">
          <source>To access component instance properties, we need to convert &lt;code&gt;provide&lt;/code&gt; to be a function returning an object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19f5499c85a1ceeb0b480c98eff4e4346929cd2" translate="yes" xml:space="preserve">
          <source>To add line highlighting to your code blocks, you need to append the line number in curly braces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddd888c6582ef9d6fa2ab28bf309c8d36b0be42" translate="yes" xml:space="preserve">
          <source>To add methods to a component instance we use the &lt;code&gt;methods&lt;/code&gt; option. This should be an object containing the desired methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20869228946fc9bfb3ec15b09cdff057ca44c507" translate="yes" xml:space="preserve">
          <source>To add reactivity between provided and injected values, we can use a &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;ref&lt;/a&gt; or &lt;a href=&quot;reactivity-fundamentals#declaring-reactive-state&quot;&gt;reactive&lt;/a&gt; when providing a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0cfd696ee7275a932682ace8d519ee632cc69c" translate="yes" xml:space="preserve">
          <source>To add validation, the event is assigned a function that receives the arguments passed to the &lt;code&gt;$emit&lt;/code&gt; call and returns a boolean to indicate whether the event is valid or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788042730e582de0e5c9cadbed06a9452fa7048a" translate="yes" xml:space="preserve">
          <source>To address these issues, we added a new way to organize code by logical concerns: the &lt;a href=&quot;composition-api-introduction&quot;&gt;Composition API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f6ddc9e83523ba73e6944910a55021c297893e" translate="yes" xml:space="preserve">
          <source>To address this problem, Vue provides &lt;strong&gt;event modifiers&lt;/strong&gt; for &lt;code&gt;v-on&lt;/code&gt;. Recall that modifiers are directive postfixes denoted by a dot.</source>
          <target state="translated">이 문제를 해결하기 위해 Vue는 &lt;code&gt;v-on&lt;/code&gt; 에 대한 &lt;strong&gt;이벤트 수정자를&lt;/strong&gt; 제공합니다 . 수정자는 점으로 표시되는 지시문 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="1f82c84ad360cae69c196ca0363ef72d7d1df639" translate="yes" xml:space="preserve">
          <source>To also build &lt;code&gt;umd&lt;/code&gt; and &lt;code&gt;cjs&lt;/code&gt; modules we can simply add a few lines of configuration to our &lt;code&gt;rollup.config.js&lt;/code&gt; and &lt;code&gt;package.json&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fbfda62f8c47b0cf26f2ea631c53bf263f1ecd" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don&amp;rsquo;t need to do so to listen for Array mutations.</source>
          <target state="translated">Objects 내에서 중첩 값 변경을 감지하려면 options 인수 에서 &lt;code&gt;deep: true&lt;/code&gt; 를 전달해야합니다 . Array 돌연변이를 청취하기 위해 그렇게 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cce00248496d96a2067177aed26ff61ce35a2340" translate="yes" xml:space="preserve">
          <source>To also detect nested value changes inside Objects, you need to pass in &lt;code&gt;deep: true&lt;/code&gt; in the options argument. Note that you don't need to do so to listen for array mutations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e407d7b5fb83d759864567de67b6dc7262ee1c" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they&amp;rsquo;re usually delivered as images or static SVGs. So although GitHub&amp;rsquo;s octocat, Twitter&amp;rsquo;s bird, and many other logos resemble living creatures, they don&amp;rsquo;t really seem alive.</source>
          <target state="translated">하나의 정의로 애니메이션을 적용한다는 것은 생명을 얻는 것입니다. 불행하게도, 디자이너가 아이콘, 로고 및 마스코트를 만들 때 일반적으로 이미지 또는 정적 SVG로 제공됩니다. 따라서 GitHub의 octocat, Twitter의 새 및 기타 많은 로고가 살아있는 생물과 비슷하지만 실제로 살아있는 것처럼 보이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a3a9f59e5420390dc20b2d39b4aad21d989a106" translate="yes" xml:space="preserve">
          <source>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they're usually delivered as images or static SVGs. So although GitHub's octocat, Twitter's bird, and many other logos resemble living creatures, they don't really seem alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b12f0b2b03b56612ac89d3a0da0c957181b463" translate="yes" xml:space="preserve">
          <source>To apply and &lt;em&gt;automatically re-apply&lt;/em&gt; a side effect based on reactive state, we can use the &lt;code&gt;watchEffect&lt;/code&gt; method. It runs a function immediately while reactively tracking its dependencies and re-runs it whenever the dependencies are changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd440feea95e8113a121d0207c819f60960da69" translate="yes" xml:space="preserve">
          <source>To avoid rendering a list if it should be hidden (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt;). In these cases, move the &lt;code&gt;v-if&lt;/code&gt; to a container element (e.g. &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;ol&lt;/code&gt;).</source>
          <target state="translated">목록을 숨겨야하는 경우 목록을 렌더링하지 않으려면 (예 : &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;&lt;/code&gt; ) 이 경우 &lt;code&gt;v-if&lt;/code&gt; 를 컨테이너 요소 (예 : &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;ol&lt;/code&gt; )로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="11af8c48788875166f2c82baaf2047c13709005d" translate="yes" xml:space="preserve">
          <source>To avoid these problems, in Vue 3 we introduce&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f959a2209cc4ae6dde0fc52d270647a756227800" translate="yes" xml:space="preserve">
          <source>To change a model name, instead of a &lt;code&gt;model&lt;/code&gt; component option, now we can pass an &lt;em&gt;argument&lt;/em&gt; to &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f16b9b50a22626214a8a2ce30432a9dda3b421" translate="yes" xml:space="preserve">
          <source>To configure our build with Rollup we will need to create a &lt;code&gt;rollup.config.js&lt;/code&gt; file in the root of our project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f956073caa60e7478f9715ae3f9c555d2f8969" translate="yes" xml:space="preserve">
          <source>To create a VNode for a component, the first argument passed to &lt;code&gt;h&lt;/code&gt; should be the component itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a4ddff02308f2d46c7bfb2cc80ec93a6254881" translate="yes" xml:space="preserve">
          <source>To create a reactive state from a JavaScript object, we can use a &lt;code&gt;reactive&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c205fa5653088d04441a5d46746a863c98b018" translate="yes" xml:space="preserve">
          <source>To deal with caveat 2, you can use &lt;code&gt;splice&lt;/code&gt;:</source>
          <target state="translated">경고 2를 처리하기 위해 &lt;code&gt;splice&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d872aff4853ffd947160017a366852e73bfc2ed" translate="yes" xml:space="preserve">
          <source>To explain what&amp;rsquo;s happening, let&amp;rsquo;s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It&amp;rsquo;s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &amp;ldquo;A needs B &lt;em&gt;eventually&lt;/em&gt;, but there&amp;rsquo;s no need to resolve B first.&amp;rdquo;</source>
          <target state="translated">무슨 일이 일어나고 있는지 설명하기 위해 컴포넌트 A와 B를 호출 해 봅시다. 모듈 시스템은 A가 필요하지만 먼저 A는 B가 필요하지만 B는 A가 필요하지만 A는 B가 필요하다는 것을 알 수 있습니다. 먼저 다른 구성 요소를 해결하지 않고 구성 요소를 완전히 해결하십시오. 이 문제를 해결하려면 모듈 시스템에 &quot;A는 &lt;em&gt;결국&lt;/em&gt; B 가 필요하지만 B를 먼저 해결할 필요는 없습니다.&quot; 라고 말할 수있는 지점을 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f704c78b660c6599dd1fd0c78c96300ee070e37" translate="yes" xml:space="preserve">
          <source>To filter items in a list (e.g. &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt;). In these cases, replace &lt;code&gt;users&lt;/code&gt; with a new computed property that returns your filtered list (e.g. &lt;code&gt;activeUsers&lt;/code&gt;).</source>
          <target state="translated">목록에서 항목을 필터링합니다 (예 : &lt;code&gt;v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;&lt;/code&gt; ). 이 경우 필터링 된 목록을 반환하는 새로운 계산 된 속성 (예 : &lt;code&gt;activeUsers&lt;/code&gt; )으로 &lt;code&gt;users&lt;/code&gt; 를 교체 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac31ac440566ea1907419215aa2f6fe6b76e4bb3" translate="yes" xml:space="preserve">
          <source>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading &lt;a href=&quot;../index&quot;&gt;the guide&lt;/a&gt;.</source>
          <target state="translated">Vue를 시작하려면 HTML 및 ES5 JavaScript (일반 JavaScript)에 익숙하면됩니다. 이 기본 기술을 사용 &lt;a href=&quot;../index&quot;&gt;하면 가이드&lt;/a&gt; 를 읽고 하루 만에 사소한 응용 프로그램을 구축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="776030a16d16967752ee7198797ade27b5d2a7fc" translate="yes" xml:space="preserve">
          <source>To get type inference for the arguments passed to &lt;code&gt;setup()&lt;/code&gt;, the use of &lt;a href=&quot;global-api#definecomponent&quot;&gt;defineComponent&lt;/a&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6a7be936df8f4976d7c991e70077b80aee512a" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node&amp;rsquo;s identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="translated">Vue가 각 노드의 ID를 추적하여 기존 요소를 재사용하고 재정렬 할 수 있도록 힌트를 제공하려면 각 항목에 고유 한 &lt;code&gt;key&lt;/code&gt; 속성 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5fcb75ebf027b9d0a0175ff64ac67858b09230bc" translate="yes" xml:space="preserve">
          <source>To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique &lt;code&gt;key&lt;/code&gt; attribute for each item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75de4b3808772ba349e727ba7f78014a936ee3b" translate="yes" xml:space="preserve">
          <source>To help solve this problem, we can adopt a &lt;strong&gt;store pattern&lt;/strong&gt;:</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;strong&gt;상점 패턴을&lt;/strong&gt; 채택 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6bab7ec362c384e83157e34842533353476c5f9b" translate="yes" xml:space="preserve">
          <source>To hide the link unless it is focused, you can add the following style:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08b3c5e2c296cf501fe81d8b1fdad39e5bceb5" translate="yes" xml:space="preserve">
          <source>To keep the old behavior work, and as we will be coercing &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;'false'&lt;/code&gt;, in 3.x Vue developers need to make &lt;code&gt;v-bind&lt;/code&gt; expression resolve to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;'false'&lt;/code&gt; for &lt;code&gt;contenteditable&lt;/code&gt; and &lt;code&gt;spellcheck&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb8a7e0c9b146414452970176fd17030d598fc" translate="yes" xml:space="preserve">
          <source>To learn more about programmatic listeners, check out the API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt;.</source>
          <target state="translated">프로그래밍 방식 리스너에 대한 자세한 내용은 API for &lt;a href=&quot;../api/index#Instance-Methods-Events&quot;&gt;Events Instance Methods&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f63e037fab7411a20c7d6797002ce6c1ea370d23" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;Vue.component&lt;/code&gt; or &lt;code&gt;Vue.extend&lt;/code&gt;:</source>
          <target state="translated">TypeScript가 Vue 구성 요소 옵션 내에서 유형을 올바르게 유추하도록하려면 &lt;code&gt;Vue.component&lt;/code&gt; 또는 &lt;code&gt;Vue.extend&lt;/code&gt; 로 구성 요소를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a0debe65b75107b626e13146620736020251e6" translate="yes" xml:space="preserve">
          <source>To let TypeScript properly infer types inside Vue component options, you need to define components with &lt;code&gt;defineComponent&lt;/code&gt; global method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d5d14cc89427095a5243c18af0d1e934e75f1c" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our Vue instances:</source>
          <target state="translated">사용자가 앱과 상호 작용할 수 있도록 &lt;code&gt;v-on&lt;/code&gt; 지시문을 사용하여 Vue 인스턴스에서 메서드를 호출하는 이벤트 리스너를 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33212d2502112422cf740d702a092d37f765943" translate="yes" xml:space="preserve">
          <source>To let users interact with your app, we can use the &lt;code&gt;v-on&lt;/code&gt; directive to attach event listeners that invoke methods on our instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b795d5e4656eb47b1b382ba73bb73ecac50f9c6e" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;item&lt;/code&gt; available to the slot content provided by the parent, we can add a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element and bind it as an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2252111700f506a786c1bdd74f51e20a902d095" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;user&lt;/code&gt; available to the slot content in the parent, we can bind &lt;code&gt;user&lt;/code&gt; as an attribute to the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">하려면 &lt;code&gt;user&lt;/code&gt; 부모의 슬롯 콘텐츠에 사용할 수를, 우리는 결합 할 수있는 &lt;code&gt;user&lt;/code&gt; 받는 속성으로 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소 :</target>
        </trans-unit>
        <trans-unit id="8d5ee521751945f607f368f2972a7a5e30916787" translate="yes" xml:space="preserve">
          <source>To make Composition API feature-complete compared to Options API, we also need a way to register lifecycle hooks inside &lt;code&gt;setup&lt;/code&gt;. This is possible thanks to several new functions exported from Vue. Lifecycle hooks on composition API have the same name as for Options API but are prefixed with &lt;code&gt;on&lt;/code&gt;: i.e. &lt;code&gt;mounted&lt;/code&gt; would look like &lt;code&gt;onMounted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f339c5f06bd1c70bd6a59a91fa2c7296dfce01e" translate="yes" xml:space="preserve">
          <source>To overcome caveat 1, both of the following will accomplish the same as &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;, but will also trigger state updates in the reactivity system:</source>
          <target state="translated">경고 1을 극복하기 위해 다음 두 가지 모두 &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt; 와 동일하지만 반응성 시스템에서 상태 업데이트를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="b21e4db7e451cf3b08481a1ab12a6f11393d30f0" translate="yes" xml:space="preserve">
          <source>To pass content to named slots from the parent, use the special &lt;code&gt;slot&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; (using the &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; component described &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">부모에서 이름이 지정된 슬롯으로 컨텐츠를 전달하려면 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 의 특수 &lt;code&gt;slot&lt;/code&gt; 속성을 사용하십시오 ( &lt;a href=&quot;#Named-Slots&quot;&gt;여기&lt;/a&gt; 에서 설명 된 &lt;code&gt;&amp;lt;base-layout&amp;gt;&lt;/code&gt; 컴포넌트 사용 ).</target>
        </trans-unit>
        <trans-unit id="7d224921563544c4b732cb7daad7320d9fff997d" translate="yes" xml:space="preserve">
          <source>To pass scoped slots to a child component using render functions, use the &lt;code&gt;scopedSlots&lt;/code&gt; field in VNode data:</source>
          <target state="translated">렌더링 기능을 사용하여 범위가 지정된 슬롯을 하위 구성 요소로 전달하려면 VNode 데이터 의 &lt;code&gt;scopedSlots&lt;/code&gt; 필드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3040fecd05b5350f6cd19b5d9d470249a65d3a34" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we can use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;&amp;lsquo;s argument:</source>
          <target state="translated">명명 된 슬롯에 컨텐츠를 제공하기 위해 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;v-slot&lt;/code&gt; 지시문을 사용하여 슬롯 이름을 &lt;code&gt;v-slot&lt;/code&gt; 의 인수로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b95472ceb5c02875dbc3b9d728b462388305b4" translate="yes" xml:space="preserve">
          <source>To provide content to named slots, we need to use the &lt;code&gt;v-slot&lt;/code&gt; directive on a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, providing the name of the slot as &lt;code&gt;v-slot&lt;/code&gt;'s argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9822cbc90becc7c85283ddc496bc85247e9e908" translate="yes" xml:space="preserve">
          <source>To receive props passed to a slot, the parent component can use &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; with the &lt;code&gt;slot-scope&lt;/code&gt; attribute (using the &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; as example):</source>
          <target state="translated">슬롯에 전달 소품을 수신하기 위해, 부모 구성 요소를 사용할 수 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 와 &lt;code&gt;slot-scope&lt;/code&gt; 속성 (은 USING &lt;code&gt;&amp;lt;slot-example&amp;gt;&lt;/code&gt; 설명 &lt;a href=&quot;#Scoped-Slots&quot;&gt;여기&lt;/a&gt; 예로)</target>
        </trans-unit>
        <trans-unit id="d3f9cfe4e2cdeebe7bd4ec32a7761a9fc73b24fe" translate="yes" xml:space="preserve">
          <source>To scope styles, Vue adds a unique attribute to component elements, such as &lt;code&gt;data-v-f3f3eg9&lt;/code&gt;. Then selectors are modified so that only matching elements with this attribute are selected (e.g. &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt;).</source>
          <target state="translated">스타일 범위를 지정하기 위해 Vue는 &lt;code&gt;data-v-f3f3eg9&lt;/code&gt; 와 같은 구성 요소에 고유 한 속성을 추가합니다 . 그런 다음이 속성과 일치하는 요소 만 선택되도록 선택기를 수정합니다 (예 : &lt;code&gt;button[data-v-f3f3eg9]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e1258805ea6cb31e4a16aebae91838cb2b51823e" translate="yes" xml:space="preserve">
          <source>To solve this problem, Vue provides a &lt;code&gt;$listeners&lt;/code&gt; property containing an object of listeners being used on the component. For example:</source>
          <target state="translated">이 문제를 해결하기 위해 Vue는 구성 요소에서 사용되는 리스너 객체를 포함하는 &lt;code&gt;$listeners&lt;/code&gt; 속성을 제공합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74e4ed250349981c3620f36729665b310ba83bc0" translate="yes" xml:space="preserve">
          <source>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</source>
          <target state="translated">날짜 선택기 플러그인의 테마를 지정하려면 다음과 같이 특정 클래스를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="db281192f2ae7e8aaae42433318460411bdce998" translate="yes" xml:space="preserve">
          <source>To specify prop validations, you can provide an object with validation requirements to the value of &lt;code&gt;props&lt;/code&gt;, instead of an array of strings. For example:</source>
          <target state="translated">prop 유효성 검사를 지정하기 위해 문자열 배열 대신 &lt;code&gt;props&lt;/code&gt; 값에 유효성 검사 요구 사항이있는 객체를 제공 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df730f7289460e401600ab8828525feef7da880a" translate="yes" xml:space="preserve">
          <source>To start transitioning towards a more robust solution using Vue 2.0, let&amp;rsquo;s first wrap this filter in a new &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Vue 2.0을 사용하여보다 강력한 솔루션으로 전환을 시작하려면 먼저이 필터를 새로운 &lt;code&gt;&amp;lt;currency-input&amp;gt;&lt;/code&gt; 구성 요소로 감싸겠습니다 .</target>
        </trans-unit>
        <trans-unit id="69b37bec21337bb3fab748d90757734b339759ac" translate="yes" xml:space="preserve">
          <source>To take advantage of our newly created &lt;code&gt;esm&lt;/code&gt; module we need to add a few fields in our &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceeb4fc5def0e78eb9b247f42dfe35a650c1ee1" translate="yes" xml:space="preserve">
          <source>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ce5efe8104fcb04d9fe2076a11036b5f04f71a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we&amp;rsquo;ve only registered components globally, using &lt;code&gt;Vue.component&lt;/code&gt;:</source>
          <target state="translated">템플릿에서 이러한 구성 요소를 사용하려면 Vue가이를 알 수 있도록 등록해야합니다. 구성 요소 등록에는 &lt;strong&gt;global&lt;/strong&gt; 및 &lt;strong&gt;local&lt;/strong&gt; 의 두 가지 유형이 있습니다 . 지금까지 &lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 전 세계적으로 구성 요소를 등록 했습니다 .</target>
        </trans-unit>
        <trans-unit id="c646dfddede1e8b816398b2a45bcbd049b84852a" translate="yes" xml:space="preserve">
          <source>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: &lt;strong&gt;global&lt;/strong&gt; and &lt;strong&gt;local&lt;/strong&gt;. So far, we've only registered components globally, using the &lt;code&gt;component&lt;/code&gt; method of our app:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083ac4d1bdb64c24b06053515311f1dbb9c56468" translate="yes" xml:space="preserve">
          <source>Toggles the element&amp;rsquo;s &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="translated">표현식 값의 진실성을 기반으로 요소의 &lt;code&gt;display&lt;/code&gt; CSS 속성을 토글합니다 .</target>
        </trans-unit>
        <trans-unit id="c759e0477d126a03e9d103eb8525e47fab0be4d4" translate="yes" xml:space="preserve">
          <source>Toggles the element's &lt;code&gt;display&lt;/code&gt; CSS property based on the truthy-ness of the expression value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2062eeee29d80bbd790b6b1c6949a13f04e9706" translate="yes" xml:space="preserve">
          <source>Track the function that changes it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6caa355a086fc2249c03acc2b1839b71a8b078d" translate="yes" xml:space="preserve">
          <source>Tracking Runtime Errors</source>
          <target state="translated">런타임 오류 추적</target>
        </trans-unit>
        <trans-unit id="a176cdd957b46dda003cee3ad2c254dd6615b0eb" translate="yes" xml:space="preserve">
          <source>Transform and Opacity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ce581f0ea8d1b2420e91fc530ed304c21108f8" translate="yes" xml:space="preserve">
          <source>Transition &lt;code&gt;stagger&lt;/code&gt; Attribute &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">전환 스 &lt;code&gt;stagger&lt;/code&gt; 속성이 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="da0592cf78795180a4901cee778a25e6a87d50a4" translate="yes" xml:space="preserve">
          <source>Transition Class Change</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f251498a9b6cf9beba1d76cd01407a53ded18fc" translate="yes" xml:space="preserve">
          <source>Transition Classes</source>
          <target state="translated">전환 수업</target>
        </trans-unit>
        <trans-unit id="e11311738d4c6ffea274c409ecdda9e0756654ab" translate="yes" xml:space="preserve">
          <source>Transition Group Root Element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378b930e1b5fcf70d0c6bd07479947a4eb546d50" translate="yes" xml:space="preserve">
          <source>Transition Modes</source>
          <target state="translated">전환 모드</target>
        </trans-unit>
        <trans-unit id="c63dd8b039c9bc74f39dc660f1a5dd0332bdb933" translate="yes" xml:space="preserve">
          <source>Transition Modes so that you can orchestrate ordering during a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88887fef46466032f502eb29f868554693e91d2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Components</source>
          <target state="translated">구성 요소 간 전환</target>
        </trans-unit>
        <trans-unit id="729ea31da2993e21396230fd8222c60977213fa2" translate="yes" xml:space="preserve">
          <source>Transitioning Between Elements</source>
          <target state="translated">요소 간 전환</target>
        </trans-unit>
        <trans-unit id="a49e21a903b97ba094868eb0afba5e8256564527" translate="yes" xml:space="preserve">
          <source>Transitioning Single Elements/Components</source>
          <target state="translated">단일 요소 / 컴포넌트 전환</target>
        </trans-unit>
        <trans-unit id="683fee2e7c72141affe501b569a593b5a663b63c" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don&amp;rsquo;t even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;components#Dynamic-Components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="translated">구성 요소 간 전환이 훨씬 간단 합니다. &lt;code&gt;key&lt;/code&gt; 속성이 필요하지 않습니다 . 대신 &lt;a href=&quot;components#Dynamic-Components&quot;&gt;동적 구성 요소를&lt;/a&gt; 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="3ebf68016515c38ab5d5bb14e02906e976906a37" translate="yes" xml:space="preserve">
          <source>Transitioning between components is even simpler - we don't even need the &lt;code&gt;key&lt;/code&gt; attribute. Instead, we wrap a &lt;a href=&quot;component-basics#dynamic-components&quot;&gt;dynamic component&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e93cce4e6bbda7187841b2d8bb8c9ea9bb591d" translate="yes" xml:space="preserve">
          <source>Transitioning different states in an application, with &lt;code&gt;watchers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="2c61460002f7db08fe602f2c55ec5b58109e727a" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue&amp;rsquo;s component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="translated">Vue의 컴포넌트 시스템을 통해 전환을 재사용 할 수 있습니다. 재사용 가능한 전환을 만들려면 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 구성 요소를 루트에 배치 한 다음 모든 하위 항목을 전환 구성 요소에 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3389419ab0dc8619c42e92046a205d6cbaad10df" translate="yes" xml:space="preserve">
          <source>Transitions can be reused through Vue's component system. To create a reusable transition, all you have to do is place a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; component at the root, then pass any children into the transition component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe7bf85c8e42bb35f5c119b60107ac08d7dd2" translate="yes" xml:space="preserve">
          <source>Transitions on Initial Render</source>
          <target state="translated">초기 렌더링시 전환</target>
        </trans-unit>
        <trans-unit id="ea9b9a14750b0c53f7e4ae9826cc61972586d91e" translate="yes" xml:space="preserve">
          <source>Transitions with Style Bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ba1a884606d8d53aae517b3c977aedd3829998" translate="yes" xml:space="preserve">
          <source>Translate Docs</source>
          <target state="translated">문서 번역</target>
        </trans-unit>
        <trans-unit id="8ad8302d110b05d7e02330dac58628134fdcff02" translate="yes" xml:space="preserve">
          <source>Translations</source>
          <target state="translated">Translations</target>
        </trans-unit>
        <trans-unit id="eafcab92249a0ffd49ad48547d7448759e6aa04c" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener&amp;rsquo;s callback function.</source>
          <target state="translated">현재 인스턴스에서 이벤트를 트리거합니다. 추가 인수는 리스너의 콜백 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7ce3c92d4d6dbb6b2b78de21280fe459138d0f" translate="yes" xml:space="preserve">
          <source>Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdc40b121c3b5e2b8c970420d2e421c9a7ed7cd" translate="yes" xml:space="preserve">
          <source>Trigger the function so it can update the final value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b1b4852352a99bc2e60b5c2bca0de04c5a0e58" translate="yes" xml:space="preserve">
          <source>Trigger transitions</source>
          <target state="translated">트리거 전환</target>
        </trans-unit>
        <trans-unit id="157ebe584fb6f0fc58df93caa511c65b6198fe3d" translate="yes" xml:space="preserve">
          <source>Triggers the &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;destroyed&lt;/code&gt; hooks.</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; 및 &lt;code&gt;destroyed&lt;/code&gt; 훅을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="d420c849a5dc1f0529452193788a65de950aab62" translate="yes" xml:space="preserve">
          <source>Truthiness/Falsiness with &lt;code&gt;v-bind&lt;/code&gt;&lt;sup&gt;changed&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 진실 / 거짓이 &lt;sup&gt;변경됨&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d01a4f9ab1ff7fae7cb3dedf5ed58a422558aa71" translate="yes" xml:space="preserve">
          <source>Try this lesson on Scrimba</source>
          <target state="translated">Scrimba에서이 강의를 시도해보십시오</target>
        </trans-unit>
        <trans-unit id="32ae11a86cc97e517601b6c7e4ad185de28233ca" translate="yes" xml:space="preserve">
          <source>Try to change the value of &lt;code&gt;books&lt;/code&gt; array in the application &lt;code&gt;data&lt;/code&gt; and you will see how &lt;code&gt;publishedBooksMessage&lt;/code&gt; is changing accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d5f8ded86e9c7db19490f3af36b27e26fc547c" translate="yes" xml:space="preserve">
          <source>Turn on Production Mode</source>
          <target state="translated">생산 모드 켜기</target>
        </trans-unit>
        <trans-unit id="6ad6b070d8858ef9034c2b27714131daa17dc2f1" translate="yes" xml:space="preserve">
          <source>Two of the most commonly used directives in Vue.js are &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;. So it's no surprise that there comes a time when developers want to use both together. While this is not a recommended practice, there may be times when this is necessary, so we wanted to provide guidance for how it works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f301c8844da472aa1a826f8a27afb3c78a049e5" translate="yes" xml:space="preserve">
          <source>Two-Way Filters &lt;sup&gt;replaced&lt;/sup&gt;</source>
          <target state="translated">양방향 필터 &lt;sup&gt;교체&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5541b2f56b10335a874486b8e8c3fb6f6652d19" translate="yes" xml:space="preserve">
          <source>Type Checks</source>
          <target state="translated">타입 확인</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="aec373f2c6104f4e0717f76308cbda4cbd9ffa55" translate="yes" xml:space="preserve">
          <source>TypeScript Support</source>
          <target state="translated">TypeScript 지원</target>
        </trans-unit>
        <trans-unit id="8170f1ce20dc21f163cf51322861b52a4e97389f" translate="yes" xml:space="preserve">
          <source>TypeScript should be able to infer most of the types without defining types explicitly. For example, if you have a component with a number &lt;code&gt;count&lt;/code&gt; property, you will have an error if you try to call a string-specific method on it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55ceb4ee3907ab73fac7e8e26ce07c11d3e0af7" translate="yes" xml:space="preserve">
          <source>Typically this is done on the top of &lt;code&gt;App.vue&lt;/code&gt; as it will be the first focusable element on all your pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c49cff5528c3adc7123ea4b4bd10c092f423a6" translate="yes" xml:space="preserve">
          <source>Typically this is used to avoid conflicting with server-side frameworks that also use mustache syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5614fd83d7c12176ea9d23d0a9a55af15cb1297f" translate="yes" xml:space="preserve">
          <source>Typing</source>
          <target state="translated">Typing</target>
        </trans-unit>
        <trans-unit id="008b2efd937ff1c3483ebcd86c95416cf9a4fc6a" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;computed&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b08374e53ad50d899f5b39f4b437e0d89dd152" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;reactive&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78cd4e8a3266b63fc59c7788f1a2d9d235e682" translate="yes" xml:space="preserve">
          <source>Typing &lt;code&gt;refs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd6ddea889188f5409ccc93b3f07e4e036e69a1" translate="yes" xml:space="preserve">
          <source>UMD</source>
          <target state="translated">UMD</target>
        </trans-unit>
        <trans-unit id="57c74547c7338aa72bc084a3800f580c969f4939" translate="yes" xml:space="preserve">
          <source>Under no circumstances should 2 alerts be used next to one another, it's a sign that we're not able to explain context well enough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d13eb403bd42b865740161f8cbc0987c94607" translate="yes" xml:space="preserve">
          <source>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</source>
          <target state="translated">Vue는 템플릿을 Virtual DOM 렌더링 함수로 컴파일합니다. 반응성 시스템과 결합 된 Vue는 앱 상태가 변경 될 때 최소한의 컴포넌트를 지능적으로 파악하여 최소한의 DOM 조작을 다시 렌더링하고 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1ce3521c0de87c0b96c0765bcfe6f68f1f6e9e" translate="yes" xml:space="preserve">
          <source>Understandable (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efebc0e828d40a601d9f18dd32ec7ffc783e63b7" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn&amp;rsquo;t allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &amp;ldquo;void&amp;rdquo; elements&lt;/a&gt;. That&amp;rsquo;s why the strategy is only possible when Vue&amp;rsquo;s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="translated">불행히도 HTML은 사용자 정의 요소가 자체 폐쇄 전용 &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;공식 &quot;void&quot;요소&lt;/a&gt; 가되도록 허용하지 않습니다 . 그렇기 때문에 Vue의 템플릿 컴파일러가 DOM보다 먼저 템플릿에 도달 한 다음 DOM 사양 호환 HTML을 제공 할 수있는 경우에만 전략이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="98c83482c6886ad1473a05cf5f78dcfee5bc89dc" translate="yes" xml:space="preserve">
          <source>Unfortunately, HTML doesn't allow custom elements to be self-closing - only &lt;a href=&quot;https://www.w3.org/TR/html/syntax.html#void-elements&quot;&gt;official &quot;void&quot; elements (opens new window)&lt;/a&gt;. That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde72f0f84d52a7aa84d7462ed5f19ec98ac0985" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML&amp;rsquo;s case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="translated">불행히도 HTML의 대소 문자 구분이 없기 때문에 DOM 템플릿은 여전히 ​​케밥 케이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b10a452c474e61495690e111a7011d55f17f26b9" translate="yes" xml:space="preserve">
          <source>Unfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5fadc81ad6c9be68633a21c0b94f28044dc294" translate="yes" xml:space="preserve">
          <source>Unfortunately, with such a destructuring the reactivity for both properties would be lost. For such a case, we need to convert our reactive object to a set of refs. These refs will retain the reactive connection to the source object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438d23452047f4defac8e18aecae37372fcea335" translate="yes" xml:space="preserve">
          <source>Unit Testing</source>
          <target state="translated">단위 테스트</target>
        </trans-unit>
        <trans-unit id="fa4ba8e0a89b5b3663d1a20fd16ffec2b04f9510" translate="yes" xml:space="preserve">
          <source>Unit testing a Vue application does not significantly differ from testing other types of applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fab82db2414bfb4495b150b0fb016a74e7217d8" translate="yes" xml:space="preserve">
          <source>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5784cfdccc209a8e200b1ac07b791bba6b8e33be" translate="yes" xml:space="preserve">
          <source>Unless you spread components out over multiple files (for example with &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS Modules&lt;/a&gt;), scoping CSS in React is often done via CSS-in-JS solutions (e.g. &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-components&lt;/a&gt;, &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;glamorous&lt;/a&gt;, and &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;emotion&lt;/a&gt;). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</source>
          <target state="translated">컴포넌트를 여러 파일에 분산시키지 않는 한 (예 : &lt;a href=&quot;https://github.com/gajus/react-css-modules&quot;&gt;CSS 모듈 사용&lt;/a&gt; ) React에서 CSS 범위 지정은 종종 CSS-in-JS 솔루션 (예 : &lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;스타일 컴포넌트&lt;/a&gt; , &lt;a href=&quot;https://github.com/paypal/glamorous&quot;&gt;화려 함&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/emotion-js/emotion&quot;&gt;감정&lt;/a&gt; )을 통해 수행됩니다. 이것은 일반적인 CSS 저작 프로세스와는 다른 새로운 컴포넌트 지향 스타일링 패러다임을 소개합니다. 또한 빌드시 CSS를 단일 스타일 시트로 추출하는 기능이 지원되지만 스타일링이 제대로 작동하려면 번들을 런타임에 포함시켜야하는 것이 일반적입니다. 스타일을 구성하는 동안 JavaScript의 역동성에 액세스 할 수 있지만 번들 크기와 런타임 비용이 증가하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd579c46ea157b603f52518cfa50c5d9581039b9" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, it renders an actual element: a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; by default. You can change the element that&amp;rsquo;s rendered with the &lt;code&gt;tag&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 달리 실제 요소 인 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 을 기본적으로 렌더링합니다 . &lt;code&gt;tag&lt;/code&gt; 속성으로 렌더링되는 요소를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6acb74ac65b8a5066968b3279fd2e776accbabb" translate="yes" xml:space="preserve">
          <source>Unlike attributes, directives can't be passed to a different element with &lt;code&gt;v-bind=&quot;$attrs&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca7305c07b7e218db67c93a49432c3e6a15dd6" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names don&amp;rsquo;t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</source>
          <target state="translated">컴포넌트 및 소품과 달리 이벤트 이름은 자동 대소 문자 변환을 제공하지 않습니다. 대신, 생성 된 이벤트의 이름은 해당 이벤트를 청취하는 데 사용 된 이름과 정확히 일치해야합니다. 예를 들어, camelCased 이벤트 이름을 내보내는 경우 :</target>
        </trans-unit>
        <trans-unit id="1b5932d92048f8173920b18339d8abf66540f64a" translate="yes" xml:space="preserve">
          <source>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there&amp;rsquo;s no reason to use camelCase or PascalCase. Additionally, &lt;code&gt;v-on&lt;/code&gt; event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML&amp;rsquo;s case-insensitivity), so &lt;code&gt;v-on:myEvent&lt;/code&gt; would become &lt;code&gt;v-on:myevent&lt;/code&gt; &amp;ndash; making &lt;code&gt;myEvent&lt;/code&gt; impossible to listen to.</source>
          <target state="translated">컴포넌트 및 소품과 달리 이벤트 이름은 JavaScript에서 변수 또는 속성 이름으로 사용되지 않으므로 camelCase 또는 PascalCase를 사용할 이유가 없습니다. 또한 DOM 템플릿 내의 &lt;code&gt;v-on&lt;/code&gt; 이벤트 리스너는 HTML의 대소 문자를 구분하지 않기 때문에 자동으로 소문자로 변환되므로 &lt;code&gt;v-on:myEvent&lt;/code&gt; 는 &lt;code&gt;v-on:myevent&lt;/code&gt; 가 되어 &lt;code&gt;myEvent&lt;/code&gt; 를들을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f006741a889552e701feca503ae9ecc21cef3c4c" translate="yes" xml:space="preserve">
          <source>Unlike in 1.x, these &lt;code&gt;$refs&lt;/code&gt; are not reactive, because they&amp;rsquo;re registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</source>
          <target state="translated">1.x와 달리이 &lt;code&gt;$refs&lt;/code&gt; 는 렌더링 프로세스 자체에서 등록 / 업데이트되기 때문에 반응하지 않습니다. 그것들을 반응 적으로 만들려면 모든 변경에 대해 중복 렌더링이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fcbebe457290f0fc4402b0c59876bcbdda0f2d4e" translate="yes" xml:space="preserve">
          <source>Unlike most of the application methods, &lt;code&gt;mount&lt;/code&gt; does not return the application. Instead it returns the root component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2884ecb559d2fe9248396c1892b61a7ac7c3279" translate="yes" xml:space="preserve">
          <source>Unlike single root node components, components with multiple root nodes do not have an automatic attribute fallthrough behavior. If &lt;code&gt;$attrs&lt;/code&gt; are not bound explicitly, a runtime warning will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a11b676273740dcc6b273657283a0efe154b9e" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;component-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven't read about components yet, don't worry about this for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a336f78a69fc6406c5b9e9b9181b8c60e3829997" translate="yes" xml:space="preserve">
          <source>Unlike the other modifiers, which are exclusive to native DOM events, the &lt;code&gt;.once&lt;/code&gt; modifier can also be used on &lt;a href=&quot;components-custom-events&quot;&gt;component events&lt;/a&gt;. If you haven&amp;rsquo;t read about components yet, don&amp;rsquo;t worry about this for now.</source>
          <target state="translated">네이티브 DOM 이벤트에만 적용되는 다른 수정 자와 달리 &lt;code&gt;.once&lt;/code&gt; 수정자는 &lt;a href=&quot;components-custom-events&quot;&gt;구성 요소 이벤트&lt;/a&gt; 에도 사용할 수 있습니다 . 아직 구성 요소에 대해 읽지 않았다면 지금 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d465ac61f7785357bc3939f874106ce910c0065e" translate="yes" xml:space="preserve">
          <source>Unmounts a root component of the application instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289cb3bfd569e3d20bbdf203e762e02753089f2c" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot-scope&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0 이상에서 업데이트되었습니다. &lt;code&gt;slot-scope&lt;/code&gt; 속성을 사용하는 더 이상 사용되지 않는 구문 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;은 여기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6850e978579f57a9a7da09e605e48276246d285" translate="yes" xml:space="preserve">
          <source>Updated in 2.6.0+. &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;See here&lt;/a&gt; for the deprecated syntax using the &lt;code&gt;slot&lt;/code&gt; attribute.</source>
          <target state="translated">2.6.0 이상에서 업데이트되었습니다. &lt;code&gt;slot&lt;/code&gt; 속성을 사용하는 더 이상 사용되지 않는 구문 &lt;a href=&quot;#Deprecated-Syntax&quot;&gt;은 여기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4273a6bbb2974f5727228ca361ff3584716df7e4" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;innerHTML&lt;/code&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="translated">요소의 &lt;code&gt;innerHTML&lt;/code&gt; 을 업데이트합니다 . &lt;strong&gt;내용은 일반 HTML로 삽입되므로 Vue 템플릿으로 컴파일되지 않습니다&lt;/strong&gt; . &lt;code&gt;v-html&lt;/code&gt; 을 사용하여 템플릿을 작성하려는 경우 구성 요소를 대신 사용하여 솔루션을 다시 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="004c861aa8adec999af936828cfad53817d95e1d" translate="yes" xml:space="preserve">
          <source>Updates the element&amp;rsquo;s &lt;code&gt;textContent&lt;/code&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;code&gt;{{ Mustache }}&lt;/code&gt; interpolations.</source>
          <target state="translated">요소의 &lt;code&gt;textContent&lt;/code&gt; 를 업데이트합니다 . &lt;code&gt;textContent&lt;/code&gt; 의 일부를 업데이트 해야하는 경우 &lt;code&gt;{{ Mustache }}&lt;/code&gt; 보간 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0dca31a6bb9b094601cb2bf5c3fb308c6b17b07" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML (opens new window)&lt;/a&gt;. &lt;strong&gt;Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates&lt;/strong&gt;. If you find yourself trying to compose templates using &lt;code&gt;v-html&lt;/code&gt;, try to rethink the solution by using components instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56a36977305fbcc90290b7281ac8a8f0c3bd604" translate="yes" xml:space="preserve">
          <source>Updates the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent&quot;&gt;textContent (opens new window)&lt;/a&gt;. If you need to update the part of &lt;code&gt;textContent&lt;/code&gt;, you should use &lt;a href=&quot;../guide/template-syntax#text&quot;&gt;mustache interpolations&lt;/a&gt; instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c47365d1a0fe7112a5f7aa0465ebbfe1515656" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, we never have to do it manually. Instead, we tell Vue what HTML we want on the page, in a template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728bcaed30d135845ad4d9727bb2fedf3ab532fd" translate="yes" xml:space="preserve">
          <source>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</source>
          <target state="translated">이러한 모든 노드를 효율적으로 업데이트하는 것은 어려울 수 있지만 다행히도 수동으로 수행 할 필요는 없습니다. 대신 Vue에게 페이지에서 원하는 HTML을 템플릿으로 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="df5f7691ac781f41ca5afafd2680476339c01140" translate="yes" xml:space="preserve">
          <source>Upgrade Path</source>
          <target state="translated">업그레이드 경로</target>
        </trans-unit>
        <trans-unit id="ec1b871568c8f9b96404fba4999e4bb30bebeba0" translate="yes" xml:space="preserve">
          <source>Usage in Plugins</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4904a06bbdeb879018def05329454362a6b30d64" translate="yes" xml:space="preserve">
          <source>Usage inside &lt;code&gt;v-for&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a7118317b50bdd15b995e3d624b912b5b2b04f" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;this&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e644418d310386dee848ceb934d28e9af6afeacb" translate="yes" xml:space="preserve">
          <source>Usage on Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f552ba1fe9fac09e7847e64d87dc1587fbb26d11" translate="yes" xml:space="preserve">
          <source>Usage with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba388099a4f8ff3ba8295c16666928b0c410e2" translate="yes" xml:space="preserve">
          <source>Usage with Render Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74099084c0693149248e8ca16d0bd6b67bb5c59" translate="yes" xml:space="preserve">
          <source>Usage with Templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ee016fea5ce9a71d77f20f1124659e54e0db2b" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/plugins/tree/master/packages/replace&quot;&gt;@rollup/plugin-replace (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4358eb815c9ed342dae4a95fe44e11cf8da5da2f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;rollup-plugin-replace&lt;/a&gt;:</source>
          <target state="translated">사용 &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;롤업 - 플러그인 - 교체&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="770eccd63737a87d0af971af27197f8bcf7a45af" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;debounce&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt;&lt;code&gt;throttle&lt;/code&gt;&lt;/a&gt;) to directly limit calling the expensive method. You can achieve the same as above like this:</source>
          <target state="translated">사용 &lt;a href=&quot;https://lodash.com/docs/4.15.0#debounce&quot;&gt;lodash의 &lt;code&gt;debounce&lt;/code&gt; &lt;/a&gt; (또는 아마도 &lt;a href=&quot;https://lodash.com/docs/4.15.0#throttle&quot;&gt; &lt;code&gt;throttle&lt;/code&gt; &lt;/a&gt; ) 직접 비용이 메소드를 호출 제한합니다. 다음과 같이 위와 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f776d9fd3fd7d4cf6f4d0ff2c7bfb1f591f9665e" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash&amp;rsquo;s &lt;code&gt;orderBy&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt;&lt;code&gt;sortBy&lt;/code&gt;&lt;/a&gt;) in a computed property:</source>
          <target state="translated">계산 된 속성에서 &lt;a href=&quot;https://lodash.com/docs/4.15.0#orderBy&quot;&gt;lodash의 &lt;code&gt;orderBy&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://lodash.com/docs/4.15.0#sortBy&quot;&gt; &lt;code&gt;sortBy&lt;/code&gt; &lt;/a&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b65b00b4f349332f98c19c8c7946c443739424f" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteEnter&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">대신 컴포넌트에서 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteEnter&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4b6a0918785a35f0aff111346b42f9d5ed745a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt;&lt;code&gt;beforeRouteLeave&lt;/code&gt;&lt;/a&gt; in the component instead.</source>
          <target state="translated">대신 구성 요소에서 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards&quot;&gt; &lt;code&gt;beforeRouteLeave&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b146a4d03f95af25cb10c2b0020494c65743663" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt;&lt;code&gt;beforeEnter&lt;/code&gt;&lt;/a&gt; in the route instead.</source>
          <target state="translated">대신 경로에 &lt;a href=&quot;https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard&quot;&gt; &lt;code&gt;beforeEnter&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33f1e610a57929c4e74366b0a8a6bb3ea3c38c36" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;$parent&lt;/code&gt; and &lt;code&gt;$children&lt;/code&gt; sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</source>
          <target state="translated">사용 &lt;code&gt;$parent&lt;/code&gt; 와 &lt;code&gt;$children&lt;/code&gt; 아껴서를 - 그들은 대부분 탈출 해치 역할을합니다. 부모-자식 의사 소통을 위해 소품과 이벤트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae236c5510e3bb66bf05b93a526a41048c00529d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Array.prototype.splice&lt;/code&gt; instead. For example:</source>
          <target state="translated">대신 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 를 사용하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0de57bc92cbef9103a4feec014e70c0e78ec2fde" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Vue.set&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;Vue.set&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9da9bf6c22c0cbdcaec5f091c5322fc90e7ae5a" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt;&lt;code&gt;.filter&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">계산 된 속성 에서 JavaScript의 기본 제공 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples&quot;&gt; &lt;code&gt;.filter&lt;/code&gt; 메서드&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="003bf1a1826ab5d9749321efe03218bdcb718541" translate="yes" xml:space="preserve">
          <source>Use JavaScript&amp;rsquo;s built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt;&lt;code&gt;.slice&lt;/code&gt; method&lt;/a&gt; in a computed property:</source>
          <target state="translated">계산 된 속성 에서 JavaScript의 기본 제공 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples&quot;&gt; &lt;code&gt;.slice&lt;/code&gt; 메서드&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7e721c416e04d64ab5e5780f342a54b19396986" translate="yes" xml:space="preserve">
          <source>Use a custom in-DOM check in other hooks. For example, to replace:</source>
          <target state="translated">다른 후크에서 사용자 정의 DOM 점검을 사용하십시오. 예를 들어 다음을 바꾸려면</target>
        </trans-unit>
        <trans-unit id="181538426a8718fe366424835db6e5717dd50aee" translate="yes" xml:space="preserve">
          <source>Use actual heading tags instead of styling text to give the visual appearance of headings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81da353e3fb3a59a8169efc41ef1b1548bc374a5" translate="yes" xml:space="preserve">
          <source>Use components instead.</source>
          <target state="translated">대신 구성 요소를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b6155be32a2fc7dfe3a4813d55af8d925da09a" translate="yes" xml:space="preserve">
          <source>Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It&amp;rsquo;s also a good idea to ship them as &lt;a href=&quot;plugins&quot;&gt;Plugins&lt;/a&gt; to avoid duplicate application.</source>
          <target state="translated">글로벌 믹스 인은 타사 구성 요소를 포함하여 생성 된 모든 단일 Vue 인스턴스에 영향을주기 때문에 드물고 신중하게 사용하십시오. 대부분의 경우 위의 예에서 설명한 것처럼 사용자 지정 옵션 처리에만 사용해야합니다. 중복 응용 프로그램을 피하기 위해 &lt;a href=&quot;plugins&quot;&gt;플러그인&lt;/a&gt; 으로 제공 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="85c08ee2f7039cb44ad9c33cd944c4130587b85f" translate="yes" xml:space="preserve">
          <source>Use plugins by calling the &lt;code&gt;Vue.use()&lt;/code&gt; global method. This has to be done before you start your app by calling &lt;code&gt;new Vue()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Vue.use()&lt;/code&gt; 전역 메소드 를 호출하여 플러그인을 사용하십시오 . &lt;code&gt;new Vue()&lt;/code&gt; 호출하여 앱을 시작하기 전에이 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8e44f9d7cf511d97072bab1fc39f6bfbb414fe" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; for the optimal debugging experience.</source>
          <target state="translated">최적의 디버깅 경험을 위해서는 &lt;a href=&quot;https://github.com/vuejs/vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fef0499237cdabcdb792468442be5967c7e8686b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;created&lt;/code&gt; hook instead.</source>
          <target state="translated">대신 &lt;code&gt;created&lt;/code&gt; 후크를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="74f29cc48c4d34caf8438d092e7f5db6485b0b48" translate="yes" xml:space="preserve">
          <source>Use the component&amp;rsquo;s &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt;&lt;code&gt;beforeDestroy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/index#destroyed&quot;&gt;&lt;code&gt;destroyed&lt;/code&gt;&lt;/a&gt; hooks instead.</source>
          <target state="translated">대신 구성 요소의 &lt;a href=&quot;../api/index#beforeDestroy&quot;&gt; &lt;code&gt;beforeDestroy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../api/index#destroyed&quot;&gt; &lt;code&gt;destroyed&lt;/code&gt; &lt;/a&gt; 훅을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="537e927a3b754157432123069801236c6891d42d" translate="yes" xml:space="preserve">
          <source>Use the native DOM API:</source>
          <target state="translated">기본 DOM API를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="49f7c44dbc505ff4b6fe57133375f62aee01c648" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;beforeCreate&lt;/code&gt; hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</source>
          <target state="translated">대신 새로운 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 사용하십시오. 이는 본질적으로 동일합니다. 다른 수명주기 방법과의 일관성을 위해 이름이 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="4c301d9951079bd9b87dc0a676559de31cdc0957" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead.</source>
          <target state="translated">대신 새 &lt;code&gt;mounted&lt;/code&gt; 고리를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3d602cbc444cd25effed3179178c8fe1d36b0d9" translate="yes" xml:space="preserve">
          <source>Use the new &lt;code&gt;mounted&lt;/code&gt; hook instead. It should be noted though that with &lt;code&gt;mounted&lt;/code&gt;, there&amp;rsquo;s no guarantee to be in-document. For that, also include &lt;code&gt;Vue.nextTick&lt;/code&gt;/&lt;code&gt;vm.$nextTick&lt;/code&gt;. For example:</source>
          <target state="translated">대신 새 &lt;code&gt;mounted&lt;/code&gt; 고리를 사용하십시오. 하지만 &lt;code&gt;mounted&lt;/code&gt; 하면 문서 내를 보장 할 수 없습니다. 이를 위해 &lt;code&gt;Vue.nextTick&lt;/code&gt; / &lt;code&gt;vm.$nextTick&lt;/code&gt; 도 포함 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4605b49670d374a5aa51ee71b7ef52006c5d7a3" translate="yes" xml:space="preserve">
          <source>Use the official &lt;a href=&quot;#cli&quot;&gt;CLI&lt;/a&gt; to scaffold a project, which provides batteries-included build setups for a modern frontend workflow (e.g., hot-reload, lint-on-save, and much more)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160b6d69d6038c85412ab8171ce4aea2da0fb502" translate="yes" xml:space="preserve">
          <source>Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; component instance created afterwards in the given app (for example, child components):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f909c50760bc08f177877869663a7491252c658f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/component-dynamic-async&quot;&gt;dynamic components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8398bc374e7299bcdc0bcd8814f8339b2d9b2f" translate="yes" xml:space="preserve">
          <source>Used for &lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;dynamic components&lt;/a&gt; and to work around &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;limitations of in-DOM templates&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Dynamic-Components&quot;&gt;동적 구성 요소에&lt;/a&gt; 사용되며 &lt;a href=&quot;../guide/components#DOM-Template-Parsing-Caveats&quot;&gt;In-DOM 템플릿의 제한 사항&lt;/a&gt; 을 해결하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1747aa5023d3689b28a9d8a62ae870f54f3b5d5e" translate="yes" xml:space="preserve">
          <source>Used on content inserted into child components to indicate which named slot the content belongs to.</source>
          <target state="translated">하위 컴포넌트에 삽입 된 컨텐츠에서 컨텐츠가 속하는 명명 된 슬롯을 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22127d9f3bc8fde382f2797750f0f521f655892f" translate="yes" xml:space="preserve">
          <source>Used to denote a &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element as a scoped slot.</source>
          <target state="translated">&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 범위가 지정된 슬롯으로 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4331447ff379465e5cfbc7b6668bd16157a0f747" translate="yes" xml:space="preserve">
          <source>Used to denote an element or component as a scoped slot. The attribute&amp;rsquo;s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for &lt;a href=&quot;#scope-replaced&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; in 2.5.0+.</source>
          <target state="translated">요소 또는 구성 요소를 범위가 지정된 슬롯으로 표시하는 데 사용됩니다. 속성 값은 함수 시그니처의 인수 위치에 나타날 수있는 유효한 JavaScript 표현식이어야합니다. 이는 지원되는 환경에서 표현식에서 ES2015 파괴를 사용할 수도 있음을 의미합니다. 2.5.0 이상에서 &lt;a href=&quot;#scope-replaced&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6e2c7515c0dae7baac879187b01636fa11edecb1" translate="yes" xml:space="preserve">
          <source>Used to programmatically access &lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;scoped slots&lt;/a&gt;. For each slot, including the &lt;code&gt;default&lt;/code&gt; one, the object contains a corresponding function that returns VNodes.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Scoped-Slots&quot;&gt;범위가 지정된 슬롯&lt;/a&gt; 에 프로그래밍 방식으로 액세스하는 데 사용됩니다 . &lt;code&gt;default&lt;/code&gt; 슬롯을 포함하여 각 슬롯에 대해 객체는 VNode를 반환하는 해당 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="76072ee6b19562b61739da43c75a8552a434c5d4" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/component-basics#content-distribution-with-slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/component-slots#named-slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;this.$slots.foo()&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8b5683fd652bb8adfa41ec534ebcd919be8706" translate="yes" xml:space="preserve">
          <source>Used to programmatically access content &lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;distributed by slots&lt;/a&gt;. Each &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;named slot&lt;/a&gt; has its own corresponding property (e.g. the contents of &lt;code&gt;v-slot:foo&lt;/code&gt; will be found at &lt;code&gt;vm.$slots.foo&lt;/code&gt;). The &lt;code&gt;default&lt;/code&gt; property contains either nodes not included in a named slot or contents of &lt;code&gt;v-slot:default&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/components#Content-Distribution-with-Slots&quot;&gt;슬롯별로 배포 된&lt;/a&gt; 콘텐츠에 프로그래밍 방식으로 액세스하는 데 사용됩니다 . 각각의 &lt;a href=&quot;../guide/components#Named-Slots&quot;&gt;이름이 슬롯은&lt;/a&gt; 자신의 상응하는 특성이있다 (예 : 내용 &lt;code&gt;v-slot:foo&lt;/code&gt; 에서 찾을 수 &lt;code&gt;vm.$slots.foo&lt;/code&gt; ). &lt;code&gt;default&lt;/code&gt; 속성 중 하나라는 슬롯 또는 내용에 포함되지 않은 노드들이 포함 &lt;code&gt;v-slot:default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e6bf115dec713a7c40e6db8b7a9b940453656d5" translate="yes" xml:space="preserve">
          <source>User Agent Accessibility Guidelines (UAAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="88c450bf7dc4b899fc608077fc184ec1727d8b1a" translate="yes" xml:space="preserve">
          <source>Users can navigate an application through headings. Having descriptive headings for every section of your application makes it easier for users to predict the content of each section. When it comes to headings, there are a couple of recommended accessibility practices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2aa5abde13c9a2b4d796246137c973fbb88554" translate="yes" xml:space="preserve">
          <source>Users must be able to access the content as technologies advance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a271e1f44586e5083fc1918fdaffbb8a054342" translate="yes" xml:space="preserve">
          <source>Users must be able to perceive the information being presented</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589f322b8166b58e4896f447ee126a460ba0bbe3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt; is similar to &lt;code&gt;aria-label&lt;/code&gt; expect it is used if the label text is visible on screen. It is paired to other elements by their &lt;code&gt;id&lt;/code&gt; and you can link multiple &lt;code&gt;id&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa62aeea16980ec64983f9904128d289d5c289d1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with additional arguments:</source>
          <target state="translated">추가 인수와 함께 &lt;code&gt;$emit&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="12da60edc3ad2c7b70d8e9cce9f0a9df3bfdda28" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;$emit&lt;/code&gt; with only an event name:</source>
          <target state="translated">이벤트 이름으로 &lt;code&gt;$emit&lt;/code&gt; 사용하기 :</target>
        </trans-unit>
        <trans-unit id="6dd92839e80d19c8ccf3963667869ebe9c723664" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;keyCode&lt;/code&gt; attributes is also permitted:</source>
          <target state="translated">&lt;code&gt;keyCode&lt;/code&gt; 속성 사용 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="08b4f74f4b29aefd57fecf9253958e21fc91a467" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; (discussed &lt;a href=&quot;#provide-inject&quot;&gt;below&lt;/a&gt;) should also be considered as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890d71127137c4c4cd4e9d9a52e044f00ece5fd0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;provide&lt;/code&gt; is especially useful when writing a plugin, as an alternative to &lt;code&gt;globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86076651686c0fbe2de9bc0df0db687049714e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520de81fd3ca0b36aa8f7bf6d1956e1927c8833d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-bind.sync&lt;/code&gt; with a literal object, such as in &lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt;, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</source>
          <target state="translated">&lt;code&gt;v-bind.sync=&amp;rdquo;{ title: doc.title }&amp;rdquo;&lt;/code&gt; 과 같이 리터럴 객체와 함께 &lt;code&gt;v-bind.sync&lt;/code&gt; 를 사용 하면 복잡한 표현식을 구문 분석 할 때 고려해야 할 에지 케이스가 너무 많으므로 작동하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="cb9ed6a801a2b736f9a0652c49f9728b264bc60a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt;, we &lt;em&gt;only&lt;/em&gt; iterate over active users during render, making rendering much more efficient.</source>
          <target state="translated">사용 &lt;code&gt;v-for=&quot;user in activeUsers&quot;&lt;/code&gt; , 우리 &lt;em&gt;만&lt;/em&gt; 렌더링하는 동안 반복 처리를 통해 활성 사용자를 훨씬 더 효율적으로 렌더링하기.</target>
        </trans-unit>
        <trans-unit id="35b55bd9e1ce580fb7b538c51534550ec7476474" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="translated">사용 &lt;code&gt;v-if&lt;/code&gt; 와 &lt;code&gt;v-for&lt;/code&gt; 함께하는 것이됩니다 &lt;strong&gt;하지 않는 것이 좋습니다&lt;/strong&gt; . 자세한 내용은 &lt;a href=&quot;../style-guide/index#Avoid-v-if-with-v-for-essential&quot;&gt;스타일 가이드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e65c164b999421d82c5e3d232a414fe76b72cd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; together is &lt;strong&gt;not recommended&lt;/strong&gt;. See the &lt;a href=&quot;../style-guide/index#avoid-v-if-with-v-for-essential&quot;&gt;style guide&lt;/a&gt; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08436e8dc76f8135756ac6e58f6c2e883ec453a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;v-model&lt;/code&gt; on Components</source>
          <target state="translated">컴포넌트에서 &lt;code&gt;v-model&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="61103105b06a8a12d7a44547eb3823dbfa7110a6" translate="yes" xml:space="preserve">
          <source>Using Inject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bec21c8cee3e33b5dac0046a374df3c2c48880" translate="yes" xml:space="preserve">
          <source>Using JavaScript Expressions</source>
          <target state="translated">JavaScript 표현식 사용</target>
        </trans-unit>
        <trans-unit id="132307a32976d23c3e63eb2beb64895a6f3b8113" translate="yes" xml:space="preserve">
          <source>Using Provide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3e224c9ece88fc5daf98825603dfa596a858f9" translate="yes" xml:space="preserve">
          <source>Using Transitions and Animations Together</source>
          <target state="translated">전환과 애니메이션을 함께 사용</target>
        </trans-unit>
        <trans-unit id="b579cc565a1407302b51f876ebcc73fcff092577" translate="yes" xml:space="preserve">
          <source>Using a Plugin</source>
          <target state="translated">플러그인 사용</target>
        </trans-unit>
        <trans-unit id="9cf1549aea5e4ae2e67b0407f6b2344a0f1eb294" translate="yes" xml:space="preserve">
          <source>Using a watcher to compare values of an array or object that are reactive requires that it has a copy made of just the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0336a05c8502e8781bee82f0a3465066267e8899" translate="yes" xml:space="preserve">
          <source>Using an injected value as data entry:</source>
          <target state="translated">주입 된 값을 데이터 입력으로 사용 :</target>
        </trans-unit>
        <trans-unit id="ee566e9a4742cc53aa6541d4b3218cedba54e109" translate="yes" xml:space="preserve">
          <source>Using an injected value as the default for a prop:</source>
          <target state="translated">prop의 기본값으로 주입 된 값 사용 :</target>
        </trans-unit>
        <trans-unit id="cadb29867f8bf5340110eea6965faf58a3f6b48a" translate="yes" xml:space="preserve">
          <source>Using multiple teleports on the same target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e60545192243d051978512aa4ed96cc42d4d52" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; example from before, here is how it would look now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59268f2ba7d914bcab2c86e53d4606060ae7fc63" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our code can be updated as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc842072bfc033f9a866308b4dcf7050475c4957" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMap&lt;/code&gt; component, our provided values can be refactored as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e1a63d9acef5fd371c928b3e6b7280614408e1" translate="yes" xml:space="preserve">
          <source>Using our &lt;code&gt;MyMarker&lt;/code&gt; component, we can refactor it with the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86942fa2e2d5d629468c3dd32e1a6910c8344b97" translate="yes" xml:space="preserve">
          <source>Using our date-picker component example from the &lt;a href=&quot;#attribute-inheritance&quot;&gt;previous section&lt;/a&gt;, in the event we need to apply all non-prop attributes to the &lt;code&gt;input&lt;/code&gt; element rather than the root &lt;code&gt;div&lt;/code&gt; element, this can be accomplished by using the &lt;code&gt;v-bind&lt;/code&gt; shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a479ac1ba66150f457dfcfb3c03073ce4ece9b05" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;$listeners&lt;/code&gt; property, you can forward all event listeners on the component to a specific child element with &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt;. For elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, that you also want to work with &lt;code&gt;v-model&lt;/code&gt;, it&amp;rsquo;s often useful to create a new computed property for listeners, like &lt;code&gt;inputListeners&lt;/code&gt; below:</source>
          <target state="translated">&lt;code&gt;$listeners&lt;/code&gt; 속성을 사용하면 &lt;code&gt;v-on=&quot;$listeners&quot;&lt;/code&gt; 를 사용하여 구성 요소의 모든 이벤트 리스너를 특정 자식 요소로 전달할 수 있습니다. &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 과 같은 요소 의 경우 &lt;code&gt;v-model&lt;/code&gt; 로도 작업하려는 경우 아래 &lt;code&gt;inputListeners&lt;/code&gt; 와 같이 리스너에 대해 새로운 계산 속성을 만드는 것이 종종 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="a02a4af8d1e455a687fdc66fdceb59a54e15b8f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, which is responsible for rendering out the appropriate heading (i.e., &lt;code&gt;h1&lt;/code&gt;, &lt;code&gt;h2&lt;/code&gt;, &lt;code&gt;h3&lt;/code&gt;, etc.), this could have been written as a single-file component in 2.x as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c482d5a66a3ed1e5cc31f6c18a950ad5c8ab15d8" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; described &lt;a href=&quot;#Other-Examples&quot;&gt;here&lt;/a&gt; as an example, here&amp;rsquo;s the equivalent usage using &lt;code&gt;slot-scope&lt;/code&gt;:</source>
          <target state="translated">은 Using &lt;code&gt;&amp;lt;todo-list&amp;gt;&lt;/code&gt; 설명 &lt;a href=&quot;#Other-Examples&quot;&gt;여기&lt;/a&gt; 여기하여 등가의 사용, 예를 들어 &lt;code&gt;slot-scope&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f458b4647572808c3369e3942c8038e15c728d5b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;debounce&lt;/code&gt; attribute, there&amp;rsquo;d be no way to detect the &amp;ldquo;Typing&amp;rdquo; state, because we lose access to the input&amp;rsquo;s real-time state. By decoupling the debounce function from Vue however, we&amp;rsquo;re able to debounce only the operation we want to limit, removing the limits on features we can develop:</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 속성을 사용하면 입력의 실시간 상태에 액세스 할 수 없기 때문에 &quot;타이핑&quot;상태를 감지 할 방법이 없습니다. 그러나 Vue에서 디 바운스 기능을 분리하여 제한하려는 작업 만 디 바운싱 할 수 있으므로 개발할 수있는 기능에 대한 제한이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a87de46920f91d20c4a8374d7b0a5c7e603757dc" translate="yes" xml:space="preserve">
          <source>Using the example above, here is one example of how it could be implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3341dcb36ab8af8d89b35f44cc440d1a7d17430" translate="yes" xml:space="preserve">
          <source>Using the example above, there would only be one possible implementation of the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d5a2cbab66f55349694e4719943675255a69f1" translate="yes" xml:space="preserve">
          <source>Using the previously mentioned example of a &lt;code&gt;&amp;lt;dynamic-heading&amp;gt;&lt;/code&gt; component, here is how it looks now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55fb4e45a691d83cb89ad7b70f465e311afb55b" translate="yes" xml:space="preserve">
          <source>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</source>
          <target state="translated">이 전략을 사용하면 여러 입력 요소와 함께 Pikaday를 사용할 수 있으며 각각의 새 인스턴스가 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="420b1d24b2826ff84b27e5503c9d5fa275794cf8" translate="yes" xml:space="preserve">
          <source>Using with Composition API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7c2de355d1860ca4480d839a4fbef456709fc8" translate="yes" xml:space="preserve">
          <source>Using with Options API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1305a554f414402ea39d6c0eec337641f1f80daa" translate="yes" xml:space="preserve">
          <source>Using with Suspense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e76ca31176d1fccdd6bf8f9d90b0ddb005901f" translate="yes" xml:space="preserve">
          <source>Using with Vue components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceea66ab4211a7caa0a8bc0030f6869c29b5f77" translate="yes" xml:space="preserve">
          <source>Usually it is not recommended to visually hide labels, even if the input has an accessible name. However, if the functionality of the input can be understood with surrounding content, then we can hide the visual label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902c05ed61ffecdcb861a0a513fb2a3d4db8f937" translate="yes" xml:space="preserve">
          <source>Usually though, you&amp;rsquo;ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties&amp;rsquo; names and values contain the prop names and types, respectively:</source>
          <target state="translated">그러나 일반적으로 모든 소품이 특정 유형의 가치가되기를 원할 것입니다. 이 경우 소품을 객체로 나열 할 수 있습니다. 속성의 이름과 값에 각각 소품 이름과 유형이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2c03a1928d0df3b20ddcf6357f95f4926b46174c" translate="yes" xml:space="preserve">
          <source>Usually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f363e5aa689f12e08f65b4262f0add9ceb5a0b70" translate="yes" xml:space="preserve">
          <source>Usually, when we need to pass data from the parent to child component, we use &lt;a href=&quot;component-props&quot;&gt;props&lt;/a&gt;. Imagine the structure where you have some deeply nested components and you only need something from the parent component in the deep nested child. In this case, you still need to pass the prop down the whole component chain which might be annoying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1f04aa32791204e8959162d55c6a61602685fd" translate="yes" xml:space="preserve">
          <source>VNode Interface</source>
          <target state="translated">VNode 인터페이스</target>
        </trans-unit>
        <trans-unit id="d7fdca34045c394bdf9bbb0a0408e559b64e8a0a" translate="yes" xml:space="preserve">
          <source>VNode Props Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f99862e340a0893eee57fe6c2e3eeeed495dea2" translate="yes" xml:space="preserve">
          <source>VNodes Must Be Unique</source>
          <target state="translated">VNode는 고유해야합니다</target>
        </trans-unit>
        <trans-unit id="49ce46f211c09d9aa88ca4b4b3542fca5ed37ba1" translate="yes" xml:space="preserve">
          <source>VNodes now have a flat props structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084ea9ddae2c0ecd015b716116978e8325213232" translate="yes" xml:space="preserve">
          <source>Validate Emitted Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12f8ca6eecbf13923d4270c3d2e0dc247e9cf95" translate="yes" xml:space="preserve">
          <source>Value Bindings</source>
          <target state="translated">가치 바인딩</target>
        </trans-unit>
        <trans-unit id="942a2054dbdb4f692ee9d24cdf0ad9184052d0e9" translate="yes" xml:space="preserve">
          <source>Via CDN: &lt;code&gt;&amp;lt;script src=&quot;https://unpkg.com/vue@next&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32f685e7efba1be35060ac9fdaec19c6efdb60f" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-3/intro-to-vue3&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0753dc6ec65641eef8979902d3647c228f0b61" translate="yes" xml:space="preserve">
          <source>Video by &lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery&lt;/a&gt;. Watch Vue Mastery&amp;rsquo;s free &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Intro to Vue course&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.vuemastery.com&quot;&gt;Vue Mastery의&lt;/a&gt; 비디오 . Vue Mastery의 무료 &lt;a href=&quot;https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/&quot;&gt;Vue 소개 과정을&lt;/a&gt; 시청하십시오 .</target>
        </trans-unit>
        <trans-unit id="cab0d7e1c96c3ea19c16733af4fdea5420773df9" translate="yes" xml:space="preserve">
          <source>Virtual DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4ad933224c9c018075556e20e9443504c60df4" translate="yes" xml:space="preserve">
          <source>Visibility in headless mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97347f9404e482f1732d8abafe227157226e8e0e" translate="yes" xml:space="preserve">
          <source>Visitor &lt;em&gt;to the&lt;/em&gt; museum</source>
          <target state="translated">방문자 &lt;em&gt;받는&lt;/em&gt; 박물관</target>
        </trans-unit>
        <trans-unit id="47e69e75f6b5116df912c06bde68d77a66e8ffd9" translate="yes" xml:space="preserve">
          <source>Vite</source>
          <target state="translated">Vite</target>
        </trans-unit>
        <trans-unit id="3dee610647aa7d97b936e215cc6e8fa092669039" translate="yes" xml:space="preserve">
          <source>VoiceOver (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df144818169dcae305b2c6ce5856caa779bc88c2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-component&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1f3fe63ade848d4b754b1fabc84dc4fa1c76f2" translate="yes" xml:space="preserve">
          <source>Vue (pronounced /vjuː/, like &lt;strong&gt;view&lt;/strong&gt;) is a &lt;strong&gt;progressive framework&lt;/strong&gt; for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with &lt;a href=&quot;guide/single-file-components&quot;&gt;modern tooling&lt;/a&gt; and &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;supporting libraries&lt;/a&gt;.</source>
          <target state="translated">Vue ( &lt;strong&gt;view&lt;/strong&gt; 와 같이 / vjuː /로 발음 됨 )는 사용자 인터페이스를 구축하기위한 &lt;strong&gt;점진적인 프레임 워크&lt;/strong&gt; 입니다. 다른 모 놀리 식 프레임 워크와 달리 Vue는 처음부터 점차적으로 채택 할 수 있도록 설계되었습니다. 핵심 라이브러리는보기 계층에만 초점을 맞추고 다른 라이브러리 나 기존 프로젝트와 쉽게 통합하여 통합 할 수 있습니다. 반면에 Vue는 &lt;a href=&quot;guide/single-file-components&quot;&gt;최신 툴링&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/vuejs/awesome-vue#components--libraries&quot;&gt;지원 라이브러리&lt;/a&gt; 와 함께 사용될 때 정교한 단일 페이지 애플리케이션에 전력을 공급할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd79eece92c5ffe4c720051711e0f90d551d945b" translate="yes" xml:space="preserve">
          <source>Vue 2.x has a number of global APIs and configurations that globally mutate Vue&amp;rsquo;s behavior. For instance, to register a global component, you would use the &lt;code&gt;Vue.component&lt;/code&gt; API like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893d303c551ebb9fe5672e80454924e163f7fe29" translate="yes" xml:space="preserve">
          <source>Vue 3 now offers an &lt;code&gt;emits&lt;/code&gt; option, similar to the existing &lt;code&gt;props&lt;/code&gt; option. This option can be used to define the events that a component can emit to its parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7940d725dbd937d9de670c4768fc0ccd47788f" translate="yes" xml:space="preserve">
          <source>Vue CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e97d04ea2024c1a4dbe8d36669c3d0551d334b" translate="yes" xml:space="preserve">
          <source>Vue Devtools</source>
          <target state="translated">부 데브 툴</target>
        </trans-unit>
        <trans-unit id="9b4162890a260c6325ca0e85fd029f15d2319406" translate="yes" xml:space="preserve">
          <source>Vue Docs Writing Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf53a6c36521f7bfb85181c1e488fc3bdefe2160" translate="yes" xml:space="preserve">
          <source>Vue Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1581d8a5ef292e49547c61633956998a288fd6aa" translate="yes" xml:space="preserve">
          <source>Vue Router 4.0 provides Vue 3 support and has a number of breaking changes of its own. Check out its &lt;a href=&quot;https://next.router.vuejs.org/guide/migration/&quot;&gt;migration guide (opens new window)&lt;/a&gt; for full details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e18b7a4f3086a13d2a0b9179ebded28163c885" translate="yes" xml:space="preserve">
          <source>Vue Test Utils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d1880504f36bb5a94fba498a0a0cfb67577f83" translate="yes" xml:space="preserve">
          <source>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d701148514b6b1195422aa314e247a9c6ce4ed" translate="yes" xml:space="preserve">
          <source>Vue Testing Library (@testing-library/vue)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d00cb6f0b01ec3c037dd727f0b00f8ee2ebbd46" translate="yes" xml:space="preserve">
          <source>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859c56d5130177d3945e1dec6cc5a5f97ec3630" translate="yes" xml:space="preserve">
          <source>Vue accomplishes this by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="translated">Vue 는 실제 DOM에 필요한 변경 사항을 추적하기 위해 &lt;strong&gt;가상 DOM&lt;/strong&gt; 을 구축하여이를 달성합니다 . 이 라인을 자세히 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="3c67c991de8300834c38a25c1ca2498be450c64f" translate="yes" xml:space="preserve">
          <source>Vue also exposes some built-in properties via the component instance, such as &lt;code&gt;$attrs&lt;/code&gt; and &lt;code&gt;$emit&lt;/code&gt;. These properties all have a &lt;code&gt;$&lt;/code&gt; prefix to avoid conflicting with user-defined property names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125a9384e967ff4a8c66210cf14fc5911c587de4" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&amp;lsquo;s &lt;code&gt;passive&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">Vue는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;passive&lt;/code&gt; 옵션에 해당하는 &lt;code&gt;.passive&lt;/code&gt; 수정자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="adf689defceb2bc071b35560777fed6fba514f1f" translate="yes" xml:space="preserve">
          <source>Vue also offers the &lt;code&gt;.passive&lt;/code&gt; modifier, corresponding to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;'s &lt;code&gt;passive&lt;/code&gt; option (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605504cfd5ddde3ecc8c8b4f19e48e377a0c4f3d" translate="yes" xml:space="preserve">
          <source>Vue also provides the &lt;code&gt;v-model&lt;/code&gt; directive that makes two-way binding between form input and app state a breeze:</source>
          <target state="translated">Vue는 또한 양식 입력과 앱 상태를 양방향 바인딩 하는 &lt;code&gt;v-model&lt;/code&gt; 지시문을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="885b8f9999638cb0ba7b84d6b1e20f2e73c6af0f" translate="yes" xml:space="preserve">
          <source>Vue automatically binds the &lt;code&gt;this&lt;/code&gt; value for &lt;code&gt;methods&lt;/code&gt; so that it always refers to the component instance. This ensures that a method retains the correct &lt;code&gt;this&lt;/code&gt; value if it's used as an event listener or callback. You should avoid using arrow functions when defining &lt;code&gt;methods&lt;/code&gt;, as that prevents Vue from binding the appropriate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca242d2d873eee02c1c2067409c6aa7de3fbf37" translate="yes" xml:space="preserve">
          <source>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</source>
          <target state="translated">Vue가 도울 수 있습니다. SVG는 데이터 일 뿐이므로 흥분하거나 생각하거나 놀라 울 때이 생물이 어떻게 보이는지에 대한 예만 있으면됩니다. 그러면 Vue는 이러한 상태 간 전환을 도와 주어 환영 페이지,로드 표시기 및 알림을보다 정서적으로 매력적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f789efe555358e086dec2286a04d16497d60bbf4" translate="yes" xml:space="preserve">
          <source>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the &lt;code&gt;data&lt;/code&gt; object in order for Vue to convert it and make it reactive. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76acf301d7c1d195a8e6c80016f7abf03185310" translate="yes" xml:space="preserve">
          <source>Vue cannot detect the following changes to an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c6af4e3cef9103ebba7535117ed1fc9a70968ce" translate="yes" xml:space="preserve">
          <source>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</source>
          <target state="translated">Vue 구성 요소는 일반 사용자 지정 요소, 특히 교차 구성 요소 데이터 흐름, 사용자 지정 이벤트 통신 및 빌드 도구 통합에서는 사용할 수없는 중요한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37147a4b37600d215ff72836bc22ae45766e8aaf" translate="yes" xml:space="preserve">
          <source>Vue does &lt;strong&gt;not&lt;/strong&gt; support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 compliant browsers&lt;/a&gt;.</source>
          <target state="translated">Vue는 IE8에서 지원 되지 &lt;strong&gt;않는&lt;/strong&gt; ECMAScript 5 기능을 사용하므로 IE8 이하를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 그러나 모든 &lt;a href=&quot;https://caniuse.com/#feat=es5&quot;&gt;ECMAScript 5 호환 브라우저를 지원합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcde1702db5cf00f14ae819af084b9d5e13e847d" translate="yes" xml:space="preserve">
          <source>Vue does a runtime validation on props with a &lt;code&gt;type&lt;/code&gt; defined. To provide these types to TypeScript, we need to cast the constructor with &lt;code&gt;PropType&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9644530939c86150587d7763eb986ef8509e60fe" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method. For example, given:</source>
          <target state="translated">Vue에서는 이미 생성 된 인스턴스에 새로운 루트 수준 반응 속성을 동적으로 추가 할 수 없습니다. 그러나 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 메서드를 사용하여 중첩 속성에 반응 속성을 추가 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae4e619e0432f9df163ef8635c7eaee1ab68c9d" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it&amp;rsquo;s possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="translated">Vue에서는 이미 생성 된 인스턴스에 새로운 루트 수준 반응 속성을 동적으로 추가 할 수 없습니다. 그러나 &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; 메소드를 사용하여 중첩 된 오브젝트에 반응 특성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="343af74f45c6d504ae330328dd8b0a9201ec2a40" translate="yes" xml:space="preserve">
          <source>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the &lt;code&gt;Vue.set(object, propertyName, value)&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19e40c5aefab10a48d600828d78fdd34132f866" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a Vue instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="translated">Vue는 Vue 인스턴스의 데이터 변경 사항을 관찰하고 이에 대응하는보다 일반적인 방법 인 &lt;strong&gt;watch properties를 제공&lt;/strong&gt; 합니다. 다른 데이터를 기반으로 변경해야하는 데이터가있는 경우 특히 AngularJS 배경에서 오는 경우 &lt;code&gt;watch&lt;/code&gt; 를 과도하게 사용 하려는 경향이 있습니다. 그러나 명령형 &lt;code&gt;watch&lt;/code&gt; 콜백 보다는 계산 된 속성을 사용하는 것이 좋습니다 . 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c5264d84d3913aaee37aae0efaf21239b2f1ce3b" translate="yes" xml:space="preserve">
          <source>Vue does provide a more generic way to observe and react to data changes on a current active instance: &lt;strong&gt;watch properties&lt;/strong&gt;. When you have some data that needs to change based on some other data, it is tempting to overuse &lt;code&gt;watch&lt;/code&gt; - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative &lt;code&gt;watch&lt;/code&gt; callback. Consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa20ee25a985c5ea6e1e0de59eb8059a57dc11b9" translate="yes" xml:space="preserve">
          <source>Vue doesn&amp;rsquo;t suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</source>
          <target state="translated">Vue는 비동기 대기열과 함께 투명한 의존성 추적 관찰 시스템을 사용하기 때문에 전혀 고통받지 않습니다. 명백한 의존성 관계가 없으면 모든 변경 사항이 독립적으로 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2be91f79d826fa58f7ebe4ed4e0d032247230c" translate="yes" xml:space="preserve">
          <source>Vue doesn't include built-in support for debouncing or throttling but it can be implemented using libraries such as &lt;a href=&quot;https://lodash.com/&quot;&gt;Lodash (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cec1602b0b81b69b55e68ee2a3e76a167245823" translate="yes" xml:space="preserve">
          <source>Vue embraces classic web technologies and builds on top of them. To show you what that means, we&amp;rsquo;ll dive into some examples.</source>
          <target state="translated">Vue는 고전적인 웹 기술을 수용하고 그 위에 구축합니다. 그 의미를 보여주기 위해 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a951ea402d433567bd65b048725a50d77f19283f" translate="yes" xml:space="preserve">
          <source>Vue encourages us to build our UIs by encapsulating UI and related behavior into components. We can nest them inside one another to build a tree that makes up an application UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4d5a5737de32d531811b293a6b6c8f4dd6038d" translate="yes" xml:space="preserve">
          <source>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</source>
          <target state="translated">Vue는 지시문과 구성 요소를 명확하게 구분합니다. 지시문은 DOM 조작 만 캡슐화하기위한 것이며 구성 요소는 자체보기 및 데이터 논리가있는 독립적 인 단위입니다. AngularJS에서 지시문은 모든 것을 수행하며 구성 요소는 특정 유형의 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="5f5b28822c7ba305194d65c64adf4bcfa7d893d3" translate="yes" xml:space="preserve">
          <source>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;actively-maintained translations&lt;/a&gt;. We&amp;rsquo;re very proud of Vue&amp;rsquo;s international reach, but we can do even better.</source>
          <target state="translated">Vue는 이미 전 세계에 퍼져 있으며 핵심 팀조차도 최소한 6 개 이상의 시간대로 있습니다. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;포럼&lt;/a&gt; 에는 7 개 언어와 계산이 포함되어 있으며 많은 문서가 &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;query=vuejs.org&quot;&gt;활발하게 유지 관리되는 번역이&lt;/a&gt; 있습니다. 우리는 Vue의 국제적인 접근을 매우 자랑스럽게 생각하지만 더 잘할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="881974d376493ccbbdc99809953ca1768f35401b" translate="yes" xml:space="preserve">
          <source>Vue has better performance and is much, much easier to optimize because it doesn&amp;rsquo;t use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &amp;ldquo;stabilize&amp;rdquo; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there&amp;rsquo;s no way to optimize a scope with many watchers.</source>
          <target state="translated">Vue는 성능이 더 좋고 더티 검사를 사용하지 않기 때문에 최적화하기가 훨씬 쉽습니다. 범위에있는 항목이 변경 될 때마다 이러한 모든 감시자를 다시 평가해야하기 때문에 감시자가 많은 경우 AngularJS가 느려집니다. 또한 일부 감시자가 다른 업데이트를 트리거하는 경우 다이제스트주기를 여러 번 실행하여 &quot;안정화&quot;해야 할 수도 있습니다. AngularJS 사용자는 종종 다이제스트주기를 극복하기 위해 난해한 기술에 의존해야하며 경우에 따라 많은 감시자와 함께 범위를 최적화 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2605f10b94203eb3d7c6121d24fd706b16d41799" translate="yes" xml:space="preserve">
          <source>Vue has spread across the globe, with the core team being in at least half a dozen different timezones. &lt;a href=&quot;https://forum.vuejs.org/&quot;&gt;The forum (opens new window)&lt;/a&gt; includes 7 languages and counting and many of our docs have &lt;a href=&quot;https://github.com/vuejs?utf8=%E2%9C%93&amp;amp;q=vuejs.org&quot;&gt;actively-maintained translations (opens new window)&lt;/a&gt;. We're very proud of Vue's international reach, but we can do even better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c550aa4342c74e83ae493691c6ae0befcbbd2d7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft (opens new window)&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e39e9d5c8a76f6f5db130e65186a24c2ad2a7" translate="yes" xml:space="preserve">
          <source>Vue implements a content distribution API inspired by the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components spec draft&lt;/a&gt;, using the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; element to serve as distribution outlets for content.</source>
          <target state="translated">Vue 는 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소를 사용하여 컨텐츠의 배포 아울렛 역할을 하는 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Web Components 스펙 초안&lt;/a&gt; 에서 영감을 얻은 컨텐츠 분배 API를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3a793e8d661b43bbe34ed4b73bb734bc567f99e0" translate="yes" xml:space="preserve">
          <source>Vue internally tracks all objects that have been made reactive, so it always returns the same proxy for the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cc26bda089d22ee9d524a03dbd85e42bb4830f" translate="yes" xml:space="preserve">
          <source>Vue is also available on &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; and &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnjs&lt;/a&gt; (cdnjs takes some time to sync so the latest release may not be available yet).</source>
          <target state="translated">Vue는 &lt;a href=&quot;https://unpkg.com/vue@2.6.10/dist/vue.js&quot;&gt;unpkg&lt;/a&gt; 및 &lt;a href=&quot;https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js&quot;&gt;cdnj&lt;/a&gt; 에서도 사용할 수 있습니다 (cdnj는 동기화하는 데 시간이 걸리므로 최신 릴리스를 아직 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="10ee466f89c6e492df9449492b2c0cad1124cbd6" translate="yes" xml:space="preserve">
          <source>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</source>
          <target state="translated">Vue는 Angular보다 의견이 많지 않으므로 응용 프로그램을 구성하는 방법에 대한 제한없이 다양한 빌드 시스템에 대한 공식 지원을 제공합니다. 많은 개발자들이 이러한 자유를 누리고 있지만, 어떤 개발자는 단 하나의 올바른 방법으로 응용 프로그램을 빌드하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="5f16a9a3da3c8339a4180458be820db747efab17" translate="yes" xml:space="preserve">
          <source>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</source>
          <target state="translated">Vue는 API 및 디자인 측면에서 AngularJS보다 훨씬 간단합니다. 사소한 응용 프로그램을 작성하기에 충분한 학습은 일반적으로 하루 미만이 소요되며 AngularJS에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cffec81f79bb5fd465edfb05ca6c6a20e73cd65d" translate="yes" xml:space="preserve">
          <source>Vue keeps the page updated by building a &lt;strong&gt;virtual DOM&lt;/strong&gt; to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65cd273e5f6ab6e9dff779a723ce1ab6e016a34" translate="yes" xml:space="preserve">
          <source>Vue needs to attach event listeners in order to know when a transition has ended. It can either be &lt;code&gt;transitionend&lt;/code&gt; or &lt;code&gt;animationend&lt;/code&gt;, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</source>
          <target state="translated">Vue는 전환이 언제 종료되었는지 알기 위해 이벤트 리스너를 연결해야합니다. 적용된 CSS 규칙의 유형에 따라 &lt;code&gt;transitionend&lt;/code&gt; 또는 &lt;code&gt;animationend&lt;/code&gt; 일 수 있습니다 . 둘 중 하나만 사용하는 경우 Vue는 자동으로 올바른 유형을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365212719322a63f4e306455d5f27b8a3966dc5d" translate="yes" xml:space="preserve">
          <source>Vue offers some abstractions that can help work with transitions and animations, particularly in response to something changing. Some of these abstractions include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abff090748f024b1aa003637a4b72dd4dc06e5f" translate="yes" xml:space="preserve">
          <source>Vue projects can quickly be set up with Vite by running the following commands in your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ecd2fd20f1617fec18255c802e4165961e34ff8" translate="yes" xml:space="preserve">
          <source>Vue provides a &lt;code&gt;transition&lt;/code&gt; wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</source>
          <target state="translated">Vue는 다음 컨텍스트에서 요소 또는 구성 요소에 대한 입력 / 이동 전환을 추가 할 수 있는 &lt;code&gt;transition&lt;/code&gt; 래퍼 구성 요소를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="90f6435d17defefabfdaefdbf0248c547a6baa43" translate="yes" xml:space="preserve">
          <source>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</source>
          <target state="translated">Vue는 항목이 DOM에서 삽입, 업데이트 또는 제거 될 때 전환 효과를 적용하는 다양한 방법을 제공합니다. 여기에는 다음과 같은 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c875e25ec6e673bd0fa4b43fbaf93eb5a80089d3" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</source>
          <target state="translated">Vue는 레거시 브라우저 지원에 필요할 때 가장 일반적으로 사용되는 키 코드에 대한 별칭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c90e634ab0c74f1d079a1c75ea53bce697797633" translate="yes" xml:space="preserve">
          <source>Vue provides aliases for the most commonly used keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a311fa8fbae830ba1eadba1b420d03469cdf2806" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI (opens new window)&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs (opens new window)&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a7e9def36f28bbd974e54d04ac78901b82dde6" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;official CLI&lt;/a&gt; for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;the Vue CLI docs&lt;/a&gt; for more details.</source>
          <target state="translated">Vue는 야심 찬 단일 페이지 응용 프로그램을 빠르게 비계하기위한 &lt;a href=&quot;https://github.com/vuejs/vue-cli&quot;&gt;공식 CLI&lt;/a&gt; 를 제공합니다 . 최신 프론트 엔드 워크 플로우를 위해 배터리가 포함 된 빌드 설정을 제공합니다. 핫 리로드, 린트 온 저장 및 프로덕션 준비 빌드로 시작하고 실행하는 데 몇 분 밖에 걸리지 않습니다. 자세한 내용 &lt;a href=&quot;https://cli.vuejs.org&quot;&gt;은 Vue CLI 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="198884e2076bf367c22dbd13bc52339d681396a7" translate="yes" xml:space="preserve">
          <source>Vue provides an &lt;code&gt;InjectionKey&lt;/code&gt; interface which is a generic type that extends &lt;code&gt;Symbol&lt;/code&gt;. It can be used to sync the type of the injected value between the provider and the consumer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d1ad276c1e9b0a434e314eacca760e6163db38" translate="yes" xml:space="preserve">
          <source>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</source>
          <target state="translated">Vue는 일반 JavaScript 객체 및 완전 자동 계산 속성에 대한 눈에 띄지 않는 반응성을 제공합니다. Ember에서는 Ember Objects의 모든 것을 감싸고 계산 된 속성에 대한 종속성을 수동으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a53f20609320f4a24cb94f7b4da549347f4bbbd" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build applications in the vast majority of cases. However, there are situations where we need the full programmatic power of JavaScript. That's where we can use the &lt;strong&gt;render function&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7346ec062ad9807eec320c99bd8abe0bacd7643f" translate="yes" xml:space="preserve">
          <source>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That&amp;rsquo;s where you can use the &lt;strong&gt;render function&lt;/strong&gt;, a closer-to-the-compiler alternative to templates.</source>
          <target state="translated">Vue는 템플릿을 사용하여 대부분의 경우 HTML을 빌드 할 것을 권장합니다. 그러나 JavaScript의 전체 프로그래밍 기능이 실제로 필요한 상황이 있습니다. 여기서는 템플릿 대신 컴파일러에 더 가까운 &lt;strong&gt;render 함수&lt;/strong&gt; 인 &lt;strong&gt;render 함수를&lt;/strong&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8156b77f1cb02753b763c4feb44d817ea36bfdc0" translate="yes" xml:space="preserve">
          <source>Vue should not be bundled into the library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b71c188d7cf41c5602a8754468c8e9d993c9edd" translate="yes" xml:space="preserve">
          <source>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</source>
          <target state="translated">Vue는 가능한 한 효율적으로 요소를 렌더링하려고 시도하며 종종 처음부터 렌더링하는 대신 요소를 재사용합니다. Vue를 매우 빠르게 만드는 것 외에도 유용한 이점이 있습니다. 예를 들어, 사용자가 여러 로그인 유형간에 전환 할 수 있도록 허용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1bfea290ac9ffe33c850d1b0a939949cd7dfe376" translate="yes" xml:space="preserve">
          <source>Vue uses a &lt;code&gt;$&lt;/code&gt; prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix &lt;code&gt;_&lt;/code&gt; for internal properties. You should avoid using names for top-level &lt;code&gt;data&lt;/code&gt; properties that start with either of these characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444100368a15ace2e6288fb295611b81775b2a56" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won&amp;rsquo;t arise in a later version.</source>
          <target state="translated">Vue는 &lt;code&gt;_&lt;/code&gt; 접두사를 사용하여 자체 개인 속성을 정의하므로 동일한 접두사 (예 : &lt;code&gt;_update&lt;/code&gt; )를 사용하면 인스턴스 속성을 덮어 쓸 위험이 있습니다. Vue가 현재 특정 속성 이름을 사용하고 있지 않은지 확인하더라도 이후 버전에서는 충돌이 발생하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="85dd560a9154cd8cc040ca30f4c194c517655b32" translate="yes" xml:space="preserve">
          <source>Vue uses the &lt;code&gt;_&lt;/code&gt; prefix to define its own private properties, so using the same prefix (e.g. &lt;code&gt;_update&lt;/code&gt;) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984f76b6b17c9c7750c863470482e24ce27debcc" translate="yes" xml:space="preserve">
          <source>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</source>
          <target state="translated">Vue는 대상 요소에 CSS 전환 또는 애니메이션이 적용되었는지 여부를 자동으로 스니핑합니다. 그렇다면 CSS 전환 클래스가 적절한 타이밍에 추가 / 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3622b63c9271442caba43d7cdf8ec076797d3e" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array&amp;rsquo;s mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="translated">Vue는 관찰 된 배열의 돌연변이 방법을 래핑하여 뷰 업데이트도 트리거합니다. 랩핑 된 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="052994ca379981542bf778170c739a04a769c1d8" translate="yes" xml:space="preserve">
          <source>Vue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e1fa19cf5758f9db9d0f3677b23685acc53107" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s community is growing incredibly fast and if you&amp;rsquo;re reading this, there&amp;rsquo;s a good chance you&amp;rsquo;re ready to join it. So&amp;hellip; welcome!</source>
          <target state="translated">Vue의 커뮤니티는 엄청나게 빠르게 성장하고 있습니다.이 글을 읽고 있다면 참여할 준비가 된 것입니다. 환영합니다!</target>
        </trans-unit>
        <trans-unit id="322e869fcc97102e7e016c8418cdb3094a9f4241" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s template syntax harnesses the full power of JavaScript expressions, while Handlebars&amp;rsquo; expression and helper syntax is intentionally quite limited in comparison.</source>
          <target state="translated">Vue의 템플릿 구문은 JavaScript 표현식의 모든 기능을 활용하는 반면, Handlebars의 표현식 및 도우미 구문은 의도적으로 상당히 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="624a0a9a36cd9f9702aa8d1741b7285770304340" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system has changed quite drastically and now uses &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; wrapper elements, rather than the &lt;code&gt;transition&lt;/code&gt; attribute. It&amp;rsquo;s recommended to read the new &lt;a href=&quot;transitions&quot;&gt;Transitions guide&lt;/a&gt; to learn more.</source>
          <target state="translated">Vue의 전이 시스템은 상당히 급격히 바뀌 었으며 이제 &lt;code&gt;transition&lt;/code&gt; 속성 대신 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;transition-group&amp;gt;&lt;/code&gt; 래퍼 요소를 사용 합니다. 자세한 내용 은 새로운 &lt;a href=&quot;transitions&quot;&gt;전환 가이드&lt;/a&gt; 를 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="76757ff90e72da993b6b789516932e1e47009d9a" translate="yes" xml:space="preserve">
          <source>Vue&amp;rsquo;s transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="translated">Vue의 전환 시스템은 입력, 출발 및 목록에 애니메이션을 적용하는 여러 가지 간단한 방법을 제공하지만 데이터 자체에 애니메이션을 적용하는 방법은 무엇입니까? 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b31ca06d3a5f393764ec4e9c8ef653d752ddc802" translate="yes" xml:space="preserve">
          <source>Vue's reactivity system buffers invalidated effects and flushes them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same &quot;tick&quot;. Internally, a component's &lt;code&gt;update&lt;/code&gt; function is also a watched effect. When a user effect is queued, it is by default invoked &lt;strong&gt;before&lt;/strong&gt; all component &lt;code&gt;update&lt;/code&gt; effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a97b271690906d44d32706aa7062d75c719e21d" translate="yes" xml:space="preserve">
          <source>Vue's transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49720efe6c6aa6c85c1ae9a211e82f72036b89c2" translate="yes" xml:space="preserve">
          <source>Vue's usage of the &lt;code&gt;is&lt;/code&gt; special prop was simulating what the native attribute does before it was made universally available in browsers. However, in 2.x it was interpreted as rendering a Vue component with the name &lt;code&gt;plastic-button&lt;/code&gt;. This blocks the native usage of Customized Built-in Element mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747f5a69bf5b0a247d5063d8cba744d0c67792fc" translate="yes" xml:space="preserve">
          <source>Vue.compile( template )</source>
          <target state="translated">Vue.compile (템플릿)</target>
        </trans-unit>
        <trans-unit id="006274a914f30334bdd61869c339c9cc2f697c2f" translate="yes" xml:space="preserve">
          <source>Vue.compile()</source>
          <target state="translated">Vue.compile()</target>
        </trans-unit>
        <trans-unit id="b7ea66a12347f6ffc2b94442e80c35d15d597413" translate="yes" xml:space="preserve">
          <source>Vue.component</source>
          <target state="translated">Vue.component</target>
        </trans-unit>
        <trans-unit id="5ce4d7fb595d7cb94a3d2b693db1f767216e55af" translate="yes" xml:space="preserve">
          <source>Vue.component( id, [definition] )</source>
          <target state="translated">Vue.component (id, [definition])</target>
        </trans-unit>
        <trans-unit id="e8c7a1fb76f08ecda2c23ba8eb798c4d21544eec" translate="yes" xml:space="preserve">
          <source>Vue.component()</source>
          <target state="translated">Vue.component()</target>
        </trans-unit>
        <trans-unit id="fa7c2ad2da40c783fe07fb4836f3bda4a2b8cf11" translate="yes" xml:space="preserve">
          <source>Vue.config</source>
          <target state="translated">Vue.config</target>
        </trans-unit>
        <trans-unit id="fbf8d19b7eb0ae647266f2c96abf99945277ea9e" translate="yes" xml:space="preserve">
          <source>Vue.config.ignoredElements</source>
          <target state="translated">Vue.config.ignoredElements</target>
        </trans-unit>
        <trans-unit id="5b4f8634a75bc7bfd88be1dd891c9ea29cfa97f5" translate="yes" xml:space="preserve">
          <source>Vue.config.productionTip</source>
          <target state="translated">Vue.config.productionTip</target>
        </trans-unit>
        <trans-unit id="12cb69d1f5d780a9746d6267306c64b64405fa4c" translate="yes" xml:space="preserve">
          <source>Vue.delete( target, propertyName/index )</source>
          <target state="translated">Vue.delete (target, propertyName / index)</target>
        </trans-unit>
        <trans-unit id="68d21641f735f542e8f7c3a7ea648aa0c4e35779" translate="yes" xml:space="preserve">
          <source>Vue.delete()</source>
          <target state="translated">Vue.delete()</target>
        </trans-unit>
        <trans-unit id="580b85815fc398d542e95ec7b5e861e1e012763f" translate="yes" xml:space="preserve">
          <source>Vue.directive</source>
          <target state="translated">Vue.directive</target>
        </trans-unit>
        <trans-unit id="c32347439fe04c6336437069efe2d91df26659e1" translate="yes" xml:space="preserve">
          <source>Vue.directive( id, [definition] )</source>
          <target state="translated">Vue.directive (id, [definition])</target>
        </trans-unit>
        <trans-unit id="b59efa9215d110ba12928742d620af77e6a759f2" translate="yes" xml:space="preserve">
          <source>Vue.directive()</source>
          <target state="translated">Vue.directive()</target>
        </trans-unit>
        <trans-unit id="975e10259e8ed9d0d727102a1cd5cc4b93d7a650" translate="yes" xml:space="preserve">
          <source>Vue.extend( options )</source>
          <target state="translated">Vue.extend (옵션)</target>
        </trans-unit>
        <trans-unit id="1c725e9693b45558981c599b39d3fda6642f8d5b" translate="yes" xml:space="preserve">
          <source>Vue.extend()</source>
          <target state="translated">Vue.extend()</target>
        </trans-unit>
        <trans-unit id="675dca7e9f347b0a088b36a4d1b36ae828e38f75" translate="yes" xml:space="preserve">
          <source>Vue.filter( id, [definition] )</source>
          <target state="translated">Vue.filter (id, [definition])</target>
        </trans-unit>
        <trans-unit id="23a90de397a54f20910cfb3bd88027e09054324b" translate="yes" xml:space="preserve">
          <source>Vue.filter()</source>
          <target state="translated">Vue.filter()</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="fd45ecca01e877661425a659bd70e10fa2aaa543" translate="yes" xml:space="preserve">
          <source>Vue.js API</source>
          <target state="translated">Vue.js API</target>
        </trans-unit>
        <trans-unit id="aad801d0cb83bef6f7c5626839ce4549782c00f2" translate="yes" xml:space="preserve">
          <source>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: &lt;strong&gt;mustache interpolations and &lt;code&gt;v-bind&lt;/code&gt; expressions&lt;/strong&gt; (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &amp;ldquo;pipe&amp;rdquo; symbol:</source>
          <target state="translated">Vue.js를 사용하면 일반적인 텍스트 형식을 적용하는 데 사용할 수있는 필터를 정의 할 수 있습니다. 필터는 &lt;strong&gt;콧수염 보간과 &lt;code&gt;v-bind&lt;/code&gt; 표현식&lt;/strong&gt; (후자는 2.1.0 이상에서 지원됨)의 두 위치에서 사용할 수 있습니다. &quot;파이프&quot;기호로 표시되는 JavaScript 표현식의 끝에 필터를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9050802f5567e26ffa96732c93096ee9dcffa91f" translate="yes" xml:space="preserve">
          <source>Vue.js is built by design to be incrementally adoptable. This means that it can be integrated into a project multiple ways depending on the requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b0bd3a6d7b1cc4cde0ebb1b1ce9add80d460a8" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance&amp;rsquo;s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="translated">Vue.js는 렌더링 된 DOM을 기본 Vue 인스턴스의 데이터에 선언적으로 바인딩 할 수있는 HTML 기반 템플릿 구문을 사용합니다. 모든 Vue.js 템플릿은 사양을 준수하는 브라우저와 HTML 파서로 파싱 할 수있는 유효한 HTML입니다.</target>
        </trans-unit>
        <trans-unit id="89a8a92dc46a36b0e2b8305728a1f8aaf8a88b78" translate="yes" xml:space="preserve">
          <source>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying component instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42311314f611dc7df4fd1777e98448bb4c96ecdb" translate="yes" xml:space="preserve">
          <source>Vue.mixin</source>
          <target state="translated">Vue.mixin</target>
        </trans-unit>
        <trans-unit id="e602f02f3f51d5822ae83f16f43c6d8d79e67534" translate="yes" xml:space="preserve">
          <source>Vue.mixin( mixin )</source>
          <target state="translated">Vue.mixin (믹스 인)</target>
        </trans-unit>
        <trans-unit id="4e4d009b2737b0f51ebf1e738443ba7ede850af2" translate="yes" xml:space="preserve">
          <source>Vue.mixin()</source>
          <target state="translated">Vue.mixin()</target>
        </trans-unit>
        <trans-unit id="5c9a730edbafdfc1ce8565e66bb8641c7e1ed1de" translate="yes" xml:space="preserve">
          <source>Vue.nextTick</source>
          <target state="translated">Vue.nextTick</target>
        </trans-unit>
        <trans-unit id="143fba6c6a7c26c9258fd60cbadd2d844001d109" translate="yes" xml:space="preserve">
          <source>Vue.nextTick( [callback, context] )</source>
          <target state="translated">Vue.nextTick ([콜백, 컨텍스트])</target>
        </trans-unit>
        <trans-unit id="6fbce1a433934248bd340ceb4888036ac364ba2b" translate="yes" xml:space="preserve">
          <source>Vue.nextTick()</source>
          <target state="translated">Vue.nextTick()</target>
        </trans-unit>
        <trans-unit id="32a54ad5f6f9d484aaf21effb1fa3702f7e1d680" translate="yes" xml:space="preserve">
          <source>Vue.observable( object )</source>
          <target state="translated">Vue.observable (객체)</target>
        </trans-unit>
        <trans-unit id="f422890fec57dc45446350cf215180b740a4422a" translate="yes" xml:space="preserve">
          <source>Vue.observable()</source>
          <target state="translated">Vue.observable()</target>
        </trans-unit>
        <trans-unit id="7ea3574e637178c673386a1b01019ea3760cf139" translate="yes" xml:space="preserve">
          <source>Vue.prototype</source>
          <target state="translated">Vue.prototype</target>
        </trans-unit>
        <trans-unit id="c438f73a1c59e3aa3df076ac89cf95e937f458a9" translate="yes" xml:space="preserve">
          <source>Vue.set( target, propertyName/index, value )</source>
          <target state="translated">Vue.set (target, propertyName / 인덱스, 값)</target>
        </trans-unit>
        <trans-unit id="e8107a8261cab4790e710bac13da561d42e5a9f6" translate="yes" xml:space="preserve">
          <source>Vue.set()</source>
          <target state="translated">Vue.set()</target>
        </trans-unit>
        <trans-unit id="5a623310c41e9f9c01feb186a71709087e21e7da" translate="yes" xml:space="preserve">
          <source>Vue.use</source>
          <target state="translated">Vue.use</target>
        </trans-unit>
        <trans-unit id="4e2c5dd87fde81c317ac0bd9c0ff7bbb87f3c89e" translate="yes" xml:space="preserve">
          <source>Vue.use( plugin )</source>
          <target state="translated">Vue.use (플러그인)</target>
        </trans-unit>
        <trans-unit id="f39db1673387c15674c362f9c69fa81a648b0ccf" translate="yes" xml:space="preserve">
          <source>Vue.use()</source>
          <target state="translated">Vue.use()</target>
        </trans-unit>
        <trans-unit id="a17ed02515b1156a989c141f6f9f251c40827a7a" translate="yes" xml:space="preserve">
          <source>Vue.version</source>
          <target state="translated">Vue.version</target>
        </trans-unit>
        <trans-unit id="58df3887d367d6a05cae0279723a97a86100bfeb" translate="yes" xml:space="preserve">
          <source>VuePress provides a custom container plugin to create alert boxes. There are four types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fde70f98c4cbf6a7b48ee19696e129152a7fb55" translate="yes" xml:space="preserve">
          <source>VuePress uses Prism to provide language syntax highlighting by appending the language to the beginning backticks of a code block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0b33121be26507e3433bd94203e17aa9b5f222" translate="yes" xml:space="preserve">
          <source>Vuex</source>
          <target state="translated">Vuex</target>
        </trans-unit>
        <trans-unit id="9c6ca3eb223f49942f07259d47688ad89f9e86ad" translate="yes" xml:space="preserve">
          <source>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What&amp;rsquo;s going on? Which one should I use and what&amp;rsquo;s compatible with Vue 2.0?</source>
          <target state="translated">Vuex 2.0이 출시되었지만이 안내서는 1.0으로의 마이그레이션에만 적용됩니다. 오타입니까? 또한 Vuex 1.0과 2.0이 동시에 출시 된 것 같습니다. 무슨 일이야? 어떤 것을 사용해야하고 Vue 2.0과 호환되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c8b618e05a2594cc2596f0d284d48d16432c525a" translate="yes" xml:space="preserve">
          <source>Vuex 4.0 provides Vue 3 support with largely the same API as 3.x. The only breaking change is &lt;a href=&quot;https://next.vuex.vuejs.org/guide/migrating-to-4-0-from-3-x.html#breaking-changes&quot;&gt;how the plugin is installed (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd40be6d96cb39a60cc6c39b8ea11e9937c18f8" translate="yes" xml:space="preserve">
          <source>Vuex is the &lt;a href=&quot;../guide/state-management#official-flux-like-implementation&quot;&gt;official flux-like implementation&lt;/a&gt; for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full &lt;a href=&quot;../guide/installation#vue-devtools&quot;&gt;Vue DevTools&lt;/a&gt; support).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d11819e7a1d9589b690ec06234450093f24c627" translate="yes" xml:space="preserve">
          <source>W3C's WAI-ARIA provides guidance on how to build dynamic content and advanced user interface controls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066e0172350e0754c39de0933398067fbaebdf66" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices 1.2 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45649ea79803ea52f28827ee4e547e4085b9b0c5" translate="yes" xml:space="preserve">
          <source>WAVE (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43059526c7805cadcc812c12f2c0f217edb0caf4" translate="yes" xml:space="preserve">
          <source>WCAG 2.0 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7254fa8467e45dc2111643677937dc826c7381" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bd5df2f8313fd0f66a6834ec679fec70aa231e" translate="yes" xml:space="preserve">
          <source>WCAG 2.1 Four Main Guiding Principles (abbreviated as POUR):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f3911027dbf5f81418e3868022034d4fbc381c" translate="yes" xml:space="preserve">
          <source>Watch a free lesson on Vue School</source>
          <target state="translated">Vue School에서 무료 강의를 시청하십시오</target>
        </trans-unit>
        <trans-unit id="62e0a695e7ccab369a0f49419284d104f98c2575" translate="yes" xml:space="preserve">
          <source>Watch a free video about Lifecycle Hooks on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e7187cdc04cab3317a2d6229024de7b88422b" translate="yes" xml:space="preserve">
          <source>Watch a free video about the Composition API on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3535c94715b644deaedbebce90d9555f3e89e9a6" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue Mastery</source>
          <target state="translated">Vue Mastery에서 무료 비디오 코스 시청</target>
        </trans-unit>
        <trans-unit id="3cd344bfc05810ff25f79ac8b462005767e2c6fd" translate="yes" xml:space="preserve">
          <source>Watch a free video course on Vue School</source>
          <target state="translated">Vue School에서 무료 비디오 코스 시청</target>
        </trans-unit>
        <trans-unit id="2f1efcb17036784de8e540836ed981009aebdfb3" translate="yes" xml:space="preserve">
          <source>Watch a free video lesson on Vue School</source>
          <target state="translated">Vue School에서 무료 비디오 강의 시청</target>
        </trans-unit>
        <trans-unit id="0b642e69ff5dd94afbc4e677ac7245afd2b75050" translate="yes" xml:space="preserve">
          <source>Watch a free video on Reactivity in Depth on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2a20165ccd85b019b022c5d12f356aa7e7ddb2" translate="yes" xml:space="preserve">
          <source>Watch a free video on how to define custom events on Vue School</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ef5fd200efa5ea9f0c8791591c28f563aa2607" translate="yes" xml:space="preserve">
          <source>Watch a free video on setup on Vue Mastery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a603438f7073cd71b9f2b8f7c700ac8737ed9345" translate="yes" xml:space="preserve">
          <source>Watch a reactive property or a computed function on the component instance for changes. The callback gets called with the new value and the old value for the given property. We can only pass top-level &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;prop&lt;/code&gt;, or &lt;code&gt;computed&lt;/code&gt; property name as a string. For more complex expressions or nested properties, use a function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a67bf8a391e3b919ddea5c7191736b34e4eda6f" translate="yes" xml:space="preserve">
          <source>Watch a video explanation on Vue Mastery</source>
          <target state="translated">Vue Mastery에 대한 비디오 설명보기</target>
        </trans-unit>
        <trans-unit id="955262b41b7d1f92214423e751f80e0d37bd6a39" translate="yes" xml:space="preserve">
          <source>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</source>
          <target state="translated">Vue 인스턴스에서 표현식 또는 계산 된 함수가 변경되는지 확인하십시오. 콜백은 새 값과 이전 값으로 호출됩니다. 이 식은 점으로 구분 된 경로 만 허용합니다. 더 복잡한 표현식의 경우 함수를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa35ca415d20b9f4a53f5d20f60b4e2506e17dc4" translate="yes" xml:space="preserve">
          <source>Watch on Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a37889e8f85fb3cc8ac5b854d904e40ddf13894" translate="yes" xml:space="preserve">
          <source>Watcher Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc01934e544fe692a8a590e35cab70ab09f9b33" translate="yes" xml:space="preserve">
          <source>Watchers</source>
          <target state="translated">Watchers</target>
        </trans-unit>
        <trans-unit id="5cf8cbd115de2abf5faeb9247b097fd9a89418e1" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let&amp;rsquo;s dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock&lt;/a&gt;:</source>
          <target state="translated">감시자는 수치 속성의 변경 사항을 다른 속성으로 애니메이션 할 수 있습니다. 초록에서는 복잡하게 들릴 수 있으므로 &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock을&lt;/a&gt; 사용하여 예제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="3e3b9441a3e5ab81aea2316854b5cd4f81568ab3" translate="yes" xml:space="preserve">
          <source>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let's dive into an example using &lt;a href=&quot;https://greensock.com/&quot;&gt;GreenSock (opens new window)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba9360cf0bca86052f0efa45b5c520b36dc2561" translate="yes" xml:space="preserve">
          <source>Watchers created via &lt;code&gt;vm.$watch&lt;/code&gt; are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component&amp;rsquo;s own data when the prop changes.</source>
          <target state="translated">&lt;code&gt;vm.$watch&lt;/code&gt; 를 통해 생성 된 감시자 는 이제 관련 구성 요소를 다시 렌더링하기 전에 시작됩니다. 이를 통해 구성 요소를 다시 렌더링하기 전에 상태를 추가로 업데이트 할 수 있으므로 불필요한 업데이트를 피할 수 있습니다. 예를 들어 구성 요소 소품을보고 소품이 변경 될 때 구성 요소 자체의 데이터를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c56f7248c60849f85774dec247f8195050af1aa" translate="yes" xml:space="preserve">
          <source>Watching Multiple Sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059a180684023e522c315cea524c6d4c3c650aaf" translate="yes" xml:space="preserve">
          <source>Watching Reactive Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8debcbf1f849cc32580625667ebbdeef8f8eeb6a" translate="yes" xml:space="preserve">
          <source>Watching Template Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bace31b55ee998845b6d5b8e3891e59a6675d64c" translate="yes" xml:space="preserve">
          <source>Watching a Single Source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d17151eadf5c934a94706826860753d855216f0" translate="yes" xml:space="preserve">
          <source>Watching a template ref for changes can be an alternative to the use of lifecycle hooks that was demonstrated in the previous examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58cc7cd1ba8085ead942b2bbc2bd84439f53be7" translate="yes" xml:space="preserve">
          <source>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn&amp;rsquo;t believe that, we wouldn&amp;rsquo;t be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React&amp;rsquo;s vast ecosystem of alternative renderers or Knockout&amp;rsquo;s browser support back to IE6, we try to list these as well.</source>
          <target state="translated">우리는 또한 편견을 피하기 위해 매우 열심히 노력합니다. 핵심 팀으로서 Vue를 좋아합니다. 우리가 다른 어떤 것보다 더 잘 해결한다고 생각하는 몇 가지 문제가 있습니다. 우리가 그것을 믿지 않는다면, 우리는 그것에 노력하지 않을 것입니다. 우리는 공정하고 정확하기를 원합니다. React의 방대한 대체 렌더러 에코 시스템이나 Knockout의 브라우저 지원과 같은 다른 라이브러리가 IE6로 다시 지원되는 등 우리는 이러한 라이브러리도 나열하려고합니다.</target>
        </trans-unit>
        <trans-unit id="145d670173003080c2dd95e109d6624af3091f7c" translate="yes" xml:space="preserve">
          <source>We appreciate small, focused PRs. If you'd like to make an extremely large change, please communicate with team members prior to a pull request. Here's a &lt;a href=&quot;https://www.netlify.com/blog/2020/03/31/how-to-scope-down-prs/&quot;&gt;writeup that details why this is so critical (opens new window)&lt;/a&gt; for us to work well on this team. Please understand that though we always appreciate contributions, ultimately we have to prioritize what works best for the project as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ddf11e5b6912a4511915ec63b40d6843a024e4" translate="yes" xml:space="preserve">
          <source>We are registering the invalidation callback via a passed-in function instead of returning it from the callback because the return value is important for async error handling. It is very common for the effect function to be an async function when performing data fetching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf15350412bdd57a1ba478919853106222c77d2" translate="yes" xml:space="preserve">
          <source>We are still working on a dedicated Migration Build of Vue 3 with Vue 2 compatible behavior and runtime warnings of incompatible usage. If you are planning to migrate a non-trivial Vue 2 app, we strongly recommend waiting for the Migration Build for a smoother experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b413666b6609e2e923f9dac7f2dbb73deb11598" translate="yes" xml:space="preserve">
          <source>We are working on a new version of the Devtools with a new UI and refactored internals to support multiple Vue versions. The new version is currently in beta and only supports Vue 3 (for now). Vuex and Router integration is also work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4590c53baf3d1bcb7b3f91125ba505380d0c3454" translate="yes" xml:space="preserve">
          <source>We can access slot contents as arrays of VNodes from &lt;a href=&quot;../api/instance-properties#slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19325bef373c7011977b1dc1240632398096e83b" translate="yes" xml:space="preserve">
          <source>We can annotate a payload for the emitted event. Also, all non-declared emitted events will throw a type error when called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded0fe3886c210ed1f69601603a576fff08f9afa" translate="yes" xml:space="preserve">
          <source>We can check resources like &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS-Triggers (opens new window)&lt;/a&gt; to see which properties will trigger repaints if we animate them. Here, if you look under &lt;code&gt;transform&lt;/code&gt;, you will see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d01d3af55b1b61c1d3a9c7fb07204866aad330" translate="yes" xml:space="preserve">
          <source>We can combine this technique with our previous implementation to animate every possible change to our list!</source>
          <target state="translated">이 기술을 이전 구현과 결합하여 가능한 모든 변경 사항을 애니메이션으로 만들 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="cd1d61172e00dd1e1c488b575a87db8e2cda970e" translate="yes" xml:space="preserve">
          <source>We can create extremely smooth animations on the web by being aware of performance. We want to hardware accelerate elements when we can, and use properties that don't trigger repaints. Let's go over some of how we can accomplish this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b738e997b0df8d616d9cdb2cc5977352977ba792" translate="yes" xml:space="preserve">
          <source>We can do this because the search button will help visual users identify the purpose of the input field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578ccaba9c04ab4407d0e1982d8ccf1d0a6b7d5a" translate="yes" xml:space="preserve">
          <source>We can list emitted events in the component's &lt;code&gt;emits&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a5cb8e42f077c1fe5767909f49df6511a23c3c" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;v-model&lt;/code&gt; directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</source>
          <target state="translated">이제 사용자 정의 입력에서 &lt;code&gt;v-model&lt;/code&gt; 을 직접 사용할 수 있습니다 . 이는 일반 입력과보다 일관성이있을뿐만 아니라 Vuex 친화적 인 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="8e665af7b29d480225aa1952784d4bbf8b4eb21b" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355091be9a6d8f6adad9082fc7271b2db1fff1d5" translate="yes" xml:space="preserve">
          <source>We can pass an array to &lt;code&gt;v-bind:class&lt;/code&gt; to apply a list of classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; 에 배열을 전달하여 클래스 목록을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="406b9892cf3e59eeb19dc1064b0235c19adccc7c" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;:class&lt;/code&gt; (short for &lt;code&gt;v-bind:class&lt;/code&gt;) to dynamically toggle classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005cab2aeec12d5fca81549807922fe01dfc3429" translate="yes" xml:space="preserve">
          <source>We can pass an object to &lt;code&gt;v-bind:class&lt;/code&gt; to dynamically toggle classes:</source>
          <target state="translated">&lt;code&gt;v-bind:class&lt;/code&gt; 에 객체를 전달하여 클래스 를 동적으로 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e7623c17ea7ebe75cd4f565824983dde786be" translate="yes" xml:space="preserve">
          <source>We can see from the table above, current implementation coerces &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;'true'&lt;/code&gt; but removes the attribute if it's &lt;code&gt;false&lt;/code&gt;. This also led to inconsistency and required users to manually coerce boolean values to string in very common use cases like &lt;code&gt;aria-*&lt;/code&gt; attributes like &lt;code&gt;aria-selected&lt;/code&gt;, &lt;code&gt;aria-hidden&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4415051c820f469ebda2e174386196145ce7433" translate="yes" xml:space="preserve">
          <source>We can use &lt;a href=&quot;component-provide-inject&quot;&gt;provide / inject&lt;/a&gt; with the Composition API as well. Both can only be called during &lt;a href=&quot;composition-api-setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; with a current active instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df72788c45d87bd5e47825b2ad8e91055d4e9ce1" translate="yes" xml:space="preserve">
          <source>We can use CSS to visually hide elements but keep them available for assistive technology:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee275d541bee10b64a1c9ec38cc555e113f6f7" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-for&lt;/code&gt; directive to render a list of items based on an array. The &lt;code&gt;v-for&lt;/code&gt; directive requires a special syntax in the form of &lt;code&gt;item in items&lt;/code&gt;, where &lt;code&gt;items&lt;/code&gt; is the source data array and &lt;code&gt;item&lt;/code&gt; is an &lt;strong&gt;alias&lt;/strong&gt; for the array element being iterated on:</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 지시문을 사용하여 배열을 기반으로 항목 목록을 렌더링 할 수 있습니다 . &lt;code&gt;v-for&lt;/code&gt; 지시자의 형태로 특수 구문 요구 &lt;code&gt;item in items&lt;/code&gt; , &lt;code&gt;items&lt;/code&gt; 소스 데이터 배열 및 &lt;code&gt;item&lt;/code&gt; 인 &lt;strong&gt;별명&lt;/strong&gt; 에 반복되는 배열 요소를 :</target>
        </trans-unit>
        <trans-unit id="08647a6e0d6544e518fabc04e7c8f3381fecd799" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive to listen to DOM events and run some JavaScript when they&amp;rsquo;re triggered.</source>
          <target state="translated">&lt;code&gt;v-on&lt;/code&gt; 지시문을 사용하여 DOM 이벤트를 수신하고 트리거 될 때 일부 JavaScript를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b3e0b88025a1cd9dd1aa491f0dd2bc179180f4" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;v-on&lt;/code&gt; directive, which we typically shorten to the &lt;code&gt;@&lt;/code&gt; symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be &lt;code&gt;v-on:click=&quot;methodName&quot;&lt;/code&gt; or with the shortcut, &lt;code&gt;@click=&quot;methodName&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b6da1cf882bfbaa28b18476abab8f6ff6b7b6e" translate="yes" xml:space="preserve">
          <source>We can use this to coordinate more expressive movement, such as a folding card, as demonstrated below. It's actually two elements transitioning between each other, but since the beginning and end states are scaling the same: horizontally to 0, it appears like one fluid movement. This type of sleight-of-hand can be very useful for realistic UI microinteractions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817f50bdc2a016379b436c13b4b442890443585f" translate="yes" xml:space="preserve">
          <source>We could do the same for other &lt;strong&gt;logical concerns&lt;/strong&gt; but you might be already asking the question &amp;ndash; &lt;em&gt;Isn&amp;rsquo;t this just moving the code to the &lt;code&gt;setup&lt;/code&gt; option and making it extremely big?&lt;/em&gt; Well, that&amp;rsquo;s true. That&amp;rsquo;s why before moving on with the other responsibilities, we will first extract the above code into a standalone &lt;strong&gt;composition function&lt;/strong&gt;. Let's start with creating &lt;code&gt;useUserRepositories&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ffe41784517452c4544784a7be6d8d5108fe6" translate="yes" xml:space="preserve">
          <source>We could manage communication between components with this single event hub:</source>
          <target state="translated">이 단일 이벤트 허브를 사용하여 구성 요소 간의 통신을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0630f4d9efe7a98a7c8142cce5768ccbc2ddb708" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="translated">우리 토론 &lt;a href=&quot;#Transitioning-Between-Components&quot;&gt;구성 요소 사이의 전환&lt;/a&gt; 이후,하지만 당신은 원시 요소들 사이의 전환은 사용 할 수 있습니다 &lt;code&gt;v-if&lt;/code&gt; / &lt;code&gt;v-else&lt;/code&gt; . 가장 일반적인 두 요소 전환 중 하나는 목록 컨테이너와 빈 목록을 설명하는 메시지 사이입니다.</target>
        </trans-unit>
        <trans-unit id="e2e7b18ff8837f7d2c779646a84e95769cc3303b" translate="yes" xml:space="preserve">
          <source>We discuss &lt;a href=&quot;#transitioning-between-components&quot;&gt;transitioning between components&lt;/a&gt; later, but you can also transition between raw elements using &lt;code&gt;v-if&lt;/code&gt;/&lt;code&gt;v-else&lt;/code&gt;. One of the most common two-element transitions is between a list container and a message describing an empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b661bb8cef40b1e52670e390897ae263c3d477" translate="yes" xml:space="preserve">
          <source>We get similar benefits from updating:</source>
          <target state="translated">업데이트를 통해 유사한 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1404134e0f64ba7c9a0eb5c96c6caba434af9f39" translate="yes" xml:space="preserve">
          <source>We get the following benefits:</source>
          <target state="translated">다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="836491b426d471931d091eb3bfa8b677fe7b6214" translate="yes" xml:space="preserve">
          <source>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</source>
          <target state="translated">새로운 Angular는 AngularJS와 완전히 다른 프레임 워크이므로 별도의 섹션이 있습니다. 예를 들어, 그것은 일급 컴포넌트 시스템을 특징으로하며 많은 구현 세부 사항이 완전히 재 작성되었으며 API도 상당히 크게 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e8c721f28fbdf12b00ac6dc8ba0de44aa2efa5c" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Open your browser&amp;rsquo;s JavaScript console (right now, on this page) and set &lt;code&gt;app.message&lt;/code&gt; to a different value. You should see the rendered example above update accordingly.</source>
          <target state="translated">우리는 이미 첫 Vue 앱을 만들었습니다! 이것은 문자열 템플릿을 렌더링하는 것과 매우 유사하지만 Vue는 많은 작업을 수행했습니다. 이제 데이터와 DOM이 연결되었으며 모든 것이 &lt;strong&gt;반응 형&lt;/strong&gt; 입니다. 우리가 어떻게 알아? 브라우저의 JavaScript 콘솔 ( &lt;code&gt;app.message&lt;/code&gt; 페이지에서)을 열고 app.message 를 다른 값으로 설정하십시오 . 위의 렌더링 된 예제는 이에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a3de3e0ebfec380551325c5d2024c30336332771" translate="yes" xml:space="preserve">
          <source>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now &lt;strong&gt;reactive&lt;/strong&gt;. How do we know? Take a look at the example below where &lt;code&gt;counter&lt;/code&gt; property increments every second and you will see how rendered DOM changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9882cb189eb18be1f8b18353e20480e68691217f" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5c9fe6c6c8767e1c9e46c7912f5d36985ece63" translate="yes" xml:space="preserve">
          <source>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt;.</source>
          <target state="translated">서버 렌더링 Vue 응용 프로그램을 만들기위한 독립 실행 형 가이드를 만들었습니다. 이것은 클라이언트 측 Vue 개발, 서버 측 Node.js 개발 및 웹팩에 이미 익숙한 사용자를위한 매우 심층적 인 안내서입니다. &lt;a href=&quot;https://ssr.vuejs.org/&quot;&gt;ssr.vuejs.org&lt;/a&gt; 에서 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e2d326202574eaf0a4b0a6f118cf078e50093fa" translate="yes" xml:space="preserve">
          <source>We have moved several pieces of our first logical concern into the &lt;code&gt;setup&lt;/code&gt; method, nicely put close to each other. What&amp;rsquo;s left is calling &lt;code&gt;getUserRepositories&lt;/code&gt; in the &lt;code&gt;mounted&lt;/code&gt; hook and setting up a watcher to do that whenever the &lt;code&gt;user&lt;/code&gt; prop changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f49be9e4b4a0bd2cc13f3ef887bdbb56e8ea881" translate="yes" xml:space="preserve">
          <source>We have some dedicated styles to denote something that's worth highlighting in a particular way. These are captured &lt;a href=&quot;../doc-style-guide#alerts&quot;&gt;on this page (opens new window)&lt;/a&gt;. &lt;strong&gt;They are to be used sparingly.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2365bbdeaabeff7b76c97dd6062eceb546eae44b" translate="yes" xml:space="preserve">
          <source>We have to provide a proper prop name for the event handler, e.g., to handle &lt;code&gt;click&lt;/code&gt; events, the prop name would be &lt;code&gt;onClick&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b667182eef0a9564fcc136526a19be6641183fb" translate="yes" xml:space="preserve">
          <source>We intend to drop this internal concept of &quot;enumerated attributes&quot; and treat them as normal non-boolean HTML attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3eea1c16de0a8e9cf42e189bd675df96a77366" translate="yes" xml:space="preserve">
          <source>We make a copy of the DOM in JavaScript called the Virtual DOM, we do this because touching the DOM with JavaScript is computationally expensive. While performing updates in JavaScript is cheap, finding the required DOM nodes and updating them with JavaScript is expensive. So we batch calls, and change the DOM all at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a6f46a302366b1b4d268e8a2baf4204e756c65" translate="yes" xml:space="preserve">
          <source>We mentioned before that in order to have an API that updates a final value when something changes, we&amp;rsquo;re going to have to set new values when something changes. We do this in the handler, in a function called &lt;code&gt;track&lt;/code&gt;, where we pass in the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd40e61c317c21b5589b1855722a4f76630a6a7" translate="yes" xml:space="preserve">
          <source>We might want the text &quot;Submit&quot; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &quot;Submit&quot; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b81c111ded5524bb8ba95145dfdcec13c623" translate="yes" xml:space="preserve">
          <source>We might want the text &amp;ldquo;Submit&amp;rdquo; to be rendered inside the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; most of the time. To make &amp;ldquo;Submit&amp;rdquo; the fallback content, we can place it in between the &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; tags:</source>
          <target state="translated">&amp;ldquo;제출&amp;rdquo;텍스트가 대부분 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 안에 렌더링되기를 원할 수 있습니다 . 대체 콘텐츠를 &quot;제출&quot;하기 위해 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 태그 사이에 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea4d2b2947c843536ed2a98837450506cc32476" translate="yes" xml:space="preserve">
          <source>We might want to replace the &lt;code&gt;{{ item }}&lt;/code&gt; with a &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; to customize it on parent component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b8c040118415f530225ac0a01e6d757fa256dc" translate="yes" xml:space="preserve">
          <source>We might want to replace this fallback content to display the user&amp;rsquo;s first name, instead of last, like this:</source>
          <target state="translated">다음과 같이이 대체 콘텐츠를 대체하여 사용자 대신 이름을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="549db0def9cf014f83eb865e4d0765c64a3bfee1" translate="yes" xml:space="preserve">
          <source>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There&amp;rsquo;s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</source>
          <target state="translated">이 구성 요소를 재사용하여 사용자가 여러 목록 (예 : 쇼핑, 위시리스트, 일일 집안일 등)을 유지할 수 있도록 할 수 있습니다. 그래도 문제가 있습니다. 컴포넌트의 모든 인스턴스가 동일한 데이터 오브젝트를 참조하므로 한 목록의 제목을 변경하면 다른 모든 목록의 제목도 변경됩니다. 할 일을 추가 / 편집 / 삭제할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="d78b76b13dec2d9479f1cfb4f190e2eb6e217389" translate="yes" xml:space="preserve">
          <source>We recommend replacing any complex expressions with a &lt;a href=&quot;computed&quot;&gt;computed property&lt;/a&gt;, one of the most fundamental pieces of Vue, which we'll cover shortly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b734f82d47813efa3a6806ce727611d03115657d" translate="yes" xml:space="preserve">
          <source>We recommend:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9d55967630e0ffef70ef9b3f460a567135d1e5" translate="yes" xml:space="preserve">
          <source>We removed &lt;code&gt;$on&lt;/code&gt;, &lt;code&gt;$off&lt;/code&gt; and &lt;code&gt;$once&lt;/code&gt; methods from the instance completely. &lt;code&gt;$emit&lt;/code&gt; is still a part of the existing API as it's used to trigger event handlers declaratively attached by a parent component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f5ee5b56c067fa325613b60b7faa1aebd9325d" translate="yes" xml:space="preserve">
          <source>We surround the arguments with parentheses and delimit the arguments with commas:</source>
          <target state="translated">인수를 괄호로 묶고 인수를 쉼표로 구분합니다.</target>
        </trans-unit>
        <trans-unit id="3f6388f12bd97827e87f720eb7e6528b0cdd918b" translate="yes" xml:space="preserve">
          <source>We use it like this: &lt;code&gt;new Proxy(target, handler)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866e301e87de4875c510e32c3de7ad212732a107" translate="yes" xml:space="preserve">
          <source>We want to make a function to translate keys available to the whole application, so we will expose it using &lt;code&gt;app.config.globalProperties&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bb8d549018405cd3717be9cfc0482cf533a00b" translate="yes" xml:space="preserve">
          <source>We will assume that our users will pass in an object containing the translated keys in the &lt;code&gt;options&lt;/code&gt; parameter when they use the plugin. Our &lt;code&gt;$translate&lt;/code&gt; function will take a string such as &lt;code&gt;greetings.hello&lt;/code&gt;, look inside the user provided configuration and return the translated value - in this case, &lt;code&gt;Bonjour!&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2d79d26a57c657532cfa93323b5aa7856a950f" translate="yes" xml:space="preserve">
          <source>We will cover all of these and more in the next three sections in this Guide. However, aside from these useful API offerings, it's worth mentioning that the class and style declarations we covered earlier can be used to apply animations and transitions as well, for more simple use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0330d8076787db736d1163a550844572651d3ec8" translate="yes" xml:space="preserve">
          <source>We will need to install Rollup and a few dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9990a125d88c5ba238d041e04854bb4b051a20bc" translate="yes" xml:space="preserve">
          <source>We will start with the lifecycle hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bee3c68a3f59f9dbc34ec660b948ec6a34b4f2" translate="yes" xml:space="preserve">
          <source>We will start with the most obvious parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34746e60611d8ce199ba5e1744dcd31fcb6189c0" translate="yes" xml:space="preserve">
          <source>We will use the &lt;code&gt;i18nPlugin&lt;/code&gt; we created in the &lt;a href=&quot;#writing-a-plugin&quot;&gt;Writing a Plugin&lt;/a&gt; section for demo purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b7e00cf3c217540b9859501e68dc10129cbf2f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d also like &lt;strong&gt;your&lt;/strong&gt; help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn&amp;rsquo;t seem quite right, please let us know by &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">JavaScript 세계가 빠르게 움직이기 때문에이 문서를 최신 상태로 유지하는 데 도움 을 드리고자 &lt;strong&gt;합니다&lt;/strong&gt; . 정확하지 않은 것 또는 부정확 한 것이 발견 &lt;a href=&quot;https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide&quot;&gt;되면 문제&lt;/a&gt; 를 열어 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="d9d3e90ad0f5f8e3a16d2f0593a1c96b7e9437ba" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll cover VNodes in more detail &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;later&lt;/a&gt;, when we discuss &lt;a href=&quot;render-function&quot;&gt;render functions&lt;/a&gt;.</source>
          <target state="translated">우리는 &lt;a href=&quot;render-function#The-Virtual-DOM&quot;&gt;나중에 &lt;/a&gt;&lt;a href=&quot;render-function&quot;&gt;렌더링 함수에&lt;/a&gt; 대해 논의 할 때 VNode를 더 자세히 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a2a13deabe649b5c3118707a53fb4509b5ea3b89" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;oldVnode&lt;/code&gt;) in the next section.</source>
          <target state="translated">다음 섹션에서 이러한 후크에 전달 된 인수 (예 : &lt;code&gt;el&lt;/code&gt; , &lt;code&gt;binding&lt;/code&gt; , &lt;code&gt;vnode&lt;/code&gt; 및 &lt;code&gt;oldVnode&lt;/code&gt; )를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="48d3e43fe68276b9cc259bd79455e2bc4213c8db" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about &lt;a href=&quot;components&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</source>
          <target state="translated">&lt;a href=&quot;components&quot;&gt;구성 요소 시스템&lt;/a&gt; 에 대해서는 나중에 자세히 설명 하겠습니다 . 지금은 모든 Vue 구성 요소도 Vue 인스턴스라는 것을 알고 있으므로 동일한 옵션 개체를 수락하십시오 (몇 가지 루트 별 옵션 제외).</target>
        </trans-unit>
        <trans-unit id="8573a8cbd8f1b40ae7525ff0d66bbf6d9920e106" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="translated">우리는 단순히 각 언어의 규칙을 따르고 있습니다. JavaScript 내에서 camelCase가 더 자연 스럽습니다. HTML 내에서 케밥 케이스입니다.</target>
        </trans-unit>
        <trans-unit id="b358f1e880381f7d6e871561f446388962244398" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still limited however, by filters and by Vue 1.0 in general, so let&amp;rsquo;s complete the upgrade to Vue 2.0:</source>
          <target state="translated">그러나 여전히 필터와 Vue 1.0에 의해 여전히 제한되어 있으므로 Vue 2.0으로의 업그레이드를 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="54237427c42ae1e9fb9b273cbab35c157528d0e1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="translated">우리는 Vue.js 코어의 가장 기본적인 기능을 간략하게 소개했습니다.이 가이드의 나머지 부분에서는 그 기능 및 기타 고급 기능에 대해 훨씬 더 자세한 내용을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb8b82ed49a41a1aeaad51c988296a83c46302ad" translate="yes" xml:space="preserve">
          <source>We'll be using GreenSock in some of the examples in the sections following. They have a great &lt;a href=&quot;https://greensock.com/ease-visualizer&quot;&gt;ease visualizer (opens new window)&lt;/a&gt; that will help you build nicely crafted eases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abdbdf8ec29be45ff4f5a54f8824c87ed93395f" translate="yes" xml:space="preserve">
          <source>We'll cover VNodes in more detail &lt;a href=&quot;render-function#the-virtual-dom-tree&quot;&gt;later&lt;/a&gt;, when we discuss render functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11cb422fd9a8827a4bee9296e2eefeb8799791f" translate="yes" xml:space="preserve">
          <source>We'll talk about &lt;a href=&quot;component-basics&quot;&gt;the component system&lt;/a&gt; in detail later. For now, just be aware that the root component isn't really any different from any other component. The configuration options are the same, as is the behavior of the corresponding component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4763cc35fb84a23678cf26a9f7a29bb762c52dee" translate="yes" xml:space="preserve">
          <source>We're showing you a simple example here, but in a typical Vue application we use Single File Components instead of a string template. You can find more information about them &lt;a href=&quot;single-file-component&quot;&gt;in this section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902ee1e6bc3aa622843aa289195cfdd213ac8ef1" translate="yes" xml:space="preserve">
          <source>We're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3ca188b1df773cfd1eeb0376541bfa59686bfe" translate="yes" xml:space="preserve">
          <source>We've briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96cc25eb05f1274ae7b9eebefd157220abac3ca" translate="yes" xml:space="preserve">
          <source>Web Accessibility Initiative &amp;ndash; Accessible Rich Internet Applications (WAI-ARIA)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf30cbd1ee6db2c9121250baf622ac22c881128" translate="yes" xml:space="preserve">
          <source>Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff265f994041ba5e431f8222c5c1ba6691182894" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83aec0744d18b3272452883bc73b55a421d84c62" translate="yes" xml:space="preserve">
          <source>Web Content Accessibility Guidelines (WCAG) (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279f4a441a4b12f3b9de64ff7f0e63d1f6fc5d06" translate="yes" xml:space="preserve">
          <source>Web accessibility (also known as a11y) refers to the practice of creating websites that can be used by anyone &amp;mdash; be that a person with a disability, a slow connection, outdated or broken hardware or simply someone in an unfavorable environment. For example, adding subtitles to a video would help both your deaf and hard-of-hearing users and your users who are in a loud environment and can't hear their phone. Similarly, making sure your text isn't too low contrast will help both your low-vision users and your users who are trying to use their phone in bright sunlight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8917af5cf347fb6a6fe194798f4f56a85c811a01" translate="yes" xml:space="preserve">
          <source>WebAim Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca0768e3dfd8cfbe2c2bff1e16645bb18dbfe9b" translate="yes" xml:space="preserve">
          <source>WebAim Link Color Contrast (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="b0f63abab58780fc9096086a11d8c4fd44969c50" translate="yes" xml:space="preserve">
          <source>Webpack Configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bea3e418773cf65893996cd6beb9f369dec51f2" translate="yes" xml:space="preserve">
          <source>What About Separation of Concerns?</source>
          <target state="translated">우려의 분리는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="c41e81975a805013a596d74998d05b0991be3b34" translate="yes" xml:space="preserve">
          <source>What You Can Do</source>
          <target state="translated">할 수있는 일</target>
        </trans-unit>
        <trans-unit id="167fd1d6380ec0bfe627ebef6ee16c27264edd27" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;createElement&lt;/code&gt; actually returning? It&amp;rsquo;s not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It could perhaps more accurately be named &lt;code&gt;createNodeDescription&lt;/code&gt;, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &amp;ldquo;virtual node&amp;rdquo;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &amp;ldquo;Virtual DOM&amp;rdquo; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="translated">&lt;code&gt;createElement&lt;/code&gt; 가 실제로 반환하는 것은 무엇입니까 ? 그것은 아니다 &lt;em&gt;정확히&lt;/em&gt; 진짜 DOM 요소. 자식 노드에 대한 설명을 포함하여 페이지에 렌더링해야하는 노드 종류를 설명하는 정보가 포함되어 있으므로 더 정확하게 &lt;code&gt;createNodeDescription&lt;/code&gt; 으로 이름을 지정할 수 있습니다 . 이 노드 설명을 &quot;가상 노드&quot;라고하며 일반적으로 &lt;strong&gt;VNode로&lt;/strong&gt; 약칭합니다 . &quot;가상 DOM&quot;은 Vue 구성 요소 트리에 의해 구축 된 전체 VNode 트리라고합니다.</target>
        </trans-unit>
        <trans-unit id="c23944cd8d26c2cb26b60dd0d1caadba140c80c6" translate="yes" xml:space="preserve">
          <source>What is Reactivity?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4bf93cce91f7c3fb6d3854aa9288f33a74e958" translate="yes" xml:space="preserve">
          <source>What is Vue.js?</source>
          <target state="translated">Vue.js은 (는) 무엇 이죠?</target>
        </trans-unit>
        <trans-unit id="6762984b105eb8b517b607b726e8ea600efa2e2a" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;h()&lt;/code&gt; function returning? It's not &lt;em&gt;exactly&lt;/em&gt; a real DOM element. It returns a plain object which contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &quot;virtual node&quot;, usually abbreviated to &lt;strong&gt;VNode&lt;/strong&gt;. &quot;Virtual DOM&quot; is what we call the entire tree of VNodes, built by a tree of Vue components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b4db1127a98add882b9a9fa2787d6954410927" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 가 여러 아이들, 그들은 결국 하나의 아이를 평가해야합니다. 첫 번째 아이 이외의 아이는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4fa4fac2c46b4a9cb5fd7f97a6be2dad1bbe60c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is mutated, the callback will be called &lt;strong&gt;before&lt;/strong&gt; the component has updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309b02e7394c67ecb1bf6afa2ce27ef901e58b3d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; is truthy, the rendered HTML will be:</source>
          <target state="translated">때 &lt;code&gt;isActive&lt;/code&gt; truthy이며, 렌더링 된 HTML은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="ac61ff2088162189efe616f91e65e3365c7ef127" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isActive&lt;/code&gt; or &lt;code&gt;hasError&lt;/code&gt; changes, the class list will be updated accordingly. For example, if &lt;code&gt;hasError&lt;/code&gt; becomes &lt;code&gt;true&lt;/code&gt;, the class list will become &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;isActive&lt;/code&gt; 또는 &lt;code&gt;hasError&lt;/code&gt; 이 변경 클래스 목록이 그에 따라 업데이트됩니다. 예를 들어 &lt;code&gt;hasError&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 클래스 목록은 &lt;code&gt;&quot;static active text-danger&quot;&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="934dc1b26aeb98269916de2b7fd28293e3c6d44a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ref&lt;/code&gt; is used together with &lt;code&gt;v-for&lt;/code&gt;, the ref you get will be an array containing the child components mirroring the data source.</source>
          <target state="translated">때 &lt;code&gt;ref&lt;/code&gt; 함께 사용되는 &lt;code&gt;v-for&lt;/code&gt; , 당신이 얻을 심판은 데이터 소스를 미러링 하위 구성 요소를 포함하는 배열 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="68799a9bc72bc5436c612e032f0302797e50e850" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setup&lt;/code&gt; is executed, the component instance has not been created yet. As a result, you will only be able to access the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47602c789504fad3106f84efc16c598040016f06" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; will always be replaced instead of patched, so a transition will be triggered.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 변경의 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 항상 교체 대신 패치됩니다 전환이 발생됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="e9a272c5ffb0265f805ce14ec56031bc1589886c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt; are both used on the same element, &lt;code&gt;v-if&lt;/code&gt; will be evaluated first. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc1cc0e7f7cb99eda1ea39c8e59b8e52d17b215" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;watchEffect&lt;/code&gt; is called during a component's &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt; function or &lt;a href=&quot;composition-api-lifecycle-hooks&quot;&gt;lifecycle hooks&lt;/a&gt;, the watcher is linked to the component's lifecycle and will be automatically stopped when the component is unmounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6c45281f0e9295693c785e9c077ccf9de2ef90" translate="yes" xml:space="preserve">
          <source>When Vue 2.0 was released, the &lt;code&gt;v-model&lt;/code&gt; directive required developers to always use the &lt;code&gt;value&lt;/code&gt; prop. And if developers required different props for different purposes, they would have to resort to using &lt;code&gt;v-bind.sync&lt;/code&gt;. In addition, this hard-coded relationship between &lt;code&gt;v-model&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; led to issues with how native elements and custom elements were handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c133285af76b6277f0041e5a1b902c2f3bc7a50" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &quot;in-place patch&quot; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a14f3e4c0ab76a85e402fcdb8f819a5ba90c68" translate="yes" xml:space="preserve">
          <source>When Vue is updating a list of elements rendered with &lt;code&gt;v-for&lt;/code&gt;, by default it uses an &amp;ldquo;in-place patch&amp;rdquo; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; in Vue 1.x.</source>
          <target state="translated">Vue가 &lt;code&gt;v-for&lt;/code&gt; 로 렌더링 된 요소 목록을 업데이트 할 때 기본적으로 &quot;in-place patch&quot;전략을 사용합니다. 데이터 항목의 순서가 변경된 경우, 항목의 순서와 일치하도록 DOM 요소를 이동하는 대신 Vue는 각 요소를 제자리에 패치하여 해당 특정 인덱스에서 렌더링해야하는 요소를 반영합니다. 이는 Vue 1.x 의 &lt;code&gt;track-by=&quot;$index&quot;&lt;/code&gt; 동작과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2c0ed8c392c7855b9cfcb0f1d593848f3d1d64ec" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;, so that this template:</source>
          <target state="translated">Vue가 지시문을 처리 할 때 &lt;code&gt;v-for&lt;/code&gt; 가 &lt;code&gt;v-if&lt;/code&gt; 보다 우선 순위가 높으므로이 템플리트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b259e9996f2602892d2efd59722e6bdb4ae4ddf9" translate="yes" xml:space="preserve">
          <source>When Vue processes directives, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;, so that this template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee4a8778693915a3019bc1ea6f3a54f6005a00f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ref&lt;/code&gt; is accessed or mutated as a property of a reactive object, it automatically unwraps to the inner value so it behaves like a normal property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22299c2d8ba7d7e0ca3851b5863bdfc318d6f049" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don&amp;rsquo;t need to worry about cleaning it up yourself.</source>
          <target state="translated">ViewModel이 파괴되면 모든 이벤트 리스너가 자동으로 제거됩니다. 스스로 청소하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea83eee9db8590cd8fc96e20bb41e31cb11921cd" translate="yes" xml:space="preserve">
          <source>When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61abf89b8df56e434a82bb51460860f497d2afd" translate="yes" xml:space="preserve">
          <source>When a Vue instance is created, it adds all the properties found in its &lt;code&gt;data&lt;/code&gt; object to Vue&amp;rsquo;s &lt;strong&gt;reactivity system&lt;/strong&gt;. When the values of those properties change, the view will &amp;ldquo;react&amp;rdquo;, updating to match the new values.</source>
          <target state="translated">Vue 인스턴스가 작성되면 &lt;code&gt;data&lt;/code&gt; 오브젝트 에서 찾은 모든 특성 이 Vue의 &lt;strong&gt;반응성 시스템에 추가&lt;/strong&gt; 됩니다. 해당 속성 값이 변경되면보기가 &quot;반응&quot;하여 새 값과 일치하도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e10ac371624472fea62e8a9b8d7a32ccc5fd883e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &quot;DOM nodes&quot; (opens new window)&lt;/a&gt; to help it keep track of everything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9c5b81a5681d40b1461fa8b123f7a49c06375e" translate="yes" xml:space="preserve">
          <source>When a browser reads this code, it builds a &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;tree of &amp;ldquo;DOM nodes&amp;rdquo;&lt;/a&gt; to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</source>
          <target state="translated">브라우저는이 코드를 읽을 때 확장 된 패밀리를 추적하기 위해 가계도를 작성할 수있는 것처럼 모든 것을 추적 할 수 있도록 &lt;a href=&quot;https://javascript.info/dom-nodes&quot;&gt;&quot;DOM 노드&quot;&lt;/a&gt; 트리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="29317cfc514db816870cce186295052bddc2f50e" translate="yes" xml:space="preserve">
          <source>When a component is toggled inside &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt;, its &lt;code&gt;activated&lt;/code&gt; and &lt;code&gt;deactivated&lt;/code&gt; lifecycle hooks will be invoked accordingly.</source>
          <target state="translated">&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 내부에서 구성 요소를 토글하면 구성 요소 에 따라 &lt;code&gt;activated&lt;/code&gt; 및 &lt;code&gt;deactivated&lt;/code&gt; 라이프 사이클 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="421b8a98b1760ead672f1b77216c67fcc30374a6" translate="yes" xml:space="preserve">
          <source>When a component returns a single root node, non-prop attributes will automatically be added to the root node's attributes. For example, in the instance of a date-picker component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4093e40e3a7a628dc648fbb3e9f015f5439f571" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &quot;merged&quot; using appropriate strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bd02b68298dd5a1f896d4edc79b24aabb58235" translate="yes" xml:space="preserve">
          <source>When a mixin and the component itself contain overlapping options, they will be &amp;ldquo;merged&amp;rdquo; using appropriate strategies.</source>
          <target state="translated">믹스 인과 구성 요소 자체에 겹치는 옵션이 포함 된 경우 적절한 전략을 사용하여 &quot;병합&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="15a4799ba709de314050c2aeb417d1c062407080" translate="yes" xml:space="preserve">
          <source>When a native event (e.g., &lt;code&gt;click&lt;/code&gt;) is defined in the &lt;code&gt;emits&lt;/code&gt; option, the component event will be used &lt;strong&gt;instead&lt;/strong&gt; of a native event listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f72c8ed98813c97629aa3dff3ba23fdf14af142" translate="yes" xml:space="preserve">
          <source>When a nested object is accessed from a reactive proxy, that object is &lt;em&gt;also&lt;/em&gt; converted into a proxy before being returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db172a75e05ba77d82b2612c1d789b4232b4b0f" translate="yes" xml:space="preserve">
          <source>When a parent listens for the &lt;code&gt;click&lt;/code&gt; event on the component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0801ddea4aa0f45998c371d842fd8cd4d1bfcbd5" translate="yes" xml:space="preserve">
          <source>When a ref is returned as a property on the render context (the object returned from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;) and accessed in the template, it automatically unwraps to the inner value. There is no need to append &lt;code&gt;.value&lt;/code&gt; in the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00843c9d85b596ab87a52656147b09febbd8f473" translate="yes" xml:space="preserve">
          <source>When a value is passed to a prop attribute, it becomes a property on that component instance. The value of that property is accessible within the template, just like any other component property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c053395d17d13ce80a0364c9ff5e250131f80f75" translate="yes" xml:space="preserve">
          <source>When adding instructions for your input fields, make sure to link it correctly to the input. You can provide additional instructions and bind multiple ids inside an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute&quot;&gt;&lt;code&gt;aria-labelledby&lt;/code&gt; (opens new window)&lt;/a&gt;. This allows for more flexible design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441171155cec8cb7b4886d622933622cf7cc0aa7" translate="yes" xml:space="preserve">
          <source>When an element wrapped in a &lt;code&gt;transition&lt;/code&gt; component is inserted or removed, this is what happens:</source>
          <target state="translated">&lt;code&gt;transition&lt;/code&gt; 구성 요소에 싸인 요소를 삽입하거나 제거하면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="a6231838dcc377e59b6f7a45b72b3be9da61805a" translate="yes" xml:space="preserve">
          <source>When assigning a &lt;a href=&quot;refs-api#ref&quot;&gt;ref&lt;/a&gt; to a &lt;code&gt;reactive&lt;/code&gt; property, that ref will be automatically unwrapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bedf600c3ab131cb247e5836babdb736c7f1c0b" translate="yes" xml:space="preserve">
          <source>When building out a &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; component, your template will eventually contain more than just the title:</source>
          <target state="translated">밖으로 만들 때 &lt;code&gt;&amp;lt;blog-post&amp;gt;&lt;/code&gt; 구성 요소, 템플릿은 결국 더 단지 제목보다는이 포함됩니다 :</target>
        </trans-unit>
        <trans-unit id="38bfebbfa9c7071d667afc65ea17c45a78ca6bbc" translate="yes" xml:space="preserve">
          <source>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</source>
          <target state="translated">구성 요소가 비좁거나 읽기 어려운 느낌이 들기 시작하면 여러 줄 속성 사이에 공백을 추가하면 다시 쉽게 감을 수 있습니다. Vim과 같은 일부 편집기에서는 이와 같은 서식 옵션을 사용하면 키보드를 사용하여 쉽게 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="309c2a92544230a15a51f890171560d2c2b0da32" translate="yes" xml:space="preserve">
          <source>When creating a form, you can use the following elements: &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574ddee43c6d5c376daa9d7c67db78f6a16adac7" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="translated">사용자 지정 옵션을 병합하면 기존 값을 덮어 쓰는 기본 전략을 사용합니다. 사용자 정의 로직을 사용하여 사용자 정의 옵션을 병합하려면 &lt;code&gt;Vue.config.optionMergeStrategies&lt;/code&gt; 에 함수를 첨부해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a48b042d07d089f8ac425b2bfbb816b814258e35" translate="yes" xml:space="preserve">
          <source>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to &lt;code&gt;app.config.optionMergeStrategies&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0246a7b06b284f630c270a3b6fd7d4bf46f87f10" translate="yes" xml:space="preserve">
          <source>When defining a &lt;strong&gt;component&lt;/strong&gt;, &lt;code&gt;data&lt;/code&gt; must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for &lt;code&gt;data&lt;/code&gt;, that same object will be &lt;strong&gt;shared by reference&lt;/strong&gt; across all instances created! By providing a &lt;code&gt;data&lt;/code&gt; function, every time a new instance is created we can call it to return a fresh copy of the initial data.</source>
          <target state="translated">결정적인 때 &lt;strong&gt;구성 요소를&lt;/strong&gt; , &lt;code&gt;data&lt;/code&gt; 함수로 선언해야 그 반환 초기 데이터 객체, 동일한 정의를 사용하여 만든 많은 경우가있을 것입니다 때문입니다. &lt;code&gt;data&lt;/code&gt; 에 일반 객체를 사용하면 생성 된 모든 인스턴스에서 동일한 객체가 &lt;strong&gt;참조&lt;/strong&gt; 로 &lt;strong&gt;공유됩니다&lt;/strong&gt; ! &lt;code&gt;data&lt;/code&gt; 함수 를 제공함으로써 , 새로운 인스턴스가 생성 될 때마다 호출하여 초기 데이터의 새로운 사본을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6959ec846f757993ef51859848d0ec694e4b4d8" translate="yes" xml:space="preserve">
          <source>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</source>
          <target state="translated">PascalCase로 구성 요소를 정의 할 때 해당 사용자 정의 요소를 참조 할 때 두 가지 경우 모두를 사용할 수 있습니다. 즉 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;MyComponentName&amp;gt;&lt;/code&gt; 이 모두 허용됩니다. 그러나 케밥 케이스 이름 만 DOM에서 직접 유효합니다 (즉, 문자열이 아닌 템플릿).</target>
        </trans-unit>
        <trans-unit id="11520acb769061d44c7641a4bea26df4e007c1c6" translate="yes" xml:space="preserve">
          <source>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">kebab-case로 컴포넌트를 정의 할 때 &lt;code&gt;&amp;lt;my-component-name&amp;gt;&lt;/code&gt; 과 같이 해당 사용자 정의 요소를 참조 할 때 kebab-case도 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b21b5775a35c4109c91409425882806e5dcafab" translate="yes" xml:space="preserve">
          <source>When defining components in a string template or a single-file component, you have two options when defining component names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066a19ef89f904a34f15aab25b5aa44f5d2acef0" translate="yes" xml:space="preserve">
          <source>When dynamically binding attributes on an element, a common scenario involves using both the &lt;code&gt;v-bind=&quot;object&quot;&lt;/code&gt; syntax as well as individual properties in the same element. However, this raises questions as far as the priority of merging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd74ac6287481f52e2e49b0f37a17fd417c26d06" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it&amp;rsquo;s much easier to write tests confirming that it works correctly.</source>
          <target state="translated">계산 된 각 속성에 종속성이 거의없는 매우 간단한 식만 포함 된 경우 제대로 작동하는지 확인하는 테스트를 작성하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="7941adba64b48e32e845c4386f579d258e69a4db" translate="yes" xml:space="preserve">
          <source>When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df23522a9402466e18df90100856fe06a436e73c" translate="yes" xml:space="preserve">
          <source>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b75011d4b1187e131605bb1c9cb8eb76b5decdc" translate="yes" xml:space="preserve">
          <source>When including a property name/key, the argument order for objects used to be &lt;code&gt;(name, value)&lt;/code&gt;. It is now &lt;code&gt;(value, name)&lt;/code&gt; to be more consistent with common object iterators such as lodash&amp;rsquo;s.</source>
          <target state="translated">속성 이름 / 키를 포함 할 때 객체의 인수 순서는 &lt;code&gt;(name, value)&lt;/code&gt; 입니다. lodash와 같은 일반적인 객체 반복자와보다 일관성을 유지하는 것이 이제는 &lt;code&gt;(value, name)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1bb50b705881ceba60e0753e4ec83e3bcc90e582" translate="yes" xml:space="preserve">
          <source>When including an &lt;code&gt;index&lt;/code&gt;, the argument order for arrays used to be &lt;code&gt;(index, value)&lt;/code&gt;. It is now &lt;code&gt;(value, index)&lt;/code&gt; to be more consistent with JavaScript&amp;rsquo;s native array methods such as &lt;code&gt;forEach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 를 포함 할 때 배열의 인수 순서는 &lt;code&gt;(index, value)&lt;/code&gt; 입니다. &lt;code&gt;forEach&lt;/code&gt; 및 &lt;code&gt;map&lt;/code&gt; 과 같은 JavaScript의 기본 배열 메소드와보다 일관성을 유지하는 것이 이제는 &lt;code&gt;(value, index)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c307aa08a2101632c0ad4b3a6317b17bab92e104" translate="yes" xml:space="preserve">
          <source>When it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b12026aaf6eb65059456dcbe2dfd1de583b0fb" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="translated">반복하는이 객체 위로, 순서는의 열거 순서를 기준으로 할 때 &lt;code&gt;Object.keys()&lt;/code&gt; 한다, &lt;strong&gt;하지&lt;/strong&gt; 자바 스크립트 엔진 구현에 걸쳐 일관성을 보장.</target>
        </trans-unit>
        <trans-unit id="fab3293fcdc1fc50ed0d6ad7581641eed28e2498" translate="yes" xml:space="preserve">
          <source>When iterating over an object, the order is based on the enumeration order of &lt;code&gt;Object.keys()&lt;/code&gt;, which isn't guaranteed to be consistent across JavaScript engine implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230ed0a7a0be6695cb0d232f9093b7cd6c4fcf5a" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; when listening for key events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e251d7dfd8699c3af6db56d89c3c03d6f9790c85" translate="yes" xml:space="preserve">
          <source>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for &lt;code&gt;v-on&lt;/code&gt; when listening for key events:</source>
          <target state="translated">키보드 이벤트를들을 때 종종 특정 키를 확인해야합니다. Vue를 사용하면 주요 이벤트를 수신 할 때 &lt;code&gt;v-on&lt;/code&gt; 용 키 수정자를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e11ceb78177526f054cb2e65a44b13cd1b4c54e" translate="yes" xml:space="preserve">
          <source>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special &lt;code&gt;$event&lt;/code&gt; property: &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt;.</source>
          <target state="translated">기본 DOM 이벤트를 청취 할 때 메소드는 기본 이벤트를 유일한 인수로받습니다. 인라인 명령문을 사용하는 경우 명령문은 특수 &lt;code&gt;$event&lt;/code&gt; 특성에 액세스 할 수 있습니다. &lt;code&gt;v-on:click=&quot;handle('ok', $event)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2a136029d41ad6a228327504bda8738ba0fa6e" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app&amp;rsquo;s base components are all listed together, making them easier to identify.</source>
          <target state="translated">편집기에서 사전 순으로 구성하면 앱의 기본 구성 요소가 모두 함께 나열되어 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74937f5b6caa6e834c6f6b061e657dfd695c54c2" translate="yes" xml:space="preserve">
          <source>When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def79d873f4e1bf1cac75faa9a431656147056c0" translate="yes" xml:space="preserve">
          <source>When passing arrays to query parameters the QueryString syntax is no longer &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt;, instead, the new syntax is &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt;. Internally, &lt;code&gt;$route.query.users&lt;/code&gt; will still be an Array, but if there&amp;rsquo;s only one parameter in the query: &lt;code&gt;/foo?users=Tom&lt;/code&gt;, when directly accessing this route, there&amp;rsquo;s no way for the router to know if we were expecting &lt;code&gt;users&lt;/code&gt; to be an Array. Because of this, consider adding a computed property and replacing every reference of &lt;code&gt;$route.query.users&lt;/code&gt; with it:</source>
          <target state="translated">쿼리 매개 변수에 배열을 전달할 때 QueryString 구문은 더 이상 &lt;code&gt;/foo?users[]=Tom&amp;amp;users[]=Jerry&lt;/code&gt; 가 아니며 대신 새 구문은 &lt;code&gt;/foo?users=Tom&amp;amp;users=Jerry&lt;/code&gt; 입니다. 내부적으로 &lt;code&gt;$route.query.users&lt;/code&gt; 는 여전히 배열이지만 쿼리에 매개 변수가 하나만 있으면 &lt;code&gt;/foo?users=Tom&lt;/code&gt; 이 경로에 직접 액세스 할 때 라우터가 &lt;code&gt;users&lt;/code&gt; 를 기대하는지 알 수있는 방법이 없습니다 배열입니다. 이 때문에 계산 된 속성을 추가하고 &lt;code&gt;$route.query.users&lt;/code&gt; 의 모든 참조를이를 대체하는 것을 고려 하십시오.</target>
        </trans-unit>
        <trans-unit id="c92c1efef67ab553f75dcd81d8995c7af3a57f63" translate="yes" xml:space="preserve">
          <source>When prop validation fails, Vue will produce a console warning (if using the development build).</source>
          <target state="translated">prop 유효성 검사가 실패하면 Vue는 콘솔 경고를 생성합니다 (개발 빌드를 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="101b9b9b96420f85fbf4b82db83c1e9b1572015e" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we&amp;rsquo;ve seen so far:</source>
          <target state="translated">컴포넌트를 등록 할 때 항상 이름이 부여됩니다. 예를 들어, 글로벌 등록에서 지금까지 본 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d3b8893cae1a97943ce59e8f17a3cc54c4a8d8" translate="yes" xml:space="preserve">
          <source>When registering a component, it will always be given a name. For example, in the global registration we've seen so far:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e5c326f59d187f049e28a2666c0724bc0c2933" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, will preserve and render HTML comments found in templates. The default behavior is discarding them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정하면 템플릿에서 찾은 HTML 주석이 유지되고 렌더링됩니다. 기본 동작은 버리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="abe00b8936cd06e1fda1ba07cdc78de54ed7719e" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you&amp;rsquo;ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="translated">그러나 이러한 구성 요소 간을 전환 할 때 성능상의 이유로 상태를 유지하거나 다시 렌더링하지 않는 것이 좋습니다. 예를 들어 탭 인터페이스를 약간 확장 할 때 :</target>
        </trans-unit>
        <trans-unit id="651beb4b3e6f062a8bc7db612ca2ba6b3d198430" translate="yes" xml:space="preserve">
          <source>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d915145995bbbbc905958405c390550f8e65e" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746d16bd5abc3a9c7e4d55d39555ad4b65929566" translate="yes" xml:space="preserve">
          <source>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22af2530a0066e4bf48a905ba4a853b99426fc58" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;inline-template&lt;/code&gt; special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</source>
          <target state="translated">때 &lt;code&gt;inline-template&lt;/code&gt; 특별한 속성은 하위 구성 요소에 존재하는 구성 요소는 오히려 분산 컨텐츠로 치료하는 것보다, 자신의 템플릿의 내부 콘텐츠를 사용합니다. 이를 통해보다 유연한 템플릿 작성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5c0db747b0eba54fa03d888a984d7c54baac77f8" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &quot;Add Todo&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd74cb4ecd8a9224eda5489dff9a3ea0ae979ac" translate="yes" xml:space="preserve">
          <source>When the component renders, &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; will be replaced by &amp;ldquo;Your Profile&amp;rdquo;. Slots can contain any template code, including HTML:</source>
          <target state="translated">구성 요소가 렌더링되면 &lt;code&gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&lt;/code&gt; 이&amp;ldquo;Your Profile&amp;rdquo;로 바뀝니다. 슬롯에는 HTML을 포함한 모든 템플릿 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a1dbac0913fba4e7eca7a103592962ab67125c" translate="yes" xml:space="preserve">
          <source>When the global filter has the same name as the local filter, the local filter will be preferred.</source>
          <target state="translated">글로벌 필터의 이름이 로컬 필터와 동일한 경우 로컬 필터가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="124da0bbab39c06d12e465b5be78ea53d3fc66ab" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn&amp;rsquo;t work on mobile Safari). In fact, if you haven&amp;rsquo;t clicked on anything else since visiting this page, the input above should be focused now. Now let&amp;rsquo;s build the directive that accomplishes this:</source>
          <target state="translated">페이지가로드되면 해당 요소에 초점이 맞춰집니다 (참고 : 모바일 Safari에서는 &lt;code&gt;autofocus&lt;/code&gt; 이 작동하지 않습니다). 실제로이 페이지를 방문한 후 다른 항목을 클릭하지 않은 경우 위의 입력에 초점이 맞춰져야합니다. 이제 이것을 달성하는 지시어를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="53fa055e2ff552cf0106e82aee9a9ceb3b099fb5" translate="yes" xml:space="preserve">
          <source>When the page loads, that element gains focus (note: &lt;code&gt;autofocus&lt;/code&gt; doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Also, you can click on the &lt;code&gt;Rerun&lt;/code&gt; button and input will be focused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ace105eaf0ba1d9f4079a872792b4cfa534918" translate="yes" xml:space="preserve">
          <source>When the value of &lt;code&gt;data&lt;/code&gt; is an object, it&amp;rsquo;s shared across all instances of a component. Imagine, for example, a &lt;code&gt;TodoList&lt;/code&gt; component with this data:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 값이 객체 인 경우 구성 요소의 모든 인스턴스에서 공유됩니다. 예를 &lt;code&gt;TodoList&lt;/code&gt; 데이터가 있는 TodoList 컴포넌트를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c971f0813e2512d2a41d743091482019c0669839" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only &lt;em&gt;some&lt;/em&gt; items, like below:</source>
          <target state="translated">동일한 노드에 존재하는 경우 &lt;code&gt;v-for&lt;/code&gt; 가 &lt;code&gt;v-if&lt;/code&gt; 보다 우선 순위가 높습니다 . 즉 , 루프의 각 반복 에서 &lt;code&gt;v-if&lt;/code&gt; 가 개별적으로 실행됩니다. 아래처럼 &lt;em&gt;일부&lt;/em&gt; 아이템 에 대해서만 노드를 렌더링 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="4b3806336239800c5ec794a9d3907163b07e9915" translate="yes" xml:space="preserve">
          <source>When they exist on the same node, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. That means the &lt;code&gt;v-if&lt;/code&gt; condition will not have access to variables from the scope of the &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c810013903d2f4032babdbbdae77af65f2830a27" translate="yes" xml:space="preserve">
          <source>When this data changes, the view will re-render. It should be noted that properties in &lt;code&gt;data&lt;/code&gt; are only &lt;strong&gt;reactive&lt;/strong&gt; if they existed when the instance was created. That means if you add a new property, like:</source>
          <target state="translated">이 데이터가 변경되면보기가 다시 렌더링됩니다. &lt;code&gt;data&lt;/code&gt; 속성 은 인스턴스가 생성 될 때 존재 &lt;strong&gt;하는&lt;/strong&gt; 경우 에만 &lt;strong&gt;반응&lt;/strong&gt; 한다는 점에 유의해야합니다 . 즉, 다음과 같은 새 속성을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8672efd0617cd888d9bb1e3c737957074d1bc51c" translate="yes" xml:space="preserve">
          <source>When this method is called on the same plugin multiple times, the plugin will be installed only once.</source>
          <target state="translated">이 메소드가 동일한 플러그인에서 여러 번 호출되면 플러그인은 한 번만 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="8c57990092bff4c63af046b16e646096a1592578" translate="yes" xml:space="preserve">
          <source>When toggling between elements that have &lt;strong&gt;the same tag name&lt;/strong&gt;, you must tell Vue that they are distinct elements by giving them unique &lt;code&gt;key&lt;/code&gt; attributes. Otherwise, Vue&amp;rsquo;s compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, &lt;strong&gt;it&amp;rsquo;s considered good practice to always key multiple items within a &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; component.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;태그 이름이 동일한&lt;/strong&gt; 요소를 전환 할 때 Vue에 고유 한 &lt;code&gt;key&lt;/code&gt; 속성 을 부여하여 고유 한 요소임을 Vue에 알려야 합니다. 그렇지 않으면 Vue의 컴파일러는 효율성을 위해 요소의 내용 만 바꿉니다. 기술적으로 불필요 할 때에도 &lt;strong&gt;항상 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 구성 요소 내에 여러 항목을 입력하는 것이 좋습니다 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4fd996911a0f54f846028a84e8762021497009a" translate="yes" xml:space="preserve">
          <source>When typing a &lt;code&gt;reactive&lt;/code&gt; property, we can use interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc2b25beebdd34dc380c9fd23b43f7c65cc4486" translate="yes" xml:space="preserve">
          <source>When used for prop binding, the prop must be properly declared in the child component.</source>
          <target state="translated">소품 바인딩에 사용될 때는 소품이 하위 구성 요소에 올바르게 선언되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="48c747cb7a6755cfb07e7973db15c1ed5c7e3ffd" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-model&lt;/code&gt; instead does this:</source>
          <target state="translated">구성 요소에서 사용될 때 &lt;code&gt;v-model&lt;/code&gt; 은 대신 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="64fca958e73a8a2c2d35d431e6c2e83b1da085a6" translate="yes" xml:space="preserve">
          <source>When used on a component, &lt;code&gt;v-on&lt;/code&gt; now only listens to custom events &lt;code&gt;$emit&lt;/code&gt;ted by that component. To listen for a native DOM event on the root element, you can use the &lt;code&gt;.native&lt;/code&gt; modifier. For example:</source>
          <target state="translated">구성 요소에 사용하는 경우, &lt;code&gt;v-on&lt;/code&gt; 이제 사용자 정의 이벤트를 수신 &lt;code&gt;$emit&lt;/code&gt; 해당 구성 요소에 의해 테드. 루트 요소에서 기본 DOM 이벤트를 수신하려면 &lt;code&gt;.native&lt;/code&gt; 수정자를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39c2818e21858b65998b9cb9c792d34b526f9165" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt; (opens new window)&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e820aca19dc00b200ff77d1c2279ec5f556dff" translate="yes" xml:space="preserve">
          <source>When used on a normal element, it listens to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;native DOM events&lt;/strong&gt;&lt;/a&gt; only. When used on a custom element component, it listens to &lt;strong&gt;custom events&lt;/strong&gt; emitted on that child component.</source>
          <target state="translated">일반 요소에서 사용될 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;&lt;strong&gt;원시 DOM 이벤트&lt;/strong&gt;&lt;/a&gt; 만 청취합니다 . 사용자 정의 요소 구성 요소에서 사용될 때 해당 하위 구성 요소에서 생성 된 &lt;strong&gt;사용자 정의 이벤트를&lt;/strong&gt; 청취합니다 .</target>
        </trans-unit>
        <trans-unit id="7424a99bcccbebcb1704239527c00d6ecfad0963" translate="yes" xml:space="preserve">
          <source>When used on components, custom directive will always apply to component's root node, similarly to &lt;a href=&quot;component-attrs&quot;&gt;non-prop attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6354ba0509e976f620f5684a0ecbdb3c62711b" translate="yes" xml:space="preserve">
          <source>When used on elements/components with &lt;code&gt;v-for&lt;/code&gt;, the registered reference will be an Array containing DOM nodes or component instances.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 가있는 요소 / 컴포넌트에서 사용될 경우 등록 된 참조는 DOM 노드 또는 컴포넌트 인스턴스를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f4a7dad4c6cfc5b01fc8733a0ec4ecb22ab51d3e" translate="yes" xml:space="preserve">
          <source>When used on normal components, it will behave like a normal prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e732a1c52ca8cf754429434fdc2c9d76e59a40b" translate="yes" xml:space="preserve">
          <source>When used on plain elements, it will be passed to the &lt;code&gt;createElement&lt;/code&gt; call as the &lt;code&gt;is&lt;/code&gt; option, and also rendered as a native attribute. This supports the usage of customized built-in elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351a36d6e4d3bd7a9ce7236de933a0d2d3934ac" translate="yes" xml:space="preserve">
          <source>When used on the reserved &lt;code&gt;&amp;lt;component&amp;gt;&lt;/code&gt; tag, it will behave exactly the same as in 2.x;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765016b97659c6d561b95942c108d740532eb2f6" translate="yes" xml:space="preserve">
          <source>When used to bind the &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;style&lt;/code&gt; attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;style&lt;/code&gt; 속성 을 바인딩하는 데 사용되는 경우 배열 또는 객체와 같은 추가 값 유형을 지원합니다. 자세한 내용은 아래 링크 된 가이드 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3aa4f6aa06672812c020dc14f091831d9a5bfaff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, make sure to nest it inside:</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 함께 사용하는 경우 다음과 같이 중첩하십시오.</target>
        </trans-unit>
        <trans-unit id="d2004737a99c7cd400658a4b50d801ecb378d7ff" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;v-if&lt;/code&gt;, &lt;code&gt;v-for&lt;/code&gt; has a higher priority than &lt;code&gt;v-if&lt;/code&gt;. See the &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">함께 사용될 때, &lt;code&gt;v-if&lt;/code&gt; , &lt;code&gt;v-for&lt;/code&gt; 보다 높은 우선 순위 갖는 &lt;code&gt;v-if&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;list#v-for-with-v-if&quot;&gt;목록 렌더링 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bee43712dd211f1c35df632055f8887b9d1cfc4e" translate="yes" xml:space="preserve">
          <source>When used together with v-if, v-for has a higher priority than v-if. See the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="translated">v-if와 함께 사용하면 v-for가 v-if보다 우선 순위가 높습니다. 자세한 내용은 &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;목록 렌더링 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5bb95376e672859dca4d4310ff771e83f090090" translate="yes" xml:space="preserve">
          <source>When used together, &lt;code&gt;v-if&lt;/code&gt; has a higher priority than &lt;code&gt;v-for&lt;/code&gt;. We don't recommend using these two directives together on one element &amp;mdash; see the &lt;a href=&quot;../guide/list#v-for-with-v-if&quot;&gt;list rendering guide&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be5b9382ac62c19c6f4c6d35f193f4842773377" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;v-bind&lt;/code&gt;, the only falsy values are now: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt;. This means &lt;code&gt;0&lt;/code&gt; and empty strings will render as truthy. So for example, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; will render as &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 와 함께 사용하면 이제 잘못된 값은 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;undefined&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 입니다. 이것은 &lt;code&gt;0&lt;/code&gt; 을 의미 하며 빈 문자열은 진실로 렌더링됩니다. 예를 들어, &lt;code&gt;v-bind:draggable=&quot;''&quot;&lt;/code&gt; 은 &lt;code&gt;draggable=&quot;true&quot;&lt;/code&gt; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="73d22b936f5f6ffa1364c72049c04fab5ebd1aad" translate="yes" xml:space="preserve">
          <source>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; does not support Array or Objects.</source>
          <target state="translated">인수없이 사용하면 속성 이름-값 쌍을 포함하는 객체를 바인딩하는 데 사용할 수 있습니다. 이 모드에서 &lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;style&lt;/code&gt; 은 배열 또는 객체를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c92b86613bb50d0d3909045ae62372cbd0ba73dc" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../api/options-data#watch&quot;&gt;the &lt;code&gt;watch&lt;/code&gt; option&lt;/a&gt; to watch an array, the callback will only trigger when the array is replaced. In other words, the watch callback will no longer be triggered on array mutation. To trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37ce001f85a01806e0a868532afd28214a23c8d" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../guide/component-registration#local-registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c790db75231ac4e455c32a062aaa4b55e184839b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;components-registration#Local-Registration&quot;&gt;local registration&lt;/a&gt;, you can also directly provide a function that returns a &lt;code&gt;Promise&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;components-registration#Local-Registration&quot;&gt;로컬 등록을&lt;/a&gt; 사용할 때 &lt;code&gt;Promise&lt;/code&gt; 를 반환하는 함수를 직접 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="155dd72290bb5a75b47cd1b727e2637716b8c1c8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;inject&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we also need to explicitly import it from &lt;code&gt;vue&lt;/code&gt;. Once we do so, this allows us to invoke it to define how we want to expose it to our component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71dd171ffdf07ffc560f972b60c7a451789477b7" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;provide&lt;/code&gt; in &lt;code&gt;setup()&lt;/code&gt;, we start by explicitly importing the method from &lt;code&gt;vue&lt;/code&gt;. This allows us to define each property with its own invocation of &lt;code&gt;provide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99c3ac076c214df02b2fff4ef44f92751d560253" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt; or &lt;code&gt;vueify&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="translated">&lt;code&gt;vue-loader&lt;/code&gt; 또는 &lt;code&gt;vueify&lt;/code&gt; 를 사용할 때 &lt;code&gt;*.vue&lt;/code&gt; 파일 내의 템플릿 은 빌드시 JavaScript로 사전 컴파일됩니다. 최종 번들에 컴파일러가 실제로 필요하지 않으므로 런타임 전용 빌드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49fe6055e1baf5ecb1fa9c79e5109c02c820ea28" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;vue-loader&lt;/code&gt;, templates inside &lt;code&gt;*.vue&lt;/code&gt; files are pre-compiled into JavaScript at build time. You don&amp;rsquo;t really need the compiler in the final bundle, and can therefore use the runtime-only build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2867cff36a3fe6d83bd3572deaa22405cc206f8" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately.</source>
          <target state="translated">JavaScript 전용 전환을 사용 &lt;strong&gt;하는 경우 &lt;code&gt;done&lt;/code&gt; 콜백이 &lt;code&gt;enter&lt;/code&gt; 및 &lt;code&gt;leave&lt;/code&gt; 훅에 필요합니다&lt;/strong&gt; . 그렇지 않으면 후크가 동 기적으로 호출되고 전환이 즉시 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="492a825e70975417fd58f060648eb43809c5835c" translate="yes" xml:space="preserve">
          <source>When using JavaScript-only transitions, &lt;strong&gt;the &lt;code&gt;done&lt;/code&gt; callbacks are required for the &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; hooks&lt;/strong&gt;. Otherwise, the hooks will be called synchronously and the transition will finish immediately. Adding &lt;code&gt;:css=&quot;false&quot;&lt;/code&gt; will also let Vue know to skip CSS detection. Aside from being slightly more performant, this also prevents CSS rules from accidentally interfering with the transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8e11afcc19c58163c7f043d414ef7a0a2eb199" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &quot;flash of unstyled content&quot;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fb89cebf9e12b8e890d2c8212be0ff387c7a63" translate="yes" xml:space="preserve">
          <source>When using Single-File Components, the CSS inside components are injected dynamically as &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &amp;ldquo;flash of unstyled content&amp;rdquo;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</source>
          <target state="translated">단일 파일 구성 요소를 사용하는 경우 구성 요소 내부의 CSS는 JavaScript를 통해 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그 로 동적으로 주입됩니다 . 이는 런타임 비용이 적으며 서버 측 렌더링을 사용하는 경우 &quot;스타일이 지정되지 않은 컨텐츠의 플래시&quot;가 발생합니다. 모든 구성 요소에서 CSS를 동일한 파일로 추출하면 이러한 문제가 발생하지 않으며 CSS 축소 및 캐싱 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae9007703022fa5cb7c0cd322bf3a50ec4cecf4" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools (opens new window)&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552be3178df5885d9ef1af398d3a7802f9917a44" translate="yes" xml:space="preserve">
          <source>When using Vue, we recommend also installing the &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</source>
          <target state="translated">Vue를 사용하는 경우 &lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot;&gt;Vue Devtools&lt;/a&gt; 를 브라우저에 설치하여 보다 사용자 친화적 인 인터페이스에서 Vue 응용 프로그램을 검사하고 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83ec783173aead30ee96ed5f55121a4a391b2b2" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue&amp;rsquo;s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue&amp;rsquo;s production mode, and warnings will be stripped by minifiers during the build. All &lt;code&gt;vue-cli&lt;/code&gt; templates have these pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="translated">Webpack 또는 Browserify와 같은 빌드 도구를 사용하는 경우 프로덕션 모드는 Vue 소스 코드 내의 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 에 의해 결정 되며 기본적으로 개발 모드에 있습니다. 두 빌드 도구 모두 Vue의 프로덕션 모드를 활성화하기 위해이 변수를 덮어 쓰는 방법을 제공하며 빌드 중에 축소 기에서 경고가 제거됩니다. 모든 &lt;code&gt;vue-cli&lt;/code&gt; 템플릿에는 미리 구성되어 있지만 어떻게 수행되는지 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="73ab3894a5373b24631fe2355bde56549085fb2c" translate="yes" xml:space="preserve">
          <source>When using a build tool like Webpack or Browserify, the production mode will be determined by &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. Vue CLI has this pre-configured for you, but it would be beneficial to know how it is done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7feb3981a84943e5fbab5765c5ec53aded8a95c4" translate="yes" xml:space="preserve">
          <source>When using buttons inside a form, you must set the type to prevent submitting the form. You can also use an input to create buttons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90059bdf6364a692356bb5121dc518a09307b6ec" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</source>
          <target state="translated">DOM 내 템플릿 (HTML 파일로 직접 작성된 템플릿)을 사용하는 경우 브라우저가 속성 이름을 소문자로 강제 변환하므로 대문자로 키 이름을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9f49b04be3603b07dc0618756118b73addc7b4bc" translate="yes" xml:space="preserve">
          <source>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</source>
          <target state="translated">DOM 내 템플릿 또는 JavaScript 템플릿 문자열을 사용하는 경우 템플릿 간 렌더링 기능 컴파일이 즉시 수행됩니다. 대개 대부분의 경우 빠르지 만 응용 프로그램이 성능에 민감한 경우에는 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="52a194f1e41a6a5db000b3e319f51a2d953f4422" translate="yes" xml:space="preserve">
          <source>When using outside of &lt;a href=&quot;#setup&quot;&gt;setup&lt;/a&gt; or &lt;a href=&quot;#lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt;, please call &lt;code&gt;getCurrentInstance()&lt;/code&gt; on &lt;code&gt;setup&lt;/code&gt; and use the instance instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8268513fd3714a6bb1e18655deb42d64d8195501" translate="yes" xml:space="preserve">
          <source>When using reactive provide / inject values, &lt;strong&gt;it is recommended to keep any mutations to reactive properties inside of the &lt;em&gt;provider&lt;/em&gt; whenever possible&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a50aa13ab45b9b9f84e07dc20f120967762dc9a" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;data&lt;/code&gt; property on a component (i.e. anywhere except on &lt;code&gt;new Vue&lt;/code&gt;), the value must be a function that returns an object.</source>
          <target state="translated">컴포넌트 에서 &lt;code&gt;data&lt;/code&gt; 속성을 사용할 때 (예 : &lt;code&gt;new Vue&lt;/code&gt; 제외 ) 값은 객체를 반환하는 함수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="29cfa5029bb45e9515038e53406ba42c15ddb95c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;setup&lt;/code&gt; function, it will take two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe17ea531d76bcff516416b2c63a3806ff1db39b" translate="yes" xml:space="preserve">
          <source>When using the Composition API, the concept of &lt;a href=&quot;reactivity-fundamentals#creating-standalone-reactive-values-as-refs&quot;&gt;reactive refs&lt;/a&gt; and &lt;a href=&quot;component-template-refs&quot;&gt;template refs&lt;/a&gt; are unified. In order to obtain a reference to an in-template element or component instance, we can declare a ref as usual and return it from &lt;a href=&quot;composition-api-setup&quot;&gt;setup()&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2325636eb7899967fe90bf565cfdf8509e2423d9" translate="yes" xml:space="preserve">
          <source>When using the render function, i.e., &lt;code&gt;h&lt;/code&gt;, 2.x used to define the &lt;code&gt;slot&lt;/code&gt; data property on the content nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b53ab6a7a09c723aad6b1a3af71ea61e4b6a3b8" translate="yes" xml:space="preserve">
          <source>When using this component inside the initial HTML structure, we can see a problem - the modal is being rendered inside the deeply nested &lt;code&gt;div&lt;/code&gt; and the &lt;code&gt;position: absolute&lt;/code&gt; of the modal takes the parent relatively positioned &lt;code&gt;div&lt;/code&gt; as reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b443edf845e80ba0a827955e7f9e75dfd908e2cd" translate="yes" xml:space="preserve">
          <source>When watched value is an object or array, any changes to its properties or elements won't trigger the watcher because they reference the same object/array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3115fa755473f700797db8a3eaa25ac70279399a" translate="yes" xml:space="preserve">
          <source>When watching an array, the callback will only trigger when the array is replaced. If you need to trigger on mutation, the &lt;code&gt;deep&lt;/code&gt; option must be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac33dbea1192d62c5d6e524087e525e604c224b" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="translated">버튼을 클릭하면 모든 게시물의 텍스트를 확대해야한다는 부모와 통신해야합니다. 다행히 Vue 인스턴스는이 문제를 해결하기 위해 사용자 지정 이벤트 시스템을 제공합니다. 부모는 네이티브 DOM 이벤트와 마찬가지로 &lt;code&gt;v-on&lt;/code&gt; 을 사용하여 자식 구성 요소 인스턴스의 모든 이벤트를 수신하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56b6480e99f62d0b0a2594baeb4025339f0556be" translate="yes" xml:space="preserve">
          <source>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. To solve this problem, component instances provide a custom events system. The parent can choose to listen to any event on the child component instance with &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;, just as we would with a native DOM event:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503e44cb3c820763078d2ca02c03c4a8a431e8d6" translate="yes" xml:space="preserve">
          <source>When we defined the &lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; component, you may have noticed that &lt;code&gt;data&lt;/code&gt; wasn&amp;rsquo;t directly provided an object, like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;button-counter&amp;gt;&lt;/code&gt; 구성 요소를 정의 할 때 다음과 같이 &lt;code&gt;data&lt;/code&gt; 가 오브젝트를 직접 제공하지 않은 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07b462f32af9d739921941c237aa3a2d6e82914c" translate="yes" xml:space="preserve">
          <source>When we want to use a few properties of the large reactive object, it could be tempting to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 destructuring (opens new window)&lt;/a&gt; to get properties we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25563d9cbbe500885b8017f11094dbe20ce5416" translate="yes" xml:space="preserve">
          <source>When we were learning about form input bindings, we saw that &lt;code&gt;v-model&lt;/code&gt; has &lt;a href=&quot;forms#modifiers&quot;&gt;built-in modifiers&lt;/a&gt; - &lt;code&gt;.trim&lt;/code&gt;, &lt;code&gt;.number&lt;/code&gt; and &lt;code&gt;.lazy&lt;/code&gt;. In some cases, however, you might also want to add your own custom modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc31d9024fc1569b72c4369fcb0a381a7a9ef3d" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn&amp;rsquo;t render a DOM element itself, and doesn&amp;rsquo;t show up in the component parent chain.</source>
          <target state="translated">동적 구성 요소를 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 는 비활성 구성 요소 인스턴스를 손상시키지 않고 캐시합니다. &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 마찬가지로 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 는 추상 구성 요소입니다. DOM 요소 자체를 렌더링하지 않으며 구성 요소 상위 체인에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6024fe4000d9406c04c3b8e635b2733012f8d604" translate="yes" xml:space="preserve">
          <source>When wrapped around a dynamic component, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; caches the inactive component instances without destroying them. Similar to &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8cb2aa251b532a1099571f894888303ae87f928" translate="yes" xml:space="preserve">
          <source>When you create a Vue instance, you pass in an &lt;strong&gt;options object&lt;/strong&gt;. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">Vue 인스턴스를 만들 때 &lt;strong&gt;옵션 객체&lt;/strong&gt; 를 전달 &lt;strong&gt;합니다&lt;/strong&gt; . 이 안내서의 대부분은 이러한 옵션을 사용하여 원하는 동작을 만드는 방법을 설명합니다. 참조를 위해 &lt;a href=&quot;../api/index#Options-Data&quot;&gt;API 참조 서&lt;/a&gt; 에서 전체 옵션 목록을 찾아 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5edfa6e15cc3b92cf84e0d23dc57525471bb32f0" translate="yes" xml:space="preserve">
          <source>When you directly set an item with the index, e.g. &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</source>
          <target state="translated">색인을 사용하여 항목을 직접 설정하는 경우 (예 : &lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e05eb2c179f008e282eb11dbfab780273bd17af" translate="yes" xml:space="preserve">
          <source>When you get started with a component that only generates a heading based on the &lt;code&gt;level&lt;/code&gt; prop, you quickly arrive at this:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 소품을 기준으로 제목 만 생성하는 구성 요소를 시작하면 다음과 같이 빠르게 도달합니다.</target>
        </trans-unit>
        <trans-unit id="83380da98aaeb039f4a9465908493672dd7cb6c2" translate="yes" xml:space="preserve">
          <source>When you look closely, you&amp;rsquo;ll see that these components will actually be each other&amp;rsquo;s descendent &lt;em&gt;and&lt;/em&gt; ancestor in the render tree - a paradox! When registering components globally with &lt;code&gt;Vue.component&lt;/code&gt;, this paradox is resolved for you automatically. If that&amp;rsquo;s you, you can stop reading here.</source>
          <target state="translated">자세히 살펴보면 이러한 구성 요소가 실제로 렌더링 트리에서 서로의 후손 &lt;em&gt;이자&lt;/em&gt; 조상이 될 것입니다 . &lt;code&gt;Vue.component&lt;/code&gt; 를 사용 하여 컴포넌트를 전역으로 등록하면 이 역설이 자동으로 해결됩니다. 그게 너라면 여기에서 더 이상 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30f5b44a5fc3fcf76c6bc5c1c85bd3a58259448" translate="yes" xml:space="preserve">
          <source>When you modify the length of the array, e.g. &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</source>
          <target state="translated">배열의 길이를 수정하면 (예 : &lt;code&gt;vm.items.length = newLength&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="116f534bd5f4250bf1748ab421ed8f10e572e2f6" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to a Vue instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter/setters&lt;/a&gt; using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/a&gt;. This is an ES5-only and un-shimmable feature, which is why Vue doesn&amp;rsquo;t support IE8 and below.</source>
          <target state="translated">일반 JavaScript 객체를 &lt;code&gt;data&lt;/code&gt; 옵션 으로 Vue 인스턴스에 전달하면 Vue는 모든 속성 을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters&quot;&gt;getter / setter&lt;/a&gt; 로 변환합니다 . 이것은 ES5 전용이며 shimable 기능이 아니기 때문에 Vue는 IE8 이하를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="933b3b1c3bc981ed309ab3c1c26b343f83550c6c" translate="yes" xml:space="preserve">
          <source>When you pass a plain JavaScript object to an application or component instance as its &lt;code&gt;data&lt;/code&gt; option, Vue will walk through all of its properties and convert them to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy&quot;&gt;Proxies (opens new window)&lt;/a&gt; using a handler with getters and setters. This is an ES6-only feature, but we offer a version of Vue 3 that uses the older &lt;code&gt;Object.defineProperty&lt;/code&gt; to support IE browsers. Both have the same surface API, but the Proxy version is slimmer and offers improved performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc08c055658d2907306b28227fc08089b9c9d0b" translate="yes" xml:space="preserve">
          <source>When you pass an object to a component instance as data, Vue converts it to a proxy. This proxy enables Vue to perform dependency-tracking and change-notification when properties are accessed or modified. Each property is considered a dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b263fbf80fd17168172064fb809118419b3f90b" translate="yes" xml:space="preserve">
          <source>When you register a component globally using &lt;code&gt;Vue.component&lt;/code&gt;, the global ID is automatically set as the component&amp;rsquo;s &lt;code&gt;name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;Vue.component&lt;/code&gt; 를 사용하여 컴포넌트를 글로벌로 등록 하면 글로벌 ID가 컴포넌트의 &lt;code&gt;name&lt;/code&gt; 옵션 으로 자동 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a59415917e0f7bce0c1e1ce588bc65642dde4e2" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e99dda28553577f5a72c70f4cf761e117d5aa05" translate="yes" xml:space="preserve">
          <source>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn&amp;rsquo;t directly stored as a number, like any valid CSS color for example? Here&amp;rsquo;s how we could accomplish this with &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; and &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js&lt;/a&gt;:</source>
          <target state="translated">숫자를 업데이트하면 입력 아래에 변경 내용이 표시됩니다. 이것은 좋은 데모를 만들지 만 유효한 CSS 색상과 같이 숫자로 직접 저장되지 않은 것은 어떻습니까? &lt;a href=&quot;https://github.com/tweenjs/tween.js&quot;&gt;Tween.js&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/brehaut/color-js&quot;&gt;Color.js &lt;/a&gt;로이를 달성하는 방법은 다음 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e0e5cc8bd4dbd3f0f73f17bc44dd88fc965b701e" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes (opens new window)&lt;/a&gt; in &lt;code&gt;:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2b512d3d14fbcaa1fe4759c2ac6d6267d1b944" translate="yes" xml:space="preserve">
          <source>When you use a CSS property that requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;vendor prefixes&lt;/a&gt; in &lt;code&gt;v-bind:style&lt;/code&gt;, for example &lt;code&gt;transform&lt;/code&gt;, Vue will automatically detect and add appropriate prefixes to the applied styles.</source>
          <target state="translated">&lt;code&gt;v-bind:style&lt;/code&gt; 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix&quot;&gt;공급 업체 접두사&lt;/a&gt; 가 필요한 CSS 속성 ( 예 : &lt;code&gt;transform&lt;/code&gt; )을 사용 하면 Vue가 자동으로 적용된 스타일에 적절한 접두사를 감지하고 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b1215d8f619fb72cc267754d02609941e493e8b" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component with a single root element, those classes will be added to this element. Existing classes on this element will not be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b326885055699fce588d56dd25601619eb5af2c" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;class&lt;/code&gt; attribute on a custom component, those classes will be added to the component&amp;rsquo;s root element. Existing classes on this element will not be overwritten.</source>
          <target state="translated">사용자 컴포넌트 에서 &lt;code&gt;class&lt;/code&gt; 속성 을 사용하면 해당 클래스가 컴포넌트의 루트 요소에 추가됩니다. 이 요소의 기존 클래스는 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b29e2633e0031493fdfbbbfa60e0c5563fa25e4d" translate="yes" xml:space="preserve">
          <source>When you want to use data inside a slot, such as in:</source>
          <target state="translated">다음과 같이 슬롯 내부의 데이터를 사용하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5224afaf87d02d75b63b7c58580593c3450a4bdb" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;counter&lt;/code&gt; is modified, for example &lt;code&gt;counter.value = 5&lt;/code&gt;, the watch will trigger and execute the callback (second argument) which in this case will log &lt;code&gt;'The new counter value is: 5'&lt;/code&gt; into our console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd9221b01210b73d5a5bf23b096d0f97ea0e9fb" translate="yes" xml:space="preserve">
          <source>Whenever there are multiple slots, use the full &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; based syntax for &lt;em&gt;all&lt;/em&gt; slots:</source>
          <target state="translated">슬롯이 여러 개인 경우 &lt;em&gt;모든&lt;/em&gt; 슬롯에 대해 전체 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 기반 구문을 사용 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3c59757a70411453c39e9877f5bd40fa36fe8fd5" translate="yes" xml:space="preserve">
          <source>Whenever this plugin is added to an application, the &lt;code&gt;install&lt;/code&gt; method will be called if it is an object. If it is a &lt;code&gt;function&lt;/code&gt;, the function itself will be called. In both cases, it will receive two parameters - the &lt;code&gt;app&lt;/code&gt; object resulting from Vue's &lt;code&gt;createApp&lt;/code&gt;, and the options passed in by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a8989fc5605591725bf2c16d034ac1a8557ebb" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you&amp;rsquo;re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="translated">동일하고 좋은 옵션이 여러 개있는 경우 일관성을 유지하기 위해 임의의 선택을 할 수 있습니다. 이 규칙에서는 허용 가능한 각 옵션을 설명하고 기본 선택을 제안합니다. 이는 일관성 있고 합당한 이유가있는 한 자신의 코드베이스에서 다른 선택을 자유롭게 할 수 있음을 의미합니다. 그래도 좋은 이유가 있으십시오! 커뮤니티 표준에 적응하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40389be7b40b64109eb2a221c81a64962b25ce29" translate="yes" xml:space="preserve">
          <source>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c156561396e2c0ff843d5dfefecf7d5f00b748" translate="yes" xml:space="preserve">
          <source>Where should I start in a migration?</source>
          <target state="translated">마이그레이션은 어디에서 시작해야합니까?</target>
        </trans-unit>
        <trans-unit id="a916519a784aae97a6a144ef6d4aef7bf8304468" translate="yes" xml:space="preserve">
          <source>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using &lt;code&gt;v-if&lt;/code&gt; and &lt;code&gt;v-for&lt;/code&gt;:</source>
          <target state="translated">일반 JavaScript로 쉽게 수행 할 수있는 곳이라면 Vue 렌더 함수는 독점적 인 대안을 제공하지 않습니다. 예를 들어, &lt;code&gt;v-if&lt;/code&gt; 및 &lt;code&gt;v-for&lt;/code&gt; 를 사용하는 템플릿 에서 :</target>
        </trans-unit>
        <trans-unit id="5cd4ca7066a7f80f437ded62b2c4ba106bff4e1c" translate="yes" xml:space="preserve">
          <source>Whether the current Vue instance is running on the server.</source>
          <target state="translated">현재 Vue 인스턴스가 서버에서 실행 중인지 여부</target>
        </trans-unit>
        <trans-unit id="2496f7d91335bdaa5a94c0ccf88817d25c97566b" translate="yes" xml:space="preserve">
          <source>Which can be used in the template to control the font size of all blog posts:</source>
          <target state="translated">템플릿에서 모든 블로그 게시물의 글꼴 크기를 제어하는 ​​데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f372ca77a18336d9ceb38b597b82fab9d460d4" translate="yes" xml:space="preserve">
          <source>Which could also be written as:</source>
          <target state="translated">다음과 같이 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f641e57e62a95de7443f1d301628bdc0504168b" translate="yes" xml:space="preserve">
          <source>Which might render something like:</source>
          <target state="translated">다음과 같이 렌더링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6dc1e7242ce0f196ee79154bfdd52a6d576a6b3" translate="yes" xml:space="preserve">
          <source>Which obsolete features you&amp;rsquo;re using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you&amp;rsquo;re not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</source>
          <target state="translated">사용중인 더 이상 사용되지 않는 기능 대부분은 찾기 및 바꾸기로 업그레이드 할 수 있지만 몇 분 정도 걸릴 수 있습니다. 현재 모범 사례를 따르지 않는 경우 Vue 2.0은 강제로 더 열심히 노력할 것입니다. 이것은 장기적으로는 좋은 일이지만 중요한 리팩토링을 의미 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="13542c96e2b2982abdd966332d81cd761c716dab" translate="yes" xml:space="preserve">
          <source>Which will render:</source>
          <target state="translated">렌더링됩니다 :</target>
        </trans-unit>
        <trans-unit id="411f7634e21861007457debbcec0bcc5996eff6a" translate="yes" xml:space="preserve">
          <source>While Vue scales up just as well as React, it also scales down just as well as jQuery. That&amp;rsquo;s right - to get started, all you have to do is drop a single script tag into the page:</source>
          <target state="translated">Vue는 React와 마찬가지로 확장되지만 jQuery와 마찬가지로 축소됩니다. 맞습니다. 시작하려면 단일 스크립트 태그를 페이지에 놓기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="67526a3ad5381ad5a3d17e38178b4ebbd75ccade" translate="yes" xml:space="preserve">
          <source>While Vue.js does not natively support mobile app development, there are a number of solutions for creating native iOS and Android apps with Vue.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d93357bd259acbade7c18b02dac0a7c343f7e5" translate="yes" xml:space="preserve">
          <source>While all the examples on this page only need a single component, most real applications are organized into a tree of nested, reusable components. For example, a Todo application's component tree might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0753de87f790a1e2f19722cd77fe0ca388129290" translate="yes" xml:space="preserve">
          <source>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to &lt;em&gt;avoiding&lt;/em&gt; spaces, making attribute values less readable.</source>
          <target state="translated">공백이없는 속성 값은 HTML에 따옴표가 필요하지 않지만,이 방법은 종종 공백 을 &lt;em&gt;피하여&lt;/em&gt; 속성 값을 읽기 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d1be13562f7dcc7da151626387e08df77b338b25" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That&amp;rsquo;s why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="translated">대부분의 경우 계산 된 속성이 더 적합하지만 사용자 지정 감시자가 필요한 경우가 있습니다. 그렇기 때문에 Vue가 &lt;code&gt;watch&lt;/code&gt; 옵션을 통해 데이터 변경에 반응하는보다 일반적인 방법을 제공합니다 . 데이터 변경에 대한 응답으로 비동기식 또는 값 비싼 작업을 수행하려는 경우 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fd4fac6fce5850105ed2b54389e0980507751bfb" translate="yes" xml:space="preserve">
          <source>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the &lt;code&gt;watch&lt;/code&gt; option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58ceb4be486c0d3bcb8a6914f2874907486034f" translate="yes" xml:space="preserve">
          <source>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd77b96c3d24d46385ee19732ac45b61f33bee8a" translate="yes" xml:space="preserve">
          <source>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8785c918b15353f580978dd18459f72bc2edbf02" translate="yes" xml:space="preserve">
          <source>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can&amp;rsquo;t always foresee the contexts in which their components might be used. That&amp;rsquo;s why components can accept arbitrary attributes, which are added to the component&amp;rsquo;s root element.</source>
          <target state="translated">명시 적으로 정의 된 소품은 정보를 자식 구성 요소에 전달하는 데 선호되지만 구성 요소 라이브러리 작성자는 해당 구성 요소가 사용될 수있는 컨텍스트를 항상 예측할 수는 없습니다. 그렇기 때문에 컴포넌트가 컴포넌트의 루트 요소에 추가되는 임의의 속성을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c06ac05b4fad90251fe1178ba3f0d2779deb1c" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it&amp;rsquo;s clear that this isn&amp;rsquo;t one of them. So let&amp;rsquo;s try rewriting it with a &lt;code&gt;render&lt;/code&gt; function:</source>
          <target state="translated">템플릿은 대부분의 구성 요소에 적합하지만이 중 하나가 아님은 분명합니다. &lt;code&gt;render&lt;/code&gt; 함수로 다시 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="dccd95c62bd449380bb4f7810be214fe6f2cc294" translate="yes" xml:space="preserve">
          <source>While templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a &lt;code&gt;render()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f53a61720d34f8deb200583fb4293a0b28f026" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4a80a732fb32a76bcecd383d1d0a7ebd43cd2" translate="yes" xml:space="preserve">
          <source>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d958d9d37ed58a5f1f97ee679c1620d781626e" translate="yes" xml:space="preserve">
          <source>While this approach is convenient, it leads to a couple of problems. Technically, Vue 2 doesn't have a concept of an &quot;app&quot;. What we define as an app is simply a root Vue instance created via &lt;code&gt;new Vue()&lt;/code&gt;. Every root instance created from the same Vue constructor &lt;strong&gt;shares the same global configuration&lt;/strong&gt;. As a result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26388458f8fca7cd6a63de038df2a21f485dd436" translate="yes" xml:space="preserve">
          <source>While this seems like a convenience, it requires a custom syntax that breaks the assumption of expressions inside of curly braces being &quot;just JavaScript,&quot; which has both learning and implementation costs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaa3f23ca2ee3059b2128051891a6ae3197f8a2" translate="yes" xml:space="preserve">
          <source>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008a9bd1fd351881294a8ab7c58eff00ecd921e6" translate="yes" xml:space="preserve">
          <source>Why Composition API?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4c575b6d22f5470b02ebf75178499ff65c9979" translate="yes" xml:space="preserve">
          <source>Why Listeners in HTML?</source>
          <target state="translated">왜 리스너는 HTML입니까?</target>
        </trans-unit>
        <trans-unit id="d05a9a10126e300cca0827aed2703aed49fcd394" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;code&gt;list&lt;/code&gt;, which requires looping through a huge array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;code&gt;list&lt;/code&gt;. Without caching, we would be executing &lt;code&gt;list&lt;/code&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a &lt;code&gt;method&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cace55ca4b0d7fffbac7fef7ee11697b6e93db4" translate="yes" xml:space="preserve">
          <source>Why do we need caching? Imagine we have an expensive computed property &lt;strong&gt;A&lt;/strong&gt;, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on &lt;strong&gt;A&lt;/strong&gt;. Without caching, we would be executing &lt;strong&gt;A&lt;/strong&gt;&amp;rsquo;s getter many more times than necessary! In cases where you do not want caching, use a method instead.</source>
          <target state="translated">캐싱이 필요한 이유는 무엇입니까? 고가의 계산 속성 &lt;strong&gt;A&lt;/strong&gt; 가 있다고 가정 해보십시오 . 거대한 배열을 반복하고 많은 계산을 수행해야합니다. 그런 다음 &lt;strong&gt;A에&lt;/strong&gt; 의존하는 다른 계산 된 속성을 가질 수 있습니다 . 캐싱을하지 않으면 필요 이상으로 &lt;strong&gt;A&lt;/strong&gt; 's getter를 여러 번 실행할 수 있습니다 ! 캐싱을 원하지 않는 경우 방법을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4becacb6433612ab9fdced5b1ce8e770411d96" translate="yes" xml:space="preserve">
          <source>Will be equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30e24dc765d4c7a4af0703d2af20cd8e134ee849" translate="yes" xml:space="preserve">
          <source>Will be evaluated similar to:</source>
          <target state="translated">다음과 유사하게 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f06b08a2392c0b43e3833f9f4c17e1475f8d4643" translate="yes" xml:space="preserve">
          <source>Will instead be defined with:</source>
          <target state="translated">대신 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d2b826d3f7d8e2201135c671569ea283afb245af" translate="yes" xml:space="preserve">
          <source>Will result in:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bcd42cce76c522e00acc375bb83a386e44895e9" translate="yes" xml:space="preserve">
          <source>Will throw an error, because the &lt;code&gt;v-if&lt;/code&gt; directive will be evaluated first and the iteration variable &lt;code&gt;user&lt;/code&gt; does not exist at this moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b523d2bcf5fca866ffcaea5c846072e6f454e3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2972362a724a19189b0c528b9c31cb4d552d316e" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;migration/fragments#overview&quot;&gt;fragments&lt;/a&gt; support, components can potentially have more than one root nodes. When applied to a multi-root component, directive will be ignored and the warning will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3c68936845bcadd633acd3c5e92f54a35dd57a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&amp;lt;template v-for&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776dc7dc9ff80fd08e48b9caa4c38e270742c451" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we&amp;rsquo;re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven&amp;rsquo;t already:</source>
          <target state="translated">&lt;code&gt;.vue&lt;/code&gt; 구성 요소를 사용 하여 고급 JavaScript 응용 프로그램 영역에 들어갑니다. 즉, 아직 추가하지 않은 경우 몇 가지 추가 도구를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="e3840f18f3809fb17a5fc20b99dd0f910da3163d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;.vue&lt;/code&gt; components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84703fc2f9027470467014d24c7b02320fb62bd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;inheritAttrs: false&lt;/code&gt; and &lt;code&gt;$attrs&lt;/code&gt;, you can manually decide which element you want to forward attributes to, which is often desirable for &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;base components&lt;/a&gt;:</source>
          <target state="translated">함께 &lt;code&gt;inheritAttrs: false&lt;/code&gt; 과 &lt;code&gt;$attrs&lt;/code&gt; 수동 종종 바람직하다에 당신이 속성을 전달하고자하는 요소를 결정할 수 있습니다 &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;기본 구성 요소&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4e6cb97e1c707f6c266a663d8286562e9030cd23" translate="yes" xml:space="preserve">
          <source>With Build Tools</source>
          <target state="translated">빌드 도구</target>
        </trans-unit>
        <trans-unit id="e1e4b2e3dbdbf822ef565f7ce5070aedda94bed6" translate="yes" xml:space="preserve">
          <source>With Components</source>
          <target state="translated">구성 요소 포함</target>
        </trans-unit>
        <trans-unit id="e94afd24abb64d9b90f7248caba76323b7bd6df5" translate="yes" xml:space="preserve">
          <source>With Composition API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e14b5de4bdbf06aaa5c7d60756f18b22f131973" translate="yes" xml:space="preserve">
          <source>With ES2015 Symbols, function &lt;code&gt;provide&lt;/code&gt; and object &lt;code&gt;inject&lt;/code&gt;:</source>
          <target state="translated">ES2015 기호를 사용하면 기능이 &lt;code&gt;provide&lt;/code&gt; 되고 객체가 &lt;code&gt;inject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91634f01017a54aaae34da9aa5791b8ed1ace732" translate="yes" xml:space="preserve">
          <source>With MobX</source>
          <target state="translated">MobX로</target>
        </trans-unit>
        <trans-unit id="a4c0ad0fedf665b5addf50ef4ee3e843c9bae79a" translate="yes" xml:space="preserve">
          <source>With Object-based syntax, you can use following options:</source>
          <target state="translated">객체 기반 구문을 사용하면 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddaa6dc6d7bbbc58f451bb92e742747f8a0ad5d" translate="yes" xml:space="preserve">
          <source>With Options API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0907e78d48e052b47acae86f3368c0fee26b2f" translate="yes" xml:space="preserve">
          <source>With PascalCase</source>
          <target state="translated">PascalCase로</target>
        </trans-unit>
        <trans-unit id="8e3c02906d7a5cad13118eea9109a6e2b7c11fa1" translate="yes" xml:space="preserve">
          <source>With Vue 3, the API for two-way data binding is being standardized in order to reduce confusion and to allow developers more flexibility with the &lt;code&gt;v-model&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6e8d5c594ae0eeedbf57f7bb713ef9a3488318" translate="yes" xml:space="preserve">
          <source>With a Bundler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c796447490b9562e329b4eb4f3c1a45c3a13ab" translate="yes" xml:space="preserve">
          <source>With all these changes, the component and directive we have at the beginning of the guide will be rewritten into something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f67259032ce5e6a9b51cd6c8ee262fb5c3605c" translate="yes" xml:space="preserve">
          <source>With global tree-shaking, the user only &amp;ldquo;pay&amp;rdquo; for the features they actually use. Even better, knowing that optional features won't increase the bundle size for applications not using them, framework size has become much less a concern for additional core features in the future, if at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6729eb0e977f70c132c422c576ca3d368d86fc" translate="yes" xml:space="preserve">
          <source>With kebab-case</source>
          <target state="translated">케밥 케이스</target>
        </trans-unit>
        <trans-unit id="5262fdf2404668ac87ace7bc5320c88ae3fec32d" translate="yes" xml:space="preserve">
          <source>With npm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146754717a175d1f89fc3628f35dddfee5647668" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we&amp;rsquo;ve fixed that original transition without having to add any special styling.</source>
          <target state="translated">하나의 속성 추가로 특별한 스타일을 추가하지 않고도 원래 전환을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="689393a6c1bd0377fbe965e3cad93231017b2f2b" translate="yes" xml:space="preserve">
          <source>With one attribute addition, we've fixed that original transition without having to add any special styling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36361bcb7732d5e11757dbbeec045c06c4c7e7ac" translate="yes" xml:space="preserve">
          <source>With render function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726c2d492949be251e96d2fc6891fcc11ab60be3" translate="yes" xml:space="preserve">
          <source>With that said, it&amp;rsquo;s inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</source>
          <target state="translated">그렇게 말하면, 탐구 된 많은 주제가 어느 정도 주관적이므로 비교는 일부 React 사용자에게 Vue를 향한 편향으로 보일 것입니다. 우리는 다양한 기술적 취향의 존재를 인정하며,이 비교는 주로 Vue가 선호 사항과 일치 할 때 Vue가 더 적합 할 수있는 이유를 간략하게 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74293b552f92b191f072c0da0451d95393b6de4a" translate="yes" xml:space="preserve">
          <source>With the behavior change of &lt;code&gt;is&lt;/code&gt;, we introduce a new directive &lt;code&gt;v-is&lt;/code&gt; for working around these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0003a3096e960ec10c4bccd66adf7dbf8bea11" translate="yes" xml:space="preserve">
          <source>With the new transition system, you can now &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;use components for reusable transitions&lt;/a&gt;.</source>
          <target state="translated">새로운 전이 시스템을 통해 이제 &lt;a href=&quot;transitions#Reusable-Transitions&quot;&gt;재사용 가능한 전이에 컴포넌트를 사용할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3828ac5cca844bde7e12cdc97494a2e145077de0" translate="yes" xml:space="preserve">
          <source>With the second parameter, we can pass root props to the application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d2800ca9c44c02e89db888766c57a4c894655" translate="yes" xml:space="preserve">
          <source>With the template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5db4b3ecbbcef145192161b4e8a9adf72f34af" translate="yes" xml:space="preserve">
          <source>With this change, provided the module bundler supports tree-shaking, global APIs that are not used in a Vue application will be eliminated from the final bundle, resulting in an optimal file size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039e52a50855f92c82cc8a84a142a54cd6c17f7d" translate="yes" xml:space="preserve">
          <source>With this knowledge, we can now finish the component we started:</source>
          <target state="translated">이 지식으로 이제 시작한 구성 요소를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b51b14ed767e15b6133cfad9870cba3b70f4a4" translate="yes" xml:space="preserve">
          <source>With this new configuration, our &lt;code&gt;data-status&lt;/code&gt; attribute will be applied to our &lt;code&gt;input&lt;/code&gt; element!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d064e70d3aeb0eac7d3ba972b7156b0acdc5ed48" translate="yes" xml:space="preserve">
          <source>With those changes in place, we've just moved the whole first logical concern into a single place. We can now do the same with the second concern &amp;ndash; filtering based on &lt;code&gt;searchQuery&lt;/code&gt;, this time with a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89cca8416101fd32770a454f8d5273ad1bc7716" translate="yes" xml:space="preserve">
          <source>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue&amp;rsquo;s &lt;a href=&quot;transitions&quot;&gt;built-in transition system&lt;/a&gt;. Together, there are very few limits to what can be accomplished.</source>
          <target state="translated">하위 구성 요소 내에서이 페이지에서 다루는 전환 전략과 Vue의 &lt;a href=&quot;transitions&quot;&gt;내장 전환 시스템에서&lt;/a&gt; 제공하는 모든 조합을 사용할 수 있습니다 . 함께 수행 할 수있는 작업에는 제한이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b46b3ddd55e7832cce6f8044474d8ac05b815614" translate="yes" xml:space="preserve">
          <source>Without Build Tools</source>
          <target state="translated">빌드 도구없이</target>
        </trans-unit>
        <trans-unit id="f2a1442937e9312fb88d30abe594d3832e40b6c8" translate="yes" xml:space="preserve">
          <source>Woah - this is a super long page! Does that mean 2.0 is completely different, I&amp;rsquo;ll have to learn the basics all over again, and migrating will be practically impossible?</source>
          <target state="translated">우와-이것은 매우 긴 페이지입니다! 2.0이 완전히 다르다는 것을 의미합니까? 다시 기본을 배워야하며 마이그레이션이 실제로 불가능할까요?</target>
        </trans-unit>
        <trans-unit id="c9e02cb643a613f1c79faab9079d2f3e58edae60" translate="yes" xml:space="preserve">
          <source>Working with reactivity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3413e9fc86a733fea321b8d4f5dce2cd96c7c946" translate="yes" xml:space="preserve">
          <source>Wrapping values inside an object might seem unnecessary but is required to keep the behavior unified across different data types in JavaScript. That&amp;rsquo;s because in JavaScript, primitive types like &lt;code&gt;Number&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; are passed by value, not by reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5357865535aa2a476144e9beb3464ba1cbdbcf27" translate="yes" xml:space="preserve">
          <source>Writing &amp;amp; Grammar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9c28b71ec2be9f31844a95d25a8e022dbe663f" translate="yes" xml:space="preserve">
          <source>Writing Testable Components</source>
          <target state="translated">테스트 가능한 구성 요소 작성</target>
        </trans-unit>
        <trans-unit id="510a261ec2843f68a4816e4735bf0f01c466c291" translate="yes" xml:space="preserve">
          <source>Writing a Plugin</source>
          <target state="translated">플러그인 작성</target>
        </trans-unit>
        <trans-unit id="4835d6c16769322c715842b97457649636213963" translate="yes" xml:space="preserve">
          <source>Writing documentation is an exercise in empathy. We're not describing an objective reality - the source code already does that. Our job is to help shape the relationship between users and the Vue ecosystem. This ever-evolving guide provides some rules and recommendations on how to do that consistently within the Vue ecosystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90541f524186259ca7b45913e319ab878043cca6" translate="yes" xml:space="preserve">
          <source>X-Templates</source>
          <target state="translated">X-Templates</target>
        </trans-unit>
        <trans-unit id="3da53c899f2de058d0a78dc035fc82fa4168e261" translate="yes" xml:space="preserve">
          <source>Yes! We are ready for translation!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56f5c342be3541ee986cb873bbad4da1de25564" translate="yes" xml:space="preserve">
          <source>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the &lt;code&gt;name&lt;/code&gt; attribute to a dynamic property.</source>
          <target state="translated">예, Vue의 전환조차도 데이터 중심입니다! 동적 전이의 가장 기본적인 예는 &lt;code&gt;name&lt;/code&gt; 속성을 동적 속성에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="9c7930e65cfb28d01dc27c348442febb4d224313" translate="yes" xml:space="preserve">
          <source>You actually don&amp;rsquo;t need to for debugging anymore, as Vue will nicely format output for you automatically, whether it&amp;rsquo;s a string, number, array, or plain object. If you want the exact same functionality as JavaScript&amp;rsquo;s &lt;code&gt;JSON.stringify&lt;/code&gt; though, then you can use that in a method or computed property.</source>
          <target state="translated">Vue는 문자열, 숫자, 배열 또는 일반 객체인지 여부에 따라 자동으로 출력 형식을 지정하므로 더 이상 디버깅 할 필요가 없습니다. JavaScript의 &lt;code&gt;JSON.stringify&lt;/code&gt; 와 동일한 기능을 원한다면 메소드 또는 계산 속성에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e119e2f6092103e55af9dce5ad23bb6ea3fc658c" translate="yes" xml:space="preserve">
          <source>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</source>
          <target state="translated">당신은 강요된 가치를 그 가치관에 전달 된 가치와 구별하는 이름을 부여함으로써보다 명백해야합니다.</target>
        </trans-unit>
        <trans-unit id="259bd96ca0effe183387e9e5f024f56b5205a591" translate="yes" xml:space="preserve">
          <source>You can access a component's lifecycle hook by prefixing the lifecycle hook with &quot;on&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c426dccdf7bb9d113711cec6e8b178109d4c59" translate="yes" xml:space="preserve">
          <source>You can access static slot contents as Arrays of VNodes from &lt;a href=&quot;../api/index#vm-slots&quot;&gt;&lt;code&gt;this.$slots&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정적 슬롯 내용은 &lt;a href=&quot;../api/index#vm-slots&quot;&gt; &lt;code&gt;this.$slots&lt;/code&gt; &lt;/a&gt; 에서 VNode 배열로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c01f592d841d8e339fea13c397b0df69d3de97" translate="yes" xml:space="preserve">
          <source>You can also &lt;a href=&quot;../api/index#keyCodes&quot;&gt;define custom key modifier aliases&lt;/a&gt; via the global &lt;code&gt;config.keyCodes&lt;/code&gt; object:</source>
          <target state="translated">전역 &lt;code&gt;config.keyCodes&lt;/code&gt; 객체 를 통해 &lt;a href=&quot;../api/index#keyCodes&quot;&gt;사용자 정의 키 수정 자 별명&lt;/a&gt; 을 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1813d70fbaf8bba2c2a5a3785639129921bc5052" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally for a Vue application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622e98e0d6c37bfb7ab2f18e227b46cbc3583f37" translate="yes" xml:space="preserve">
          <source>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect &lt;strong&gt;every&lt;/strong&gt; Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</source>
          <target state="translated">믹스 인을 전체적으로 적용 할 수도 있습니다. 주의해서 사용하십시오! 믹스 인을 전체적으로 적용하면 나중에 생성 된 &lt;strong&gt;모든&lt;/strong&gt; Vue 인스턴스에 영향을줍니다 . 올바르게 사용하면 사용자 지정 옵션에 대한 처리 논리를 주입하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8823272620bc63ace5da9fd0bc048769cb40d6" translate="yes" xml:space="preserve">
          <source>You can also declare additional global properties and component options:</source>
          <target state="translated">추가 전역 속성 및 구성 요소 옵션을 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adecb9f768a677f404c477ccc6a1e9688aad9512" translate="yes" xml:space="preserve">
          <source>You can also define JavaScript hooks in attributes:</source>
          <target state="translated">속성에서 JavaScript 후크를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="beebaf9986e9097a2444f204aa81ae1c568b7cbd" translate="yes" xml:space="preserve">
          <source>You can also give the input an accessible name with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute&quot;&gt;&lt;code&gt;aria-label&lt;/code&gt; (opens new window)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503a3e28cf5a8489e2b8f7a242ab27389b2b6691" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/directives#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59db4f1c8c537e3299ed286ab9edc0d67d61747" translate="yes" xml:space="preserve">
          <source>You can also perform one-time interpolations that do not update on data change by using the &lt;a href=&quot;../api/index#v-once&quot;&gt;v-once directive&lt;/a&gt;, but keep in mind this will also affect any other bindings on the same node:</source>
          <target state="translated">&lt;a href=&quot;../api/index#v-once&quot;&gt;v-once 지시문&lt;/a&gt; 을 사용하여 데이터 변경시 업데이트되지 않는 일회성 보간을 수행 할 수도 있지만 동일한 노드의 다른 바인딩에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e11efe63fd06b61dcfcaba4eeda09c76401a3855" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property&amp;rsquo;s name (a.k.a. key):</source>
          <target state="translated">속성 이름 (일명 키)에 대한 두 번째 인수를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e590ee53b15356b15c6804307c06fa95680eb6f" translate="yes" xml:space="preserve">
          <source>You can also provide a second argument for the property's name (a.k.a. key):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525e813968758780c48d074f432233acab02c34" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 and ES2015 syntax you can do:</source>
          <target state="translated">팩토리 함수에서 &lt;code&gt;Promise&lt;/code&gt; 를 반환 할 수 있으므로 Webpack 2 및 ES2015 구문을 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f9cab99bb92ad04f5fd1ef133a533bca320077d" translate="yes" xml:space="preserve">
          <source>You can also return a &lt;code&gt;Promise&lt;/code&gt; in the factory function, so with Webpack 2 or later and ES2015 syntax you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571c9a02435c95b783b2181af7abafb404a7a321" translate="yes" xml:space="preserve">
          <source>You can also specify custom transition classes by providing the following attributes:</source>
          <target state="translated">다음 속성을 제공하여 사용자 정의 전환 클래스를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="123d964ca13d8922b3a59e09ea5d0738f8870247" translate="yes" xml:space="preserve">
          <source>You can also specify separate values for enter and leave durations:</source>
          <target state="translated">입력 및 종료 기간에 대해 별도의 값을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b708002bf5e4f269767c152c0103659f003ed958" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;defineAsyncComponent&lt;/code&gt; when &lt;a href=&quot;component-registration#local-registration&quot;&gt;registering a component locally&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29859f4274a48a2f62e987c9e06a4e3094c11f59" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript&amp;rsquo;s syntax for iterators:</source>
          <target state="translated">당신은 또한 사용할 수 &lt;code&gt;of&lt;/code&gt; 구분 기호로 대신 &lt;code&gt;in&lt;/code&gt; 이 반복자에 대한 자바 스크립트의 구문에 가까운 그래서, :</target>
        </trans-unit>
        <trans-unit id="56680b86213ebfab218348e1f259349ba40ffdea" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;of&lt;/code&gt; as the delimiter instead of &lt;code&gt;in&lt;/code&gt;, so that it is closer to JavaScript's syntax for iterators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7003d01ea6e5751b64f6c501e1367eadc0f20feb" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;v-for&lt;/code&gt; to iterate through the properties of an object.</source>
          <target state="translated">&lt;code&gt;v-for&lt;/code&gt; 를 사용하여 객체의 속성을 반복 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2874f410c245555c54bfa970bdbf6a97ed6f8241" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../api/index#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt;&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;a href=&quot;../api/index#vm-set&quot;&gt; &lt;code&gt;vm.$set&lt;/code&gt; &lt;/a&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caa2f5e4a5e7cb8569f06fc887bf75bbeb1e905a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://vuejs.org/v2/api/#vm-set&quot;&gt;&lt;code&gt;vm.$set&lt;/code&gt; (opens new window)&lt;/a&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7016af3cddf281827fcb1fb635902cd99d67f65c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;is&lt;/code&gt; attribute to create regular HTML elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248865e59fe69c22e3616cb9bf4e8973863a8b12" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias for the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;code&gt;vm.$set&lt;/code&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ae0ee1e212b211b93a0c32174c255bb0860a240" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;vm.$set&lt;/code&gt; instance method, which is an alias to the global &lt;code&gt;Vue.set&lt;/code&gt;:</source>
          <target state="translated">전역 &lt;code&gt;Vue.set&lt;/code&gt; 의 별칭 인 &lt;code&gt;vm.$set&lt;/code&gt; 인스턴스 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fcb1d8476b09ce2de67cd75aeb50a678e90199d" translate="yes" xml:space="preserve">
          <source>You can assert its render output with different props using the &lt;code&gt;propsData&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;propsData&lt;/code&gt; 옵션을 사용하여 다른 props로 렌더 출력을 어설 션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1723b0ed33c8953b91ffd8fc42e598875ee5aa7" translate="yes" xml:space="preserve">
          <source>You can bind as many attributes to the &lt;code&gt;slot&lt;/code&gt; as you need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9450a9423cc08d4d6f86fddb51f97f1895339a" translate="yes" xml:space="preserve">
          <source>You can browse the full application API in the &lt;a href=&quot;../api/application-api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff5ae9be823fef3066f1625fd66ddc473d6f7bd" translate="yes" xml:space="preserve">
          <source>You can browse the source of the NPM package at &lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cdn.jsdelivr.net/npm/vue/&quot;&gt;cdn.jsdelivr.net/npm/vue&lt;/a&gt; 에서 NPM 패키지의 소스를 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a50584cf2f28b29d5933a7806dfd6c8fe93a173" translate="yes" xml:space="preserve">
          <source>You can chain other methods after &lt;code&gt;createApp&lt;/code&gt;, they can be found in &lt;a href=&quot;application-api&quot;&gt;Application API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a108d1490b085325e471f3c57d3e9dc0f3ae2bc3" translate="yes" xml:space="preserve">
          <source>You can change &lt;code&gt;seen&lt;/code&gt; from &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the sandbox below to check the effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb59a77a247c2d91532f11b2a60d478be4cab66" translate="yes" xml:space="preserve">
          <source>You can check &lt;code&gt;&amp;lt;teleport&amp;gt;&lt;/code&gt; component options in the &lt;a href=&quot;../api/built-in-components#teleport&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48aa82a368ad205d3da3994cb186cdc0a22d46d8" translate="yes" xml:space="preserve">
          <source>You can check the arguments passed into these hooks (i.e. &lt;code&gt;el&lt;/code&gt;, &lt;code&gt;binding&lt;/code&gt;, &lt;code&gt;vnode&lt;/code&gt;, and &lt;code&gt;prevVnode&lt;/code&gt;) in &lt;a href=&quot;../api/application-api#directive&quot;&gt;Custom Directive API&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a321e28dae8c3d2b4ba9a95524f5a758d218685" translate="yes" xml:space="preserve">
          <source>You can check the list of available options in the &lt;a href=&quot;../api/global-api#arguments-4&quot;&gt;API Reference&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498c9c8804cc7d12217ea3d9f3524d82346ca9db" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; depends on &lt;code&gt;vm.author.books&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.publishedBooksMessage&lt;/code&gt; when &lt;code&gt;vm.author.books&lt;/code&gt; changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167a0aedab0a55ff7ffc58babd47e8de07340c0a" translate="yes" xml:space="preserve">
          <source>You can data-bind to computed properties in templates just like a normal property. Vue is aware that &lt;code&gt;vm.reversedMessage&lt;/code&gt; depends on &lt;code&gt;vm.message&lt;/code&gt;, so it will update any bindings that depend on &lt;code&gt;vm.reversedMessage&lt;/code&gt; when &lt;code&gt;vm.message&lt;/code&gt; changes. And the best part is that we&amp;rsquo;ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</source>
          <target state="translated">일반 속성과 마찬가지로 템플릿에서 계산 된 속성에 데이터 바인딩 할 수 있습니다. 뷰는 것을 알고 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 가 에 따라 달라 &lt;code&gt;vm.message&lt;/code&gt; 가 종속 된 바인딩 업데이트 있도록, &lt;code&gt;vm.reversedMessage&lt;/code&gt; 때 &lt;code&gt;vm.message&lt;/code&gt; 가 변경합니다. 그리고 가장 중요한 부분은이 의존성 관계를 선언적으로 생성했다는 것입니다. 계산 된 getter 함수에는 부작용이 없으므로 테스트하고 이해하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1044eededcd74e76a9fea5a18966c11b17ea2990" translate="yes" xml:space="preserve">
          <source>You can define local filters in a component&amp;rsquo;s options:</source>
          <target state="translated">구성 요소 옵션에서 로컬 필터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e0ba3946572236040373d70df47614040a79eb8" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you&amp;rsquo;d like, but the order is still important.</source>
          <target state="translated">원하는 경우 이러한 커넥터 단어를 구성 요소 이름에 포함시킬 수 있지만 순서는 여전히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f39a90801437ef44d3dae3a0d0e800d9fa37f7c2" translate="yes" xml:space="preserve">
          <source>You can definitely include these connector words in component names if you'd like, but the order is still important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c022f147799d0182c220604e3362863fce8a99c" translate="yes" xml:space="preserve">
          <source>You can directly use &lt;code&gt;v-for&lt;/code&gt; on a custom component, like any normal element:</source>
          <target state="translated">일반 요소와 같이 사용자 컴포넌트에서 &lt;code&gt;v-for&lt;/code&gt; 를 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0f496ff2b9d3f296d22a7febb3e4014d60fe282" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt; (opens new window)&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7028a553eca439b2e7747d4a1bf01ca9da41dba8" translate="yes" xml:space="preserve">
          <source>You can directly use any valid key names exposed via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt;&lt;code&gt;KeyboardEvent.key&lt;/code&gt;&lt;/a&gt; as modifiers by converting them to kebab-case.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values&quot;&gt; &lt;code&gt;KeyboardEvent.key&lt;/code&gt; &lt;/a&gt; 를 통해 노출 된 유효한 키 이름 을 kebab-case로 변환하여 수정 자로 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b0d30a1d66ac3fa2c67a819e1376ba0a0473acd" translate="yes" xml:space="preserve">
          <source>You can even define fallbacks, to be used in case a slot prop is undefined:</source>
          <target state="translated">슬롯 소품이 정의되지 않은 경우 사용할 폴백을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad42325319e7ea64ca1905e50eeba3ae1d34a1e1" translate="yes" xml:space="preserve">
          <source>You can even order by multiple columns:</source>
          <target state="translated">여러 열로 주문할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc0ce516635c38508cc33c06a657a1d3f774e4f" translate="yes" xml:space="preserve">
          <source>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</source>
          <target state="translated">Pug (이전의 Jade)와 같은 프리 프로세서를 사용하여 Vue 템플릿을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde8b53cf3059c4972d20e4534b1e469ee4c5fb" translate="yes" xml:space="preserve">
          <source>You can find more information at this site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b95ad424054751a98acdcf21d4dc4035ab20f" translate="yes" xml:space="preserve">
          <source>You can get a lot of unique effects and make your animation very stylish by adjusting your easing. CSS allows you to modify this by adjusting a cubic bezier property, &lt;a href=&quot;https://cubic-bezier.com/#.17,.67,.83,.67&quot;&gt;this playground (opens new window)&lt;/a&gt; by Lea Verou is very helpful for exploring this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df595af00721f8288076a5f9fba469b9a917832" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c19203d0961c36adfdf784eff782bb9b89fe5ea" translate="yes" xml:space="preserve">
          <source>You can have multiple classes toggled by having more fields in the object. In addition, the &lt;code&gt;v-bind:class&lt;/code&gt; directive can also co-exist with the plain &lt;code&gt;class&lt;/code&gt; attribute. So given the following template:</source>
          <target state="translated">객체에 더 많은 필드를 두어 여러 클래스를 토글 할 수 있습니다. 또한 &lt;code&gt;v-bind:class&lt;/code&gt; 지시문은 일반 &lt;code&gt;class&lt;/code&gt; 속성 과 공존 할 수도 있습니다 . 따라서 다음 템플릿이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="8aa030b589eee93625f4864d21a641f8663ff7c6" translate="yes" xml:space="preserve">
          <source>You can have multiple methods in an event handler separated by a comma operator like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56c7af523fb7e0763535f3902c25d971d409bc6" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;reactive&lt;/code&gt; in the &lt;a href=&quot;../api/basic-reactivity&quot;&gt;Basic Reactivity API's&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08c4fe759a5cd0a79d2084a4f5a83a750978591" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;refs&lt;/code&gt; in the &lt;a href=&quot;../api/refs-api#ref&quot;&gt;Refs API&lt;/a&gt; section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bd14a02b45ad31d79cd406616fc79e061cec94" translate="yes" xml:space="preserve">
          <source>You can learn more about component attribute inheritance in &lt;a href=&quot;component-attrs&quot;&gt;Non-Prop Attributes&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8478ec92b8428be9713f6498961af7738c99a9" translate="yes" xml:space="preserve">
          <source>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</source>
          <target state="translated">완전한 프로그래밍 언어 (JavaScript)의 강력한 기능을 활용하여보기를 구축 할 수 있습니다. 여기에는 임시 변수, 흐름 제어 및 범위 내에서 JavaScript 값을 직접 참조하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="905d51cd5fa57a6f04be69e05b9de5a2548b1f8f" translate="yes" xml:space="preserve">
          <source>You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</source>
          <target state="translated">이 후크에서 구성 요소 상태를 수정할 수 있습니다. 그러나 오류가 발생했을 때 다른 컨텐츠를 단락시키는 템플릿 또는 렌더 기능에 조건을 설정하는 것이 중요합니다. 그렇지 않으면, 컴포넌트는 무한의 렌더 루프에 던져 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="483010467e7b1520e8252c976ccc95f6183b6a3a" translate="yes" xml:space="preserve">
          <source>You can modify its properties, listed below, before mounting your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc726e3c336929e5a4f3f15f2e5d000f5d9087e9" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the example vm yourself. The value of &lt;code&gt;vm.reversedMessage&lt;/code&gt; is always dependent on the value of &lt;code&gt;vm.message&lt;/code&gt;.</source>
          <target state="translated">콘솔을 열고 예제 vm을 직접 재생할 수 있습니다. 의 값 &lt;code&gt;vm.reversedMessage&lt;/code&gt; 은 항상의 값에 따라 달라집니다 &lt;code&gt;vm.message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8012275d0890f19d6be6f05bec36e87984695c2" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples&amp;rsquo; &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="translated">콘솔을 열고 돌연변이 메소드를 호출 하여 이전 예제의 &lt;code&gt;items&lt;/code&gt; 배열로 재생할 수 있습니다 . 예를 들면 다음과 같습니다. &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7275711fe53486de9349eeef7453708059692c43" translate="yes" xml:space="preserve">
          <source>You can open the console and play with the previous examples' &lt;code&gt;items&lt;/code&gt; array by calling their mutation methods. For example: &lt;code&gt;example1.items.push({ message: 'Baz' })&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba921687af5126b7f400e59dbcbdedd8cdb124c" translate="yes" xml:space="preserve">
          <source>You can optionally pass in some options:</source>
          <target state="translated">선택적으로 일부 옵션을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69df9eda77fa786bedb0320c7efdaa4e55ad2623" translate="yes" xml:space="preserve">
          <source>You can provide an array of multiple (prefixed) values to a style property, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a4f4044c3911054f58336d3572114ed40ddb95" translate="yes" xml:space="preserve">
          <source>You can replace it with:</source>
          <target state="translated">다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ebee5b6a0c8de1d1b75a459aa211a5e7be2130" translate="yes" xml:space="preserve">
          <source>You can see how we could use this for data visualization, for physics effects, for character animations and interactions, the sky's the limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95775e978fa861006adc17e274f17759126e18a9" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../style-guide/index#Base-component-names-strongly-recommended&quot;&gt;스타일 안내서&lt;/a&gt; 에서 구성 요소 이름에 대한 다른 권장 사항을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c82861be683435cc1668ccd7f2e6b81cafe38300" translate="yes" xml:space="preserve">
          <source>You can see other recommendations for component names in the &lt;a href=&quot;../style-guide/index#base-component-names-strongly-recommended&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb44edcad32144ea0ed5ecec8aaeb904c53b619" translate="yes" xml:space="preserve">
          <source>You can see the &lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;full example here&lt;/a&gt;. The advantage over using &lt;code&gt;$parent&lt;/code&gt; is that we can access &lt;code&gt;getMap&lt;/code&gt; in &lt;em&gt;any&lt;/em&gt; descendant component, without exposing the entire instance of &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt;. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with &lt;code&gt;props&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jsfiddle.net/chrisvfritz/tdv8dt3s/&quot;&gt;여기&lt;/a&gt; 에서 전체 예제를 볼 수 있습니다 . 사용을 통해 장점 &lt;code&gt;$parent&lt;/code&gt; 우리가 접근 할 수 있다는 것입니다 &lt;code&gt;getMap&lt;/code&gt; 에 &lt;em&gt;어떤&lt;/em&gt; 의 전체 인스턴스를 노출하지 않고, 하위 구성 요소 &lt;code&gt;&amp;lt;google-map&amp;gt;&lt;/code&gt; . 이를 통해 하위 구성 요소가 의존하는 것을 변경 / 제거 할 염려없이 해당 구성 요소를보다 안전하게 개발할 수 있습니다. &lt;code&gt;props&lt;/code&gt; 와 마찬가지로 이러한 구성 요소 간의 인터페이스는 명확하게 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16bcf864fb3aac6cb97fde8cea277e3092eccb3c" translate="yes" xml:space="preserve">
          <source>You can see the description by inspecting Chrome DevTools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e4d8ebb6112a000f5549eb59e46ddfbf5ba539c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &quot;else block&quot; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245b045b34476511514b4b5c3df43a3bd4d1f68c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-else&lt;/code&gt; directive to indicate an &amp;ldquo;else block&amp;rdquo; for &lt;code&gt;v-if&lt;/code&gt;:</source>
          <target state="translated">당신은 사용할 수있는 &lt;code&gt;v-else&lt;/code&gt; 에 대한 &quot;다른 블록&quot;표시하기 위해 지침을 &lt;code&gt;v-if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2a4fae4f9f57495dc2dabf7c2d98d7cf9f74df2a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;v-model&lt;/code&gt; directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, &lt;code&gt;v-model&lt;/code&gt; is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</source>
          <target state="translated">&lt;code&gt;v-model&lt;/code&gt; 지시문을 사용하여 양식 입력, 텍스트 영역 및 선택 요소에 양방향 데이터 바인딩을 작성할 수 있습니다 . 입력 유형에 따라 요소를 업데이트하는 올바른 방법을 자동으로 선택합니다. 약간 마술 적이지만, &lt;code&gt;v-model&lt;/code&gt; 은 본질적으로 사용자 입력 이벤트에 대한 데이터를 업데이트하는 구문 설탕이며 일부 경우에 특별한주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="b7c793ba84fdf736cdbc25fee71f2a2c7eaf0e57" translate="yes" xml:space="preserve">
          <source>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</source>
          <target state="translated">다음 수정자를 사용하여 해당 수정 자 키를 누를 때만 마우스 또는 키보드 이벤트 리스너를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddb37f26a92a06753b285b9c9c11e196959baab" translate="yes" xml:space="preserve">
          <source>You can use this technique to create functional images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="ca0c657ad0278a0921d29ff9ef965a0e62ef03be" translate="yes" xml:space="preserve">
          <source>You could add a new &lt;code&gt;age&lt;/code&gt; property to the nested &lt;code&gt;userProfile&lt;/code&gt; object with:</source>
          <target state="translated">다음 을 사용하여 중첩 된 &lt;code&gt;userProfile&lt;/code&gt; 오브젝트에 새 &lt;code&gt;age&lt;/code&gt; 특성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0acc99ee1e9f7a5721274787de8b1c76d139ac14" translate="yes" xml:space="preserve">
          <source>You could resolve both issues with a programmatic listener:</source>
          <target state="translated">프로그래밍 방식의 리스너로 두 가지 문제를 모두 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">당신은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4e0ef273090898bde0e037c96c402023d3d76aed" translate="yes" xml:space="preserve">
          <source>You could write:</source>
          <target state="translated">당신은 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1ad84f5c26c15d7162b3722b45d0ba843c67381b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to do anything special in your components to make them testable. Export the raw options:</source>
          <target state="translated">테스트 할 수 있도록 구성 요소에서 특별한 작업을 수행하지 않아도됩니다. 원시 옵션을 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="3d0f507759bdd0fc68a3de5b0514f524e5f3294e" translate="yes" xml:space="preserve">
          <source>You have two options when defining component names:</source>
          <target state="translated">구성 요소 이름을 정의 할 때 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c890526e2b50fb6ddd6a47a453deb3b5176a87" translate="yes" xml:space="preserve">
          <source>You may also find that entrances look better with slightly more time than an exit. The user typically is being guided during the entrance, and is a little less patient upon exit because they want to go on their way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052f909a44e11196b7f8fa3d033ec09119d35042" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue&amp;rsquo;s templates actually compile to render functions. This is an implementation detail you usually don&amp;rsquo;t need to know about, but if you&amp;rsquo;d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="translated">Vue의 템플릿이 실제로 함수를 렌더링하기 위해 컴파일된다는 것을 알고 싶을 것입니다. 이것은 일반적으로 알 필요가없는 구현 세부 사항이지만 특정 템플릿 기능이 어떻게 컴파일되는지 알고 싶다면 흥미로울 것입니다. 다음은 &lt;code&gt;Vue.compile&lt;/code&gt; 을 사용하여 템플릿 문자열을 라이브 컴파일하는 데모입니다 .</target>
        </trans-unit>
        <trans-unit id="8cd17a8f30e925013013a4351cf5807785289ba1" translate="yes" xml:space="preserve">
          <source>You may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using &lt;code&gt;Vue.compile&lt;/code&gt; to live-compile a template string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6dc5bbc4d3bace526bdc2fd08d2cfab5d8dec3" translate="yes" xml:space="preserve">
          <source>You may be wondering:</source>
          <target state="translated">궁금 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="143b9f4f1dc7d1bfde27bde6e896dca625ded097" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec (opens new window)&lt;/a&gt;. That's because Vue's component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API (opens new window)&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc07e2aec6e341f69ef26081c0e5222d68f3b55" translate="yes" xml:space="preserve">
          <source>You may have noticed that Vue components are very similar to &lt;strong&gt;Custom Elements&lt;/strong&gt;, which are part of the &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;Web Components Spec&lt;/a&gt;. That&amp;rsquo;s because Vue&amp;rsquo;s component syntax is loosely modeled after the spec. For example, Vue components implement the &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API&lt;/a&gt; and the &lt;code&gt;is&lt;/code&gt; special attribute. However, there are a few key differences:</source>
          <target state="translated">Vue 구성 요소는 &lt;a href=&quot;https://www.w3.org/wiki/WebComponents/&quot;&gt;웹 구성 요소 사양의&lt;/a&gt; 일부인 &lt;strong&gt;사용자 지정 요소&lt;/strong&gt; 와 매우 유사합니다 . Vue의 구성 요소 구문이 사양에 따라 느슨하게 모델링 되었기 때문입니다. 예를 들어 Vue 구성 요소는 &lt;a href=&quot;https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md&quot;&gt;Slot API를&lt;/a&gt; 구현 하며 &lt;code&gt;is&lt;/code&gt; 특수 속성입니다. 그러나 몇 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8faf1ddcecc2ccb7d0d4b5801a7f067548f165d" translate="yes" xml:space="preserve">
          <source>You may have noticed we can achieve the same result by invoking a method in the expression:</source>
          <target state="translated">표현식에서 메소드를 호출하여 동일한 결과를 얻을 수 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3e133c225d466ecd683f06d0a8f9b03a34053d" translate="yes" xml:space="preserve">
          <source>You may not have accounted for change detection caveats &lt;a href=&quot;list#Caveats&quot;&gt;with arrays&lt;/a&gt; or &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;objects&lt;/a&gt;, or you may be relying on state that isn&amp;rsquo;t tracked by Vue&amp;rsquo;s reactivity system, e.g. with &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;list#Caveats&quot;&gt;배열&lt;/a&gt; 이나 &lt;a href=&quot;list#Object-Change-Detection-Caveats&quot;&gt;객체의&lt;/a&gt; 변경 감지주의 사항 을 설명하지 않았 거나 Vue의 반응성 시스템 (예 : &lt;code&gt;data&lt;/code&gt; ) 에서 추적하지 않는 상태에 의존하고있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f78a45e93ff614ad4d560280cdd81744a9547eeb" translate="yes" xml:space="preserve">
          <source>You may notice that the animations shown above are using things like &lt;code&gt;transforms&lt;/code&gt;, and applying strange properties like &lt;code&gt;perspective&lt;/code&gt;- why were they built that way instead of just using &lt;code&gt;margin&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; etc?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56316fe542cc1b3610fe594b75ba3af739e576a" translate="yes" xml:space="preserve">
          <source>You may notice that:</source>
          <target state="translated">다음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e2f8675ad97e6ec4ee4ad4c7d9ed72b6a98e329" translate="yes" xml:space="preserve">
          <source>You may wonder why we need both &lt;code&gt;slots()&lt;/code&gt; and &lt;code&gt;children&lt;/code&gt;. Wouldn&amp;rsquo;t &lt;code&gt;slots().default&lt;/code&gt; be the same as &lt;code&gt;children&lt;/code&gt;? In some cases, yes - but what if you have a functional component with the following children?</source>
          <target state="translated">왜 &lt;code&gt;slots()&lt;/code&gt; 와 &lt;code&gt;children&lt;/code&gt; 이 필요한지 궁금 할 것 입니다. 하지 않을까요 &lt;code&gt;slots().default&lt;/code&gt; 과 동일 &lt;code&gt;children&lt;/code&gt; ? 어떤 경우에는 그렇습니다. 그러나 다음과 같은 하위 요소를 가진 기능적 구성 요소가 있다면 어떨까요?</target>
        </trans-unit>
        <trans-unit id="f4b169dfdbff18ce5e5cf4146c1cf33c657dfab8" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &quot;separation of concerns&quot;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e1b5ea3cb693ce24f280b44d340791c063f5aa" translate="yes" xml:space="preserve">
          <source>You might be concerned that this whole event listening approach violates the good old rules about &amp;ldquo;separation of concerns&amp;rdquo;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that&amp;rsquo;s handling the current view, it won&amp;rsquo;t cause any maintenance difficulty. In fact, there are several benefits in using &lt;code&gt;v-on&lt;/code&gt;:</source>
          <target state="translated">이 전체 이벤트 청취 방식이&amp;ldquo;문제의 분리&amp;rdquo;에 관한 오래된 규칙을 위반하는 것에 대해 우려 할 수도 있습니다. 안심하십시오-모든 Vue 핸들러 함수와 표현식은 현재 뷰를 처리하는 ViewModel에 엄격하게 바인딩되어 있기 때문에 유지 관리에 어려움이 없습니다. 실제로 &lt;code&gt;v-on&lt;/code&gt; 을 사용하면 몇 가지 이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b95fdb476d99a0cdcdb7cfdf0abca7591aa1787" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</source>
          <target state="translated">부모의 이름을 딴 디렉토리에 자식 구성 요소를 중첩하여이 문제를 해결하려고 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a47591adc396778366644573330c716aad893852" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &quot;search&quot; directory, then all the settings components under a &quot;settings&quot; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5617302f09918fe6715d17bbf628df2dfc2db645" translate="yes" xml:space="preserve">
          <source>You might be tempted to solve this problem differently, nesting all the search components under a &amp;ldquo;search&amp;rdquo; directory, then all the settings components under a &amp;ldquo;settings&amp;rdquo; directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</source>
          <target state="translated">모든 검색 구성 요소를 &quot;검색&quot;디렉토리 아래에 중첩 한 다음 모든 설정 구성 요소를 &quot;설정&quot;디렉토리 아래에 중첩 시키면이 문제를 다르게 해결하려는 유혹을받을 수 있습니다. 다음과 같은 이유로 매우 큰 앱 (예 : 100 개 이상의 구성 요소)에서만이 방법을 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa7fb79770049661cccac5c46719619557b2fa6b" translate="yes" xml:space="preserve">
          <source>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</source>
          <target state="translated">이것이 Vue가 기존 DOM을 버리고 전체 목록을 다시 렌더링하게 할 것이라고 생각할 수도 있습니다. 운 좋게도 그렇지 않습니다. Vue는 DOM 요소 재사용을 극대화하기 위해 일부 스마트 휴리스틱을 구현하므로 겹치는 객체를 포함하는 다른 어레이로 배열을 바꾸는 것이 매우 효율적인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="af73f4fae217fbf1fdd9f84b803aac67150174c7" translate="yes" xml:space="preserve">
          <source>You normally won&amp;rsquo;t have to use these, but they&amp;rsquo;re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</source>
          <target state="translated">일반적으로이를 사용할 필요는 없지만 구성 요소 인스턴스에서 이벤트를 수동으로 수신해야하는 경우에 사용할 수 있습니다. 또한 코드 구성 도구로 유용 할 수 있습니다. 예를 들어, 타사 라이브러리를 통합 할 때이 패턴이 자주 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32cb581eeb56efa438796b9971ee44ba01ae446b" translate="yes" xml:space="preserve">
          <source>You pass a router property to a Vue instance:</source>
          <target state="translated">라우터 속성을 Vue 인스턴스에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="efb25a0ae9444bc1df853a464d4343356ffb5415" translate="yes" xml:space="preserve">
          <source>You probably have noticed the use of &lt;code&gt;toRefs&lt;/code&gt; at the top of our &lt;code&gt;setup&lt;/code&gt;. This is to ensure our watcher will react to changes made to the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6607184e34ec98c705e8936d4bd119debd7a5883" translate="yes" xml:space="preserve">
          <source>You should add a link at the top of each page that goes directly to the main content area so users can skip content that is repeated on multiple Web pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cbb9b4948567ec7d8fcd49f2d19a471f8d2b2a" translate="yes" xml:space="preserve">
          <source>You should ensure your initial value for &lt;code&gt;text&lt;/code&gt; is &amp;ldquo;hello world&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 의 초기 값 이 &quot;hello world&quot; 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0388064a0faab22748fe939b523209cc3a4161d9" translate="yes" xml:space="preserve">
          <source>You should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45a86f83ace1c03cb53baba5bc8187e35c91e8d" translate="yes" xml:space="preserve">
          <source>You still have access to the original value of the prop.</source>
          <target state="translated">여전히 소품의 원래 가치에 접근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11c1c2c028934d5bbcb142d155ffb56c0c189c5b" translate="yes" xml:space="preserve">
          <source>You would add new, reactive properties with:</source>
          <target state="translated">다음을 사용하여 새로운 반응 형 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="20728f1a16caf4befc427a8e6e74564862df5ba2" translate="yes" xml:space="preserve">
          <source>You would now write:</source>
          <target state="translated">이제 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="161f58130bcdfa0a115e5914f0b475cdc7c281e0" translate="yes" xml:space="preserve">
          <source>You would use:</source>
          <target state="translated">당신은 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="23069654131c71fce55bf35e4df935bea4d59d1a" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need to update it like this:</source>
          <target state="translated">다음과 같이 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce8b38bdf63cc6de78844a6e80332a8d228551d1" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it&amp;rsquo;s no longer showing the post you selected. That&amp;rsquo;s because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="translated">게시물을 선택하고 &lt;em&gt;보관&lt;/em&gt; 탭으로 전환 한 다음 다시 &lt;em&gt;게시물&lt;/em&gt; 로 전환 하면 선택한 게시물이 더 이상 표시되지 않습니다. 새 탭으로 전환 할 때마다 Vue는 &lt;code&gt;currentTabComponent&lt;/code&gt; 의 새 인스턴스를 생성하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="24954ec56901e878c0cebe8e9e38748e3b95f2bf" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see other examples of modifiers later, &lt;a href=&quot;events#Event-Modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#Modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="translated">당신은 나중에 수정의 다른 예를 볼 수 있습니다 &lt;a href=&quot;events#Event-Modifiers&quot;&gt;위한 &lt;code&gt;v-on&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;forms#Modifiers&quot;&gt;대한 &lt;code&gt;v-model&lt;/code&gt; &lt;/a&gt; 우리가 그 기능을 탐색 할 때.</target>
        </trans-unit>
        <trans-unit id="3fca6997a996507a0a2f511c041749b30ea59a71" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt;, such as in:</source>
          <target state="translated">&lt;code&gt;v-bind&lt;/code&gt; 와 함께 동적으로 할당 된 소품도 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="e7be35175595e36028a58566d499b0922b290b29" translate="yes" xml:space="preserve">
          <source>You'll find very quickly that &lt;code&gt;out-in&lt;/code&gt; is the state you will want most of the time 😃</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534161e1c7e94319d05a92ec6723a8bacc8c01a4" translate="yes" xml:space="preserve">
          <source>You'll notice that if you select a post, switch to the &lt;em&gt;Archive&lt;/em&gt; tab, then switch back to &lt;em&gt;Posts&lt;/em&gt;, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the &lt;code&gt;currentTabComponent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daeca355004e5e6b6695c8995c5901fed3362699" translate="yes" xml:space="preserve">
          <source>You'll see other examples of modifiers later, &lt;a href=&quot;events#event-modifiers&quot;&gt;for &lt;code&gt;v-on&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;forms#modifiers&quot;&gt;for &lt;code&gt;v-model&lt;/code&gt;&lt;/a&gt;, when we explore those features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a835cf811b8522c8db0e1f6d873fc28bdc60bb" translate="yes" xml:space="preserve">
          <source>You've also seen props assigned dynamically with &lt;code&gt;v-bind&lt;/code&gt; or its shortcut, the &lt;code&gt;:&lt;/code&gt; character, such as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b27e33e416edbd67daffe51a424c0c9ef6b0f3" translate="yes" xml:space="preserve">
          <source>Your browser does not support the video tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16495c712ef4bb3f6daaec07a27bda6dcb2de3b" translate="yes" xml:space="preserve">
          <source>Your inline template needs to be defined inside the DOM element to which Vue is attached.</source>
          <target state="translated">Vue가 연결된 DOM 요소 내에 인라인 템플릿을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a898991781228e1b8f324be36491bab255f87e5" translate="yes" xml:space="preserve">
          <source>Your x-template needs to be defined outside the DOM element to which Vue is attached.</source>
          <target state="translated">V- 템플릿은 Vue가 연결된 DOM 요소 외부에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="719b3279429110b4281221c4c4d4388f5c5f6d57" translate="yes" xml:space="preserve">
          <source>ZoomText (opens new window)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954963c855d044c40d394debb8685e798d25e0c3" translate="yes" xml:space="preserve">
          <source>Zooming Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a221925ebff8ab7b21b8e492fd8afd314da61e41" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/eslint-plugin-vue&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808b02ba7769882289f391dd6032af22b8a8bcfc" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/jsx-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25af989e02d5c99908ae438d2926502894ee2e7e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/rollup-plugin-vue/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baa16f6d48ca446fc08d35723e042c4ab28008f" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-class-component/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36204eda54f3ff6c52797fd1a52e5a030c6b5463" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-loader/tree/next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8ba12c942b8b26403cd1f4cc7f6445d6ba6cd3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;https://github.com/vuejs/vue-test-utils-next&quot;&gt;GitHub (opens new window)&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d0755f22a328b4f298c59f5483245132c44891" translate="yes" xml:space="preserve">
          <source>[] Syntax for Arrays in Queries &lt;sup&gt;removed&lt;/sup&gt;</source>
          <target state="translated">[] 쿼리의 배열 구문이 &lt;sup&gt;제거되었습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="05f06f89e67d5e29faafce2571087b800d959cf1" translate="yes" xml:space="preserve">
          <source>a component&amp;rsquo;s options object</source>
          <target state="translated">컴포넌트의 옵션 객체</target>
        </trans-unit>
        <trans-unit id="aac58ea6af883add3a2d5783edf0931a374353ca" translate="yes" xml:space="preserve">
          <source>a component's options object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6f977aae904b70e03db8be89e04306d985fff9" translate="yes" xml:space="preserve">
          <source>a computed property</source>
          <target state="translated">계산 된 재산</target>
        </trans-unit>
        <trans-unit id="bdcd6b24d7256da2dc86cd11b5e2bfc22f0bbfd9" translate="yes" xml:space="preserve">
          <source>a data property, with the prop used to set its default value</source>
          <target state="translated">소품이 기본값을 설정하는 데 사용되는 데이터 속성</target>
        </trans-unit>
        <trans-unit id="0a2a5fb75e421181bc33cbe4cff3883b8bc3e0c5" translate="yes" xml:space="preserve">
          <source>activated</source>
          <target state="translated">activated</target>
        </trans-unit>
        <trans-unit id="afa841449d16eb794efb8d9de6a6f1dba60b5507" translate="yes" xml:space="preserve">
          <source>an array of strings, or</source>
          <target state="translated">문자열 배열 또는</target>
        </trans-unit>
        <trans-unit id="8ba29b644bf0d96ca60dcdd83182f0d4523d6d61" translate="yes" xml:space="preserve">
          <source>an object where the keys are the local binding name and the value is either:</source>
          <target state="translated">키가 로컬 바인딩 이름이고 값이 다음과 같은 객체 :</target>
        </trans-unit>
        <trans-unit id="1f0fd3140718ffb119179b1d6559195ecab794b0" translate="yes" xml:space="preserve">
          <source>an object where:</source>
          <target state="translated">다음과 같은 객체 :</target>
        </trans-unit>
        <trans-unit id="183f9cf8e98ab46fad30f22829e7359386bcc859" translate="yes" xml:space="preserve">
          <source>ancestor components don&amp;rsquo;t need to know which descendants use the properties it provides</source>
          <target state="translated">조상 구성 요소는 제공하는 속성을 사용하는 자손을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="435c0eff27e6bd37bfd007287d502c24caaa618e" translate="yes" xml:space="preserve">
          <source>and custom JavaScript hooks:</source>
          <target state="translated">사용자 정의 JavaScript 후크 :</target>
        </trans-unit>
        <trans-unit id="467081e5090da9dbbbeef46980aa3215471c51a8" translate="yes" xml:space="preserve">
          <source>app.component</source>
          <target state="translated">app.component</target>
        </trans-unit>
        <trans-unit id="5242c228688e376d238375da2e61daa4d72f01db" translate="yes" xml:space="preserve">
          <source>app.config</source>
          <target state="translated">app.config</target>
        </trans-unit>
        <trans-unit id="18219ca7f262cc06aea854c86b553561b308e57f" translate="yes" xml:space="preserve">
          <source>app.config.globalProperties (&lt;a href=&quot;#vue-prototype-replaced-by-config-globalproperties&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a870440d8c7f82a6a1f2568c003080c77c5339e" translate="yes" xml:space="preserve">
          <source>app.config.isCustomElement (&lt;a href=&quot;#config-ignoredelements-is-now-config-iscustomelement&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85ceb7e6fd9d135c221589e806583d76513472" translate="yes" xml:space="preserve">
          <source>app.directive</source>
          <target state="translated">app.directive</target>
        </trans-unit>
        <trans-unit id="4c693e55b34812b4bae7c65ed8632f25ecb7dd87" translate="yes" xml:space="preserve">
          <source>app.mixin</source>
          <target state="translated">app.mixin</target>
        </trans-unit>
        <trans-unit id="1f2300b97dba467c4a8c4a56ebdb0ce97fcb714d" translate="yes" xml:space="preserve">
          <source>app.use (&lt;a href=&quot;#a-note-for-plugin-authors&quot;&gt;see below&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e046efd172457735b44f7929fe7efc0747f1" translate="yes" xml:space="preserve">
          <source>aria-describedby</source>
          <target state="translated">aria-describedby</target>
        </trans-unit>
        <trans-unit id="e4f0ab341d5e8e82e3d8dc99926c2333f783f688" translate="yes" xml:space="preserve">
          <source>aria-hidden=&quot;true&quot;</source>
          <target state="translated">aria-hidden=&quot;true&quot;</target>
        </trans-unit>
        <trans-unit id="c399d0d9385cb50ef9a74487c5e1ea13ac3f984e" translate="yes" xml:space="preserve">
          <source>aria-label</source>
          <target state="translated">aria-label</target>
        </trans-unit>
        <trans-unit id="ec0bffb04210018ec41d270900cc33a6714de325" translate="yes" xml:space="preserve">
          <source>aria-labelledby</source>
          <target state="translated">aria-labelledby</target>
        </trans-unit>
        <trans-unit id="f68ce285b8377013d64f60cad53e6825b9961b6a" translate="yes" xml:space="preserve">
          <source>as a performance optimization, because they initialized much faster than stateful components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77cad1467608c98b4675073084c13ea3aba2ffb" translate="yes" xml:space="preserve">
          <source>aside</source>
          <target state="translated">aside</target>
        </trans-unit>
        <trans-unit id="394bb07928a366287168902c26665311049fa093" translate="yes" xml:space="preserve">
          <source>authoring tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d006c05ec9429e15a41c040a3bce4c19f3e5bf12" translate="yes" xml:space="preserve">
          <source>automatically apply classes for CSS transitions and animations</source>
          <target state="translated">CSS 전환 및 애니메이션에 클래스를 자동으로 적용</target>
        </trans-unit>
        <trans-unit id="cf96e5119b1388a4b34a03ab22f4668c3d645b8d" translate="yes" xml:space="preserve">
          <source>backed by this data:</source>
          <target state="translated">이 데이터를 바탕으로 :</target>
        </trans-unit>
        <trans-unit id="cce342be435b5f51f04f16e98c3fefe789ea7c5f" translate="yes" xml:space="preserve">
          <source>be able to copy and paste most community code examples without modification</source>
          <target state="translated">대부분의 커뮤니티 코드 예제를 수정하지 않고 복사하여 붙여 넣기 가능</target>
        </trans-unit>
        <trans-unit id="761fb4d2dcb65a5b7e1da135705a631428b3960c" translate="yes" xml:space="preserve">
          <source>beforeCreate</source>
          <target state="translated">beforeCreate</target>
        </trans-unit>
        <trans-unit id="fb7b61aa27d85a7c0d89dbb8710f2b4ce42d0a55" translate="yes" xml:space="preserve">
          <source>beforeDestroy</source>
          <target state="translated">beforeDestroy</target>
        </trans-unit>
        <trans-unit id="86fa6b808c6c10e368e48d1722281f10de42f6e9" translate="yes" xml:space="preserve">
          <source>beforeMount</source>
          <target state="translated">beforeMount</target>
        </trans-unit>
        <trans-unit id="8acebefba44388f598e2b99e8302ab67d355632c" translate="yes" xml:space="preserve">
          <source>beforeUnmount</source>
          <target state="translated">beforeUnmount</target>
        </trans-unit>
        <trans-unit id="fc8ab7b582911146b3b4dd03b3bdbdc1ab81a594" translate="yes" xml:space="preserve">
          <source>beforeUpdate</source>
          <target state="translated">beforeUpdate</target>
        </trans-unit>
        <trans-unit id="77c5f425bb928c51b842ddf1e44748f43c932105" translate="yes" xml:space="preserve">
          <source>bind &amp;rarr; &lt;strong&gt;beforeMount&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9fb8d92972382b39b524ce7f8cdc6213d95500" translate="yes" xml:space="preserve">
          <source>binding</source>
          <target state="translated">binding</target>
        </trans-unit>
        <trans-unit id="8e2b6e21dfdfc190c998d11093ac469ffd7f3aed" translate="yes" xml:space="preserve">
          <source>breaking</source>
          <target state="translated">breaking</target>
        </trans-unit>
        <trans-unit id="e7e9a567c503b2e50fdbc398b040c30a13bd8f80" translate="yes" xml:space="preserve">
          <source>checkboxes and radiobuttons use &lt;code&gt;checked&lt;/code&gt; property and &lt;code&gt;change&lt;/code&gt; event;</source>
          <target state="translated">확인란과 라디오 버튼은 &lt;code&gt;checked&lt;/code&gt; 속성 및 &lt;code&gt;change&lt;/code&gt; 이벤트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db88192ef37fddf9df1a8a94d3fa600728fa8e81" translate="yes" xml:space="preserve">
          <source>checking your codebase for &lt;code&gt;.sync&lt;/code&gt; usage and replace it with &lt;code&gt;v-model&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cbf9910961b7b720be422c5227a48b45481be1" translate="yes" xml:space="preserve">
          <source>child components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42685f11da91a55b1f5c5b782edb2f0fc1dd5148" translate="yes" xml:space="preserve">
          <source>children</source>
          <target state="translated">children</target>
        </trans-unit>
        <trans-unit id="a486e7ea0cf0cfcfc85d9c25120d9f0151c2792b" translate="yes" xml:space="preserve">
          <source>colors displayed</source>
          <target state="translated">표시되는 색상</target>
        </trans-unit>
        <trans-unit id="5b17a6c606a82dafd93db84a19945afe2d559ed4" translate="yes" xml:space="preserve">
          <source>comments</source>
          <target state="translated">comments</target>
        </trans-unit>
        <trans-unit id="335c4c1e2f05b5297a56769d8de75ad9c4874cd3" translate="yes" xml:space="preserve">
          <source>component</source>
          <target state="translated">component</target>
        </trans-unit>
        <trans-unit id="ddcc491de82ebec3c03853395e5b60c154cbc452" translate="yes" xml:space="preserve">
          <source>componentUpdated &amp;rarr; &lt;strong&gt;updated&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c212f08ed1157ae268fd83d142afd5ccd48664b2" translate="yes" xml:space="preserve">
          <source>components</source>
          <target state="translated">components</target>
        </trans-unit>
        <trans-unit id="4ebaef57b71a3ae20e28c13e1420fb5ed634b545" translate="yes" xml:space="preserve">
          <source>computed</source>
          <target state="translated">computed</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f568e3b2e689e9753b26737cdc027b1633a22b7e" translate="yes" xml:space="preserve">
          <source>createApp</source>
          <target state="translated">createApp</target>
        </trans-unit>
        <trans-unit id="43caa510c0daadd6d3dc4ad43a5427148c2e6d9c" translate="yes" xml:space="preserve">
          <source>createRenderer</source>
          <target state="translated">createRenderer</target>
        </trans-unit>
        <trans-unit id="21c50805b553b7a40e48394a5d77d442587ddee2" translate="yes" xml:space="preserve">
          <source>created</source>
          <target state="translated">created</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="4858ba92ec21f96af837089e5c3d7e06fcbf313a" translate="yes" xml:space="preserve">
          <source>deactivated</source>
          <target state="translated">deactivated</target>
        </trans-unit>
        <trans-unit id="d8844c3455799a9155c640b8dcfd223ef31c8542" translate="yes" xml:space="preserve">
          <source>defineAsyncComponent</source>
          <target state="translated">defineAsyncComponent</target>
        </trans-unit>
        <trans-unit id="0b351e6c4acf449188607d84ef9ac58fe7aff147" translate="yes" xml:space="preserve">
          <source>defineComponent</source>
          <target state="translated">defineComponent</target>
        </trans-unit>
        <trans-unit id="68b8b8520c00c2719c966d9dcb2bb957972581e7" translate="yes" xml:space="preserve">
          <source>delimiters</source>
          <target state="translated">delimiters</target>
        </trans-unit>
        <trans-unit id="a24bc0a57325762a96243f075d13449452f9b8b0" translate="yes" xml:space="preserve">
          <source>descendant components don&amp;rsquo;t need to know where injected properties are coming from</source>
          <target state="translated">하위 컴포넌트는 주입 된 속성이 어디에서 오는지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b148f44e1a22c3e6e463576927f5b9c961fe05d" translate="yes" xml:space="preserve">
          <source>destroyed</source>
          <target state="translated">destroyed</target>
        </trans-unit>
        <trans-unit id="154cfec6bb116856227577921ae39f8885428eb2" translate="yes" xml:space="preserve">
          <source>devtools</source>
          <target state="translated">devtools</target>
        </trans-unit>
        <trans-unit id="3d981bf920ab98c455a9796d062745b9d6b5cbfb" translate="yes" xml:space="preserve">
          <source>directive</source>
          <target state="translated">directive</target>
        </trans-unit>
        <trans-unit id="5b41ba2601e37104d54d7666ca68c4f5e11a1c4c" translate="yes" xml:space="preserve">
          <source>directives</source>
          <target state="translated">directives</target>
        </trans-unit>
        <trans-unit id="064b9e1c3d444b95c7dadc7c61ec024d1be16721" translate="yes" xml:space="preserve">
          <source>does the same thing as:</source>
          <target state="translated">다음과 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="72ef9ecc0ee2490979708ebb01e137eae4c8f425" translate="yes" xml:space="preserve">
          <source>e.g. &lt;code&gt;.enter&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1ea4f09db2aaafb0a92c0b9e57751121ed6647" translate="yes" xml:space="preserve">
          <source>el</source>
          <target state="translated">el</target>
        </trans-unit>
        <trans-unit id="53f9ce69544263d25131c6704271a197bba315a5" translate="yes" xml:space="preserve">
          <source>emits</source>
          <target state="translated">emits</target>
        </trans-unit>
        <trans-unit id="01b78ec3ef69d582c34c04fd02137b4b2a0b2057" translate="yes" xml:space="preserve">
          <source>ensure that all your components document their events with the &lt;code&gt;emits&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8cde4c5110e00e8ab6ca4b7d2c6edd8a17e9ab" translate="yes" xml:space="preserve">
          <source>errorCaptured</source>
          <target state="translated">errorCaptured</target>
        </trans-unit>
        <trans-unit id="4c2276426206f2c8fe07194eb022393389343699" translate="yes" xml:space="preserve">
          <source>errorHandler</source>
          <target state="translated">errorHandler</target>
        </trans-unit>
        <trans-unit id="72f59f31388477ad92fbebfc6b623eb3ba553f3e" translate="yes" xml:space="preserve">
          <source>eslint-plugin-vue</source>
          <target state="translated">eslint-plugin-vue</target>
        </trans-unit>
        <trans-unit id="e9922bd8a80da72306d79eeaf9a6b98cb64268db" translate="yes" xml:space="preserve">
          <source>event: &lt;code&gt;input&lt;/code&gt; -&amp;gt; &lt;code&gt;update:modelValue&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27219f98594d851506e670e303db3d394bbf7d6" translate="yes" xml:space="preserve">
          <source>exposes the same events as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 동일한 이벤트를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="eecc8a607a5b6bcf2f4cfccabf69cad7dd41577c" translate="yes" xml:space="preserve">
          <source>exposes the same props as &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; except &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 를 제외하고 &lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt; 과 동일한 소품을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="2b781ff8e3327e3e897ec571fa02fec12242e7dd" translate="yes" xml:space="preserve">
          <source>extends</source>
          <target state="translated">extends</target>
        </trans-unit>
        <trans-unit id="9ce5ff458c686cc5e9436295af1c60fa27be6140" translate="yes" xml:space="preserve">
          <source>filters</source>
          <target state="translated">filters</target>
        </trans-unit>
        <trans-unit id="d7eb6b340a11a367a1bec55e4a421d949214759f" translate="yes" xml:space="preserve">
          <source>footer</source>
          <target state="translated">footer</target>
        </trans-unit>
        <trans-unit id="acb51e7c16264c729e7521b40c23a4b9d8986b65" translate="yes" xml:space="preserve">
          <source>for all &lt;code&gt;v-model&lt;/code&gt;s without arguments, make sure to change props and events name to &lt;code&gt;modelValue&lt;/code&gt; and &lt;code&gt;update:modelValue&lt;/code&gt; respectively</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00b39815c187d832cef3239eb7a77580728dc47" translate="yes" xml:space="preserve">
          <source>form</source>
          <target state="translated">form</target>
        </trans-unit>
        <trans-unit id="abb0afab1fe624aaec8f1353940f7784a64dee93" translate="yes" xml:space="preserve">
          <source>fully support both Vue 1.0 and 2.0</source>
          <target state="translated">Vue 1.0과 2.0을 완벽하게 지원</target>
        </trans-unit>
        <trans-unit id="f3605082b0a1ec03cd430e3897145a2220e6a57c" translate="yes" xml:space="preserve">
          <source>functional</source>
          <target state="translated">functional</target>
        </trans-unit>
        <trans-unit id="8574ae3fb0102e604b132e245a7a13501af7382a" translate="yes" xml:space="preserve">
          <source>globalProperties</source>
          <target state="translated">globalProperties</target>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="594fd1615a341c77829e83ed988f137e1ba96231" translate="yes" xml:space="preserve">
          <source>header</source>
          <target state="translated">header</target>
        </trans-unit>
        <trans-unit id="aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" translate="yes" xml:space="preserve">
          <source>hello</source>
          <target state="translated">hello</target>
        </trans-unit>
        <trans-unit id="33651e92d7f8755c3775bf7e6f2865577e7988de" translate="yes" xml:space="preserve">
          <source>how to build our package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6066146b8f7a1eae3838af761cd6befdb13e6827" translate="yes" xml:space="preserve">
          <source>ignoredElements</source>
          <target state="translated">ignoredElements</target>
        </trans-unit>
        <trans-unit id="9d11a6da206f5d9ba47bfe6d9f54e66f57219274" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Named-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0 이상에서. 새로운 권장 구문 은 &lt;a href=&quot;#Named-Slots&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f4156caffb807ffaf37ccea584a3b209ba5640a" translate="yes" xml:space="preserve">
          <source>in 2.6.0+. See &lt;a href=&quot;#Scoped-Slots&quot;&gt;here&lt;/a&gt; for the new, recommended syntax.</source>
          <target state="translated">2.6.0 이상에서. 새로운 권장 구문 은 &lt;a href=&quot;#Scoped-Slots&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7f3f9b4b535ba19cfa1c71d40f8666d3627fdf8" translate="yes" xml:space="preserve">
          <source>inheritAttrs</source>
          <target state="translated">inheritAttrs</target>
        </trans-unit>
        <trans-unit id="3014bf5a29cbc2f5b4c95b4c0f384113201b257e" translate="yes" xml:space="preserve">
          <source>inserted &amp;rarr; &lt;strong&gt;mounted&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9587db9f8e8a4535e8dcb6eaa79c2cf675a7519b" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as &lt;a href=&quot;https://animate.style/&quot;&gt;Animate.css (opens new window)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66fb24fc087a328881af1d47bdb9a574b63023d8" translate="yes" xml:space="preserve">
          <source>integrate 3rd-party CSS animation libraries, such as Animate.css</source>
          <target state="translated">Animate.css와 같은 타사 CSS 애니메이션 라이브러리 통합</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
