<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cmake">
    <body>
      <group id="cmake">
        <trans-unit id="5223e155f3847f4d07db6f90e4725b0b01243e64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NAMELINK_SKIP&lt;/code&gt; is specified, &lt;code&gt;NAMELINK_COMPONENT&lt;/code&gt; has no effect. It is not recommended to use &lt;code&gt;NAMELINK_SKIP&lt;/code&gt; in conjunction with &lt;code&gt;NAMELINK_COMPONENT&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;NAMELINK_SKIP&lt;/code&gt; 가 지정되어, &lt;code&gt;NAMELINK_COMPONENT&lt;/code&gt; 는 효과가 없습니다. &lt;code&gt;NAMELINK_SKIP&lt;/code&gt; 와 함께 &lt;code&gt;NAMELINK_COMPONENT&lt;/code&gt; 를) 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a987270cba03c1cf8aac71225f3c8840a4d845d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NO_DEFAULT_PATH&lt;/code&gt; is specified, then no additional paths are added to the search. If &lt;code&gt;NO_DEFAULT_PATH&lt;/code&gt; is not specified, the search process is as follows:</source>
          <target state="translated">경우 &lt;code&gt;NO_DEFAULT_PATH&lt;/code&gt; 을 지정하면 추가 경로는 검색에 추가됩니다. 경우 &lt;code&gt;NO_DEFAULT_PATH&lt;/code&gt; 가 지정되지 않은 다음과 같이 검색 프로세스는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="75b7a0417a2b55276855bf7958eb12cee4662fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OBJC&lt;/code&gt; is not defined, the &lt;a href=&quot;cc#envvar:CC&quot; id=&quot;index-0-envvar:CC&quot;&gt;&lt;code&gt;CC&lt;/code&gt;&lt;/a&gt; environment variable will be checked instead.</source>
          <target state="translated">경우 &lt;code&gt;OBJC&lt;/code&gt; 가 정의되지는 &lt;a href=&quot;cc#envvar:CC&quot; id=&quot;index-0-envvar:CC&quot;&gt; &lt;code&gt;CC&lt;/code&gt; 의&lt;/a&gt; 환경 변수 대신에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="1983a499ccecab18da55abcd8ff3314d22b08562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OBJCXX&lt;/code&gt; is not defined, the &lt;a href=&quot;cxx#envvar:CXX&quot; id=&quot;index-0-envvar:CXX&quot;&gt;&lt;code&gt;CXX&lt;/code&gt;&lt;/a&gt; environment variable will be checked instead.</source>
          <target state="translated">&lt;code&gt;OBJCXX&lt;/code&gt; 가 정의되지 않은 경우 &lt;a href=&quot;cxx#envvar:CXX&quot; id=&quot;index-0-envvar:CXX&quot;&gt; &lt;code&gt;CXX&lt;/code&gt; &lt;/a&gt; 환경 변수가 대신 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="ca1e97ca4fb52ee7a5c19b5e864755c0ce74ed69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PARENT_SCOPE&lt;/code&gt; is present then the variable is removed from the scope above the current scope. See the same option in the &lt;a href=&quot;set#command:set&quot; id=&quot;index-0-command:set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; command for further details.</source>
          <target state="translated">경우 &lt;code&gt;PARENT_SCOPE&lt;/code&gt; 가 존재 다음 변수는 현재 범위 위의 범위에서 제거된다. 자세한 내용은 &lt;a href=&quot;set#command:set&quot; id=&quot;index-0-command:set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 명령 에서 동일한 옵션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="9b49daf8b9bc2e87b53d7ce74829b289f82ac6b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PATH_SUFFIXES&lt;/code&gt; is specified, the suffixes are appended to each (&lt;code&gt;W&lt;/code&gt;) or (&lt;code&gt;U&lt;/code&gt;) directory entry one-by-one.</source>
          <target state="translated">경우 &lt;code&gt;PATH_SUFFIXES&lt;/code&gt; 가 지정되어, 접미사 각 (에 추가됩니다 &lt;code&gt;W&lt;/code&gt; ) 또는 ( &lt;code&gt;U&lt;/code&gt; ) 디렉토리 엔트리 하나씩.</target>
        </trans-unit>
        <trans-unit id="9503111aebb1371246ff62fec6c68303438de54e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PREFIX_NAME&lt;/code&gt; is specified, the argument will be used as a prefix to all generated macros.</source>
          <target state="translated">경우 &lt;code&gt;PREFIX_NAME&lt;/code&gt; 지정되어 인수는 생성 된 모든 매크로의 접두사로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a78ed9af41c6fa770151641302a09ddd7547fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Python2_FIND_FRAMEWORK&lt;/code&gt; is not defined, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt;&lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt;&lt;/a&gt; variable will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;Python2_FIND_FRAMEWORK&lt;/code&gt; 가 정의되지 않은, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt; &lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt; 에&lt;/a&gt; 있는 경우 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c3b50dbcd4132c7668313b729cabe43423050d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Python3_FIND_ABI&lt;/code&gt; is not defined, any ABI will be searched.</source>
          <target state="translated">&lt;code&gt;Python3_FIND_ABI&lt;/code&gt; 가 정의되지 않은 경우 모든 ABI가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="d2777b6b755873811701320f4aca9e9c1e83bfbe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Python3_FIND_FRAMEWORK&lt;/code&gt; is not defined, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt;&lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt;&lt;/a&gt; variable will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;Python3_FIND_FRAMEWORK&lt;/code&gt; 가 정의되지 않은, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt; &lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt; 에&lt;/a&gt; 있는 경우 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2e95dff594588354af06ddd9c66b42ffff674a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Python_FIND_ABI&lt;/code&gt; is not defined, any ABI will be searched.</source>
          <target state="translated">&lt;code&gt;Python_FIND_ABI&lt;/code&gt; 가 정의되지 않은 경우 모든 ABI가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3833a52d19f3e3d17a5af71b1eaf6d032f375029" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Python_FIND_FRAMEWORK&lt;/code&gt; is not defined, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt;&lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt;&lt;/a&gt; variable will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;Python_FIND_FRAMEWORK&lt;/code&gt; 가 정의되지 않은, &lt;a href=&quot;../variable/cmake_find_framework#variable:CMAKE_FIND_FRAMEWORK&quot; id=&quot;index-1-variable:CMAKE_FIND_FRAMEWORK&quot;&gt; &lt;code&gt;CMAKE_FIND_FRAMEWORK&lt;/code&gt; 에&lt;/a&gt; 있는 경우 변수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e2dd30e2725c1dcc8b960390418dcdde4befb6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QUIET&lt;/code&gt; is used, CTest will suppress any non-error messages that it otherwise would have printed to the console.</source>
          <target state="translated">경우 &lt;code&gt;QUIET&lt;/code&gt; 가 사용되며, CTest는 달리 콘솔에 인쇄 한 것이 아닌 오류 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fe1769fb8cc752adf87915b060c38a505893b09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SYMBOLIC&lt;/code&gt; (boolean) is set to &lt;code&gt;True&lt;/code&gt; the build system will be informed that the source file is not actually created on disk but instead used as a symbolic name for a build rule.</source>
          <target state="translated">경우 &lt;code&gt;SYMBOLIC&lt;/code&gt; (부울)이 설정되어 &lt;code&gt;True&lt;/code&gt; 빌드 시스템은 소스 파일이 실제로 디스크에 생성 대신 빌드 규칙에 대한 상징적 인 이름으로 사용되지 않음을 알려드립니다.</target>
        </trans-unit>
        <trans-unit id="c1f184a2031267879df091c13d595365978c40bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRACK&lt;/code&gt; is used, the submissions will go to the specified track on the CDash server. If no &lt;code&gt;TRACK&lt;/code&gt; is specified, the name of the model is used by default.</source>
          <target state="translated">경우 &lt;code&gt;TRACK&lt;/code&gt; 를 사용하는 경우, 제출은 CDash 서버의 지정된 트랙으로 이동합니다. &lt;code&gt;TRACK&lt;/code&gt; 을 지정 하지 않으면 기본적으로 모델 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3c861fca4272f69bb87929089c24ba66cad1d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRUE&lt;/code&gt;, CMake will neither generate installation rules nor will it generate &lt;code&gt;cmake_install.cmake&lt;/code&gt; files. This variable is &lt;code&gt;FALSE&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 인 경우 CMake는 설치 규칙을 생성하지 않으며 &lt;code&gt;cmake_install.cmake&lt;/code&gt; 파일을 생성하지 않습니다 . 이 변수는 기본적으로 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5af564aabb3bb252a1e6046d6ecc34806491ea66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRUE&lt;/code&gt;, use of deprecated functionality will issue fatal errors. If this variable is not set, CMake behaves as if it were set to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TRUE&lt;/code&gt; , 사용되지 않는 기능의 사용은 치명적인 오류를 발행합니다. 이 변수를 설정하지 않으면 CMake는 마치 &lt;code&gt;FALSE&lt;/code&gt; 로 설정된 것처럼 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="62f0a3ad1a5544a1eb14cff4b6dac2459f264bb0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;USE_BAR&lt;/code&gt; is true and &lt;code&gt;USE_ZOT&lt;/code&gt; is false, this provides an option called &lt;code&gt;USE_FOO&lt;/code&gt; that defaults to ON. Otherwise, it sets &lt;code&gt;USE_FOO&lt;/code&gt; to OFF and hides the option from the user. If the status of &lt;code&gt;USE_BAR&lt;/code&gt; or &lt;code&gt;USE_ZOT&lt;/code&gt; ever changes, any value for the &lt;code&gt;USE_FOO&lt;/code&gt; option is saved so that when the option is re-enabled it retains its old value.</source>
          <target state="translated">경우 &lt;code&gt;USE_BAR&lt;/code&gt; 가 사실이고 &lt;code&gt;USE_ZOT&lt;/code&gt; 이 거짓이라는 옵션이 제공 &lt;code&gt;USE_FOO&lt;/code&gt; 그 기본값을 ON으로합니다. 그렇지 않으면 &lt;code&gt;USE_FOO&lt;/code&gt; 를 OFF로 설정 하고 사용자에게 옵션을 숨 깁니다. &lt;code&gt;USE_BAR&lt;/code&gt; 또는 &lt;code&gt;USE_ZOT&lt;/code&gt; 의 상태가 변경되면 &lt;code&gt;USE_FOO&lt;/code&gt; 옵션의 모든 값 이 저장되어 옵션이 다시 활성화 될 때 이전 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b2f740024ee45ca83324b273739eadebf0d209c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; is set, the custom command defined by this function will create a stamp file with the name &lt;code&gt;&amp;lt;targetName&amp;gt;.stamp&lt;/code&gt; in the current binary directory whenever doxygen is re-run. With this option present, all items in &lt;code&gt;&amp;lt;filesOrDirs&amp;gt;&lt;/code&gt; must be files (i.e. no directories, symlinks or wildcards) and each of the files must exist at the time &lt;code&gt;doxygen_add_docs()&lt;/code&gt; is called. An error will be raised if any of the items listed is missing or is not a file when &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; is given. A dependency will be created on each of the files so that doxygen will only be re-run if one of the files is updated. Without the &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; option, doxygen will always be re-run if the &lt;code&gt;&amp;lt;targetName&amp;gt;&lt;/code&gt; target is built regardless of whether anything listed in &lt;code&gt;&amp;lt;filesOrDirs&amp;gt;&lt;/code&gt; has changed.</source>
          <target state="translated">경우 &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; 가 설정되어,이 함수에 의해 정의 된 사용자 정의 명령은 이름 스탬프 파일이 생성됩니다 &lt;code&gt;&amp;lt;targetName&amp;gt;.stamp&lt;/code&gt; doxygen이 재 실행 될 때마다 현재 바이너리 디렉토리에 있습니다. 이 옵션이있는 경우 &lt;code&gt;&amp;lt;filesOrDirs&amp;gt;&lt;/code&gt; 의 모든 항목은 파일이어야하며 (즉, 디렉토리, 심볼릭 링크 또는 와일드 카드 없음) 각 파일은 &lt;code&gt;doxygen_add_docs()&lt;/code&gt; 가 호출 될 때 존재해야합니다 . 나열된 항목 중 하나라도 누락되었거나 &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; 이 제공 될 때 파일이 아닌 경우 오류가 발생합니다 . 파일 중 하나가 업데이트 된 경우에만 doxygen이 다시 실행되도록 각 파일에 종속성이 생성됩니다. &lt;code&gt;USE_STAMP_FILE&lt;/code&gt; 옵션이 없으면 doxygen은 항상 다음과 같은 경우 다시 실행됩니다. &lt;code&gt;&amp;lt;targetName&amp;gt;&lt;/code&gt; 대상은 &lt;code&gt;&amp;lt;filesOrDirs&amp;gt;&lt;/code&gt; 에 나열된 항목 이 변경 되었는지 여부에 관계없이 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1d7a072cc2cc9434ed312ac21e0598694df0fd2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; is 1 or is undefined, output is written to the &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">경우 &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; 이 1 또는 정의되지, 출력에 기록됩니다 &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; 의&lt;/a&gt; 디렉토리.</target>
        </trans-unit>
        <trans-unit id="0254fd4f3b09a96cc47349e95d2214257677bf43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; is 2, a dedicated directory will be used. The path of this directory can be retrieved from the &lt;code&gt;SWIG_SUPPORT_FILES_DIRECTORY&lt;/code&gt; target property.</source>
          <target state="translated">경우 &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; 은 2, 전용 디렉토리가 사용됩니다. 이 디렉토리의 경로는 &lt;code&gt;SWIG_SUPPORT_FILES_DIRECTORY&lt;/code&gt; 대상 특성 에서 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7800eac1bfef21c1f5ab9034fd7fabbcd20a3db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; is set to 2, it is &lt;strong&gt;strongly&lt;/strong&gt; recommended to use a dedicated directory unique to the target when either the &lt;code&gt;OUTPUT_DIR&lt;/code&gt; option or the &lt;code&gt;CMAKE_SWIG_OUTDIR&lt;/code&gt; variable are specified. The output directory contents are erased as part of the target build, so to prevent interference between targets or losing other important files, each target should have its own dedicated output directory.</source>
          <target state="translated">경우 &lt;code&gt;UseSWIG_MODULE_VERSION&lt;/code&gt; 가 2로 설정,된다 &lt;strong&gt;강하게&lt;/strong&gt; 중 하나를 할 때 대상에 고유의 전용 디렉토리를 사용하는 것이 좋습니다 &lt;code&gt;OUTPUT_DIR&lt;/code&gt; 의 옵션 또는 &lt;code&gt;CMAKE_SWIG_OUTDIR&lt;/code&gt; 의 변수가 지정됩니다. 출력 디렉토리 내용은 대상 빌드의 일부로 지워 지므로 대상 간의 간섭을 막거나 다른 중요한 파일이 손실되지 않도록 각 대상에는 고유 한 출력 디렉토리가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c82f0f51b5c571a01369715817ae9b73091b0162" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WIN32&lt;/code&gt; is given the property &lt;a href=&quot;../prop_tgt/win32_executable#prop_tgt:WIN32_EXECUTABLE&quot; id=&quot;index-0-prop_tgt:WIN32_EXECUTABLE&quot;&gt;&lt;code&gt;WIN32_EXECUTABLE&lt;/code&gt;&lt;/a&gt; will be set on the target created. See documentation of that target property for details.</source>
          <target state="translated">경우 &lt;code&gt;WIN32&lt;/code&gt; 가 주어진 속성 &lt;a href=&quot;../prop_tgt/win32_executable#prop_tgt:WIN32_EXECUTABLE&quot; id=&quot;index-0-prop_tgt:WIN32_EXECUTABLE&quot;&gt; &lt;code&gt;WIN32_EXECUTABLE&lt;/code&gt; 이&lt;/a&gt; 생성 된 대상에 설정됩니다. 자세한 내용은 해당 대상 속성의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fb2ea5cf8b6a7fc3473d5e5d00dae9d1d62952d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bison&lt;/code&gt; is found, the module defines the macro:</source>
          <target state="translated">경우 &lt;code&gt;bison&lt;/code&gt; 발견, 모듈은 매크로를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="fb0232c29e2f4502ca937571d7f6879d90fdf134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;include(CPack)&lt;/code&gt; is used then by default this variable is set to the content of &lt;a href=&quot;cmake_install_default_directory_permissions#variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot; id=&quot;index-1-variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot;&gt;&lt;code&gt;CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;include(CPack)&lt;/code&gt; 기본적으로 다음 사용이 변수의 내용으로 설정되어 &lt;a href=&quot;cmake_install_default_directory_permissions#variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot; id=&quot;index-1-variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot;&gt; &lt;code&gt;CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22d72e238fd63f1ca0ecbfc31e8151ef1131ef58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; are available on the system, then we will use them to compute the square root in the &lt;code&gt;mysqrt&lt;/code&gt; function. Add the following code to the &lt;code&gt;mysqrt&lt;/code&gt; function in &lt;code&gt;MathFunctions/mysqrt.cxx&lt;/code&gt; (don&amp;rsquo;t forget the &lt;code&gt;#endif&lt;/code&gt; before returning the result!):</source>
          <target state="translated">경우 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;exp&lt;/code&gt; 시스템에서 사용할 수있는, 우리는의 제곱근을 계산하는 데 사용할 것 &lt;code&gt;mysqrt&lt;/code&gt; 의 기능. &lt;code&gt;MathFunctions/mysqrt.cxx&lt;/code&gt; 의 &lt;code&gt;mysqrt&lt;/code&gt; 함수에 다음 코드를 추가합니다 ( 결과를 반환하기 전에 &lt;code&gt;#endif&lt;/code&gt; 를 잊지 마세요 !).</target>
        </trans-unit>
        <trans-unit id="755dfbeb5796600eb5e5926c49b4e418d05d642b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make install&lt;/code&gt; is invoked and directories are implicitly created they get permissions set by &lt;a href=&quot;#variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot; id=&quot;index-0-variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot;&gt;&lt;code&gt;CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&lt;/code&gt;&lt;/a&gt; variable or platform specific default permissions if the variable is not set.</source>
          <target state="translated">경우 &lt;code&gt;make install&lt;/code&gt; 호출되고 디렉토리가 암시 적으로 만들어 그들이 설정 권한을 얻을 &lt;a href=&quot;#variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot; id=&quot;index-0-variable:CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&quot;&gt; &lt;code&gt;CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS&lt;/code&gt; 의&lt;/a&gt; 변수가 설정되지 않은 경우 변수 또는 플랫폼 특정 기본 권한을.</target>
        </trans-unit>
        <trans-unit id="9b32ea172cfac162d3c08c5ef739c2385835347e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make install&lt;/code&gt; is invoked or &lt;code&gt;INSTALL&lt;/code&gt; is built, this directory is prepended onto all install directories. This variable defaults to &lt;code&gt;/usr/local&lt;/code&gt; on UNIX and &lt;code&gt;c:/Program Files/${PROJECT_NAME}&lt;/code&gt; on Windows. See &lt;a href=&quot;cmake_install_prefix_initialized_to_default#variable:CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&lt;/code&gt;&lt;/a&gt; for how a project might choose its own default.</source>
          <target state="translated">경우 &lt;code&gt;make install&lt;/code&gt; 호출되거나 &lt;code&gt;INSTALL&lt;/code&gt; 내장되어,이 디렉토리는 모든 설치 디렉토리에 앞에 추가됩니다. 이 변수의 기본값 은 UNIX의 경우 &lt;code&gt;/usr/local&lt;/code&gt; 이고 Windows의 경우 &lt;code&gt;c:/Program Files/${PROJECT_NAME}&lt;/code&gt; 입니다. 프로젝트가 자체 기본값을 선택하는 방법 은 &lt;a href=&quot;cmake_install_prefix_initialized_to_default#variable:CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ff9193e8936ac26ee22f9207d8333e8480e4f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pkg-config&lt;/code&gt; returns multiple values for the specified variable, &lt;code&gt;resultVar&lt;/code&gt; will contain a &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;;-list&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pkg-config&lt;/code&gt; 지정된 변수에 대한 여러 값을 반환 &lt;code&gt;resultVar&lt;/code&gt; 는 를 포함합니다 &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;; -list&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf1cd5e314dd0b71b22fedd85511647dc2ae1e11" translate="yes" xml:space="preserve">
          <source>If ALL is set, the target will be added to the default build target.</source>
          <target state="translated">ALL을 설정하면 대상이 기본 빌드 대상에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="16b256dd2471e93b77c29265347ae93f5d471be1" translate="yes" xml:space="preserve">
          <source>If Boost was built using the boost-cmake project or from Boost 1.70.0 on it provides a package configuration file for use with find_package&amp;rsquo;s config mode. This module looks for the package configuration file called &lt;code&gt;BoostConfig.cmake&lt;/code&gt; or &lt;code&gt;boost-config.cmake&lt;/code&gt; and stores the result in &lt;code&gt;CACHE&lt;/code&gt; entry &amp;ldquo;Boost_DIR&amp;rdquo;. If found, the package configuration file is loaded and this module returns with no further action. See documentation of the Boost CMake package configuration for details on what it provides.</source>
          <target state="translated">Boost가 boost-cmake 프로젝트 또는 Boost 1.70.0에서 빌드 된 경우 find_package의 구성 모드와 함께 사용할 패키지 구성 파일을 제공합니다. 이 모듈은 &lt;code&gt;BoostConfig.cmake&lt;/code&gt; 또는 &lt;code&gt;boost-config.cmake&lt;/code&gt; 라는 패키지 구성 파일을 찾아 결과를 &lt;code&gt;CACHE&lt;/code&gt; 항목&amp;ldquo;Boost_DIR&amp;rdquo; 에 저장합니다 . 발견되면 패키지 구성 파일이로드되고이 모듈은 추가 조치없이 리턴됩니다. 제공되는 기능에 대한 자세한 내용은 Boost CMake 패키지 구성 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d91ec96a190cb075995286d5fc9e0cdae317050" translate="yes" xml:space="preserve">
          <source>If CMake is currently processing deferred calls scheduled by the &lt;a href=&quot;../command/cmake_language#command:cmake_language&quot; id=&quot;index-0-command:cmake_language&quot;&gt;&lt;code&gt;cmake_language(DEFER)&lt;/code&gt;&lt;/a&gt; command, this variable evaluates to &lt;code&gt;DEFERRED&lt;/code&gt; instead of a specific line number.</source>
          <target state="translated">CMake가 현재 &lt;a href=&quot;../command/cmake_language#command:cmake_language&quot; id=&quot;index-0-command:cmake_language&quot;&gt; &lt;code&gt;cmake_language(DEFER)&lt;/code&gt; &lt;/a&gt; 명령에 의해 예약 된 지연된 호출을 처리하고있는 경우이 변수 는 특정 줄 번호 대신 &lt;code&gt;DEFERRED&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="029bb713c83429f5d5e7995236e27a13ac47bb96" translate="yes" xml:space="preserve">
          <source>If CMake is run with the Makefile or Ninja generator, then &lt;code&gt;include(CPack)&lt;/code&gt; also generates a target &lt;code&gt;package_source&lt;/code&gt;. To build a source package, instead of &lt;code&gt;cpack -G TGZ --config CPackSourceConfig.cmake&lt;/code&gt; one may call &lt;code&gt;cmake --build . --target package_source&lt;/code&gt;, &lt;code&gt;make package_source&lt;/code&gt;, or &lt;code&gt;ninja package_source&lt;/code&gt;.</source>
          <target state="translated">CMake가 Makefile 또는 Ninja 생성기로 실행되는 경우 &lt;code&gt;include(CPack)&lt;/code&gt; 은 대상 &lt;code&gt;package_source&lt;/code&gt; 도 생성합니다 . 소스 패키지를 빌드하려면 &lt;code&gt;cpack -G TGZ --config CPackSourceConfig.cmake&lt;/code&gt; 대신 &lt;code&gt;cmake --build . --target package_source&lt;/code&gt; 호출 할 수 있습니다 . --target package_source , &lt;code&gt;make package_source&lt;/code&gt; 또는 &lt;code&gt;ninja package_source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d825ba1b0d98086890654b869a50e96b19fd86f" translate="yes" xml:space="preserve">
          <source>If CMake is run with the Makefile, Ninja, or Xcode generator, then &lt;code&gt;include(CPack)&lt;/code&gt; generates a target &lt;code&gt;package&lt;/code&gt;. This makes it possible to build a binary installer from CMake, Make, or Ninja: Instead of &lt;code&gt;cpack&lt;/code&gt;, one may call &lt;code&gt;cmake --build . --target package&lt;/code&gt; or &lt;code&gt;make package&lt;/code&gt; or &lt;code&gt;ninja package&lt;/code&gt;. The VS generator creates an uppercase target &lt;code&gt;PACKAGE&lt;/code&gt;.</source>
          <target state="translated">CMake가 Makefile, Ninja 또는 Xcode 생성기로 실행되는 경우 &lt;code&gt;include(CPack)&lt;/code&gt; 은 대상 &lt;code&gt;package&lt;/code&gt; 생성 합니다 . 이를 통해 CMake, Make 또는 Ninja에서 바이너리 설치 프로그램을 빌드 할 수 있습니다 &lt;code&gt;cmake --build . --target package&lt;/code&gt; &lt;code&gt;cpack&lt;/code&gt; 대신 cmake --build를 호출 할 수 있습니다 . --target package 또는 &lt;code&gt;make package&lt;/code&gt; 또는 &lt;code&gt;ninja package&lt;/code&gt; . VS 생성기는 대문자 대상 &lt;code&gt;PACKAGE&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e6f339798b174d94e66a83a4fe08aba5893b9034" translate="yes" xml:space="preserve">
          <source>If CTest is asked to run only a subset of tests (e.g. using regular expressions or the &lt;code&gt;--rerun-failed&lt;/code&gt; option) and the cleanup test is not in the set of tests to run, it will automatically be added if any tests in the set require any fixture listed in &lt;code&gt;FIXTURES_CLEANUP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--rerun-failed&lt;/code&gt; 에 테스트의 하위 집합 만 실행하도록 요청한 경우 (예 : 정규식 또는 --rerun-failed 옵션 사용) 정리 테스트가 실행할 테스트 세트에없는 경우 세트의 테스트가 있으면 자동으로 추가됩니다 &lt;code&gt;FIXTURES_CLEANUP&lt;/code&gt; 에 나열된 조명기가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="5d267b6bb4d5ef12baed307fada0f826a8ec855e" translate="yes" xml:space="preserve">
          <source>If CTest is asked to run only a subset of tests (e.g. using regular expressions or the &lt;code&gt;--rerun-failed&lt;/code&gt; option) and the setup test is not in the set of tests to run, it will automatically be added if any tests in the set require any fixture listed in &lt;code&gt;FIXTURES_SETUP&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--rerun-failed&lt;/code&gt; 에 테스트의 하위 집합 만 실행하도록 요청한 경우 (예 : 정규식 또는 --rerun-failed 옵션 사용) 설정 테스트가 실행할 테스트 세트에없는 경우 세트의 테스트가 있으면 자동으로 추가됩니다 &lt;code&gt;FIXTURES_SETUP&lt;/code&gt; 에 나열된 조명기가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ec58b23c55b54b9b245b4918924f5e51892c14fc" translate="yes" xml:space="preserve">
          <source>If CURL was built using the CMake buildsystem then it provides its own &lt;code&gt;CURLConfig.cmake&lt;/code&gt; file for use with the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; command&amp;rsquo;s config mode. This module looks for this file and, if found, returns its results with no further action.</source>
          <target state="translated">CURL이 CMake 빌드 시스템을 사용하여 빌드 된 경우 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령의 구성 모드 와 함께 사용할 자체 &lt;code&gt;CURLConfig.cmake&lt;/code&gt; 파일을 제공 합니다. 이 모듈은이 파일을 찾고 발견 된 경우 추가 작업없이 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abf02ccdb2d3409a988d8d038ccd606ad63d705e" translate="yes" xml:space="preserve">
          <source>If False, do not try to use the relevant CMake wrapping command.</source>
          <target state="translated">False 인 경우 관련 CMake Wrapping 명령을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="45d44b1292592dc708ef500f8cba7911a8ffd925" translate="yes" xml:space="preserve">
          <source>If False, optional Yy part of Xxx system is not available.</source>
          <target state="translated">False이면 Xxx 시스템의 선택적 Yy 부분을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab02204c2b483912e1b1bf78f7f3a02eccba3411" translate="yes" xml:space="preserve">
          <source>If GSL is found, this module defines the following &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-0-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; targets:</source>
          <target state="translated">GSL을 찾으면이 모듈은 다음과 같은 &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-0-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1b9301d9a14b3d0ef762051513d0e3346a23233c" translate="yes" xml:space="preserve">
          <source>If USE_BAR is true and USE_ZOT is false, this provides an option called USE_FOO that defaults to ON. Otherwise, it sets USE_FOO to OFF. If the status of USE_BAR or USE_ZOT ever changes, any value for the USE_FOO option is saved so that when the option is re-enabled it retains its old value.</source>
          <target state="translated">USE_BAR이 true이고 USE_ZOT가 false 인 경우 USE_FOO라는 옵션을 제공하며 기본값은 ON입니다. 그렇지 않으면 USE_FOO를 OFF로 설정합니다. USE_BAR 또는 USE_ZOT의 상태가 계속 변경되면 USE_FOO 옵션의 값이 저장되므로 옵션을 다시 사용할 때 이전 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6133a60b4a2b7a6507e2c6571908a17624d85b99" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CMAKE_TARGET_MESSAGES&lt;/code&gt; cache entry exists its value initializes the value of this property.</source>
          <target state="translated">경우 &lt;code&gt;CMAKE_TARGET_MESSAGES&lt;/code&gt; 의 캐시 항목이 존재 그 값이 속성의 값을 초기화한다.</target>
        </trans-unit>
        <trans-unit id="38ad99888bdf2e2daa11c3fbdeb77bf0f28d6156" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;FILENAME&lt;/code&gt; is given, the information is printed into this file. If &lt;code&gt;APPEND&lt;/code&gt; is used, it is appended to this file, otherwise the file is overwritten if it already existed. If the VAR option is used, the information is &amp;ldquo;printed&amp;rdquo; into the specified variable. If &lt;code&gt;FILENAME&lt;/code&gt; is not used, the information is printed to the terminal. Using the &lt;code&gt;DESCRIPTION&lt;/code&gt; option a description or headline can be set which will be printed above the actual content. If only one type of package was requested, no title is printed, unless it is explicitly set using either &lt;code&gt;DESCRIPTION&lt;/code&gt; to use a custom string, or &lt;code&gt;DEFAULT_DESCRIPTION&lt;/code&gt; to use a default title for the requested type. If &lt;code&gt;INCLUDE_QUIET_PACKAGES&lt;/code&gt; is given, packages which have been searched with &lt;code&gt;find_package(... QUIET)&lt;/code&gt; will also be listed. By default they are skipped. If &lt;code&gt;FATAL_ON_MISSING_REQUIRED_PACKAGES&lt;/code&gt; is given, CMake will abort if a package which is marked as one of the package types listed in the &lt;a href=&quot;#variable:FeatureSummary_REQUIRED_PKG_TYPES&quot; id=&quot;index-1-variable:FeatureSummary_REQUIRED_PKG_TYPES&quot;&gt;&lt;code&gt;FeatureSummary_REQUIRED_PKG_TYPES&lt;/code&gt;&lt;/a&gt; global property has not been found. The default value for the &lt;a href=&quot;#variable:FeatureSummary_REQUIRED_PKG_TYPES&quot; id=&quot;index-2-variable:FeatureSummary_REQUIRED_PKG_TYPES&quot;&gt;&lt;code&gt;FeatureSummary_REQUIRED_PKG_TYPES&lt;/code&gt;&lt;/a&gt; global property is &lt;code&gt;REQUIRED&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;FILENAME&lt;/code&gt; 주어집니다, 정보가이 파일로 인쇄됩니다. 경우 &lt;code&gt;APPEND&lt;/code&gt; 가 사용됩니다, 이미 존재하는 경우, 그렇지 않으면 파일이 덮어 쓰기,이 파일에 추가됩니다. VAR 옵션을 사용하면 정보가 지정된 변수에 &quot;인쇄&quot;됩니다. 경우 &lt;code&gt;FILENAME&lt;/code&gt; 사용되지 않는, 정보 단말에 출력된다. &lt;code&gt;DESCRIPTION&lt;/code&gt; 옵션을 사용하면 실제 내용 위에 인쇄 될 설명이나 헤드 라인을 설정할 수 있습니다. 패키지 유형이 하나만 요청 된 경우 &lt;code&gt;DESCRIPTION&lt;/code&gt; 을 사용하여 사용자 지정 문자열 을 사용 하거나 &lt;code&gt;DEFAULT_DESCRIPTION&lt;/code&gt; 을 사용하여 요청 된 유형에 기본 제목을 사용 하지 않으면 제목이 인쇄되지 않습니다 . &lt;code&gt;INCLUDE_QUIET_PACKAGES&lt;/code&gt; 인 경우 &lt;code&gt;find_package(... QUIET)&lt;/code&gt; 로 검색된 패키지 도 표시됩니다. 기본적으로 생략됩니다. 경우 &lt;code&gt;FATAL_ON_MISSING_REQUIRED_PACKAGES&lt;/code&gt; 가 주어진다에 나열된 패키지 유형 중 하나로 표시되는 패키지 경우, CMake는 중단됩니다 &lt;a href=&quot;#variable:FeatureSummary_REQUIRED_PKG_TYPES&quot; id=&quot;index-1-variable:FeatureSummary_REQUIRED_PKG_TYPES&quot;&gt; &lt;code&gt;FeatureSummary_REQUIRED_PKG_TYPES&lt;/code&gt; &lt;/a&gt; 전역 속성이 발견되지 않았습니다. &lt;a href=&quot;#variable:FeatureSummary_REQUIRED_PKG_TYPES&quot; id=&quot;index-2-variable:FeatureSummary_REQUIRED_PKG_TYPES&quot;&gt; &lt;code&gt;FeatureSummary_REQUIRED_PKG_TYPES&lt;/code&gt; &lt;/a&gt; 글로벌 특성 의 기본값 은 &lt;code&gt;REQUIRED&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce1ad6cc8b4cfafe232f565f2f1c4345ca358a16" translate="yes" xml:space="preserve">
          <source>If a Makefile or Ninja generator is used to generate the build tree, it is not recommended to invoke &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;ninja&lt;/code&gt; directly. Instead, it is recommended that the IDE invoke &lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-3-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake(1)&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;--build&lt;/code&gt; argument, which will in turn invoke the appropriate build tool.</source>
          <target state="translated">Makefile 또는 Ninja 생성기를 사용하여 빌드 트리를 생성하는 경우 &lt;code&gt;make&lt;/code&gt; 또는 &lt;code&gt;ninja&lt;/code&gt; 를 직접 호출하지 않는 것이 좋습니다 . 대신 IDE 가 &lt;code&gt;--build&lt;/code&gt; 인수를 사용하여 &lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-3-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake(1)&lt;/code&gt; &lt;/a&gt; 를 호출하여 적절한 빌드 도구를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="30da87e82d95c1f6b4609119037e4119fc9a6375" translate="yes" xml:space="preserve">
          <source>If a Qt macro is found, then the C++ source file &lt;code&gt;&amp;lt;base&amp;gt;.&amp;lt;source_extension&amp;gt;&lt;/code&gt; is expected to as well contain an include statement</source>
          <target state="translated">Qt 매크로가 발견되면 C ++ 소스 파일 &lt;code&gt;&amp;lt;base&amp;gt;.&amp;lt;source_extension&amp;gt;&lt;/code&gt; 에 include 문이 포함될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8f29417611d74a81e0c2da5b42b2e17268bca5ed" translate="yes" xml:space="preserve">
          <source>If a Qt macro is found, then the header will be compiled by the &lt;code&gt;moc&lt;/code&gt; to the output file &lt;code&gt;moc_&amp;lt;base_name&amp;gt;.cpp&lt;/code&gt;. The complete output file path is described in the section &lt;a href=&quot;#output-file-location&quot;&gt;Output file location&lt;/a&gt;.</source>
          <target state="translated">Qt 매크로가 발견되면 &lt;code&gt;moc&lt;/code&gt; 가 헤더를 출력 파일 &lt;code&gt;moc_&amp;lt;base_name&amp;gt;.cpp&lt;/code&gt; 로 컴파일합니다 . 전체 출력 파일 경로는 &lt;a href=&quot;#output-file-location&quot;&gt;출력 파일 위치&lt;/a&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d81907809743ab71d2f0c569251fe08a3d45207" translate="yes" xml:space="preserve">
          <source>If a binary target is linked transitively to a macOS &lt;a href=&quot;../prop_tgt/framework#prop_tgt:FRAMEWORK&quot; id=&quot;index-1-prop_tgt:FRAMEWORK&quot;&gt;&lt;code&gt;FRAMEWORK&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Headers&lt;/code&gt; directory of the framework is also treated as a usage requirement. This has the same effect as passing the framework directory as an include directory.</source>
          <target state="translated">이진 대상이 macOS &lt;a href=&quot;../prop_tgt/framework#prop_tgt:FRAMEWORK&quot; id=&quot;index-1-prop_tgt:FRAMEWORK&quot;&gt; &lt;code&gt;FRAMEWORK&lt;/code&gt; 에&lt;/a&gt; 전 이적으로 연결되어 있으면 프레임 워크 의 &lt;code&gt;Headers&lt;/code&gt; 디렉토리도 사용 요구 사항으로 처리됩니다. 이는 프레임 워크 디렉토리를 포함 디렉토리로 전달하는 것과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b38c16842af76f1a34b978439304e09452f61f1f" translate="yes" xml:space="preserve">
          <source>If a download method is specified, any existing contents of the source directory may be deleted. Only the URL download method checks whether this directory is either missing or empty before initiating the download, stopping with an error if it is not empty. All other download methods silently discard any previous contents of the source directory.</source>
          <target state="translated">다운로드 방법을 지정하면 소스 디렉토리의 기존 내용이 삭제 될 수 있습니다. URL 다운로드 방법 만 다운로드를 시작하기 전에이 디렉토리가 누락되었거나 비어 있는지 확인하고 비어 있지 않은 경우 오류와 함께 중지합니다. 다른 모든 다운로드 방법은 소스 디렉토리의 이전 내용을 자동으로 버립니다.</target>
        </trans-unit>
        <trans-unit id="bf495c6174880956522c16daa2126fbdc860de6a" translate="yes" xml:space="preserve">
          <source>If a file is specified, the version is written into it. The help is printed to a named &amp;lt;f&amp;gt;ile if given.</source>
          <target state="translated">파일이 지정되면 버전이 파일에 기록됩니다. 도움말은 이름이 지정된 &amp;lt;f&amp;gt; 파일로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cde95a6fbde81056465c0717a39c7a9abf3c1717" translate="yes" xml:space="preserve">
          <source>If a library does not export any symbols, it must not be declared as a &lt;code&gt;SHARED&lt;/code&gt; library. For example, a Windows resource DLL or a managed C++/CLI DLL that exports no unmanaged symbols would need to be a &lt;code&gt;MODULE&lt;/code&gt; library. This is because CMake expects a &lt;code&gt;SHARED&lt;/code&gt; library to always have an associated import library on Windows.</source>
          <target state="translated">라이브러리가 심볼을 내 보내지 않으면 &lt;code&gt;SHARED&lt;/code&gt; 라이브러리 로 선언하면 안됩니다 . 예를 들어, 관리되지 않는 심볼을 내 보내지 않는 Windows 리소스 DLL 또는 관리되는 C ++ / CLI DLL은 &lt;code&gt;MODULE&lt;/code&gt; 라이브러리 여야합니다 . CMake는 Windows 에서 &lt;code&gt;SHARED&lt;/code&gt; 라이브러리가 항상 연관된 가져 오기 라이브러리를 갖기를 기대하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1c7c20d06b1ceb52bc20bce290d4a6ceed994c89" translate="yes" xml:space="preserve">
          <source>If a library search path must be provided, prefer to localize the effect where possible by using the &lt;a href=&quot;target_link_directories#command:target_link_directories&quot; id=&quot;index-0-command:target_link_directories&quot;&gt;&lt;code&gt;target_link_directories()&lt;/code&gt;&lt;/a&gt; command rather than &lt;code&gt;link_directories()&lt;/code&gt;. The target-specific command can also control how the search directories propagate to other dependent targets.</source>
          <target state="translated">라이브러리 검색 경로를 제공 &lt;code&gt;link_directories()&lt;/code&gt; 경우 link_directories () 대신 &lt;a href=&quot;target_link_directories#command:target_link_directories&quot; id=&quot;index-0-command:target_link_directories&quot;&gt; &lt;code&gt;target_link_directories()&lt;/code&gt; &lt;/a&gt; 명령 을 사용하여 가능한 경우 효과를 현지화하십시오 . 대상별 명령은 또한 검색 디렉토리가 다른 종속 대상으로 전파되는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d8e546933123589d9c078b3fa2f1d940bed581" translate="yes" xml:space="preserve">
          <source>If a macro from &lt;a href=&quot;../prop_tgt/automoc_macro_names#prop_tgt:AUTOMOC_MACRO_NAMES&quot; id=&quot;index-0-prop_tgt:AUTOMOC_MACRO_NAMES&quot;&gt;&lt;code&gt;AUTOMOC_MACRO_NAMES&lt;/code&gt;&lt;/a&gt; is found in a header file, &lt;code&gt;moc&lt;/code&gt; will be run on the file. The result will be put into a file named according to &lt;code&gt;moc_&amp;lt;basename&amp;gt;.cpp&lt;/code&gt;. If the macro is found in a C++ implementation file, the moc output will be put into a file named according to &lt;code&gt;&amp;lt;basename&amp;gt;.moc&lt;/code&gt;, following the Qt conventions. The &lt;code&gt;&amp;lt;basename&amp;gt;.moc&lt;/code&gt; must be included by the user in the C++ implementation file with a preprocessor &lt;code&gt;#include&lt;/code&gt;.</source>
          <target state="translated">헤더 파일에 &lt;a href=&quot;../prop_tgt/automoc_macro_names#prop_tgt:AUTOMOC_MACRO_NAMES&quot; id=&quot;index-0-prop_tgt:AUTOMOC_MACRO_NAMES&quot;&gt; &lt;code&gt;AUTOMOC_MACRO_NAMES&lt;/code&gt; &lt;/a&gt; 의 매크로가 있으면 &lt;code&gt;moc&lt;/code&gt; 가 파일에서 실행됩니다. 결과는 &lt;code&gt;moc_&amp;lt;basename&amp;gt;.cpp&lt;/code&gt; 에 따라 이름이 지정된 파일에 저장됩니다 . 매크로가 C ++ 구현 파일에서 발견되면 mot 출력은 Qt 규칙 에 따라 &lt;code&gt;&amp;lt;basename&amp;gt;.moc&lt;/code&gt; 에 따라 이름이 지정된 파일에 저장됩니다 . 이 &lt;code&gt;&amp;lt;basename&amp;gt;.moc&lt;/code&gt; 전 처리기와 C ++ 실행 파일에 사용자가 포함되어야 &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5118a0725ca4c145abc986d741e5223705b89c8" translate="yes" xml:space="preserve">
          <source>If a module is found, the &lt;code&gt;&amp;lt;prefix&amp;gt;_MODULE_NAME&lt;/code&gt; variable will contain the name of the matching module. This variable can be used if you need to run &lt;a href=&quot;#command:pkg_get_variable&quot; id=&quot;index-1-command:pkg_get_variable&quot;&gt;&lt;code&gt;pkg_get_variable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈이 발견되면 &lt;code&gt;&amp;lt;prefix&amp;gt;_MODULE_NAME&lt;/code&gt; 변수에 일치하는 모듈의 이름이 포함됩니다. 이 변수는 &lt;a href=&quot;#command:pkg_get_variable&quot; id=&quot;index-1-command:pkg_get_variable&quot;&gt; &lt;code&gt;pkg_get_variable()&lt;/code&gt; &lt;/a&gt; 을 실행해야하는 경우 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e61d89320b40aba27bcf79fccf87c4aed97f1b2b" translate="yes" xml:space="preserve">
          <source>If a module is specified instead of a file, the file with name &lt;code&gt;&amp;lt;modulename&amp;gt;.cmake&lt;/code&gt; is searched first in &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-0-variable:CMAKE_MODULE_PATH&quot;&gt;&lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt;&lt;/a&gt;, then in the CMake module directory. There is one exception to this: if the file which calls &lt;code&gt;include()&lt;/code&gt; is located itself in the CMake builtin module directory, then first the CMake builtin module directory is searched and &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-1-variable:CMAKE_MODULE_PATH&quot;&gt;&lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt;&lt;/a&gt; afterwards. See also policy &lt;a href=&quot;../policy/cmp0017#policy:CMP0017&quot; id=&quot;index-0-policy:CMP0017&quot;&gt;&lt;code&gt;CMP0017&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈이 대신 파일의 지정되는 경우, 이름의 파일 &lt;code&gt;&amp;lt;modulename&amp;gt;.cmake&lt;/code&gt; IS는 처음에 검색 &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-0-variable:CMAKE_MODULE_PATH&quot;&gt; &lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt; &lt;/a&gt; 다음 CMake 모듈 디렉토리에. &lt;code&gt;include()&lt;/code&gt; 를 호출하는 파일이 CMake 내장 모듈 디렉토리에있는 경우 먼저 CMake 내장 모듈 디렉토리를 검색 한 후 &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-1-variable:CMAKE_MODULE_PATH&quot;&gt; &lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt; 를 제외하십시오&lt;/a&gt; . 정책 &lt;a href=&quot;../policy/cmp0017#policy:CMP0017&quot; id=&quot;index-0-policy:CMP0017&quot;&gt; &lt;code&gt;CMP0017&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ffc6354b2e588493e140bc7b0710dcba5e576b" translate="yes" xml:space="preserve">
          <source>If a module library target has this property set to true it will be built as a &lt;code&gt;CFBundle&lt;/code&gt; when built on the mac. It will have the directory structure required for a &lt;code&gt;CFBundle&lt;/code&gt; and will be suitable to be used for creating Browser Plugins or other application resources.</source>
          <target state="translated">모듈 라이브러리 대상에이 속성이 true로 설정되어 있으면 Mac에서 빌드 될 때 &lt;code&gt;CFBundle&lt;/code&gt; 로 빌드됩니다 . &lt;code&gt;CFBundle&lt;/code&gt; 에 필요한 디렉토리 구조를 가지며 브라우저 플러그인 또는 기타 애플리케이션 자원을 작성하는 데 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="56a4ad6e890033baf429a7642de0b3d8f0409c6b" translate="yes" xml:space="preserve">
          <source>If a module library target has this property set to true it will be built as a CFBundle when built on the Mac. It will have the directory structure required for a CFBundle.</source>
          <target state="translated">모듈 라이브러리 대상에이 속성이 true로 설정되어 있으면 Mac에서 빌드 될 때 CFBundle로 빌드됩니다. CFBundle에 필요한 디렉토리 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6bcc9eb162a4ea86518a1d45e609ab1ab92e7156" translate="yes" xml:space="preserve">
          <source>If a non-full path value is supplied then CMake will resolve the full path of the compiler.</source>
          <target state="translated">전체 경로가 아닌 값이 제공되면 CMake는 컴파일러의 전체 경로를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="09802ddc5835d1f8601e782f10eb13e94cff49c0" translate="yes" xml:space="preserve">
          <source>If a preprocessor &lt;code&gt;#include&lt;/code&gt; directive is found which matches &lt;code&gt;&amp;lt;path&amp;gt;ui_&amp;lt;basename&amp;gt;.h&lt;/code&gt;, and a &lt;code&gt;&amp;lt;basename&amp;gt;.ui&lt;/code&gt; file exists, then &lt;code&gt;uic&lt;/code&gt; will be executed to generate the appropriate file. The &lt;code&gt;&amp;lt;basename&amp;gt;.ui&lt;/code&gt; file is searched for in the following places</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;ui_&amp;lt;basename&amp;gt;.h&lt;/code&gt; 와 일치 하는 전 처리기 &lt;code&gt;#include&lt;/code&gt; 지시문이 있고 &lt;code&gt;&amp;lt;basename&amp;gt;.ui&lt;/code&gt; 파일이 있으면 적절한 파일을 생성하기 위해 &lt;code&gt;uic&lt;/code&gt; 이 실행됩니다. &lt;code&gt;&amp;lt;basename&amp;gt;.ui&lt;/code&gt; 파일은 다음 장소에서 검색됩니다</target>
        </trans-unit>
        <trans-unit id="d6da461134eb622c066a37f8f41e6aa35023f548" translate="yes" xml:space="preserve">
          <source>If a project arranges for package registry entries to exist, such as:</source>
          <target state="translated">프로젝트가 다음과 같은 패키지 레지스트리 항목이 존재하도록 정렬하는 경우 :</target>
        </trans-unit>
        <trans-unit id="69112ed1ca4287eda16218232add0593f5fa3361" translate="yes" xml:space="preserve">
          <source>If a project has presets available, either through &lt;code&gt;CMakePresets.json&lt;/code&gt; or &lt;code&gt;CMakeUserPresets.json&lt;/code&gt;, the list of presets will appear in a drop-down menu in &lt;a href=&quot;../../manual/cmake-gui.1#manual:cmake-gui(1)&quot; id=&quot;index-9-manual:cmake-gui(1)&quot;&gt;&lt;code&gt;cmake-gui(1)&lt;/code&gt;&lt;/a&gt; between the source directory and the binary directory. Choosing a preset sets the binary directory, generator, environment variables, and cache variables, but all of these options can be overridden after a preset is selected.</source>
          <target state="translated">프로젝트에 &lt;code&gt;CMakePresets.json&lt;/code&gt; 또는 &lt;code&gt;CMakeUserPresets.json&lt;/code&gt; 을 통해 사용 가능한 사전 설정이있는 경우 사전 설정 목록은 소스 디렉터리와 바이너리 디렉터리 사이의 &lt;a href=&quot;../../manual/cmake-gui.1#manual:cmake-gui(1)&quot; id=&quot;index-9-manual:cmake-gui(1)&quot;&gt; &lt;code&gt;cmake-gui(1)&lt;/code&gt; &lt;/a&gt; 드롭 다운 메뉴에 표시됩니다 . 사전 설정을 선택하면 이진 디렉터리, 생성기, 환경 변수 및 캐시 변수가 설정되지만 이러한 모든 옵션은 사전 설정을 선택한 후에 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65be43e974227fe9b147c8a92b603c8470a2b7e0" translate="yes" xml:space="preserve">
          <source>If a relative path is given it is interpreted relative to the value of the &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt; variable. The prefix can be relocated at install time using the &lt;code&gt;DESTDIR&lt;/code&gt; mechanism explained in the &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-1-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt; variable documentation.</source>
          <target state="translated">상대 경로가 제공되면 &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; 변수 의 값에 상대적으로 해석 됩니다. &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-1-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; 변수 문서에 설명 된 &lt;code&gt;DESTDIR&lt;/code&gt; 메커니즘을 사용하여 설치시 접두어를 재배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e47823b6d62c96e9277c973d24a085c76125200d" translate="yes" xml:space="preserve">
          <source>If a required dependency is not found by &lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake(1)&lt;/code&gt;&lt;/a&gt;, the cache is populated with an entry which contains a &lt;code&gt;NOTFOUND&lt;/code&gt; value. This value can be replaced by specifying it on the command line, or in the &lt;a href=&quot;../../manual/ccmake.1#manual:ccmake(1)&quot; id=&quot;index-0-manual:ccmake(1)&quot;&gt;&lt;code&gt;ccmake(1)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../manual/cmake-gui.1#manual:cmake-gui(1)&quot; id=&quot;index-0-manual:cmake-gui(1)&quot;&gt;&lt;code&gt;cmake-gui(1)&lt;/code&gt;&lt;/a&gt; tool. See the &lt;a href=&quot;../user-interaction/index#guide:User%20Interaction%20Guide&quot; id=&quot;index-0-guide:User Interaction Guide&quot;&gt;&lt;code&gt;User Interaction Guide&lt;/code&gt;&lt;/a&gt; for more about setting cache entries.</source>
          <target state="translated">&lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake(1)&lt;/code&gt; &lt;/a&gt; 에서 필수 종속성을 찾지 못하면 캐시는 &lt;code&gt;NOTFOUND&lt;/code&gt; 값 을 포함하는 항목으로 채워집니다 . 이 값은 명령 줄이나 &lt;a href=&quot;../../manual/ccmake.1#manual:ccmake(1)&quot; id=&quot;index-0-manual:ccmake(1)&quot;&gt; &lt;code&gt;ccmake(1)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../manual/cmake-gui.1#manual:cmake-gui(1)&quot; id=&quot;index-0-manual:cmake-gui(1)&quot;&gt; &lt;code&gt;cmake-gui(1)&lt;/code&gt; &lt;/a&gt; 도구 에서 지정하여 바꿀 수 있습니다 . 캐시 항목 설정에 대한 자세한 내용은 &lt;a href=&quot;../user-interaction/index#guide:User%20Interaction%20Guide&quot; id=&quot;index-0-guide:User Interaction Guide&quot;&gt; &lt;code&gt;User Interaction Guide&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c8196579aa746a6923b61258b6c04c94e465626" translate="yes" xml:space="preserve">
          <source>If a selected architecture is available for both: device SDK and simulator SDK it will be built for the SDK selected by &lt;a href=&quot;../variable/cmake_osx_sysroot#variable:CMAKE_OSX_SYSROOT&quot; id=&quot;index-0-variable:CMAKE_OSX_SYSROOT&quot;&gt;&lt;code&gt;CMAKE_OSX_SYSROOT&lt;/code&gt;&lt;/a&gt; and removed from the corresponding SDK.</source>
          <target state="translated">선택한 아키텍처가 장치 SDK 및 시뮬레이터 SDK 모두에 사용 가능한 경우 &lt;a href=&quot;../variable/cmake_osx_sysroot#variable:CMAKE_OSX_SYSROOT&quot; id=&quot;index-0-variable:CMAKE_OSX_SYSROOT&quot;&gt; &lt;code&gt;CMAKE_OSX_SYSROOT&lt;/code&gt; 에서&lt;/a&gt; 선택한 SDK에 대해 빌드 되고 해당 SDK에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce4f4bc21be48080994173da37cb6c23cdc10a3" translate="yes" xml:space="preserve">
          <source>If a sequential execution of multiple commands is required, use multiple &lt;a href=&quot;#command:execute_process&quot; id=&quot;index-0-command:execute_process&quot;&gt;&lt;code&gt;execute_process()&lt;/code&gt;&lt;/a&gt; calls with a single &lt;code&gt;COMMAND&lt;/code&gt; argument.</source>
          <target state="translated">여러 명령을 순차적으로 실행해야하는 경우 단일 &lt;code&gt;COMMAND&lt;/code&gt; 인수 와 함께 여러 &lt;a href=&quot;#command:execute_process&quot; id=&quot;index-0-command:execute_process&quot;&gt; &lt;code&gt;execute_process()&lt;/code&gt; &lt;/a&gt; 호출을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="547e42797e310852adfe811b5914e22366c828a1" translate="yes" xml:space="preserve">
          <source>If a single target needs to produce more than one jar from its java source code, to prevent the accumulation of duplicate class files in subsequent jars, set/reset &lt;code&gt;CMAKE_JAR_CLASSES_PREFIX&lt;/code&gt; prior to calling the &lt;code&gt;add_jar()&lt;/code&gt; function:</source>
          <target state="translated">단일 대상이 Java 소스 코드에서 하나 이상의 jar을 생성해야하는 경우 후속 jar에 중복 클래스 파일이 누적되지 않도록 하려면 &lt;code&gt;add_jar()&lt;/code&gt; 함수 를 호출하기 전에 &lt;code&gt;CMAKE_JAR_CLASSES_PREFIX&lt;/code&gt; 를 설정 / 재설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c641393cb0eece48d4dd44486eeb44abf009bad3" translate="yes" xml:space="preserve">
          <source>If a source file matches multiple groups, the &lt;em&gt;last&lt;/em&gt; group that explicitly lists the file with &lt;code&gt;FILES&lt;/code&gt; will be favored, if any. If no group explicitly lists the file, the &lt;em&gt;last&lt;/em&gt; group whose regular expression matches the file will be favored.</source>
          <target state="translated">소스 파일이 여러 그룹과 일치하면 &lt;code&gt;FILES&lt;/code&gt; 와 함께 파일 을 명시 적으로 나열하는 &lt;em&gt;마지막&lt;/em&gt; 그룹이 선호됩니다. 그룹이 파일을 명시 적으로 나열하지 않으면 정규식이 파일과 일치하는 &lt;em&gt;마지막&lt;/em&gt; 그룹이 선호됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="536c556452212ea95ed6c58cfeaa6b27e5dedb31" translate="yes" xml:space="preserve">
          <source>If a static or object library has dependency optimization enabled, it first discards all dependencies. Then, it looks through all of the direct and indirect dependencies that it initially had, and adds them back if they meet any of the following criteria:</source>
          <target state="translated">정적 또는 개체 라이브러리에 종속성 최적화가 활성화 된 경우 먼저 모든 종속성을 삭제합니다. 그런 다음 처음에 가졌던 모든 직접 및 간접 종속성을 살펴보고 다음 기준 중 하나라도 충족하면 다시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1ff64afb256005e648317888f49a9ea8bedf5a29" translate="yes" xml:space="preserve">
          <source>If a step target is created for an independent step by the &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-3-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;STEP_TARGETS&lt;/code&gt; option or by the &lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-3-command:externalproject_add_steptargets&quot;&gt;&lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt;&lt;/a&gt; function, it will not depend on the external targets, but may depend on targets for other steps.</source>
          <target state="translated">&lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-3-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;STEP_TARGETS&lt;/code&gt; 옵션 또는 &lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-3-command:externalproject_add_steptargets&quot;&gt; &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; &lt;/a&gt; 함수에 의해 독립 단계에 대한 단계 대상이 생성 된 경우 외부 대상에 종속되지 않지만 다른 단계의 대상에 종속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54c2368249cdcf215901649de3840031aae28a1e" translate="yes" xml:space="preserve">
          <source>If a supported thread library was found.</source>
          <target state="translated">지원되는 스레드 라이브러리가 발견 된 경우.</target>
        </trans-unit>
        <trans-unit id="94c4041072aa12a8170210a7c2481c4a26139cbb" translate="yes" xml:space="preserve">
          <source>If a target has &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; set to true, it may still be listed in an &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt;&lt;code&gt;install(TARGETS)&lt;/code&gt;&lt;/a&gt; command, but the user is responsible for ensuring that the target&amp;rsquo;s build artifacts are not missing or outdated when an install is performed.</source>
          <target state="translated">대상에 &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; 이 true로 설정된 경우 여전히 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt; &lt;code&gt;install(TARGETS)&lt;/code&gt; &lt;/a&gt; 명령에 나열 될 수 있지만 사용자는 설치가 수행 될 때 대상의 빌드 아티팩트가 누락되거나 오래되지 않았는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="268cbe75fdcd8fdd0afae3aae3c9376547806fc0" translate="yes" xml:space="preserve">
          <source>If a test in the set of tests to be executed requires a particular fixture, that fixture&amp;rsquo;s setup and cleanup tests would normally be added to the test set automatically. This option prevents adding setup or cleanup tests for fixtures matching the &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;. Note that all other fixture behavior is retained, including test dependencies and skipping tests that have fixture setup tests that fail.</source>
          <target state="translated">실행할 테스트 세트의 테스트에 특정 픽스처가 필요한 경우 해당 픽스처의 설정 및 정리 테스트는 일반적으로 테스트 세트에 자동으로 추가됩니다. 이 옵션은 &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; 와 일치하는 조명기의 셋업 또는 클린업 테스트를 추가하지 못하게 합니다. 테스트 종속성 및 실패한 픽스처 설정 테스트가있는 테스트 건너 뛰기를 포함하여 다른 모든 픽스처 동작은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef878935fc088712608718479f10bca7a3fe5b5" translate="yes" xml:space="preserve">
          <source>If a test with the &lt;a href=&quot;fixtures_setup#prop_test:FIXTURES_SETUP&quot; id=&quot;index-0-prop_test:FIXTURES_SETUP&quot;&gt;&lt;code&gt;FIXTURES_SETUP&lt;/code&gt;&lt;/a&gt; property set is &lt;code&gt;DISABLED&lt;/code&gt;, the fixture behavior will be as though that setup test was passing and any test case requiring that fixture will still run.</source>
          <target state="translated">&lt;a href=&quot;fixtures_setup#prop_test:FIXTURES_SETUP&quot; id=&quot;index-0-prop_test:FIXTURES_SETUP&quot;&gt; &lt;code&gt;FIXTURES_SETUP&lt;/code&gt; &lt;/a&gt; 속성이 설정된 테스트 가 &lt;code&gt;DISABLED&lt;/code&gt; 이면 픽스처 동작은 해당 설정 테스트가 통과 한 것처럼 보이며 해당 픽스처가 필요한 모든 테스트 케이스는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e25c4d39c99f143a71529fe04e60d393c28c3dc5" translate="yes" xml:space="preserve">
          <source>If a user passes &lt;code&gt;-DMY_CUSTOM_VARIABLE=SomeValue&lt;/code&gt; to CMake then this setting will be made visible to the toolchain file both for the main project and for test projects generated by the &lt;a href=&quot;../command/try_compile#command:try_compile&quot; id=&quot;index-1-command:try_compile&quot;&gt;&lt;code&gt;try_compile()&lt;/code&gt;&lt;/a&gt; command source file signature.</source>
          <target state="translated">사용자가 &lt;code&gt;-DMY_CUSTOM_VARIABLE=SomeValue&lt;/code&gt; 를 CMake로 전달하면이 설정은 기본 프로젝트와 &lt;a href=&quot;../command/try_compile#command:try_compile&quot; id=&quot;index-1-command:try_compile&quot;&gt; &lt;code&gt;try_compile()&lt;/code&gt; &lt;/a&gt; 명령 소스 파일 서명으로 생성 된 테스트 프로젝트 모두에 대한 툴체인 파일에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a842b761fc2cc46d1bf8004e60de2d41c1f8aef7" translate="yes" xml:space="preserve">
          <source>If all of these parameters were not sufficient to find the right MPI implementation, a user may disable the entire autodetection process by specifying both a list of libraries in &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_LIBRARIES&lt;/code&gt; and a list of include directories in &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_ADDITIONAL_INCLUDE_DIRS&lt;/code&gt;. Any other variable may be set in addition to these two. The module will then validate the MPI settings and store the settings in the cache.</source>
          <target state="translated">이러한 매개 변수의 모든 권리 MPI 구현을 발견하기에 충분하지 있다면, 사용자는 도서관의 목록을 모두 지정하여 전체 자동 감지 프로세스를 비활성화 할 수 있습니다 &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_LIBRARIES&lt;/code&gt; 의 디렉토리 등의과 목록을 &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_ADDITIONAL_INCLUDE_DIRS&lt;/code&gt; . 이 두 가지 외에 다른 변수도 설정할 수 있습니다. 그런 다음 모듈은 MPI 설정을 확인하고 설정을 캐시에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9f1067c13a7dcb4c490cdf987b03d674713e663a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command is used without the &lt;code&gt;COMPONENT&lt;/code&gt; argument, these files will be grouped into a default component. The name of this default install component will be taken from this variable. It defaults to &lt;code&gt;Unspecified&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 명령이없이 사용 &lt;code&gt;COMPONENT&lt;/code&gt; 인수,이 파일은 기본 구성 요소로 분류됩니다. 이 기본 설치 구성 요소의 이름은이 변수에서 가져옵니다. 기본값은 &lt;code&gt;Unspecified&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3770be889285772cbcbfe827735f8497e101f896" translate="yes" xml:space="preserve">
          <source>If an IDE project generator is used, such as &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt;&lt;code&gt;Xcode&lt;/code&gt;&lt;/a&gt; or one of the Visual Studio generators, and the IDE understands the project format used, the IDE should read the project file and build it the same way it would otherwise.</source>
          <target state="translated">&lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt; &lt;code&gt;Xcode&lt;/code&gt; &lt;/a&gt; 또는 Visual Studio 생성기 중 하나 와 같은 IDE 프로젝트 생성기가 사용되고 IDE가 사용 된 프로젝트 형식을 이해하는 경우 IDE는 프로젝트 파일을 읽고 다른 방법과 동일한 방식으로 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="87a6f86c5573059989c9d5d97e79a6d4a1c57901" translate="yes" xml:space="preserve">
          <source>If an absolute path (with a leading slash or drive letter) is given it is used verbatim.</source>
          <target state="translated">절대 경로 (선행 슬래시 또는 드라이브 문자 포함)가 제공되면 그대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4127e7e02b19c3ee7c444efc55bb5a66de7c64" translate="yes" xml:space="preserve">
          <source>If an additional clean file is specific to a single target only, then the &lt;a href=&quot;../prop_tgt/additional_clean_files#prop_tgt:ADDITIONAL_CLEAN_FILES&quot; id=&quot;index-0-prop_tgt:ADDITIONAL_CLEAN_FILES&quot;&gt;&lt;code&gt;ADDITIONAL_CLEAN_FILES&lt;/code&gt;&lt;/a&gt; target property would usually be a better choice than this directory property.</source>
          <target state="translated">추가 정리 파일이 단일 대상에만 고유 한 경우 일반적으로 &lt;a href=&quot;../prop_tgt/additional_clean_files#prop_tgt:ADDITIONAL_CLEAN_FILES&quot; id=&quot;index-0-prop_tgt:ADDITIONAL_CLEAN_FILES&quot;&gt; &lt;code&gt;ADDITIONAL_CLEAN_FILES&lt;/code&gt; &lt;/a&gt; 대상 특성이이 디렉토리 특성보다 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="686deca2ff89a7d4cf50a69d2978f830f599e5d6" translate="yes" xml:space="preserve">
          <source>If an imported library has the &lt;a href=&quot;../prop_tgt/imported_no_soname#prop_tgt:IMPORTED_NO_SONAME&quot; id=&quot;index-0-prop_tgt:IMPORTED_NO_SONAME&quot;&gt;&lt;code&gt;IMPORTED_NO_SONAME&lt;/code&gt;&lt;/a&gt; target property set, CMake may ask the linker to search for the library instead of using the full path (e.g. &lt;code&gt;/usr/lib/libfoo.so&lt;/code&gt; becomes &lt;code&gt;-lfoo&lt;/code&gt;).</source>
          <target state="translated">가져온 라이브러리에 &lt;a href=&quot;../prop_tgt/imported_no_soname#prop_tgt:IMPORTED_NO_SONAME&quot; id=&quot;index-0-prop_tgt:IMPORTED_NO_SONAME&quot;&gt; &lt;code&gt;IMPORTED_NO_SONAME&lt;/code&gt; &lt;/a&gt; 대상 속성이 설정 되어 있으면 CMake는 전체 경로를 사용하는 대신 링커에서 라이브러리를 검색하도록 요청할 수 있습니다 (예 : &lt;code&gt;/usr/lib/libfoo.so&lt;/code&gt; 는 &lt;code&gt;-lfoo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="63071814530f0cecd16e2a7b5266265a6759857e" translate="yes" xml:space="preserve">
          <source>If an interface library has source files (i.e. the &lt;a href=&quot;../prop_tgt/sources#prop_tgt:SOURCES&quot; id=&quot;index-0-prop_tgt:SOURCES&quot;&gt;&lt;code&gt;SOURCES&lt;/code&gt;&lt;/a&gt; target property is set), it will appear in the generated buildsystem as a build target much like a target defined by the &lt;a href=&quot;add_custom_target#command:add_custom_target&quot; id=&quot;index-0-command:add_custom_target&quot;&gt;&lt;code&gt;add_custom_target()&lt;/code&gt;&lt;/a&gt; command. It does not compile any sources, but does contain build rules for custom commands created by the &lt;a href=&quot;add_custom_command#command:add_custom_command&quot; id=&quot;index-0-command:add_custom_command&quot;&gt;&lt;code&gt;add_custom_command()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">인터페이스 라이브러리에 소스 파일이있는 경우 (예 : &lt;a href=&quot;../prop_tgt/sources#prop_tgt:SOURCES&quot; id=&quot;index-0-prop_tgt:SOURCES&quot;&gt; &lt;code&gt;SOURCES&lt;/code&gt; &lt;/a&gt; 대상 속성이 설정 됨) 생성 된 빌드 시스템에 &lt;a href=&quot;add_custom_target#command:add_custom_target&quot; id=&quot;index-0-command:add_custom_target&quot;&gt; &lt;code&gt;add_custom_target()&lt;/code&gt; &lt;/a&gt; 명령으로 정의 된 대상과 매우 유사한 빌드 대상으로 나타납니다 . 소스를 컴파일하지는 않지만 &lt;a href=&quot;add_custom_command#command:add_custom_command&quot; id=&quot;index-0-command:add_custom_command&quot;&gt; &lt;code&gt;add_custom_command()&lt;/code&gt; &lt;/a&gt; 명령으로 만든 사용자 지정 명령에 대한 빌드 규칙을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="f340b5d202dc558a099da87acbeddfd7ee2cf4f1" translate="yes" xml:space="preserve">
          <source>If another project wishes to use &lt;code&gt;Foo&lt;/code&gt; it need only to locate the &lt;code&gt;FooConfig.cmake&lt;/code&gt; file and load it to get all the information it needs about package content locations. Since the package configuration file is provided by the package installation it already knows all the file locations.</source>
          <target state="translated">다른 프로젝트에서 &lt;code&gt;Foo&lt;/code&gt; 를 사용 하려면 &lt;code&gt;FooConfig.cmake&lt;/code&gt; 파일 을 찾아 로드하면 패키지 컨텐츠 위치에 필요한 모든 정보를 얻을 수 있습니다. 패키지 구성 파일은 패키지 설치에 의해 제공되므로 모든 파일 위치를 이미 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb3450146ea57e19ac69da16371933be619c4c5" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;RPATH&lt;/code&gt;/&lt;code&gt;RUNPATH&lt;/code&gt; entries passed to the linker contain the &lt;a href=&quot;#variable:CMAKE_STAGING_PREFIX&quot; id=&quot;index-1-variable:CMAKE_STAGING_PREFIX&quot;&gt;&lt;code&gt;CMAKE_STAGING_PREFIX&lt;/code&gt;&lt;/a&gt;, the matching path fragments are replaced with the &lt;a href=&quot;cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 경우 &lt;code&gt;RPATH&lt;/code&gt; / &lt;code&gt;RUNPATH&lt;/code&gt; 의 링커에 전달 항목이 포함 &lt;a href=&quot;#variable:CMAKE_STAGING_PREFIX&quot; id=&quot;index-1-variable:CMAKE_STAGING_PREFIX&quot;&gt; &lt;code&gt;CMAKE_STAGING_PREFIX&lt;/code&gt; 를&lt;/a&gt; , 매칭 경로 단편이 대체된다 &lt;a href=&quot;cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="551ced0b3d41b44343e965393c2779d700e688c8" translate="yes" xml:space="preserve">
          <source>If any dependency is an &lt;code&gt;OUTPUT&lt;/code&gt; of another custom command in the same directory (&lt;code&gt;CMakeLists.txt&lt;/code&gt; file), CMake automatically brings the other custom command into the target in which this command is built. A target-level dependency is added if any dependency is listed as &lt;code&gt;BYPRODUCTS&lt;/code&gt; of a target or any of its build events in the same directory to ensure the byproducts will be available.</source>
          <target state="translated">종속성이 동일한 디렉터리 ( &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일) 에있는 다른 사용자 지정 명령 의 &lt;code&gt;OUTPUT&lt;/code&gt; 인 경우 CMake는 다른 사용자 지정 명령을이 명령이 빌드 된 대상으로 자동으로 가져옵니다. 종속 항목이 대상의 &lt;code&gt;BYPRODUCTS&lt;/code&gt; 또는 동일한 디렉토리에있는 빌드 이벤트로 나열되는 경우 대상 레벨 종속성이 추가되어 부산물을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc32bb81e8e11188b3e232ec2557ca4bbeaa0b4f" translate="yes" xml:space="preserve">
          <source>If any macros should be provided by the &lt;code&gt;MathFunctions&lt;/code&gt; package, they should be in a separate file which is installed to the same location as the &lt;code&gt;MathFunctionsConfig.cmake&lt;/code&gt; file, and included from there.</source>
          <target state="translated">&lt;code&gt;MathFunctions&lt;/code&gt; 패키지에서 매크로를 제공해야하는 경우 &lt;code&gt;MathFunctionsConfig.cmake&lt;/code&gt; 파일과 동일한 위치에 설치되고 여기에 포함 된 별도의 파일에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa302667eeacecadece2926953fee3342f3d2a5" translate="yes" xml:space="preserve">
          <source>If any of a fixture&amp;rsquo;s setup tests fail, none of the tests listing that fixture in its &lt;a href=&quot;fixtures_required#prop_test:FIXTURES_REQUIRED&quot; id=&quot;index-1-prop_test:FIXTURES_REQUIRED&quot;&gt;&lt;code&gt;FIXTURES_REQUIRED&lt;/code&gt;&lt;/a&gt; property will be run. Cleanup tests will, however, still be executed.</source>
          <target state="translated">조명기의 설정 테스트 중 하나라도 실패하면 &lt;a href=&quot;fixtures_required#prop_test:FIXTURES_REQUIRED&quot; id=&quot;index-1-prop_test:FIXTURES_REQUIRED&quot;&gt; &lt;code&gt;FIXTURES_REQUIRED&lt;/code&gt; &lt;/a&gt; 속성 에 해당 조명기를 나열하는 테스트 는 실행되지 않습니다. 그러나 정리 테스트는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="31be31c1956c6ce625bb108b4d063dc37c13fc5c" translate="yes" xml:space="preserve">
          <source>If any of the above &lt;code&gt;..._DIR&lt;/code&gt; options are not specified, their defaults are computed as follows. If the &lt;code&gt;PREFIX&lt;/code&gt; option is given or the &lt;code&gt;EP_PREFIX&lt;/code&gt; directory property is set, then an external project is built and installed under the specified prefix:</source>
          <target state="translated">위의 &lt;code&gt;..._DIR&lt;/code&gt; 옵션 중 하나를 지정하지 않으면 기본값이 다음과 같이 계산됩니다. 는 IF &lt;code&gt;PREFIX&lt;/code&gt; 의 옵션이 주어 또는 &lt;code&gt;EP_PREFIX&lt;/code&gt; 의 디렉토리 속성을 설정 한 후 외부 프로젝트를 구축하고 지정된 접두사 아래에 설치됩니다</target>
        </trans-unit>
        <trans-unit id="ce0ab55359c26cf33d083e8b56a394029f52de2f" translate="yes" xml:space="preserve">
          <source>If any of the extracted files changes, then the &lt;code&gt;moc&lt;/code&gt; file for the source file gets rebuilt even when the source file itself doesn&amp;rsquo;t change.</source>
          <target state="translated">추출 된 파일이 변경 되면 소스 파일 자체가 변경되지 않은 경우에도 소스 파일 의 &lt;code&gt;moc&lt;/code&gt; 파일이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="21f56c9f2c1213410ff0686ab1ca0a54a2adec77" translate="yes" xml:space="preserve">
          <source>If any of the extracted files is &lt;a href=&quot;../prop_sf/generated#prop_sf:GENERATED&quot; id=&quot;index-0-prop_sf:GENERATED&quot;&gt;&lt;code&gt;GENERATED&lt;/code&gt;&lt;/a&gt; or if it is not in the target&amp;rsquo;s sources, then it might be necessary to add it to the &lt;code&gt;_autogen&lt;/code&gt; target dependencies. See &lt;a href=&quot;autogen_target_depends#prop_tgt:AUTOGEN_TARGET_DEPENDS&quot; id=&quot;index-0-prop_tgt:AUTOGEN_TARGET_DEPENDS&quot;&gt;&lt;code&gt;AUTOGEN_TARGET_DEPENDS&lt;/code&gt;&lt;/a&gt; for reference.</source>
          <target state="translated">추출 된 파일이 &lt;a href=&quot;../prop_sf/generated#prop_sf:GENERATED&quot; id=&quot;index-0-prop_sf:GENERATED&quot;&gt; &lt;code&gt;GENERATED&lt;/code&gt; &lt;/a&gt; 이거나 대상의 소스에없는 경우 &lt;code&gt;_autogen&lt;/code&gt; 대상 종속성에 파일 을 추가해야합니다 . 참조를 위해 &lt;a href=&quot;autogen_target_depends#prop_tgt:AUTOGEN_TARGET_DEPENDS&quot; id=&quot;index-0-prop_tgt:AUTOGEN_TARGET_DEPENDS&quot;&gt; &lt;code&gt;AUTOGEN_TARGET_DEPENDS&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48ace6fa6d0fc10df03ce17a8578176351f5c361" translate="yes" xml:space="preserve">
          <source>If called from within a find module loaded by &lt;a href=&quot;find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt;&lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt;&lt;/a&gt;, search prefixes unique to the current package being found. Specifically look in the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake variable and the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; environment variable. The package root variables are maintained as a stack so if called from nested find modules, root paths from the parent&amp;rsquo;s find module will be searched after paths from the current module, i.e. &lt;code&gt;&amp;lt;CurrentPackage&amp;gt;_ROOT&lt;/code&gt;, &lt;code&gt;ENV{&amp;lt;CurrentPackage&amp;gt;_ROOT}&lt;/code&gt;, &lt;code&gt;&amp;lt;ParentPackage&amp;gt;_ROOT&lt;/code&gt;, &lt;code&gt;ENV{&amp;lt;ParentPackage&amp;gt;_ROOT}&lt;/code&gt;, etc. This can be skipped if &lt;code&gt;NO_PACKAGE_ROOT_PATH&lt;/code&gt; is passed. See policy &lt;a href=&quot;../policy/cmp0074#policy:CMP0074&quot; id=&quot;index-0-policy:CMP0074&quot;&gt;&lt;code&gt;CMP0074&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt; &lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt; &lt;/a&gt; 의해로드 된 찾기 모듈 내에서 호출 된 경우 , 검색중인 현재 패키지에 고유 한 검색 접두어입니다. 특히 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake 변수 및 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 환경 변수를 확인하십시오. 패키지 루트 변수는 스택으로 유지되므로 중첩 된 찾기 모듈에서 호출 된 경우 현재 모듈의 경로 (예 : &lt;code&gt;&amp;lt;CurrentPackage&amp;gt;_ROOT&lt;/code&gt; , &lt;code&gt;ENV{&amp;lt;CurrentPackage&amp;gt;_ROOT}&lt;/code&gt; , &lt;code&gt;&amp;lt;ParentPackage&amp;gt;_ROOT&lt;/code&gt; 에서 상위 찾기 모듈의 루트 경로가 검색됩니다. &amp;gt; _ROOT , &lt;code&gt;ENV{&amp;lt;ParentPackage&amp;gt;_ROOT}&lt;/code&gt; 등 . &lt;code&gt;NO_PACKAGE_ROOT_PATH&lt;/code&gt; 가 전달 되면 건너 뛸 수 있습니다 .정책 &lt;a href=&quot;../policy/cmp0074#policy:CMP0074&quot; id=&quot;index-0-policy:CMP0074&quot;&gt; &lt;code&gt;CMP0074&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ace4bf92f50f5027cdb18f88aa1000fcd48f9168" translate="yes" xml:space="preserve">
          <source>If called from within a find module or any other script loaded by a call to &lt;a href=&quot;find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt;&lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt;&lt;/a&gt;, search prefixes unique to the current package being found. Specifically, look in the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake variable and the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; environment variable. The package root variables are maintained as a stack, so if called from nested find modules or config packages, root paths from the parent&amp;rsquo;s find module or config package will be searched after paths from the current module or package. In other words, the search order would be &lt;code&gt;&amp;lt;CurrentPackage&amp;gt;_ROOT&lt;/code&gt;, &lt;code&gt;ENV{&amp;lt;CurrentPackage&amp;gt;_ROOT}&lt;/code&gt;, &lt;code&gt;&amp;lt;ParentPackage&amp;gt;_ROOT&lt;/code&gt;, &lt;code&gt;ENV{&amp;lt;ParentPackage&amp;gt;_ROOT}&lt;/code&gt;, etc. This can be skipped if &lt;code&gt;NO_PACKAGE_ROOT_PATH&lt;/code&gt; is passed or by setting the &lt;a href=&quot;../variable/cmake_find_use_package_root_path#variable:CMAKE_FIND_USE_PACKAGE_ROOT_PATH&quot; id=&quot;index-0-variable:CMAKE_FIND_USE_PACKAGE_ROOT_PATH&quot;&gt;&lt;code&gt;CMAKE_FIND_USE_PACKAGE_ROOT_PATH&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;FALSE&lt;/code&gt;. See policy &lt;a href=&quot;../policy/cmp0074#policy:CMP0074&quot; id=&quot;index-0-policy:CMP0074&quot;&gt;&lt;code&gt;CMP0074&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt; &lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt; &lt;/a&gt; 에 대한 호출에 의해로드 된 찾기 모듈 또는 기타 스크립트 내에서 호출 되는 경우 현재 발견중인 패키지에 고유 한 검색 접두사를 검색합니다. 특히 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake 변수와 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 환경 변수를 살펴보십시오 . 패키지 루트 변수는 스택으로 유지되므로 중첩 된 찾기 모듈 또는 구성 패키지에서 호출하면 부모의 찾기 모듈 또는 구성 패키지의 루트 경로가 현재 모듈 또는 패키지의 경로를 따라 검색됩니다. 즉, 검색 순서는 &lt;code&gt;&amp;lt;CurrentPackage&amp;gt;_ROOT&lt;/code&gt; , &lt;code&gt;ENV{&amp;lt;CurrentPackage&amp;gt;_ROOT}&lt;/code&gt; , &lt;code&gt;&amp;lt;ParentPackage&amp;gt;_ROOT&lt;/code&gt; , &lt;code&gt;ENV{&amp;lt;ParentPackage&amp;gt;_ROOT}&lt;/code&gt; 등입니다. &lt;code&gt;NO_PACKAGE_ROOT_PATH&lt;/code&gt; 가 전달되거나 &lt;a href=&quot;../variable/cmake_find_use_package_root_path#variable:CMAKE_FIND_USE_PACKAGE_ROOT_PATH&quot; id=&quot;index-0-variable:CMAKE_FIND_USE_PACKAGE_ROOT_PATH&quot;&gt; &lt;code&gt;CMAKE_FIND_USE_PACKAGE_ROOT_PATH&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;FALSE&lt;/code&gt; 로 설정하여 건너 뛸 수 있습니다 . 정책 &lt;a href=&quot;../policy/cmp0074#policy:CMP0074&quot; id=&quot;index-0-policy:CMP0074&quot;&gt; &lt;code&gt;CMP0074&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b31c93a143d375c1c52be3e439969375ba18588c" translate="yes" xml:space="preserve">
          <source>If calling both &lt;code&gt;find_package(PythonInterp)&lt;/code&gt; and &lt;code&gt;find_package(PythonLibs)&lt;/code&gt;, call &lt;code&gt;find_package(PythonInterp)&lt;/code&gt; first to get the currently active Python version by default with a consistent version of PYTHON_LIBRARIES.</source>
          <target state="translated">모두 호출하는 경우 &lt;code&gt;find_package(PythonInterp)&lt;/code&gt; 와 &lt;code&gt;find_package(PythonLibs)&lt;/code&gt; , 전화 &lt;code&gt;find_package(PythonInterp)&lt;/code&gt; 첫 PYTHON_LIBRARIES의 일관된 버전으로 기본적으로 현재 활성화 된 파이썬 버전을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fab332da51b5bc3f9f294a4e32e446bb209cb3e7" translate="yes" xml:space="preserve">
          <source>If compiling with MSVC, this variable can be set to &lt;code&gt;MT&lt;/code&gt; or &lt;code&gt;MD&lt;/code&gt; (the default) to enable searching a GTest build tree</source>
          <target state="translated">MSVC로 컴파일하는 경우이 변수를 &lt;code&gt;MT&lt;/code&gt; 또는 &lt;code&gt;MD&lt;/code&gt; (기본값)로 설정하여 GTest 빌드 트리를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d41c846ee25d932a4b3832a4b3eb6ada1c88af" translate="yes" xml:space="preserve">
          <source>If component &lt;code&gt;Development&lt;/code&gt; is specified, it implies sub-components &lt;code&gt;Development.Module&lt;/code&gt; and &lt;code&gt;Development.Embed&lt;/code&gt;.</source>
          <target state="translated">구성 요소 &lt;code&gt;Development&lt;/code&gt; 가 지정되면 하위 구성 요소 &lt;code&gt;Development.Module&lt;/code&gt; 및 &lt;code&gt;Development.Embed&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="dbca474ee16576ce231953be33a7edeedf3a1746" translate="yes" xml:space="preserve">
          <source>If components &lt;code&gt;Interpreter&lt;/code&gt; and &lt;code&gt;Development&lt;/code&gt; (or one of its sub-components) are both specified, this module search only for interpreter with same platform architecture as the one defined by &lt;code&gt;CMake&lt;/code&gt; configuration. This constraint does not apply if only &lt;code&gt;Interpreter&lt;/code&gt; component is specified.</source>
          <target state="translated">구성 요소 &lt;code&gt;Interpreter&lt;/code&gt; 및 &lt;code&gt;Development&lt;/code&gt; (또는 하위 구성 요소 중 하나)가 모두 지정된 경우이 모듈은 &lt;code&gt;CMake&lt;/code&gt; 구성에 정의 된 것과 동일한 플랫폼 아키텍처를 가진 인터프리터 만 검색 합니다. &lt;code&gt;Interpreter&lt;/code&gt; 구성 요소 만 지정된 경우에는이 제약이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9c9240327accea955bd9cd5dbf01f37a734eb44" translate="yes" xml:space="preserve">
          <source>If components &lt;code&gt;Interpreter&lt;/code&gt; and &lt;code&gt;Development&lt;/code&gt; are both specified, this module search only for interpreter with same platform architecture as the one defined by &lt;code&gt;CMake&lt;/code&gt; configuration. This contraint does not apply if only &lt;code&gt;Interpreter&lt;/code&gt; component is specified.</source>
          <target state="translated">컴포넌트 &lt;code&gt;Interpreter&lt;/code&gt; 및 &lt;code&gt;Development&lt;/code&gt; 이 모두 지정된 경우이 모듈은 &lt;code&gt;CMake&lt;/code&gt; 구성으로 정의 된 것과 동일한 플랫폼 아키텍처를 가진 인터프리터 만 검색 합니다. &lt;code&gt;Interpreter&lt;/code&gt; 구성 요소 만 지정된 경우에는이 제약 조건이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="23f33bf9f5310a8b358bb121e66d9ab06b833722" translate="yes" xml:space="preserve">
          <source>If enabled, generates a &lt;code&gt;compile_commands.json&lt;/code&gt; file containing the exact compiler calls for all translation units of the project in machine-readable form. The format of the JSON file looks like:</source>
          <target state="translated">사용 가능한 경우, 정확한 컴파일러 호출을 포함 하는 &lt;code&gt;compile_commands.json&lt;/code&gt; 파일을 시스템에서 읽을 수있는 형식으로 프로젝트의 모든 변환 단위에 대해 생성합니다 . JSON 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40365f751e960380e567b1d5706111db75c88a28" translate="yes" xml:space="preserve">
          <source>If enabled, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt;&lt;code&gt;Xcode&lt;/code&gt;&lt;/a&gt; generator will generate only a single Xcode project file for the topmost &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command instead of generating one for every &lt;code&gt;project()&lt;/code&gt; command.</source>
          <target state="translated">활성화 된 경우 &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt; &lt;code&gt;Xcode&lt;/code&gt; &lt;/a&gt; 생성기는 모든 &lt;code&gt;project()&lt;/code&gt; 명령 마다 하나씩 생성하는 대신 최상위 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령에 대해 단일 Xcode 프로젝트 파일 만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="fb2c75d71e08090054aaa90c83b9d8ee337c6ac0" translate="yes" xml:space="preserve">
          <source>If enabled, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt;&lt;code&gt;Xcode&lt;/code&gt;&lt;/a&gt; generator will generate schema files. These are useful to invoke analyze, archive, build-for-testing and test actions from the command line.</source>
          <target state="translated">사용 가능한 경우 &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt; &lt;code&gt;Xcode&lt;/code&gt; &lt;/a&gt; 생성기는 스키마 파일을 생성합니다. 명령 행에서 분석, 아카이브, 테스트 빌드 및 테스트 조치를 호출하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="867050304a7675288eaf8963cc56214d9f2847a0" translate="yes" xml:space="preserve">
          <source>If enabled, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt;&lt;code&gt;Xcode&lt;/code&gt;&lt;/a&gt; generator will generate only a single Xcode project file for the topmost &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command instead of generating one for every &lt;code&gt;project()&lt;/code&gt; command.</source>
          <target state="translated">활성화 된 경우 &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt; &lt;code&gt;Xcode&lt;/code&gt; &lt;/a&gt; 생성기는 모든 &lt;code&gt;project()&lt;/code&gt; 명령에 대해 하나를 생성하는 대신 최상위 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령에 대해 단일 Xcode 프로젝트 파일 만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e9a4365232a4a7c505cff30323b768170bacd0a8" translate="yes" xml:space="preserve">
          <source>If enabled, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt;&lt;code&gt;Xcode&lt;/code&gt;&lt;/a&gt; generator will generate schema files. These are useful to invoke analyze, archive, build-for-testing and test actions from the command line.</source>
          <target state="translated">활성화하면 &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Xcode.html#generator:Xcode&quot; id=&quot;index-0-generator:Xcode&quot;&gt; &lt;code&gt;Xcode&lt;/code&gt; &lt;/a&gt; 생성기가 스키마 파일을 생성합니다. 이는 명령 줄에서 분석, 보관, 테스트 용 빌드 및 테스트 작업을 호출하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="184b891eafb7658e9eb08bb9aaa68720d472cdf6" translate="yes" xml:space="preserve">
          <source>If enabled, the main build&amp;rsquo;s default ALL target will not depend on the test step. This can be a useful way of ensuring the test step is defined but only gets invoked when manually requested.</source>
          <target state="translated">활성화하면 기본 빌드의 기본 ALL 대상이 테스트 단계에 의존하지 않습니다. 이는 테스트 단계가 정의되었지만 수동 요청시에만 호출되도록하는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fe34f0138ab67bac2c5b9512463a9e0d22ab71c0" translate="yes" xml:space="preserve">
          <source>If enabled, the main build&amp;rsquo;s default ALL target will not depend on the test step. This can be a useful way of ensuring the test step is defined but only gets invoked when manually requested. This may cause a step target to be created automatically for either the &lt;code&gt;install&lt;/code&gt; or &lt;code&gt;build&lt;/code&gt; step. See policy &lt;a href=&quot;../policy/cmp0114#policy:CMP0114&quot; id=&quot;index-1-policy:CMP0114&quot;&gt;&lt;code&gt;CMP0114&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">활성화하면 기본 빌드의 기본 ALL 대상이 테스트 단계에 종속되지 않습니다. 이는 테스트 단계가 정의되었는지 확인하는 유용한 방법이 될 수 있지만 수동으로 요청한 경우에만 호출됩니다. 이로 인해 &lt;code&gt;install&lt;/code&gt; 또는 &lt;code&gt;build&lt;/code&gt; 단계에 대해 단계 대상이 자동으로 생성 될 수 있습니다 . 정책 &lt;a href=&quot;../policy/cmp0114#policy:CMP0114&quot; id=&quot;index-1-policy:CMP0114&quot;&gt; &lt;code&gt;CMP0114&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34f61f4d033b49a768ae71cfe043ec99e358b69f" translate="yes" xml:space="preserve">
          <source>If enabled, this gives the custom step direct access to the terminal if possible.</source>
          <target state="translated">활성화 된 경우 가능하면 사용자 지정 단계에서 터미널에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26201c8e30d3cbdebd02af3699dc887019c7afac" translate="yes" xml:space="preserve">
          <source>If enabling &lt;code&gt;ASM&lt;/code&gt;, enable it last so that CMake can check whether compilers for other languages like &lt;code&gt;C&lt;/code&gt; work for assembly too.</source>
          <target state="translated">가능하면 &lt;code&gt;ASM&lt;/code&gt; 을 , CMake 같은 다른 언어를위한 컴파일러 여부를 확인할 수 있습니다 지난 그래서 가능 &lt;code&gt;C&lt;/code&gt; 의 작업 조립도에 대해.</target>
        </trans-unit>
        <trans-unit id="7abbffa540742c7cf4fa1ebe0e74ebfd81b48ba7" translate="yes" xml:space="preserve">
          <source>If enabling &lt;code&gt;ASM&lt;/code&gt;, list it last so that CMake can check whether compilers for other languages like &lt;code&gt;C&lt;/code&gt; work for assembly too.</source>
          <target state="translated">&lt;code&gt;ASM&lt;/code&gt; 을 활성화 한 경우 CMake가 &lt;code&gt;C&lt;/code&gt; 와 같은 다른 언어의 컴파일러 가 어셈블리에서도 작동 하는지 확인할 수 있도록 마지막으로 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="1454d9f78cfb0a64ae2e61b388f844084cb6d4a9" translate="yes" xml:space="preserve">
          <source>If false, do not try to link to OpenAL</source>
          <target state="translated">거짓이면 OpenAL에 연결하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3cc02da9837a8f08b40d058d7d5eb6baf210fb68" translate="yes" xml:space="preserve">
          <source>If false, do not try to use GIF.</source>
          <target state="translated">false 인 경우 GIF를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3ea9918af87118318049529c8bdb3158bb864037" translate="yes" xml:space="preserve">
          <source>If false, do not try to use JPEG.</source>
          <target state="translated">false 인 경우 JPEG를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7e6a05720011b912a1c5f9e7333daa111ad94d7d" translate="yes" xml:space="preserve">
          <source>If false, do not try to use PNG.</source>
          <target state="translated">false 인 경우 PNG를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="25876edcd37fcd6d58f200b27a90ab322adb7dcc" translate="yes" xml:space="preserve">
          <source>If false, don&amp;rsquo;t try to use Qt 4.</source>
          <target state="translated">False이면 Qt 4를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="05ff46dab8de8348fb8ae91792efa4efbdfbd4e1" translate="yes" xml:space="preserve">
          <source>If false, don&amp;rsquo;t try to use Qt 4. This variable is for compatibility only.</source>
          <target state="translated">거짓 인 경우 Qt 4를 사용하지 마십시오.이 변수는 호환성을 위해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c937fd47bf1974552f241cf782ed4fef913739e" translate="yes" xml:space="preserve">
          <source>If false, don&amp;rsquo;t try to use Qt. This variable is for compatibility only.</source>
          <target state="translated">False이면 Qt를 사용하지 마십시오. 이 변수는 호환성을 위해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97b28576175ccb25f038fe5a0fef27b1a21ed678" translate="yes" xml:space="preserve">
          <source>If flex is found on the system, the module provides the macro:</source>
          <target state="translated">시스템에서 flex가 발견되면 모듈은 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="34048faf9083cbcc1bbe0d5f7656256ea69a678d" translate="yes" xml:space="preserve">
          <source>If it is not set, or is set to a non-integer value, a sensible default limit is used. If the recursion limit is reached, the script terminates immediately with a fatal error.</source>
          <target state="translated">설정되지 않았거나 정수가 아닌 값으로 설정된 경우 적절한 기본 제한이 사용됩니다. 재귀 제한에 도달하면 치명적인 오류와 함께 스크립트가 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a9f6ad21f4bff30dad19b272775d6969dac0e7b3" translate="yes" xml:space="preserve">
          <source>If left out the &lt;code&gt;all&lt;/code&gt; target is built.</source>
          <target state="translated">생략하면 &lt;code&gt;all&lt;/code&gt; 대상이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="5442bb15452a712ecfb89dd0bc8d4368d66e1ab9" translate="yes" xml:space="preserve">
          <source>If library type is not specified, &lt;code&gt;MODULE&lt;/code&gt; is assumed.</source>
          <target state="translated">라이브러리 유형을 지정하지 않으면 &lt;code&gt;MODULE&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="aeba8e375f0c783f9c209104440b7f2423c3045f" translate="yes" xml:space="preserve">
          <source>If mangling for a category is not known, its macro is left undefined. All macros require raw names in both lower case and upper case.</source>
          <target state="translated">범주에 대한 조작을 알 수없는 경우 매크로가 정의되지 않은 상태로 남아 있습니다. 모든 매크로에는 소문자와 대문자 모두에서 원시 이름이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4e9f60ab0766159d96adfcbc5c7875194ce06d0f" translate="yes" xml:space="preserve">
          <source>If many external projects should have the same set of step targets, setting a directory property may be more convenient. The &lt;code&gt;build&lt;/code&gt; step target could be created automatically by setting the &lt;code&gt;EP_STEP_TARGETS&lt;/code&gt; directory property before creating the external projects with &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-10-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">많은 외부 프로젝트에 동일한 단계 대상 집합이 있어야하는 경우 디렉터리 속성을 설정하는 것이 더 편리 할 수 ​​있습니다. &lt;code&gt;build&lt;/code&gt; 단계의 목표는 설정에 의해 자동으로 생성 할 수 &lt;code&gt;EP_STEP_TARGETS&lt;/code&gt; 의 와 외부 프로젝트를 생성하기 전에 디렉토리 속성을 &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-10-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="81fd05cbc2865f3191f4c14fc220507bd602549d" translate="yes" xml:space="preserve">
          <source>If many external projects should have the same set of step targets, setting a directory property may be more convenient. The &lt;code&gt;build&lt;/code&gt; step target could be created automatically by setting the &lt;code&gt;EP_STEP_TARGETS&lt;/code&gt; directory property before creating the external projects with &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-6-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">많은 외부 프로젝트에 동일한 단계 대상 세트가 있어야하는 경우 디렉토리 특성을 설정하는 것이 더 편리 할 수 ​​있습니다. &lt;code&gt;build&lt;/code&gt; 단계의 목표는 설정에 의해 자동으로 생성 할 수 &lt;code&gt;EP_STEP_TARGETS&lt;/code&gt; 의 와 외부 프로젝트를 생성하기 전에 디렉토리 속성을 &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-6-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="557efab8af7815cb81652f809b79455810cd6fcc" translate="yes" xml:space="preserve">
          <source>If more than one &lt;code&gt;OUTPUT_*&lt;/code&gt; or &lt;code&gt;ERROR_*&lt;/code&gt; option is given for the same pipe the precedence is not specified. If no &lt;code&gt;OUTPUT_*&lt;/code&gt; or &lt;code&gt;ERROR_*&lt;/code&gt; options are given the output will be shared with the corresponding pipes of the CMake process itself.</source>
          <target state="translated">동일한 파이프에 대해 둘 이상의 &lt;code&gt;OUTPUT_*&lt;/code&gt; 또는 &lt;code&gt;ERROR_*&lt;/code&gt; 옵션이 제공된 경우 우선 순위가 지정되지 않습니다. NO이면 &lt;code&gt;OUTPUT_*&lt;/code&gt; 또는 &lt;code&gt;ERROR_*&lt;/code&gt; 옵션 출력이 CMake 프로세스 자체의 대응 파이프와 공유한다 주어진다.</target>
        </trans-unit>
        <trans-unit id="1bf10a4079d54118f50926664fe4d801b72e746b" translate="yes" xml:space="preserve">
          <source>If more than one artifact is specified, it is the user&amp;rsquo;s responsibility to ensure the consistency of the various artifacts.</source>
          <target state="translated">둘 이상의 아티팩트가 지정된 경우 다양한 아티팩트의 일관성을 보장하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="dc7929c846614bb3c192a2fe8907908cc5e956f0" translate="yes" xml:space="preserve">
          <source>If more than one library was found, all of them should be included in these variables (see the &lt;a href=&quot;#standard-variable-names&quot;&gt;Standard Variable Names&lt;/a&gt; section for more information).</source>
          <target state="translated">둘 이상의 라이브러리가 발견되면 모든 변수가이 변수에 포함되어야합니다 (자세한 내용은 &lt;a href=&quot;#standard-variable-names&quot;&gt;표준 변수 이름&lt;/a&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="2b7d1e9bc9224820618f618eb5f12dad67320006" translate="yes" xml:space="preserve">
          <source>If multiple tests specify the same resource lock, they are guaranteed not to run concurrently.</source>
          <target state="translated">여러 테스트에서 동일한 리소스 잠금을 지정하면 동시에 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="738e91e7a3f68b153b759e799475035fdec70559" translate="yes" xml:space="preserve">
          <source>If neither &lt;a href=&quot;#prop_tgt:JOB_POOL_PRECOMPILE_HEADER&quot; id=&quot;index-0-prop_tgt:JOB_POOL_PRECOMPILE_HEADER&quot;&gt;&lt;code&gt;JOB_POOL_PRECOMPILE_HEADER&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;../variable/cmake_job_pool_precompile_header#variable:CMAKE_JOB_POOL_PRECOMPILE_HEADER&quot; id=&quot;index-1-variable:CMAKE_JOB_POOL_PRECOMPILE_HEADER&quot;&gt;&lt;code&gt;CMAKE_JOB_POOL_PRECOMPILE_HEADER&lt;/code&gt;&lt;/a&gt; are set then &lt;a href=&quot;job_pool_compile#prop_tgt:JOB_POOL_COMPILE&quot; id=&quot;index-0-prop_tgt:JOB_POOL_COMPILE&quot;&gt;&lt;code&gt;JOB_POOL_COMPILE&lt;/code&gt;&lt;/a&gt; will be used for this task.</source>
          <target state="translated">어느 경우 &lt;a href=&quot;#prop_tgt:JOB_POOL_PRECOMPILE_HEADER&quot; id=&quot;index-0-prop_tgt:JOB_POOL_PRECOMPILE_HEADER&quot;&gt; &lt;code&gt;JOB_POOL_PRECOMPILE_HEADER&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;../variable/cmake_job_pool_precompile_header#variable:CMAKE_JOB_POOL_PRECOMPILE_HEADER&quot; id=&quot;index-1-variable:CMAKE_JOB_POOL_PRECOMPILE_HEADER&quot;&gt; &lt;code&gt;CMAKE_JOB_POOL_PRECOMPILE_HEADER&lt;/code&gt; 이&lt;/a&gt; 다음 설정 &lt;a href=&quot;job_pool_compile#prop_tgt:JOB_POOL_COMPILE&quot; id=&quot;index-0-prop_tgt:JOB_POOL_COMPILE&quot;&gt; &lt;code&gt;JOB_POOL_COMPILE&lt;/code&gt; 는&lt;/a&gt; 이 작업에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ec764198dd1c6663dfba4bd8e0bdc9f8b206129" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;NETRC&lt;/code&gt; option is given CMake will check variables &lt;code&gt;CMAKE_NETRC&lt;/code&gt; and &lt;code&gt;CMAKE_NETRC_FILE&lt;/code&gt;, respectively.</source>
          <target state="translated">&lt;code&gt;NETRC&lt;/code&gt; 옵션이 제공 되지 않으면 CMake는 각각 &lt;code&gt;CMAKE_NETRC&lt;/code&gt; 및 &lt;code&gt;CMAKE_NETRC_FILE&lt;/code&gt; 변수를 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d3c352b14aac248dc3a1c47bd89084829f5acb" translate="yes" xml:space="preserve">
          <source>If neither of the above conditions are met, it is assumed that the command name is a program to be found on the &lt;code&gt;PATH&lt;/code&gt; at build time.</source>
          <target state="translated">위의 조건 중 어느 것도 충족되지 않는 경우 명령 이름은 빌드시 &lt;code&gt;PATH&lt;/code&gt; 에서 찾을 수있는 프로그램이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="72bbd38d1eb0d3712acbba4fd016c2da07213906" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;COMPONENTS&lt;/code&gt; are specified, &lt;code&gt;Interpreter&lt;/code&gt; is assumed.</source>
          <target state="translated">&lt;code&gt;COMPONENTS&lt;/code&gt; 가 지정 되지 않은 경우 &lt;code&gt;Interpreter&lt;/code&gt; 로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e7bed97e422d1a916929ce04438590b9a8a9859e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;COMPONENTS&lt;/code&gt; is specified, &lt;code&gt;Interpreter&lt;/code&gt; is assumed.</source>
          <target state="translated">&lt;code&gt;COMPONENTS&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;Interpreter&lt;/code&gt; 로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="326df0ed4b9d0688a5041a3173717fc7cdfb9152" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;PREFIX&lt;/code&gt;, &lt;code&gt;EP_PREFIX&lt;/code&gt;, or &lt;code&gt;EP_BASE&lt;/code&gt; is specified, then the default is to set &lt;code&gt;PREFIX&lt;/code&gt; to &lt;code&gt;&amp;lt;name&amp;gt;-prefix&lt;/code&gt;. Relative paths are interpreted with respect to &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt; at the point where &lt;code&gt;ExternalProject_Add()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;PREFIX&lt;/code&gt; , &lt;code&gt;EP_PREFIX&lt;/code&gt; 또는 &lt;code&gt;EP_BASE&lt;/code&gt; 가 지정 되지 않은 경우 기본값은 &lt;code&gt;PREFIX&lt;/code&gt; 를 &lt;code&gt;&amp;lt;name&amp;gt;-prefix&lt;/code&gt; 로 설정하는 것 입니다. 상대 경로는 &lt;code&gt;ExternalProject_Add()&lt;/code&gt; 가 호출 되는 지점에서 &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; &lt;/a&gt; 과 관련하여 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e4e8532d2c76f3d90ea05988211445b1992dd4c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;VERSION&lt;/code&gt; is given, the &lt;a href=&quot;../variable/project_version#variable:PROJECT_VERSION&quot; id=&quot;index-0-variable:PROJECT_VERSION&quot;&gt;&lt;code&gt;PROJECT_VERSION&lt;/code&gt;&lt;/a&gt; variable is used. If this hasn&amp;rsquo;t been set, it errors out.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 이 제공 되지 않으면 &lt;a href=&quot;../variable/project_version#variable:PROJECT_VERSION&quot; id=&quot;index-0-variable:PROJECT_VERSION&quot;&gt; &lt;code&gt;PROJECT_VERSION&lt;/code&gt; &lt;/a&gt; 변수가 사용됩니다. 이것이 설정되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45101166804a3c8302449d2b26279989369cfd35" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;[version]&lt;/code&gt; and/or component list is given to a recursive invocation inside a find-module, the corresponding arguments are forwarded automatically from the outer call (including the &lt;code&gt;EXACT&lt;/code&gt; flag for &lt;code&gt;[version]&lt;/code&gt;). Version support is currently provided only on a package-by-package basis (see the &lt;a href=&quot;#version-selection&quot;&gt;Version Selection&lt;/a&gt; section below). When a version range is specified but the package is only designed to expect a single version, the package will ignore the upper end point of the range and only take the single version at the lower end of the range into account.</source>
          <target state="translated">find-module 내부의 재귀 호출에 &lt;code&gt;[version]&lt;/code&gt; 및 / 또는 구성 요소 목록이 제공 되지 않으면 해당 인수가 외부 호출에서 자동으로 전달됩니다 ( &lt;code&gt;[version]&lt;/code&gt; 에 대한 &lt;code&gt;EXACT&lt;/code&gt; 플래그 포함 ). 버전 지원은 현재 패키지 단위로만 제공됩니다 (아래 &lt;a href=&quot;#version-selection&quot;&gt;버전 선택&lt;/a&gt; 섹션 참조). 버전 범위가 지정되었지만 패키지가 단일 버전 만 예상하도록 설계된 경우 패키지는 범위의 상단 끝점을 무시하고 범위의 하단에있는 단일 버전 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="c2f698832628ef5f8c4ead002990c5e31959a51e" translate="yes" xml:space="preserve">
          <source>If no argument is given after &lt;code&gt;ENV{&amp;lt;variable&amp;gt;}&lt;/code&gt; or if &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is an empty string, then this command will clear any existing value of the environment variable.</source>
          <target state="translated">&lt;code&gt;ENV{&amp;lt;variable&amp;gt;}&lt;/code&gt; 뒤에 인수가 제공되지 않거나 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 가 빈 문자열 인 경우이 명령은 환경 변수의 기존 값을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="f67727e80d8df0633da95ebe9836eda8c2e1d01f" translate="yes" xml:space="preserve">
          <source>If no arguments given, &lt;code&gt;include_guard&lt;/code&gt; has the same scope as a variable, meaning that the include guard effect is isolated by the most recent function scope or current directory if no inner function scopes exist. In this case the command behavior is the same as:</source>
          <target state="translated">인수가 제공되지 않으면 &lt;code&gt;include_guard&lt;/code&gt; 는 변수와 동일한 범위를 갖습니다. 즉, 내부 함수 범위가 존재하지 않으면 포함 가드 효과가 최신 함수 범위 또는 현재 디렉토리에 의해 분리됩니다. 이 경우 명령 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0ddeddd7faedd568ef8d5b7b2c671f916f2220d" translate="yes" xml:space="preserve">
          <source>If no component is specified in the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; call, then it only searches for the ImageMagick executable directory. This code defines the following variables:</source>
          <target state="translated">&lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 호출 에 구성 요소가 지정되지 않은 경우 ImageMagick 실행 파일 디렉토리 만 검색합니다. 이 코드는 다음 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="429bbff986c1aecd35eada0718b113ebdb0a04ec" translate="yes" xml:space="preserve">
          <source>If no explicit &lt;a href=&quot;#prop_tgt:UNITY_BUILD_MODE&quot; id=&quot;index-0-prop_tgt:UNITY_BUILD_MODE&quot;&gt;&lt;code&gt;UNITY_BUILD_MODE&lt;/code&gt;&lt;/a&gt; has been specified, CMake will default to &lt;code&gt;BATCH&lt;/code&gt;.</source>
          <target state="translated">명시 적 &lt;a href=&quot;#prop_tgt:UNITY_BUILD_MODE&quot; id=&quot;index-0-prop_tgt:UNITY_BUILD_MODE&quot;&gt; &lt;code&gt;UNITY_BUILD_MODE&lt;/code&gt; &lt;/a&gt; 가 지정 되지 않은 경우 CMake는 기본적으로 &lt;code&gt;BATCH&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f96038217144684da1eb206e8c7a554ea9017ad" translate="yes" xml:space="preserve">
          <source>If no explicit &lt;a href=&quot;unity_build_mode#prop_tgt:UNITY_BUILD_MODE&quot; id=&quot;index-1-prop_tgt:UNITY_BUILD_MODE&quot;&gt;&lt;code&gt;UNITY_BUILD_MODE&lt;/code&gt;&lt;/a&gt; has been specified, CMake will default to &lt;code&gt;BATCH&lt;/code&gt;.</source>
          <target state="translated">명시 적 &lt;a href=&quot;unity_build_mode#prop_tgt:UNITY_BUILD_MODE&quot; id=&quot;index-1-prop_tgt:UNITY_BUILD_MODE&quot;&gt; &lt;code&gt;UNITY_BUILD_MODE&lt;/code&gt; &lt;/a&gt; 가 지정 되지 않은 경우 CMake는 기본적으로 &lt;code&gt;BATCH&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cee43e793c33b8fc5ce96b3ab373d44b41a3a7f" translate="yes" xml:space="preserve">
          <source>If no explicit &lt;code&gt;&amp;lt;format string&amp;gt;&lt;/code&gt; is given it will default to:</source>
          <target state="translated">명시적인 &lt;code&gt;&amp;lt;format string&amp;gt;&lt;/code&gt; 이 없으면 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="674cf2c8cb48e088b2e72e10862aafb55095c771" translate="yes" xml:space="preserve">
          <source>If no explicit &lt;code&gt;&amp;lt;format_string&amp;gt;&lt;/code&gt; is given, it will default to:</source>
          <target state="translated">명시 적 &lt;code&gt;&amp;lt;format_string&amp;gt;&lt;/code&gt; 이 지정 되지 않은 경우 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07cfde79fa51309df3c1c8e13832b49cd36f822c" translate="yes" xml:space="preserve">
          <source>If no tests were found, the default behavior of CTest is to always log an error message but to return an error code in script mode only. This option unifies the behavior of CTest by either returning an error code if no tests were found or by ignoring it.</source>
          <target state="translated">테스트가 발견되지 않은 경우 CTest의 기본 동작은 항상 오류 메시지를 기록하지만 스크립트 모드에서만 오류 코드를 반환하는 것입니다. 이 옵션은 테스트를 찾을 수없는 경우 오류 코드를 반환하거나 무시하여 CTest의 동작을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="b505dd517fb85fe7ea74ba5312f273fa9f6ad9c8" translate="yes" xml:space="preserve">
          <source>If no value is set and if a &lt;code&gt;.int&lt;/code&gt; file is added as a source file to the executable target it will be treated as an &lt;code&gt;Integrity Application&lt;/code&gt;.</source>
          <target state="translated">값을 설정하지 않고 &lt;code&gt;.int&lt;/code&gt; 파일을 실행 파일에 소스 파일로 추가하면 &lt;code&gt;Integrity Application&lt;/code&gt; 으로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="d19f4a86a17f0ec822a40563125dd7743176e5e8" translate="yes" xml:space="preserve">
          <source>If no variable name is given, removes exactly one element. Otherwise, assign the first element&amp;rsquo;s value to the given variable and removes it, up to the last variable name given.</source>
          <target state="translated">변수 이름이 없으면 정확히 하나의 요소를 제거합니다. 그렇지 않으면 첫 번째 요소의 값을 주어진 변수에 할당하고 주어진 마지막 변수 이름까지 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9ed74f4234a3180de981150cab53a4bf64ae0456" translate="yes" xml:space="preserve">
          <source>If no variable name is given, removes exactly one element. Otherwise, assign the last element&amp;rsquo;s value to the given variable and removes it, up to the last variable name given.</source>
          <target state="translated">변수 이름이 없으면 정확히 하나의 요소를 제거합니다. 그렇지 않으면 마지막 요소의 값을 주어진 변수에 할당하고 주어진 마지막 변수 이름까지 제거합니다.</target>
        </trans-unit>
        <trans-unit id="de994325bf4c3507d6337d773fbe378097afb001" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;FALSE&lt;/code&gt;, use of deprecated functionality will issue warnings. If this variable is not set, CMake behaves as if it were set to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 가 아닌 경우 , 더 이상 사용되지 않는 기능을 사용하면 경고가 발행됩니다. 이 변수를 설정하지 않으면 CMake는 마치 &lt;code&gt;TRUE&lt;/code&gt; 로 설정된 것처럼 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="df40a7cf08e816ddb19eced6d55adee232926119" translate="yes" xml:space="preserve">
          <source>If not defined, search for shared libraries and static libraries in that order.</source>
          <target state="translated">정의되지 않은 경우 공유 라이브러리 및 정적 라이브러리를 순서대로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="da3f1097a123dc3a947e2dee06fc1440a9acfad4" translate="yes" xml:space="preserve">
          <source>If not set explicitly the value is initialized by the &lt;code&gt;CMAKE_MSVCIDE_RUN_PATH&lt;/code&gt; environment variable, if set, and otherwise left empty.</source>
          <target state="translated">명시 적으로 설정하지 않으면 값은 &lt;code&gt;CMAKE_MSVCIDE_RUN_PATH&lt;/code&gt; 환경 변수 (설정된 경우)에 의해 초기화 되고 그렇지 않으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23d25baa2dbf6fc969bf8dbcecf42019c2960778" translate="yes" xml:space="preserve">
          <source>If not set explicitly the value is initialized by the &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt; environment variable, if set, and otherwise computed based on the host platform.</source>
          <target state="translated">명시 적으로 설정하지 않으면 값은 &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt; 환경 변수 (설정된 경우)에 의해 초기화되고 그렇지 않으면 호스트 플랫폼을 기반으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ade365e49df034b291a4e6dd2b70207c6474b2c2" translate="yes" xml:space="preserve">
          <source>If not set explicitly the value is initialized by the &lt;code&gt;SDKROOT&lt;/code&gt; environment variable, if set, and otherwise computed based on the &lt;a href=&quot;cmake_osx_deployment_target#variable:CMAKE_OSX_DEPLOYMENT_TARGET&quot; id=&quot;index-0-variable:CMAKE_OSX_DEPLOYMENT_TARGET&quot;&gt;&lt;code&gt;CMAKE_OSX_DEPLOYMENT_TARGET&lt;/code&gt;&lt;/a&gt; or the host platform.</source>
          <target state="translated">명시 적으로 설정하지 않으면 값은 &lt;code&gt;SDKROOT&lt;/code&gt; 환경 변수에 의해 초기화되고 ( 설정된 경우) &lt;a href=&quot;cmake_osx_deployment_target#variable:CMAKE_OSX_DEPLOYMENT_TARGET&quot; id=&quot;index-0-variable:CMAKE_OSX_DEPLOYMENT_TARGET&quot;&gt; &lt;code&gt;CMAKE_OSX_DEPLOYMENT_TARGET&lt;/code&gt; &lt;/a&gt; 또는 호스트 플랫폼을 기반으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b350555ffbfe92a276b57345b8d1dad228c8d82" translate="yes" xml:space="preserve">
          <source>If not set, CMake treats this property as &lt;code&gt;OFF&lt;/code&gt; by default. CMake generators that are capable of organizing into a hierarchy of folders use the values of the &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-1-prop_tgt:FOLDER&quot;&gt;&lt;code&gt;FOLDER&lt;/code&gt;&lt;/a&gt; target property to name those folders. See also the documentation for the &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-2-prop_tgt:FOLDER&quot;&gt;&lt;code&gt;FOLDER&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">설정하지 않으면 CMake는이 속성 을 기본적 으로 &lt;code&gt;OFF&lt;/code&gt; 로 취급합니다 . 폴더 계층 구조로 구성 할 수있는 CMake 생성기는 &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-1-prop_tgt:FOLDER&quot;&gt; &lt;code&gt;FOLDER&lt;/code&gt; &lt;/a&gt; 대상 특성 의 값을 사용하여 해당 폴더의 이름을 지정합니다. &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-2-prop_tgt:FOLDER&quot;&gt; &lt;code&gt;FOLDER&lt;/code&gt; &lt;/a&gt; 대상 속성에 대한 설명서도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb74e6ff4bb1be8aa0a1ebb606bec384f11e8742" translate="yes" xml:space="preserve">
          <source>If not set, CMake uses &amp;ldquo;CMakePredefinedTargets&amp;rdquo; as a default value for this property. Targets such as INSTALL, PACKAGE and RUN_TESTS will be organized into this FOLDER. See also the documentation for the &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-0-prop_tgt:FOLDER&quot;&gt;&lt;code&gt;FOLDER&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">설정하지 않으면 CMake는이 속성의 기본값으로 &quot;CMakePredefinedTargets&quot;를 사용합니다. INSTALL, PACKAGE 및 RUN_TESTS와 같은 대상이이 FOLDER로 구성됩니다. &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-0-prop_tgt:FOLDER&quot;&gt; &lt;code&gt;FOLDER&lt;/code&gt; &lt;/a&gt; 대상 속성에 대한 설명서도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9193e511f15947f1228cccdef8e3ebd91a751c55" translate="yes" xml:space="preserve">
          <source>If not set, CMake uses the &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-1-prop_tgt:FOLDER&quot;&gt;&lt;code&gt;FOLDER&lt;/code&gt;&lt;/a&gt; property of the parent target as a default value for this property. See also the documentation for the &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-2-prop_tgt:FOLDER&quot;&gt;&lt;code&gt;FOLDER&lt;/code&gt;&lt;/a&gt; target property and the &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-1-prop_tgt:AUTOMOC&quot;&gt;&lt;code&gt;AUTOMOC&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">설정하지 않으면 CMake는 상위 대상 의 &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-1-prop_tgt:FOLDER&quot;&gt; &lt;code&gt;FOLDER&lt;/code&gt; &lt;/a&gt; 속성을이 속성의 기본값으로 사용합니다. &lt;a href=&quot;../prop_tgt/folder#prop_tgt:FOLDER&quot; id=&quot;index-2-prop_tgt:FOLDER&quot;&gt; &lt;code&gt;FOLDER&lt;/code&gt; &lt;/a&gt; 대상 속성 및 &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-1-prop_tgt:AUTOMOC&quot;&gt; &lt;code&gt;AUTOMOC&lt;/code&gt; &lt;/a&gt; 대상 속성에 대한 설명서도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbc0b8dd8779fda12d439f8b008a02d0f194d0ae" translate="yes" xml:space="preserve">
          <source>If not set, the string &amp;ldquo;&lt;code&gt;&amp;lt;TYPE&amp;gt;&lt;/code&gt; packages&amp;rdquo; is used.</source>
          <target state="translated">설정하지 않으면 문자열 &quot; &lt;code&gt;&amp;lt;TYPE&amp;gt;&lt;/code&gt; packages&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c910b932becb0586cd772435b7784cb48528dd" translate="yes" xml:space="preserve">
          <source>If not set, this property uses the value of the &lt;a href=&quot;../variable/cmake_job_pools#variable:CMAKE_JOB_POOLS&quot; id=&quot;index-0-variable:CMAKE_JOB_POOLS&quot;&gt;&lt;code&gt;CMAKE_JOB_POOLS&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">설정되지 않은 경우이 특성은 &lt;a href=&quot;../variable/cmake_job_pools#variable:CMAKE_JOB_POOLS&quot; id=&quot;index-0-variable:CMAKE_JOB_POOLS&quot;&gt; &lt;code&gt;CMAKE_JOB_POOLS&lt;/code&gt; &lt;/a&gt; 변수 의 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fe79476e1a8a00d4d5090047776246f0935cb077" translate="yes" xml:space="preserve">
          <source>If not specified, CMake checks the &lt;a href=&quot;../envvar/cmake_generator#envvar:CMAKE_GENERATOR&quot; id=&quot;index-0-envvar:CMAKE_GENERATOR&quot;&gt;&lt;code&gt;CMAKE_GENERATOR&lt;/code&gt;&lt;/a&gt; environment variable and otherwise falls back to a builtin default selection.</source>
          <target state="translated">지정하지 않으면 CMake는 &lt;a href=&quot;../envvar/cmake_generator#envvar:CMAKE_GENERATOR&quot; id=&quot;index-0-envvar:CMAKE_GENERATOR&quot;&gt; &lt;code&gt;CMAKE_GENERATOR&lt;/code&gt; &lt;/a&gt; 환경 변수를 확인하고 그렇지 않으면 기본 제공 기본 선택으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="0383a3936dbe01c440196142e58b24182954b1d4" translate="yes" xml:space="preserve">
          <source>If not specified, the default will be &lt;em&gt;false&lt;/em&gt; if using a NDK version that provides the unified headers and &lt;em&gt;true&lt;/em&gt; otherwise.</source>
          <target state="translated">지정하지 않으면 통합 헤더를 제공하는 NDK 버전을 사용하는 경우 기본값은 &lt;em&gt;false&lt;/em&gt; 이고 &lt;em&gt;그렇지&lt;/em&gt; 않으면 &lt;em&gt;true&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fa2aa5cc02c205b99dc76d79bc8d459f575bffb" translate="yes" xml:space="preserve">
          <source>If not specified, the default will be a value that selects the latest available GCC toolchain.</source>
          <target state="translated">지정하지 않으면 기본값은 사용 가능한 최신 GCC 툴체인을 선택하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="b069f3c1816aa6ea2d4b779547d8e21dc098d457" translate="yes" xml:space="preserve">
          <source>If one or more package in this categories has not been found, CMake will abort when calling &lt;a href=&quot;#command:feature_summary&quot; id=&quot;index-0-command:feature_summary&quot;&gt;&lt;code&gt;feature_summary()&lt;/code&gt;&lt;/a&gt; with the &amp;lsquo;FATAL_ON_MISSING_REQUIRED_PACKAGES&amp;rsquo; option enabled.</source>
          <target state="translated">이 범주에서 하나 이상의 패키지를 찾지 못한 경우 CMFA는 'FATAL_ON_MISSING_REQUIRED_PACKAGES'옵션을 활성화하여 &lt;a href=&quot;#command:feature_summary&quot; id=&quot;index-0-command:feature_summary&quot;&gt; &lt;code&gt;feature_summary()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="2518d614876354e845d92e10ad71efe7209de0f6" translate="yes" xml:space="preserve">
          <source>If only &lt;code&gt;basename_LIBRARY_RELEASE&lt;/code&gt; is defined, &lt;code&gt;basename_LIBRARY&lt;/code&gt; will be set to the release value, and &lt;code&gt;basename_LIBRARY_DEBUG&lt;/code&gt; will be set to &lt;code&gt;basename_LIBRARY_DEBUG-NOTFOUND&lt;/code&gt;. If only &lt;code&gt;basename_LIBRARY_DEBUG&lt;/code&gt; is defined, then &lt;code&gt;basename_LIBRARY&lt;/code&gt; will take the debug value, and &lt;code&gt;basename_LIBRARY_RELEASE&lt;/code&gt; will be set to &lt;code&gt;basename_LIBRARY_RELEASE-NOTFOUND&lt;/code&gt;.</source>
          <target state="translated">경우에만 &lt;code&gt;basename_LIBRARY_RELEASE&lt;/code&gt; 가 정의되고, &lt;code&gt;basename_LIBRARY&lt;/code&gt; 은 릴리스 값으로 설정되며, &lt;code&gt;basename_LIBRARY_DEBUG&lt;/code&gt; 이 설정됩니다 &lt;code&gt;basename_LIBRARY_DEBUG-NOTFOUND&lt;/code&gt; . 경우에만 &lt;code&gt;basename_LIBRARY_DEBUG&lt;/code&gt; 가 정의되고, 다음 &lt;code&gt;basename_LIBRARY&lt;/code&gt; 는 디버그 값을 취할 것이며, &lt;code&gt;basename_LIBRARY_RELEASE&lt;/code&gt; 이 설정됩니다 &lt;code&gt;basename_LIBRARY_RELEASE-NOTFOUND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebcbde2218e66c214c9f58a9a93171174de2845a" translate="yes" xml:space="preserve">
          <source>If policy &lt;a href=&quot;../policy/cmp0060#policy:CMP0060&quot; id=&quot;index-0-policy:CMP0060&quot;&gt;&lt;code&gt;CMP0060&lt;/code&gt;&lt;/a&gt; is not set to &lt;code&gt;NEW&lt;/code&gt;, then when a library in one of these directories is given by full path to &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-0-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt; CMake will generate the &lt;code&gt;-l&amp;lt;name&amp;gt;&lt;/code&gt; form on link lines for historical purposes.</source>
          <target state="translated">정책 &lt;a href=&quot;../policy/cmp0060#policy:CMP0060&quot; id=&quot;index-0-policy:CMP0060&quot;&gt; &lt;code&gt;CMP0060&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;NEW&lt;/code&gt; 로 설정되지 않은 경우,이 디렉토리 중 하나의 라이브러리가 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-0-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; 전체 경로로 제공 되면 CMake는 히스토리 목적으로 링크 행에 &lt;code&gt;-l&amp;lt;name&amp;gt;&lt;/code&gt; 양식을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="1adf54f66df93def1552e65b8b1c773994e72024" translate="yes" xml:space="preserve">
          <source>If policy &lt;a href=&quot;../policy/cmp0068#policy:CMP0068&quot; id=&quot;index-0-policy:CMP0068&quot;&gt;&lt;code&gt;CMP0068&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;NEW&lt;/code&gt;, this property also controls use of &lt;a href=&quot;install_name_dir#prop_tgt:INSTALL_NAME_DIR&quot; id=&quot;index-0-prop_tgt:INSTALL_NAME_DIR&quot;&gt;&lt;code&gt;INSTALL_NAME_DIR&lt;/code&gt;&lt;/a&gt; in the build tree on macOS. Either way, the &lt;a href=&quot;build_with_install_name_dir#prop_tgt:BUILD_WITH_INSTALL_NAME_DIR&quot; id=&quot;index-0-prop_tgt:BUILD_WITH_INSTALL_NAME_DIR&quot;&gt;&lt;code&gt;BUILD_WITH_INSTALL_NAME_DIR&lt;/code&gt;&lt;/a&gt; target property takes precedence.</source>
          <target state="translated">정책 &lt;a href=&quot;../policy/cmp0068#policy:CMP0068&quot; id=&quot;index-0-policy:CMP0068&quot;&gt; &lt;code&gt;CMP0068&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;NEW&lt;/code&gt; 가 아닌 경우이 특성은 macOS의 빌드 트리에서 &lt;a href=&quot;install_name_dir#prop_tgt:INSTALL_NAME_DIR&quot; id=&quot;index-0-prop_tgt:INSTALL_NAME_DIR&quot;&gt; &lt;code&gt;INSTALL_NAME_DIR&lt;/code&gt; &lt;/a&gt; 사용을 제어합니다 . 어느 쪽이든 &lt;a href=&quot;build_with_install_name_dir#prop_tgt:BUILD_WITH_INSTALL_NAME_DIR&quot; id=&quot;index-0-prop_tgt:BUILD_WITH_INSTALL_NAME_DIR&quot;&gt; &lt;code&gt;BUILD_WITH_INSTALL_NAME_DIR&lt;/code&gt; &lt;/a&gt; 대상 속성이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="956833caeba66e8c3b7ef50acbe1706aa405421a" translate="yes" xml:space="preserve">
          <source>If policy &lt;a href=&quot;../policy/cmp0086#policy:CMP0086&quot; id=&quot;index-0-policy:CMP0086&quot;&gt;&lt;code&gt;CMP0086&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;NEW&lt;/code&gt;, &lt;code&gt;-module &amp;lt;module_name&amp;gt;&lt;/code&gt; is passed to &lt;code&gt;SWIG&lt;/code&gt; compiler.</source>
          <target state="translated">정책 경우 &lt;a href=&quot;../policy/cmp0086#policy:CMP0086&quot; id=&quot;index-0-policy:CMP0086&quot;&gt; &lt;code&gt;CMP0086&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;code&gt;NEW&lt;/code&gt; , &lt;code&gt;-module &amp;lt;module_name&amp;gt;&lt;/code&gt; 에 전달 &lt;code&gt;SWIG&lt;/code&gt; 컴파일러.</target>
        </trans-unit>
        <trans-unit id="1e020b0c2f005309a323e464c9709aff4ae278f6" translate="yes" xml:space="preserve">
          <source>If possible, the MPI version will be determined by this module. The facilities to detect the MPI version were introduced with MPI-1.2, and therefore cannot be found for older MPI versions.</source>
          <target state="translated">가능하면이 모듈에서 MPI 버전을 결정합니다. MPI 버전을 감지하는 기능은 MPI-1.2에서 도입되었으므로 이전 MPI 버전에서는 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8521310c7ab6e5e56e009826eabca260d778b45" translate="yes" xml:space="preserve">
          <source>If present and true, this will cause all libraries to be built shared unless the library was explicitly added as a static library. This variable is often added to projects as an &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-0-command:option&quot;&gt;&lt;code&gt;option()&lt;/code&gt;&lt;/a&gt; so that each user of a project can decide if they want to build the project using shared or static libraries.</source>
          <target state="translated">존재하고 true이면 라이브러리가 정적 라이브러리로 명시 적으로 추가되지 않은 경우 모든 라이브러리가 공유로 빌드됩니다. 이 변수는 종종 프로젝트에 &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-0-command:option&quot;&gt; &lt;code&gt;option()&lt;/code&gt; &lt;/a&gt; 으로 추가되어 프로젝트의 각 사용자가 공유 또는 정적 라이브러리를 사용하여 프로젝트를 빌드 할 것인지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46443ef3218d266800ab26081649bb729efa30e5" translate="yes" xml:space="preserve">
          <source>If provided, the optional &lt;code&gt;comment&lt;/code&gt; will be passed as the &lt;code&gt;COMMENT&lt;/code&gt; for the &lt;a href=&quot;../command/add_custom_target#command:add_custom_target&quot; id=&quot;index-0-command:add_custom_target&quot;&gt;&lt;code&gt;add_custom_target()&lt;/code&gt;&lt;/a&gt; command used to create the custom target internally.</source>
          <target state="translated">제공 한 경우, 옵션 &lt;code&gt;comment&lt;/code&gt; 는 AS 전달됩니다 &lt;code&gt;COMMENT&lt;/code&gt; 에 대한 &lt;a href=&quot;../command/add_custom_target#command:add_custom_target&quot; id=&quot;index-0-command:add_custom_target&quot;&gt; &lt;code&gt;add_custom_target()&lt;/code&gt; &lt;/a&gt; 내부적으로 사용자 정의 대상을 만드는 데 사용되는 명령.</target>
        </trans-unit>
        <trans-unit id="ec6bc186ce164c347e9de686a37bf1dd2980360c" translate="yes" xml:space="preserve">
          <source>If required, you may select which files and directories to list or extract from the archive using the specified &lt;code&gt;&amp;lt;patterns&amp;gt;&lt;/code&gt;. Wildcards are supported. If the &lt;code&gt;PATTERNS&lt;/code&gt; option is not given, the entire archive will be listed or extracted.</source>
          <target state="translated">필요한 경우 지정된 &lt;code&gt;&amp;lt;patterns&amp;gt;&lt;/code&gt; 를 사용하여 아카이브에서 나열하거나 추출 할 파일 및 디렉토리를 선택할 수 있습니다 . 와일드 카드가 지원됩니다. 는 IF &lt;code&gt;PATTERNS&lt;/code&gt; 옵션이 제공되지 않으며, 전체 아카이브 목록 또는 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="1d09d0430e79bf59f7b657720c27b472484899c7" translate="yes" xml:space="preserve">
          <source>If set in the cache it is used to initialize the value of the &lt;a href=&quot;../prop_gbl/rule_messages#prop_gbl:RULE_MESSAGES&quot; id=&quot;index-0-prop_gbl:RULE_MESSAGES&quot;&gt;&lt;code&gt;RULE_MESSAGES&lt;/code&gt;&lt;/a&gt; property. Users may disable the option in their local build tree to disable granular messages and report only as each target completes in Makefile builds.</source>
          <target state="translated">캐시에 설정된 경우 &lt;a href=&quot;../prop_gbl/rule_messages#prop_gbl:RULE_MESSAGES&quot; id=&quot;index-0-prop_gbl:RULE_MESSAGES&quot;&gt; &lt;code&gt;RULE_MESSAGES&lt;/code&gt; &lt;/a&gt; 특성 값을 초기화하는 데 사용됩니다 . 사용자는 로컬 빌드 트리에서 옵션을 비활성화하여 세부 메시지를 비활성화하고 각 대상이 Makefile 빌드에서 완료 될 때만보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="272ec1d6420f5b2744281dbff393f2a7317dff29" translate="yes" xml:space="preserve">
          <source>If set this CMake script will be executed by CPack during its local [CPack-private] installation which is done right before packaging the files. The script is not called by e.g.: &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">설정하면이 CMake 스크립트는 파일을 패키징하기 직전에 수행되는 로컬 [CPack-private] 설치 중에 CPack에 의해 실행됩니다. 스크립트는 예를 들어 &lt;code&gt;make install&lt;/code&gt; 에 의해 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c1fc101f76be58173fe034af9fb26a060d0a33e9" translate="yes" xml:space="preserve">
          <source>If set this will enable device linking on the library target. Normally device linking is deferred until a shared library or executable is generated, allowing for multiple static libraries to resolve device symbols at the same time when they are used by a shared library or executable.</source>
          <target state="translated">설정하면 라이브러리 대상에서 장치 연결이 활성화됩니다. 일반적으로 장치 링크는 공유 라이브러리 또는 실행 파일이 생성 될 때까지 지연되므로 공유 라이브러리 또는 실행 파일에서 여러 심볼 라이브러리를 사용할 때 여러 정적 라이브러리가 동시에 장치 기호를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343524f270e356ac04c4117963b1a6c10a95d3ca" translate="yes" xml:space="preserve">
          <source>If set this will enable separable compilation for all CUDA files for the given target.</source>
          <target state="translated">설정하면 주어진 타겟에 대한 모든 CUDA 파일에 대해 분리 가능한 컴파일이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9f5805ecfd5007b48fdaee93cffbd5e01ccbbc02" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;FALSE&lt;/code&gt; or undefined: Enable multiple version/component requirements.</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 로 설정 하거나 정의되지 않은 경우 : 여러 버전 / 구성 요소 요구 사항을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2e1923da3a35fe97453420dc041c5d1976347b78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OFF&lt;/code&gt; it will never be emitted</source>
          <target state="translated">&lt;code&gt;OFF&lt;/code&gt; 로 설정하면 방출되지 않습니다</target>
        </trans-unit>
        <trans-unit id="6e102b02dc555a53d99c0d8996a336936070f308" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;ON&lt;/code&gt; it will always be emitted</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 으로 설정 하면 항상 방출됩니다</target>
        </trans-unit>
        <trans-unit id="61c105cb51eaf644ff72e45505b80c22d0725e40" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;ONLY&lt;/code&gt;, then only the roots in &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-1-variable:CMAKE_FIND_ROOT_PATH&quot;&gt;&lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt;&lt;/a&gt; will be searched. If set to &lt;code&gt;NEVER&lt;/code&gt;, then the roots in &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-2-variable:CMAKE_FIND_ROOT_PATH&quot;&gt;&lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt;&lt;/a&gt; will be ignored and only the host system root will be used. If set to &lt;code&gt;BOTH&lt;/code&gt;, then the host system paths and the paths in &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-3-variable:CMAKE_FIND_ROOT_PATH&quot;&gt;&lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt;&lt;/a&gt; will be searched.</source>
          <target state="translated">&lt;code&gt;ONLY&lt;/code&gt; 로 설정하면 &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-1-variable:CMAKE_FIND_ROOT_PATH&quot;&gt; &lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt; &lt;/a&gt; 의 루트 만 검색됩니다. &lt;code&gt;NEVER&lt;/code&gt; 로 설정되면 &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-2-variable:CMAKE_FIND_ROOT_PATH&quot;&gt; &lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt; &lt;/a&gt; 의 루트는 무시되고 호스트 시스템 루트 만 사용됩니다. &lt;code&gt;BOTH&lt;/code&gt; 로 설정 되면 호스트 시스템 경로 및 &lt;a href=&quot;cmake_find_root_path#variable:CMAKE_FIND_ROOT_PATH&quot; id=&quot;index-3-variable:CMAKE_FIND_ROOT_PATH&quot;&gt; &lt;code&gt;CMAKE_FIND_ROOT_PATH&lt;/code&gt; &lt;/a&gt; 의 경로 가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1653dba7defc4aa4365dc4c6b95572e33dd7ac88" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;TRUE&lt;/code&gt;, contents of target property &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-0-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; will be forwarded to &lt;code&gt;SWIG&lt;/code&gt; compiler. If set to &lt;code&gt;FALSE&lt;/code&gt; target property &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; will be ignored. If not set, target property &lt;code&gt;SWIG_USE_TARGET_INCLUDE_DIRECTORIES&lt;/code&gt; will be considered.</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 설정되면 대상 특성 &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-0-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; 의&lt;/a&gt; 컨텐츠 가 &lt;code&gt;SWIG&lt;/code&gt; 컴파일러 로 전달됩니다 . &lt;code&gt;FALSE&lt;/code&gt; 로 설정하면 &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; 대상 속성 이 무시됩니다. 설정하지 않으면 대상 특성 &lt;code&gt;SWIG_USE_TARGET_INCLUDE_DIRECTORIES&lt;/code&gt; 가 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="b60b56bd68196a381f3866767bfd11bcbc287868" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;TRUE&lt;/code&gt;, contents of target property &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-3-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; will be forwarded to &lt;code&gt;SWIG&lt;/code&gt; compiler. If set to &lt;code&gt;FALSE&lt;/code&gt; or not defined, target property &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-4-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; will be ignored. This behavior can be overridden by specifying source property &lt;code&gt;USE_TARGET_INCLUDE_DIRECTORIES&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 설정되면 대상 특성 &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-3-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; 의&lt;/a&gt; 컨텐츠 가 &lt;code&gt;SWIG&lt;/code&gt; 컴파일러 로 전달됩니다 . &lt;code&gt;FALSE&lt;/code&gt; 로 설정 되거나 정의되지 않으면 대상 특성 &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-4-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; 가 무시됩니다. 소스 특성 &lt;code&gt;USE_TARGET_INCLUDE_DIRECTORIES&lt;/code&gt; 를 지정 하여이 작동을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a5754a3387ef38858ec8c6092013434463093ea" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;TRUE&lt;/code&gt;, values of variables prefixed with &lt;code&gt;CPACK_&lt;/code&gt; will be escaped before being written to the configuration files, so that the cpack program receives them exactly as they were specified. If not, characters like quotes and backslashes can cause parsing errors or alter the value received by the cpack program. Defaults to &lt;code&gt;FALSE&lt;/code&gt; for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 설정되면 &lt;code&gt;CPACK_&lt;/code&gt; 이 접두어로 변수의 값을 구성 파일에 기록하기 전에 이스케이프하므로 cpack 프로그램은 지정된대로 정확하게 수신합니다. 그렇지 않은 경우 따옴표 및 백 슬래시와 같은 문자로 인해 구문 분석 오류가 발생하거나 cpack 프로그램이 수신 한 값을 변경할 수 있습니다. 이전 버전과의 호환성을 위해 기본값은 &lt;code&gt;FALSE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75aff9a59610f6f48529b4715559de0f345225eb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;TRUE&lt;/code&gt;: Create CMake cache entries for the above artifact specification variables so that users can edit them interactively. This disables support for multiple version/component requirements.</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 설정된 경우 : 사용자가 대화 형으로 편집 할 수 있도록 위의 아티팩트 사양 변수에 대한 CMake 캐시 항목을 만듭니다. 이렇게하면 여러 버전 / 구성 요소 요구 사항에 대한 지원이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f53525f3d97ca399f00ebd0208aa03b3f0fc33eb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;True&lt;/code&gt;, the test will be skipped and its status will be &amp;lsquo;Not Run&amp;rsquo;. A &lt;code&gt;DISABLED&lt;/code&gt; test will not be counted in the total number of tests and its completion status will be reported to CDash as &lt;code&gt;Disabled&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정 하면 테스트를 건너 뛰고 상태는 'Not Run'이됩니다. &lt;code&gt;DISABLED&lt;/code&gt; 시험은 시험의 총 수에 계산되지 않습니다와 완료 상태로 CDash에보고됩니다 &lt;code&gt;Disabled&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd857f6dae53345c336a4b22238674cd1770ff33" translate="yes" xml:space="preserve">
          <source>If set to FALSE, search &lt;strong&gt;only&lt;/strong&gt; for shared libraries.</source>
          <target state="translated">FALSE로 설정하면 공유 라이브러리 &lt;strong&gt;만&lt;/strong&gt; 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6b905e6d62cbbc469cfc3f9d734dc04122ff5d3" translate="yes" xml:space="preserve">
          <source>If set to TRUE, search &lt;strong&gt;only&lt;/strong&gt; for static libraries.</source>
          <target state="translated">TRUE로 설정되면 정적 라이브러리 &lt;strong&gt;만&lt;/strong&gt; 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="656b07b5d0646a11f05f535fb9f6e26cc13e4ed5" translate="yes" xml:space="preserve">
          <source>If set to a list of arguments those will be added to the scheme.</source>
          <target state="translated">인수 목록으로 설정하면 해당 인수가 체계에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7e8a371bfae5e6ce9c30aee8a4ac4a49d1660765" translate="yes" xml:space="preserve">
          <source>If set to a list of environment variables and values of the form &lt;code&gt;MYVAR=value&lt;/code&gt; those environment variables will be added to the scheme.</source>
          <target state="translated">환경 변수 및 &lt;code&gt;MYVAR=value&lt;/code&gt; 형식의 값 목록으로 설정하면 해당 환경 변수가 체계에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7cc5d6e6ed2eb1934bf73f5562d4ae46549b95" translate="yes" xml:space="preserve">
          <source>If set to a list of environment variables and values of the form &lt;code&gt;MYVAR=value&lt;/code&gt; those environment variables will be defined while running the test. The environment is restored to its previous state after the test is done.</source>
          <target state="translated">환경 변수 및 &lt;code&gt;MYVAR=value&lt;/code&gt; 형식의 값 목록으로 설정된 경우 해당 환경 변수는 테스트를 실행하는 동안 정의됩니다. 테스트가 완료된 후 환경이 이전 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="3961c65e52c433ace06b0fc5f95f6e64e715ead6" translate="yes" xml:space="preserve">
          <source>If set to a list of files, the test will not be run unless all of the files exist.</source>
          <target state="translated">파일 목록으로 설정하면 모든 파일이 존재하지 않으면 테스트가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e324226d89ff39ffcb6cfaca900000fb561b143d" translate="yes" xml:space="preserve">
          <source>If set to a name then that name will be reported to &lt;code&gt;CDASH&lt;/code&gt; as a named measurement with a value of &lt;code&gt;1&lt;/code&gt;. You may also specify a value by setting &lt;code&gt;MEASUREMENT&lt;/code&gt; to &lt;code&gt;measurement=value&lt;/code&gt;.</source>
          <target state="translated">이름으로 설정된 경우 해당 이름은 &lt;code&gt;1&lt;/code&gt; 값을 가진 명명 된 측정 값으로 &lt;code&gt;CDASH&lt;/code&gt; 에보고 됩니다 . &lt;code&gt;MEASUREMENT&lt;/code&gt; 를 &lt;code&gt;measurement=value&lt;/code&gt; 로 설정하여 값을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="508483b7c2e7e2b9a8c20b7c6ce01623bb6b2036" translate="yes" xml:space="preserve">
          <source>If set to true then this is an object file.</source>
          <target state="translated">true로 설정하면 이것이 오브젝트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="68aeca830ab8d49e7291d649bb0708a8f7d0163e" translate="yes" xml:space="preserve">
          <source>If set to true, enables interprocedural optimizations if they are known &lt;a href=&quot;../module/checkiposupported#module:CheckIPOSupported&quot; id=&quot;index-0-module:CheckIPOSupported&quot;&gt;&lt;code&gt;to be supported&lt;/code&gt;&lt;/a&gt; by the compiler. Depending on value of policy &lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-0-policy:CMP0069&quot;&gt;&lt;code&gt;CMP0069&lt;/code&gt;&lt;/a&gt;, the error will be reported or ignored, if interprocedural optimization is enabled but not supported.</source>
          <target state="translated">true로 설정하면 프로 시저가 최적화를 컴파일러에서 &lt;a href=&quot;../module/checkiposupported#module:CheckIPOSupported&quot; id=&quot;index-0-module:CheckIPOSupported&quot;&gt; &lt;code&gt;to be supported&lt;/code&gt; &lt;/a&gt; 하는 경우 프로 시저 최적화를 사용합니다 . 정책 &lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-0-policy:CMP0069&quot;&gt; &lt;code&gt;CMP0069&lt;/code&gt; 의&lt;/a&gt; 값에 따라 프로 시저 간 최적화가 사용 가능하지만 지원되지 않는 경우 오류가보고되거나 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d8cd6cac7b512160799c8a74b37c0affe381073a" translate="yes" xml:space="preserve">
          <source>If set to true, enables interprocedural optimizations if they are known to be supported by the compiler.</source>
          <target state="translated">true로 설정하면 프로 시저가 최적화를 컴파일러에서 지원하는 경우 프로 시저 최적화를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bcd7b6cf97d8e2a0168a26ddd277cfbe0505f12b" translate="yes" xml:space="preserve">
          <source>If set to true, this will invert the pass/fail flag of the test.</source>
          <target state="translated">true로 설정하면 테스트의 합격 / 불합격 플래그가 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="e84408a2ba103ae2828cb3568033d31b2933c5a9" translate="yes" xml:space="preserve">
          <source>If set, CTest will update the repository&amp;rsquo;s submodules before updating.</source>
          <target state="translated">설정된 경우 CTest는 업데이트하기 전에 리포지토리의 하위 모듈을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e0d920612995f8a0b917b2c1a49b5b76f2e604d3" translate="yes" xml:space="preserve">
          <source>If set, checks only the specified vendor, if not set checks all the possibilities. List of vendors valid in this module:</source>
          <target state="translated">설정 한 경우 지정된 공급 업체 만 확인하고 설정하지 않은 경우 모든 가능성을 확인합니다. 이 모듈에 유효한 공급 업체 목록 :</target>
        </trans-unit>
        <trans-unit id="c823d9115e264ca718c48dba7c4d21c4a0dc6708" translate="yes" xml:space="preserve">
          <source>If set, if the output matches one of specified regular expressions, the test will be marked as skipped. Example:</source>
          <target state="translated">설정된 경우 출력이 지정된 정규식 중 하나와 일치하면 테스트가 건너 뛴 것으로 표시됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="eb25be356f11f13bd96a46fe54f2d93d67e8de75" translate="yes" xml:space="preserve">
          <source>If set, if the output matches one of specified regular expressions, the test will fail. Example:</source>
          <target state="translated">설정된 경우 출력이 지정된 정규식 중 하나와 일치하면 테스트가 실패합니다. 예:</target>
        </trans-unit>
        <trans-unit id="7d59224a9baba3d0037b4d9660d56273a7d1c4bb" translate="yes" xml:space="preserve">
          <source>If set, report any undefined properties to this file.</source>
          <target state="translated">설정된 경우 정의되지 않은 속성을이 파일에보고하십시오.</target>
        </trans-unit>
        <trans-unit id="dbb4e64ce44b0f96f9be8ff420869ebe5a6ea017" translate="yes" xml:space="preserve">
          <source>If set, specifies additional versions of Matlab that may be looked for. The variable should be a list of strings, organised by pairs of release name and versions, such as follows:</source>
          <target state="translated">설정된 경우 찾을 수있는 추가 버전의 Matlab을 지정합니다. 변수는 다음과 같이 릴리스 이름 및 버전 쌍으로 구성된 문자열 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c8997cdfecb1cfb937ac71bcd0e98ab20663b90" translate="yes" xml:space="preserve">
          <source>If set, the &lt;a href=&quot;#variable:CPACK_PROJECT_CONFIG_FILE&quot; id=&quot;index-3-variable:CPACK_PROJECT_CONFIG_FILE&quot;&gt;&lt;code&gt;CPACK_PROJECT_CONFIG_FILE&lt;/code&gt;&lt;/a&gt; is included automatically on a per-generator basis. It only need contain overrides.</source>
          <target state="translated">설정되면 &lt;a href=&quot;#variable:CPACK_PROJECT_CONFIG_FILE&quot; id=&quot;index-3-variable:CPACK_PROJECT_CONFIG_FILE&quot;&gt; &lt;code&gt;CPACK_PROJECT_CONFIG_FILE&lt;/code&gt; &lt;/a&gt; 이 생성자별로 자동으로 포함됩니다. 재정의 만 포함하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f926a3c63300107774698cdf1b2dd1ec46d7225" translate="yes" xml:space="preserve">
          <source>If set, the following variables are passed in to the generated try_compile CMakeLists.txt to initialize compile target properties with default values:</source>
          <target state="translated">설정된 경우 다음 변수가 생성 된 try_compile CMakeLists.txt에 전달되어 기본값으로 컴파일 대상 특성을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="8514d73d44c12bb07d874aaf69a90ad39d7031fe" translate="yes" xml:space="preserve">
          <source>If set, the lookup of Matlab and the intermediate configuration steps are outputted to the console.</source>
          <target state="translated">설정된 경우 Matlab 조회 및 중간 구성 단계가 콘솔에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b34bbfeba5b8d0aa737893e1f435919690da6666" translate="yes" xml:space="preserve">
          <source>If set, the test output will be checked against the specified regular expressions and at least one of the regular expressions has to match, otherwise the test will fail. Example:</source>
          <target state="translated">설정하면 테스트 결과가 지정된 정규식에 대해 검사되고 하나 이상의 정규식이 일치해야합니다. 그렇지 않으면 테스트가 실패합니다. 예:</target>
        </trans-unit>
        <trans-unit id="83f095438a33c2e4139501c17adbaa860231f094" translate="yes" xml:space="preserve">
          <source>If set, this causes the output from the custom step to be captured to files in the external project&amp;rsquo;s &lt;code&gt;LOG_DIR&lt;/code&gt; if supplied or &lt;code&gt;STAMP_DIR&lt;/code&gt;.</source>
          <target state="translated">설정되면, 사용자 정의 단계의 출력이 외부 프로젝트의 &lt;code&gt;LOG_DIR&lt;/code&gt; 또는 제공된 경우 &lt;code&gt;STAMP_DIR&lt;/code&gt; 의 파일로 캡처됩니다 .</target>
        </trans-unit>
        <trans-unit id="82972795f71affe19082f745d349524d05f1d948" translate="yes" xml:space="preserve">
          <source>If set, this property completely overrides the generic property for the named configuration.</source>
          <target state="translated">설정된 경우이 특성은 이름 지정된 구성의 일반 특성을 완전히 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2ef098119209ba85d386a15248da3719b9f2f55c" translate="yes" xml:space="preserve">
          <source>If set, this will tell the required compilers to enable device linking on the library target. Device linking is an additional link step required by some CUDA compilers when &lt;a href=&quot;cuda_separable_compilation#prop_tgt:CUDA_SEPARABLE_COMPILATION&quot; id=&quot;index-0-prop_tgt:CUDA_SEPARABLE_COMPILATION&quot;&gt;&lt;code&gt;CUDA_SEPARABLE_COMPILATION&lt;/code&gt;&lt;/a&gt; is enabled. Normally device linking is deferred until a shared library or executable is generated, allowing for multiple static libraries to resolve device symbols at the same time when they are used by a shared library or executable.</source>
          <target state="translated">설정되면 필요한 컴파일러에게 라이브러리 대상에서 장치 링크를 활성화하도록 지시합니다. 장치 연결은 &lt;a href=&quot;cuda_separable_compilation#prop_tgt:CUDA_SEPARABLE_COMPILATION&quot; id=&quot;index-0-prop_tgt:CUDA_SEPARABLE_COMPILATION&quot;&gt; &lt;code&gt;CUDA_SEPARABLE_COMPILATION&lt;/code&gt; &lt;/a&gt; 이 활성화 된 경우 일부 CUDA 컴파일러에 필요한 추가 연결 단계 입니다. 일반적으로 장치 연결은 공유 라이브러리 또는 실행 파일이 생성 될 때까지 연기되므로 여러 정적 라이브러리가 공유 라이브러리 또는 실행 파일에서 사용될 때 동시에 장치 심볼을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0482866b4dde63796f7920f8866b1ca2d2719b60" translate="yes" xml:space="preserve">
          <source>If specified, configuration will error if a suitable CUDA Toolkit is not found.</source>
          <target state="translated">지정된 경우 적합한 CUDA 툴킷을 찾을 수없는 경우 구성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74fe61013fc0da2e7e13f2aea36a950a0abe8db1" translate="yes" xml:space="preserve">
          <source>If specified, describes the version of the CUDA Toolkit to search for.</source>
          <target state="translated">지정된 경우 검색 할 CUDA 툴킷의 버전을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="64c88640f9f8518c9809a5716a9881041a27466c" translate="yes" xml:space="preserve">
          <source>If specified, the CUDA Toolkit is considered found only if the exact &lt;code&gt;VERSION&lt;/code&gt; specified is recovered.</source>
          <target state="translated">지정된 경우 CUDA Toolkit은 지정된 정확한 &lt;code&gt;VERSION&lt;/code&gt; 이 복구 된 경우에만 찾은 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="228e18132f5561d618b3af8d81d58a42a727bf08" translate="yes" xml:space="preserve">
          <source>If specified, the parameter is passed along with &lt;code&gt;--gtest_output=xml:&lt;/code&gt; to test executable. The actual file name is the same as the test target, including prefix and suffix. This should be used instead of &lt;code&gt;EXTRA_ARGS --gtest_output=xml&lt;/code&gt; to avoid race conditions writing the XML result output when using parallel test execution.</source>
          <target state="translated">지정된 경우 매개 변수는 &lt;code&gt;--gtest_output=xml:&lt;/code&gt; 과 함께 전달되어 실행 파일을 테스트합니다. 실제 파일 이름은 접두사와 접미사를 포함하여 테스트 대상과 동일합니다. 병렬 테스트 실행을 사용할 때 경쟁 조건이 XML 결과 출력을 작성하지 않도록하려면 &lt;code&gt;EXTRA_ARGS --gtest_output=xml&lt;/code&gt; 대신 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c8d14636863c3dec3c5b856df68f15342cb2920" translate="yes" xml:space="preserve">
          <source>If specified, the search for a suitable CUDA Toolkit will not produce any messages.</source>
          <target state="translated">지정된 경우 적합한 CUDA 툴킷을 검색해도 메시지가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c7930d04d2f2d1434014d736aa507b2744a7261" translate="yes" xml:space="preserve">
          <source>If such a library target has this property set to &lt;code&gt;TRUE&lt;/code&gt; it will be built as a framework when built on the macOS and iOS. It will have the directory structure required for a framework and will be suitable to be used with the &lt;code&gt;-framework&lt;/code&gt; option. This property is initialized by the value of the &lt;a href=&quot;../variable/cmake_framework#variable:CMAKE_FRAMEWORK&quot; id=&quot;index-0-variable:CMAKE_FRAMEWORK&quot;&gt;&lt;code&gt;CMAKE_FRAMEWORK&lt;/code&gt;&lt;/a&gt; variable if it is set when a target is created.</source>
          <target state="translated">이러한 라이브러리 대상이이 특성을 &lt;code&gt;TRUE&lt;/code&gt; 로 설정 하면 macOS 및 iOS에서 빌드 될 때 프레임 워크로 빌드됩니다. 프레임 워크에 필요한 디렉토리 구조를 &lt;code&gt;-framework&lt;/code&gt; 옵션 과 함께 사용하기에 적합합니다 . 이 특성은 대상을 작성할 때 설정된 경우 &lt;a href=&quot;../variable/cmake_framework#variable:CMAKE_FRAMEWORK&quot; id=&quot;index-0-variable:CMAKE_FRAMEWORK&quot;&gt; &lt;code&gt;CMAKE_FRAMEWORK&lt;/code&gt; &lt;/a&gt; 변수 의 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="af731b6633381becd0cd3ada4b497552d16c5823" translate="yes" xml:space="preserve">
          <source>If that property is not set then CMake uses an appropriate default value based on the compiler to select the CUDA runtime library.</source>
          <target state="translated">해당 속성이 설정되지 않은 경우 CMake는 컴파일러에 따라 적절한 기본값을 사용하여 CUDA 런타임 라이브러리를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="106e236f57f265f5539272df6448eb4f55c60bc0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../prop_gbl/find_library_use_lib32_paths#prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIB32_PATHS&lt;/code&gt;&lt;/a&gt; global property is set all search paths will be tested as normal, with &lt;code&gt;32/&lt;/code&gt; appended, and with all matches of &lt;code&gt;lib/&lt;/code&gt; replaced with &lt;code&gt;lib32/&lt;/code&gt;. This property is automatically set for the platforms that are known to need it if at least one of the languages supported by the &lt;a href=&quot;project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;../prop_gbl/find_library_use_lib32_paths#prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIB32_PATHS&lt;/code&gt; &lt;/a&gt; 전역 속성이 설정되어 모든 검색 경로로, 정상적으로 테스트됩니다 &lt;code&gt;32/&lt;/code&gt; 추가, 그리고 모든 일치와 &lt;code&gt;lib/&lt;/code&gt; 로 대체 &lt;code&gt;lib32/&lt;/code&gt; . 이 특성은 &lt;a href=&quot;project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령이 지원하는 언어 중 하나 이상 이 사용 가능한 경우 필요한 것으로 알려진 플랫폼에 대해 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="692c2434840c30f4c658bd7821648965c03938b7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../prop_gbl/find_library_use_lib64_paths#prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIB64_PATHS&lt;/code&gt;&lt;/a&gt; global property is set all search paths will be tested as normal, with &lt;code&gt;64/&lt;/code&gt; appended, and with all matches of &lt;code&gt;lib/&lt;/code&gt; replaced with &lt;code&gt;lib64/&lt;/code&gt;. This property is automatically set for the platforms that are known to need it if at least one of the languages supported by the &lt;a href=&quot;project#command:project&quot; id=&quot;index-2-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;../prop_gbl/find_library_use_lib64_paths#prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIB64_PATHS&lt;/code&gt; &lt;/a&gt; 전역 속성이 설정되어 모든 검색 경로로, 정상적으로 테스트됩니다 &lt;code&gt;64/&lt;/code&gt; 추가, 그리고 모든 일치와 &lt;code&gt;lib/&lt;/code&gt; 로 대체 &lt;code&gt;lib64/&lt;/code&gt; . 이 특성은 &lt;a href=&quot;project#command:project&quot; id=&quot;index-2-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령이 지원하는 언어 중 하나 이상 이 사용 가능한 경우 필요한 것으로 알려진 플랫폼에 대해 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dc246617e7d654446957c593c9948b9f9c9cd81" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../prop_gbl/find_library_use_libx32_paths#prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIBX32_PATHS&lt;/code&gt;&lt;/a&gt; global property is set all search paths will be tested as normal, with &lt;code&gt;x32/&lt;/code&gt; appended, and with all matches of &lt;code&gt;lib/&lt;/code&gt; replaced with &lt;code&gt;libx32/&lt;/code&gt;. This property is automatically set for the platforms that are known to need it if at least one of the languages supported by the &lt;a href=&quot;project#command:project&quot; id=&quot;index-1-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;../prop_gbl/find_library_use_libx32_paths#prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot; id=&quot;index-1-prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIBX32_PATHS&lt;/code&gt; &lt;/a&gt; 전역 속성이 설정되어 모든 검색 경로로, 정상적으로 테스트됩니다 &lt;code&gt;x32/&lt;/code&gt; , 그리고 모든 경기가 추가 &lt;code&gt;lib/&lt;/code&gt; 로 대체 &lt;code&gt;libx32/&lt;/code&gt; . 이 특성은 &lt;a href=&quot;project#command:project&quot; id=&quot;index-1-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령이 지원하는 언어 중 하나 이상 이 사용 가능한 경우 필요한 것으로 알려진 플랫폼에 대해 자동으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd8533fbd3ebe00344ed769b81a2c1910a022ef7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../prop_gbl/job_pools#prop_gbl:JOB_POOLS&quot; id=&quot;index-0-prop_gbl:JOB_POOLS&quot;&gt;&lt;code&gt;JOB_POOLS&lt;/code&gt;&lt;/a&gt; global property is not set, the value of this variable is used in its place. See &lt;a href=&quot;../prop_gbl/job_pools#prop_gbl:JOB_POOLS&quot; id=&quot;index-1-prop_gbl:JOB_POOLS&quot;&gt;&lt;code&gt;JOB_POOLS&lt;/code&gt;&lt;/a&gt; for additional information.</source>
          <target state="translated">는 IF &lt;a href=&quot;../prop_gbl/job_pools#prop_gbl:JOB_POOLS&quot; id=&quot;index-0-prop_gbl:JOB_POOLS&quot;&gt; &lt;code&gt;JOB_POOLS&lt;/code&gt; &lt;/a&gt; 전역 속성이 설정되지 않은,이 변수의 값은 그 자리에 사용됩니다. 추가 정보는 &lt;a href=&quot;../prop_gbl/job_pools#prop_gbl:JOB_POOLS&quot; id=&quot;index-1-prop_gbl:JOB_POOLS&quot;&gt; &lt;code&gt;JOB_POOLS&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86b775c85f5a15ecdb40ed2fd1db7aa137ad4543" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../prop_tgt/exclude_from_all#prop_tgt:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_tgt:EXCLUDE_FROM_ALL&quot;&gt;&lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt;&lt;/a&gt; target property is set on a target then its value determines whether the target is included in the &amp;ldquo;all&amp;rdquo; target of this directory and its ancestors.</source>
          <target state="translated">는 IF &lt;a href=&quot;../prop_tgt/exclude_from_all#prop_tgt:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_tgt:EXCLUDE_FROM_ALL&quot;&gt; &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; 의&lt;/a&gt; 대상 속성이 대상에 설정되어 그 값이 대상이 디렉토리와 그 조상의 &quot;모든&quot;대상에 포함되는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2e08d12fdd805bd7f16723cabb549085f5855840" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_android_api#variable:CMAKE_ANDROID_API&quot; id=&quot;index-0-variable:CMAKE_ANDROID_API&quot;&gt;&lt;code&gt;CMAKE_ANDROID_API&lt;/code&gt;&lt;/a&gt; variable is set, its value is used as the API level.</source>
          <target state="translated">는 IF &lt;a href=&quot;../variable/cmake_android_api#variable:CMAKE_ANDROID_API&quot; id=&quot;index-0-variable:CMAKE_ANDROID_API&quot;&gt; &lt;code&gt;CMAKE_ANDROID_API&lt;/code&gt; 의&lt;/a&gt; 변수가 설정되고, 그 값은 API의 레벨로도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b4a6212c1587b4bffde0ab6297f7a42e07e368c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_android_ndk#variable:CMAKE_ANDROID_NDK&quot; id=&quot;index-0-variable:CMAKE_ANDROID_NDK&quot;&gt;&lt;code&gt;CMAKE_ANDROID_NDK&lt;/code&gt;&lt;/a&gt; variable is set, the NDK at the specified location will be used.</source>
          <target state="translated">경우] &lt;a href=&quot;../variable/cmake_android_ndk#variable:CMAKE_ANDROID_NDK&quot; id=&quot;index-0-variable:CMAKE_ANDROID_NDK&quot;&gt; &lt;code&gt;CMAKE_ANDROID_NDK&lt;/code&gt; 의&lt;/a&gt; 변수가 설정되면, 지정된 위치에 NDK 사용한다.</target>
        </trans-unit>
        <trans-unit id="c5f96a2f65a671e007aa0f113bbcb2405e581932" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_find_library_custom_lib_suffix#variable:CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&quot; id=&quot;index-0-variable:CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&quot;&gt;&lt;code&gt;CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&lt;/code&gt;&lt;/a&gt; variable is set all search paths will be tested as normal, with the suffix appended, and with all matches of &lt;code&gt;lib/&lt;/code&gt; replaced with &lt;code&gt;lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/&lt;/code&gt;. This variable overrides the &lt;a href=&quot;../prop_gbl/find_library_use_lib32_paths#prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIB32_PATHS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../prop_gbl/find_library_use_libx32_paths#prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIBX32_PATHS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../prop_gbl/find_library_use_lib64_paths#prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot;&gt;&lt;code&gt;FIND_LIBRARY_USE_LIB64_PATHS&lt;/code&gt;&lt;/a&gt; global properties.</source>
          <target state="translated">는 IF &lt;a href=&quot;../variable/cmake_find_library_custom_lib_suffix#variable:CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&quot; id=&quot;index-0-variable:CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&quot;&gt; &lt;code&gt;CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX&lt;/code&gt; 의&lt;/a&gt; 변수가 설정되어 모든 검색 경로는 접미사가 추가로 정상적으로 시험, 그리고 모든 경기와됩니다 &lt;code&gt;lib/&lt;/code&gt; 로 대체 &lt;code&gt;lib${CMAKE_FIND_LIBRARY_CUSTOM_LIB_SUFFIX}/&lt;/code&gt; . 이 변수는 &lt;a href=&quot;../prop_gbl/find_library_use_lib32_paths#prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIB32_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIB32_PATHS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../prop_gbl/find_library_use_libx32_paths#prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIBX32_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIBX32_PATHS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../prop_gbl/find_library_use_lib64_paths#prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot; id=&quot;index-0-prop_gbl:FIND_LIBRARY_USE_LIB64_PATHS&quot;&gt; &lt;code&gt;FIND_LIBRARY_USE_LIB64_PATHS&lt;/code&gt; &lt;/a&gt; 글로벌 특성을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="a6a9453c4ba32452c7432ac067eb4ce832621a60" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_project_include#variable:CMAKE_PROJECT_INCLUDE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE&quot;&gt;&lt;code&gt;CMAKE_PROJECT_INCLUDE&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE&lt;/code&gt; variables are set, the files they point to will be included as the last step of the &lt;code&gt;project()&lt;/code&gt; command. If both are set, then &lt;a href=&quot;../variable/cmake_project_include#variable:CMAKE_PROJECT_INCLUDE&quot; id=&quot;index-1-variable:CMAKE_PROJECT_INCLUDE&quot;&gt;&lt;code&gt;CMAKE_PROJECT_INCLUDE&lt;/code&gt;&lt;/a&gt; will be included before &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;../variable/cmake_project_include#variable:CMAKE_PROJECT_INCLUDE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE&quot;&gt; &lt;code&gt;CMAKE_PROJECT_INCLUDE&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE&lt;/code&gt; 변수가 설정되어, 그들이 가리키는 파일의 마지막 단계로 포함됩니다하는 &lt;code&gt;project()&lt;/code&gt; 명령. 모두가 설정되어있는 경우, 다음 &lt;a href=&quot;../variable/cmake_project_include#variable:CMAKE_PROJECT_INCLUDE&quot; id=&quot;index-1-variable:CMAKE_PROJECT_INCLUDE&quot;&gt; &lt;code&gt;CMAKE_PROJECT_INCLUDE&lt;/code&gt; 는&lt;/a&gt; 전에 포함됩니다 &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7061488d89587435e02b5a9e73825410ac8a5d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt;&lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE_BEFORE&lt;/code&gt; variables are set, the files they point to will be included as the first step of the &lt;code&gt;project()&lt;/code&gt; command. If both are set, then &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-1-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt;&lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt;&lt;/a&gt; will be included before &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE_BEFORE&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt; &lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE_BEFORE&lt;/code&gt; 변수가 설정되며, 이들이 가리키는 파일의 첫 번째 단계로서 포함된다하는 &lt;code&gt;project()&lt;/code&gt; 명령. 둘 다 설정하면 &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-1-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt; &lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;CMAKE_PROJECT_&amp;lt;PROJECT-NAME&amp;gt;_INCLUDE_BEFORE&lt;/code&gt; 앞에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b42833e1521cd3e5a61b28079b80e0bafe9479d7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt;&lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt;&lt;/a&gt; variable is set, the file pointed to by that variable will be included as the first step of the &lt;code&gt;project()&lt;/code&gt; command.</source>
          <target state="translated">는 IF &lt;a href=&quot;../variable/cmake_project_include_before#variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot; id=&quot;index-0-variable:CMAKE_PROJECT_INCLUDE_BEFORE&quot;&gt; &lt;code&gt;CMAKE_PROJECT_INCLUDE_BEFORE&lt;/code&gt; 의&lt;/a&gt; 변수가 설정 파일은 변수의 첫 번째 단계로 포함됩니다 가리키는 &lt;code&gt;project()&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="ea6cb4551f7806bb14f1e3366adb4ac5d36795e5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/cmake_sysroot#variable:CMAKE_SYSROOT&quot; id=&quot;index-3-variable:CMAKE_SYSROOT&quot;&gt;&lt;code&gt;CMAKE_SYSROOT&lt;/code&gt;&lt;/a&gt; variable is set, the API level is detected from the NDK directory structure containing the sysroot.</source>
          <target state="translated">경우] &lt;a href=&quot;../variable/cmake_sysroot#variable:CMAKE_SYSROOT&quot; id=&quot;index-3-variable:CMAKE_SYSROOT&quot;&gt; &lt;code&gt;CMAKE_SYSROOT&lt;/code&gt; 의&lt;/a&gt; 변수가 설정되면, API 레벨은 SYSROOT 함유 NDK 디렉토리 구조에서 검출된다.</target>
        </trans-unit>
        <trans-unit id="0841bf5b3d471d7eafec2418f248759990deb068" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../variable/ctest_checkout_command#variable:CTEST_CHECKOUT_COMMAND&quot; id=&quot;index-0-variable:CTEST_CHECKOUT_COMMAND&quot;&gt;&lt;code&gt;CTEST_CHECKOUT_COMMAND&lt;/code&gt;&lt;/a&gt; variable (or the &lt;a href=&quot;../variable/ctest_cvs_checkout#variable:CTEST_CVS_CHECKOUT&quot; id=&quot;index-0-variable:CTEST_CVS_CHECKOUT&quot;&gt;&lt;code&gt;CTEST_CVS_CHECKOUT&lt;/code&gt;&lt;/a&gt; variable) is set, its content is treated as command-line. The command is invoked with the current working directory set to the parent of the source directory, even if the source directory already exists. This can be used to create the source tree from a version control repository.</source>
          <target state="translated">경우] &lt;a href=&quot;../variable/ctest_checkout_command#variable:CTEST_CHECKOUT_COMMAND&quot; id=&quot;index-0-variable:CTEST_CHECKOUT_COMMAND&quot;&gt; &lt;code&gt;CTEST_CHECKOUT_COMMAND&lt;/code&gt; 의&lt;/a&gt; 변수 (또는 &lt;a href=&quot;../variable/ctest_cvs_checkout#variable:CTEST_CVS_CHECKOUT&quot; id=&quot;index-0-variable:CTEST_CVS_CHECKOUT&quot;&gt; &lt;code&gt;CTEST_CVS_CHECKOUT&lt;/code&gt; 의&lt;/a&gt; 변수)를 설정하고, 그 내용은 명령 라인으로 간주된다. 소스 디렉토리가 이미 존재하더라도 현재 작업 디렉토리를 소스 디렉토리의 상위로 설정하여 명령을 호출합니다. 버전 관리 저장소에서 소스 트리를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026ae09c815c0d6fc4b6a3e1c275b8677f7fb941" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; compiler passes to the linker an architecture-specific system library search directory such as &lt;code&gt;&amp;lt;prefix&amp;gt;/lib/&amp;lt;arch&amp;gt;&lt;/code&gt; this variable contains the &lt;code&gt;&amp;lt;arch&amp;gt;&lt;/code&gt; name if/as detected by CMake.</source>
          <target state="translated">는 IF &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; 와 같은 컴파일러는 링커에 아키텍처 특정 시스템 라이브러리 검색 디렉토리를 전달 &lt;code&gt;&amp;lt;prefix&amp;gt;/lib/&amp;lt;arch&amp;gt;&lt;/code&gt; 이 변수가 포함 &lt;code&gt;&amp;lt;arch&amp;gt;&lt;/code&gt; CMake에서 감지 경우 / 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c8b6ca35e4389840705d7748f801abbb707b3dc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; could be built and run successfully, the internal cache variable specified by &lt;code&gt;&amp;lt;resultVar&amp;gt;&lt;/code&gt; will be set to 1, otherwise it will be set to an value that evaluates to boolean false (e.g. an empty string or an error message).</source>
          <target state="translated">는 IF &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 구축하고 성공적으로 실행 될 수있는 내부 캐시 변수에 의해 지정된 &lt;code&gt;&amp;lt;resultVar&amp;gt;&lt;/code&gt; 1로 설정되고, 그렇지 않은 경우가 값으로 설정됩니다 부울 false로 평가 (예 : 빈 문자열 또는 오류 메시지) .</target>
        </trans-unit>
        <trans-unit id="abde6e0d8ce027f57124ce88144da68238b6e41b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&amp;lt;ui_base&amp;gt;.ui&lt;/code&gt; file was found, &lt;code&gt;uic&lt;/code&gt; is called on it to generate &lt;code&gt;ui_&amp;lt;ui_base&amp;gt;.h&lt;/code&gt; in the directory</source>
          <target state="translated">만약 &lt;code&gt;&amp;lt;ui_base&amp;gt;.ui&lt;/code&gt; 파일이 발견, &lt;code&gt;uic&lt;/code&gt; 생성 할 불려 &lt;code&gt;ui_&amp;lt;ui_base&amp;gt;.h&lt;/code&gt; 디렉토리에</target>
        </trans-unit>
        <trans-unit id="0d62d6213c4bb8bc375810a215fedc2d3fffcb40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:&amp;lt;type&amp;gt;&lt;/code&gt; portion is given it must be one of the types specified by the &lt;a href=&quot;../command/set#command:set&quot; id=&quot;index-1-command:set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; command documentation for its &lt;code&gt;CACHE&lt;/code&gt; signature. If the &lt;code&gt;:&amp;lt;type&amp;gt;&lt;/code&gt; portion is omitted the entry will be created with no type if it does not exist with a type already. If a command in the project sets the type to &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;FILEPATH&lt;/code&gt; then the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; will be converted to an absolute path.</source>
          <target state="translated">&lt;code&gt;:&amp;lt;type&amp;gt;&lt;/code&gt; 부분이 제공 되면 해당 부분은 &lt;code&gt;CACHE&lt;/code&gt; 서명에 대해 &lt;a href=&quot;../command/set#command:set&quot; id=&quot;index-1-command:set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 명령 문서에 지정된 유형 중 하나 여야합니다 . 경우] &lt;code&gt;:&amp;lt;type&amp;gt;&lt;/code&gt; 부분은 생략 이미 형태로 존재하지 않는 경우의 항목 유형을 더 생성한다. 프로젝트의 명령이 유형을 &lt;code&gt;PATH&lt;/code&gt; 또는 &lt;code&gt;FILEPATH&lt;/code&gt; 로 설정하면 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 가 절대 경로로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="18e502ccb5dd261d96c313b282aef2959856381e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;APPEND&lt;/code&gt; option is given the list is appended to any existing property value (except that empty values are ignored and not appended). If the &lt;code&gt;APPEND_STRING&lt;/code&gt; option is given the string is appended to any existing property value as string, i.e. it results in a longer string and not a list of strings. When using &lt;code&gt;APPEND&lt;/code&gt; or &lt;code&gt;APPEND_STRING&lt;/code&gt; with a property defined to support &lt;code&gt;INHERITED&lt;/code&gt; behavior (see &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt;&lt;code&gt;define_property()&lt;/code&gt;&lt;/a&gt;), no inheriting occurs when finding the initial value to append to. If the property is not already directly set in the nominated scope, the command will behave as though &lt;code&gt;APPEND&lt;/code&gt; or &lt;code&gt;APPEND_STRING&lt;/code&gt; had not been given.</source>
          <target state="translated">경우 &lt;code&gt;APPEND&lt;/code&gt; 의 옵션 (즉, 빈 값이 무시됩니다 제외하고는 추가되지 않습니다)리스트는 기존 속성 값에 추가됩니다 주어집니다. 는 IF &lt;code&gt;APPEND_STRING&lt;/code&gt; 의 옵션 문자열이 문자열로 기존 속성 값에 추가됩니다 주어,이 문자열 목록을 더 긴 문자열을 초래하지 즉. 사용하는 경우 &lt;code&gt;APPEND&lt;/code&gt; 또는 &lt;code&gt;APPEND_STRING&lt;/code&gt; 을 지원하기 위해 정의 된 속성을 &lt;code&gt;INHERITED&lt;/code&gt; 동작을 (참조 &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt; &lt;code&gt;define_property()&lt;/code&gt; &lt;/a&gt; 에 추가 할 초기 값을 찾을 때)에는 상속이 발생하지 않습니다. 지정된 범위에서 속성이 아직 직접 설정되지 않은 경우 명령은 &lt;code&gt;APPEND&lt;/code&gt; 또는 &lt;code&gt;APPEND_STRING&lt;/code&gt; 이 제공되지 않은 것처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="92cb4c2b601264f6395c5e6f098dd57e6b88121f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;APPEND&lt;/code&gt; option is given the list is appended to any existing property value. If the &lt;code&gt;APPEND_STRING&lt;/code&gt; option is given the string is appended to any existing property value as string, i.e. it results in a longer string and not a list of strings. When using &lt;code&gt;APPEND&lt;/code&gt; or &lt;code&gt;APPEND_STRING&lt;/code&gt; with a property defined to support &lt;code&gt;INHERITED&lt;/code&gt; behavior (see &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt;&lt;code&gt;define_property()&lt;/code&gt;&lt;/a&gt;), no inheriting occurs when finding the initial value to append to. If the property is not already directly set in the nominated scope, the command will behave as though &lt;code&gt;APPEND&lt;/code&gt; or &lt;code&gt;APPEND_STRING&lt;/code&gt; had not been given.</source>
          <target state="translated">경우 &lt;code&gt;APPEND&lt;/code&gt; 의 옵션이 주어리스트는 기존 속성 값에 추가됩니다. 는 IF &lt;code&gt;APPEND_STRING&lt;/code&gt; 의 옵션 문자열이 문자열로 기존 속성 값에 추가됩니다 주어,이 문자열 목록을 더 긴 문자열을 초래하지 즉. 사용하는 경우 &lt;code&gt;APPEND&lt;/code&gt; 또는 &lt;code&gt;APPEND_STRING&lt;/code&gt; 을 지원하기 위해 정의 된 속성을 &lt;code&gt;INHERITED&lt;/code&gt; 동작을 (참조 &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt; &lt;code&gt;define_property()&lt;/code&gt; &lt;/a&gt; 에 추가 할 초기 값을 찾을 때)에는 상속이 발생하지 않습니다. 속성이 지정된 범위에서 직접 설정되지 않은 경우 명령은 &lt;code&gt;APPEND&lt;/code&gt; 또는 &lt;code&gt;APPEND_STRING&lt;/code&gt; 이 제공되지 않은 것처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="b3c6d194e6610169dd91e505c431088309c1dff5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BUILTIN_TYPES_ONLY&lt;/code&gt; option is not given, the macro checks for headers &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;, and saves results in &lt;code&gt;HAVE_SYS_TYPES_H&lt;/code&gt;, &lt;code&gt;HAVE_STDINT_H&lt;/code&gt;, and &lt;code&gt;HAVE_STDDEF_H&lt;/code&gt;. The type size check automatically includes the available headers, thus supporting checks of types defined in the headers.</source>
          <target state="translated">는 IF &lt;code&gt;BUILTIN_TYPES_ONLY&lt;/code&gt; 의 옵션이 주어지지, 헤더에 대한 매크로 검사 &lt;code&gt;&amp;lt;sys/types.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; , 및 결과 저장 &lt;code&gt;HAVE_SYS_TYPES_H&lt;/code&gt; , &lt;code&gt;HAVE_STDINT_H&lt;/code&gt; 및 &lt;code&gt;HAVE_STDDEF_H&lt;/code&gt; 을 . 유형 크기 확인에는 사용 가능한 헤더가 자동으로 포함되므로 헤더에 정의 된 유형 확인이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="87001704a9c9f037372706a35804a957f0758614" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BU_CHMOD_BUNDLE_ITEMS&lt;/code&gt; variable is set then bundle items will be marked writable before &lt;code&gt;install_name_tool&lt;/code&gt; tries to change them.</source>
          <target state="translated">는 IF &lt;code&gt;BU_CHMOD_BUNDLE_ITEMS&lt;/code&gt; 의 변수가 설정되기 전에 번들 항목은 쓰기를 표시됩니다 &lt;code&gt;install_name_tool&lt;/code&gt; 의 시도가이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d436e35f4ed44e40987df48abb9ca1805145da65" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CONFIGURE_DEPENDS&lt;/code&gt; flag is specified, CMake will add logic to the main build system check target to rerun the flagged &lt;code&gt;GLOB&lt;/code&gt; commands at build time. If any of the outputs change, CMake will regenerate the build system.</source>
          <target state="translated">는 IF &lt;code&gt;CONFIGURE_DEPENDS&lt;/code&gt; 의 플래그가 지정되고, CMake는 플래그가 다시 실행의 주요 빌드 시스템 검사 대상에 로직을 추가합니다 &lt;code&gt;GLOB&lt;/code&gt; 의 빌드 시간에 명령을. 출력이 변경되면 CMake는 빌드 시스템을 재생성합니다.</target>
        </trans-unit>
        <trans-unit id="18451159d1b05ae5672e6e9aa3419b2ef580a3b1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CUDA&lt;/code&gt; language has been enabled we will use the directory containing the compiler as the first search location for &lt;code&gt;nvcc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;CUDA&lt;/code&gt; 의 언어가 활성화 된 우리의 첫 번째 검색 위치로 컴파일러가 포함 된 디렉토리 사용 &lt;code&gt;nvcc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17efef13905605a50a8bcb93c18a3796d38051e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CUDAToolkit_ROOT&lt;/code&gt; cmake configuration variable (e.g., &lt;code&gt;-DCUDAToolkit_ROOT=/some/path&lt;/code&gt;) &lt;em&gt;or&lt;/em&gt; environment variable is defined, it will be searched. If both an environment variable &lt;strong&gt;and&lt;/strong&gt; a configuration variable are specified, the &lt;em&gt;configuration&lt;/em&gt; variable takes precedence.</source>
          <target state="translated">경우] &lt;code&gt;CUDAToolkit_ROOT&lt;/code&gt; 의 cmake 설정 변수 (예 &lt;code&gt;-DCUDAToolkit_ROOT=/some/path&lt;/code&gt; ) &lt;em&gt;또는&lt;/em&gt; 환경 변수를 정의하고,이를 검색한다. 환경 변수 &lt;strong&gt;와&lt;/strong&gt; 구성 변수를 모두 지정하면 &lt;em&gt;구성&lt;/em&gt; 변수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="aae98b828c863d9f6a4ab587f76831d3b091e9b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Config.cmake&lt;/code&gt; file is found and the optionally-specified version is satisfied, then the CMake &lt;a href=&quot;../../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; command considers the package to be found and the entire library package is assumed to be complete as designed.</source>
          <target state="translated">는 IF &lt;code&gt;Config.cmake&lt;/code&gt; 의 파일이 발견되고, 선택적으로 지정된 버전이 만족, 다음 CMake의 &lt;a href=&quot;../../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 패키지를 찾을 수 간주하고 전체 라이브러리 패키지 설계로 완전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="627cf4bf20c57c39f86cc6bf24d6cbbb67544070" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; argument is provided then targets in the subdirectory will not be included in the &lt;code&gt;ALL&lt;/code&gt; target of the parent directory by default, and will be excluded from IDE project files. Users must explicitly build targets in the subdirectory. This is meant for use when the subdirectory contains a separate part of the project that is useful but not necessary, such as a set of examples. Typically the subdirectory should contain its own &lt;a href=&quot;project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command invocation so that a full build system will be generated in the subdirectory (such as a VS IDE solution file). Note that inter-target dependencies supersede this exclusion. If a target built by the parent project depends on a target in the subdirectory, the dependee target will be included in the parent project build system to satisfy the dependency.</source>
          <target state="translated">는 IF &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; 의 인수 후 제공되는 서브 디렉토리의 목표는에 포함되지 않습니다 &lt;code&gt;ALL&lt;/code&gt; 에 기본적으로 상위 디렉토리의 대상 및 IDE 프로젝트 파일에서 제외됩니다. 사용자는 서브 디렉토리에 명시 적으로 대상을 빌드해야합니다. 이는 서브 디렉토리에 예제 세트와 같이 유용하지만 필요하지 않은 별도의 프로젝트 부분이 포함 된 경우에 사용됩니다. 일반적으로 서브 디렉토리는 자체 &lt;a href=&quot;project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 포함해야합니다.전체 빌드 시스템이 서브 디렉토리 (예 : VS IDE 솔루션 파일)에 생성되도록 명령 호출. 대상 간 종속성이이 제외를 대체합니다. 상위 프로젝트가 빌드 한 대상이 서브 디렉토리의 대상에 종속되는 경우 종속 대상을 상위 프로젝트 빌드 시스템에 포함시켜 종속성을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="612dfc91330eed12cf8e9c8d4433a2fc59f69112" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INHERITED&lt;/code&gt; option is given, then the &lt;a href=&quot;get_property#command:get_property&quot; id=&quot;index-3-command:get_property&quot;&gt;&lt;code&gt;get_property()&lt;/code&gt;&lt;/a&gt; command will chain up to the next higher scope when the requested property is not set in the scope given to the command.</source>
          <target state="translated">경우 &lt;code&gt;INHERITED&lt;/code&gt; 옵션이 주어 다음 &lt;a href=&quot;get_property#command:get_property&quot; id=&quot;index-3-command:get_property&quot;&gt; &lt;code&gt;get_property()&lt;/code&gt; &lt;/a&gt; 다음으로 높은 범위에 명령 의지 체인까지가 요청 된 속성은 명령에 주어진 범위에 설정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="88ebba1c8ea161fb5d5e2741ab907eb160257684" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; argument is passed, this is used as base path to calculate all the relative paths. The &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; argument must be an absolute path. If this argument is not passed, the &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-1-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt; variable will be used instead. The default value is good when generating a FooConfig.cmake file to use your package from the install tree. When generating a FooConfig.cmake file to use your package from the build tree this option should be used.</source>
          <target state="translated">는 IF &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 의 인수가 전달되고,이 모든 상대 경로를 계산하는 기본 경로로 사용됩니다. &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 인수 절대 경로이어야한다. 이 인수가 전달되지 않으면 &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-1-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; 변수가 대신 사용됩니다. 설치 트리에서 패키지를 사용하기 위해 FooConfig.cmake 파일을 생성 할 때 기본값이 좋습니다. 빌드 트리에서 패키지를 사용하기 위해 FooConfig.cmake 파일을 생성 할 때이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="64279e21a7d26c7d1e69239ad7f7694b2573dbf6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MODULE&lt;/code&gt; option is not specfied in the above signature, CMake first searches for the package using Module mode. Then, if the package is not found, it searches again using Config mode. A user may set the variable &lt;a href=&quot;../variable/cmake_find_package_prefer_config#variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_PREFER_CONFIG&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;TRUE&lt;/code&gt; to direct CMake first search using Config mode before falling back to Module mode.</source>
          <target state="translated">는 IF &lt;code&gt;MODULE&lt;/code&gt; 옵션은 위의 서명에 specfied되지 않으며, 패키지 CMake 첫번째 검색 모듈 모드를 사용하여. 그런 다음 패키지를 찾지 못하면 구성 모드를 사용하여 다시 검색합니다. 사용자는 &lt;a href=&quot;../variable/cmake_find_package_prefer_config#variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_PREFER_CONFIG&lt;/code&gt; &lt;/a&gt; 변수 를 &lt;code&gt;TRUE&lt;/code&gt; 로 설정하여 모듈 모드로 돌아 가기 전에 구성 모드를 사용하여 CMake 첫 번째 검색을 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42f6f8b192382b7a7b6cf8792663ac10c34c1a95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MODULE&lt;/code&gt; option is not specified in the above signature, CMake first searches for the package using Module mode. Then, if the package is not found, it searches again using Config mode. A user may set the variable &lt;a href=&quot;../variable/cmake_find_package_prefer_config#variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_PREFER_CONFIG&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;TRUE&lt;/code&gt; to direct CMake first search using Config mode before falling back to Module mode.</source>
          <target state="translated">는 IF &lt;code&gt;MODULE&lt;/code&gt; 옵션은 위의 서명에 지정되지 않은 패키지에 대한 CMake 첫번째 검색 모듈 모드를 사용하여. 그런 다음 패키지를 찾을 수 없으면 Config 모드를 사용하여 다시 검색합니다. 사용자는 &lt;a href=&quot;../variable/cmake_find_package_prefer_config#variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_PREFER_CONFIG&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_PREFER_CONFIG&lt;/code&gt; &lt;/a&gt; 변수 를 &lt;code&gt;TRUE&lt;/code&gt; 로 설정하여 모듈 모드로 돌아 가기 전에 구성 모드를 사용하여 CMake 첫 번째 검색을 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9648b83f1bad51b37424088974b5cbf3e0313f7d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NO_DEPENDS&lt;/code&gt; option is specified, the step target will not depend on the dependencies of the external project (i.e. on any dependencies of the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; custom target created by &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-3-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt;). This is usually safe for the &lt;code&gt;download&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; steps, since they do not typically require that the dependencies are updated and built. Using &lt;code&gt;NO_DEPENDS&lt;/code&gt; for any of the other pre-defined steps, however, may break parallel builds. Only use &lt;code&gt;NO_DEPENDS&lt;/code&gt; where it is certain that the named steps genuinely do not have dependencies. For custom steps, consider whether or not the custom commands require the dependencies to be configured, built and installed.</source>
          <target state="translated">는 IF &lt;code&gt;NO_DEPENDS&lt;/code&gt; 의 옵션을 지정, 단계 목표 (의 종속성에 즉, 외부 프로젝트의 의존성에 의존하지 않습니다 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 에 의해 만들어진 사용자 지정 대상 &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-3-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; ). 일반적으로 &lt;code&gt;download&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;patch&lt;/code&gt; 단계에서 안전합니다. 일반적으로 종속성을 업데이트하고 빌드 할 필요가 없기 때문입니다. 그러나 다른 사전 정의 된 단계에 &lt;code&gt;NO_DEPENDS&lt;/code&gt; 를 사용하면 병렬 빌드가 중단 될 수 있습니다. &lt;code&gt;NO_DEPENDS&lt;/code&gt; 만 사용여기서 명명 된 단계에 진정으로 의존성이없는 것이 확실합니다. 사용자 정의 단계의 경우 사용자 정의 명령에 종속성을 구성, 빌드 및 설치해야하는지 여부를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="30d2ddbcab2f19a67f471cb639a405b338e0cb82" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PARENT_SCOPE&lt;/code&gt; option is given the variable will be set in the scope above the current scope. Each new directory or function creates a new scope. This command will set the value of a variable into the parent directory or calling function (whichever is applicable to the case at hand). The previous state of the variable&amp;rsquo;s value stays the same in the current scope (e.g., if it was undefined before, it is still undefined and if it had a value, it is still that value).</source>
          <target state="translated">는 IF &lt;code&gt;PARENT_SCOPE&lt;/code&gt; 의 옵션이 주어 변수는 현재 범위 위의 범위에 설정됩니다. 각각의 새로운 디렉토리 또는 함수는 새로운 범위를 만듭니다. 이 명령은 변수의 값을 상위 디렉토리 또는 호출 함수 (현재 상황에 해당하는 것)로 설정합니다. 변수 값의 이전 상태는 현재 범위에서 동일하게 유지됩니다 (예 : 이전에 정의되지 않은 경우 여전히 정의되지 않았으며 값이있는 경우 여전히 해당 값임).</target>
        </trans-unit>
        <trans-unit id="9afab6f67fc04819ba850074a45b394deefc743e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;QUIET_ON_EMPTY&lt;/code&gt; option is used, if only one type of package was requested, and no packages belonging to that category were found, then no output (including the &lt;code&gt;DESCRIPTION&lt;/code&gt;) is printed or added to the &lt;code&gt;VAR&lt;/code&gt; variable.</source>
          <target state="translated">경우] &lt;code&gt;QUIET_ON_EMPTY&lt;/code&gt; 의 패키지의 하나의 타입이 요청 된 경우 옵션이 이용되고, 그 카테고리에 속하는 어떠한 패키지가 발견되지 않았다 (포함 일절 출력 &lt;code&gt;DESCRIPTION&lt;/code&gt; ) 프린트되지 않거나 추가되는 &lt;code&gt;VAR&lt;/code&gt; 의 변수.</target>
        </trans-unit>
        <trans-unit id="914314f70eac980ec014938b5b8595c651d89dce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SET&lt;/code&gt; option is given the variable is set to a boolean value indicating whether the property has been set. If the &lt;code&gt;DEFINED&lt;/code&gt; option is given the variable is set to a boolean value indicating whether the property has been defined such as with the &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-1-command:define_property&quot;&gt;&lt;code&gt;define_property()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">는 IF &lt;code&gt;SET&lt;/code&gt; 의 옵션이 주어 변수는 속성이 설정되어 있는지 여부를 나타내는 부울 값으로 설정된다. 는 IF &lt;code&gt;DEFINED&lt;/code&gt; 옵션은 변수가 건물이와 같은 정의되었는지를 나타내는 부울 값으로 설정된다 주어진다 &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-1-command:define_property&quot;&gt; &lt;code&gt;define_property()&lt;/code&gt; &lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="30165bc362af77b1c1f9688b6b04fa5a20876aa2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; environment variable is set, its value will be used instead of the current time. See &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; for details.</source>
          <target state="translated">경우] &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; 의 환경 변수가 설정되고, 그 값은 현재 시간 대신 사용될 것이다. 자세한 내용은 &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bd6972740f597018508b2c092ce10433e6d5fea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SYSTEM&lt;/code&gt; option is given, the compiler will be told the directories are meant as system include directories on some platforms. Signalling this setting might achieve effects such as the compiler skipping warnings, or these fixed-install system files not being considered in dependency calculations - see compiler docs.</source>
          <target state="translated">는 IF &lt;code&gt;SYSTEM&lt;/code&gt; 옵션이 주어 컴파일러는 시스템이 일부 플랫폼 디렉토리를 포함로 디렉토리를 의미 말했다됩니다. 이 설정을 알리면 컴파일러 건너 뛰기 경고 또는 종속성 계산에서 고려되지 않는 이러한 고정 설치 시스템 파일과 같은 효과를 얻을 수 있습니다 (컴파일러 문서 참조).</target>
        </trans-unit>
        <trans-unit id="eb7a98fc24f3b4bb6be9f96344b8c19e843e5ab3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;moc&lt;/code&gt; output file of a header is included by a source, it will be generated in a different location than if it was not included. This is described in the section &lt;a href=&quot;#output-file-location&quot;&gt;Output file location&lt;/a&gt;.</source>
          <target state="translated">헤더 의 &lt;code&gt;moc&lt;/code&gt; 출력 파일이 소스에 포함 된 경우 포함되지 않은 경우와 다른 위치에 생성됩니다. 이에 대한 내용은 &lt;a href=&quot;#output-file-location&quot;&gt;출력 파일 위치&lt;/a&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bedfd205b0a3f42156b2645185355c17f1155b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;query.json&lt;/code&gt; file &lt;code&gt;requests&lt;/code&gt; member is missing or invalid, this member is a JSON object with a single &lt;code&gt;error&lt;/code&gt; member containing a string with an error message. Otherwise, this member contains a JSON array with a response for each entry of the &lt;code&gt;requests&lt;/code&gt; array, in the same order. Each response is</source>
          <target state="translated">는 IF &lt;code&gt;query.json&lt;/code&gt; 파일 &lt;code&gt;requests&lt;/code&gt; 구성원이 없거나 잘못이 멤버는 하나와 JSON 객체 인 &lt;code&gt;error&lt;/code&gt; 오류 메시지 문자열을 포함하는 멤버. 그렇지 않으면이 멤버에는 &lt;code&gt;requests&lt;/code&gt; 배열 의 각 항목에 대한 응답 이 동일한 JSON 배열이 포함 됩니다. 각 응답은</target>
        </trans-unit>
        <trans-unit id="cf32e6dced5532dbeb69dc080165053934332908" translate="yes" xml:space="preserve">
          <source>If the CMake generator is the &lt;code&gt;Green Hills MULTI&lt;/code&gt; and not overridden then the orginal projects settings for the GHS toolset and target system customization cache variables are propagated into the external project.</source>
          <target state="translated">CMake 생성기가 &lt;code&gt;Green Hills MULTI&lt;/code&gt; 이고 재정의되지 않은 경우 GHS 도구 세트 및 대상 시스템 사용자 정의 캐시 변수에 대한 원래 프로젝트 설정이 외부 프로젝트로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa02b08f683e3b9754fad40365c97bf16a5ce42" translate="yes" xml:space="preserve">
          <source>If the CMake generator is the &lt;code&gt;Green Hills MULTI&lt;/code&gt; and not overridden then the original project&amp;rsquo;s settings for the GHS toolset and target system customization cache variables are propagated into the external project.</source>
          <target state="translated">CMake 생성기가 &lt;code&gt;Green Hills MULTI&lt;/code&gt; 이고 재정의되지 않은 경우 GHS 도구 집합 및 대상 시스템 사용자 지정 캐시 변수에 대한 원래 프로젝트의 설정이 외부 프로젝트로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="2dda889ff51a8ce1be56bcfb82d179de998a12e3" translate="yes" xml:space="preserve">
          <source>If the CUDA_PATH environment variable is defined, it will be searched for &lt;code&gt;nvcc&lt;/code&gt;.</source>
          <target state="translated">CUDA_PATH 환경 변수가 정의 된 경우 &lt;code&gt;nvcc&lt;/code&gt; 를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="bce5d569f1d441e714f9fc634e609f93412a8cb0" translate="yes" xml:space="preserve">
          <source>If the GLVND OpenGL and GLX libraries are available, prefer them. This forces &lt;code&gt;OPENGL_gl_LIBRARY&lt;/code&gt; to be empty. This is the default if components were requested (since components correspond to GLVND libraries) or if policy &lt;a href=&quot;../policy/cmp0072#policy:CMP0072&quot; id=&quot;index-0-policy:CMP0072&quot;&gt;&lt;code&gt;CMP0072&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">GLVND OpenGL 및 GLX 라이브러리가 사용 가능한 경우 선호합니다. 그러면 &lt;code&gt;OPENGL_gl_LIBRARY&lt;/code&gt; 가 비워집니다. 구성 요소가 요청 된 경우 (구성 요소가 GLVND 라이브러리에 해당하므로) 정책 &lt;a href=&quot;../policy/cmp0072#policy:CMP0072&quot; id=&quot;index-0-policy:CMP0072&quot;&gt; &lt;code&gt;CMP0072&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;NEW&lt;/code&gt; 로 설정된 경우 이것이 기본값 입니다 .</target>
        </trans-unit>
        <trans-unit id="14939988c62a966844fa6c581fe15b05439214db" translate="yes" xml:space="preserve">
          <source>If the argument is a relative path and it exists in the current source directory, a file-level dependency is created on that file in the current source directory.</source>
          <target state="translated">인수가 상대 경로이고 현재 소스 디렉토리에있는 경우 현재 소스 디렉토리의 해당 파일에 파일 수준 종속성이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b33b760f7acd8416cd2c7b6a46f2034fb6702bf9" translate="yes" xml:space="preserve">
          <source>If the argument is an absolute path, a file-level dependency is created on that path.</source>
          <target state="translated">인수가 절대 경로이면 해당 경로에 파일 수준 종속성이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="c9a6f2272461199fd0c5cb8b4362b7cd32d8539c" translate="yes" xml:space="preserve">
          <source>If the argument is the name of a source file that has been added to a target or on which a source file property has been set, a file-level dependency is created on that source file.</source>
          <target state="translated">인수가 대상에 추가되었거나 소스 파일 속성이 설정된 소스 파일의 이름 인 경우 해당 소스 파일에 파일 수준 종속성이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="517435c5456f5797ac46708153a43e71aecc0dd9" translate="yes" xml:space="preserve">
          <source>If the argument is the name of a target (created by the &lt;a href=&quot;add_custom_target#command:add_custom_target&quot; id=&quot;index-1-command:add_custom_target&quot;&gt;&lt;code&gt;add_custom_target()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;add_executable#command:add_executable&quot; id=&quot;index-1-command:add_executable&quot;&gt;&lt;code&gt;add_executable()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library()&lt;/code&gt;&lt;/a&gt; command) a target-level dependency is created to make sure the target is built before any target using this custom command. Additionally, if the target is an executable or library, a file-level dependency is created to cause the custom command to re-run whenever the target is recompiled.</source>
          <target state="translated">인수가 대상의 이름 ( &lt;a href=&quot;add_custom_target#command:add_custom_target&quot; id=&quot;index-1-command:add_custom_target&quot;&gt; &lt;code&gt;add_custom_target()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;add_executable#command:add_executable&quot; id=&quot;index-1-command:add_executable&quot;&gt; &lt;code&gt;add_executable()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library()&lt;/code&gt; &lt;/a&gt; 명령으로 생성됨 ) 인 경우 대상 수준 종속성이 생성 되어이 사용자 지정 명령을 사용하는 대상보다 먼저 대상이 빌드되었는지 확인합니다. 또한 대상이 실행 파일 또는 라이브러리 인 경우 파일 수준 종속성이 만들어져 대상이 다시 컴파일 될 때마다 사용자 지정 명령이 다시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="127f440d15138216f83961a135ae42956d155176" translate="yes" xml:space="preserve">
          <source>If the cache entry does not exist prior to the call or the &lt;code&gt;FORCE&lt;/code&gt; option is given then the cache entry will be set to the given value. Furthermore, any normal variable binding in the current scope will be removed to expose the newly cached value to any immediately following evaluation.</source>
          <target state="translated">호출 전에 캐시 항목이 존재하지 않거나 &lt;code&gt;FORCE&lt;/code&gt; 옵션이 제공되면 캐시 항목이 제공된 값으로 설정됩니다. 또한 현재 범위의 모든 일반 변수 바인딩이 제거되어 새로 캐시 된 값이 평가 직후에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="056a82e56fc2bbae7440dc4c505b10604d660059" translate="yes" xml:space="preserve">
          <source>If the command is unable to obtain a timestamp, the &lt;code&gt;&amp;lt;output_variable&amp;gt;&lt;/code&gt; will be set to the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">명령이 타임 스탬프를 얻을 수없는 경우 &lt;code&gt;&amp;lt;output_variable&amp;gt;&lt;/code&gt; 은 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="78c30fffd9009e745843799c6fc686e52d950153" translate="yes" xml:space="preserve">
          <source>If the command line client executable is found the following macro is defined:</source>
          <target state="translated">명령 행 클라이언트 실행 파일이 발견되면 다음 매크로가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8ee68900ff2dd86077ac8e980b9bce723367a651" translate="yes" xml:space="preserve">
          <source>If the command line client executable is found two macros are defined:</source>
          <target state="translated">명령 행 클라이언트 실행 파일이 발견되면 두 개의 매크로가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f2aa3a8ec48e1ef00eb148ee9c39b77423c045ce" translate="yes" xml:space="preserve">
          <source>If the component &lt;code&gt;Development&lt;/code&gt; is requested, it is &lt;strong&gt;strongly&lt;/strong&gt; recommended to also include the component &lt;code&gt;Interpreter&lt;/code&gt; to get expected result.</source>
          <target state="translated">구성 요소 경우 &lt;code&gt;Development&lt;/code&gt; 요구되고,된다 &lt;strong&gt;강하게&lt;/strong&gt; 또한 구성 요소를 포함하도록 권장 &lt;code&gt;Interpreter&lt;/code&gt; 결과를 예상 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0746bb15856aff956a9f8399555685028e89f583" translate="yes" xml:space="preserve">
          <source>If the configuration type is set via &lt;code&gt;-C &amp;lt;cfg&amp;gt;&lt;/code&gt; from the command line then this variable is populated accordingly.</source>
          <target state="translated">구성 유형이 명령 줄에서 &lt;code&gt;-C &amp;lt;cfg&amp;gt;&lt;/code&gt; 를 통해 설정되면 그에 따라이 변수가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a786d18d9166e14b02a2996c15c4d2de0163d05c" translate="yes" xml:space="preserve">
          <source>If the configure step assumed the external project uses CMake as its build system, the build step will also. Otherwise, the build step will assume a Makefile-based build and simply run &lt;code&gt;make&lt;/code&gt; with no arguments as the default build step. This can be overridden with custom build commands if required.</source>
          <target state="translated">구성 단계에서 외부 프로젝트가 CMake를 빌드 시스템으로 사용한다고 가정하면 빌드 단계도 수행됩니다. 그렇지 않으면, 빌드 단계는 Makefile 기반 빌드를 가정 하고 기본 빌드 단계로 인수없이 &lt;code&gt;make&lt;/code&gt; 를 실행 합니다. 필요한 경우 사용자 정의 빌드 명령으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da9730129890fa0cd9f6e7d2e948b4e5d9e1f010" translate="yes" xml:space="preserve">
          <source>If the configure step assumed the external project uses CMake as its build system, the install step will also. Otherwise, the install step will assume a Makefile-based build and simply run &lt;code&gt;make install&lt;/code&gt; as the default build step. This can be overridden with custom install commands if required.</source>
          <target state="translated">구성 단계에서 외부 프로젝트가 CMake를 빌드 시스템으로 사용한다고 가정하면 설치 단계도 수행됩니다. 그렇지 않으면 설치 단계에서 Makefile 기반 빌드를 가정 하고 기본 빌드 단계로 &lt;code&gt;make install&lt;/code&gt; 을 실행 하면 됩니다. 필요한 경우 사용자 정의 설치 명령으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19b312103b6a0fa603fb35d087009ae86c954f9a" translate="yes" xml:space="preserve">
          <source>If the dependency could not be found it sets an informative diagnostic message and calls &lt;a href=&quot;../command/return#command:return&quot; id=&quot;index-0-command:return&quot;&gt;&lt;code&gt;return()&lt;/code&gt;&lt;/a&gt; to end processing of the calling package configuration file and return to the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; command that loaded it.</source>
          <target state="translated">종속성을 찾을 수 없으면 정보 진단 메시지를 설정하고 &lt;a href=&quot;../command/return#command:return&quot; id=&quot;index-0-command:return&quot;&gt; &lt;code&gt;return()&lt;/code&gt; &lt;/a&gt; 을 호출하여 호출 패키지 구성 파일의 처리를 종료하고 이를로드 한 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령으로 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="96fae9af91a51f71db660ede5fbb6107ac3c8d2d" translate="yes" xml:space="preserve">
          <source>If the dependency is found, and its full path does not match either &lt;code&gt;POST_INCLUDE_REGEXES&lt;/code&gt; or &lt;code&gt;POST_EXCLUDE_REGEXES&lt;/code&gt;, the full path is added to the resolved dependencies, and &lt;code&gt;file(GET_RUNTIME_DEPENDENCIES)&lt;/code&gt; recursively resolves that library&amp;rsquo;s own dependencies.</source>
          <target state="translated">종속성이 발견되고 전체 경로가 &lt;code&gt;POST_INCLUDE_REGEXES&lt;/code&gt; 또는 &lt;code&gt;POST_EXCLUDE_REGEXES&lt;/code&gt; 와 일치하지 않으면 전체 경로가 확인 된 종속성에 추가되고 &lt;code&gt;file(GET_RUNTIME_DEPENDENCIES)&lt;/code&gt; 은 해당 라이브러리의 자체 종속성을 반복적으로 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0d3d2575880313387bb2d12a2352ddada4de6b2c" translate="yes" xml:space="preserve">
          <source>If the dependency is found, and its full path matches one of the &lt;code&gt;POST_INCLUDE_REGEXES&lt;/code&gt;, the full path is added to the resolved dependencies, and &lt;code&gt;file(GET_RUNTIME_DEPENDENCIES)&lt;/code&gt; recursively resolves that library&amp;rsquo;s own dependencies. Otherwise, resolution proceeds to step 6.</source>
          <target state="translated">종속성이 발견되고 전체 경로가 &lt;code&gt;POST_INCLUDE_REGEXES&lt;/code&gt; 중 하나와 일치 하면 전체 경로가 확인 된 종속성에 추가되고 &lt;code&gt;file(GET_RUNTIME_DEPENDENCIES)&lt;/code&gt; 은 해당 라이브러리의 자체 종속성을 반복적으로 확인합니다. 그렇지 않으면 해결이 6 단계로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="89909557c3e9823498a99f911b0661cff9186cf4" translate="yes" xml:space="preserve">
          <source>If the dependency is found, but its full path matches one of the &lt;code&gt;POST_EXCLUDE_REGEXES&lt;/code&gt;, it is not added to the resolved dependencies, and dependency resolution stops for that dependency.</source>
          <target state="translated">종속성이 발견되었지만 전체 경로가 &lt;code&gt;POST_EXCLUDE_REGEXES&lt;/code&gt; 중 하나와 일치 하면 확인 된 종속성에 추가되지 않고 해당 종속성에 대한 종속성 확인이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="045ccc0597846f5d7d3fa926e21d9f9e8dc6e941" translate="yes" xml:space="preserve">
          <source>If the dependency starts with &lt;code&gt;@executable_path/&lt;/code&gt;, and an &lt;code&gt;EXECUTABLES&lt;/code&gt; argument is in the process of being resolved, and replacing &lt;code&gt;@executable_path/&lt;/code&gt; with the directory of the executable yields an existing file, the dependency is resolved to that file.</source>
          <target state="translated">종속성이 &lt;code&gt;@executable_path/&lt;/code&gt; 시작 하고 &lt;code&gt;EXECUTABLES&lt;/code&gt; 인수가 해결되는 중이고 &lt;code&gt;@executable_path/&lt;/code&gt; 를 실행 파일 의 디렉터리로 바꾸면 기존 파일이 생성되는 경우 종속성이 해당 파일로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="f901bbe545c313c01ae1b78203f0d2794d3c408d" translate="yes" xml:space="preserve">
          <source>If the depending file does not have any &lt;code&gt;RUNPATH&lt;/code&gt; entries, and the library exists in one of the depending file&amp;rsquo;s &lt;code&gt;RPATH&lt;/code&gt; entries, or its parents&amp;rsquo;, in that order, the dependency is resolved to that file.</source>
          <target state="translated">종속 파일에 &lt;code&gt;RUNPATH&lt;/code&gt; 항목 이없고 라이브러리가 종속 파일의 &lt;code&gt;RPATH&lt;/code&gt; 항목 중 하나 또는 상위 항목에 순서대로 존재하는 경우 종속성은 해당 파일로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2cc8186868c77569de1bc1f17461e52dd033e3" translate="yes" xml:space="preserve">
          <source>If the directory doesn&amp;rsquo;t already exist CMake will make it.</source>
          <target state="translated">디렉토리가 존재하지 않으면 CMake가 디렉토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4c31e21e8a219fa31aeaa8c1577f2491c58b1e5e" translate="yes" xml:space="preserve">
          <source>If the file is a build input, use the &lt;a href=&quot;configure_file#command:configure_file&quot; id=&quot;index-0-command:configure_file&quot;&gt;&lt;code&gt;configure_file()&lt;/code&gt;&lt;/a&gt; command to update the file only when its content changes.</source>
          <target state="translated">파일이 빌드 입력 인 경우 &lt;a href=&quot;configure_file#command:configure_file&quot; id=&quot;index-0-command:configure_file&quot;&gt; &lt;code&gt;configure_file()&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 내용이 변경 될 때만 파일을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="fee07055472b9e2cc033acb1218d21549d5cc062" translate="yes" xml:space="preserve">
          <source>If the find procedure fails for a variable &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_WORKS&lt;/code&gt;, then the settings detected by or passed to the module did not work and even a simple MPI test program failed to compile.</source>
          <target state="translated">변수 &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_WORKS&lt;/code&gt; 에 대해 찾기 프로 시저가 실패하면 , 모듈에 의해 감지되거나 모듈에 전달 된 설정이 작동하지 않고 간단한 MPI 테스트 프로그램도 컴파일하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="f4db254792119b926535d35f67a261b159bcc013" translate="yes" xml:space="preserve">
          <source>If the following variables are set to true, the respective search will be performed:</source>
          <target state="translated">다음 변수가 true로 설정되면 해당 검색이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c5f8892911b9443b21b3c7da7d01c077944d90" translate="yes" xml:space="preserve">
          <source>If the found thread library is pthread compatible.</source>
          <target state="translated">발견 된 스레드 라이브러리가 pthread와 호환되는 경우.</target>
        </trans-unit>
        <trans-unit id="9d5fe9b452c697badf81668a9efee5c4a2c3abcd" translate="yes" xml:space="preserve">
          <source>If the found thread library is the HP thread library.</source>
          <target state="translated">찾은 스레드 라이브러리가 HP 스레드 라이브러리 인 경우.</target>
        </trans-unit>
        <trans-unit id="55f03b1760a021f61ef39912bc60b9bc89d58ca8" translate="yes" xml:space="preserve">
          <source>If the found thread library is the win32 one.</source>
          <target state="translated">발견 된 스레드 라이브러리가 win32 인 경우.</target>
        </trans-unit>
        <trans-unit id="8afc21ba3b19f5017930dbea305ddfdc14be6e22" translate="yes" xml:space="preserve">
          <source>If the generator supports &lt;a href=&quot;../variable/cmake_generator_platform#variable:CMAKE_GENERATOR_PLATFORM&quot; id=&quot;index-0-variable:CMAKE_GENERATOR_PLATFORM&quot;&gt;&lt;code&gt;CMAKE_GENERATOR_PLATFORM&lt;/code&gt;&lt;/a&gt;, this is a string specifying the generator platform name.</source>
          <target state="translated">생성기가 &lt;a href=&quot;../variable/cmake_generator_platform#variable:CMAKE_GENERATOR_PLATFORM&quot; id=&quot;index-0-variable:CMAKE_GENERATOR_PLATFORM&quot;&gt; &lt;code&gt;CMAKE_GENERATOR_PLATFORM&lt;/code&gt; 을&lt;/a&gt; 지원 하는 경우 생성기 플랫폼 이름을 지정하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2ac777367b9e5b8ae469973518aacfb56e0a0582" translate="yes" xml:space="preserve">
          <source>If the generator supports configuration types, then &lt;code&gt;basename_LIBRARY&lt;/code&gt; and &lt;code&gt;basename_LIBRARIES&lt;/code&gt; will be set with debug and optimized flags specifying the library to be used for the given configuration. If no build type has been set or the generator in use does not support configuration types, then &lt;code&gt;basename_LIBRARY&lt;/code&gt; and &lt;code&gt;basename_LIBRARIES&lt;/code&gt; will take only the release value, or the debug value if the release one is not set.</source>
          <target state="translated">생성기가 구성 유형을 지원하면 &lt;code&gt;basename_LIBRARY&lt;/code&gt; 및 &lt;code&gt;basename_LIBRARIES&lt;/code&gt; 는 지정된 구성에 사용할 라이브러리를 지정하는 디버그 및 최적화 된 플래그와 함께 설정됩니다. 빌드 유형이 설정되지 않았거나 사용중인 생성기가 구성 유형을 지원하지 않는 경우 &lt;code&gt;basename_LIBRARY&lt;/code&gt; 및 &lt;code&gt;basename_LIBRARIES&lt;/code&gt; 는 릴리스 값만 취하거나 릴리스 값이 설정되지 않은 경우 디버그 값만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a825cfea9a15f0e3c5d7b7b6c20bcefb75639c7" translate="yes" xml:space="preserve">
          <source>If the header files define the symbol as a macro it is considered available and assumed to work. If the header files declare the symbol as a function or variable then the symbol must also be available for linking (so intrinsics may not be detected). If the symbol is a type, enum value, or intrinsic it will not be recognized (consider using &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt;&lt;code&gt;CheckTypeSize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;checkcsourcecompiles#module:CheckCSourceCompiles&quot; id=&quot;index-0-module:CheckCSourceCompiles&quot;&gt;&lt;code&gt;CheckCSourceCompiles&lt;/code&gt;&lt;/a&gt;). If the check needs to be done in C++, consider using &lt;a href=&quot;checkcxxsymbolexists#module:CheckCXXSymbolExists&quot; id=&quot;index-0-module:CheckCXXSymbolExists&quot;&gt;&lt;code&gt;CheckCXXSymbolExists&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">헤더 파일이 심볼을 매크로로 정의하면 사용 가능한 것으로 간주되고 작동하는 것으로 간주됩니다. 헤더 파일이 심볼을 함수 또는 변수로 선언하는 경우 심볼을 링크에 사용할 수 있어야합니다 (따라서 내장 함수가 감지되지 않을 수 있음). 기호가 유형, 열거 형 값 또는 고유 한 경우 인식되지 않습니다 ( &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt; &lt;code&gt;CheckTypeSize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;checkcsourcecompiles#module:CheckCSourceCompiles&quot; id=&quot;index-0-module:CheckCSourceCompiles&quot;&gt; &lt;code&gt;CheckCSourceCompiles&lt;/code&gt; 사용&lt;/a&gt; ). C ++에서 점검이 필요한 경우 &lt;a href=&quot;checkcxxsymbolexists#module:CheckCXXSymbolExists&quot; id=&quot;index-0-module:CheckCXXSymbolExists&quot;&gt; &lt;code&gt;CheckCXXSymbolExists&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b39d20d6c179691c6022701af9ee3dbb591179c6" translate="yes" xml:space="preserve">
          <source>If the header files define the symbol as a macro it is considered available and assumed to work. If the header files declare the symbol as a function or variable then the symbol must also be available for linking. If the symbol is a type or enum value it will not be recognized (consider using &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt;&lt;code&gt;CheckTypeSize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;checkcxxsourcecompiles#module:CheckCXXSourceCompiles&quot; id=&quot;index-0-module:CheckCXXSourceCompiles&quot;&gt;&lt;code&gt;CheckCXXSourceCompiles&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">헤더 파일이 심볼을 매크로로 정의하면 사용 가능한 것으로 간주되고 작동하는 것으로 간주됩니다. 헤더 파일이 심볼을 함수 또는 변수로 선언하면 심볼을 링크에 사용할 수 있어야합니다. 기호가 유형 또는 열거 형 값이면 인식되지 않습니다 ( &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt; &lt;code&gt;CheckTypeSize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;checkcxxsourcecompiles#module:CheckCXXSourceCompiles&quot; id=&quot;index-0-module:CheckCXXSourceCompiles&quot;&gt; &lt;code&gt;CheckCXXSourceCompiles&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0247aaa07bb083238e1b60c52cf5dc6297cbe6d7" translate="yes" xml:space="preserve">
          <source>If the header files define the symbol as a macro it is considered available and assumed to work. If the header files declare the symbol as a function or variable then the symbol must also be available for linking. If the symbol is a type, enum value, or C++ template it will not be recognized: consider using the &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt;&lt;code&gt;CheckTypeSize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;checkcxxsourcecompiles#module:CheckCXXSourceCompiles&quot; id=&quot;index-0-module:CheckCXXSourceCompiles&quot;&gt;&lt;code&gt;CheckCXXSourceCompiles&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">헤더 파일이 심볼을 매크로로 정의하면 사용 가능한 것으로 간주되고 작동하는 것으로 간주됩니다. 헤더 파일이 기호를 함수 또는 변수로 선언하는 경우 해당 기호도 링크에 사용할 수 있어야합니다. 기호가 유형, 열거 형 값 또는 C ++ 템플릿이면 인식되지 않습니다 . 대신 &lt;a href=&quot;checktypesize#module:CheckTypeSize&quot; id=&quot;index-0-module:CheckTypeSize&quot;&gt; &lt;code&gt;CheckTypeSize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;checkcxxsourcecompiles#module:CheckCXXSourceCompiles&quot; id=&quot;index-0-module:CheckCXXSourceCompiles&quot;&gt; &lt;code&gt;CheckCXXSourceCompiles&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7e4bcaa007503c90e98f66c3dcb2f0f1a74bbeb9" translate="yes" xml:space="preserve">
          <source>If the imported project has different configuration names than the current project, set the &lt;code&gt;MAP_IMPORTED_CONFIG_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; target property to specify the mapping.</source>
          <target state="translated">가져온 프로젝트의 구성 이름이 현재 프로젝트와 다른 경우 &lt;code&gt;MAP_IMPORTED_CONFIG_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; 대상 특성을 설정하여 맵핑을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef37225d4c049b47efcf19609de88c0aa83b198" translate="yes" xml:space="preserve">
          <source>If the includer does not define a value the above-shown default will be used and the value will appear in the cache for editing by the user.</source>
          <target state="translated">포함자가 값을 정의하지 않으면 위에 표시된 기본값이 사용되며 값은 사용자가 편집 할 수 있도록 캐시에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7229063fd8f5d9edc3e5dcf86b3b6c20d714e674" translate="yes" xml:space="preserve">
          <source>If the input file is modified the build system will re-run CMake to re-configure the file and generate the build system again. The generated file is modified and its timestamp updated on subsequent cmake runs only if its content is changed.</source>
          <target state="translated">입력 파일이 수정되면 빌드 시스템은 CMake를 다시 실행하여 파일을 재구성하고 빌드 시스템을 다시 생성합니다. 생성 된 파일이 수정되고 후속 cmake에서 업데이트 된 타임 스탬프는 내용이 변경된 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd95d4375c3f59407ec5ad3ad61f53d1415f21c" translate="yes" xml:space="preserve">
          <source>If the keyword &lt;code&gt;CLEAR&lt;/code&gt; is given then advanced variables are changed back to unadvanced. If the keyword &lt;code&gt;FORCE&lt;/code&gt; is given then the variables are made advanced. If neither &lt;code&gt;FORCE&lt;/code&gt; nor &lt;code&gt;CLEAR&lt;/code&gt; is specified, new values will be marked as advanced, but if a variable already has an advanced/non-advanced state, it will not be changed.</source>
          <target state="translated">키워드 &lt;code&gt;CLEAR&lt;/code&gt; 가 제공 되면 고급 변수가 다시 고급으로 변경됩니다. 키워드 &lt;code&gt;FORCE&lt;/code&gt; 가 제공되면 변수가 고급화됩니다. &lt;code&gt;FORCE&lt;/code&gt; 또는 &lt;code&gt;CLEAR&lt;/code&gt; 를 지정 하지 않으면 새 값이 고급으로 표시되지만 변수에 이미 고급 / 고급 상태가 아닌 경우에는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa11ec4d2c499822b4a97b8ea66028083c29ce86" translate="yes" xml:space="preserve">
          <source>If the left hand argument to &lt;code&gt;MATCHES&lt;/code&gt; is missing it returns false without error</source>
          <target state="translated">&lt;code&gt;MATCHES&lt;/code&gt; 에 대한 왼쪽 인수 가 없으면 오류없이 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca976db296b62307634ed55538b2f60d1382ba12" translate="yes" xml:space="preserve">
          <source>If the libexslt library has been found</source>
          <target state="translated">libexslt 라이브러리가 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="c5d69bb2712516e28654ad76b4e35e57ab49a21f" translate="yes" xml:space="preserve">
          <source>If the library file is in a macOS framework, the &lt;code&gt;Headers&lt;/code&gt; directory of the framework will also be processed as a &lt;a href=&quot;../manual/cmake-buildsystem.7#target-usage-requirements&quot;&gt;usage requirement&lt;/a&gt;. This has the same effect as passing the framework directory as an include directory.</source>
          <target state="translated">라이브러리 파일이 macOS 프레임 워크에있는 경우 프레임 워크의 &lt;code&gt;Headers&lt;/code&gt; 디렉토리도 &lt;a href=&quot;../manual/cmake-buildsystem.7#target-usage-requirements&quot;&gt;사용 요구 사항&lt;/a&gt; 으로 처리됩니다 . 이는 프레임 워크 디렉토리를 포함 디렉토리로 전달하는 것과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a6aeaf755f136d2fa24e2f379337a38f35766919" translate="yes" xml:space="preserve">
          <source>If the library found is a framework, then &lt;code&gt;&amp;lt;VAR&amp;gt;&lt;/code&gt; will be set to the full path to the framework &lt;code&gt;&amp;lt;fullPath&amp;gt;/A.framework&lt;/code&gt;. When a full path to a framework is used as a library, CMake will use a &lt;code&gt;-framework A&lt;/code&gt;, and a &lt;code&gt;-F&amp;lt;fullPath&amp;gt;&lt;/code&gt; to link the framework to the target.</source>
          <target state="translated">찾은 라이브러리가 프레임 워크 인 경우 &lt;code&gt;&amp;lt;VAR&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;fullPath&amp;gt;/A.framework&lt;/code&gt; 프레임 워크의 전체 경로로 설정됩니다 . 프레임 워크의 전체 경로가 라이브러리로 사용되면 CMake는 &lt;code&gt;-framework A&lt;/code&gt; 및 &lt;code&gt;-F&amp;lt;fullPath&amp;gt;&lt;/code&gt; 를 사용하여 프레임 워크를 대상에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="480a847a4ec0873d542be0e2f0a384a20681eb86" translate="yes" xml:space="preserve">
          <source>If the library is available with multiple configurations, the &lt;a href=&quot;../prop_tgt/imported_configurations#prop_tgt:IMPORTED_CONFIGURATIONS&quot; id=&quot;index-0-prop_tgt:IMPORTED_CONFIGURATIONS&quot;&gt;&lt;code&gt;IMPORTED_CONFIGURATIONS&lt;/code&gt;&lt;/a&gt; target property should also be populated:</source>
          <target state="translated">라이브러리가 여러 구성으로 사용 가능한 경우 &lt;a href=&quot;../prop_tgt/imported_configurations#prop_tgt:IMPORTED_CONFIGURATIONS&quot; id=&quot;index-0-prop_tgt:IMPORTED_CONFIGURATIONS&quot;&gt; &lt;code&gt;IMPORTED_CONFIGURATIONS&lt;/code&gt; &lt;/a&gt; 대상 특성도 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="18ab6b8361de4008028c2f9094dfd98c10e35918" translate="yes" xml:space="preserve">
          <source>If the library type is not specified, &lt;code&gt;MODULE&lt;/code&gt; is assumed.</source>
          <target state="translated">라이브러리 유형이 지정되지 않은 경우 &lt;code&gt;MODULE&lt;/code&gt; 가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="663c4b7e7b52b37ae8fb04dd7eeb5e583e7b583f" translate="yes" xml:space="preserve">
          <source>If the libxml2 library has been found</source>
          <target state="translated">libxml2 라이브러리가 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="23c81ae610c85776879a16001183eedc839bc079" translate="yes" xml:space="preserve">
          <source>If the libxslt library has been found</source>
          <target state="translated">libxslt 라이브러리가 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="dddd335c9713542e2b0a86e70bfd6a602fa49036" translate="yes" xml:space="preserve">
          <source>If the local clone already has the commit corresponding to the hash, no &lt;code&gt;git fetch&lt;/code&gt; needs to be performed to check for changes each time CMake is re-run. This can result in a significant speed up if many external projects are being used.</source>
          <target state="translated">로컬 클론에 이미 해시에 해당하는 커밋이있는 경우 CMake를 다시 실행할 때마다 변경 사항을 확인하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 를 수행 할 필요가 없습니다 . 많은 외부 프로젝트를 사용하는 경우 속도가 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbec8e724da2f9299c8c428ab998999af78c556" translate="yes" xml:space="preserve">
          <source>If the mangling for some symbol is not known then no preprocessor definition is created, and a warning is displayed.</source>
          <target state="translated">일부 기호에 대한 조작을 알 수없는 경우 프리 프로세서 정의가 작성되지 않고 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="de117eaafe839a260ce801f2587f20f0632b8a94" translate="yes" xml:space="preserve">
          <source>If the not-yet-resolved dependency matches any of the &lt;code&gt;PRE_EXCLUDE_REGEXES&lt;/code&gt;, dependency resolution stops for that dependency.</source>
          <target state="translated">아직 해결되지 않은 종속성이 &lt;code&gt;PRE_EXCLUDE_REGEXES&lt;/code&gt; 중 하나와 일치하면 해당 종속성에 대한 종속성 확인이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="4c0dca9c10124a53bf5e1c5b382b1989e566c5b5" translate="yes" xml:space="preserve">
          <source>If the not-yet-resolved dependency matches any of the &lt;code&gt;PRE_INCLUDE_REGEXES&lt;/code&gt;, steps 2 and 3 are skipped, and the dependency resolution proceeds to step 4.</source>
          <target state="translated">아직 해결되지 않은 종속성이 &lt;code&gt;PRE_INCLUDE_REGEXES&lt;/code&gt; 중 하나와 일치하면 2 단계와 3 단계를 건너 뛰고 종속성 해결은 4 단계로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="788a913d2f05d89c7266359583c99c4baec074a3" translate="yes" xml:space="preserve">
          <source>If the output matches this regular expression the test will be marked as skipped.</source>
          <target state="translated">출력이이 정규식과 일치하면 테스트는 건너 뛴 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c15b6027a33ae314c140c72b5b4f6f0de1e84cb8" translate="yes" xml:space="preserve">
          <source>If the output matches this regular expression the test will fail.</source>
          <target state="translated">출력이이 정규식과 일치하면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b02991fb310a7ffdd348a7041053c496a66633b" translate="yes" xml:space="preserve">
          <source>If the package configuration file cannot be found CMake will generate an error describing the problem unless the &lt;code&gt;QUIET&lt;/code&gt; argument is specified. If &lt;code&gt;REQUIRED&lt;/code&gt; is specified and the package is not found a fatal error is generated and the configure step stops executing. If &lt;code&gt;&amp;lt;PackageName&amp;gt;_DIR&lt;/code&gt; has been set to a directory not containing a configuration file CMake will ignore it and search from scratch.</source>
          <target state="translated">패키지 구성 파일을 찾을 수 없으면 CMake는 &lt;code&gt;QUIET&lt;/code&gt; 인수를 지정 하지 않으면 문제를 설명하는 오류를 생성 합니다. 경우 &lt;code&gt;REQUIRED&lt;/code&gt; 가 지정되고, 패키지가 발견되지 않은 치명적인 에러가 발생되고, 구성 단계는 실행하지 않습니다. 경우 &lt;code&gt;&amp;lt;PackageName&amp;gt;_DIR&lt;/code&gt; 디렉토리가 CMake 그것을 무시하고 처음부터 검색합니다 구성 파일을 포함하지 않는 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c8efb888f3779aec23b79c76d6e0ed90e9f5f1" translate="yes" xml:space="preserve">
          <source>If the package provides any macros or functions, they should be listed in an additional section, but can be documented by additional &lt;code&gt;.rst:&lt;/code&gt; comment blocks immediately above where those macros or functions are defined.</source>
          <target state="translated">패키지가 매크로 또는 함수를 제공하는 경우 추가 섹션에 나열되어야하지만 매크로 또는 함수가 정의 된 바로 위의 추가 &lt;code&gt;.rst:&lt;/code&gt; 주석 블록 으로 문서화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a0bafb9a8d90e13f8a9841521905d961585723f" translate="yes" xml:space="preserve">
          <source>If the platform has &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; then we will use them to compute the square root in the &lt;code&gt;mysqrt&lt;/code&gt; function. We first test for the availability of these functions using the &lt;a href=&quot;../../module/checksymbolexists#module:CheckSymbolExists&quot; id=&quot;index-0-module:CheckSymbolExists&quot;&gt;&lt;code&gt;CheckSymbolExists&lt;/code&gt;&lt;/a&gt; module in the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt;. On some platforms, we will need to link to the m library. If &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; are not initially found, require the m library and try again.</source>
          <target state="translated">플랫폼에 &lt;code&gt;log&lt;/code&gt; 와 &lt;code&gt;exp&lt;/code&gt; 가 있으면 &lt;code&gt;mysqrt&lt;/code&gt; 함수 에서 제곱근을 계산하는 데 사용합니다 . 설명서에서는 사용하여이 기능의 가용성에 대해 첫 번째 테스트 &lt;a href=&quot;../../module/checksymbolexists#module:CheckSymbolExists&quot; id=&quot;index-0-module:CheckSymbolExists&quot;&gt; &lt;code&gt;CheckSymbolExists&lt;/code&gt; 는&lt;/a&gt; 최상위에 모듈 &lt;code&gt;CMakeLists.txt&lt;/code&gt; . 일부 플랫폼에서는 m 라이브러리에 연결해야합니다. 경우 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;exp&lt;/code&gt; 초기에 발견되지는 m 라이브러리를 필요로하고 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="884833f2e8da59fce1382e26656c1379a11b4480" translate="yes" xml:space="preserve">
          <source>If the project code does not set the policy explicitly, users may set it on the command line by defining the &lt;code&gt;CMAKE_POLICY_DEFAULT_CMP0056&lt;/code&gt; variable in the cache.</source>
          <target state="translated">프로젝트 코드가 명시 적으로 정책을 설정하지 않은 경우 사용자는 캐시에서 &lt;code&gt;CMAKE_POLICY_DEFAULT_CMP0056&lt;/code&gt; 변수를 정의하여 명령 줄에서 정책을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26aaad5e3dca4ff8c4c1c8ff6b182a25fb5bc34b" translate="yes" xml:space="preserve">
          <source>If the property is not defined for the nominated directory scope, an empty string is returned. In the case of &lt;code&gt;INHERITED&lt;/code&gt; properties, if the property is not found for the nominated directory scope, the search will chain to a parent scope as described for the &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt;&lt;code&gt;define_property()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">지정된 디렉토리 범위에 대해 특성이 정의되지 않은 경우 빈 문자열이 리턴됩니다. &lt;code&gt;INHERITED&lt;/code&gt; 특성 의 경우 , 지정된 디렉토리 범위에 대한 특성을 찾을 수 없으면 검색은 &lt;a href=&quot;define_property#command:define_property&quot; id=&quot;index-0-command:define_property&quot;&gt; &lt;code&gt;define_property()&lt;/code&gt; &lt;/a&gt; 명령에 설명 된대로 상위 범위로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="b53ce9a5cafbc34a35b03719ab7b01640fc0c1c9" translate="yes" xml:space="preserve">
          <source>If the property is not set, CMake will use the value provided by &lt;a href=&quot;../variable/cmake_disable_precompile_headers#variable:CMAKE_DISABLE_PRECOMPILE_HEADERS&quot; id=&quot;index-0-variable:CMAKE_DISABLE_PRECOMPILE_HEADERS&quot;&gt;&lt;code&gt;CMAKE_DISABLE_PRECOMPILE_HEADERS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않은 경우 CMake는 &lt;a href=&quot;../variable/cmake_disable_precompile_headers#variable:CMAKE_DISABLE_PRECOMPILE_HEADERS&quot; id=&quot;index-0-variable:CMAKE_DISABLE_PRECOMPILE_HEADERS&quot;&gt; &lt;code&gt;CMAKE_DISABLE_PRECOMPILE_HEADERS&lt;/code&gt; 에서&lt;/a&gt; 제공하는 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8b1dc08fc655babfcf603618c21cde532ece0972" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;c_extensions#prop_tgt:C_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:C_EXTENSIONS&quot;&gt;&lt;code&gt;C_EXTENSIONS&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;c_extensions#prop_tgt:C_EXTENSIONS&quot; id=&quot;index-1-prop_tgt:C_EXTENSIONS&quot;&gt;&lt;code&gt;C_EXTENSIONS&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJC_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:OBJC_EXTENSIONS&quot;&gt;&lt;code&gt;OBJC_EXTENSIONS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;c_extensions#prop_tgt:C_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:C_EXTENSIONS&quot;&gt; &lt;code&gt;C_EXTENSIONS&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;c_extensions#prop_tgt:C_EXTENSIONS&quot; id=&quot;index-1-prop_tgt:C_EXTENSIONS&quot;&gt; &lt;code&gt;C_EXTENSIONS&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJC_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:OBJC_EXTENSIONS&quot;&gt; &lt;code&gt;OBJC_EXTENSIONS&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0497532004112f39c7e2b1fd699eb26fe291d825" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-0-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-0-prop_tgt:OBJC_STANDARD&quot;&gt;&lt;code&gt;OBJC_STANDARD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-0-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-0-prop_tgt:OBJC_STANDARD&quot;&gt; &lt;code&gt;OBJC_STANDARD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="049e0ee49f668b6bf9a07fac62a736dfb1807cac" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;c_standard_required#prop_tgt:C_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:C_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;C_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;c_standard_required#prop_tgt:C_STANDARD_REQUIRED&quot; id=&quot;index-1-prop_tgt:C_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;C_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJC_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:OBJC_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;OBJC_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;c_standard_required#prop_tgt:C_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:C_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;C_STANDARD_REQUIRED&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;c_standard_required#prop_tgt:C_STANDARD_REQUIRED&quot; id=&quot;index-1-prop_tgt:C_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;C_STANDARD_REQUIRED&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJC_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:OBJC_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;OBJC_STANDARD_REQUIRED&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec42359e90f0b9e4d48ae045be16802a6e5647c8" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;cxx_extensions#prop_tgt:CXX_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:CXX_EXTENSIONS&quot;&gt;&lt;code&gt;CXX_EXTENSIONS&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;cxx_extensions#prop_tgt:CXX_EXTENSIONS&quot; id=&quot;index-1-prop_tgt:CXX_EXTENSIONS&quot;&gt;&lt;code&gt;CXX_EXTENSIONS&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJCXX_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:OBJCXX_EXTENSIONS&quot;&gt;&lt;code&gt;OBJCXX_EXTENSIONS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;cxx_extensions#prop_tgt:CXX_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:CXX_EXTENSIONS&quot;&gt; &lt;code&gt;CXX_EXTENSIONS&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;cxx_extensions#prop_tgt:CXX_EXTENSIONS&quot; id=&quot;index-1-prop_tgt:CXX_EXTENSIONS&quot;&gt; &lt;code&gt;CXX_EXTENSIONS&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJCXX_EXTENSIONS&quot; id=&quot;index-0-prop_tgt:OBJCXX_EXTENSIONS&quot;&gt; &lt;code&gt;OBJCXX_EXTENSIONS&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd9ccea63d6554bfdb2561bee9408bebb77293e" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-0-prop_tgt:OBJCXX_STANDARD&quot;&gt;&lt;code&gt;OBJCXX_STANDARD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-0-prop_tgt:OBJCXX_STANDARD&quot;&gt; &lt;code&gt;OBJCXX_STANDARD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfc36642d73a1280da12bf4b91cffcb1a7b74b5" translate="yes" xml:space="preserve">
          <source>If the property is not set, and the project has set the &lt;a href=&quot;cxx_standard_required#prop_tgt:CXX_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;CXX_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt;, the value of &lt;a href=&quot;cxx_standard_required#prop_tgt:CXX_STANDARD_REQUIRED&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;CXX_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt; is set for &lt;a href=&quot;#prop_tgt:OBJCXX_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:OBJCXX_STANDARD_REQUIRED&quot;&gt;&lt;code&gt;OBJCXX_STANDARD_REQUIRED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 설정되지 않으며, 프로젝트가 설정 한 경우 &lt;a href=&quot;cxx_standard_required#prop_tgt:CXX_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;CXX_STANDARD_REQUIRED&lt;/code&gt; 를&lt;/a&gt; ,의 값 &lt;a href=&quot;cxx_standard_required#prop_tgt:CXX_STANDARD_REQUIRED&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;CXX_STANDARD_REQUIRED&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#prop_tgt:OBJCXX_STANDARD_REQUIRED&quot; id=&quot;index-0-prop_tgt:OBJCXX_STANDARD_REQUIRED&quot;&gt; &lt;code&gt;OBJCXX_STANDARD_REQUIRED&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32ccf7d9cf41398c264ae645659401c9842ada84" translate="yes" xml:space="preserve">
          <source>If the provided &lt;code&gt;&amp;lt;FileName&amp;gt;&lt;/code&gt; is a relative path, it is evaluated relative to the given base directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt;. If no base directory is provided, the default base directory will be &lt;a href=&quot;../variable/cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;&amp;lt;FileName&amp;gt;&lt;/code&gt; 이 상대 경로 인 경우 제공된 기본 디렉토리 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 를 기준으로 평가 됩니다. 기본 디렉토리가 제공되지 않으면 기본 기본 디렉토리는 &lt;a href=&quot;../variable/cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb8106d30205ece490c122f32ea8af6ad8654354" translate="yes" xml:space="preserve">
          <source>If the provided &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is a relative path, it is evaluated relative to the given base directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt;. If no base directory is provided, the default base directory will be &lt;a href=&quot;../variable/cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-1-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 가 상대 경로이면 지정된 기본 디렉토리 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 에 대해 상대적으로 평가 됩니다. 기본 디렉토리가 제공되지 않은 경우 기본 기본 디렉토리는 &lt;a href=&quot;../variable/cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-1-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b42e5baadb9b450227ed74aa5d54e782655b4fb" translate="yes" xml:space="preserve">
          <source>If the required resource can be controlled by CTest you should use &lt;a href=&quot;resource_lock#prop_test:RESOURCE_LOCK&quot; id=&quot;index-0-prop_test:RESOURCE_LOCK&quot;&gt;&lt;code&gt;RESOURCE_LOCK&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#prop_test:TIMEOUT_AFTER_MATCH&quot; id=&quot;index-2-prop_test:TIMEOUT_AFTER_MATCH&quot;&gt;&lt;code&gt;TIMEOUT_AFTER_MATCH&lt;/code&gt;&lt;/a&gt;. This property should be used when only the test itself can determine when its required resources are available.</source>
          <target state="translated">CTest에서 필요한 자원을 제어 할 수있는 경우 &lt;a href=&quot;#prop_test:TIMEOUT_AFTER_MATCH&quot; id=&quot;index-2-prop_test:TIMEOUT_AFTER_MATCH&quot;&gt; &lt;code&gt;TIMEOUT_AFTER_MATCH&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;resource_lock#prop_test:RESOURCE_LOCK&quot; id=&quot;index-0-prop_test:RESOURCE_LOCK&quot;&gt; &lt;code&gt;RESOURCE_LOCK&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 . 테스트 자체만으로 필요한 자원이 사용 가능한시기를 판별 할 수있는 경우이 특성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8be5e3d26119a719d5d82ac446c736b74f653767" translate="yes" xml:space="preserve">
          <source>If the running version of CMake is lower than the &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt; required version it will stop processing the project and report an error. The optional &lt;code&gt;&amp;lt;max&amp;gt;&lt;/code&gt; version, if specified, must be at least the &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt; version and affects policy settings as described below. If the running version of CMake is older than 3.12, the extra &lt;code&gt;...&lt;/code&gt; dots will be seen as version component separators, resulting in the &lt;code&gt;...&amp;lt;max&amp;gt;&lt;/code&gt; part being ignored and preserving the pre-3.12 behavior of basing policies on &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">실행중인 CMake 버전이 &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt; 필수 버전 보다 낮 으면 프로젝트 처리가 중지되고 오류가보고됩니다. 선택적 &lt;code&gt;&amp;lt;max&amp;gt;&lt;/code&gt; 버전은 지정된 경우 &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt; 버전 이상이어야하며 아래 설명 된대로 정책 설정에 영향을줍니다. CMake의 실행 버전이 3.12보다 오래된 경우 추가 &lt;code&gt;...&lt;/code&gt; 도트가 버전 구성 요소 구분 기호로 표시되어 &lt;code&gt;...&amp;lt;max&amp;gt;&lt;/code&gt; 부분이 무시되고 &lt;code&gt;&amp;lt;min&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207467c7e9547d09795fdda12450ebc1075cbdcb" translate="yes" xml:space="preserve">
          <source>If the same sources are used to create both a shared and a static library, the uppercased symbol &lt;code&gt;${BASE_NAME}_STATIC_DEFINE&lt;/code&gt; should be used when building the static library:</source>
          <target state="translated">동일한 소스를 사용하여 공유 라이브러리와 정적 라이브러리를 모두 작성 하는 경우 정적 라이브러리를 빌드 할 때 대문자 기호 &lt;code&gt;${BASE_NAME}_STATIC_DEFINE&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2298d1fe31990959aacf4b9e2c7d2d193e6ed609" translate="yes" xml:space="preserve">
          <source>If the set of inputs includes directories, this variable will specify patterns used to exclude files from them. The following patterns are added by &lt;code&gt;doxygen_add_docs()&lt;/code&gt; to ensure CMake-specific files and directories are not included in the input. If the project sets &lt;code&gt;DOXYGEN_EXCLUDE_PATTERNS&lt;/code&gt;, those contents are merged with these additional patterns rather than replacing them:</source>
          <target state="translated">입력 세트에 디렉토리가 포함 된 경우이 변수는 파일을 제외시키는 데 사용되는 패턴을 지정합니다. CMake 특정 파일 및 디렉토리가 입력에 포함되지 않도록 &lt;code&gt;doxygen_add_docs()&lt;/code&gt; 에 의해 다음 패턴이 추가됩니다 . 프로젝트가 &lt;code&gt;DOXYGEN_EXCLUDE_PATTERNS&lt;/code&gt; 를 설정 하면 해당 컨텐츠는 다음과 같은 추가 패턴과 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00d7e06570a5af7561acdbf87c2b9cfea40ede92" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; changes and no &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; is given, a message will be printed to inform about the change.</source>
          <target state="translated">지정된 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 변경되고 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 변경 사항 을 알리는 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdc76dbc6acd34cdbaf058b7a4e31b4bf743d18" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; changes, a message will be printed to inform about the change.</source>
          <target state="translated">지정된 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 변경되면 변경 내용을 알리는 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ccf9fd78c805bc88c8880bd3e8adfd660d4657" translate="yes" xml:space="preserve">
          <source>If the specified location is equal to &lt;code&gt;Resources&lt;/code&gt;, the resulting location will be the same as if the &lt;a href=&quot;../prop_tgt/resource#prop_tgt:RESOURCE&quot; id=&quot;index-1-prop_tgt:RESOURCE&quot;&gt;&lt;code&gt;RESOURCE&lt;/code&gt;&lt;/a&gt; property had been used. If the specified location is a sub-folder of &lt;code&gt;Resources&lt;/code&gt;, it will be placed into the respective sub-folder. Note: For iOS Apple uses a flat bundle layout where no &lt;code&gt;Resources&lt;/code&gt; folder exist. Therefore CMake strips the &lt;code&gt;Resources&lt;/code&gt; folder name from the specified location.</source>
          <target state="translated">지정된 위치가 &lt;code&gt;Resources&lt;/code&gt; 와 같으면 결과 위치는 &lt;a href=&quot;../prop_tgt/resource#prop_tgt:RESOURCE&quot; id=&quot;index-1-prop_tgt:RESOURCE&quot;&gt; &lt;code&gt;RESOURCE&lt;/code&gt; &lt;/a&gt; 특성이 사용 된 것과 같습니다 . 지정된 위치가 &lt;code&gt;Resources&lt;/code&gt; 의 하위 폴더 인 경우 해당 하위 폴더에 배치됩니다. 참고 : iOS의 경우 Apple은 &lt;code&gt;Resources&lt;/code&gt; 폴더가 없는 플랫 번들 레이아웃을 사용 합니다. 따라서 CMake 는 지정된 위치에서 &lt;code&gt;Resources&lt;/code&gt; 폴더 이름을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1b3666bf44a169eb8d893fa7a3718ab95d2192cc" translate="yes" xml:space="preserve">
          <source>If the sub-project&amp;rsquo;s &lt;code&gt;CMakeLists.txt&lt;/code&gt; file is not at the top level of its source tree, the &lt;code&gt;SOURCE_SUBDIR&lt;/code&gt; option can be used to tell &lt;code&gt;FetchContent&lt;/code&gt; where to find it. The following example shows how to use that option and it also sets a variable which is meaningful to the subproject before pulling it into the main build:</source>
          <target state="translated">하위 프로젝트의 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일이 소스 트리의 최상위 수준에 있지 않은 경우 &lt;code&gt;SOURCE_SUBDIR&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;FetchContent&lt;/code&gt; 를 찾을 위치를 알릴 수 있습니다. 다음 예제는 해당 옵션을 사용하는 방법을 보여 주며, 기본 빌드로 가져 오기 전에 하위 프로젝트에 의미있는 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cd3da126920da25b9730e37e60af1cacc71aa7f8" translate="yes" xml:space="preserve">
          <source>If the target contains Fortran source files that provide modules and the compiler supports a module output directory this specifies the directory in which the modules will be placed. When this property is not set the modules will be placed in the build directory corresponding to the target&amp;rsquo;s source directory. If the variable &lt;a href=&quot;../variable/cmake_fortran_module_directory#variable:CMAKE_Fortran_MODULE_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_Fortran_MODULE_DIRECTORY&quot;&gt;&lt;code&gt;CMAKE_Fortran_MODULE_DIRECTORY&lt;/code&gt;&lt;/a&gt; is set when a target is created its value is used to initialize this property.</source>
          <target state="translated">대상에 모듈을 제공하는 포트란 소스 파일이 포함되어 있고 컴파일러가 모듈 출력 디렉토리를 지원하는 경우 모듈이 배치 될 디렉토리를 지정합니다. 이 특성을 설정하지 않으면 대상 소스 디렉토리에 해당하는 빌드 디렉토리에 모듈이 배치됩니다. 대상이 작성 될 때 변수 &lt;a href=&quot;../variable/cmake_fortran_module_directory#variable:CMAKE_Fortran_MODULE_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_Fortran_MODULE_DIRECTORY&quot;&gt; &lt;code&gt;CMAKE_Fortran_MODULE_DIRECTORY&lt;/code&gt; &lt;/a&gt; 가 설정되면 값이이 특성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9844821a39bedb63cafe3de6279c81b7e3d3637e" translate="yes" xml:space="preserve">
          <source>If the target contains ISPC source files, this specifies the directory in which the generated headers will be placed. Relative paths are treated with respect to the value of &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt;. When this property is not set, the headers will be placed a generator defined build directory. If the variable &lt;a href=&quot;../variable/cmake_ispc_header_directory#variable:CMAKE_ISPC_HEADER_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_ISPC_HEADER_DIRECTORY&quot;&gt;&lt;code&gt;CMAKE_ISPC_HEADER_DIRECTORY&lt;/code&gt;&lt;/a&gt; is set when a target is created its value is used to initialize this property.</source>
          <target state="translated">대상에 ISPC 소스 파일이 포함 된 경우 생성 된 헤더가 배치 될 디렉토리를 지정합니다. 상대 경로는 &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; &lt;/a&gt; 값과 관련하여 처리됩니다 . 이 속성이 설정되지 않은 경우 헤더는 생성기 정의 빌드 디렉터리에 배치됩니다. 대상이 생성 될 때 &lt;a href=&quot;../variable/cmake_ispc_header_directory#variable:CMAKE_ISPC_HEADER_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_ISPC_HEADER_DIRECTORY&quot;&gt; &lt;code&gt;CMAKE_ISPC_HEADER_DIRECTORY&lt;/code&gt; &lt;/a&gt; 변수 가 설정되면 해당 값이이 속성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="daa6481f338aeb14d63c02c3f44c0c9606ed58b0" translate="yes" xml:space="preserve">
          <source>If the target contains Swift source files, this specifies the directory in which the modules will be placed. When this property is not set, the modules will be placed in the build directory corresponding to the target&amp;rsquo;s source directory. If the variable &lt;a href=&quot;../variable/cmake_swift_module_directory#variable:CMAKE_Swift_MODULE_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_Swift_MODULE_DIRECTORY&quot;&gt;&lt;code&gt;CMAKE_Swift_MODULE_DIRECTORY&lt;/code&gt;&lt;/a&gt; is set when a target is created its value is used to initialise this property.</source>
          <target state="translated">대상에 Swift 소스 파일이 포함되어 있으면 모듈이 배치 될 디렉토리를 지정합니다. 이 특성을 설정하지 않으면 대상 소스 디렉토리에 해당하는 빌드 디렉토리에 모듈이 배치됩니다. 대상이 작성 될 때 변수 &lt;a href=&quot;../variable/cmake_swift_module_directory#variable:CMAKE_Swift_MODULE_DIRECTORY&quot; id=&quot;index-0-variable:CMAKE_Swift_MODULE_DIRECTORY&quot;&gt; &lt;code&gt;CMAKE_Swift_MODULE_DIRECTORY&lt;/code&gt; &lt;/a&gt; 가 설정되면 값이이 특성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1a7596a56f08cfdb95ae654e69a25397b52100" translate="yes" xml:space="preserve">
          <source>If the target is a JNI library, utilize the following commands to create a JNI symbolic link:</source>
          <target state="translated">대상이 JNI 라이브러리 인 경우 다음 명령을 사용하여 JNI 기호 링크를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c71f7de5e1a977c08481189823c8eb86e2ad1711" translate="yes" xml:space="preserve">
          <source>If the target platform doesn&amp;rsquo;t support deployment, this property won&amp;rsquo;t have any effect.</source>
          <target state="translated">대상 플랫폼이 배포를 지원하지 않는 경우이 속성은 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a39c500f09285496f819a8ea4b55310886000f8" translate="yes" xml:space="preserve">
          <source>If the use of the -pthread compiler and linker flag is preferred then the caller can set</source>
          <target state="translated">-pthread 컴파일러 및 링커 플래그 사용이 선호되는 경우 호출자가 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d34dfaaf7fe6d9f0a7d65e18862b94d7c44c5f9" translate="yes" xml:space="preserve">
          <source>If the use of the -pthread compiler and linker flag is preferred then the caller can set this variable to TRUE. The compiler flag can only be used with the imported target. Use of both the imported target as well as this switch is highly recommended for new code.</source>
          <target state="translated">-pthread 컴파일러 및 링커 플래그 사용이 선호되는 경우 호출자는이 변수를 TRUE로 설정할 수 있습니다. 컴파일러 플래그는 가져온 대상에만 사용할 수 있습니다. 새 코드에는 가져온 대상과이 스위치를 모두 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14e7c7f865a33eeeb669d351cf0a8bc392c36e25" translate="yes" xml:space="preserve">
          <source>If the value requested does not result in a compile flag being added for the compiler in use, a previous standard flag will be added instead. This means that using:</source>
          <target state="translated">요청 된 값으로 인해 사용중인 컴파일러에 대해 컴파일 플래그가 추가되지 않으면 이전 표준 플래그가 대신 추가됩니다. 이것은 다음을 사용하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="114d2105a920f81751ee48b2fa305a19bdeae44f" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;CMAKE_GNUtoMS&lt;/code&gt; is set when a target is created its value is used to initialize this property. The variable must be set prior to the first command that enables a language such as &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt;&lt;code&gt;enable_language()&lt;/code&gt;&lt;/a&gt;. CMake provides the variable as an option to the user automatically when configuring on Windows with GNU tools.</source>
          <target state="translated">대상이 작성 될 때 변수 &lt;code&gt;CMAKE_GNUtoMS&lt;/code&gt; 가 설정되면 해당 값이이 특성을 초기화하는 데 사용됩니다. &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt; &lt;code&gt;enable_language()&lt;/code&gt; &lt;/a&gt; 와 같은 언어를 활성화하는 첫 번째 명령 전에 변수를 설정해야합니다 . CMake는 GNU 도구를 사용하여 Windows에서 구성 할 때 사용자에게 자동으로 변수를 옵션으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d104b425cb6e48eb4e180bf39c26c7f7e32ceb8" translate="yes" xml:space="preserve">
          <source>If the xmllint command-line executable has been found</source>
          <target state="translated">xmllint 명령 줄 실행 파일이 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="7884e3bafb039371675f08ebebfb72cbe801ce39" translate="yes" xml:space="preserve">
          <source>If the xsltproc command-line executable has been found</source>
          <target state="translated">xsltproc 명령 줄 실행 파일이 발견 된 경우</target>
        </trans-unit>
        <trans-unit id="ad162c06ca8a2bd7caddbaf8ccc9ed92df99495c" translate="yes" xml:space="preserve">
          <source>If this is an &lt;a href=&quot;../manual/cmake-buildsystem.7#alias-targets&quot;&gt;Alias Target&lt;/a&gt;, this property contains the name of the target aliased.</source>
          <target state="translated">이는 경우 &lt;a href=&quot;../manual/cmake-buildsystem.7#alias-targets&quot;&gt;별칭 대상&lt;/a&gt; 이 속성은 별칭 대상의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f4e35d3ca4120e1451c8ad4af6c52f0fe815b898" translate="yes" xml:space="preserve">
          <source>If this is defined, then no SDL_main will be linked in because only applications need main(). Otherwise, it is assumed you are building an application and this module will attempt to locate and set the proper link flags as part of the returned SDL_LIBRARY variable.</source>
          <target state="translated">이것이 정의되면 응용 프로그램에만 main ()이 필요하기 때문에 SDL_main이 연결되지 않습니다. 그렇지 않으면 응용 프로그램을 빌드하고 있다고 가정하고이 모듈은 반환 된 SDL_LIBRARY 변수의 일부로 적절한 링크 플래그를 찾고 설정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c1b9c29febe69f2811dc139ec834f6ae9303348c" translate="yes" xml:space="preserve">
          <source>If this is not set, the test will be run with the working directory set to the binary directory associated with where the test was created (i.e. the &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt; for where &lt;a href=&quot;../command/add_test#command:add_test&quot; id=&quot;index-0-command:add_test&quot;&gt;&lt;code&gt;add_test()&lt;/code&gt;&lt;/a&gt; was called).</source>
          <target state="translated">이 설정되어 있지 않은 경우, 시험은 (즉, 테스트가 생성 된 위치와 관련된 바이너리 디렉토리로 작업 디렉토리 설정과 실행됩니다 &lt;a href=&quot;../variable/cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; &lt;/a&gt; 경우에 대한 &lt;a href=&quot;../command/add_test#command:add_test&quot; id=&quot;index-0-command:add_test&quot;&gt; &lt;code&gt;add_test()&lt;/code&gt; &lt;/a&gt; 호출 된).</target>
        </trans-unit>
        <trans-unit id="745c10103d92eb5d1a49a6fd3de949b83bb8284c" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;TRUE&lt;/code&gt;, then the rpath information is not added to compiled executables. The default is to add rpath information if the platform supports it. This allows for easy running from the build tree. To omit RPATH in the install step, but not the build step, use &lt;a href=&quot;cmake_skip_install_rpath#variable:CMAKE_SKIP_INSTALL_RPATH&quot; id=&quot;index-0-variable:CMAKE_SKIP_INSTALL_RPATH&quot;&gt;&lt;code&gt;CMAKE_SKIP_INSTALL_RPATH&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이것이 &lt;code&gt;TRUE&lt;/code&gt; 로 설정 되면 rpath 정보는 컴파일 된 실행 파일에 추가되지 않습니다. 플랫폼이 지원하는 경우 기본값은 rpath 정보를 추가하는 것입니다. 이를 통해 빌드 트리에서 쉽게 실행할 수 있습니다. 설치 단계에서 RPATH를 생략하지만 빌드 단계는 생략하려면 &lt;a href=&quot;cmake_skip_install_rpath#variable:CMAKE_SKIP_INSTALL_RPATH&quot; id=&quot;index-0-variable:CMAKE_SKIP_INSTALL_RPATH&quot;&gt; &lt;code&gt;CMAKE_SKIP_INSTALL_RPATH&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7a6e673595436e0a99cea485ec03f1adeaa4667c" translate="yes" xml:space="preserve">
          <source>If this is set, no download or update steps are performed for the specified content and the &lt;code&gt;&amp;lt;lcName&amp;gt;_SOURCE_DIR&lt;/code&gt; variable returned to the caller is pointed at this location. This gives developers a way to have a separate checkout of the content that they can modify freely without interference from the build. The build simply uses that existing source, but it still defines &lt;code&gt;&amp;lt;lcName&amp;gt;_BINARY_DIR&lt;/code&gt; to point inside its own build area. Developers are strongly encouraged to use this mechanism rather than editing the sources populated in the default location, as changes to sources in the default location can be lost when content population details are changed by the project.</source>
          <target state="translated">이를 설정하면 지정된 컨텐츠에 대해 다운로드 또는 업데이트 단계가 수행되지 않으며 호출자에게 리턴 된 &lt;code&gt;&amp;lt;lcName&amp;gt;_SOURCE_DIR&lt;/code&gt; 변수가이 위치를 가리 킵니다 . 이를 통해 개발자는 빌드의 방해없이 자유롭게 수정할 수있는 컨텐츠를 별도로 체크 아웃 할 수 있습니다. 빌드는 단순히 기존 소스를 사용하지만 여전히 자체 빌드 영역 내부를 가리 &lt;code&gt;&amp;lt;lcName&amp;gt;_BINARY_DIR&lt;/code&gt; 도록 &amp;lt;lcName&amp;gt; _BINARY_DIR 을 정의 합니다. 프로젝트에서 컨텐츠 채우기 세부 사항을 변경하면 기본 위치의 소스에 대한 변경 사항이 유실 될 수 있으므로 개발자는 기본 위치에 채워진 소스를 편집하는 대신이 메커니즘을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="59453de23b218ed0ac388cabb6e9384f17c93393" translate="yes" xml:space="preserve">
          <source>If this module replaces an older version, you should set compatibility variables to cause the least disruption possible.</source>
          <target state="translated">이 모듈이 이전 버전을 대체하는 경우 가능한 최소한의 중단을 유발하도록 호환성 변수를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d88a3acf88a63b9fc172526711ef1c0d7152f074" translate="yes" xml:space="preserve">
          <source>If this option is specified, any &lt;code&gt;-DLINK_LIBRARIES=...&lt;/code&gt; value given to the &lt;code&gt;CMAKE_FLAGS&lt;/code&gt; option will be ignored.</source>
          <target state="translated">이 옵션을 지정하면 어떤 &lt;code&gt;-DLINK_LIBRARIES=...&lt;/code&gt; 받는 주어진 값 &lt;code&gt;CMAKE_FLAGS&lt;/code&gt; 의 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="97274455e8968ea5618ce0fc8f030ed428982daf" translate="yes" xml:space="preserve">
          <source>If this property contains a &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;semicolon-separated list&lt;/a&gt;, then the first value is the command and remaining values are its arguments.</source>
          <target state="translated">이 특성에 &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;세미콜론으로 구분 된 list&lt;/a&gt; 가 포함 된 경우 첫 번째 값은 명령이고 나머지 값은 해당 인수입니다.</target>
        </trans-unit>
        <trans-unit id="02268b70ca35116337a6c0574a877c73a06db6d5" translate="yes" xml:space="preserve">
          <source>If this property is not set and policy &lt;a href=&quot;../policy/cmp0068#policy:CMP0068&quot; id=&quot;index-0-policy:CMP0068&quot;&gt;&lt;code&gt;CMP0068&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;NEW&lt;/code&gt;, the value of &lt;a href=&quot;build_with_install_rpath#prop_tgt:BUILD_WITH_INSTALL_RPATH&quot; id=&quot;index-0-prop_tgt:BUILD_WITH_INSTALL_RPATH&quot;&gt;&lt;code&gt;BUILD_WITH_INSTALL_RPATH&lt;/code&gt;&lt;/a&gt; is used in its place.</source>
          <target state="translated">이 특성이 설정되지 않고 정책 &lt;a href=&quot;../policy/cmp0068#policy:CMP0068&quot; id=&quot;index-0-policy:CMP0068&quot;&gt; &lt;code&gt;CMP0068&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;NEW&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;build_with_install_rpath#prop_tgt:BUILD_WITH_INSTALL_RPATH&quot; id=&quot;index-0-prop_tgt:BUILD_WITH_INSTALL_RPATH&quot;&gt; &lt;code&gt;BUILD_WITH_INSTALL_RPATH&lt;/code&gt; &lt;/a&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f6caee9db62b40c92a94a92e9c266163861ed210" translate="yes" xml:space="preserve">
          <source>If this property is not set by the user, it will be calculated at generate-time by CMake.</source>
          <target state="translated">이 속성을 사용자가 설정하지 않으면 CMake에 의해 생성시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5fb0fd7d35d4bc47da151d89ec484436b9593c41" translate="yes" xml:space="preserve">
          <source>If this property is not set then CMake uses the default value &lt;code&gt;MultiThreaded$&amp;lt;$&amp;lt;CONFIG:Debug&amp;gt;:Debug&amp;gt;DLL&lt;/code&gt; to select a MSVC runtime library.</source>
          <target state="translated">이 속성을 설정하지 않으면 CMake는 기본값 &lt;code&gt;MultiThreaded$&amp;lt;$&amp;lt;CONFIG:Debug&amp;gt;:Debug&amp;gt;DLL&lt;/code&gt; 을 사용하여 MSVC 런타임 라이브러리를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0877ba77bc191c7ba32fd37baa76796533e02233" translate="yes" xml:space="preserve">
          <source>If this property is not specified, then the &lt;code&gt;ALL_BUILD&lt;/code&gt; project will be the default.</source>
          <target state="translated">이 특성을 지정하지 않으면 &lt;code&gt;ALL_BUILD&lt;/code&gt; 프로젝트가 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="592090a25fd3802a73c2bfc99e16a50175da1890" translate="yes" xml:space="preserve">
          <source>If this property is set and no matching configurations are available, then the imported target is considered to be not found. This property is ignored for non-imported targets.</source>
          <target state="translated">이 특성이 설정되고 사용 가능한 일치 구성이 없으면 가져온 대상을 찾을 수없는 것으로 간주됩니다. 가져 오지 않은 대상의 경우이 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="820a9972664d6cbf958a6bb5a562203e75229aaa" translate="yes" xml:space="preserve">
          <source>If this property is set then the file extension of the output file will be the same as that of the source file. Normally the output file extension is computed based on the language of the source file, for example &lt;code&gt;.cxx&lt;/code&gt; will go to a &lt;code&gt;.o&lt;/code&gt; extension.</source>
          <target state="translated">이 특성을 설정하면 출력 파일의 파일 확장자는 소스 파일의 파일 확장자와 동일합니다. 일반적으로 출력 파일 확장자는 소스 파일의 언어를 기반으로 계산됩니다. 예를 들어 &lt;code&gt;.cxx&lt;/code&gt; 는 &lt;code&gt;.o&lt;/code&gt; 확장자 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="658e8a2d36d2ad08725c045c682a347f19bb198b" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-2-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC 1800 (Visual Studio 2013) and lower, this has no effect.</source>
          <target state="translated">이 속성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 이거나 설정되지 않은 경우 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-2-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 처리되며 요청 된 항목을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;될 수 있습니다. MSVC 1800 (Visual Studio 2013) 이하와 같이 표준 수준의 개념이없는 컴파일러의 경우 이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d6a42e06b5c10209d3ab38741c6c6ba27900d29" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-2-prop_tgt:C_STANDARD&quot;&gt;&lt;code&gt;C_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC, this has no effect.</source>
          <target state="translated">이 특성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-1-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 특성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 있거나 설정되어 &lt;a href=&quot;c_standard#prop_tgt:C_STANDARD&quot; id=&quot;index-2-prop_tgt:C_STANDARD&quot;&gt; &lt;code&gt;C_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 취급되며 요청 된 내용을 사용할 수없는 경우 이전 표준으로 &quot;부패&quot;될 수 있습니다. MSVC와 같은 표준 수준의 개념이없는 컴파일러의 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="145d811465431e86fc13853360d3c9316e821033" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-1-prop_tgt:CUDA_STANDARD&quot;&gt;&lt;code&gt;CUDA_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-2-prop_tgt:CUDA_STANDARD&quot;&gt;&lt;code&gt;CUDA_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC 1800 (Visual Studio 2013) and lower, this has no effect.</source>
          <target state="translated">이 속성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-1-prop_tgt:CUDA_STANDARD&quot;&gt; &lt;code&gt;CUDA_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 이거나 설정되지 않은 경우 &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-2-prop_tgt:CUDA_STANDARD&quot;&gt; &lt;code&gt;CUDA_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 처리되며 요청 된 항목을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;될 수 있습니다. MSVC 1800 (Visual Studio 2013) 이하와 같이 표준 수준의 개념이없는 컴파일러의 경우 이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e789f2277be6ed3ee3e768be774436b4f0f21d8d" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-1-prop_tgt:CUDA_STANDARD&quot;&gt;&lt;code&gt;CUDA_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-2-prop_tgt:CUDA_STANDARD&quot;&gt;&lt;code&gt;CUDA_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC, this has no effect.</source>
          <target state="translated">이 특성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-1-prop_tgt:CUDA_STANDARD&quot;&gt; &lt;code&gt;CUDA_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 특성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 있거나 설정되어 &lt;a href=&quot;cuda_standard#prop_tgt:CUDA_STANDARD&quot; id=&quot;index-2-prop_tgt:CUDA_STANDARD&quot;&gt; &lt;code&gt;CUDA_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 취급되며 요청 된 내용을 사용할 수없는 경우 이전 표준으로 &quot;부패&quot;될 수 있습니다. MSVC와 같은 표준 수준의 개념이없는 컴파일러의 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ba3638dfc1a2afbae87268bf97ac87b97068827" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-2-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC 1800 (Visual Studio 2013) and lower, this has no effect.</source>
          <target state="translated">이 속성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 이거나 설정되지 않은 경우 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-2-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 처리되며 요청 된 항목을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;할 수 있습니다. MSVC 1800 (Visual Studio 2013) 이하와 같이 표준 수준의 개념이없는 컴파일러의 경우 이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d131467a32c41578579e973fff81b62c2e1e2267" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-2-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available. For compilers that have no notion of a standard level, such as MSVC, this has no effect.</source>
          <target state="translated">이 특성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-1-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 특성 의 값이 요구 사항으로 처리됩니다. 이 특성이 &lt;code&gt;OFF&lt;/code&gt; 또는 설정되지 않은 경우 &lt;a href=&quot;cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-2-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 특성은 선택 사항으로 취급되며 요청 된 사항을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;할 수 있습니다. MSVC와 같은 표준 수준의 개념이없는 컴파일러의 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="86ba2f08b9d7f81f07e86407de99a71f9769d698" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;objc_standard#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-1-prop_tgt:OBJC_STANDARD&quot;&gt;&lt;code&gt;OBJC_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;objc_standard#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-2-prop_tgt:OBJC_STANDARD&quot;&gt;&lt;code&gt;OBJC_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available.</source>
          <target state="translated">이 속성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;objc_standard#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-1-prop_tgt:OBJC_STANDARD&quot;&gt; &lt;code&gt;OBJC_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 이거나 설정되지 않은 경우 &lt;a href=&quot;objc_standard#prop_tgt:OBJC_STANDARD&quot; id=&quot;index-2-prop_tgt:OBJC_STANDARD&quot;&gt; &lt;code&gt;OBJC_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 처리되며 요청 된 항목을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="347daf2af7a3e526d3e2191f310081ad4d88de7c" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;ON&lt;/code&gt;, then the value of the &lt;a href=&quot;objcxx_standard#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-1-prop_tgt:OBJCXX_STANDARD&quot;&gt;&lt;code&gt;OBJCXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as a requirement. If this property is &lt;code&gt;OFF&lt;/code&gt; or unset, the &lt;a href=&quot;objcxx_standard#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-2-prop_tgt:OBJCXX_STANDARD&quot;&gt;&lt;code&gt;OBJCXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property is treated as optional and may &amp;ldquo;decay&amp;rdquo; to a previous standard if the requested is not available.</source>
          <target state="translated">이 속성이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;a href=&quot;objcxx_standard#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-1-prop_tgt:OBJCXX_STANDARD&quot;&gt; &lt;code&gt;OBJCXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성 의 값이 요구 사항으로 처리됩니다. 이 속성이 &lt;code&gt;OFF&lt;/code&gt; 이거나 설정되지 않은 경우 &lt;a href=&quot;objcxx_standard#prop_tgt:OBJCXX_STANDARD&quot; id=&quot;index-2-prop_tgt:OBJCXX_STANDARD&quot;&gt; &lt;code&gt;OBJCXX_STANDARD&lt;/code&gt; &lt;/a&gt; 대상 속성은 선택 사항으로 처리되며 요청 된 항목을 사용할 수없는 경우 이전 표준으로 &quot;감소&quot;될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc944da24605fc0f876ed05a8face444342d576" translate="yes" xml:space="preserve">
          <source>If this property is set to &lt;code&gt;True&lt;/code&gt; then the source file is really an object file and should not be compiled. It will still be linked into the target though.</source>
          <target state="translated">이 특성이 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 소스 파일은 실제로 오브젝트 파일이므로 컴파일해서는 안됩니다. 그래도 여전히 대상에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="107bfb6b511bbd6e540c0ab9e2fe9b7f95739303" translate="yes" xml:space="preserve">
          <source>If this property is set to a filename then when CMake runs it will report any properties or variables that were accessed but not defined into the filename specified in this property.</source>
          <target state="translated">이 속성이 파일 이름으로 설정되면 CMake가 실행될 때 액세스되었지만이 속성에 지정된 파일 이름으로 정의되지 않은 속성 또는 변수가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="560c52752d48fd93e310cc9f26dc969491d66e9d" translate="yes" xml:space="preserve">
          <source>If this target property is not set then the target will be included in the &amp;ldquo;all&amp;rdquo; target of the containing directory. Furthermore, it will be included in the &amp;ldquo;all&amp;rdquo; target of its ancestor directories unless the &lt;a href=&quot;../prop_dir/exclude_from_all#prop_dir:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_dir:EXCLUDE_FROM_ALL&quot;&gt;&lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt;&lt;/a&gt; directory property is set.</source>
          <target state="translated">이 대상 속성이 설정되지 않은 경우 대상은 포함하는 디렉터리의 &quot;모든&quot;대상에 포함됩니다. 또한 &lt;a href=&quot;../prop_dir/exclude_from_all#prop_dir:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_dir:EXCLUDE_FROM_ALL&quot;&gt; &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; &lt;/a&gt; 디렉터리 속성이 설정되어 있지 않으면 상위 디렉터리의 &quot;모든&quot;대상에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="87359b9ef527cebb071fbdadf08ba713fbbb2421" translate="yes" xml:space="preserve">
          <source>If this variable contains a &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;semicolon-separated list&lt;/a&gt;, then the first value is the command and remaining values are its arguments.</source>
          <target state="translated">이 변수에 &lt;a href=&quot;../manual/cmake-language.7#cmake-language-lists&quot;&gt;세미콜론으로 구분 된 list&lt;/a&gt; 가 포함 된 경우 첫 번째 값은 명령이고 나머지 값은 해당 인수입니다.</target>
        </trans-unit>
        <trans-unit id="3d8c7aec3d039fc5873940fa9d82eebb1dee56bb" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to &lt;code&gt;ON&lt;/code&gt; at the end of the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt; file, CMake will not add the regeneration target to the build system or perform any build system checks.</source>
          <target state="translated">최상위 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일 끝 에서이 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 평가 되면 CMake는 재생성 대상을 빌드 시스템에 추가하거나 빌드 시스템 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb2ad5711d88b8f590b0746cf172c9737874cfaf" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to &lt;code&gt;ON&lt;/code&gt; at the end of the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt; file, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Sublime%20Text%202.html#generator:Sublime%20Text%202&quot; id=&quot;index-0-generator:Sublime Text 2&quot;&gt;&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;/a&gt; extra generator excludes the build tree from the &lt;code&gt;.sublime-project&lt;/code&gt; if it is inside the source tree.</source>
          <target state="translated">최상위 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일 의 끝 에서이 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 평가 되면 &lt;a href=&quot;https://cmake.org/cmake/help/v3.15/generator/Sublime%20Text%202.html#generator:Sublime%20Text%202&quot; id=&quot;index-0-generator:Sublime Text 2&quot;&gt; &lt;code&gt;Sublime Text 2&lt;/code&gt; &lt;/a&gt; 추가 생성기는 빌드 트리 가 소스 트리 안에있는 경우 &lt;code&gt;.sublime-project&lt;/code&gt; 에서 빌드 트리를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="2904a0f8228c6fbb9ac3939861bb0efac8b1629b" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to &lt;code&gt;ON&lt;/code&gt; at the end of the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt; file, the &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Sublime%20Text%202.html#generator:Sublime%20Text%202&quot; id=&quot;index-0-generator:Sublime Text 2&quot;&gt;&lt;code&gt;Sublime Text 2&lt;/code&gt;&lt;/a&gt; extra generator excludes the build tree from the &lt;code&gt;.sublime-project&lt;/code&gt; if it is inside the source tree.</source>
          <target state="translated">이 변수 가 최상위 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일 의 끝에서 &lt;code&gt;ON&lt;/code&gt; 으로 평가 되면 &lt;a href=&quot;https://cmake.org/cmake/help/v3.19/generator/Sublime%20Text%202.html#generator:Sublime%20Text%202&quot; id=&quot;index-0-generator:Sublime Text 2&quot;&gt; &lt;code&gt;Sublime Text 2&lt;/code&gt; &lt;/a&gt; 추가 생성기 가 소스 트리 내부에있는 경우 &lt;code&gt;.sublime-project&lt;/code&gt; 에서 빌드 트리를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="4b615dd880b2243378d765b82fda9e8c5a2d1234" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to &lt;code&gt;ON&lt;/code&gt; at the end of the top-level &lt;code&gt;CMakeLists.txt&lt;/code&gt; file, the generator creates projectfiles based on targets rather than projects.</source>
          <target state="translated">최상위 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일 의 끝 에서이 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 평가 되면 생성기는 프로젝트가 아닌 대상을 기반으로 프로젝트 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="37c5da609c3b89432b44db6580bc4df9d53f0495" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to &lt;code&gt;ON&lt;/code&gt; the generator excludes from the project file any files that are located outside the project root.</source>
          <target state="translated">이 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 평가 되면 생성기는 프로젝트 루트에서 프로젝트 루트 외부에있는 파일을 제외시킵니다.</target>
        </trans-unit>
        <trans-unit id="8ee0173b82daab8d7fbb371bf7a330d485119fa7" translate="yes" xml:space="preserve">
          <source>If this variable evaluates to a boolean true value, all status messages associated with the check will be suppressed.</source>
          <target state="translated">이 변수가 부울 true 값으로 평가되면 검사와 관련된 모든 상태 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b34710e66ed10fd7cd7c19061ff369063979df1" translate="yes" xml:space="preserve">
          <source>If this variable is defined empty the native build tool&amp;rsquo;s default number is used.</source>
          <target state="translated">이 변수가 비어 있으면 기본 빌드 도구의 기본 번호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f91bdd0ce5abf26abfd69add0e827de6d945adc" translate="yes" xml:space="preserve">
          <source>If this variable is enabled, CMake automatically adds &lt;a href=&quot;cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt; to the include path for each directory. These additional include directories do not propagate down to subdirectories. This is useful mainly for out-of-source builds, where files generated into the build tree are included by files located in the source tree.</source>
          <target state="translated">이 변수가 활성화되면 CMake는 &lt;a href=&quot;cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; &lt;/a&gt; 을 각 디렉토리의 포함 경로에 자동으로 추가합니다 . 이러한 추가 포함 디렉토리는 하위 디렉토리로 전파되지 않습니다. 이는 주로 소스 트리에있는 파일에 의해 빌드 트리에 생성 된 파일이 포함되는 소스 외부 빌드에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f0cb48cb8df1fb274ff087420ce81109e01481d" translate="yes" xml:space="preserve">
          <source>If this variable is enabled, CMake automatically adds for each shared library target, static library target, module target and executable target, &lt;a href=&quot;cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt;&lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; target property. By default &lt;code&gt;CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE&lt;/code&gt; is &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">이 변수가 사용 가능한 경우 CMake는 각 공유 라이브러리 대상, 정적 라이브러리 대상, 모듈 대상 및 실행 가능 대상 &lt;a href=&quot;cmake_current_source_dir#variable:CMAKE_CURRENT_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_SOURCE_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cmake_current_binary_dir#variable:CMAKE_CURRENT_BINARY_DIR&quot; id=&quot;index-0-variable:CMAKE_CURRENT_BINARY_DIR&quot;&gt; &lt;code&gt;CMAKE_CURRENT_BINARY_DIR&lt;/code&gt; &lt;/a&gt; 에 대해 &lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; 대상 특성에 자동으로 추가 합니다. 기본적으로 &lt;code&gt;CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE&lt;/code&gt; 는 &lt;code&gt;OFF&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f27b9c7a76dd75faec68d3755b87bc8e49006902" translate="yes" xml:space="preserve">
          <source>If this variable is not set then the &lt;a href=&quot;../prop_tgt/cuda_runtime_library#prop_tgt:CUDA_RUNTIME_LIBRARY&quot; id=&quot;index-1-prop_tgt:CUDA_RUNTIME_LIBRARY&quot;&gt;&lt;code&gt;CUDA_RUNTIME_LIBRARY&lt;/code&gt;&lt;/a&gt; target property will not be set automatically. If that property is not set then CMake uses an appropriate default value based on the compiler to select the CUDA runtime library.</source>
          <target state="translated">이 변수가 설정되지 않으면 &lt;a href=&quot;../prop_tgt/cuda_runtime_library#prop_tgt:CUDA_RUNTIME_LIBRARY&quot; id=&quot;index-1-prop_tgt:CUDA_RUNTIME_LIBRARY&quot;&gt; &lt;code&gt;CUDA_RUNTIME_LIBRARY&lt;/code&gt; &lt;/a&gt; 대상 속성이 자동으로 설정되지 않습니다. 해당 속성이 설정되지 않은 경우 CMake는 컴파일러에 따라 적절한 기본값을 사용하여 CUDA 런타임 라이브러리를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6d8c00eb8928c5b1331b8e51769f6456ed96a25e" translate="yes" xml:space="preserve">
          <source>If this variable is not set then the &lt;a href=&quot;../prop_tgt/msvc_runtime_library#prop_tgt:MSVC_RUNTIME_LIBRARY&quot; id=&quot;index-1-prop_tgt:MSVC_RUNTIME_LIBRARY&quot;&gt;&lt;code&gt;MSVC_RUNTIME_LIBRARY&lt;/code&gt;&lt;/a&gt; target property will not be set automatically. If that property is not set then CMake uses the default value &lt;code&gt;MultiThreaded$&amp;lt;$&amp;lt;CONFIG:Debug&amp;gt;:Debug&amp;gt;DLL&lt;/code&gt; to select a MSVC runtime library.</source>
          <target state="translated">이 변수를 설정하지 않으면 &lt;a href=&quot;../prop_tgt/msvc_runtime_library#prop_tgt:MSVC_RUNTIME_LIBRARY&quot; id=&quot;index-1-prop_tgt:MSVC_RUNTIME_LIBRARY&quot;&gt; &lt;code&gt;MSVC_RUNTIME_LIBRARY&lt;/code&gt; &lt;/a&gt; 대상 속성이 자동으로 설정되지 않습니다. 해당 속성을 설정하지 않으면 CMake는 기본값 &lt;code&gt;MultiThreaded$&amp;lt;$&amp;lt;CONFIG:Debug&amp;gt;:Debug&amp;gt;DLL&lt;/code&gt; 을 사용하여 MSVC 런타임 라이브러리를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cc009ec01d00cb824b37579310380742a9ab81ee" translate="yes" xml:space="preserve">
          <source>If this variable is not set, the default behavior is &lt;code&gt;ALWAYS&lt;/code&gt;.</source>
          <target state="translated">이 변수가 설정되지 않은 경우 기본 동작은 &lt;code&gt;ALWAYS&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01acc490f8aa302dd83e10050ab579c5f95417e2" translate="yes" xml:space="preserve">
          <source>If this variable is not set, this behavior is enabled by default if &lt;a href=&quot;../variable/cmake_minimum_required_version#variable:CMAKE_MINIMUM_REQUIRED_VERSION&quot; id=&quot;index-1-variable:CMAKE_MINIMUM_REQUIRED_VERSION&quot;&gt;&lt;code&gt;CMAKE_MINIMUM_REQUIRED_VERSION&lt;/code&gt;&lt;/a&gt; is 3.1 or later, disabled otherwise.</source>
          <target state="translated">이 변수를 설정하지 않으면 &lt;a href=&quot;../variable/cmake_minimum_required_version#variable:CMAKE_MINIMUM_REQUIRED_VERSION&quot; id=&quot;index-1-variable:CMAKE_MINIMUM_REQUIRED_VERSION&quot;&gt; &lt;code&gt;CMAKE_MINIMUM_REQUIRED_VERSION&lt;/code&gt; &lt;/a&gt; 이 3.1 이상 이면 기본적으로이 동작이 활성화되고 그렇지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="70d97702a5c43ed53c1e395eceff687ce49d7fbb" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it is determined automatically by system introspection.</source>
          <target state="translated">이 변수를 지정하지 않으면 시스템 검사에 의해 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab715f956cf23707b80a1b1c0ce69b3acab521a7" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it is determined by the value of &lt;code&gt;CMAKE_OBJDUMP&lt;/code&gt; if set, else by system introspection.</source>
          <target state="translated">이 변수가 지정되지 않은 경우 &lt;code&gt;CMAKE_OBJDUMP&lt;/code&gt; ( 설정된 경우) 의 값에 의해 결정되고 그렇지 않으면 시스템 검사에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7edac8955b37ef873dafa8a7f7c5dd0d67dd38a4" translate="yes" xml:space="preserve">
          <source>If this variable is set to &lt;code&gt;STDERR&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;NONE&lt;/code&gt; then commands in &lt;a href=&quot;../command/execute_process#command:execute_process&quot; id=&quot;index-0-command:execute_process&quot;&gt;&lt;code&gt;execute_process()&lt;/code&gt;&lt;/a&gt; calls will be printed to either stderr or stdout or not at all.</source>
          <target state="translated">이 변수가 &lt;code&gt;STDERR&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; 또는 &lt;code&gt;NONE&lt;/code&gt; 으로 설정되면 &lt;a href=&quot;../command/execute_process#command:execute_process&quot; id=&quot;index-0-command:execute_process&quot;&gt; &lt;code&gt;execute_process()&lt;/code&gt; &lt;/a&gt; 호출의 명령이 stderr 또는 stdout에 인쇄되거나 전혀 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="794b0b8d927116641b36668add340c3f8f66c2ce" translate="yes" xml:space="preserve">
          <source>If this variable is set to TRUE, the Eclipse project generator will generate an Eclipse project in &lt;a href=&quot;cmake_source_dir#variable:CMAKE_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_SOURCE_DIR&quot;&gt;&lt;code&gt;CMAKE_SOURCE_DIR&lt;/code&gt;&lt;/a&gt; . This project can then be used in Eclipse e.g. for the version control functionality. &lt;a href=&quot;#variable:CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&quot; id=&quot;index-0-variable:CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&quot;&gt;&lt;code&gt;CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&lt;/code&gt;&lt;/a&gt; defaults to FALSE; so nothing is written into the source directory.</source>
          <target state="translated">이 변수가 TRUE로 설정되면 Eclipse 프로젝트 생성기는 &lt;a href=&quot;cmake_source_dir#variable:CMAKE_SOURCE_DIR&quot; id=&quot;index-0-variable:CMAKE_SOURCE_DIR&quot;&gt; &lt;code&gt;CMAKE_SOURCE_DIR&lt;/code&gt; 에&lt;/a&gt; Eclipse 프로젝트를 생성합니다 . 이 프로젝트는 예를 들어 버전 제어 기능과 같은 Eclipse에서 사용될 수 있습니다. &lt;a href=&quot;#variable:CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&quot; id=&quot;index-0-variable:CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&quot;&gt; &lt;code&gt;CMAKE_ECLIPSE_GENERATE_SOURCE_PROJECT&lt;/code&gt; 의&lt;/a&gt; 기본값은 FALSE입니다. 소스 디렉토리에는 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e95746b0051a057a1ff83ee1c30e6fbd2f8500d" translate="yes" xml:space="preserve">
          <source>If true, do not add run time path information.</source>
          <target state="translated">true 인 경우 런타임 경로 정보를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a89b7d8465a0a5b89c8545a7852f6f1c0e9ad053" translate="yes" xml:space="preserve">
          <source>If true, no compiler wrapper will be searched for.</source>
          <target state="translated">true이면 컴파일러 랩퍼가 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1137daa9a8b974db53f0acb5d090570797803c7" translate="yes" xml:space="preserve">
          <source>If true, the guessing step will be skipped.</source>
          <target state="translated">true 인 경우 추측 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="28729f3a182bb43fe798fa0d0a35993e2c74015e" translate="yes" xml:space="preserve">
          <source>If true, the module assumes that the compiler itself does not provide an MPI implementation and skips to step 2.</source>
          <target state="translated">true 인 경우 모듈은 컴파일러 자체가 MPI 구현을 제공하지 않고 2 단계로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e4d38ddd2c85476e4303eabe26804fb16927fc0c" translate="yes" xml:space="preserve">
          <source>If two or more directories contain libraries with identical file names and some libraries are linked from those directories, the library search path lookup will end up linking libraries from the first directory. This is a known limitation of Xcode.</source>
          <target state="translated">둘 이상의 디렉토리에 동일한 파일 이름을 가진 라이브러리가 포함되어 있고 일부 라이브러리가 해당 디렉토리에서 링크 된 경우 라이브러리 검색 경로 조회는 첫 번째 디렉토리에서 라이브러리를 링크하게됩니다. 이것은 Xcode의 알려진 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c5d17bbb804d5250bd91f365271871df4c3e03a4" translate="yes" xml:space="preserve">
          <source>If unset (the default) it will only be emitted when the project was configured for an embedded Xcode SDK like iOS, tvOS, watchOS or any of the simulators.</source>
          <target state="translated">설정하지 않은 경우 (기본값) 프로젝트가 iOS, tvOS, watchOS 또는 다른 시뮬레이터와 같은 임베디드 Xcode SDK 용으로 구성된 경우에만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4debc9a25b5fbc1b4d73d514aa623b4655e9496" translate="yes" xml:space="preserve">
          <source>If unset or empty, rely on the compiler to determine whether the file should be preprocessed. If explicitly set to &lt;code&gt;OFF&lt;/code&gt; then the file does not need to be preprocessed. If explicitly set to &lt;code&gt;ON&lt;/code&gt;, then the file does need to be preprocessed as part of the compilation step.</source>
          <target state="translated">설정되지 않았거나 비어있는 경우 컴파일러를 사용하여 파일을 사전 처리해야하는지 여부를 결정하십시오. 명시 적으로 &lt;code&gt;OFF&lt;/code&gt; 로 설정 하면 파일을 사전 처리 할 필요가 없습니다. 명시 적으로 &lt;code&gt;ON&lt;/code&gt; 으로 설정 하면 컴파일 단계의 일부로 파일을 사전 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="35beb3e2b8fc61f0e40a1f1fcc7a56ec37a43f15" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;FetchContent_Populate()&lt;/code&gt; within CMake&amp;rsquo;s script mode, be aware that the implementation sets up a sub-build which therefore requires a CMake generator and build tool to be available. If these cannot be found by default, then the &lt;a href=&quot;../variable/cmake_generator#variable:CMAKE_GENERATOR&quot; id=&quot;index-0-variable:CMAKE_GENERATOR&quot;&gt;&lt;code&gt;CMAKE_GENERATOR&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../variable/cmake_make_program#variable:CMAKE_MAKE_PROGRAM&quot; id=&quot;index-0-variable:CMAKE_MAKE_PROGRAM&quot;&gt;&lt;code&gt;CMAKE_MAKE_PROGRAM&lt;/code&gt;&lt;/a&gt; variables will need to be set appropriately on the command line invoking the script.</source>
          <target state="translated">CMake의 스크립트 모드에서 &lt;code&gt;FetchContent_Populate()&lt;/code&gt; 사용 하는 경우 구현시 하위 빌드를 설정하므로 CMake 생성기 및 빌드 도구를 사용할 수 있어야합니다. 기본적으로 이러한 변수를 찾을 수 없으면 스크립트를 호출하는 명령 줄 에서 &lt;a href=&quot;../variable/cmake_generator#variable:CMAKE_GENERATOR&quot; id=&quot;index-0-variable:CMAKE_GENERATOR&quot;&gt; &lt;code&gt;CMAKE_GENERATOR&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;../variable/cmake_make_program#variable:CMAKE_MAKE_PROGRAM&quot; id=&quot;index-0-variable:CMAKE_MAKE_PROGRAM&quot;&gt; &lt;code&gt;CMAKE_MAKE_PROGRAM&lt;/code&gt; &lt;/a&gt; 변수를 적절하게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="467d235ab2b447f04a92e3449a01dd60402b8f68" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;UseSWIG_TARGET_NAME_PREFERENCE&lt;/code&gt; is set to &lt;code&gt;STANDARD&lt;/code&gt;, this command is deprecated and &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-2-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt; command must be used instead.</source>
          <target state="translated">변수 &lt;code&gt;UseSWIG_TARGET_NAME_PREFERENCE&lt;/code&gt; 가 &lt;code&gt;STANDARD&lt;/code&gt; 로 설정 되면이 명령은 더 이상 사용되지 않으며 대신 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-2-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3858510c34dbe23e3be2aabe2500e8eacf23da77" translate="yes" xml:space="preserve">
          <source>If we want our example project to also be used from a build directory we only have to add the following to &lt;code&gt;CMakeLists.txt&lt;/code&gt;:</source>
          <target state="translated">예제 프로젝트를 빌드 디렉토리에서도 사용하려면 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 에 다음을 추가하기 만하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="55be3dca421b3e3930e5f2ffe02d2ceee70ea6d7" translate="yes" xml:space="preserve">
          <source>If wxWidgets is required (i.e., not an optional part):</source>
          <target state="translated">wxWidgets가 필요한 경우 (예 : 선택적 부분이 아님) :</target>
        </trans-unit>
        <trans-unit id="7629f66b98e72ca234c5e469dac092268133b92a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t set the &lt;code&gt;INSTALLPATH&lt;/code&gt;, then by default the documentation will be installed to :</source>
          <target state="translated">&lt;code&gt;INSTALLPATH&lt;/code&gt; 를 설정하지 않으면 기본적으로 설명서가 다음 위치에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="240dfa844479574de8aa4d5a3b5d3347a001e2d0" translate="yes" xml:space="preserve">
          <source>If you have a good way of getting the version (from a header file, for example), you can use that information to set &lt;code&gt;Foo_VERSION&lt;/code&gt; (although note that find modules have traditionally used &lt;code&gt;Foo_VERSION_STRING&lt;/code&gt;, so you may want to set both). Otherwise, attempt to use the information from &lt;code&gt;pkg-config&lt;/code&gt;</source>
          <target state="translated">예를 들어 헤더 파일에서 버전을 얻는 좋은 방법이 있다면 해당 정보를 사용하여 &lt;code&gt;Foo_VERSION&lt;/code&gt; 을 설정할 수 있습니다 (찾기 모듈은 전통적으로 &lt;code&gt;Foo_VERSION_STRING&lt;/code&gt; 을 사용 했으므로 둘 다 설정할 수 있습니다). 그렇지 않으면 &lt;code&gt;pkg-config&lt;/code&gt; 의 정보를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="da2758d30b2b9d5cc70af05f5541b856dc3f949e" translate="yes" xml:space="preserve">
          <source>If you have options that depend on the values of other options, see the module help for &lt;a href=&quot;../module/cmakedependentoption#module:CMakeDependentOption&quot; id=&quot;index-0-module:CMakeDependentOption&quot;&gt;&lt;code&gt;CMakeDependentOption&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 옵션의 값에 의존하는 옵션이있는 경우 &lt;a href=&quot;../module/cmakedependentoption#module:CMakeDependentOption&quot; id=&quot;index-0-module:CMakeDependentOption&quot;&gt; &lt;code&gt;CMakeDependentOption&lt;/code&gt; 에&lt;/a&gt; 대한 모듈 도움말을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a783d68605ba9a71240b242ac8a3558069d13192" translate="yes" xml:space="preserve">
          <source>If you need the multithreaded version of Qt, set QT_MT_REQUIRED to TRUE</source>
          <target state="translated">멀티 스레드 버전의 Qt가 필요한 경우 QT_MT_REQUIRED를 TRUE로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ad3e21f3a121362d780a5f05bd1c165694d81eb7" translate="yes" xml:space="preserve">
          <source>If you pass plugins to &lt;code&gt;fixup_bundle&lt;/code&gt; as the libs parameter, you should install them or copy them into the bundle before calling &lt;code&gt;fixup_bundle&lt;/code&gt;. The &lt;code&gt;&amp;lt;libs&amp;gt;&lt;/code&gt; parameter is a list of libraries that must be fixed up, but that cannot be determined by &lt;code&gt;otool&lt;/code&gt; output analysis (i.e. &lt;code&gt;plugins&lt;/code&gt;).</source>
          <target state="translated">당신이 플러그인을 전달하면 &lt;code&gt;fixup_bundle&lt;/code&gt; libs와 매개 변수로, 당신은 그 (것)들을 설치하거나 호출하기 전에 번들로 복사해야 &lt;code&gt;fixup_bundle&lt;/code&gt; 을 . &lt;code&gt;&amp;lt;libs&amp;gt;&lt;/code&gt; 파라미터는 최대 고정해야 라이브러리 목록이지만, 그 의해 결정될 수 &lt;code&gt;otool&lt;/code&gt; 출력 분석 (즉, &lt;code&gt;plugins&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="342ad3f46a23d13e0a765e537dc4610778667a26" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;TEST_INCLUDE_FILE&lt;/code&gt;, that file will be included and processed when ctest is run on the directory.</source>
          <target state="translated">&lt;code&gt;TEST_INCLUDE_FILE&lt;/code&gt; 을 지정 하면 디렉토리에서 ctest가 실행될 때 해당 파일이 포함되어 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5631b086af4391f2361051cda7064bef68b2d353" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;TEST_INCLUDE_FILES&lt;/code&gt;, those files will be included and processed when ctest is run on the directory.</source>
          <target state="translated">&lt;code&gt;TEST_INCLUDE_FILES&lt;/code&gt; 를 지정 하면 디렉토리에서 ctest가 실행될 때 해당 파일이 포함되어 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e59d0ed1eacb8a6f5056dead4f547cfdfdd94d5c" translate="yes" xml:space="preserve">
          <source>If you want to see the list of available presets, you can run:</source>
          <target state="translated">사용 가능한 사전 설정 목록을 보려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86412892c8e08d7232ed2afcdac8386587aaa81f" translate="yes" xml:space="preserve">
          <source>If you wish to use the Gettext library (libintl), use &lt;a href=&quot;findintl#module:FindIntl&quot; id=&quot;index-0-module:FindIntl&quot;&gt;&lt;code&gt;FindIntl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Gettext 라이브러리 (libintl)를 사용하려면 &lt;a href=&quot;findintl#module:FindIntl&quot; id=&quot;index-0-module:FindIntl&quot;&gt; &lt;code&gt;FindIntl&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9a21b6fc6b32a2e5566cbb1ecb16fe936ed261" translate="yes" xml:space="preserve">
          <source>If you wish to use the Gettext tools (&lt;code&gt;msgmerge&lt;/code&gt;, &lt;code&gt;msgfmt&lt;/code&gt;, etc.), use &lt;a href=&quot;findgettext#module:FindGettext&quot; id=&quot;index-0-module:FindGettext&quot;&gt;&lt;code&gt;FindGettext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Gettext 도구 ( &lt;code&gt;msgmerge&lt;/code&gt; , &lt;code&gt;msgfmt&lt;/code&gt; 등)를 사용하려면 &lt;a href=&quot;findgettext#module:FindGettext&quot; id=&quot;index-0-module:FindGettext&quot;&gt; &lt;code&gt;FindGettext&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="220572356970df928c6654d008f10935c25277eb" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to specify the installation of Python to use, you should modify the following cache variables:</source>
          <target state="translated">사용할 Python 설치를 지정하려면 다음 캐시 변수를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="438fe08156c697fc4a29879a7f819c1775f0e6bd" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;CMAKE_SHARED_LIBRARY_&amp;lt;Lang&amp;gt;_FLAGS&lt;/code&gt; variable.</source>
          <target state="translated">&lt;code&gt;CMAKE_SHARED_LIBRARY_&amp;lt;Lang&amp;gt;_FLAGS&lt;/code&gt; 변수를 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="adf935e0986128222bf1d163af930827bd5b1d38" translate="yes" xml:space="preserve">
          <source>Ignore COMPILE_DEFINITIONS_&amp;lt;Config&amp;gt; properties</source>
          <target state="translated">COMPILE_DEFINITIONS_ &amp;lt;Config&amp;gt; 특성 무시</target>
        </trans-unit>
        <trans-unit id="e9c35c5bb1c27ffc7e719a70db469bf46b72c43d" translate="yes" xml:space="preserve">
          <source>Ignore the local branch and always checkout the branch specified by &lt;code&gt;GIT_TAG&lt;/code&gt;.</source>
          <target state="translated">로컬 브랜치를 무시하고 항상 &lt;code&gt;GIT_TAG&lt;/code&gt; 로 지정된 브랜치를 체크 아웃하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4c835c0772da721ba47510daa9d1c33ac4af6e8" translate="yes" xml:space="preserve">
          <source>Ignored for non-imported targets.</source>
          <target state="translated">가져 오지 않은 대상에 대해서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="46a306057ab4969a4f6e26407924f5ce5ae2bd9a" translate="yes" xml:space="preserve">
          <source>Ignored. Behavior is default in CMake &amp;gt;= 3.0.</source>
          <target state="translated">무시되었습니다. CMake&amp;gt; = 3.0에서 동작은 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="573fb946b1c80d307a08138735973b58a7c0036b" translate="yes" xml:space="preserve">
          <source>Ignored. See CMake Policy &lt;a href=&quot;../policy/cmp0043#policy:CMP0043&quot; id=&quot;index-0-policy:CMP0043&quot;&gt;&lt;code&gt;CMP0043&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">무시되었습니다. CMake Policy &lt;a href=&quot;../policy/cmp0043#policy:CMP0043&quot; id=&quot;index-0-policy:CMP0043&quot;&gt; &lt;code&gt;CMP0043&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77f70e23bc4f12a1f6fdf1f528ad6f98b0a0a140" translate="yes" xml:space="preserve">
          <source>Ignored. This was once used but is no longer needed.</source>
          <target state="translated">무시되었습니다. 이것은 한 번 사용되었지만 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4a3dadc40ffc53df8d265e9f7ae52cef2b6b873" translate="yes" xml:space="preserve">
          <source>Implicit dependencies such as &lt;code&gt;Boost::filesystem&lt;/code&gt; requiring &lt;code&gt;Boost::system&lt;/code&gt; will be automatically detected and satisfied, even if system is not specified when using &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; and if &lt;code&gt;Boost::system&lt;/code&gt; is not added to &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-0-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt;. If using &lt;code&gt;Boost::thread&lt;/code&gt;, then &lt;code&gt;Threads::Threads&lt;/code&gt; will also be added automatically.</source>
          <target state="translated">같은 암시 종속성 &lt;code&gt;Boost::filesystem&lt;/code&gt; 요구 &lt;code&gt;Boost::system&lt;/code&gt; 자동으로 감지 만족 사용할 때 시스템이 지정되지 않은 경우에도한다 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 하고있는 경우 &lt;code&gt;Boost::system&lt;/code&gt; 에 추가되지 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-0-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; . 사용하는 경우 &lt;code&gt;Boost::thread&lt;/code&gt; , 다음 &lt;code&gt;Threads::Threads&lt;/code&gt; 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a31b383678419806f5ead0560328ba2bf1c79265" translate="yes" xml:space="preserve">
          <source>Implicit link libraries and flags detected for language &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; 언어에 대한 암시 적 링크 라이브러리 및 플래그가 감지되었습니다 .</target>
        </trans-unit>
        <trans-unit id="54f66e009276602ce456971ada8cab01104af9f8" translate="yes" xml:space="preserve">
          <source>Implicit linker framework search path detected for language &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">언어 &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; 에 대한 암시 적 링커 프레임 워크 검색 경로가 발견되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e247b753bea66dff24c42212fbf93dd51776ca60" translate="yes" xml:space="preserve">
          <source>Implicit linker search path detected for language &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">언어 &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; 에 대한 암시 적 링커 검색 경로가 발견되었습니다 .</target>
        </trans-unit>
        <trans-unit id="af7551d5e165e6893fd99488c8e51e2999fd587f" translate="yes" xml:space="preserve">
          <source>Implicitly created directories are created if they are not explicitly installed by &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command but are needed to install a file on a certain path. Example of such locations are directories created due to the setting of &lt;a href=&quot;cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 작성된 디렉토리는 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 명령 으로 명시 적으로 설치되지 않지만 특정 경로에 파일을 설치해야하는 경우 작성됩니다 . 이러한 위치의 예는 &lt;a href=&quot;cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; 설정으로 인해 작성된 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="19a29d496677d34abdf4064ab67098cd6b05a91d" translate="yes" xml:space="preserve">
          <source>Important message printed to stderr to attract user&amp;rsquo;s attention.</source>
          <target state="translated">사용자의주의를 끌기 위해 stderr에 중요한 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd0d4de13d733783688f546062f97ab6a08713a" translate="yes" xml:space="preserve">
          <source>Imported Executables</source>
          <target state="translated">가져온 실행 파일</target>
        </trans-unit>
        <trans-unit id="55f6f305e45f8618dd5ce0a0030a07d3b2c2840f" translate="yes" xml:space="preserve">
          <source>Imported Libraries</source>
          <target state="translated">수입 된 도서관</target>
        </trans-unit>
        <trans-unit id="f6d0f7638ba3ef0cd1a426bf0a4f991c2e1cb7da" translate="yes" xml:space="preserve">
          <source>Imported Targets</source>
          <target state="translated">가져온 대상</target>
        </trans-unit>
        <trans-unit id="f7a9640a73a64138bfc84441dcc301f6a4199db2" translate="yes" xml:space="preserve">
          <source>Imported Targets from Packages</source>
          <target state="translated">패키지에서 가져온 대상</target>
        </trans-unit>
        <trans-unit id="202f02bfc5abfe27c17eb4fa3b977b33c84e9422" translate="yes" xml:space="preserve">
          <source>Imported target</source>
          <target state="translated">수입 대상</target>
        </trans-unit>
        <trans-unit id="375ae037609c8745f55b07c09854d5867d6c1cdf" translate="yes" xml:space="preserve">
          <source>Imported target for using iconv.</source>
          <target state="translated">iconv를 사용하기 위해 가져온 대상입니다.</target>
        </trans-unit>
        <trans-unit id="37a9c8f1d81835742651b320a0a628c6cc05785a" translate="yes" xml:space="preserve">
          <source>Imported target for using the ODBC library, if found.</source>
          <target state="translated">ODBC 라이브러리 사용을 위해 가져온 대상 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="99d044d9c559cc35a01b48d24159e07faf855129" translate="yes" xml:space="preserve">
          <source>Imported targets</source>
          <target state="translated">가져온 대상</target>
        </trans-unit>
        <trans-unit id="0553ae7222ae62138779db715a3a73a9d77d8fee" translate="yes" xml:space="preserve">
          <source>Imported targets:</source>
          <target state="translated">가져온 대상 :</target>
        </trans-unit>
        <trans-unit id="b278ed35e4c25d4e3cdb29eb8d2798d2851b3470" translate="yes" xml:space="preserve">
          <source>Importing Executables</source>
          <target state="translated">실행 파일 가져 오기</target>
        </trans-unit>
        <trans-unit id="1dd489e5e4efeae515cf45caaa691b48566d2019" translate="yes" xml:space="preserve">
          <source>Importing Libraries</source>
          <target state="translated">라이브러리 가져 오기</target>
        </trans-unit>
        <trans-unit id="55f283ee7526f3c6e85099989f92e16c73f53ecc" translate="yes" xml:space="preserve">
          <source>Importing Targets</source>
          <target state="translated">대상 가져 오기</target>
        </trans-unit>
        <trans-unit id="e042284b1c843195ddf0ddee4923e774dd610905" translate="yes" xml:space="preserve">
          <source>Importing and Exporting Guide</source>
          <target state="translated">가져 오기 및 내보내기 가이드</target>
        </trans-unit>
        <trans-unit id="f96c1beede9a123ecf0d86e367c948c1219cf9e6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CMakeLists.txt&lt;/code&gt; we add a filter to &lt;a href=&quot;../variable/cmake_automoc_depend_filters#variable:CMAKE_AUTOMOC_DEPEND_FILTERS&quot; id=&quot;index-1-variable:CMAKE_AUTOMOC_DEPEND_FILTERS&quot;&gt;&lt;code&gt;CMAKE_AUTOMOC_DEPEND_FILTERS&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;code&gt;CMakeLists.txt&lt;/code&gt; 에서는 다음 과 같이 &lt;a href=&quot;../variable/cmake_automoc_depend_filters#variable:CMAKE_AUTOMOC_DEPEND_FILTERS&quot; id=&quot;index-1-variable:CMAKE_AUTOMOC_DEPEND_FILTERS&quot;&gt; &lt;code&gt;CMAKE_AUTOMOC_DEPEND_FILTERS&lt;/code&gt; 에&lt;/a&gt; 필터를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="15070484d3d209ccce43582660ea91002809b0f6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main.cc&lt;/code&gt;, replace &lt;code&gt;#include MathFunctions.h&lt;/code&gt; with:</source>
          <target state="translated">에서 &lt;code&gt;main.cc&lt;/code&gt; , 대체 &lt;code&gt;#include MathFunctions.h&lt;/code&gt; 함께 :</target>
        </trans-unit>
        <trans-unit id="09fe57648c1c369f3f8a771a8556c013a4767b89" translate="yes" xml:space="preserve">
          <source>In CMake 2.4 and below it is possible to write code like</source>
          <target state="translated">CMake 2.4 이하에서는 다음과 같은 코드를 작성할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="372753e9354c3c48a489ae905cdd21b49709af37" translate="yes" xml:space="preserve">
          <source>In CMake 2.4 and below the variable &lt;code&gt;CMAKE_BACKWARDS_COMPATIBILITY&lt;/code&gt; was used to request compatibility with earlier versions of CMake. In CMake 2.6 and above all compatibility issues are handled by policies and the &lt;a href=&quot;../command/cmake_policy#command:cmake_policy&quot; id=&quot;index-0-command:cmake_policy&quot;&gt;&lt;code&gt;cmake_policy()&lt;/code&gt;&lt;/a&gt; command. However, CMake must still check &lt;code&gt;CMAKE_BACKWARDS_COMPATIBILITY&lt;/code&gt; for projects written for CMake 2.4 and below.</source>
          <target state="translated">CMake 2.4 이하에서는 &lt;code&gt;CMAKE_BACKWARDS_COMPATIBILITY&lt;/code&gt; 변수 가 이전 버전의 CMake와의 호환성을 요청하는 데 사용되었습니다. CMake 2.6 이상에서는 모든 호환성 문제가 정책 및 &lt;a href=&quot;../command/cmake_policy#command:cmake_policy&quot; id=&quot;index-0-command:cmake_policy&quot;&gt; &lt;code&gt;cmake_policy()&lt;/code&gt; &lt;/a&gt; 명령으로 처리됩니다 . 그러나 CMake 2.4 이하 &lt;code&gt;CMAKE_BACKWARDS_COMPATIBILITY&lt;/code&gt; 용으로 작성된 프로젝트에 대해서는 CMake가 CMAKE_BACKWARDS_COMPATIBILITY 를 여전히 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="792922d718799ee6eba92c4e81a40fa8d128071d" translate="yes" xml:space="preserve">
          <source>In CMake 2.6.1 and below, &lt;a href=&quot;../command/file#command:file&quot; id=&quot;index-0-command:file&quot;&gt;&lt;code&gt;file(GLOB_RECURSE)&lt;/code&gt;&lt;/a&gt; calls would follow through symlinks, sometimes coming up with unexpectedly large result sets because of symlinks to top level directories that contain hundreds of thousands of files.</source>
          <target state="translated">CMake 2.6.1 이하에서 &lt;a href=&quot;../command/file#command:file&quot; id=&quot;index-0-command:file&quot;&gt; &lt;code&gt;file(GLOB_RECURSE)&lt;/code&gt; &lt;/a&gt; 호출은 심볼릭 링크를 따르며, 때로는 수십만 개의 파일이 포함 된 최상위 디렉토리에 대한 심볼릭 링크로 인해 예기치 않은 큰 결과 세트가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a9a3a46efd9a05da1ef101fb3d68e675598b2b6a" translate="yes" xml:space="preserve">
          <source>In CMake 2.6.2 and below, CMake Policy settings in scripts loaded by the &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-0-command:include&quot;&gt;&lt;code&gt;include()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands would affect the includer. Explicit invocations of &lt;code&gt;cmake_policy(PUSH)&lt;/code&gt; and &lt;code&gt;cmake_policy(POP)&lt;/code&gt; were required to isolate policy changes and protect the includer. While some scripts intend to affect the policies of their includer, most do not. In CMake 2.6.3 and above, &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-1-command:include&quot;&gt;&lt;code&gt;include()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; by default &lt;code&gt;PUSH&lt;/code&gt; and &lt;code&gt;POP&lt;/code&gt; an entry on the policy stack around an included script, but provide a &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; option to disable it. This policy determines whether or not to imply &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; for compatibility. The &lt;code&gt;OLD&lt;/code&gt; behavior for this policy is to imply &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; for &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-2-command:include&quot;&gt;&lt;code&gt;include()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands. The &lt;code&gt;NEW&lt;/code&gt; behavior for this policy is to allow the commands to do their default cmake_policy &lt;code&gt;PUSH&lt;/code&gt; and &lt;code&gt;POP&lt;/code&gt;.</source>
          <target state="translated">CMake 2.6.2 이하에서 &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-0-command:include&quot;&gt; &lt;code&gt;include()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령으로 로드 된 스크립트의 CMake Policy 설정 은 includer에 영향을줍니다. 정책 변경을 분리 하고 포함 &lt;code&gt;cmake_policy(POP)&lt;/code&gt; 보호하려면 &lt;code&gt;cmake_policy(PUSH)&lt;/code&gt; 및 cmake_policy (POP)를 명시 적으로 호출 해야했습니다. 일부 스크립트는 포함 자의 정책에 영향을 주려고하지만 대부분은 그렇지 않습니다. CMake 2.6.3 이상에서 기본적으로 &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-1-command:include&quot;&gt; &lt;code&gt;include()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 는 포함 된 스크립트를 중심으로 정책 스택의 항목을 &lt;code&gt;PUSH&lt;/code&gt; 및 &lt;code&gt;POP&lt;/code&gt; 하지만이 를 비활성화하려면 &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; 옵션을 제공 하십시오. 이 정책은 &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; 를 암시할지 여부를 결정합니다.호환성을 위해. 이 정책 의 &lt;code&gt;OLD&lt;/code&gt; 동작은 &lt;a href=&quot;../command/include#command:include&quot; id=&quot;index-2-command:include&quot;&gt; &lt;code&gt;include()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령에 NO_POLICY_SCOPE 를 암시하는 &lt;code&gt;NO_POLICY_SCOPE&lt;/code&gt; 입니다 . 이 정책 의 &lt;code&gt;NEW&lt;/code&gt; 동작은 명령이 기본 cmake_policy &lt;code&gt;PUSH&lt;/code&gt; 및 &lt;code&gt;POP&lt;/code&gt; 을 수행하도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2b48795ed522bc01cb0a61e135326afd93efd3d3" translate="yes" xml:space="preserve">
          <source>In CMake 2.6.2 and below, incorrect variable reference syntax such as a missing close-brace (&lt;code&gt;${FOO&lt;/code&gt;) was reported but did not stop processing of CMake code. This policy determines whether a bad variable reference is an error. The &lt;code&gt;OLD&lt;/code&gt; behavior for this policy is to warn about the error, leave the string untouched, and continue. The &lt;code&gt;NEW&lt;/code&gt; behavior for this policy is to report an error.</source>
          <target state="translated">CMake 2.6.2 이하에서는 닫기 중괄호 누락 ( &lt;code&gt;${FOO&lt;/code&gt; ) 과 같은 잘못된 변수 참조 구문 이보고되었지만 CMake 코드 처리를 중지하지 않았습니다. 이 정책은 잘못된 변수 참조가 오류인지 여부를 결정합니다. 이 정책 의 &lt;code&gt;OLD&lt;/code&gt; 동작은 오류에 대해 경고하고 문자열을 그대로 유지 한 후 계속 진행하는 것입니다. 이 정책 의 &lt;code&gt;NEW&lt;/code&gt; 동작은 오류를보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b3433edb7ff048bd90b0cf8bd20b13ebf4f4128" translate="yes" xml:space="preserve">
          <source>In CMake 2.8.0 and lower the &lt;a href=&quot;../command/link_directories#command:link_directories&quot; id=&quot;index-1-command:link_directories&quot;&gt;&lt;code&gt;link_directories()&lt;/code&gt;&lt;/a&gt; command passed relative paths unchanged to the linker. In CMake 2.8.1 and above the &lt;a href=&quot;../command/link_directories#command:link_directories&quot; id=&quot;index-2-command:link_directories&quot;&gt;&lt;code&gt;link_directories()&lt;/code&gt;&lt;/a&gt; command prefers to interpret relative paths with respect to &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;, which is consistent with &lt;a href=&quot;../command/include_directories#command:include_directories&quot; id=&quot;index-0-command:include_directories&quot;&gt;&lt;code&gt;include_directories()&lt;/code&gt;&lt;/a&gt; and other commands. The &lt;code&gt;OLD&lt;/code&gt; behavior for this policy is to use relative paths verbatim in the linker command. The &lt;code&gt;NEW&lt;/code&gt; behavior for this policy is to convert relative paths to absolute paths by appending the relative path to &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt;.</source>
          <target state="translated">CMake 2.8.0 이하에서 &lt;a href=&quot;../command/link_directories#command:link_directories&quot; id=&quot;index-1-command:link_directories&quot;&gt; &lt;code&gt;link_directories()&lt;/code&gt; &lt;/a&gt; 명령은 링커에 변경되지 않은 상대 경로를 전달했습니다. CMake 2.8.1 이상에서 &lt;a href=&quot;../command/link_directories#command:link_directories&quot; id=&quot;index-2-command:link_directories&quot;&gt; &lt;code&gt;link_directories()&lt;/code&gt; &lt;/a&gt; 명령은 &lt;a href=&quot;../command/include_directories#command:include_directories&quot; id=&quot;index-0-command:include_directories&quot;&gt; &lt;code&gt;include_directories()&lt;/code&gt; &lt;/a&gt; 및 기타 명령과 일치하는 &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; 과 관련하여 상대 경로를 해석하는 것을 선호 합니다. 이 정책 의 &lt;code&gt;OLD&lt;/code&gt; 동작은 링커 명령에서 상대 경로를 그대로 사용하는 것입니다. 이 정책 의 &lt;code&gt;NEW&lt;/code&gt; 동작은 상대 경로를 &lt;code&gt;CMAKE_CURRENT_SOURCE_DIR&lt;/code&gt; 에 추가하여 상대 경로를 절대 경로로 변환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9be4f81cf981c948e1cbe0b9eef463edadd4739f" translate="yes" xml:space="preserve">
          <source>In CMake 2.8.12 and lower, the &lt;a href=&quot;../command/get_target_property#command:get_target_property&quot; id=&quot;index-0-command:get_target_property&quot;&gt;&lt;code&gt;get_target_property()&lt;/code&gt;&lt;/a&gt; command accepted a non-existent target argument without issuing any error or warning. The result variable is set to a &lt;code&gt;-NOTFOUND&lt;/code&gt; value.</source>
          <target state="translated">CMake 2.8.12 이하에서 &lt;a href=&quot;../command/get_target_property#command:get_target_property&quot; id=&quot;index-0-command:get_target_property&quot;&gt; &lt;code&gt;get_target_property()&lt;/code&gt; &lt;/a&gt; 명령은 오류 또는 경고를 발행하지 않고 존재하지 않는 대상 인수를 승인했습니다. 결과 변수는 &lt;code&gt;-NOTFOUND&lt;/code&gt; 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f7b2894defd21b4487c815675a41df3e8ae2651" translate="yes" xml:space="preserve">
          <source>In CMake 2.8.2 and lower the &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-1-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt; command silently ignored if it was called with only one argument, and this argument wasn&amp;rsquo;t a valid target. In CMake 2.8.3 and above it reports an error in this case.</source>
          <target state="translated">CMake 2.8.2 이하에서는 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-1-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; 명령이 하나의 인수로만 호출 되고이 인수가 유효한 대상이 아닌 경우 자동으로 무시됩니다. CMake 2.8.3 이상에서는이 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="335c2a3c8a4d403f1f764426f14ed981c7b46667" translate="yes" xml:space="preserve">
          <source>In CMake 3.12 and above the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt;&lt;/a&gt; command now searches prefixes specified by the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake variable and the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; environment variable. Package roots are maintained as a stack so nested calls to all &lt;code&gt;find_*&lt;/code&gt; commands inside find modules also search the roots as prefixes. This policy provides compatibility with projects that have not been updated to avoid using &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; variables for other purposes.</source>
          <target state="translated">CMake 3.12 이상에서 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt; &lt;/a&gt; 명령은 이제 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake 변수 및 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 환경 변수로 지정된 접 두부를 검색 합니다. 패키지 루트는 스택으로 유지되므로 find 모듈 내의 모든 &lt;code&gt;find_*&lt;/code&gt; 명령에 대한 중첩 호출 은 루트를 접두사로 검색합니다. 이 정책은 다른 목적으로 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 변수를 사용하지 않도록 업데이트되지 않은 프로젝트와의 호환성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3033f9e09ff46f3d188a16dc4cce2f3d3ff87954" translate="yes" xml:space="preserve">
          <source>In CMake 3.12 and above the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt;&lt;/a&gt; command now searches prefixes specified by the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake variable and the &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; environment variable. Package roots are maintained as a stack so nested calls to all &lt;code&gt;find_*&lt;/code&gt; commands inside find modules and config packages also search the roots as prefixes. This policy provides compatibility with projects that have not been updated to avoid using &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; variables for other purposes.</source>
          <target state="translated">CMake 3.12 이상에서 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package(&amp;lt;PackageName&amp;gt;)&lt;/code&gt; &lt;/a&gt; 명령은 이제 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; CMake 변수 및 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 환경 변수로 지정된 접두사를 검색 합니다. 패키지 루트는 스택으로 유지되므로 find 모듈 및 구성 패키지 내의 모든 &lt;code&gt;find_*&lt;/code&gt; 명령에 대한 중첩 호출 도 루트를 접두사로 검색합니다. 이 정책은 다른 용도로 &lt;code&gt;&amp;lt;PackageName&amp;gt;_ROOT&lt;/code&gt; 변수를 사용하지 않도록 업데이트되지 않은 프로젝트와의 호환성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9c52384a85b2b0709ff719e3942b18b6b142d396" translate="yes" xml:space="preserve">
          <source>In CMake 3.12 and above, the</source>
          <target state="translated">CMake 3.12 이상에서</target>
        </trans-unit>
        <trans-unit id="dcd0de431a57788e96a4fd163c4a47d2f94dbb0b" translate="yes" xml:space="preserve">
          <source>In CMake 3.13 and above the &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-6-command:option&quot;&gt;&lt;code&gt;option()&lt;/code&gt;&lt;/a&gt; command prefers to do nothing when a normal variable of the given name already exists. It does not create or update a cache entry or remove the normal variable. The new behavior is consistent between the first and later runs in a build tree. This policy provides compatibility with projects that have not been updated to expect the new behavior.</source>
          <target state="translated">CMake 3.13 이상에서 &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-6-command:option&quot;&gt; &lt;code&gt;option()&lt;/code&gt; &lt;/a&gt; 명령은 주어진 이름의 일반 변수가 이미 존재하는 경우 아무것도하지 않는 것을 선호합니다. 캐시 항목을 작성 또는 업데이트하거나 일반 변수를 제거하지 않습니다. 새 동작은 빌드 트리에서 첫 번째 실행과 이후 실행간에 일관됩니다. 이 정책은 새로운 동작을 예상하기 위해 업데이트되지 않은 프로젝트와의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72cd139f9b98415e4f7b303fa6cfbc01301676b4" translate="yes" xml:space="preserve">
          <source>In CMake 3.13 and above, the &lt;a href=&quot;../command/target_sources#command:target_sources&quot; id=&quot;index-1-command:target_sources&quot;&gt;&lt;code&gt;target_sources()&lt;/code&gt;&lt;/a&gt; command now converts relative source file paths to absolute paths in the following cases:</source>
          <target state="translated">CMake 3.13 이상에서 &lt;a href=&quot;../command/target_sources#command:target_sources&quot; id=&quot;index-1-command:target_sources&quot;&gt; &lt;code&gt;target_sources()&lt;/code&gt; &lt;/a&gt; 명령은 다음과 같은 경우에 상대 소스 파일 경로를 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="570f166131644526527480ee73109380062d95f8" translate="yes" xml:space="preserve">
          <source>In CMake 3.13 and earlier, &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt;&lt;code&gt;install(CODE)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-3-command:install&quot;&gt;&lt;code&gt;install(SCRIPT)&lt;/code&gt;&lt;/a&gt; did not evaluate generator expressions. CMake 3.14 and later will evaluate generator expressions for &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-4-command:install&quot;&gt;&lt;code&gt;install(CODE)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-5-command:install&quot;&gt;&lt;code&gt;install(SCRIPT)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CMake 3.13 및 이전 버전에서 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt; &lt;code&gt;install(CODE)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-3-command:install&quot;&gt; &lt;code&gt;install(SCRIPT)&lt;/code&gt; &lt;/a&gt; 은 생성기 표현식을 평가하지 않았습니다. CMake 3.14 이상은 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-4-command:install&quot;&gt; &lt;code&gt;install(CODE)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-5-command:install&quot;&gt; &lt;code&gt;install(SCRIPT)&lt;/code&gt; &lt;/a&gt; 생성기 표현식을 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="64de8365d63699cb266201100b308fbc397c135e" translate="yes" xml:space="preserve">
          <source>In CMake 3.13 and lower, the &lt;code&gt;$&amp;lt;IN_LIST:...&amp;gt;&lt;/code&gt; generator expression always returned &lt;code&gt;0&lt;/code&gt; if the first argument was empty, even if the list contained an empty item. This behavior is inconsistent with the &lt;code&gt;IN_LIST&lt;/code&gt; behavior of &lt;a href=&quot;../command/if#command:if&quot; id=&quot;index-0-command:if&quot;&gt;&lt;code&gt;if()&lt;/code&gt;&lt;/a&gt;, which this generator expression is meant to emulate. CMake 3.14 and later handles this case correctly.</source>
          <target state="translated">CMake 3.13 이하에서 &lt;code&gt;$&amp;lt;IN_LIST:...&amp;gt;&lt;/code&gt; 생성기 표현식 은 목록에 빈 항목이 포함되어 있어도 첫 번째 인수가 비어 있으면 항상 &lt;code&gt;0&lt;/code&gt; 을 반환했습니다 . 이 동작은 &lt;a href=&quot;../command/if#command:if&quot; id=&quot;index-0-command:if&quot;&gt; &lt;code&gt;if()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;IN_LIST&lt;/code&gt; 동작 과 일치하지 않으며 ,이 생성기 표현식은 에뮬레이션됩니다. CMake 3.14 이상이이 경우를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e4667764345f76b3be45041f957257e85d005081" translate="yes" xml:space="preserve">
          <source>In CMake 3.14 and below the &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt;&lt;code&gt;export(PACKAGE)&lt;/code&gt;&lt;/a&gt; command populated the user package registry by default and users needed to set the &lt;a href=&quot;../variable/cmake_export_no_package_registry#variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_EXPORT_NO_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; to disable it, e.g. in automated build and packaging environments. Since the user package registry is stored outside the build tree, this side effect should not be enabled by default. Therefore CMake 3.15 and above prefer that &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-2-command:export&quot;&gt;&lt;code&gt;export(PACKAGE)&lt;/code&gt;&lt;/a&gt; does nothing unless an explicit &lt;a href=&quot;../variable/cmake_export_package_registry#variable:CMAKE_EXPORT_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_EXPORT_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_EXPORT_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is set to enable it. This policy provides compatibility with projects that have not been updated.</source>
          <target state="translated">CMake 3.14 이하에서 &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt; &lt;code&gt;export(PACKAGE)&lt;/code&gt; &lt;/a&gt; 명령은 기본적으로 사용자 패키지 레지스트리를 채우고 사용자 는 자동화 된 빌드 및 패키징 환경과 같이 &lt;a href=&quot;../variable/cmake_export_no_package_registry#variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_EXPORT_NO_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_EXPORT_NO_PACKAGE_REGISTRY&lt;/code&gt; &lt;/a&gt; 를 비활성화하도록 설정해야했습니다. 사용자 패키지 레지스트리는 빌드 트리 외부에 저장되므로이 부작용은 기본적으로 사용하지 않아야합니다. 따라서 CMake 3.15 이상에서는 명시 적 &lt;a href=&quot;../variable/cmake_export_package_registry#variable:CMAKE_EXPORT_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_EXPORT_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_EXPORT_PACKAGE_REGISTRY&lt;/code&gt; &lt;/a&gt; 변수가 활성화되어 있지 않으면 &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-2-command:export&quot;&gt; &lt;code&gt;export(PACKAGE)&lt;/code&gt; &lt;/a&gt; 가 아무 것도 수행하지 않는 것이 좋습니다. 이 정책은 업데이트되지 않은 프로젝트와의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39d5f02ade2e50558290bf313056f6664fa821e0" translate="yes" xml:space="preserve">
          <source>In CMake 3.14 and below the module would report the Boost version number as specified in the preprocessor definition &lt;code&gt;BOOST_VERSION&lt;/code&gt; in the &lt;code&gt;boost/version.hpp&lt;/code&gt; file. In CMake 3.15 and later it is preferred that the reported version number matches the &lt;code&gt;x.y.z&lt;/code&gt; format reported by the CMake package shipped with Boost &lt;code&gt;1.70.0&lt;/code&gt; and later. The macro value is still reported in the &lt;code&gt;Boost_VERSION_MACRO&lt;/code&gt; variable.</source>
          <target state="translated">CMake 3.14 이하에서 모듈은 &lt;code&gt;boost/version.hpp&lt;/code&gt; 파일 의 전 처리기 정의 &lt;code&gt;BOOST_VERSION&lt;/code&gt; 에 지정된대로 Boost 버전 번호를보고 합니다. CMake 3.15 이상에서는보고 된 버전 번호 가 Boost &lt;code&gt;1.70.0&lt;/code&gt; 이상 과 함께 제공되는 CMake 패키지에서보고 한 &lt;code&gt;x.y.z&lt;/code&gt; 형식 과 일치하는 것이 좋습니다 . 매크로 값은 여전히 &lt;code&gt;Boost_VERSION_MACRO&lt;/code&gt; 변수에 보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="abc7d4f4650323e98e8d9c5ac28105af13619a2e" translate="yes" xml:space="preserve">
          <source>In CMake 3.14 and below, MSVC runtime library selection flags are added to the default &lt;code&gt;CMAKE_&amp;lt;LANG&amp;gt;_FLAGS_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; cache entries by CMake automatically. This allows users to edit their cache entries to adjust the flags. However, the presence of such default flags is problematic for projects that want to choose a different runtime library programmatically. In particular, it requires string editing of the &lt;code&gt;CMAKE_&amp;lt;LANG&amp;gt;_FLAGS_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; variables with knowledge of the CMake builtin defaults so they can be replaced.</source>
          <target state="translated">CMake 3.14 이하에서는 MSVC 런타임 라이브러리 선택 플래그가 CMake에 의해 기본 &lt;code&gt;CMAKE_&amp;lt;LANG&amp;gt;_FLAGS_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; 캐시 항목에 자동으로 추가됩니다. 이를 통해 사용자는 캐시 항목을 편집하여 플래그를 조정할 수 있습니다. 그러나 이러한 기본 플래그가 있으면 프로그래밍 방식으로 다른 런타임 라이브러리를 선택하려는 프로젝트에서 문제가됩니다. 특히 CMake 내장 기본값을 알고 있는 &lt;code&gt;CMAKE_&amp;lt;LANG&amp;gt;_FLAGS_&amp;lt;CONFIG&amp;gt;&lt;/code&gt; 변수 의 문자열 편집이 필요 하므로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b83574eb8256db0a63919a719668937f20ba82" translate="yes" xml:space="preserve">
          <source>In CMake 3.15 and earlier, &lt;code&gt;RPATH&lt;/code&gt; entries set via &lt;a href=&quot;../variable/cmake_install_rpath#variable:CMAKE_INSTALL_RPATH&quot; id=&quot;index-0-variable:CMAKE_INSTALL_RPATH&quot;&gt;&lt;code&gt;CMAKE_INSTALL_RPATH&lt;/code&gt;&lt;/a&gt; or via &lt;a href=&quot;../prop_tgt/install_rpath#prop_tgt:INSTALL_RPATH&quot; id=&quot;index-0-prop_tgt:INSTALL_RPATH&quot;&gt;&lt;code&gt;INSTALL_RPATH&lt;/code&gt;&lt;/a&gt; have not been escaped before being inserted into the &lt;code&gt;cmake_install.cmake&lt;/code&gt; script. Dynamic linkers on ELF-based systems (e.g. Linux and FreeBSD) allow certain keywords in &lt;code&gt;RPATH&lt;/code&gt; entries, such as &lt;code&gt;${ORIGIN}&lt;/code&gt; (More details are available in the &lt;code&gt;ld.so&lt;/code&gt; man pages on those systems). The syntax of these keywords can match CMake&amp;rsquo;s variable syntax. In order to not be substituted (usually to an empty string) already by the intermediary &lt;code&gt;cmake_install.cmake&lt;/code&gt; script, the user had to double-escape such &lt;code&gt;RPATH&lt;/code&gt; keywords, e.g. &lt;code&gt;set(CMAKE_INSTALL_RPATH &quot;\\\${ORIGIN}/../lib&quot;)&lt;/code&gt;. Since the intermediary &lt;code&gt;cmake_install.cmake&lt;/code&gt; script is an implementation detail of CMake, CMake 3.16 and later will make sure &lt;code&gt;RPATH&lt;/code&gt; entries are inserted literally by escaping any coincidental CMake syntax.</source>
          <target state="translated">CMake 3.15 및 이전 버전에서는 &lt;a href=&quot;../variable/cmake_install_rpath#variable:CMAKE_INSTALL_RPATH&quot; id=&quot;index-0-variable:CMAKE_INSTALL_RPATH&quot;&gt; &lt;code&gt;CMAKE_INSTALL_RPATH&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../prop_tgt/install_rpath#prop_tgt:INSTALL_RPATH&quot; id=&quot;index-0-prop_tgt:INSTALL_RPATH&quot;&gt; &lt;code&gt;INSTALL_RPATH&lt;/code&gt; &lt;/a&gt; 를 통해 설정된 &lt;code&gt;RPATH&lt;/code&gt; 항목 이 &lt;code&gt;cmake_install.cmake&lt;/code&gt; 스크립트 에 삽입되기 전에 이스케이프되지 않았습니다 . ELF 기반 시스템 (예 : Linux 및 FreeBSD)의 동적 링커 는 &lt;code&gt;${ORIGIN}&lt;/code&gt; 과 같은 &lt;code&gt;RPATH&lt;/code&gt; 항목의 특정 키워드를 허용 합니다 (자세한 내용은 해당 시스템 의 &lt;code&gt;ld.so&lt;/code&gt; man 페이지에서 볼 수 있음 ). 이러한 키워드의 구문은 CMake의 변수 구문과 일치 할 수 있습니다. 중간 &lt;code&gt;cmake_install.cmake&lt;/code&gt; 스크립트로 이미 대체되지 않도록 (일반적으로 빈 문자열로) 사용자는 이러한 &lt;code&gt;RPATH&lt;/code&gt; 키워드 를 이중 이스케이프해야합니다. &lt;code&gt;set(CMAKE_INSTALL_RPATH &quot;\\\${ORIGIN}/../lib&quot;)&lt;/code&gt; . 중개 &lt;code&gt;cmake_install.cmake&lt;/code&gt; 스크립트는 CMake의 구현 세부 사항이므로 CMake 3.16 이상 에서는 우연한 CMake 구문을 이스케이프하여 &lt;code&gt;RPATH&lt;/code&gt; 항목이 문자 그대로 삽입 되었는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="d277e3b954ca87ac257f2d438c009f94d4a88f65" translate="yes" xml:space="preserve">
          <source>In CMake 3.16 and below the &lt;a href=&quot;../command/target_compile_options#command:target_compile_options&quot; id=&quot;index-1-command:target_compile_options&quot;&gt;&lt;code&gt;target_compile_options()&lt;/code&gt;&lt;/a&gt; ignores the &lt;code&gt;BEFORE&lt;/code&gt; keyword in private scope. CMake 3.17 and later honors &lt;code&gt;BEFORE&lt;/code&gt; keyword in all scopes. This policy provides compatibility for projects that have not been updated to expect the new behavior.</source>
          <target state="translated">CMake 3.16 이하에서 &lt;a href=&quot;../command/target_compile_options#command:target_compile_options&quot; id=&quot;index-1-command:target_compile_options&quot;&gt; &lt;code&gt;target_compile_options()&lt;/code&gt; &lt;/a&gt; 는 private 범위 의 &lt;code&gt;BEFORE&lt;/code&gt; 키워드를 무시합니다 . CMake 3.17 이상 은 모든 범위에서 &lt;code&gt;BEFORE&lt;/code&gt; 키워드를 따릅니다. 이 정책은 새로운 동작을 예상하도록 업데이트되지 않은 프로젝트에 대한 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bef6ad23c580562c14dda513ee6797d627b3baad" translate="yes" xml:space="preserve">
          <source>In CMake 3.16 and below the interface link properties attached to libraries are not propagated for private dependencies of static libraries. Only the libraries themselves are propagated to link the dependent binary. CMake 3.17 and later prefer to propagate all interface link properties. This policy provides compatibility for projects that have not been updated to expect the new behavior.</source>
          <target state="translated">CMake 3.16 이하에서는 라이브러리에 연결된 인터페이스 링크 속성이 정적 라이브러리의 비공개 종속성에 대해 전파되지 않습니다. 라이브러리 자체 만 전파되어 종속 바이너리를 연결합니다. CMake 3.17 이상은 모든 인터페이스 링크 속성을 전파하는 것을 선호합니다. 이 정책은 새로운 동작을 예상하도록 업데이트되지 않은 프로젝트에 대한 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf3cdb495a4764b6e69f49536e598806fabece28" translate="yes" xml:space="preserve">
          <source>In CMake 3.16 and below, if a variable was not defined at all or just defined locally, the &lt;a href=&quot;../command/mark_as_advanced#command:mark_as_advanced&quot; id=&quot;index-1-command:mark_as_advanced&quot;&gt;&lt;code&gt;mark_as_advanced()&lt;/code&gt;&lt;/a&gt; command would create a new cache entry with an &lt;code&gt;UNINITIALIZED&lt;/code&gt; type and no value. When a &lt;a href=&quot;../command/find_path#command:find_path&quot; id=&quot;index-0-command:find_path&quot;&gt;&lt;code&gt;find_path()&lt;/code&gt;&lt;/a&gt; (or other similar &lt;code&gt;find_&lt;/code&gt; command) would next run, it would find this undefined cache entry and set it up with an empty string value. This process would end up deleting the local variable in the process (due to the way the cache works), effectively clearing any stored &lt;code&gt;find_&lt;/code&gt; results that were only available in the local scope.</source>
          <target state="translated">CMake 3.16 이하에서 변수가 전혀 정의되지 않았거나 로컬로 정의 된 경우 &lt;a href=&quot;../command/mark_as_advanced#command:mark_as_advanced&quot; id=&quot;index-1-command:mark_as_advanced&quot;&gt; &lt;code&gt;mark_as_advanced()&lt;/code&gt; &lt;/a&gt; 명령은 &lt;code&gt;UNINITIALIZED&lt;/code&gt; 유형으로 값이없는 새 캐시 항목을 만듭니다 . 때 &lt;a href=&quot;../command/find_path#command:find_path&quot; id=&quot;index-0-command:find_path&quot;&gt; &lt;code&gt;find_path()&lt;/code&gt; &lt;/a&gt; (또는 다른 유사한 &lt;code&gt;find_&lt;/code&gt; 의 명령) 다음에 실행됩니다,이 정의되지 않은 캐시 항목을 찾아 빈 문자열 값을 설정하는 것입니다. 이 프로세스는 캐시가 작동하는 방식으로 인해 프로세스에서 로컬 변수를 삭제 하여 로컬 범위에서만 사용할 수 있는 저장된 &lt;code&gt;find_&lt;/code&gt; 결과를 효과적으로 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="aa45b1c9c742b0a84a82071e4542c5cec95b7523" translate="yes" xml:space="preserve">
          <source>In CMake 3.17 and below, a target can link to a target aliased to itself.</source>
          <target state="translated">CMake 3.17 이하에서는 대상이 자신에게 별칭이 지정된 대상에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c25a280f96bdef5898537e9c793009e48c97049" translate="yes" xml:space="preserve">
          <source>In CMake 3.17 and below, an &lt;code&gt;ALIAS&lt;/code&gt; target can overwrite silently an existing target with the same name.</source>
          <target state="translated">CMake 3.17 이하에서는 &lt;code&gt;ALIAS&lt;/code&gt; 대상이 동일한 이름의 기존 대상을 자동으로 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52233ecd5059a884b04f18e073e2f2bf721d7e55" translate="yes" xml:space="preserve">
          <source>In CMake 3.17 and below, link options are not used by the device link step.</source>
          <target state="translated">CMake 3.17 이하에서는 기기 링크 단계에서 링크 옵션을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd8d58d6380ec62bf0653fe5bfb39fa563d3a50b" translate="yes" xml:space="preserve">
          <source>In CMake 3.17 and below, multiple calls to &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt;&lt;code&gt;export()&lt;/code&gt;&lt;/a&gt; command with the same &lt;code&gt;FILE&lt;/code&gt; without &lt;code&gt;APPEND&lt;/code&gt; are accepted silently but only the last occurrence is taken into account during the generation.</source>
          <target state="translated">CMake 3.17 이하에서는 &lt;code&gt;APPEND&lt;/code&gt; 없이 동일한 &lt;code&gt;FILE&lt;/code&gt; 을 사용하여 &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt; &lt;code&gt;export()&lt;/code&gt; &lt;/a&gt; 명령에 대한 여러 호출이 자동으로 허용되지만 생성 중에 마지막 발생 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="b9eef3f5013259375b6f7662fbb049bb4a8f7a36" translate="yes" xml:space="preserve">
          <source>In CMake 3.18 and below, step targets have some limitations:</source>
          <target state="translated">CMake 3.18 이하에서는 단계 대상에 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d00dcdb410145e1c763c21975aff70d3ba3fed0" translate="yes" xml:space="preserve">
          <source>In CMake 3.18 and below, the &lt;a href=&quot;../command/find_program#command:find_program&quot; id=&quot;index-1-command:find_program&quot;&gt;&lt;code&gt;find_program()&lt;/code&gt;&lt;/a&gt; command on UNIX would find files that are readable without requiring execute permission, and would not find files that are executable without read permission. In CMake 3.19 and above, &lt;code&gt;find_program&lt;/code&gt; now prefers to require execute permission but not read permission. This policy provides compatibility with projects that have not been updated to expect the new behavior.</source>
          <target state="translated">CMake 3.18 이하 에서 UNIX 의 &lt;a href=&quot;../command/find_program#command:find_program&quot; id=&quot;index-1-command:find_program&quot;&gt; &lt;code&gt;find_program()&lt;/code&gt; &lt;/a&gt; 명령은 실행 권한없이 읽을 수있는 파일을 찾고 읽기 권한없이 실행 가능한 파일은 찾지 못합니다. CMake 3.19 이상에서 &lt;code&gt;find_program&lt;/code&gt; 은 이제 실행 권한이 필요하지만 읽기 권한은 필요하지 않습니다. 이 정책은 새로운 동작을 예상하도록 업데이트되지 않은 프로젝트와의 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="173094a741e02ff7542fa929d53bbf5ed65b3e40" translate="yes" xml:space="preserve">
          <source>In CMake 3.18 and lower a dependency on the evaluated target of the above generator expressions would always be added. CMake 3.19 and above prefer to not add this dependency. This policy provides compatibility for projects that have not been updated to expect the new behavior.</source>
          <target state="translated">CMake 3.18 이하에서는 위 생성기 표현식의 평가 대상에 대한 종속성이 항상 추가됩니다. CMake 3.19 이상은이 종속성을 추가하지 않는 것을 선호합니다. 이 정책은 새로운 동작을 예상하도록 업데이트되지 않은 프로젝트에 대한 호환성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e354a84c7f0f402f5a9aab36bc287c5bf3701139" translate="yes" xml:space="preserve">
          <source>In CMake 3.18 and lower, the Makefile generators put a copy of both custom commands in the Makefile for target &lt;code&gt;second&lt;/code&gt; even though its dependency on target &lt;code&gt;first&lt;/code&gt; ensures that the first custom command runs before the second. Running &lt;code&gt;make second&lt;/code&gt; would cause the first custom command to run once in the &lt;code&gt;first&lt;/code&gt; target and then again in the &lt;code&gt;second&lt;/code&gt; target.</source>
          <target state="translated">CMake 3.18 및 하부에서 메이크 발전기 타겟 메이크 모두 지정 명령의 사본을 넣어 &lt;code&gt;second&lt;/code&gt; 비록 대상 의존도 &lt;code&gt;first&lt;/code&gt; 것을 보장 제 전에 제 지정 명령 실행. 실행 &lt;code&gt;make second&lt;/code&gt; 첫 번째 사용자 정의 명령은 한 번 실행하는 원인이 &lt;code&gt;first&lt;/code&gt; 다시 다음 타겟과 &lt;code&gt;second&lt;/code&gt; 대상입니다.</target>
        </trans-unit>
        <trans-unit id="9560cec4710b5fdc0ce4e694e7776bc6b003bf3f" translate="yes" xml:space="preserve">
          <source>In CMake 3.19 and above, the &lt;a href=&quot;../module/externalproject#module:ExternalProject&quot; id=&quot;index-1-module:ExternalProject&quot;&gt;&lt;code&gt;ExternalProject&lt;/code&gt;&lt;/a&gt; module prefers a revised design to address these problems:</source>
          <target state="translated">CMake 3.19 이상에서 &lt;a href=&quot;../module/externalproject#module:ExternalProject&quot; id=&quot;index-1-module:ExternalProject&quot;&gt; &lt;code&gt;ExternalProject&lt;/code&gt; &lt;/a&gt; 모듈은 이러한 문제를 해결하기 위해 수정 된 디자인을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="c4ca3b41553414dd479832020e4819c448616aaa" translate="yes" xml:space="preserve">
          <source>In CMake versions 2.6.4 and lower the &lt;a href=&quot;../command/if#command:if&quot; id=&quot;index-1-command:if&quot;&gt;&lt;code&gt;if()&lt;/code&gt;&lt;/a&gt; command implicitly dereferenced arguments corresponding to variables, even those named like numbers or boolean constants, except for &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. Numbers and boolean constants such as &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;notfound&lt;/code&gt;, &lt;code&gt;ignore&lt;/code&gt; (all case insensitive) were recognized in some cases but not all. For example, the code &lt;code&gt;if(TRUE)&lt;/code&gt; might have evaluated as &lt;code&gt;false&lt;/code&gt;. Numbers such as 2 were recognized only in boolean expressions like &lt;code&gt;if(NOT 2)&lt;/code&gt; (leading to &lt;code&gt;false&lt;/code&gt;) but not as a single-argument like &lt;code&gt;if(2)&lt;/code&gt; (also leading to &lt;code&gt;false&lt;/code&gt;). Later versions of CMake prefer to treat numbers and boolean constants literally, so they should not be used as variable names.</source>
          <target state="translated">CMake 버전 2.6.4 이하에서 &lt;a href=&quot;../command/if#command:if&quot; id=&quot;index-1-command:if&quot;&gt; &lt;code&gt;if()&lt;/code&gt; &lt;/a&gt; 명령은 변수에 해당하는 인수를 암시 적으로 역 참조합니다 ( &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 을 제외하고 숫자 또는 부울 상수와 같은 이름의 인수도 포함) . &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;notfound&lt;/code&gt; , &lt;code&gt;ignore&lt;/code&gt; (대소 문자를 구분하지 않음) 와 같은 숫자 및 부울 상수 는 일부 경우에 인식되지만 전부는 아닙니다. 예를 들어, &lt;code&gt;if(TRUE)&lt;/code&gt; 코드 는 &lt;code&gt;false&lt;/code&gt; 로 평가되었을 수 있습니다.. 2와 같은 숫자는 &lt;code&gt;if(NOT 2)&lt;/code&gt; ( &lt;code&gt;false&lt;/code&gt; 로 이어지는 ) 와 같은 부울 식에서 만 인식 되었지만 &lt;code&gt;if(2)&lt;/code&gt; 와 같은 단일 인수로도 인식되지 않았습니다 ( &lt;code&gt;false&lt;/code&gt; 로 이어짐 ). 이후 버전의 CMake는 숫자와 부울 상수를 문자 그대로 처리하는 것을 선호하므로 변수 이름으로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="fae7d644c697e56b02ba19472fab36952e4fb166" translate="yes" xml:space="preserve">
          <source>In CMake versions 2.8.2 through 2.8.12, this variable holds the fourth version number component of the &lt;a href=&quot;cmake_version#variable:CMAKE_VERSION&quot; id=&quot;index-0-variable:CMAKE_VERSION&quot;&gt;&lt;code&gt;CMAKE_VERSION&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">CMake 버전 2.8.2-2.8.12에서이 변수는 &lt;a href=&quot;cmake_version#variable:CMAKE_VERSION&quot; id=&quot;index-0-variable:CMAKE_VERSION&quot;&gt; &lt;code&gt;CMAKE_VERSION&lt;/code&gt; &lt;/a&gt; 변수 의 네 번째 버전 번호 구성 요소를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="3994edbc03f12e3873ed0faf0b76d0fe4f8a8b77" translate="yes" xml:space="preserve">
          <source>In CMake versions 3.10.1 and 3.10.2, this option was called &lt;code&gt;TIMEOUT&lt;/code&gt;. This clashed with the &lt;code&gt;TIMEOUT&lt;/code&gt; test property, which is one of the common properties that would be set with the &lt;code&gt;PROPERTIES&lt;/code&gt; keyword, usually leading to legal but unintended behavior. The keyword was changed to &lt;code&gt;DISCOVERY_TIMEOUT&lt;/code&gt; in CMake 3.10.3 to address this problem. The ambiguous behavior of the &lt;code&gt;TIMEOUT&lt;/code&gt; keyword in 3.10.1 and 3.10.2 has not been preserved.</source>
          <target state="translated">CMake 버전 3.10.1 및 3.10.2에서는이 옵션을 &lt;code&gt;TIMEOUT&lt;/code&gt; 이라고했습니다 . 이것은 &lt;code&gt;PROPERTIES&lt;/code&gt; 키워드 로 설정되는 일반적인 속성 중 하나 인 &lt;code&gt;TIMEOUT&lt;/code&gt; 테스트 속성 과 충돌하여 일반적으로 합법적이지만 의도하지 않은 동작으로 이어집니다. 이 문제를 해결하기 위해 CMake 3.10.3에서 키워드가 &lt;code&gt;DISCOVERY_TIMEOUT&lt;/code&gt; 으로 변경되었습니다 . 3.10.1 및 3.10.2에서 &lt;code&gt;TIMEOUT&lt;/code&gt; 키워드 의 모호한 동작은 유지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5eb53b89c84abccbd172e9f7665d4f94fd415fca" translate="yes" xml:space="preserve">
          <source>In CMake versions prior to 3.0 this command returned a command line that directly invokes the native build tool for the current generator. Their implementation of the &lt;code&gt;PROJECT_NAME&lt;/code&gt; option had no useful effects, so CMake now warns on use of the option.</source>
          <target state="translated">3.0 이전의 CMake 버전에서이 명령은 현재 생성기의 기본 빌드 도구를 직접 호출하는 명령 행을 리턴했습니다. &lt;code&gt;PROJECT_NAME&lt;/code&gt; 옵션 의 구현 에는 유용한 효과가 없었으므로 CMake는 이제 옵션 사용에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5dca42f556e4fcf7bb59ad78bbf6d0dd1b3d8f67" translate="yes" xml:space="preserve">
          <source>In Module mode the loaded find module is responsible to honor the request detailed by these variables; see the find module for details. In Config mode &lt;code&gt;find_package&lt;/code&gt; handles &lt;code&gt;REQUIRED&lt;/code&gt;, &lt;code&gt;QUIET&lt;/code&gt;, and &lt;code&gt;[version]&lt;/code&gt; options automatically but leaves it to the package configuration file to handle components in a way that makes sense for the package. The package configuration file may set &lt;code&gt;&amp;lt;PackageName&amp;gt;_FOUND&lt;/code&gt; to false to tell &lt;code&gt;find_package&lt;/code&gt; that component requirements are not satisfied.</source>
          <target state="translated">모듈 모드에서로드 된 찾기 모듈은 이러한 변수에 의해 자세히 설명 된 요청을 처리합니다. 자세한 내용은 find 모듈을 참조하십시오. 구성 모드에서 &lt;code&gt;find_package&lt;/code&gt; 는 &lt;code&gt;REQUIRED&lt;/code&gt; , &lt;code&gt;QUIET&lt;/code&gt; 및 &lt;code&gt;[version]&lt;/code&gt; 옵션을 자동으로 처리하지만 패키지에 적합한 방식으로 구성 요소를 처리하도록 패키지 구성 파일에 남겨 둡니다. 패키지 구성 파일은 &lt;code&gt;&amp;lt;PackageName&amp;gt;_FOUND&lt;/code&gt; 를 false로 &lt;code&gt;find_package&lt;/code&gt; 하여 구성 요소 요구 사항이 충족되지 않음을 find_package 에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90bc7624e2e39f63a4443878d95118f6f8b9e529" translate="yes" xml:space="preserve">
          <source>In Module mode, CMake searches for a file called &lt;code&gt;Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code&gt;. The file is first searched in the &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-0-variable:CMAKE_MODULE_PATH&quot;&gt;&lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt;&lt;/a&gt;, then among the &lt;a href=&quot;../manual/cmake-developer.7#find-modules&quot;&gt;Find Modules&lt;/a&gt; provided by the CMake installation. If the file is found, it is read and processed by CMake. It is responsible for finding the package, checking the version, and producing any needed messages. Some find-modules provide limited or no support for versioning; check the module documentation.</source>
          <target state="translated">모듈 모드에서 CMake는 &lt;code&gt;Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code&gt; 파일을 검색합니다 . 파일은 먼저 &lt;a href=&quot;../variable/cmake_module_path#variable:CMAKE_MODULE_PATH&quot; id=&quot;index-0-variable:CMAKE_MODULE_PATH&quot;&gt; &lt;code&gt;CMAKE_MODULE_PATH&lt;/code&gt; &lt;/a&gt; 에서 검색된 다음 CMake 설치에서 제공 한 &lt;a href=&quot;../manual/cmake-developer.7#find-modules&quot;&gt;찾기 모듈&lt;/a&gt; 중에서 검색됩니다 . 파일이 발견되면 CMake가 파일을 읽고 처리합니다. 패키지를 찾고, 버전을 확인하고, 필요한 메시지를 생성합니다. 일부 찾기 모듈은 버전 관리를 제한적으로 지원하거나 지원하지 않습니다. 모듈 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bd67accab842c1259a891972da1d36bc52886fe6" translate="yes" xml:space="preserve">
          <source>In Visual Studio solution, by default the &lt;code&gt;INSTALL&lt;/code&gt; target will not be part of the default build. Setting this variable will enable the &lt;code&gt;INSTALL&lt;/code&gt; target to be part of the default build.</source>
          <target state="translated">Visual Studio 솔루션에서 기본적으로 &lt;code&gt;INSTALL&lt;/code&gt; 대상은 기본 빌드의 일부가 아닙니다. 이 변수를 설정하면 &lt;code&gt;INSTALL&lt;/code&gt; 대상이 기본 빌드의 일부가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa00d568302b5b8e19e42a7d91ce7994c91f2c5c" translate="yes" xml:space="preserve">
          <source>In Visual Studio solution, by default the &lt;code&gt;PACKAGE&lt;/code&gt; target will not be part of the default build. Setting this variable will enable the &lt;code&gt;PACKAGE&lt;/code&gt; target to be part of the default build.</source>
          <target state="translated">Visual Studio 솔루션에서 기본적으로 &lt;code&gt;PACKAGE&lt;/code&gt; 대상은 기본 빌드의 일부가 아닙니다. 이 변수를 설정하면 &lt;code&gt;PACKAGE&lt;/code&gt; 대상이 기본 빌드의 일부가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb189b5a79af6cbfd40bd6eeac484fae4d0192b4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_build#command:ctest_build&quot; id=&quot;index-0-command:ctest_build&quot;&gt;&lt;code&gt;ctest_build()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_build#command:ctest_build&quot; id=&quot;index-0-command:ctest_build&quot;&gt; &lt;code&gt;ctest_build()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0108a3b8ad00b0b35ec2b8d4631469052c69cf" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_configure#command:ctest_configure&quot; id=&quot;index-0-command:ctest_configure&quot;&gt;&lt;code&gt;ctest_configure()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_configure#command:ctest_configure&quot; id=&quot;index-0-command:ctest_configure&quot;&gt; &lt;code&gt;ctest_configure()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43318da7a2639ac6f1c4b4dcbf7498b8ac9bf561" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_coverage#command:ctest_coverage&quot; id=&quot;index-0-command:ctest_coverage&quot;&gt;&lt;code&gt;ctest_coverage()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_coverage#command:ctest_coverage&quot; id=&quot;index-0-command:ctest_coverage&quot;&gt; &lt;code&gt;ctest_coverage()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89b5b9dad977c71dc5cddce179a082a1f66ab18" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_memcheck#command:ctest_memcheck&quot; id=&quot;index-0-command:ctest_memcheck&quot;&gt;&lt;code&gt;ctest_memcheck()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_memcheck#command:ctest_memcheck&quot; id=&quot;index-0-command:ctest_memcheck&quot;&gt; &lt;code&gt;ctest_memcheck()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="487c35ce6bcfba74e035f483401129536df8a5b2" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_start#command:ctest_start&quot; id=&quot;index-0-command:ctest_start&quot;&gt;&lt;code&gt;ctest_start()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings. The command first runs the command-line specified by the &lt;code&gt;CTEST_CHECKOUT_COMMAND&lt;/code&gt; variable, if set, to initialize the source directory.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_start#command:ctest_start&quot; id=&quot;index-0-command:ctest_start&quot;&gt; &lt;code&gt;ctest_start()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다. 명령은 먼저 &lt;code&gt;CTEST_CHECKOUT_COMMAND&lt;/code&gt; 변수에 의해 지정된 명령 행을 실행하여 ( 설정된 경우) 소스 디렉토리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6fad17710ee7a849a23070df97414a6efd651114" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_submit#command:ctest_submit&quot; id=&quot;index-0-command:ctest_submit&quot;&gt;&lt;code&gt;ctest_submit()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_submit#command:ctest_submit&quot; id=&quot;index-0-command:ctest_submit&quot;&gt; &lt;code&gt;ctest_submit()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71936e6502cfce889a40e4ff2bd8b932fe36e412" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_test#command:ctest_test&quot; id=&quot;index-0-command:ctest_test&quot;&gt;&lt;code&gt;ctest_test()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_test#command:ctest_test&quot; id=&quot;index-0-command:ctest_test&quot;&gt; &lt;code&gt;ctest_test()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7324b400aafb97f6400cda583b36a017e57c0f6" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#ctest-script&quot;&gt;CTest Script&lt;/a&gt;, the &lt;a href=&quot;../command/ctest_update#command:ctest_update&quot; id=&quot;index-0-command:ctest_update&quot;&gt;&lt;code&gt;ctest_update()&lt;/code&gt;&lt;/a&gt; command runs this step. Arguments to the command may specify some of the step settings.</source>
          <target state="translated">A의 &lt;a href=&quot;#ctest-script&quot;&gt;CTest 스크립트&lt;/a&gt; 의 &lt;a href=&quot;../command/ctest_update#command:ctest_update&quot; id=&quot;index-0-command:ctest_update&quot;&gt; &lt;code&gt;ctest_update()&lt;/code&gt; &lt;/a&gt; 명령은이 단계를 실행합니다. 명령에 대한 인수는 일부 단계 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ce3963c46c66f8fcff18a25a83dc99f4e00034d" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;FooConfig.cmake&lt;/code&gt; file there may be code like this to make the install destinations know to the using project:</source>
          <target state="translated">A의 &lt;code&gt;FooConfig.cmake&lt;/code&gt; 의 파일 목적지가 사용하는 프로젝트에 알고 설치하기 위해 다음과 같은 코드가있을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3753e1a317f6a9f6c9bbb54b7a5f9607fca8cb6d" translate="yes" xml:space="preserve">
          <source>In a function, &lt;code&gt;ARGN&lt;/code&gt;, &lt;code&gt;ARGC&lt;/code&gt;, &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;ARGV0&lt;/code&gt;, &lt;code&gt;ARGV1&lt;/code&gt;, &amp;hellip; are true variables in the usual CMake sense. In a macro, they are not, they are string replacements much like the C preprocessor would do with a macro. This has a number of consequences, as explained in the &lt;a href=&quot;#argument-caveats&quot;&gt;Argument Caveats&lt;/a&gt; section below.</source>
          <target state="translated">함수에서 &lt;code&gt;ARGN&lt;/code&gt; , &lt;code&gt;ARGC&lt;/code&gt; , &lt;code&gt;ARGV&lt;/code&gt; 및 &lt;code&gt;ARGV0&lt;/code&gt; , &lt;code&gt;ARGV1&lt;/code&gt; ...은 일반적인 CMake 의미에서 진정한 변수입니다. 매크로에서는 그렇지 않습니다. C 프리 프로세서가 매크로로하는 것처럼 문자열을 대체하는 것입니다. 아래 의 &lt;a href=&quot;#argument-caveats&quot;&gt;인수주의 사항&lt;/a&gt; 섹션에 설명 된대로 여러 가지 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="579a843a8d47b112e922e3a0067ff904a489e088" translate="yes" xml:space="preserve">
          <source>In a similar manner, libraries from other projects may be accessed through &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-11-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; targets.</source>
          <target state="translated">유사한 방식으로 &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-11-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상을 통해 다른 프로젝트의 라이브러리에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="feb0dde0de4d247b825639ee8afea990e68b79da" translate="yes" xml:space="preserve">
          <source>In addition to accepting values from that command, values may be set directly on any directory using the &lt;a href=&quot;../command/set_property#command:set_property&quot; id=&quot;index-0-command:set_property&quot;&gt;&lt;code&gt;set_property()&lt;/code&gt;&lt;/a&gt; command, and can be set on the current directory using the &lt;a href=&quot;../command/set_directory_properties#command:set_directory_properties&quot; id=&quot;index-0-command:set_directory_properties&quot;&gt;&lt;code&gt;set_directory_properties()&lt;/code&gt;&lt;/a&gt; command. A directory gets its initial value from its parent directory if it has one. The initial value of the &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; target property comes from the value of this property. Both directory and target property values are adjusted by calls to the &lt;a href=&quot;../command/include_directories#command:include_directories&quot; id=&quot;index-1-command:include_directories&quot;&gt;&lt;code&gt;include_directories()&lt;/code&gt;&lt;/a&gt; command. Calls to &lt;a href=&quot;../command/set_property#command:set_property&quot; id=&quot;index-1-command:set_property&quot;&gt;&lt;code&gt;set_property()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../command/set_directory_properties#command:set_directory_properties&quot; id=&quot;index-1-command:set_directory_properties&quot;&gt;&lt;code&gt;set_directory_properties()&lt;/code&gt;&lt;/a&gt;, however, will update the directory property value without updating target property values. Therefore direct property updates must be made before calls to &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt;&lt;code&gt;add_executable()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library()&lt;/code&gt;&lt;/a&gt; for targets they are meant to affect.</source>
          <target state="translated">그 명령의 값을 사용할뿐만 아니라, 값은 사용하는 디렉토리에 직접 설정 될 수있다 &lt;a href=&quot;../command/set_property#command:set_property&quot; id=&quot;index-0-command:set_property&quot;&gt; &lt;code&gt;set_property()&lt;/code&gt; &lt;/a&gt; 명령을 이용하고, 현재의 디렉토리에 설정 될 수 &lt;a href=&quot;../command/set_directory_properties#command:set_directory_properties&quot; id=&quot;index-0-command:set_directory_properties&quot;&gt; &lt;code&gt;set_directory_properties()&lt;/code&gt; &lt;/a&gt; 명령. 디렉토리는 상위 디렉토리 (있는 경우)에서 초기 값을 가져옵니다. &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; 대상 특성 의 초기 값 은이 특성의 값에서옵니다. 디렉토리 및 대상 특성 값은 모두 &lt;a href=&quot;../command/include_directories#command:include_directories&quot; id=&quot;index-1-command:include_directories&quot;&gt; &lt;code&gt;include_directories()&lt;/code&gt; &lt;/a&gt; 명령 을 호출하여 조정됩니다 . &lt;a href=&quot;../command/set_property#command:set_property&quot; id=&quot;index-1-command:set_property&quot;&gt; &lt;code&gt;set_property()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../command/set_directory_properties#command:set_directory_properties&quot; id=&quot;index-1-command:set_directory_properties&quot;&gt; &lt;code&gt;set_directory_properties()&lt;/code&gt; &lt;/a&gt; 호출합니다.그러나 대상 특성 값을 업데이트하지 않고 디렉토리 특성 값을 업데이트합니다. 따라서 직접 속성 업데이트를 호출하기 전에 이루어져야합니다 &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt; &lt;code&gt;add_executable()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library()&lt;/code&gt; &lt;/a&gt; 그들이 영향을 의미 타겟.</target>
        </trans-unit>
        <trans-unit id="50a879fc595fded2fb67a7b4fb11a9fda93cf2c1" translate="yes" xml:space="preserve">
          <source>In addition to cmake language files, the &lt;code&gt;EXPORT_ANDROID_MK&lt;/code&gt; mode maybe used to specify an export to the android ndk build system. This mode accepts the same options as the normal export mode. The Android NDK supports the use of prebuilt libraries, both static and shared. This allows cmake to build the libraries of a project and make them available to an ndk build system complete with transitive dependencies, include flags and defines required to use the libraries.</source>
          <target state="translated">cmake 언어 파일 외에도 &lt;code&gt;EXPORT_ANDROID_MK&lt;/code&gt; 모드는 android ndk 빌드 시스템으로 내보내기를 지정하는 데 사용될 수 있습니다. 이 모드는 일반 내보내기 모드와 동일한 옵션을 허용합니다. Android NDK는 사전 빌드 라이브러리 (정적 및 공유)의 사용을 지원합니다. 이를 통해 cmake는 프로젝트의 라이브러리를 빌드하고 전 이적 종속성이 포함 된 ndk 빌드 시스템에 플래그를 포함하고 라이브러리를 사용하는 데 필요한 플래그를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7370c8bb1ae47a436be47a0c5121f782d551c71" translate="yes" xml:space="preserve">
          <source>In addition to finding the includes and libraries required to compile an &lt;code&gt;HDF5&lt;/code&gt; client application, this module also makes an effort to find tools that come with the &lt;code&gt;HDF5&lt;/code&gt; distribution that may be useful for regression testing.</source>
          <target state="translated">이 모듈 은 &lt;code&gt;HDF5&lt;/code&gt; 클라이언트 애플리케이션 을 컴파일하는 데 필요한 포함 및 라이브러리를 찾는 것 외에도 회귀 테스트에 유용한 &lt;code&gt;HDF5&lt;/code&gt; 배포판 과 함께 제공되는 도구를 찾기 위해 노력합니다 .</target>
        </trans-unit>
        <trans-unit id="5d54a0528f7710258d68c8f84aaaa0e907798e54" translate="yes" xml:space="preserve">
          <source>In addition to global properties, this command (for historical reasons) also supports the &lt;a href=&quot;../prop_dir/variables#prop_dir:VARIABLES&quot; id=&quot;index-0-prop_dir:VARIABLES&quot;&gt;&lt;code&gt;VARIABLES&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../prop_dir/macros#prop_dir:MACROS&quot; id=&quot;index-0-prop_dir:MACROS&quot;&gt;&lt;code&gt;MACROS&lt;/code&gt;&lt;/a&gt; directory properties. It also supports a special &lt;code&gt;COMPONENTS&lt;/code&gt; global property that lists the components given to the &lt;a href=&quot;install#command:install&quot; id=&quot;index-0-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">전역 특성 &lt;a href=&quot;../prop_dir/macros#prop_dir:MACROS&quot; id=&quot;index-0-prop_dir:MACROS&quot;&gt; &lt;code&gt;MACROS&lt;/code&gt; &lt;/a&gt; 명령 (과거 이유로)은 &lt;a href=&quot;../prop_dir/variables#prop_dir:VARIABLES&quot; id=&quot;index-0-prop_dir:VARIABLES&quot;&gt; &lt;code&gt;VARIABLES&lt;/code&gt; &lt;/a&gt; 및 MACROS 디렉토리 특성을 지원합니다 . 또한 &lt;a href=&quot;install#command:install&quot; id=&quot;index-0-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 명령에 제공된 구성 요소를 나열 하는 특수 &lt;code&gt;COMPONENTS&lt;/code&gt; 글로벌 특성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="97693a61211b6c08cdfb2cd555ffec5b362cd1ef" translate="yes" xml:space="preserve">
          <source>In addition to referencing the formal parameters you can reference the &lt;code&gt;ARGC&lt;/code&gt; variable which will be set to the number of arguments passed into the function as well as &lt;code&gt;ARGV0&lt;/code&gt;, &lt;code&gt;ARGV1&lt;/code&gt;, &lt;code&gt;ARGV2&lt;/code&gt;, &amp;hellip; which will have the actual values of the arguments passed in. This facilitates creating functions with optional arguments.</source>
          <target state="translated">공식 매개 변수를 참조하는 것 외에도 &lt;code&gt;ARGC&lt;/code&gt; 변수는 함수에 전달 된 인수 수와 &lt;code&gt;ARGV0&lt;/code&gt; , &lt;code&gt;ARGV1&lt;/code&gt; , &lt;code&gt;ARGV2&lt;/code&gt; 등으로 설정 될 수 있습니다.이 인수는 인수의 실제 값이 전달됩니다. 선택적 인수로 함수 작성</target>
        </trans-unit>
        <trans-unit id="3434845571c6e46ffa234c8b21b2ffc295a3c478" translate="yes" xml:space="preserve">
          <source>In addition to referencing the formal parameters you can reference the values &lt;code&gt;${ARGC}&lt;/code&gt; which will be set to the number of arguments passed into the function as well as &lt;code&gt;${ARGV0}&lt;/code&gt;, &lt;code&gt;${ARGV1}&lt;/code&gt;, &lt;code&gt;${ARGV2}&lt;/code&gt;, &amp;hellip; which will have the actual values of the arguments passed in. This facilitates creating macros with optional arguments.</source>
          <target state="translated">공식 매개 변수를 참조 하는 것 외에도 &lt;code&gt;${ARGV0}&lt;/code&gt; , &lt;code&gt;${ARGV1}&lt;/code&gt; , &lt;code&gt;${ARGV2}&lt;/code&gt; , $ {ARGV2} 와 같이 함수에 전달되는 인수 수로 설정되는 &lt;code&gt;${ARGC}&lt;/code&gt; 값을 참조 할 수 있습니다. 인수의 실제 값을 전달하십시오. 이는 선택적 인수를 사용하여 매크로 작성을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="3dabd33fa95da3cf66e6d9c8b7a5cce0374b6cb3" translate="yes" xml:space="preserve">
          <source>In addition to the above cache variables, the following cache variables are also defined for each content name (&lt;code&gt;&amp;lt;ucName&amp;gt;&lt;/code&gt; is the uppercased value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;):</source>
          <target state="translated">위의 캐시 변수 외에도 각 컨텐츠 이름에 대해 다음 캐시 변수가 정의됩니다 ( &lt;code&gt;&amp;lt;ucName&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 의 대문자 값임 ).</target>
        </trans-unit>
        <trans-unit id="94ed95d0c53ea8fa8873d2f2f706c0c390a1c5fc" translate="yes" xml:space="preserve">
          <source>In addition to the above explicit options, any other unrecognized options are passed through unmodified to &lt;a href=&quot;externalproject#command:externalproject_add&quot; id=&quot;index-5-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt; to perform the download, patch and update steps. The following options are explicitly prohibited (they are disabled by the &lt;code&gt;FetchContent_Populate()&lt;/code&gt; command):</source>
          <target state="translated">위의 명시 적 옵션 외에도 인식 할 수없는 다른 옵션은 수정되지 않은 &lt;a href=&quot;externalproject#command:externalproject_add&quot; id=&quot;index-5-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; 로 전달 되어 다운로드, 패치 및 업데이트 단계를 수행합니다. 다음 옵션은 명시 적으로 금지되어 있습니다 ( &lt;code&gt;FetchContent_Populate()&lt;/code&gt; 명령으로 비활성화 ).</target>
        </trans-unit>
        <trans-unit id="d5dd10862833ccd92e2b4b6f172f88e43ebfc131" translate="yes" xml:space="preserve">
          <source>In addition to the common options listed above, each target can accept the following additional arguments:</source>
          <target state="translated">위에 나열된 일반적인 옵션 외에도 각 대상은 다음과 같은 추가 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a49868c0e41bd48c9083505542b8d5cd093e0c8" translate="yes" xml:space="preserve">
          <source>In all cases the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is treated as case-insensitive and corresponds to any of the names specified (&lt;code&gt;&amp;lt;PackageName&amp;gt;&lt;/code&gt; or names given by &lt;code&gt;NAMES&lt;/code&gt;).</source>
          <target state="translated">모든 경우에 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 대소 문자를 구분하지 않으며 지정된 이름 ( &lt;code&gt;&amp;lt;PackageName&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;NAMES&lt;/code&gt; 가 지정한 이름 )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d3c51d75965d97b1950e57135b6774b69840c10e" translate="yes" xml:space="preserve">
          <source>In all cases the &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; may be zero or more of the &lt;a href=&quot;#options&quot;&gt;Options&lt;/a&gt; below.</source>
          <target state="translated">모든 경우에 &lt;code&gt;&amp;lt;options&amp;gt;&lt;/code&gt; 은 아래 &lt;a href=&quot;#options&quot;&gt;옵션&lt;/a&gt; 중 0 개 이상일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6acbf382166d428d3e4cf5ab410fd7895fcb887a" translate="yes" xml:space="preserve">
          <source>In an effort to remove some clutter and clear up some issues for people who are not necessarily Tcl/Tk gurus/developers, some variables were moved or removed. Changes compared to CMake 2.4 are:</source>
          <target state="translated">Tcl / Tk 전문가 / 개발자 일 필요는없는 사람들의 혼란을 없애고 일부 문제를 해결하기 위해 일부 변수가 이동되거나 제거되었습니다. CMake 2.4와 비교 한 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53d65c0b6bf60de95e52df5f2a3f462eaac305bf" translate="yes" xml:space="preserve">
          <source>In another directory, we can link unconditionally to the &lt;code&gt;Upstream::lib1&lt;/code&gt; target, which may be an &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-12-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; target from a package, or an &lt;code&gt;ALIAS&lt;/code&gt; target if built as part of the same buildsystem.</source>
          <target state="translated">다른 디렉토리에서 &lt;code&gt;Upstream::lib1&lt;/code&gt; 대상에 무조건 연결할 수 있습니다. Upstream :: lib1 대상 ( 패키지에서 &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-12-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상이거나 동일한 빌드 시스템의 일부로 빌드 된 경우 &lt;code&gt;ALIAS&lt;/code&gt; 대상 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="eef826a55cac06c1879ce9ba465cfaebe56eca9c" translate="yes" xml:space="preserve">
          <source>In both of these cases (typically on the first run in a new build tree), the &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-4-command:option&quot;&gt;&lt;code&gt;option()&lt;/code&gt;&lt;/a&gt; command gives the cache entry type &lt;code&gt;BOOL&lt;/code&gt; and removes any normal (non-cached) variable of the same name. In the remaining case that the cache entry of the specified name already exists and has a type (typically on later runs in a build tree), the &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-5-command:option&quot;&gt;&lt;code&gt;option()&lt;/code&gt;&lt;/a&gt; command changes nothing and any normal variable of the same name remains set.</source>
          <target state="translated">이 두 가지 경우 (일반적으로 새 빌드 트리에서 첫 번째 실행시)에서 &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-4-command:option&quot;&gt; &lt;code&gt;option()&lt;/code&gt; &lt;/a&gt; 명령은 캐시 항목 유형 &lt;code&gt;BOOL&lt;/code&gt; 을 제공하고 동일한 이름의 일반 (캐시되지 않은) 변수를 제거합니다. 지정된 이름의 캐시 항목이 이미 존재하고 유형 (일반적으로 빌드 트리에서 나중에 실행 됨)을 갖는 나머지 경우 &lt;a href=&quot;../command/option#command:option&quot; id=&quot;index-5-command:option&quot;&gt; &lt;code&gt;option()&lt;/code&gt; &lt;/a&gt; 명령은 아무 것도 변경하지 않으며 동일한 이름의 일반 변수는 설정된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d4d2fd211b265548d953b40147e0537bd2cf7b8" translate="yes" xml:space="preserve">
          <source>In build trees generated by CMake, this configuration file is generated by the &lt;a href=&quot;../module/ctest#module:CTest&quot; id=&quot;index-0-module:CTest&quot;&gt;&lt;code&gt;CTest&lt;/code&gt;&lt;/a&gt; module if included by the project. The module uses variables to obtain a value for each setting as documented with the settings below.</source>
          <target state="translated">CMake에 의해 생성 된 빌드 트리에서이 구성 파일은 프로젝트에 포함 된 경우 &lt;a href=&quot;../module/ctest#module:CTest&quot; id=&quot;index-0-module:CTest&quot;&gt; &lt;code&gt;CTest&lt;/code&gt; &lt;/a&gt; 모듈에 의해 생성됩니다 . 모듈은 변수를 사용하여 아래 설정에 설명 된대로 각 설정에 대한 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1424f591443e77ee7cef06a3de669dbef60b455c" translate="yes" xml:space="preserve">
          <source>In buildsystems which contain &lt;code&gt;foo.c&lt;/code&gt; and &lt;code&gt;foo.cpp&lt;/code&gt;, building the &lt;code&gt;foo.i&lt;/code&gt; target will preprocess both files.</source>
          <target state="translated">&lt;code&gt;foo.c&lt;/code&gt; 및 &lt;code&gt;foo.cpp&lt;/code&gt; 를 포함하는 빌드 시스템에서 &lt;code&gt;foo.i&lt;/code&gt; 타겟을 빌드하면 두 파일이 모두 사전 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b396b032ed160a8687e2ead0aeb30c843bb59dd8" translate="yes" xml:space="preserve">
          <source>In case of malformed variables CMake will fail:</source>
          <target state="translated">잘못된 변수의 경우 CMake가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fe856104fa4469feb8fa40c88847f24bf3e30606" translate="yes" xml:space="preserve">
          <source>In cases where a non-trivial generator expression is used, the &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; expression may be used within the argument of an &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; expression. It is a replacement marker which expands to the installation prefix when imported by a consuming project.</source>
          <target state="translated">적지 않은 발전기 표현이 사용되는 경우, &lt;code&gt;INSTALL_PREFIX&lt;/code&gt; 의 발현은의 인수 내에서 사용될 수있다 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 의 발현. 소비하는 프로젝트에서 가져올 때 설치 접두사로 확장되는 대체 마커입니다.</target>
        </trans-unit>
        <trans-unit id="b011d3c74fd868c800972d925777646d63cd2366" translate="yes" xml:space="preserve">
          <source>In cases where it is known that a package configuration file is provided by upstream, and only that should be used, the &lt;code&gt;CONFIG&lt;/code&gt; keyword may be passed to &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">패키지 구성 파일이 업스트림에 의해 제공되고 사용해야하는 것으로 알려진 경우 &lt;code&gt;CONFIG&lt;/code&gt; 키워드는 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-3-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de15853a2871cb4dd054a7627f7786744075e443" translate="yes" xml:space="preserve">
          <source>In cross-compiling or packaging scenarios where the sysroot is read-only or where the sysroot should otherwise remain pristine, the &lt;a href=&quot;../../variable/cmake_staging_prefix#variable:CMAKE_STAGING_PREFIX&quot; id=&quot;index-0-variable:CMAKE_STAGING_PREFIX&quot;&gt;&lt;code&gt;CMAKE_STAGING_PREFIX&lt;/code&gt;&lt;/a&gt; variable can be set to a location to actually install the files.</source>
          <target state="translated">sysroot가 읽기 전용이거나 그렇지 않으면 sysroot가 원래 상태로 유지되어야하는 크로스 컴파일 또는 패키징 시나리오에서 &lt;a href=&quot;../../variable/cmake_staging_prefix#variable:CMAKE_STAGING_PREFIX&quot; id=&quot;index-0-variable:CMAKE_STAGING_PREFIX&quot;&gt; &lt;code&gt;CMAKE_STAGING_PREFIX&lt;/code&gt; &lt;/a&gt; 변수를 실제로 파일을 설치할 위치로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="008f2be7204bb4603233413b9f5b594b55c2417d" translate="yes" xml:space="preserve">
          <source>In cygwin, look for the cygwin version first. Don&amp;rsquo;t look for it later to avoid finding the cygwin version on a Win32 build.</source>
          <target state="translated">cygwin에서 cygwin 버전을 먼저 찾으십시오. Win32 빌드에서 cygwin 버전을 찾지 않으려면 나중에 찾지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bc86e86efba49805a225a14ad8716f777dd1b746" translate="yes" xml:space="preserve">
          <source>In each of the following JSON-related subcommands, if the optional &lt;code&gt;ERROR_VARIABLE&lt;/code&gt; argument is given, errors will be reported in &lt;code&gt;&amp;lt;error-variable&amp;gt;&lt;/code&gt; and the &lt;code&gt;&amp;lt;out-var&amp;gt;&lt;/code&gt; will be set to &lt;code&gt;&amp;lt;member|index&amp;gt;-[&amp;lt;member|index&amp;gt;...]-NOTFOUND&lt;/code&gt; with the path elements up to the point where the error occurred, or just &lt;code&gt;NOTFOUND&lt;/code&gt; if there is no relevant path. If an error occurs but the &lt;code&gt;ERROR_VARIABLE&lt;/code&gt; option is not present, a fatal error message is generated. If no error occurs, the &lt;code&gt;&amp;lt;error-variable&amp;gt;&lt;/code&gt; will be set to &lt;code&gt;NOTFOUND&lt;/code&gt;.</source>
          <target state="translated">옵션의 경우 다음과 같은 JSON 관련 하위 명령의 각각에서, &lt;code&gt;ERROR_VARIABLE&lt;/code&gt; 인수가 주어, 오류가보고됩니다 &lt;code&gt;&amp;lt;error-variable&amp;gt;&lt;/code&gt; 과는 &lt;code&gt;&amp;lt;out-var&amp;gt;&lt;/code&gt; 로 설정됩니다 &lt;code&gt;&amp;lt;member|index&amp;gt;-[&amp;lt;member|index&amp;gt;...]-NOTFOUND&lt;/code&gt; 오류가 발생한 지점까지 경로 요소가있는 &lt;code&gt;NOTFOUND&lt;/code&gt; 또는 관련 경로가없는 경우 NOTFOUND 입니다. 오류가 발생했지만 &lt;code&gt;ERROR_VARIABLE&lt;/code&gt; 옵션이 없으면 치명적인 오류 메시지가 생성됩니다. 오류가 발생하지 않으면 &lt;code&gt;&amp;lt;error-variable&amp;gt;&lt;/code&gt; 이 &lt;code&gt;NOTFOUND&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="12e446a6b5af8852c6a882e3f68fa7ab24de49ad" translate="yes" xml:space="preserve">
          <source>In either case (or even when providing both variables and imported targets), find modules should provide backwards compatibility with old versions that had the same name.</source>
          <target state="translated">두 경우 모두 (또는 변수와 가져온 대상을 모두 제공하는 경우에도) 찾기 모듈은 동일한 이름을 가진 이전 버전과의 호환성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="da2fc9270765521b14ff00542bf409c894166e1d" translate="yes" xml:space="preserve">
          <source>In more complex project hierarchies, the dependency relationships can be more complicated. Consider a hierarchy where &lt;code&gt;projA&lt;/code&gt; is the top level project and it depends directly on projects &lt;code&gt;projB&lt;/code&gt; and &lt;code&gt;projC&lt;/code&gt;. Both &lt;code&gt;projB&lt;/code&gt; and &lt;code&gt;projC&lt;/code&gt; can be built standalone and they also both depend on another project &lt;code&gt;projD&lt;/code&gt;. &lt;code&gt;projB&lt;/code&gt; additionally depends on &lt;code&gt;projE&lt;/code&gt;. This example assumes that all five projects are available on a company git server. The &lt;code&gt;CMakeLists.txt&lt;/code&gt; of each project might have sections like the following:</source>
          <target state="translated">보다 복잡한 프로젝트 계층에서는 종속성 관계가 더 복잡 할 수 있습니다. &lt;code&gt;projA&lt;/code&gt; 가 최상위 프로젝트이고 &lt;code&gt;projB&lt;/code&gt; 및 &lt;code&gt;projC&lt;/code&gt; 프로젝트에 직접 의존 하는 계층을 고려하십시오 . 두 &lt;code&gt;projB&lt;/code&gt; 및 &lt;code&gt;projC&lt;/code&gt; 는 독립을 구축 할 수 있으며 또한 모두 다른 프로젝트에 따라 &lt;code&gt;projD&lt;/code&gt; . &lt;code&gt;projB&lt;/code&gt; 은 추가에 따라 &lt;code&gt;projE&lt;/code&gt; . 이 예에서는 회사 git 서버에서 5 개의 프로젝트를 모두 사용할 수 있다고 가정합니다. 각 프로젝트 의 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 에는 다음과 같은 섹션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed218fea753c58fb2eb5486f89dfe4fd864e22a5" translate="yes" xml:space="preserve">
          <source>In most cases none of the above variables will require setting, unless multiple ICU versions are available and a specific version is required.</source>
          <target state="translated">대부분의 경우 여러 ICU 버전을 사용할 수 있고 특정 버전이 필요한 경우를 제외하고는 위 변수 중 어느 것도 설정이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="575370cf46ed9e09106e304eff794982cfaf6350" translate="yes" xml:space="preserve">
          <source>In most cases none of the above variables will require setting, unless multiple Ice versions are available and a specific version is required. On Windows, the most recent version of Ice will be found through the registry. On Unix, the programs, headers and libraries will usually be in standard locations, but Ice_SLICE_DIRS might not be automatically detected (commonly known locations are searched). All the other variables are defaulted using Ice_HOME, if set. It&amp;rsquo;s possible to set Ice_HOME and selectively specify alternative locations for the other components; this might be required for e.g. newer versions of Visual Studio if the heuristics are not sufficient to identify the correct programs and libraries for the specific Visual Studio version.</source>
          <target state="translated">대부분의 경우 여러 Ice 버전을 사용할 수 있고 특정 버전이 필요한 경우를 제외하고 위 변수 중 어느 것도 설정이 필요하지 않습니다. Windows에서 최신 버전의 Ice는 레지스트리를 통해 찾을 수 있습니다. Unix에서 프로그램, 헤더 및 라이브러리는 일반적으로 표준 위치에 있지만 Ice_SLICE_DIRS는 자동으로 감지되지 않을 수 있습니다 (일반적으로 알려진 위치가 검색 됨). 다른 모든 변수는 설정된 경우 Ice_HOME을 사용하여 기본값으로 설정됩니다. Ice_HOME을 설정하고 다른 구성 요소의 대체 위치를 선택적으로 지정할 수 있습니다. 휴리스틱이 특정 Visual Studio 버전에 대한 올바른 프로그램 및 라이브러리를 식별하기에 충분하지 않은 경우 이것은 최신 버전의 Visual Studio에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d6cf3cf27e503d93d2ad459825a9ddd5170e36" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&amp;lt;contentOptions&amp;gt;&lt;/code&gt; will just be a couple of options defining the download method and method-specific details like a commit tag or archive hash. For example:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;&amp;lt;contentOptions&amp;gt;&lt;/code&gt; 는 다운로드 방법과 커밋 태그 또는 아카이브 해시와 같은 방법 별 세부 정보를 정의하는 몇 가지 옵션 일뿐입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5be4de0f38cec75433162f506732238b6deb0b94" translate="yes" xml:space="preserve">
          <source>In most cases, the only argument given to &lt;code&gt;FetchContent_Populate()&lt;/code&gt; is the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;. When used this way, the command assumes the content details have been recorded by an earlier call to &lt;a href=&quot;#command:fetchcontent_declare&quot; id=&quot;index-0-command:fetchcontent_declare&quot;&gt;&lt;code&gt;FetchContent_Declare()&lt;/code&gt;&lt;/a&gt;. The details are stored in a global property, so they are unaffected by things like variable or directory scope. Therefore, it doesn&amp;rsquo;t matter where in the project the details were previously declared, as long as they have been declared before the call to &lt;code&gt;FetchContent_Populate()&lt;/code&gt;. Those saved details are then used to construct a call to &lt;a href=&quot;externalproject#command:externalproject_add&quot; id=&quot;index-2-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt; in a private sub-build to perform the content population immediately. The implementation of &lt;code&gt;ExternalProject_Add()&lt;/code&gt; ensures that if the content has already been populated in a previous CMake run, that content will be reused rather than repopulating them again. For the common case where population involves downloading content, the cost of the download is only paid once.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;FetchContent_Populate()&lt;/code&gt; 주어진 유일한 인수 는 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 입니다. 이 방법을 사용하면 명령은 &lt;a href=&quot;#command:fetchcontent_declare&quot; id=&quot;index-0-command:fetchcontent_declare&quot;&gt; &lt;code&gt;FetchContent_Declare()&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 컨텐츠 세부 사항이 기록되었다고 가정합니다 . 세부 사항은 전역 특성에 저장되므로 변수 또는 디렉토리 범위와 같은 것에 영향을받지 않습니다. 따라서 &lt;code&gt;FetchContent_Populate()&lt;/code&gt; 호출하기 전에 선언 한 경우 프로젝트에서 세부 사항이 선언 된 위치는 중요하지 않습니다 . 저장된 세부 정보는 개인 하위 빌드에서 &lt;a href=&quot;externalproject#command:externalproject_add&quot; id=&quot;index-2-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; 에 대한 호출을 구성 하여 컨텐츠 채우기를 즉시 수행하는 데 사용됩니다. &lt;code&gt;ExternalProject_Add()&lt;/code&gt; 의 구현컨텐츠가 이전 CMake 실행에서 이미 채워진 경우 해당 컨텐츠를 다시 채우지 않고 재사용합니다. 인구가 콘텐츠를 다운로드하는 일반적인 경우에는 다운로드 비용이 한 번만 지불됩니다.</target>
        </trans-unit>
        <trans-unit id="60645aed53818a69cd9c8c00beb389b36af7e2bd" translate="yes" xml:space="preserve">
          <source>In most cases, the saved details do not specify any options relating to the directories to use for the internal sub-build, final source and build areas. It is generally best to leave these decisions up to the &lt;code&gt;FetchContent&lt;/code&gt; module to handle on the project&amp;rsquo;s behalf. The &lt;code&gt;FETCHCONTENT_BASE_DIR&lt;/code&gt; cache variable controls the point under which all content population directories are collected, but in most cases developers would not need to change this. The default location is &lt;code&gt;${CMAKE_BINARY_DIR}/_deps&lt;/code&gt;, but if developers change this value, they should aim to keep the path short and just below the top level of the build tree to avoid running into path length problems on Windows.</source>
          <target state="translated">대부분의 경우 저장된 세부 사항은 내부 하위 빌드, 최종 소스 및 빌드 영역에 사용할 디렉토리와 관련된 옵션을 지정하지 않습니다. 일반적으로 이러한 결정 은 프로젝트를 처리하기 위해 &lt;code&gt;FetchContent&lt;/code&gt; 모듈 에 맡기는 것이 가장 좋습니다 . &lt;code&gt;FETCHCONTENT_BASE_DIR&lt;/code&gt; 의 캐시 변수 컨트롤 모든 컨텐츠 인구 디렉토리가 수집되어 있지만, 대부분의 경우 개발자는이를 변경할 필요가 없습니다 것이다 아래에있는 점. 기본 위치는 &lt;code&gt;${CMAKE_BINARY_DIR}/_deps&lt;/code&gt; 이지만 개발자가이 값을 변경하면 Windows에서 경로 길이 문제가 발생하지 않도록 경로를 짧게 유지하고 빌드 트리의 최상위 수준 바로 아래에 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="27353e019ba2c66a5e7aeac725cb00f81aeb155f" translate="yes" xml:space="preserve">
          <source>In most command signatures where the &lt;code&gt;INTERFACE&lt;/code&gt; keyword appears, the items listed after it only become part of that target&amp;rsquo;s usage requirements and are not part of the target&amp;rsquo;s own settings. However, in this signature of &lt;code&gt;add_library&lt;/code&gt;, the &lt;code&gt;INTERFACE&lt;/code&gt; keyword refers to the library type only. Sources listed after it in the &lt;code&gt;add_library&lt;/code&gt; call are &lt;code&gt;PRIVATE&lt;/code&gt; to the interface library and do not appear in its &lt;a href=&quot;../prop_tgt/interface_sources#prop_tgt:INTERFACE_SOURCES&quot; id=&quot;index-0-prop_tgt:INTERFACE_SOURCES&quot;&gt;&lt;code&gt;INTERFACE_SOURCES&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">&lt;code&gt;INTERFACE&lt;/code&gt; 키워드가 나타나는 대부분의 명령 서명에서 뒤에 나열된 항목은 해당 대상의 사용 요구 사항의 일부가되며 대상 자체 설정의 일부가 아닙니다. 그러나이 &lt;code&gt;add_library&lt;/code&gt; 서명 에서 &lt;code&gt;INTERFACE&lt;/code&gt; 키워드는 라이브러리 유형 만 참조합니다. &lt;code&gt;add_library&lt;/code&gt; 호출 에서 그 뒤에 나열된 소스 는 인터페이스 라이브러리에 대해 &lt;code&gt;PRIVATE&lt;/code&gt; 이며 &lt;a href=&quot;../prop_tgt/interface_sources#prop_tgt:INTERFACE_SOURCES&quot; id=&quot;index-0-prop_tgt:INTERFACE_SOURCES&quot;&gt; &lt;code&gt;INTERFACE_SOURCES&lt;/code&gt; &lt;/a&gt; 대상 속성에 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="65fc96648b0c8fe8929cd2f04149b800764e1a41" translate="yes" xml:space="preserve">
          <source>In new projects, please use the &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_XXX&lt;/code&gt; equivalents. Additionally, the following variables are deprecated:</source>
          <target state="translated">새 프로젝트에서는 &lt;code&gt;MPI_&amp;lt;lang&amp;gt;_XXX&lt;/code&gt; 동등 항목을 사용하십시오. 또한 다음 변수는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a358467d931a2a73c3c567b94f39d973f221864a" translate="yes" xml:space="preserve">
          <source>In order to control the guessing step, the following variable may be set:</source>
          <target state="translated">추측 단계를 제어하기 위해 다음 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57373d5071051b529e1ed01e1ec480cc2ece27a2" translate="yes" xml:space="preserve">
          <source>In order to evaluate variable references immediately when scheduling a deferred call, wrap it using &lt;code&gt;cmake_language(EVAL)&lt;/code&gt;. However, note that arguments will be re-evaluated in the deferred call, though that can be avoided by using bracket arguments. For example:</source>
          <target state="translated">지연된 호출을 예약 할 때 변수 참조를 즉시 평가하려면 &lt;code&gt;cmake_language(EVAL)&lt;/code&gt; 사용하여이를 래핑합니다 . 그러나 대괄호 인수를 사용하여 피할 수 있지만 지연된 호출에서 인수가 다시 평가됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5c405d9b4b475b1074c352a32918dac161c6d4f7" translate="yes" xml:space="preserve">
          <source>In order to make cross compiling your project easier, use &lt;code&gt;try_run&lt;/code&gt; only if really required. If you use &lt;code&gt;try_run&lt;/code&gt;, use the &lt;code&gt;RUN_OUTPUT_VARIABLE&lt;/code&gt; or &lt;code&gt;OUTPUT_VARIABLE&lt;/code&gt; options only if really required. Using them will require that when cross-compiling, the cache variables will have to be set manually to the output of the executable. You can also &amp;ldquo;guard&amp;rdquo; the calls to &lt;code&gt;try_run&lt;/code&gt; with an &lt;a href=&quot;if#command:if&quot; id=&quot;index-0-command:if&quot;&gt;&lt;code&gt;if()&lt;/code&gt;&lt;/a&gt; block checking the &lt;a href=&quot;../variable/cmake_crosscompiling#variable:CMAKE_CROSSCOMPILING&quot; id=&quot;index-1-variable:CMAKE_CROSSCOMPILING&quot;&gt;&lt;code&gt;CMAKE_CROSSCOMPILING&lt;/code&gt;&lt;/a&gt; variable and provide an easy-to-preset alternative for this case.</source>
          <target state="translated">프로젝트 간 크로스 컴파일을 쉽게 하려면 실제로 필요한 경우에만 &lt;code&gt;try_run&lt;/code&gt; 을 사용 하십시오 . 당신이 사용하는 경우 &lt;code&gt;try_run&lt;/code&gt; , 사용 &lt;code&gt;RUN_OUTPUT_VARIABLE&lt;/code&gt; 또는 &lt;code&gt;OUTPUT_VARIABLE&lt;/code&gt; 정말 필요한 경우에만 옵션을. 이를 사용하려면 크로스 컴파일시 캐시 변수를 수동으로 실행 파일의 출력으로 설정해야합니다. 또한 &lt;a href=&quot;../variable/cmake_crosscompiling#variable:CMAKE_CROSSCOMPILING&quot; id=&quot;index-1-variable:CMAKE_CROSSCOMPILING&quot;&gt; &lt;code&gt;CMAKE_CROSSCOMPILING&lt;/code&gt; &lt;/a&gt; 변수를 검사 하는 &lt;a href=&quot;if#command:if&quot; id=&quot;index-0-command:if&quot;&gt; &lt;code&gt;if()&lt;/code&gt; &lt;/a&gt; 블록 으로 &lt;code&gt;try_run&lt;/code&gt; 호출을&amp;ldquo;보호&amp;rdquo;할 수 있으며이 경우 사전 설정이 쉬운 대안을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785ed4da0043260ec21f55facc118ed4401d7cf4" translate="yes" xml:space="preserve">
          <source>In order to support projects depending on linker search paths added by linking to libraries with known full paths, the &lt;code&gt;OLD&lt;/code&gt; behavior for this policy will add the linker search paths even though they are not needed for their own libraries. When this policy is set to &lt;code&gt;OLD&lt;/code&gt;, CMake will produce a link line such as</source>
          <target state="translated">알려진 전체 경로가있는 라이브러리에 링크하여 추가 된 링커 검색 경로에 따라 프로젝트를 지원 하기 위해이 정책 의 &lt;code&gt;OLD&lt;/code&gt; 동작은 자체 라이브러리에 필요하지 않더라도 링커 검색 경로를 추가합니다. 이 정책이 &lt;code&gt;OLD&lt;/code&gt; 로 설정 되면 CMake는 다음과 같은 링크 라인을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f5fbffa39f02c815da46345eb1a2a94103583f5d" translate="yes" xml:space="preserve">
          <source>In other words, when &lt;a href=&quot;../manual/cmake-buildsystem.7#object-libraries&quot;&gt;Object Libraries&lt;/a&gt; appear in a target&amp;rsquo;s &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-5-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt; property they will be treated as &lt;a href=&quot;../manual/cmake-buildsystem.7#interface-libraries&quot;&gt;Interface Libraries&lt;/a&gt;, but when they appear in a target&amp;rsquo;s &lt;a href=&quot;../prop_tgt/link_libraries#prop_tgt:LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_LIBRARIES&quot;&gt;&lt;code&gt;LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt; property their object files will be included in the link too.</source>
          <target state="translated">즉, &lt;a href=&quot;../manual/cmake-buildsystem.7#object-libraries&quot;&gt;객체 라이브러리&lt;/a&gt; 가 대상의 &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-5-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; 속성에 표시되면 &lt;a href=&quot;../manual/cmake-buildsystem.7#interface-libraries&quot;&gt;인터페이스 라이브러리&lt;/a&gt; 로 취급 되지만 대상의 &lt;a href=&quot;../prop_tgt/link_libraries#prop_tgt:LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_LIBRARIES&quot;&gt; &lt;code&gt;LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; 속성에 표시되면 해당 객체 파일도 링크에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bec4fb23c8d962608e746326eb0d69fe492310ad" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;MathFunctions_MAJOR_VERSION&lt;/code&gt; is defined as a &lt;a href=&quot;../../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_STRING&quot;&gt;&lt;code&gt;COMPATIBLE_INTERFACE_STRING&lt;/code&gt;&lt;/a&gt; which means that it must be compatible among the dependencies of any depender. By setting this custom defined user property in this version and in the next version of &lt;code&gt;MathFunctions&lt;/code&gt;, &lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-1-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake&lt;/code&gt;&lt;/a&gt; will issue a diagnostic if there is an attempt to use version 3 together with version 4. Packages can choose to employ such a pattern if different major versions of the package are designed to be incompatible.</source>
          <target state="translated">이 예에서 &lt;code&gt;MathFunctions_MAJOR_VERSION&lt;/code&gt; 은 &lt;a href=&quot;../../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_STRING&quot;&gt; &lt;code&gt;COMPATIBLE_INTERFACE_STRING&lt;/code&gt; 으로&lt;/a&gt; 정의되며 이는 모든 종속 항목의 종속성간에 호환되어야 함을 의미합니다. 이 버전과의 다음 버전이 사용자 정의 된 사용자 속성을 설정하여 &lt;code&gt;MathFunctions&lt;/code&gt; , &lt;a href=&quot;../../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-1-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake&lt;/code&gt; 는&lt;/a&gt; 이러한 패턴을 사용하도록 선택할 수 있습니다 함께 버전 4. 패키지 버전 3를 사용하려는 시도가있을 경우 진단을 발행 할 경우 다른 주요 버전 패키지가 호환되지 않도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="482951e89e498e98e571bf236b6e756ff80bdbcf" translate="yes" xml:space="preserve">
          <source>In processing the requirement for the &lt;code&gt;cxx_constexpr&lt;/code&gt; feature, &lt;a href=&quot;cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake(1)&lt;/code&gt;&lt;/a&gt; will ensure that the in-use C++ compiler is capable of the feature, and will add any necessary flags such as &lt;code&gt;-std=gnu++11&lt;/code&gt; to the compile lines of C++ files in the &lt;code&gt;mylib&lt;/code&gt; target. A &lt;code&gt;FATAL_ERROR&lt;/code&gt; is issued if the compiler is not capable of the feature.</source>
          <target state="translated">&lt;code&gt;cxx_constexpr&lt;/code&gt; 기능 의 요구 사항을 처리 할 때 &lt;a href=&quot;cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake(1)&lt;/code&gt; &lt;/a&gt; 은 사용중인 C ++ 컴파일러가 기능을 사용할 수 있는지 확인하고 &lt;code&gt;-std=gnu++11&lt;/code&gt; 과 같은 필요한 플래그 를 C ++ 파일의 컴파일 라인에 추가합니다. 에서 &lt;code&gt;mylib&lt;/code&gt; 타겟. &lt;code&gt;FATAL_ERROR&lt;/code&gt; 는 컴파일러가 기능을 할 수없는 경우 발급됩니다.</target>
        </trans-unit>
        <trans-unit id="cb73cd3993ee3625ca7b6607d4d6b217f76a6132" translate="yes" xml:space="preserve">
          <source>In projects that use a large number of commonly available features from a particular language standard (e.g. C++ 11) one may specify a meta-feature (e.g. &lt;code&gt;cxx_std_11&lt;/code&gt;) that requires use of a compiler mode aware of that standard. This is simpler than specifying all the features individually, but does not guarantee the existence of any particular feature. Diagnosis of use of unsupported features will be delayed until compile time.</source>
          <target state="translated">특정 언어 표준 (예 : C ++ 11)에서 일반적으로 사용 가능한 많은 기능을 사용하는 프로젝트에서는 해당 표준을 인식하는 컴파일러 모드를 사용해야 하는 메타 기능 (예 : &lt;code&gt;cxx_std_11&lt;/code&gt; )을 지정할 수 있습니다 . 이는 모든 기능을 개별적으로 지정하는 것보다 간단하지만 특정 기능의 존재를 보장하지는 않습니다. 지원되지 않는 기능의 사용 진단은 컴파일 시간까지 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="01d5356b91ce68f3df813bfbaaab6214e9158490" translate="yes" xml:space="preserve">
          <source>In projects that use a large number of commonly available features from a particular language standard (e.g. C++ 11) one may specify a meta-feature (e.g. &lt;code&gt;cxx_std_11&lt;/code&gt;) that requires use of a compiler mode that is at minimum aware of that standard, but could be greater. This is simpler than specifying all the features individually, but does not guarantee the existence of any particular feature. Diagnosis of use of unsupported features will be delayed until compile time.</source>
          <target state="translated">특정 언어 표준 (예 : C ++ 11)에서 일반적으로 사용할 수있는 많은 기능을 사용하는 프로젝트에서는 최소한 해당 표준을 인식하는 컴파일러 모드를 사용해야 하는 메타 기능 (예 : &lt;code&gt;cxx_std_11&lt;/code&gt; )을 지정할 수 있습니다. 더 크다. 이는 모든 기능을 개별적으로 지정하는 것보다 간단하지만 특정 기능의 존재를 보장하지는 않습니다. 지원되지 않는 기능 사용에 대한 진단은 컴파일 시간까지 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="ec1877efd0c9843256c66d801ebf6723be819a75" translate="yes" xml:space="preserve">
          <source>In some cases it can be necessary or useful to invoke the Qt build tools in a more-manual way. Several macros are available to add targets for such uses.</source>
          <target state="translated">어떤 경우에는보다 수동적 인 방식으로 Qt 빌드 도구를 호출하는 것이 필요하거나 유용 할 수 있습니다. 이러한 용도로 대상을 추가하기 위해 여러 매크로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fdc2a88a2aed30012c3f29a268697171295d4e7" translate="yes" xml:space="preserve">
          <source>In some cases using the Package Registries is not desirable. CMake allows one to disable them using the following variables:</source>
          <target state="translated">경우에 따라 패키지 레지스트리를 사용하지 않는 것이 좋습니다. CMake는 다음 변수를 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151cc73438c2335ed38c2afb8d0deacd8245242a" translate="yes" xml:space="preserve">
          <source>In some cases, for example for packaging and for system wide installations, it is not desirable to write the user package registry. If the &lt;code&gt;CMAKE_EXPORT_NO_PACKAGE_REGISTRY&lt;/code&gt; variable is enabled, the &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt;&lt;code&gt;export(PACKAGE)&lt;/code&gt;&lt;/a&gt; command will do nothing.</source>
          <target state="translated">일부 경우, 예를 들어 패키징 및 시스템 전체 설치의 경우 사용자 패키지 레지스트리를 작성하지 않는 것이 좋습니다. 는 IF &lt;code&gt;CMAKE_EXPORT_NO_PACKAGE_REGISTRY&lt;/code&gt; 의 변수가 활성화되면, &lt;a href=&quot;../command/export#command:export&quot; id=&quot;index-1-command:export&quot;&gt; &lt;code&gt;export(PACKAGE)&lt;/code&gt; &lt;/a&gt; 명령은 아무것도하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cb229e063b4a860506b04c6b48549576582d1d1" translate="yes" xml:space="preserve">
          <source>In some cases, for example to locate only system wide installations, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; when searching for packages. If the &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is &lt;code&gt;TRUE&lt;/code&gt;, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">예를 들어 시스템 전체 설치 만 찾는 경우와 같이 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;패키지&lt;/a&gt; 를 검색 할 때 사용자 패키지 레지스트리 를 사용하는 것은 바람직하지 않습니다 . 는 IF &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&lt;/code&gt; 의&lt;/a&gt; 변수가 &lt;code&gt;TRUE&lt;/code&gt; , 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;사용자 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="a39df5e372109009b8d668bdb97a1acdaa33a7e7" translate="yes" xml:space="preserve">
          <source>In some cases, for example to locate only system wide installations, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; when searching for packages. If the &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is enabled, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">예를 들어 시스템 전체 설치 만 찾는 경우 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;패키지&lt;/a&gt; 를 검색 할 때 사용자 패키지 레지스트리 를 사용하지 않는 것이 좋습니다 . 는 IF &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY&lt;/code&gt; 의&lt;/a&gt; 변수가 활성화되어, 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;사용자 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="cddf4c1b85d7b2c300b8fff712da5889de4b9075" translate="yes" xml:space="preserve">
          <source>In some cases, for example to locate only system wide installations, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; when searching for packages. If the &lt;a href=&quot;#variable:CMAKE_FIND_USE_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_USE_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_FIND_USE_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is &lt;code&gt;FALSE&lt;/code&gt;, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;User Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">예를 들어 시스템 전체 설치 만 찾는 경우와 같이 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;패키지&lt;/a&gt; 를 검색 할 때 사용자 패키지 레지스트리 를 사용하는 것은 바람직하지 않습니다 . 는 IF &lt;a href=&quot;#variable:CMAKE_FIND_USE_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_USE_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_FIND_USE_PACKAGE_REGISTRY&lt;/code&gt; 의&lt;/a&gt; 변수가 &lt;code&gt;FALSE&lt;/code&gt; , 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#user-package-registry&quot;&gt;사용자 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="3108e4a724be379c9e7d579ea5fe1eb5c6b7a963" translate="yes" xml:space="preserve">
          <source>In some cases, for example to locate only user specific installations, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; when searching for packages. If the &lt;code&gt;CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; variable is &lt;code&gt;FALSE&lt;/code&gt;, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">예를 들어 사용자 별 설치 만 찾기 위해 패키지를 검색 할 때 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;시스템 패키지 레지스트리&lt;/a&gt; 를 사용하는 것이 바람직하지 않은 경우도 있습니다. 는 IF &lt;code&gt;CMAKE_FIND_USE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의 변수가 &lt;code&gt;FALSE&lt;/code&gt; , 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;시스템 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="088c572dbca02ae474bda1f35266de7600d199d7" translate="yes" xml:space="preserve">
          <source>In some cases, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; when searching for packages. If the &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is &lt;code&gt;TRUE&lt;/code&gt;, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">어떤 경우에는 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;패키지&lt;/a&gt; 를 검색 할 때 시스템 패키지 레지스트리 를 사용하는 것이 바람직하지 않습니다 . 는 IF &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의&lt;/a&gt; 변수가 &lt;code&gt;TRUE&lt;/code&gt; , 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;시스템 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="1e382d860227d1f4650b5bb83ad998a8b7f71fce" translate="yes" xml:space="preserve">
          <source>In some cases, it is not desirable to use the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; when searching for packages. If the &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot;&gt;&lt;code&gt;CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt;&lt;/a&gt; variable is enabled, all the &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; commands will skip the &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;System Package Registry&lt;/a&gt; as if they were called with the &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; argument.</source>
          <target state="translated">경우에 따라 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;패키지&lt;/a&gt; 를 검색 할 때 시스템 패키지 레지스트리 를 사용하지 않는 것이 좋습니다 . 는 IF &lt;a href=&quot;#variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot; id=&quot;index-0-variable:CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&quot;&gt; &lt;code&gt;CMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의&lt;/a&gt; 변수가 활성화되어, 모든 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 명령은 건너 뜁니다 &lt;a href=&quot;../manual/cmake-packages.7#system-package-registry&quot;&gt;시스템 패키지 레지스트리를&lt;/a&gt; 그들이 호출하는 것처럼 &lt;code&gt;NO_CMAKE_SYSTEM_PACKAGE_REGISTRY&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="2601f7dd1783bcb44c322aca8587c756ad8c9ce2" translate="yes" xml:space="preserve">
          <source>In some way the function applies a canonicalization to the source names. This is necessary to find file matches if the files have been added to the target with different directory prefixes:</source>
          <target state="translated">어떤 식 으로든 함수는 정규화를 소스 이름에 적용합니다. 파일이 다른 디렉토리 접두어로 대상에 추가 된 경우 파일 일치를 찾는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4a78616e0469725b890f682c90126a1ac5b68ec0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MathFunctions&lt;/code&gt; subdirectory, a new source file named &lt;code&gt;MakeTable.cxx&lt;/code&gt; has been provided to generate the table.</source>
          <target state="translated">에서 &lt;code&gt;MathFunctions&lt;/code&gt; 의 하위 디렉토리라는 새로운 소스 파일 &lt;code&gt;MakeTable.cxx&lt;/code&gt; 은 테이블을 생성하기 위해 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="e462f51c2f68d0127a927b1eae9ef0320b28c102" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Nightly&lt;/code&gt; dashboard mode, specify the &amp;ldquo;nightly start time&amp;rdquo;. With centralized version control systems (&lt;code&gt;cvs&lt;/code&gt; and &lt;code&gt;svn&lt;/code&gt;), the &lt;code&gt;Update&lt;/code&gt; step checks out the version of the software as of this time so that multiple clients choose a common version to test. This is not well-defined in distributed version-control systems so the setting is ignored.</source>
          <target state="translated">에서 &lt;code&gt;Nightly&lt;/code&gt; 대시 보드 모드에서, &quot;야간 시작 시간&quot;을 지정합니다. 중앙 집중식 버전 제어 시스템 ( &lt;code&gt;cvs&lt;/code&gt; 및 &lt;code&gt;svn&lt;/code&gt; )을 사용하는 경우 &lt;code&gt;Update&lt;/code&gt; 단계는 현재 여러 소프트웨어가 테스트 할 공통 버전을 선택하도록 현재 소프트웨어 버전을 체크 아웃합니다. 이는 분산 버전 제어 시스템에서 잘 정의되어 있지 않으므로 설정이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eca498acf645dc75a25c3851dede036c5a81bbf4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;projA&lt;/code&gt; call to &lt;a href=&quot;#command:fetchcontent_makeavailable&quot; id=&quot;index-2-command:fetchcontent_makeavailable&quot;&gt;&lt;code&gt;FetchContent_MakeAvailable()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;projD&lt;/code&gt; is listed ahead of &lt;code&gt;projB&lt;/code&gt; and &lt;code&gt;projC&lt;/code&gt; to ensure that &lt;code&gt;projA&lt;/code&gt; is in control of how &lt;code&gt;projD&lt;/code&gt; is populated.</source>
          <target state="translated">에서 &lt;code&gt;projA&lt;/code&gt; 에 전화 &lt;a href=&quot;#command:fetchcontent_makeavailable&quot; id=&quot;index-2-command:fetchcontent_makeavailable&quot;&gt; &lt;code&gt;FetchContent_MakeAvailable()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;projD&lt;/code&gt; 는 앞서의 나열 &lt;code&gt;projB&lt;/code&gt; 및 &lt;code&gt;projC&lt;/code&gt; 수 있도록 &lt;code&gt;projA&lt;/code&gt; 방법의 제어에 &lt;code&gt;projD&lt;/code&gt; 가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="18a9f509a6cdcb9ab1c806de2d69ca549adcd182" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;projA&lt;/code&gt; call to &lt;a href=&quot;#command:fetchcontent_makeavailable&quot; id=&quot;index-5-command:fetchcontent_makeavailable&quot;&gt;&lt;code&gt;FetchContent_MakeAvailable()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;projD&lt;/code&gt; is listed ahead of &lt;code&gt;projB&lt;/code&gt; and &lt;code&gt;projC&lt;/code&gt; to ensure that &lt;code&gt;projA&lt;/code&gt; is in control of how &lt;code&gt;projD&lt;/code&gt; is populated.</source>
          <target state="translated">에서 &lt;code&gt;projA&lt;/code&gt; 에 전화 &lt;a href=&quot;#command:fetchcontent_makeavailable&quot; id=&quot;index-5-command:fetchcontent_makeavailable&quot;&gt; &lt;code&gt;FetchContent_MakeAvailable()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;projD&lt;/code&gt; 는 앞서의 나열 &lt;code&gt;projB&lt;/code&gt; 및 &lt;code&gt;projC&lt;/code&gt; 수 있도록 &lt;code&gt;projA&lt;/code&gt; 방법의 제어에 &lt;code&gt;projD&lt;/code&gt; 가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="330d324f1f03239a27814ff1f6b42f65fa2e39a6" translate="yes" xml:space="preserve">
          <source>In the CMakeLists file, add an &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-12-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; library and specify its location on disk:</source>
          <target state="translated">CMakeLists 파일에서 &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-12-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 라이브러리를 추가하고 디스크에서의 위치를 ​​지정합니다.</target>
        </trans-unit>
        <trans-unit id="04d9ad20d2d5cc5e9661f134ad7f03d178a49d10" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;mylib&lt;/code&gt; requires &lt;code&gt;cxx_constexpr&lt;/code&gt; when it is built itself, but consumers of &lt;code&gt;mylib&lt;/code&gt; are not required to use a compiler which supports &lt;code&gt;cxx_constexpr&lt;/code&gt;. If the interface of &lt;code&gt;mylib&lt;/code&gt; does require the &lt;code&gt;cxx_constexpr&lt;/code&gt; feature (or any other known feature), that may be specified with the &lt;code&gt;PUBLIC&lt;/code&gt; or &lt;code&gt;INTERFACE&lt;/code&gt; signatures of &lt;a href=&quot;../command/target_compile_features#command:target_compile_features&quot; id=&quot;index-1-command:target_compile_features&quot;&gt;&lt;code&gt;target_compile_features()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위의 예제에서 &lt;code&gt;mylib&lt;/code&gt; 는 자체 빌드 될 때 &lt;code&gt;cxx_constexpr&lt;/code&gt; 을 요구 하지만 &lt;code&gt;mylib&lt;/code&gt; 의 소비자 는 &lt;code&gt;cxx_constexpr&lt;/code&gt; 을 지원하는 컴파일러를 사용할 필요가 없습니다 . &lt;code&gt;mylib&lt;/code&gt; 의 인터페이스에 &lt;code&gt;cxx_constexpr&lt;/code&gt; 기능 (또는 다른 알려진 기능) 이 필요한 경우 &lt;a href=&quot;../command/target_compile_features#command:target_compile_features&quot; id=&quot;index-1-command:target_compile_features&quot;&gt; &lt;code&gt;target_compile_features()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;PUBLIC&lt;/code&gt; 또는 &lt;code&gt;INTERFACE&lt;/code&gt; 서명 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6069de41089952074b3b5113b70e1b84097a798f" translate="yes" xml:space="preserve">
          <source>In the build directory, notice that the file &lt;code&gt;MathFunctionsTargets.cmake&lt;/code&gt; has been created in the &lt;code&gt;cmake&lt;/code&gt; subdirectory.</source>
          <target state="translated">빌드 디렉터리에서 &lt;code&gt;MathFunctionsTargets.cmake&lt;/code&gt; 파일 이 &lt;code&gt;cmake&lt;/code&gt; 하위 디렉터리에 생성되었음을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="7ba63d43b16efd49c4fc084c6739864233f8affb" translate="yes" xml:space="preserve">
          <source>In the case of a host build then &lt;code&gt;CMAKE_SYSTEM_VERSION&lt;/code&gt; may be set explicitly when first configuring a new build tree in order to enable targeting the build for a different version of the host operating system than is actually running on the host. This is allowed and not considered cross compiling so long as the binaries built for the specified OS version can still run on the host.</source>
          <target state="translated">호스트 빌드의 경우 , 새 빌드 트리를 처음 구성 할 때 실제로 호스트에서 실행되는 것과 다른 버전의 호스트 운영 체제에 대한 빌드를 대상으로하기 위해 &lt;code&gt;CMAKE_SYSTEM_VERSION&lt;/code&gt; 을 명시 적으로 설정할 수 있습니다. 지정된 OS 버전 용으로 빌드 된 바이너리가 호스트에서 계속 실행될 수있는 한, 이는 교차 컴파일로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11a39eb756b06bcb663999bc69355898b5260ec2" translate="yes" xml:space="preserve">
          <source>In the case of properties listed in &lt;a href=&quot;../prop_tgt/compatible_interface_bool#prop_tgt:COMPATIBLE_INTERFACE_BOOL&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_BOOL&quot;&gt;&lt;code&gt;COMPATIBLE_INTERFACE_BOOL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_STRING&quot;&gt;&lt;code&gt;COMPATIBLE_INTERFACE_STRING&lt;/code&gt;&lt;/a&gt;, the debug output shows which target was responsible for setting the property, and which other dependencies also defined the property. In the case of &lt;a href=&quot;../prop_tgt/compatible_interface_number_max#prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MAX&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MAX&quot;&gt;&lt;code&gt;COMPATIBLE_INTERFACE_NUMBER_MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../prop_tgt/compatible_interface_number_min#prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MIN&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MIN&quot;&gt;&lt;code&gt;COMPATIBLE_INTERFACE_NUMBER_MIN&lt;/code&gt;&lt;/a&gt;, the debug output shows the value of the property from each dependency, and whether the value determines the new extreme.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/compatible_interface_bool#prop_tgt:COMPATIBLE_INTERFACE_BOOL&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_BOOL&quot;&gt; &lt;code&gt;COMPATIBLE_INTERFACE_BOOL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../prop_tgt/compatible_interface_string#prop_tgt:COMPATIBLE_INTERFACE_STRING&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_STRING&quot;&gt; &lt;code&gt;COMPATIBLE_INTERFACE_STRING&lt;/code&gt; 에&lt;/a&gt; 나열된 특성의 경우 디버그 출력은 특성 설정을 담당 한 대상 및 특성을 정의한 다른 종속성을 표시합니다. &lt;a href=&quot;../prop_tgt/compatible_interface_number_max#prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MAX&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MAX&quot;&gt; &lt;code&gt;COMPATIBLE_INTERFACE_NUMBER_MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../prop_tgt/compatible_interface_number_min#prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MIN&quot; id=&quot;index-1-prop_tgt:COMPATIBLE_INTERFACE_NUMBER_MIN&quot;&gt; &lt;code&gt;COMPATIBLE_INTERFACE_NUMBER_MIN&lt;/code&gt; &lt;/a&gt; 의 경우 디버그 출력은 각 종속성의 특성 값과 값이 새 극단 값을 결정하는지 여부를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c787a6007492b75e471f648e02e710be800db8b5" translate="yes" xml:space="preserve">
          <source>In the context of the buildsystem definition as a whole, it is largely irrelevant whether particular libraries are &lt;code&gt;SHARED&lt;/code&gt; or &lt;code&gt;STATIC&lt;/code&gt; &amp;ndash; the commands, dependency specifications and other APIs work similarly regardless of the library type. The &lt;code&gt;MODULE&lt;/code&gt; library type is dissimilar in that it is generally not linked to &amp;ndash; it is not used in the right-hand-side of the &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-1-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt; command. It is a type which is loaded as a plugin using runtime techniques. If the library does not export any unmanaged symbols (e.g. Windows resource DLL, C++/CLI DLL), it is required that the library not be a &lt;code&gt;SHARED&lt;/code&gt; library because CMake expects &lt;code&gt;SHARED&lt;/code&gt; libraries to export at least one symbol.</source>
          <target state="translated">전체적으로 빌드 시스템 정의와 관련하여 특정 라이브러리가 &lt;code&gt;SHARED&lt;/code&gt; 또는 &lt;code&gt;STATIC&lt;/code&gt; 인지 여부는 크게 관련이 없습니다 . 명령, 종속성 사양 및 기타 API는 라이브러리 유형에 관계없이 비슷하게 작동합니다. &lt;code&gt;MODULE&lt;/code&gt; 의 라이브러리 유형은 일반적으로 연결되어 있지 않은 점에서 이질적이다 - 그것은의 오른쪽에서 사용되지 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-1-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; 명령. 런타임 기술을 사용하여 플러그인으로로드되는 유형입니다. 라이브러리가 관리되지 않는 심볼 (예 : Windows 리소스 DLL, C ++ / CLI DLL) 을 내 보내지 않으면 CMake는 &lt;code&gt;SHARED&lt;/code&gt; 라이브러리가 하나 이상의 심볼을 내보낼 것으로 예상하므로 라이브러리 가 &lt;code&gt;SHARED&lt;/code&gt; 라이브러리가 아니 어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4c50f6fec3926ae844630f6b9c5668fc9e91991b" translate="yes" xml:space="preserve">
          <source>In the example file above, there are four GPUs with ID&amp;rsquo;s 0 through 3. GPU 0 has 2 slots, GPU 1 has 4, GPU 2 has 2, and GPU 3 has a default of 1 slot. There is also one cryptography chip with 4 slots.</source>
          <target state="translated">위의 예제 파일에는 ID가 0 ~ 3 인 GPU 4 개가 있습니다. GPU 0에는 2 개의 슬롯이 있고, GPU 1에는 4 개, GPU 2에는 2 개, GPU 3에는 기본값 인 1 개의 슬롯이 있습니다. 4 개의 슬롯이있는 하나의 암호화 칩도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d931b823e80eab20fb92cc30f9ecbcb4354b344" translate="yes" xml:space="preserve">
          <source>In the first case, you can use &lt;code&gt;if(${ARGV1})&lt;/code&gt;. In the second and third case, the proper way to check if an optional variable was passed to the macro is to use &lt;code&gt;if(${ARGC} GREATER 2)&lt;/code&gt;. In the last case, you can use &lt;code&gt;foreach(loop_var ${ARGN})&lt;/code&gt; but this will skip empty arguments. If you need to include them, you can use</source>
          <target state="translated">첫 번째 경우 &lt;code&gt;if(${ARGV1})&lt;/code&gt; 사용할 수 있습니다 . 두 번째 및 세 번째 경우 선택적 변수가 매크로에 전달되었는지 확인하는 올바른 방법은 &lt;code&gt;if(${ARGC} GREATER 2)&lt;/code&gt; 입니다. 마지막 경우에는 &lt;code&gt;foreach(loop_var ${ARGN})&lt;/code&gt; 있지만 빈 인수는 건너 뜁니다. 당신이 그들을 포함 해야하는 경우, 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="538eb9c2a0f031b0e2cc75683acb7ddf5b51d096" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;the &lt;code&gt;tgt&lt;/code&gt; filename&amp;rdquo; means the name of the &lt;code&gt;tgt&lt;/code&gt; binary file. This has to be distinguished from &amp;ldquo;the target name&amp;rdquo;, which is just the string &lt;code&gt;tgt&lt;/code&gt;.</source>
          <target state="translated">다음에서 &quot; &lt;code&gt;tgt&lt;/code&gt; 파일 이름&quot;은 &lt;code&gt;tgt&lt;/code&gt; 바이너리 파일 의 이름을 의미 합니다. 이것은 문자열 &lt;code&gt;tgt&lt;/code&gt; 인 &quot;대상 이름&quot;과 구별되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7945598b9c517f4b396895107d0346263d45edb" translate="yes" xml:space="preserve">
          <source>In the list of all given files for all files ending with &lt;code&gt;.Designer.cs&lt;/code&gt; and &lt;code&gt;.resx&lt;/code&gt; is searched. For every &lt;em&gt;designer&lt;/em&gt; or &lt;em&gt;resource&lt;/em&gt; file a file with the same base name but only &lt;code&gt;.cs&lt;/code&gt; as extension is searched. If this is found, the &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; properties are set as follows:</source>
          <target state="translated">&lt;code&gt;.Designer.cs&lt;/code&gt; 및 &lt;code&gt;.resx&lt;/code&gt; 로 끝나는 모든 파일에 대해 제공된 모든 파일 목록에서 검색됩니다. 모든 &lt;em&gt;디자이너&lt;/em&gt; 또는 &lt;em&gt;리소스&lt;/em&gt; 파일에 대해 기본 이름은 동일하지만 확장자는 &lt;code&gt;.cs&lt;/code&gt; 인 파일 이 검색됩니다. 이것이 발견되면 &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; 특성이 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c1df0858eeae0d7e9dde52661a3cf9b614d5e174" translate="yes" xml:space="preserve">
          <source>In the list of all given files for all files ending with &lt;code&gt;.Designer.cs&lt;/code&gt; is searched. For every &lt;em&gt;designer&lt;/em&gt; file all files with the same base name but different extensions are searched. If a match is found, the source file properties of the &lt;em&gt;designer&lt;/em&gt; file are set depending on the extension of the matched file:</source>
          <target state="translated">&lt;code&gt;.Designer.cs&lt;/code&gt; 로 끝나는 모든 파일의 지정된 파일 목록에서 검색됩니다. 모든 &lt;em&gt;디자이너&lt;/em&gt; 파일에 대해 기본 이름은 동일하지만 확장자가 다른 모든 파일이 검색됩니다. 일치하는 것이 있으면 &lt;em&gt;디자이너&lt;/em&gt; 파일 의 소스 파일 속성은 일치하는 파일의 확장자에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="76baf510d7d8ee0dc3463d6ddbd1b1b4bb480ba0" translate="yes" xml:space="preserve">
          <source>In the list of all given files for all files ending with &lt;code&gt;.xaml.cs&lt;/code&gt; is searched. For every &lt;em&gt;xaml-cs&lt;/em&gt; file, a file with the same base name but extension &lt;code&gt;.xaml&lt;/code&gt; is searched. If a match is found, the source file properties of the &lt;code&gt;.xaml.cs&lt;/code&gt; file are set:</source>
          <target state="translated">&lt;code&gt;.xaml.cs&lt;/code&gt; 로 끝나는 모든 파일에 대해 제공된 모든 파일 목록에서 검색됩니다. 모든 &lt;em&gt;xaml-cs&lt;/em&gt; 파일에 대해 기본 이름은 동일하지만 확장자는 &lt;code&gt;.xaml&lt;/code&gt; 인 파일 이 검색됩니다. 일치하는 것이 있으면 &lt;code&gt;.xaml.cs&lt;/code&gt; 파일 의 소스 파일 속성 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8bd77911d9b865202bc718cba2649d9b8ade9d" translate="yes" xml:space="preserve">
          <source>In the remaining sections, we will walk through a set of example projects step-by-step. The first project will create and install a library and corresponding CMake configuration and package files. The second project will use the generated package.</source>
          <target state="translated">나머지 섹션에서는 일련의 예제 프로젝트를 단계별로 살펴 보겠습니다. 첫 번째 프로젝트는 라이브러리와 해당 CMake 구성 및 패키지 파일을 만들고 설치합니다. 두 번째 프로젝트는 생성 된 패키지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0fe0294c4456feb98955115a0c3304083a693328" translate="yes" xml:space="preserve">
          <source>In the second form any program in the current source directory that matches the regular expression will be installed.</source>
          <target state="translated">두 번째 형식에서는 현재 소스 디렉토리에 정규식과 일치하는 모든 프로그램이 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b65f2c109870d5d55222ae3de15fbfd0dba89c" translate="yes" xml:space="preserve">
          <source>In the simple signature this specifies the failure message. Use &lt;code&gt;DEFAULT_MSG&lt;/code&gt; to ask for a default message to be computed (recommended). Not valid in the full signature.</source>
          <target state="translated">단순 서명에서 이는 실패 메시지를 지정합니다. &lt;code&gt;DEFAULT_MSG&lt;/code&gt; 를 사용 하여 기본 메시지를 계산하도록 요청 하십시오 (권장). 전체 서명에 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="634a9b063493393ff0b0f4b517baf5b0bc20cf53" translate="yes" xml:space="preserve">
          <source>In the standard CMake workflow, the file &lt;code&gt;CPackConfig.cmake&lt;/code&gt; is generated by the &lt;a href=&quot;cmake.1#manual:cmake(1)&quot; id=&quot;index-1-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake&lt;/code&gt;&lt;/a&gt; executable, provided the &lt;a href=&quot;../module/cpack#module:CPack&quot; id=&quot;index-0-module:CPack&quot;&gt;&lt;code&gt;CPack&lt;/code&gt;&lt;/a&gt; module is included by the project&amp;rsquo;s &lt;code&gt;CMakeLists.txt&lt;/code&gt; file.</source>
          <target state="translated">표준 CMake 워크 플로우에서 파일 &lt;code&gt;CPackConfig.cmake&lt;/code&gt; 은 에 의해 생성 된 &lt;a href=&quot;cmake.1#manual:cmake(1)&quot; id=&quot;index-1-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake&lt;/code&gt; 에&lt;/a&gt; 제공된, 실행 &lt;a href=&quot;../module/cpack#module:CPack&quot; id=&quot;index-0-module:CPack&quot;&gt; &lt;code&gt;CPack&lt;/code&gt; 의&lt;/a&gt; 모듈이 프로젝트가 포함되어 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="7ea1599cec8b79be2228dea4fcdba46f25c86739" translate="yes" xml:space="preserve">
          <source>In the target &lt;code&gt;my_target&lt;/code&gt; a header file &lt;code&gt;complex_class.hpp&lt;/code&gt; uses a custom macro &lt;code&gt;JSON_BASED_CLASS&lt;/code&gt; which is defined in an other header &lt;code&gt;macros.hpp&lt;/code&gt;:</source>
          <target state="translated">대상 &lt;code&gt;my_target&lt;/code&gt; 에서 헤더 파일 &lt;code&gt;complex_class.hpp&lt;/code&gt; 는 다른 헤더 &lt;code&gt;macros.hpp&lt;/code&gt; 에 정의 된 사용자 정의 매크로 &lt;code&gt;JSON_BASED_CLASS&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="204f1dcfd91b4602305f2d798f9b90af3199a744" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;Q_OBJECT&lt;/code&gt; macro is hidden inside another macro called &lt;code&gt;CUSTOM_MACRO&lt;/code&gt;. To let CMake know that source files that contain &lt;code&gt;CUSTOM_MACRO&lt;/code&gt; need to be &lt;code&gt;moc&lt;/code&gt; processed, we call:</source>
          <target state="translated">이 경우 &lt;code&gt;Q_OBJECT&lt;/code&gt; 매크로는 &lt;code&gt;CUSTOM_MACRO&lt;/code&gt; 라는 다른 매크로 안에 숨겨져 있습니다 . &lt;code&gt;CUSTOM_MACRO&lt;/code&gt; 가 포함 된 소스 파일을 &lt;code&gt;moc&lt;/code&gt; 처리 해야 한다는 것을 CMake에 알리려면 다음 을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4c6a3c89029e57a2d1f7070dfd963ee72e8920d5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Foo_FINAL&lt;/code&gt; will expand to &lt;code&gt;final&lt;/code&gt; if the compiler supports the keyword, or to empty otherwise.</source>
          <target state="translated">이 경우 컴파일러가 키워드를 지원하면 &lt;code&gt;Foo_FINAL&lt;/code&gt; 은 &lt;code&gt;final&lt;/code&gt; 로 확장 되거나 그렇지 않으면 비 웁니다 .</target>
        </trans-unit>
        <trans-unit id="14917a6f89a81ab57d696410ff4727ffb7df0251" translate="yes" xml:space="preserve">
          <source>In this case, a &lt;code&gt;FindAutmoc4.cmake&lt;/code&gt; module wraps a call to &lt;code&gt;find_package(Automoc4 NO_MODULE)&lt;/code&gt; and adds an additional search directory for &lt;code&gt;automoc4&lt;/code&gt;. Then the call to &lt;code&gt;find_package_handle_standard_args&lt;/code&gt; produces a proper success/failure message.</source>
          <target state="translated">이 경우, &lt;code&gt;FindAutmoc4.cmake&lt;/code&gt; 의 모듈의 호출 래핑 &lt;code&gt;find_package(Automoc4 NO_MODULE)&lt;/code&gt; 와에 대한 추가 검색 디렉토리를 추가 &lt;code&gt;automoc4&lt;/code&gt; . 그런 다음 &lt;code&gt;find_package_handle_standard_args&lt;/code&gt; 를 호출 하면 적절한 성공 / 실패 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a7746056a18b7d9a076205eac1fdec2b08bc9126" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;ClimbingStatsConfig.cmake&lt;/code&gt; file could be as simple as:</source>
          <target state="translated">이 경우 &lt;code&gt;ClimbingStatsConfig.cmake&lt;/code&gt; 파일은 다음과 같이 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b09e5afcf6a307427590313e600e45d81361b99" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;LibArchive&lt;/code&gt; package is considered to be found if both &lt;code&gt;LibArchive_LIBRARY&lt;/code&gt; and &lt;code&gt;LibArchive_INCLUDE_DIR&lt;/code&gt; are valid. Also the version of &lt;code&gt;LibArchive&lt;/code&gt; will be checked by using the version contained in &lt;code&gt;LibArchive_VERSION&lt;/code&gt;. Since no &lt;code&gt;FAIL_MESSAGE&lt;/code&gt; is given, the default messages will be printed.</source>
          <target state="translated">이 경우 &lt;code&gt;LibArchive&lt;/code&gt; 패키지는 &lt;code&gt;LibArchive_LIBRARY&lt;/code&gt; 및 &lt;code&gt;LibArchive_INCLUDE_DIR&lt;/code&gt; 이 모두 유효한 경우 발견 된 것으로 간주됩니다 . 또한 버전 &lt;code&gt;LibArchive&lt;/code&gt; 이 포함 된 버전을 사용하여 확인됩니다 &lt;code&gt;LibArchive_VERSION&lt;/code&gt; 을 . &lt;code&gt;FAIL_MESSAGE&lt;/code&gt; 가 제공 되지 않으므로 기본 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ad7830b435d957b704005c0358a6d3b72bf8b7fb" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;exe1&lt;/code&gt; executable will be compiled with &lt;code&gt;-DClimbingStats_FROM_BUILD_LOCATION&lt;/code&gt;. The exporting commands generate &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-2-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; targets with either the &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; or the &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; omitted, and the &lt;code&gt;*_INTERFACE&lt;/code&gt; marker stripped away. A separate project consuming the &lt;code&gt;ClimbingStats&lt;/code&gt; package would contain:</source>
          <target state="translated">이 경우, &lt;code&gt;exe1&lt;/code&gt; 의 실행 파일로 컴파일됩니다 &lt;code&gt;-DClimbingStats_FROM_BUILD_LOCATION&lt;/code&gt; . 익스포트 명령 은 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 또는 &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; 가 생략되고 &lt;code&gt;*_INTERFACE&lt;/code&gt; 마커가 제거 된 &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-2-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상을 생성 합니다. &lt;code&gt;ClimbingStats&lt;/code&gt; 패키지를 사용 하는 별도의 프로젝트 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c0546276adac56533f04d0e5bdf8dc378e4f6b34" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;exe1&lt;/code&gt; source files will be compiled with &lt;code&gt;-DCONTAINER_SIZE=200&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;exe1&lt;/code&gt; 소스 파일은 &lt;code&gt;-DCONTAINER_SIZE=200&lt;/code&gt; 으로 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="495c1fea41ee99340b9007386d5c6f47393c3521" translate="yes" xml:space="preserve">
          <source>In this case, the single resource group indicates that it needs four GPU slots, all of which may come from separate GPUs (though they don&amp;rsquo;t have to; CTest may still assign slots from the same GPU.)</source>
          <target state="translated">이 경우 단일 리소스 그룹은 4 개의 GPU 슬롯이 필요함을 나타내며, 모두 별도의 GPU에서 올 수 있습니다 (그럴 필요는 없지만 CTest는 여전히 동일한 GPU의 슬롯을 할당 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="faef534bcd7846b2c682b12ff151675f0992d37a" translate="yes" xml:space="preserve">
          <source>In this case, when using &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt;&lt;code&gt;install(TARGETS)&lt;/code&gt;&lt;/a&gt; the &lt;code&gt;INCLUDES DESTINATION&lt;/code&gt; was specified. This causes the &lt;code&gt;IMPORTED&lt;/code&gt; targets to have their &lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt; populated with the &lt;code&gt;include&lt;/code&gt; directory in the &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/a&gt;. When the &lt;code&gt;IMPORTED&lt;/code&gt; target is used by downstream, it automatically consumes the entries from that property.</source>
          <target state="translated">이 경우 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt; &lt;code&gt;install(TARGETS)&lt;/code&gt; &lt;/a&gt; 때 &lt;code&gt;INCLUDES DESTINATION&lt;/code&gt; 이 지정되었습니다. 이것은 &lt;code&gt;IMPORTED&lt;/code&gt; 대상 이 &lt;a href=&quot;../variable/cmake_install_prefix#variable:CMAKE_INSTALL_PREFIX&quot; id=&quot;index-0-variable:CMAKE_INSTALL_PREFIX&quot;&gt; &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;include&lt;/code&gt; 디렉토리로 채워진 &lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; 를 갖도록합니다 . 다운 스트림 에서 &lt;code&gt;IMPORTED&lt;/code&gt; 대상을 사용 하면 해당 속성의 항목이 자동으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="795768706f4a38ae7b505cd0f2f793177bc40cef" translate="yes" xml:space="preserve">
          <source>In this example, CMake will ensure the compiler is invoked in a mode of at-least C++ 11 (or C++ 14, C++ 17, &amp;hellip;), adding flags such as &lt;code&gt;-std=gnu++11&lt;/code&gt; if necessary. This applies to sources within &lt;code&gt;mylib&lt;/code&gt; as well as any dependents (that may include headers from &lt;code&gt;mylib&lt;/code&gt;).</source>
          <target state="translated">이 예제에서 CMake는 컴파일러가 최소 C ++ 11 (또는 C ++ 14, C ++ 17,&amp;hellip;) 모드에서 호출되도록하고 필요한 경우 &lt;code&gt;-std=gnu++11&lt;/code&gt; 과 같은 플래그를 추가 합니다. 이는 &lt;code&gt;mylib&lt;/code&gt; 내의 소스 와 모든 종속 항목에 적용됩니다 ( &lt;code&gt;mylib&lt;/code&gt; 의 헤더를 포함 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="c89544a45ca6b75fa73a98ece762b01f9c3972ca" translate="yes" xml:space="preserve">
          <source>In this example, CMake will ensure the compiler is invoked in a mode that is aware of C++ 11 (or above), adding flags such as &lt;code&gt;-std=gnu++11&lt;/code&gt; if necessary. This applies to sources within &lt;code&gt;mylib&lt;/code&gt; as well as any dependents (that may include headers from &lt;code&gt;mylib&lt;/code&gt;).</source>
          <target state="translated">이 예제에서 CMake는 C ++ 11 이상을 인식하는 모드에서 컴파일러를 호출하고 필요한 경우 &lt;code&gt;-std=gnu++11&lt;/code&gt; 과 같은 플래그를 추가 합니다. 이는 &lt;code&gt;mylib&lt;/code&gt; 의 소스 및 모든 종속 항목 ( &lt;code&gt;mylib&lt;/code&gt; 의 헤더를 포함 할 수 있음 )에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a781926952f21503419f7bc0fb80b66328789027" translate="yes" xml:space="preserve">
          <source>In this example, for &lt;code&gt;myapp1&lt;/code&gt;, the first pass will, unexpectedly, determine that the link language is &lt;code&gt;CXX&lt;/code&gt; because the evaluation of the generator expression will be an empty string so &lt;code&gt;myapp1&lt;/code&gt; will depends on target &lt;code&gt;lib&lt;/code&gt; which is &lt;code&gt;C++&lt;/code&gt;. On the contrary, for &lt;code&gt;myapp2&lt;/code&gt;, the first evaluation will give &lt;code&gt;C&lt;/code&gt; as link language, so the second pass will correctly add target &lt;code&gt;libother&lt;/code&gt; as link dependency.</source>
          <target state="translated">이 예에서 &lt;code&gt;myapp1&lt;/code&gt; 의 경우 첫 번째 패스는 생성기 표현식의 평가가 빈 문자열이므로 &lt;code&gt;myapp1&lt;/code&gt; 이 &lt;code&gt;C++&lt;/code&gt; 대상 &lt;code&gt;lib&lt;/code&gt; 에 종속 되기 때문에 예기치 않게 링크 언어가 &lt;code&gt;CXX&lt;/code&gt; 라고 결정합니다 . 반대로 &lt;code&gt;myapp2&lt;/code&gt; 의 경우 첫 번째 평가에서 &lt;code&gt;C&lt;/code&gt; 를 링크 언어로 제공하므로 두 번째 단계에서는 대상 &lt;code&gt;libother&lt;/code&gt; 를 링크 종속성으로 올바르게 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e813483137820a3e9af75d2b9cf5269ae6126a79" translate="yes" xml:space="preserve">
          <source>In this example, group 0 gets 2 slots from GPU &lt;code&gt;0&lt;/code&gt;, group 1 gets 2 slots from GPU &lt;code&gt;2&lt;/code&gt;, and group 2 gets 4 slots from GPU &lt;code&gt;1&lt;/code&gt;, 1 slot from GPU &lt;code&gt;3&lt;/code&gt;, and 2 slots from cryptography chip &lt;code&gt;card0&lt;/code&gt;.</source>
          <target state="translated">이 예에서 그룹 0은 GPU &lt;code&gt;0&lt;/code&gt; 에서 2 개의 슬롯을 , 그룹 1은 GPU &lt;code&gt;2&lt;/code&gt; 에서 2 개의 슬롯을 , 그룹 2는 GPU &lt;code&gt;1&lt;/code&gt; 에서 4 개의 슬롯, GPU &lt;code&gt;3&lt;/code&gt; 에서 1 개의 슬롯, 암호화 칩 &lt;code&gt;card0&lt;/code&gt; 에서 2 개의 슬롯을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="3ec83c1549b57889d549086797bf605970cfafa4" translate="yes" xml:space="preserve">
          <source>In this example, there are two group descriptions (implicitly separated by a semicolon.) The content of the first description is &lt;code&gt;2,gpus:2&lt;/code&gt;. This description specifies 2 groups, each of which requires 2 slots from a single GPU. The content of the second description is &lt;code&gt;gpus:4,crypto_chips:2&lt;/code&gt;. This description does not specify a group count, so a default of 1 is assumed. This single group requires 4 slots from a single GPU and 2 slots from a single cryptography chip. In total, 3 resource groups are specified for this test, each with its own unique requirements.</source>
          <target state="translated">이 예에는 두 개의 그룹 설명이 있습니다 (암시 적으로 세미콜론으로 &lt;code&gt;2,gpus:2&lt;/code&gt; 첫 번째 설명의 내용은 2, gpus : 2 입니다. 이 설명은 2 개의 그룹을 지정하며 각 그룹에는 단일 GPU에서 2 개의 슬롯이 필요합니다. 두 번째 설명의 내용은 &lt;code&gt;gpus:4,crypto_chips:2&lt;/code&gt; 입니다. 이 설명은 그룹 수를 지정하지 않으므로 기본값 1로 가정합니다. 이 단일 그룹에는 단일 GPU에서 4 개의 슬롯이 필요하고 단일 암호화 칩에서 2 개의 슬롯이 필요합니다. 총 3 개의 리소스 그룹이이 테스트에 지정되며 각각 고유 한 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc469e2d74ed34e509c529fc20edd178dacef100" translate="yes" xml:space="preserve">
          <source>In this form, &lt;code&gt;&amp;lt;srcdir&amp;gt;&lt;/code&gt; should contain a complete CMake project with a &lt;code&gt;CMakeLists.txt&lt;/code&gt; file and all sources. The &lt;code&gt;&amp;lt;bindir&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;srcdir&amp;gt;&lt;/code&gt; will not be deleted after this command is run. Specify &lt;code&gt;&amp;lt;targetName&amp;gt;&lt;/code&gt; to build a specific target instead of the &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;ALL_BUILD&lt;/code&gt; target. See below for the meaning of other options.</source>
          <target state="translated">이 형식에서 &lt;code&gt;&amp;lt;srcdir&amp;gt;&lt;/code&gt; 은 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일과 모든 소스 가 포함 된 완전한 CMake 프로젝트를 포함해야합니다 . &lt;code&gt;&amp;lt;bindir&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;srcdir&amp;gt;&lt;/code&gt; 이 명령이 실행 된 후 삭제되지 않습니다. &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;ALL_BUILD&lt;/code&gt; 대상 대신 특정 대상을 빌드하려면 &lt;code&gt;&amp;lt;targetName&amp;gt;&lt;/code&gt; 을 지정하십시오 . 다른 옵션의 의미는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e38723a700a8af9c8acb671019864dd441d0144b" translate="yes" xml:space="preserve">
          <source>In this form, one or more source files must be provided. If &lt;a href=&quot;../variable/cmake_try_compile_target_type#variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot; id=&quot;index-1-variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot;&gt;&lt;code&gt;CMAKE_TRY_COMPILE_TARGET_TYPE&lt;/code&gt;&lt;/a&gt; is unset or is set to &lt;code&gt;EXECUTABLE&lt;/code&gt;, the sources must include a definition for &lt;code&gt;main&lt;/code&gt; and CMake will create a &lt;code&gt;CMakeLists.txt&lt;/code&gt; file to build the source(s) as an executable. If &lt;a href=&quot;../variable/cmake_try_compile_target_type#variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot; id=&quot;index-2-variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot;&gt;&lt;code&gt;CMAKE_TRY_COMPILE_TARGET_TYPE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;STATIC_LIBRARY&lt;/code&gt;, a static library will be built instead and no definition for &lt;code&gt;main&lt;/code&gt; is required. For an executable, the generated &lt;code&gt;CMakeLists.txt&lt;/code&gt; file would contain something like the following:</source>
          <target state="translated">이 양식에서 하나 이상의 소스 파일을 제공해야합니다. 경우 &lt;a href=&quot;../variable/cmake_try_compile_target_type#variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot; id=&quot;index-1-variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot;&gt; &lt;code&gt;CMAKE_TRY_COMPILE_TARGET_TYPE&lt;/code&gt; 가&lt;/a&gt; 해제 또는 설정되어 &lt;code&gt;EXECUTABLE&lt;/code&gt; , 소스가에 대한 정의가 포함되어야합니다 &lt;code&gt;main&lt;/code&gt; 생성하고 CMake를 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 의 실행 파일과 소스 (들)을 구축 할 파일을. 경우 &lt;a href=&quot;../variable/cmake_try_compile_target_type#variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot; id=&quot;index-2-variable:CMAKE_TRY_COMPILE_TARGET_TYPE&quot;&gt; &lt;code&gt;CMAKE_TRY_COMPILE_TARGET_TYPE&lt;/code&gt; 가&lt;/a&gt; 설정되어 &lt;code&gt;STATIC_LIBRARY&lt;/code&gt; , 정적 라이브러리 대신 지어 질 것이다 및 대한 정의 &lt;code&gt;main&lt;/code&gt; 필요하지 않습니다. 실행 파일의 경우 생성 된 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일에는 다음과 같은 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="96807519e86607c3e14a00b25ca13ed90674b984" translate="yes" xml:space="preserve">
          <source>In this guide, we will present the concept of &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-0-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; targets and demonstrate how to import existing executable or library files from disk into a CMake project. We will then show how CMake supports exporting targets from one CMake-based project and importing them into another. Finally, we will demonstrate how to package a project with a configuration file to allow for easy integration into other CMake projects. This guide and the complete example source code can be found in the &lt;code&gt;Help/guide/importing-exporting&lt;/code&gt; directory of the CMake source code tree.</source>
          <target state="translated">이 가이드에서는 &lt;a href=&quot;../../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-0-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상 의 개념을 제시하고 기존 실행 파일 또는 라이브러리 파일을 디스크에서 CMake 프로젝트로 가져 오는 방법을 보여줍니다. 그런 다음 CMake가 하나의 CMake 기반 프로젝트에서 대상을 내보내고 다른 프로젝트로 가져 오는 것을 지원하는 방법을 보여줍니다. 마지막으로 다른 CMake 프로젝트에 쉽게 통합 할 수 있도록 구성 파일로 프로젝트를 패키징하는 방법을 보여줍니다. 이 가이드와 전체 예제 소스 코드는 CMake 소스 코드 트리 의 &lt;code&gt;Help/guide/importing-exporting&lt;/code&gt; 디렉토리 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6b8e905dfed21c75cf25bdc5802ed699f1a4104" translate="yes" xml:space="preserve">
          <source>In this scenario, if you choose to install only the &lt;code&gt;Development&lt;/code&gt; component, both the headers and namelink will be installed without the library. (If you don&amp;rsquo;t also install the &lt;code&gt;Libraries&lt;/code&gt; component, the namelink will be a dangling symlink, and projects that link to the library will have build errors.) If you install only the &lt;code&gt;Libraries&lt;/code&gt; component, only the library will be installed, without the headers and namelink.</source>
          <target state="translated">이 시나리오에서 &lt;code&gt;Development&lt;/code&gt; 구성 요소 만 설치하도록 선택 하면 라이브러리없이 헤더와 이름 링크가 모두 설치됩니다. &lt;code&gt;Libraries&lt;/code&gt; 구성 요소 도 설치하지 않으면 네임 링크가 매달려있는 심볼릭 링크가되고 라이브러리에 연결된 프로젝트에는 빌드 오류가 발생합니다. &lt;code&gt;Libraries&lt;/code&gt; 구성 요소 만 설치하면 라이브러리 구성 요소 만 설치됩니다 . 헤더와 이름 링크.</target>
        </trans-unit>
        <trans-unit id="6aa2ea44d8b88046da7a91e70b59846b629d607c" translate="yes" xml:space="preserve">
          <source>In this section we will show how the &lt;a href=&quot;../../variable/build_shared_libs#variable:BUILD_SHARED_LIBS&quot; id=&quot;index-0-variable:BUILD_SHARED_LIBS&quot;&gt;&lt;code&gt;BUILD_SHARED_LIBS&lt;/code&gt;&lt;/a&gt; variable can be used to control the default behavior of &lt;a href=&quot;../../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library()&lt;/code&gt;&lt;/a&gt;, and allow control over how libraries without an explicit type (&lt;code&gt;STATIC&lt;/code&gt;, &lt;code&gt;SHARED&lt;/code&gt;, &lt;code&gt;MODULE&lt;/code&gt; or &lt;code&gt;OBJECT&lt;/code&gt;) are built.</source>
          <target state="translated">이 섹션에서는 &lt;a href=&quot;../../variable/build_shared_libs#variable:BUILD_SHARED_LIBS&quot; id=&quot;index-0-variable:BUILD_SHARED_LIBS&quot;&gt; &lt;code&gt;BUILD_SHARED_LIBS&lt;/code&gt; &lt;/a&gt; 변수를 사용하여 &lt;a href=&quot;../../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library()&lt;/code&gt; &lt;/a&gt; 의 기본 동작을 제어하고 명시 적 유형 ( &lt;code&gt;STATIC&lt;/code&gt; , &lt;code&gt;SHARED&lt;/code&gt; , &lt;code&gt;MODULE&lt;/code&gt; 또는 &lt;code&gt;OBJECT&lt;/code&gt; )이 없는 라이브러리를 빌드 하는 방법 을 제어 할 수있는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="35463d41901b805f9ba19695683bc2732ed13231" translate="yes" xml:space="preserve">
          <source>In this use-case, the CMake code will wish to enable a particular language standard if available from the compiler. The &lt;a href=&quot;../prop_tgt/cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD&quot;&gt;&lt;code&gt;CXX_STANDARD&lt;/code&gt;&lt;/a&gt; target property variable may be set to the desired language standard for a particular target, and the &lt;a href=&quot;../variable/cmake_cxx_standard#variable:CMAKE_CXX_STANDARD&quot; id=&quot;index-0-variable:CMAKE_CXX_STANDARD&quot;&gt;&lt;code&gt;CMAKE_CXX_STANDARD&lt;/code&gt;&lt;/a&gt; may be set to influence all following targets:</source>
          <target state="translated">이 사용 사례에서 CMake 코드는 컴파일러에서 사용 가능한 경우 특정 언어 표준을 활성화하려고합니다. &lt;a href=&quot;../prop_tgt/cxx_standard#prop_tgt:CXX_STANDARD&quot; id=&quot;index-0-prop_tgt:CXX_STANDARD&quot;&gt; &lt;code&gt;CXX_STANDARD&lt;/code&gt; 의&lt;/a&gt; target 속성 변수는 특정 대상에 대해 원하는 언어를 기준으로 설정 될 수 있고, &lt;a href=&quot;../variable/cmake_cxx_standard#variable:CMAKE_CXX_STANDARD&quot; id=&quot;index-0-variable:CMAKE_CXX_STANDARD&quot;&gt; &lt;code&gt;CMAKE_CXX_STANDARD&lt;/code&gt; 은&lt;/a&gt; 모든 다음 목표물에 영향을 설정할 수있다 :</target>
        </trans-unit>
        <trans-unit id="90a18896dd7e3dbd05373b7e60360ba9de908dbe" translate="yes" xml:space="preserve">
          <source>In this variant, &lt;code&gt;&amp;lt;lists&amp;gt;&lt;/code&gt; is a whitespace or semicolon separated list of list-valued variables. The &lt;code&gt;foreach&lt;/code&gt; command iterates over each item in each given list. The &lt;code&gt;&amp;lt;items&amp;gt;&lt;/code&gt; following the &lt;code&gt;ITEMS&lt;/code&gt; keyword are processed as in the first variant of the &lt;code&gt;foreach&lt;/code&gt; command. The forms &lt;code&gt;LISTS A&lt;/code&gt; and &lt;code&gt;ITEMS ${A}&lt;/code&gt; are equivalent.</source>
          <target state="translated">이 변형에서 &lt;code&gt;&amp;lt;lists&amp;gt;&lt;/code&gt; 는 공백 또는 세미콜론으로 구분 된 목록 값 변수 목록입니다. &lt;code&gt;foreach&lt;/code&gt; 명령은 각각의 주어진 목록의 각 항목을 반복 처리. &lt;code&gt;ITEMS&lt;/code&gt; 키워드 다음에 나오는 &lt;code&gt;&amp;lt;items&amp;gt;&lt;/code&gt; 는 &lt;code&gt;foreach&lt;/code&gt; 명령 의 첫 번째 변형에서와 같이 처리됩니다 . 양식 &lt;code&gt;LISTS A&lt;/code&gt; 하고 &lt;code&gt;ITEMS ${A}&lt;/code&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4d09fbafc366c794c05eaa56b20f54d451e107bb" translate="yes" xml:space="preserve">
          <source>In this variant, &lt;code&gt;&amp;lt;lists&amp;gt;&lt;/code&gt; is a whitespace or semicolon separated list of list-valued variables. The &lt;code&gt;foreach&lt;/code&gt; command iterates over each list simultaneously setting the iteration variables as follows:</source>
          <target state="translated">이 변형에서 &lt;code&gt;&amp;lt;lists&amp;gt;&lt;/code&gt; 는 목록 값 변수의 공백 또는 세미콜론으로 구분 된 목록입니다. &lt;code&gt;foreach&lt;/code&gt; 는 다음과 같이 각각의리스트를 반복 명령 동시에 반복 변수 설정 :</target>
        </trans-unit>
        <trans-unit id="81d8b22a8d1010c9ab92e281bb426c8fd32311af" translate="yes" xml:space="preserve">
          <source>In this variant, &lt;code&gt;foreach&lt;/code&gt; iterates over the numbers 0, 1, &amp;hellip; up to (and including) the nonnegative integer &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 변형에서 &lt;code&gt;foreach&lt;/code&gt; 는 숫자 0, 1,&amp;hellip;에서 음이 아닌 정수 &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; 까지 반복합니다 .</target>
        </trans-unit>
        <trans-unit id="cedaab0a06bfc8d60da04b56bb5b94a4474c3074" translate="yes" xml:space="preserve">
          <source>In this variant, &lt;code&gt;foreach&lt;/code&gt; iterates over the numbers from &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; up to at most &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; in steps of &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; is not specified, then the step size is 1. The three arguments &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; must all be nonnegative integers, and &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; must not be smaller than &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;; otherwise you enter the danger zone of undocumented behavior that may change in future releases.</source>
          <target state="translated">이 변형에서 &lt;code&gt;foreach&lt;/code&gt; 는 &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; 단계 에서 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 부터 최대 &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; 까지 의 숫자를 반복합니다 . 경우 &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; 를 지정하지 않은 경우 다음 스텝 크기는 1 세 개의 인수입니다 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; 모든 음이 아닌 정수이어야합니다 &lt;code&gt;&amp;lt;stop&amp;gt;&lt;/code&gt; 보다 작은 안됩니다 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; ; 그렇지 않으면 향후 릴리스에서 변경 될 수있는 문서화되지 않은 동작의 위험 영역에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="912ad91c8a9e8d07fce740305f3e3089d4a7de32" translate="yes" xml:space="preserve">
          <source>In this version all files in &lt;code&gt;&amp;lt;bindir&amp;gt;/CMakeFiles/CMakeTmp&lt;/code&gt; will be cleaned automatically. For debugging, &lt;code&gt;--debug-trycompile&lt;/code&gt; can be passed to &lt;code&gt;cmake&lt;/code&gt; to avoid this clean. However, multiple sequential &lt;code&gt;try_compile&lt;/code&gt; operations reuse this single output directory. If you use &lt;code&gt;--debug-trycompile&lt;/code&gt;, you can only debug one &lt;code&gt;try_compile&lt;/code&gt; call at a time. The recommended procedure is to protect all &lt;code&gt;try_compile&lt;/code&gt; calls in your project by &lt;code&gt;if(NOT DEFINED &amp;lt;resultVar&amp;gt;)&lt;/code&gt; logic, configure with cmake all the way through once, then delete the cache entry associated with the try_compile call of interest, and then re-run cmake again with &lt;code&gt;--debug-trycompile&lt;/code&gt;.</source>
          <target state="translated">이 버전에서는 &lt;code&gt;&amp;lt;bindir&amp;gt;/CMakeFiles/CMakeTmp&lt;/code&gt; 의 모든 파일이 자동으로 정리됩니다. 디버깅을 위해 &lt;code&gt;--debug-trycompile&lt;/code&gt; 을 &lt;code&gt;cmake&lt;/code&gt; 에 전달 하여이 정리를 피할 수 있습니다 . 그러나 여러 순차 &lt;code&gt;try_compile&lt;/code&gt; 조작은이 단일 출력 디렉토리를 재사용합니다. &lt;code&gt;--debug-trycompile&lt;/code&gt; 을 사용 하면 한 번에 하나의 &lt;code&gt;try_compile&lt;/code&gt; 호출 만 디버깅 할 수 있습니다 . 권장되는 절차는 &lt;code&gt;if(NOT DEFINED &amp;lt;resultVar&amp;gt;)&lt;/code&gt; 로직으로 프로젝트의 모든 &lt;code&gt;try_compile&lt;/code&gt; 호출 을 보호 하고 cmake로 한 번만 구성한 다음 관심있는 try_compile 호출과 관련된 캐시 항목을 삭제 한 다음 다시 실행하는 것입니다. 다시 cmake &lt;code&gt;--debug-trycompile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d75afcedf77994041e46586e2d4fd27c496934e" translate="yes" xml:space="preserve">
          <source>In total the dependencies of the &lt;code&gt;_autogen&lt;/code&gt; target are composed from</source>
          <target state="translated">총 &lt;code&gt;_autogen&lt;/code&gt; 대상 의 종속성은</target>
        </trans-unit>
        <trans-unit id="5f8f675dc00440fd6730f9b9dc22b812593d71c4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;INSTALL&lt;/code&gt; target to default build.</source>
          <target state="translated">기본 빌드에 &lt;code&gt;INSTALL&lt;/code&gt; 대상을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="48e5e8dae482d67bdfb7fe826386762d334434b8" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;PACKAGE&lt;/code&gt; target to default build.</source>
          <target state="translated">기본 빌드에 &lt;code&gt;PACKAGE&lt;/code&gt; 대상을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="67796e70c1b3fc264ff928a09d02542e7552b222" translate="yes" xml:space="preserve">
          <source>Include Directories and Usage Requirements</source>
          <target state="translated">디렉토리 및 사용 요구 사항 포함</target>
        </trans-unit>
        <trans-unit id="e74bc52f3b3fe2528e8e649f3cc8e41b042c1138" translate="yes" xml:space="preserve">
          <source>Include an external Microsoft project file in a workspace.</source>
          <target state="translated">작업 공간에 외부 Microsoft 프로젝트 파일을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="f0d96242ab0342c46719da163872c87dba83a4eb" translate="yes" xml:space="preserve">
          <source>Include directories for GDAL headers.</source>
          <target state="translated">GDAL 헤더 용 디렉토리를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="88fa5da10c45484b3be0daa0a1788d66fb9345d1" translate="yes" xml:space="preserve">
          <source>Include directories for Google Protocol Buffers</source>
          <target state="translated">Google 프로토콜 버퍼 용 디렉토리 포함</target>
        </trans-unit>
        <trans-unit id="8e0d894920f055045fe2b193e47abf678034cef4" translate="yes" xml:space="preserve">
          <source>Include directories require some special consideration when specified as usage requirements and when used with generator expressions. The &lt;a href=&quot;../command/target_include_directories#command:target_include_directories&quot; id=&quot;index-1-command:target_include_directories&quot;&gt;&lt;code&gt;target_include_directories()&lt;/code&gt;&lt;/a&gt; command accepts both relative and absolute include directories:</source>
          <target state="translated">포함 디렉토리는 사용법 요구 사항으로 지정되고 생성기 표현식과 함께 사용될 때 특별한 고려 사항이 필요합니다. &lt;a href=&quot;../command/target_include_directories#command:target_include_directories&quot; id=&quot;index-1-command:target_include_directories&quot;&gt; &lt;code&gt;target_include_directories()&lt;/code&gt; &lt;/a&gt; 명령은 모두 상대적으로 받아들이고 절대 디렉토리를 포함한다 :</target>
        </trans-unit>
        <trans-unit id="ce43ac439197ffc955e524b2550b161ad6f531cd" translate="yes" xml:space="preserve">
          <source>Include directories to be used for every source file compiled with the &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; compiler. This is meant for specification of system include directories needed by the language for the current platform. The directories always appear at the end of the include path passed to the compiler.</source>
          <target state="translated">&lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; 컴파일러로 컴파일 된 모든 소스 파일에 사용할 디렉토리를 포함하십시오 . 이는 현재 플랫폼의 언어에 필요한 시스템 포함 디렉토리를 지정하기위한 것입니다. 디렉토리는 항상 컴파일러에 전달 된 포함 경로의 끝에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="32d2423d4df26a6d0a45a87e0b2a0f72dc810e6f" translate="yes" xml:space="preserve">
          <source>Include directories usage requirements commonly differ between the build-tree and the install-tree. The &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; and &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; generator expressions can be used to describe separate usage requirements based on the usage location. Relative paths are allowed within the &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; expression and are interpreted relative to the installation prefix. For example:</source>
          <target state="translated">포함 디렉토리 사용 요구 사항은 일반적으로 빌드 트리와 설치 트리간에 다릅니다. &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; 및 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 발전기 표현은 사용 위치에 따라 별도의 사용 요구 사항을 설명하는 데 사용 할 수 있습니다. 상대 경로는 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 표현식 내에서 허용 되며 설치 접 두부와 관련하여 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f1b0ffb783fe81c6ee7eabe3afbcc850210398e" translate="yes" xml:space="preserve">
          <source>Include file check macros honor &lt;code&gt;CMAKE_REQUIRED_LIBRARIES&lt;/code&gt;.</source>
          <target state="translated">파일 확인 매크로를 포함하면 &lt;code&gt;CMAKE_REQUIRED_LIBRARIES&lt;/code&gt; 가 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="f75295c6b25f9d91bdec92487f46ffb98ec99137" translate="yes" xml:space="preserve">
          <source>Include file scanning regular expression.</source>
          <target state="translated">파일 스캐닝 정규식을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="14ce261eaed382d8b1c4862f16a7bee6f00ed6fc" translate="yes" xml:space="preserve">
          <source>Include path(s) for MPI header.</source>
          <target state="translated">MPI 헤더의 경로를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="f16b0129fde0a65301ef3aaed51d235f77a00c03" translate="yes" xml:space="preserve">
          <source>Include this module in the top CMakeLists.txt file of a project to enable testing with CTest and dashboard submissions to CDash:</source>
          <target state="translated">CTest 및 대시 보드를 CDash에 제출하여 테스트 할 수 있도록 프로젝트의 최상위 CMakeLists.txt 파일에이 모듈을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="b12826fe44caa27a14339b084130a9357afa20a5" translate="yes" xml:space="preserve">
          <source>Include this module to search for compiler-provided system runtime libraries and add install rules for them. Some optional variables may be set prior to including the module to adjust behavior:</source>
          <target state="translated">이 모듈을 포함시켜 컴파일러 제공 시스템 런타임 라이브러리를 검색하고 설치 규칙을 추가하십시오. 동작을 조정하기 위해 모듈을 포함하기 전에 일부 선택적 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ae65a91b6d3429dd28c5ce4d4be8c5332ec71d" translate="yes" xml:space="preserve">
          <source>Included &lt;code&gt;moc_*.cpp&lt;/code&gt; and &lt;code&gt;*.moc&lt;/code&gt; files will be generated in the &lt;code&gt;&amp;lt;AUTOGEN_BUILD_DIR&amp;gt;/include&lt;/code&gt; directory which is automatically added to the target&amp;rsquo;s &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-0-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포함 된 &lt;code&gt;moc_*.cpp&lt;/code&gt; 및 &lt;code&gt;*.moc&lt;/code&gt; 파일은 대상의 &lt;a href=&quot;../prop_tgt/include_directories#prop_tgt:INCLUDE_DIRECTORIES&quot; id=&quot;index-0-prop_tgt:INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INCLUDE_DIRECTORIES&lt;/code&gt; 에&lt;/a&gt; 자동으로 추가되는 &lt;code&gt;&amp;lt;AUTOGEN_BUILD_DIR&amp;gt;/include&lt;/code&gt; 디렉토리에 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="84302a5df7b76ccdb6e34c68f72400c71ce5a8a4" translate="yes" xml:space="preserve">
          <source>Included moc output files</source>
          <target state="translated">포함 된 moc 출력 파일</target>
        </trans-unit>
        <trans-unit id="ea8a543f60580381edf0a4ac9cfb685762b0e5f4" translate="yes" xml:space="preserve">
          <source>Included scripts do automatic &lt;a href=&quot;../command/cmake_policy#command:cmake_policy&quot; id=&quot;index-0-command:cmake_policy&quot;&gt;&lt;code&gt;cmake_policy()&lt;/code&gt;&lt;/a&gt; PUSH and POP.</source>
          <target state="translated">포함 된 스크립트는 자동 &lt;a href=&quot;../command/cmake_policy#command:cmake_policy&quot; id=&quot;index-0-command:cmake_policy&quot;&gt; &lt;code&gt;cmake_policy()&lt;/code&gt; &lt;/a&gt; PUSH 및 POP을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ca576823909d32ddb6875fc1b60fa7e15d936b2c" translate="yes" xml:space="preserve">
          <source>Includes an external Microsoft project in the generated workspace file. Currently does nothing on UNIX. This will create a target named &lt;code&gt;[projectname]&lt;/code&gt;. This can be used in the &lt;a href=&quot;add_dependencies#command:add_dependencies&quot; id=&quot;index-0-command:add_dependencies&quot;&gt;&lt;code&gt;add_dependencies()&lt;/code&gt;&lt;/a&gt; command to make things depend on the external project.</source>
          <target state="translated">생성 된 작업 공간 파일에 외부 Microsoft 프로젝트를 포함합니다. 현재 UNIX에서는 아무 것도 수행하지 않습니다. &lt;code&gt;[projectname]&lt;/code&gt; 이라는 대상이 생성됩니다 . &lt;a href=&quot;add_dependencies#command:add_dependencies&quot; id=&quot;index-0-command:add_dependencies&quot;&gt; &lt;code&gt;add_dependencies()&lt;/code&gt; &lt;/a&gt; 명령에서이를 사용하여 외부 프로젝트에 종속되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48b24587f09cbb0c6d6de778bcf9dbc97bf3880e" translate="yes" xml:space="preserve">
          <source>Includes or removes items from &lt;code&gt;list&lt;/code&gt; that match the regular expression &lt;code&gt;regex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regex&lt;/code&gt; 와 일치하는 항목을 &lt;code&gt;list&lt;/code&gt; 에서 포함하거나 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="0865b4d7c07f05d7bf978b3a6f3c225e1a5056ee" translate="yes" xml:space="preserve">
          <source>Includes or removes items from the list that match the mode&amp;rsquo;s pattern. In &lt;code&gt;REGEX&lt;/code&gt; mode, items will be matched against the given regular expression.</source>
          <target state="translated">모드의 패턴과 일치하는 항목을 목록에서 포함하거나 제거합니다. 에서 &lt;code&gt;REGEX&lt;/code&gt; 모드, 항목은 지정된 정규 표현에 일치됩니다.</target>
        </trans-unit>
        <trans-unit id="5aab172bab3c2a3b59d730ace5a79dbd2f2f6825" translate="yes" xml:space="preserve">
          <source>Including header moc files in sources</source>
          <target state="translated">소스에 헤더 moc 파일 포함</target>
        </trans-unit>
        <trans-unit id="ee983326646b313992ad093f9391d987efeb75f1" translate="yes" xml:space="preserve">
          <source>Inclusion of the CPack module adds two new build targets, &lt;code&gt;package&lt;/code&gt; and &lt;code&gt;package_source&lt;/code&gt;, which build the binary and source installers respectively. The generated binary installers contain everything installed via CMake&amp;rsquo;s &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command (and the deprecated commands &lt;a href=&quot;../command/install_files#command:install_files&quot; id=&quot;index-0-command:install_files&quot;&gt;&lt;code&gt;install_files()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../command/install_programs#command:install_programs&quot; id=&quot;index-0-command:install_programs&quot;&gt;&lt;code&gt;install_programs()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../command/install_targets#command:install_targets&quot; id=&quot;index-0-command:install_targets&quot;&gt;&lt;code&gt;install_targets()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">CPack 모듈을 포함 하면 바이너리 및 소스 설치 프로그램을 각각 빌드하는 두 개의 새로운 빌드 대상인 &lt;code&gt;package&lt;/code&gt; 및 &lt;code&gt;package_source&lt;/code&gt; 가 추가 됩니다. 생성 된 바이너리 설치 프로그램에는 CMake의 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 명령 및 더 이상 사용되지 않는 명령 &lt;a href=&quot;../command/install_files#command:install_files&quot; id=&quot;index-0-command:install_files&quot;&gt; &lt;code&gt;install_files()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../command/install_programs#command:install_programs&quot; id=&quot;index-0-command:install_programs&quot;&gt; &lt;code&gt;install_programs()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/install_targets#command:install_targets&quot; id=&quot;index-0-command:install_targets&quot;&gt; &lt;code&gt;install_targets()&lt;/code&gt; &lt;/a&gt; 를 통해 설치된 모든 것이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="67bc18555a1177d099ef0ced4e356503aeeb7caa" translate="yes" xml:space="preserve">
          <source>Inclusion of this module defines the following variables:</source>
          <target state="translated">이 모듈을 포함하면 다음 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c357bfafb66ce474f3fd20335a0aa9647e140631" translate="yes" xml:space="preserve">
          <source>Index into the &lt;code&gt;commands&lt;/code&gt; member of the &lt;code&gt;backtraceGraph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;backtraceGraph&lt;/code&gt; 의 &lt;code&gt;commands&lt;/code&gt; 멤버 로 색인하십시오 .</target>
        </trans-unit>
        <trans-unit id="08184ca3440cb5c4d1ed6a21dfc7529844965ff5" translate="yes" xml:space="preserve">
          <source>Index into the &lt;code&gt;files&lt;/code&gt; member of the &lt;code&gt;backtraceGraph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;backtraceGraph&lt;/code&gt; 의 &lt;code&gt;files&lt;/code&gt; 멤버 로 색인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8a9e575346155f87f2e13080f9ca870ed430741" translate="yes" xml:space="preserve">
          <source>Index into the &lt;code&gt;nodes&lt;/code&gt; member of the &lt;code&gt;backtraceGraph&lt;/code&gt; representing the parent in the graph.</source>
          <target state="translated">그래프에서 부모를 나타내는 &lt;code&gt;backtraceGraph&lt;/code&gt; 의 &lt;code&gt;nodes&lt;/code&gt; 멤버 로 인덱스하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e3f72dfbcd8f39920f845b42377d218730b45fc" translate="yes" xml:space="preserve">
          <source>Index into the &lt;code&gt;nodes&lt;/code&gt; member of the &lt;code&gt;backtraceGraph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;backtraceGraph&lt;/code&gt; 의 &lt;code&gt;nodes&lt;/code&gt; 멤버 로 색인하십시오 .</target>
        </trans-unit>
        <trans-unit id="44a7b35850cc745f71a4e09cc355f9df1fac6a4a" translate="yes" xml:space="preserve">
          <source>Indicate that the &lt;code&gt;&amp;lt;PackageName&amp;gt;&lt;/code&gt; does not match &lt;code&gt;${CMAKE_FIND_PACKAGE_NAME}&lt;/code&gt;. This is usually a mistake and raises a warning, but it may be intentional for usage of the command for components of a larger package.</source>
          <target state="translated">&lt;code&gt;&amp;lt;PackageName&amp;gt;&lt;/code&gt; 이 &lt;code&gt;${CMAKE_FIND_PACKAGE_NAME}&lt;/code&gt; 과 (와) 일치하지 않음을 나타냅니다 . 이는 일반적으로 실수이며 경고를 발생 시키지만 더 큰 패키지의 구성 요소에 대해 명령을 사용하려는 의도 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15abe2bacc2fc425402b5f9f1ef307af0e5e3d9a" translate="yes" xml:space="preserve">
          <source>Indicate that this target should be added to the default build target so that it will be run every time (the command cannot be called &lt;code&gt;ALL&lt;/code&gt;).</source>
          <target state="translated">매번 실행되도록이 대상을 기본 빌드 대상에 추가해야 함을 나타냅니다 (명령을 &lt;code&gt;ALL&lt;/code&gt; 로 호출 할 수 없음 ).</target>
        </trans-unit>
        <trans-unit id="084b05340a492359d4fa3f6561098321d502a7ee" translate="yes" xml:space="preserve">
          <source>Indicates the version of the JSON format. The version has a major and minor components following semantic version conventions.</source>
          <target state="translated">JSON 형식의 버전을 나타냅니다. 버전에는 의미 론적 버전 규칙을 따르는 주 구성 요소와 부 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc8d7f5e1fe6d22afbdbd001b383f19154f0ef9" translate="yes" xml:space="preserve">
          <source>Indicates the version(s) of the object kind that the client understands. Versions have major and minor components following semantic version conventions. The value must be</source>
          <target state="translated">클라이언트가 이해하는 객체 종류의 버전을 나타냅니다. 버전은 시맨틱 버전 규칙에 따라 주요 구성 요소와 보조 구성 요소가 있습니다. 값은</target>
        </trans-unit>
        <trans-unit id="c71b1ed7078de3fd73795686bab3b4a65b3070eb" translate="yes" xml:space="preserve">
          <source>Indication of whether an &lt;a href=&quot;../manual/cmake-buildsystem.7#imported-targets&quot;&gt;IMPORTED target&lt;/a&gt; is globally visible.</source>
          <target state="translated">&lt;a href=&quot;../manual/cmake-buildsystem.7#imported-targets&quot;&gt;IMPORTED 대상&lt;/a&gt; 이 전체적으로 표시 되는지 여부를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="de64979f84f85b02d52b9bfd15b06fcfe41576f8" translate="yes" xml:space="preserve">
          <source>Individual component values are also available in variables:</source>
          <target state="translated">개별 구성 요소 값은 변수로도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2dbd2ee7390c6862577544debd7027e78c9c7599" translate="yes" xml:space="preserve">
          <source>Individual features from C++ 11</source>
          <target state="translated">C ++ 11의 개별 기능</target>
        </trans-unit>
        <trans-unit id="953fe87f62cfefd171e7bae9a2f7a14222715c22" translate="yes" xml:space="preserve">
          <source>Individual features from C++ 14</source>
          <target state="translated">C ++ 14의 개별 기능</target>
        </trans-unit>
        <trans-unit id="9240fc562da1462636e151b0e00206f1e805baa6" translate="yes" xml:space="preserve">
          <source>Individual features from C++ 98</source>
          <target state="translated">C ++ 98의 개별 기능</target>
        </trans-unit>
        <trans-unit id="1f7961b0e11fd11062cf867a9840aa1259e2b034" translate="yes" xml:space="preserve">
          <source>Inform &lt;a href=&quot;../manual/cmake-generators.7#visual-studio-generators&quot;&gt;Visual Studio Generators&lt;/a&gt; for VS 2010 and above that the target platform enables WinRT compilation by default and it needs to be explicitly disabled if &lt;code&gt;/ZW&lt;/code&gt; or &lt;a href=&quot;../prop_tgt/vs_winrt_component#prop_tgt:VS_WINRT_COMPONENT&quot; id=&quot;index-0-prop_tgt:VS_WINRT_COMPONENT&quot;&gt;&lt;code&gt;VS_WINRT_COMPONENT&lt;/code&gt;&lt;/a&gt; is omitted (as opposed to enabling it when either of those options is present)</source>
          <target state="translated">알리 &lt;a href=&quot;../manual/cmake-generators.7#visual-studio-generators&quot;&gt;비주얼 스튜디오 발생기를&lt;/a&gt; VS 2010와 그 대상 플랫폼 위에서는 기본적으로 WinRT 컴파일 할 수 있으며 경우 명시 적으로 비활성화 할 필요가 &lt;code&gt;/ZW&lt;/code&gt; 또는 &lt;a href=&quot;../prop_tgt/vs_winrt_component#prop_tgt:VS_WINRT_COMPONENT&quot; id=&quot;index-0-prop_tgt:VS_WINRT_COMPONENT&quot;&gt; &lt;code&gt;VS_WINRT_COMPONENT&lt;/code&gt; 이&lt;/a&gt; 생략 (이러한 옵션 중 하나가있을 때 그것을 가능하게 반대)</target>
        </trans-unit>
        <trans-unit id="760d5c61626c9c854bc797c86a64dfe5fc4bb8b4" translate="yes" xml:space="preserve">
          <source>Information for determining when cmake needs to be re-run as a result of file changes.</source>
          <target state="translated">파일 변경의 결과로 cmake를 언제 다시 실행해야하는지 결정하기위한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="5fc8e754fcf300d133b1065bed0784d42ce7a4d8" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_config_var('SOABI')&lt;/code&gt; or computed from &lt;code&gt;distutils.sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; or &lt;code&gt;python-config --extension-suffix&lt;/code&gt;. If package &lt;code&gt;distutils.sysconfig&lt;/code&gt; is not available, &lt;code&gt;sysconfig.get_config_var('SOABI')&lt;/code&gt; or &lt;code&gt;sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; are used.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_config_var('SOABI')&lt;/code&gt; 에서 반환 하거나 &lt;code&gt;distutils.sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; 또는 &lt;code&gt;python-config --extension-suffix&lt;/code&gt; 에서 계산 된 정보 입니다. &lt;code&gt;distutils.sysconfig&lt;/code&gt; 패키지를 사용할 수없는 경우 &lt;code&gt;sysconfig.get_config_var('SOABI')&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c98bea0dbe0ebfa1577d8a25002189ef27af6542" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_config_var('SOABI')&lt;/code&gt; or computed from &lt;code&gt;distutils.sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; or &lt;code&gt;python3-config --extension-suffix&lt;/code&gt;. If package &lt;code&gt;distutils.sysconfig&lt;/code&gt; is not available, &lt;code&gt;sysconfig.get_config_var('SOABI')&lt;/code&gt; or &lt;code&gt;sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; are used.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_config_var('SOABI')&lt;/code&gt; 에서 반환 하거나 &lt;code&gt;distutils.sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; 또는 &lt;code&gt;python3-config --extension-suffix&lt;/code&gt; 에서 계산 된 정보 입니다. &lt;code&gt;distutils.sysconfig&lt;/code&gt; 패키지를 사용할 수없는 경우 &lt;code&gt;sysconfig.get_config_var('SOABI')&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_config_var('EXT_SUFFIX')&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de74defde69e029b17dda4cbca7feb0173f3da16" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)&lt;/code&gt; or else &lt;code&gt;sysconfig.get_path('purelib')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_path('purelib')&lt;/code&gt; 에서 반환 된 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="5b55814270eecdb8abe78a0c097551dd267e22cf" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)&lt;/code&gt; 의해 반환되는 정보 .</target>
        </trans-unit>
        <trans-unit id="b8b2ded9c1f5f328483adb0b15b0654063932d6e" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)&lt;/code&gt; or else &lt;code&gt;sysconfig.get_path('stdlib')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_path('stdlib')&lt;/code&gt; 에서 반환하는 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="ec0210675e260ec2ceeec1041264e99d0916a952" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=True)&lt;/code&gt; 의해 반환되는 정보 .</target>
        </trans-unit>
        <trans-unit id="0eca97ef014fff034834229f64a319997d941595" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)&lt;/code&gt; or else &lt;code&gt;sysconfig.get_path('platlib')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_path('platlib')&lt;/code&gt; 에서 반환하는 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="0f0dd0b3e60b3af524934a221efe1f3dd89e56df" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)&lt;/code&gt; 반환 한 정보 .</target>
        </trans-unit>
        <trans-unit id="603b0707558df10d9ae151eb0ea3ea980e9e48c3" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)&lt;/code&gt; or else &lt;code&gt;sysconfig.get_path('platstdlib')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)&lt;/code&gt; 또는 &lt;code&gt;sysconfig.get_path('platstdlib')&lt;/code&gt; 에서 반환하는 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="94d0466121c89b424cc3b49f263c3f205df24e16" translate="yes" xml:space="preserve">
          <source>Information returned by &lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=True)&lt;/code&gt; 의해 반환되는 정보 .</target>
        </trans-unit>
        <trans-unit id="8d38dd8d4c62303b340ed596b35089ff2d586fdf" translate="yes" xml:space="preserve">
          <source>Inheriting constructors, as defined in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm&quot;&gt;N2540&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm&quot;&gt;N2540에&lt;/a&gt; 정의 된대로 생성자를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="2f68994ca2757be8a1c7985a35c3412f228a2e19" translate="yes" xml:space="preserve">
          <source>Initial values of the CMake environment variables are those of the calling process. Values can be changed using the &lt;a href=&quot;../command/set#command:set&quot; id=&quot;index-2-command:set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/unset#command:unset&quot; id=&quot;index-2-command:unset&quot;&gt;&lt;code&gt;unset()&lt;/code&gt;&lt;/a&gt; commands. These commands only affect the running CMake process, not the system environment at large. Changed values are not written back to the calling process, and they are not seen by subsequent build or test processes.</source>
          <target state="translated">CMake 환경 변수의 초기 값은 호출 프로세스의 값입니다. &lt;a href=&quot;../command/set#command:set&quot; id=&quot;index-2-command:set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/unset#command:unset&quot; id=&quot;index-2-command:unset&quot;&gt; &lt;code&gt;unset()&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 값을 변경할 수 있습니다 . 이 명령은 시스템 환경이 아니라 실행중인 CMake 프로세스에만 영향을줍니다. 변경된 값은 호출 프로세스에 다시 기록되지 않으며 후속 빌드 또는 테스트 프로세스에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="d5c957ed1b4da2c188db25f9128530ddfec287e7" translate="yes" xml:space="preserve">
          <source>Initialize &lt;a href=&quot;../variable/cmake_cuda_architectures#variable:CMAKE_CUDA_ARCHITECTURES&quot; id=&quot;index-0-variable:CMAKE_CUDA_ARCHITECTURES&quot;&gt;&lt;code&gt;CMAKE_CUDA_ARCHITECTURES&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;CMAKE_CUDA_COMPILER_ID&lt;/code&gt; is &lt;code&gt;NVIDIA&lt;/code&gt;. Raise an error if &lt;a href=&quot;../prop_tgt/cuda_architectures#prop_tgt:CUDA_ARCHITECTURES&quot; id=&quot;index-0-prop_tgt:CUDA_ARCHITECTURES&quot;&gt;&lt;code&gt;CUDA_ARCHITECTURES&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">초기화 &lt;a href=&quot;../variable/cmake_cuda_architectures#variable:CMAKE_CUDA_ARCHITECTURES&quot; id=&quot;index-0-variable:CMAKE_CUDA_ARCHITECTURES&quot;&gt; &lt;code&gt;CMAKE_CUDA_ARCHITECTURES&lt;/code&gt; 을&lt;/a&gt; 때 &lt;code&gt;CMAKE_CUDA_COMPILER_ID&lt;/code&gt; 가 있다 &lt;code&gt;NVIDIA&lt;/code&gt; . &lt;a href=&quot;../prop_tgt/cuda_architectures#prop_tgt:CUDA_ARCHITECTURES&quot; id=&quot;index-0-prop_tgt:CUDA_ARCHITECTURES&quot;&gt; &lt;code&gt;CUDA_ARCHITECTURES&lt;/code&gt; &lt;/a&gt; 가 비어 있으면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b95827639c34d5f28c6e463ed65d7dfce549b6de" translate="yes" xml:space="preserve">
          <source>Initialized lambda captures, as defined in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3648.html&quot;&gt;N3648&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3648.html&quot;&gt;N3648에&lt;/a&gt; 정의 된 초기화 된 람다 캡처 .</target>
        </trans-unit>
        <trans-unit id="849e7314588f2d49278daaac5abcc629587dc45f" translate="yes" xml:space="preserve">
          <source>Initializer lists, as defined in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm&quot;&gt;N2672&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm&quot;&gt;N2672에&lt;/a&gt; 정의 된 초 기자 목록 .</target>
        </trans-unit>
        <trans-unit id="6669706f8bb76450838b5b6b1a1c0bb0fcdf78a7" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;a href=&quot;../prop_tgt/optimize_dependencies#prop_tgt:OPTIMIZE_DEPENDENCIES&quot; id=&quot;index-0-prop_tgt:OPTIMIZE_DEPENDENCIES&quot;&gt;&lt;code&gt;OPTIMIZE_DEPENDENCIES&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/optimize_dependencies#prop_tgt:OPTIMIZE_DEPENDENCIES&quot; id=&quot;index-0-prop_tgt:OPTIMIZE_DEPENDENCIES&quot;&gt; &lt;code&gt;OPTIMIZE_DEPENDENCIES&lt;/code&gt; &lt;/a&gt; 대상 속성을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="30f852a8ae044f3a8c3c7771c3520a272f1bd81b" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;a href=&quot;../variable/ctest_use_launchers#variable:CTEST_USE_LAUNCHERS&quot; id=&quot;index-0-variable:CTEST_USE_LAUNCHERS&quot;&gt;&lt;code&gt;CTEST_USE_LAUNCHERS&lt;/code&gt;&lt;/a&gt; variable if not already defined.</source>
          <target state="translated">&lt;a href=&quot;../variable/ctest_use_launchers#variable:CTEST_USE_LAUNCHERS&quot; id=&quot;index-0-variable:CTEST_USE_LAUNCHERS&quot;&gt; &lt;code&gt;CTEST_USE_LAUNCHERS&lt;/code&gt; &lt;/a&gt; 변수를 아직 정의하지 않은 경우 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="45f75b8832779ed143501551e9ea2afefc8dbbe1" translate="yes" xml:space="preserve">
          <source>Inline namespaces, as defined in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm&quot;&gt;N2535&lt;/a&gt;.</source>
          <target state="translated">에 정의 된 인라인 네임 스페이스, &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2535.htm&quot;&gt;N2535&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caf92b611ce949cc2a2e44c5dabf3c80f7f98b9b" translate="yes" xml:space="preserve">
          <source>Input Variables</source>
          <target state="translated">입력 변수</target>
        </trans-unit>
        <trans-unit id="5e84aa4a269e4bae126e915d20feb1a8aa793a39" translate="yes" xml:space="preserve">
          <source>Input directories must have &lt;code&gt;CMakeLists.txt&lt;/code&gt;.</source>
          <target state="translated">입력 디렉토리에는 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f7cbe0d5e7bcd879cdab597264f976adc8005cc6" translate="yes" xml:space="preserve">
          <source>Insert elements to the 0th position in the list.</source>
          <target state="translated">목록에서 0 번째 위치에 요소를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="d42bab8a19b97389255c83488cd69f0338c55190" translate="yes" xml:space="preserve">
          <source>Inserts elements to the list to the specified location.</source>
          <target state="translated">지정된 위치에 목록에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7dfff46393a5e398a05480e1aa0eac374d594ebe" translate="yes" xml:space="preserve">
          <source>Inside brackets, specifies an inclusive range between characters on either side e.g. &lt;code&gt;[a-f]&lt;/code&gt; is &lt;code&gt;[abcdef]&lt;/code&gt; To match a literal &lt;code&gt;-&lt;/code&gt; using brackets, make it the first or the last character e.g. &lt;code&gt;[+*/-]&lt;/code&gt; matches basic mathematical operators.</source>
          <target state="translated">괄호 안에는 양쪽 예에 문자 사이의 포괄적 인 범위를 지정 &lt;code&gt;[a-f]&lt;/code&gt; 입니다 &lt;code&gt;[abcdef]&lt;/code&gt; 리터럴에 맞게 &lt;code&gt;-&lt;/code&gt; 브라켓을 사용하여, 그것을 예를 들어 첫 번째 또는 마지막 문자를 만들 &lt;code&gt;[+*/-]&lt;/code&gt; 기본 수학 연산자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6d04fe1aecb2f3d900223eb374b809b8bfc56494" translate="yes" xml:space="preserve">
          <source>Install (or copy) a resolved &amp;lt;plugin&amp;gt; to the default plugins directory (or &amp;lt;plugins_dir&amp;gt;) relative to &amp;lt;executable&amp;gt; and store the result in &amp;lt;installed_plugin_path_var&amp;gt;.</source>
          <target state="translated">해결 된 &amp;lt;plugin&amp;gt;을 &amp;lt;executable&amp;gt;을 기준으로 기본 플러그인 디렉토리 (또는 &amp;lt;plugins_dir&amp;gt;)에 설치 (또는 복사)하고 결과를 &amp;lt;installed_plugin_path_var&amp;gt;에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="865fe61d1b71e2d3a82dc85e60543ea718fd5217" translate="yes" xml:space="preserve">
          <source>Install (or copy) an unresolved &amp;lt;plugin&amp;gt; to the default plugins directory (or &amp;lt;plugins_dir&amp;gt;) relative to &amp;lt;executable&amp;gt; and store the result in &amp;lt;installed_plugin_path_var&amp;gt;. See documentation of INSTALL_QT4_PLUGIN_PATH.</source>
          <target state="translated">&amp;lt;실행 가능&amp;gt;을 기준으로 해결되지 않은 &amp;lt;plugin&amp;gt;을 기본 플러그인 디렉토리 (또는 &amp;lt;plugins_dir&amp;gt;)에 설치 (또는 복사)하고 결과를 &amp;lt;installed_plugin_path_var&amp;gt;에 저장하십시오. INSTALL_QT4_PLUGIN_PATH의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5e8a07ae23c93c28f19cc38c003a2bfb6a173c9" translate="yes" xml:space="preserve">
          <source>Install Rules</source>
          <target state="translated">설치 규칙</target>
        </trans-unit>
        <trans-unit id="596143eadb996007842f1892d637595afa56ce76" translate="yes" xml:space="preserve">
          <source>Install a Project</source>
          <target state="translated">프로젝트 설치</target>
        </trans-unit>
        <trans-unit id="aac3689fb44199d78ca8d02df0296ca8c199e827" translate="yes" xml:space="preserve">
          <source>Install directory for running cmake.</source>
          <target state="translated">cmake를 실행하기위한 디렉토리를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b756da7345778dc6650d2db91fa7ae91c0eb0a29" translate="yes" xml:space="preserve">
          <source>Install directory used by &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 사용하는 설치 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="a820410182ac3e9c6773d2380fc0c94ffd9b2cdc" translate="yes" xml:space="preserve">
          <source>Install rules from &lt;a href=&quot;../command/add_subdirectory#command:add_subdirectory&quot; id=&quot;index-0-command:add_subdirectory&quot;&gt;&lt;code&gt;add_subdirectory()&lt;/code&gt;&lt;/a&gt; calls are interleaved with those in caller.</source>
          <target state="translated">&lt;a href=&quot;../command/add_subdirectory#command:add_subdirectory&quot; id=&quot;index-0-command:add_subdirectory&quot;&gt; &lt;code&gt;add_subdirectory()&lt;/code&gt; &lt;/a&gt; 호출의 설치 규칙은 호출자의 규칙 과 인터리브됩니다.</target>
        </trans-unit>
        <trans-unit id="4fd128bc830c6c1092ba7637218ba80011d4a8b7" translate="yes" xml:space="preserve">
          <source>Install the generated configuration files with the &lt;a href=&quot;../../command/install#command:install&quot; id=&quot;index-7-command:install&quot;&gt;&lt;code&gt;INSTALL(files)&lt;/code&gt;&lt;/a&gt; command. Both &lt;code&gt;MathFunctionsConfigVersion.cmake&lt;/code&gt; and &lt;code&gt;MathFunctionsConfig.cmake&lt;/code&gt; are installed to the same location, completing the package.</source>
          <target state="translated">&lt;a href=&quot;../../command/install#command:install&quot; id=&quot;index-7-command:install&quot;&gt; &lt;code&gt;INSTALL(files)&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 생성 된 구성 파일을 설치합니다 . &lt;code&gt;MathFunctionsConfigVersion.cmake&lt;/code&gt; 와 &lt;code&gt;MathFunctionsConfig.cmake&lt;/code&gt; 는 모두 동일한 위치에 설치되어 패키지를 완성합니다.</target>
        </trans-unit>
        <trans-unit id="8358a66612875f90b48c5f31167ce547a99912dc" translate="yes" xml:space="preserve">
          <source>Install:</source>
          <target state="translated">Install:</target>
        </trans-unit>
        <trans-unit id="6cb6095d1a6213a7ae4a94779224aba3bbd27673" translate="yes" xml:space="preserve">
          <source>InstallRequiredSystemLibraries</source>
          <target state="translated">InstallRequiredSystemLibraries</target>
        </trans-unit>
        <trans-unit id="6cb09209a2f7f85811ae7f99854a0dbbdd77638c" translate="yes" xml:space="preserve">
          <source>Installation directory on the target system. This may be used by some CPack generators like NSIS to create an installation directory e.g., &amp;ldquo;CMake 2.5&amp;rdquo; below the installation prefix. All installed elements will be put inside this directory.</source>
          <target state="translated">대상 시스템의 설치 디렉토리 이것은 NSIS와 같은 일부 CPack 생성기에서 설치 접두사 아래에 &quot;CMake 2.5&quot;와 같은 설치 디렉토리를 만드는 데 사용할 수 있습니다. 설치된 모든 요소가이 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="832dcff63893e05fe5f4d002e43fbd31b78d2224" translate="yes" xml:space="preserve">
          <source>Installation of directories may be controlled with fine granularity using the &lt;code&gt;PATTERN&lt;/code&gt; or &lt;code&gt;REGEX&lt;/code&gt; options. These &amp;ldquo;match&amp;rdquo; options specify a globbing pattern or regular expression to match directories or files encountered within input directories. They may be used to apply certain options (see below) to a subset of the files and directories encountered. The full path to each input file or directory (with forward slashes) is matched against the expression. A &lt;code&gt;PATTERN&lt;/code&gt; will match only complete file names: the portion of the full path matching the pattern must occur at the end of the file name and be preceded by a slash. A &lt;code&gt;REGEX&lt;/code&gt; will match any portion of the full path but it may use &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to simulate the &lt;code&gt;PATTERN&lt;/code&gt; behavior. By default all files and directories are installed whether or not they are matched. The &lt;code&gt;FILES_MATCHING&lt;/code&gt; option may be given before the first match option to disable installation of files (but not directories) not matched by any expression. For example, the code</source>
          <target state="translated">&lt;code&gt;PATTERN&lt;/code&gt; 또는 &lt;code&gt;REGEX&lt;/code&gt; 옵션을 사용하여 디렉토리의 설치를 세밀하게 제어 할 수 있습니다. 이러한 &quot;일치&quot;옵션은 입력 디렉토리에서 발견 된 디렉토리 또는 파일과 일치하도록 글 로빙 패턴 또는 정규식을 지정합니다. 특정 옵션 (아래 참조)을 발견 된 파일 및 디렉토리의 서브 세트에 적용하는 데 사용될 수 있습니다. 각 입력 파일 또는 디렉토리의 전체 경로 (슬래시 포함)는 표현식과 일치합니다. &lt;code&gt;PATTERN&lt;/code&gt; 단지 전체 파일 이름과 일치합니다 : 전체 경로 매칭의 부분은 패턴은 파일 이름의 끝에서 발생해야하며, 슬래시가 선행 될 수있다. &lt;code&gt;REGEX&lt;/code&gt; 는 전체 경로의 어떤 부분을 일치하지만 사용할 수 있습니다 &lt;code&gt;/&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; &lt;code&gt;PATTERN&lt;/code&gt; 동작 을 시뮬레이션합니다 . 기본적으로 모든 파일과 디렉토리는 일치하는지 여부에 관계없이 설치됩니다. &lt;code&gt;FILES_MATCHING&lt;/code&gt; 의 옵션은 어떤 식으로 일치하지 않는 파일 (그러나 디렉토리)의 비활성화 설치에 대한 첫 번째 일치 옵션 전에 제공 할 수있다. 예를 들어, 코드</target>
        </trans-unit>
        <trans-unit id="1069ad6672b23cddf617074211b784be96073800" translate="yes" xml:space="preserve">
          <source>Installation prefix to be placed in the &lt;code&gt;&amp;lt;INSTALL_DIR&amp;gt;&lt;/code&gt; placeholder. This does not actually configure the external project to install to the given prefix. That must be done by passing appropriate arguments to the external project configuration step, e.g. using &lt;code&gt;&amp;lt;INSTALL_DIR&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;INSTALL_DIR&amp;gt;&lt;/code&gt; 플레이스 홀더에 배치 할 설치 접 두부 . 이것은 실제로 지정된 접두사에 설치하도록 외부 프로젝트를 구성하지 않습니다. &lt;code&gt;&amp;lt;INSTALL_DIR&amp;gt;&lt;/code&gt; 과 같은 적절한 인수를 외부 프로젝트 구성 단계에 전달하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c427a6f0cc8307cb555c1e7e29b1e1b136d8bf9d" translate="yes" xml:space="preserve">
          <source>Installing &lt;a href=&quot;../prop_tgt/macosx_bundle#prop_tgt:MACOSX_BUNDLE&quot; id=&quot;index-0-prop_tgt:MACOSX_BUNDLE&quot;&gt;&lt;code&gt;MACOSX_BUNDLE&lt;/code&gt;&lt;/a&gt; targets requires a &lt;code&gt;BUNDLE DESTINATION&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/macosx_bundle#prop_tgt:MACOSX_BUNDLE&quot; id=&quot;index-0-prop_tgt:MACOSX_BUNDLE&quot;&gt; &lt;code&gt;MACOSX_BUNDLE&lt;/code&gt; &lt;/a&gt; 대상을 설치 하려면 &lt;code&gt;BUNDLE DESTINATION&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7dff38038b2d84d442c8d708975b6ee317cedde5" translate="yes" xml:space="preserve">
          <source>Installing Directories</source>
          <target state="translated">디렉토리 설치</target>
        </trans-unit>
        <trans-unit id="22db3b6f18653c674e1ab24c75f2000b68ec01d0" translate="yes" xml:space="preserve">
          <source>Installing Exports</source>
          <target state="translated">내보내기 설치</target>
        </trans-unit>
        <trans-unit id="ebc6e304f03866c9429746623d6855a965a61670" translate="yes" xml:space="preserve">
          <source>Installing Files</source>
          <target state="translated">파일 설치</target>
        </trans-unit>
        <trans-unit id="88b4010941f9a5bf16e9361ee05c50d34f2990ce" translate="yes" xml:space="preserve">
          <source>Installing Targets</source>
          <target state="translated">대상 설치</target>
        </trans-unit>
        <trans-unit id="d8fdf5f4ba8f191e194595405b6615f001a9f9ba" translate="yes" xml:space="preserve">
          <source>Installing a target with the &lt;a href=&quot;../prop_tgt/exclude_from_all#prop_tgt:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_tgt:EXCLUDE_FROM_ALL&quot;&gt;&lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt;&lt;/a&gt; target property set to &lt;code&gt;TRUE&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/exclude_from_all#prop_tgt:EXCLUDE_FROM_ALL&quot; id=&quot;index-0-prop_tgt:EXCLUDE_FROM_ALL&quot;&gt; &lt;code&gt;EXCLUDE_FROM_ALL&lt;/code&gt; &lt;/a&gt; 대상 특성을 &lt;code&gt;TRUE&lt;/code&gt; 로 설정 하여 대상을 설치하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aa622fa824c2a69a933ea9568d3468ada4bd1f7" translate="yes" xml:space="preserve">
          <source>Installing and Testing (Step 4)</source>
          <target state="translated">설치 및 테스트 (4 단계)</target>
        </trans-unit>
        <trans-unit id="b7f0e3286b62dec5e7e1cceb350f12eb753efe5e" translate="yes" xml:space="preserve">
          <source>Installs Qt plugins, writes a Qt configuration file (if needed) and fixes up a Qt4 executable using BundleUtilities so it is standalone and can be drag-and-drop copied to another machine as long as all of the system libraries are compatible. The executable will be fixed-up at install time. &amp;lt;component&amp;gt; is the COMPONENT used for bundle fixup and plugin installation. See documentation of FIXUP_QT4_BUNDLE.</source>
          <target state="translated">Qt 플러그인을 설치하고 Qt 구성 파일을 작성하고 (필요한 경우) BundleUtilities를 사용하여 Qt4 실행 파일을 수정하여 독립형이며 모든 시스템 라이브러리가 호환되는 한 다른 시스템으로 끌어서 놓기 복사 할 수 있습니다. 설치시 실행 파일이 수정됩니다. &amp;lt;component&amp;gt;는 번들 수정 및 플러그인 설치에 사용되는 구성 요소입니다. FIXUP_QT4_BUNDLE의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25fad22f93e4d0246fada28ede63d0522f00f458" translate="yes" xml:space="preserve">
          <source>Installs the software. This target is only automatically available if the software defines install rules with the &lt;a href=&quot;../../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command. See also &lt;a href=&quot;#software-installation&quot;&gt;Software Installation&lt;/a&gt;.</source>
          <target state="translated">소프트웨어를 설치합니다. 이 대상은 소프트웨어가 &lt;a href=&quot;../../command/install#command:install&quot; id=&quot;index-0-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 명령으로 설치 규칙을 정의하는 경우에만 자동으로 사용할 수 있습니다 . &lt;a href=&quot;#software-installation&quot;&gt;소프트웨어 설치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e70dbf4fdcde1140ee9c5500188d0b6628492ef1" translate="yes" xml:space="preserve">
          <source>Instance specification is supported only on specific generators:</source>
          <target state="translated">인스턴스 스펙은 특정 생성기에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b80840347014f11789ad500f3f8411f65a3a72" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-1-command:externalproject_add_steptargets&quot;&gt;&lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt;&lt;/a&gt;, the target could be defined along with the &lt;code&gt;foobar&lt;/code&gt; project itself:</source>
          <target state="translated">&lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-1-command:externalproject_add_steptargets&quot;&gt; &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; &lt;/a&gt; 를 호출하는 대신 &lt;code&gt;foobar&lt;/code&gt; 프로젝트 자체 와 함께 대상을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="000473f66e917a17ada3fcffacd2fa6a4549cca9" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-4-command:externalproject_add_steptargets&quot;&gt;&lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt;&lt;/a&gt;, the target could be defined along with the &lt;code&gt;foobar&lt;/code&gt; project itself:</source>
          <target state="translated">&lt;a href=&quot;#command:externalproject_add_steptargets&quot; id=&quot;index-4-command:externalproject_add_steptargets&quot;&gt; &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; &lt;/a&gt; 를 호출하는 대신 &lt;code&gt;foobar&lt;/code&gt; 프로젝트 자체 와 함께 대상을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ee5beed50aa7f5c949f694811eccac293678fcd" translate="yes" xml:space="preserve">
          <source>Instead of leaving byproducts undeclared in the rules that generate them, Ninja expects byproducts to be listed along with other outputs. Such rules may be marked with a &lt;code&gt;restat&lt;/code&gt; option that tells Ninja to check the timestamps of outputs after the rules run. This prevents byproducts whose timestamps do not change from causing their dependents to re-build unnecessarily.</source>
          <target state="translated">Ninja는 부산물을 생성하는 규칙에 따라 부산물을 선언하지 않고 다른 산출물과 함께 부산물을 나열 할 것으로 기대합니다. 이러한 규칙에는 &lt;code&gt;restat&lt;/code&gt; 옵션이 표시되어 규칙이 실행 된 후 닌자에게 출력 타임 스탬프를 확인하도록 지시합니다. 이렇게하면 타임 스탬프가 변경되지 않은 부산물이 부양 가족이 불필요하게 재건하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="230406a82b84fbf6b6a66a305878a269e3fdbf32" translate="yes" xml:space="preserve">
          <source>Instead of specifying all the desired components, it is possible to obtain a list of all defined components and then remove the unwanted ones from the list. The &lt;a href=&quot;../command/get_cmake_property#command:get_cmake_property&quot; id=&quot;index-0-command:get_cmake_property&quot;&gt;&lt;code&gt;get_cmake_property()&lt;/code&gt;&lt;/a&gt; command can be used to obtain the &lt;code&gt;COMPONENTS&lt;/code&gt; property, then the &lt;a href=&quot;../command/list#command:list&quot; id=&quot;index-0-command:list&quot;&gt;&lt;code&gt;list(REMOVE_ITEM)&lt;/code&gt;&lt;/a&gt; command can be used to remove the unwanted ones. For example, to use all defined components except &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">원하는 모든 구성 요소를 지정하는 대신 정의 된 모든 구성 요소의 목록을 확보 한 다음 목록에서 원하지 않는 구성 요소를 제거 할 수 있습니다. &lt;a href=&quot;../command/get_cmake_property#command:get_cmake_property&quot; id=&quot;index-0-command:get_cmake_property&quot;&gt; &lt;code&gt;get_cmake_property()&lt;/code&gt; &lt;/a&gt; 명령은 얻을 수 있습니다 &lt;code&gt;COMPONENTS&lt;/code&gt; 다음 특성을 &lt;a href=&quot;../command/list#command:list&quot; id=&quot;index-0-command:list&quot;&gt; &lt;code&gt;list(REMOVE_ITEM)&lt;/code&gt; &lt;/a&gt; 명령은 원치 않는 것들을 제거하는 데 사용할 수 있습니다. 예를 들어, &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 를 제외한 모든 정의 된 구성 요소를 사용하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="b376bac70729e6a82f1d4d12115dd32253300835" translate="yes" xml:space="preserve">
          <source>Integer values specifying the major, minor, and patch version components.</source>
          <target state="translated">주 버전, 부 버전 및 패치 버전 구성 요소를 지정하는 정수 값.</target>
        </trans-unit>
        <trans-unit id="f6235cc220a6a0f5ed69e7ed8bb2cf3fa7bbd333" translate="yes" xml:space="preserve">
          <source>Integrated development environments (IDEs) may want to integrate with CMake to improve the development experience for CMake users. This document lays out the recommended best practices for such integration.</source>
          <target state="translated">IDE (통합 개발 환경)는 CMake 사용자를위한 개발 환경을 개선하기 위해 CMake와 통합 할 수 있습니다. 이 문서는 이러한 통합을위한 권장 모범 사례를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a5b5fdf4152fa200d05e2ed9454335247b287409" translate="yes" xml:space="preserve">
          <source>Intel (obsolete versions of mkl 32 and 64 bit)</source>
          <target state="translated">인텔 (mkl 32 및 64 비트의 구식 버전)</target>
        </trans-unit>
        <trans-unit id="8aab861d5c0d7682098ed6cc0b28d3e64207eea9" translate="yes" xml:space="preserve">
          <source>Intel Hex and Motorola S-record files are automatically converted to binary while reading unless this option is given.</source>
          <target state="translated">이 옵션을 지정하지 않으면 Intel Hex 및 Motorola S 레코드 파일을 읽는 동안 자동으로 이진으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1046dd1ee2507bec3fa06d2feba90d631fad18f0" translate="yes" xml:space="preserve">
          <source>Intel10_32 (intel mkl v10 32 bit)</source>
          <target state="translated">Intel10_32 (Intel MKL v10 32 비트)</target>
        </trans-unit>
        <trans-unit id="9f12d73c5bed4184eef0794062f902274141f1ed" translate="yes" xml:space="preserve">
          <source>Intel10_64ilp (intel mkl v10+ 64 bit, threaded code, ilp64 model)</source>
          <target state="translated">Intel10_64ilp (Intel Mkl v10 + 64 비트, 스레드 코드, ILP64 모델)</target>
        </trans-unit>
        <trans-unit id="c831bfd3a9b791aa8fefd0f5d9b2e39a70020571" translate="yes" xml:space="preserve">
          <source>Intel10_64ilp_seq (intel mkl v10+ 64 bit, sequential code, ilp64 model)</source>
          <target state="translated">Intel10_64ilp_seq (Intel Mkl v10 + 64 비트, 순차 코드, ILP64 모델)</target>
        </trans-unit>
        <trans-unit id="e30a223469734a63fe80dce916416c48598710dc" translate="yes" xml:space="preserve">
          <source>Intel10_64lp (intel mkl v10+ 64 bit, threaded code, lp64 model)</source>
          <target state="translated">Intel10_64LP (Intel Mkl v10 + 64 비트, 스레드 코드, LP64 모델)</target>
        </trans-unit>
        <trans-unit id="6b392507898ea23f6d087d68941f2c196fb9d1de" translate="yes" xml:space="preserve">
          <source>Intel10_64lp_seq (intel mkl v10+ 64 bit, sequential code, lp64 model)</source>
          <target state="translated">Intel10_64lp_seq (Intel Mkl v10 + 64 비트, 순차 코드, LP64 모델)</target>
        </trans-unit>
        <trans-unit id="e526825f1739063c877f1259c20f98f77fe40805" translate="yes" xml:space="preserve">
          <source>Intended to indicate whether CMake is cross compiling, but note limitations discussed below.</source>
          <target state="translated">CMake가 교차 컴파일인지 여부를 나타내려고하지만 아래에 설명 된 제한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7974fe60b15bcdb097e9dc78815ab836bf32eb" translate="yes" xml:space="preserve">
          <source>Interactive Dialogs</source>
          <target state="translated">대화식 대화 상자</target>
        </trans-unit>
        <trans-unit id="4218adeeef5c22aa0d3a90281a66729d80adc82a" translate="yes" xml:space="preserve">
          <source>Interface Libraries</source>
          <target state="translated">인터페이스 라이브러리</target>
        </trans-unit>
        <trans-unit id="96e9e5192fe756d3fd41d1979d5a3b9d7309e865" translate="yes" xml:space="preserve">
          <source>Internal Variables</source>
          <target state="translated">내부 변수</target>
        </trans-unit>
        <trans-unit id="1fc89e1d3411b0608601d8cd048609ca07f356fb" translate="yes" xml:space="preserve">
          <source>Internal management property. Do not set or get.</source>
          <target state="translated">내부 관리 속성. 설정하거나 얻지 마십시오.</target>
        </trans-unit>
        <trans-unit id="850f52e8f27f6e50bae3c9bf2beb74e599d0d4d6" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-4-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-3-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt; to create each step. If any &lt;code&gt;STEP_TARGETS&lt;/code&gt; or &lt;code&gt;INDEPENDENT_STEP_TARGETS&lt;/code&gt; were specified, then &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; will also be called after &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-4-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;INDEPENDENT_STEP_TARGETS&lt;/code&gt; have the &lt;code&gt;NO_DEPENDS&lt;/code&gt; option set, whereas &lt;code&gt;STEP_TARGETS&lt;/code&gt; do not. Other than that, the two options result in &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; being called in the same way. Even if a step is not mentioned in either of those two options, &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; can still be called later to manually define a target for the step.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-4-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-3-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 각 단계를 만듭니다. 어떤 경우 &lt;code&gt;STEP_TARGETS&lt;/code&gt; 또는 &lt;code&gt;INDEPENDENT_STEP_TARGETS&lt;/code&gt; 이 지정된 후 &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; 또한 후에 호출됩니다 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-4-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;INDEPENDENT_STEP_TARGETS&lt;/code&gt; 에는 &lt;code&gt;NO_DEPENDS&lt;/code&gt; 옵션이 설정되어 있지만 &lt;code&gt;STEP_TARGETS&lt;/code&gt; 에는 없습니다. 그 외에 두 옵션을 사용하면 &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; 가 같은 방식으로 호출됩니다. 이 두 옵션 중 하나에서 단계를 언급하지 않더라도 &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; 단계의 대상을 수동으로 정의하기 위해 나중에 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca771adda222523f4686072d750597ccff48b86" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-5-command:externalproject_add&quot;&gt;&lt;code&gt;ExternalProject_Add()&lt;/code&gt;&lt;/a&gt; calls &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-1-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt; to create each step. If any &lt;code&gt;STEP_TARGETS&lt;/code&gt; were specified, then &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; will also be called after &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-2-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt;. Even if a step is not mentioned in the &lt;code&gt;STEP_TARGETS&lt;/code&gt; option, &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; can still be called later to manually define a target for the step.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;#command:externalproject_add&quot; id=&quot;index-5-command:externalproject_add&quot;&gt; &lt;code&gt;ExternalProject_Add()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-1-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 각 단계를 만듭니다. &lt;code&gt;STEP_TARGETS&lt;/code&gt; 가 지정된 경우 &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; 도 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-2-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; 이후에 호출 됩니다. &lt;code&gt;STEP_TARGETS&lt;/code&gt; 옵션 에 단계가 언급되지 않은 경우에도 나중에 &lt;code&gt;ExternalProject_Add_StepTargets()&lt;/code&gt; 를 호출하여 단계의 대상을 수동으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9208ef80044158cba16051d29c90db7c24a6ca" translate="yes" xml:space="preserve">
          <source>Internally, this macro executes &lt;a href=&quot;../command/configure_file#command:configure_file&quot; id=&quot;index-3-command:configure_file&quot;&gt;&lt;code&gt;configure_file()&lt;/code&gt;&lt;/a&gt; to create the resulting version file. Depending on the &lt;code&gt;COMPATIBILITY&lt;/code&gt;, the corresponding &lt;code&gt;BasicConfigVersion-&amp;lt;COMPATIBILITY&amp;gt;.cmake.in&lt;/code&gt; file is used. Please note that these files are internal to CMake and you should not call &lt;a href=&quot;../command/configure_file#command:configure_file&quot; id=&quot;index-4-command:configure_file&quot;&gt;&lt;code&gt;configure_file()&lt;/code&gt;&lt;/a&gt; on them yourself, but they can be used as starting point to create more sophisticted custom &lt;code&gt;ConfigVersion.cmake&lt;/code&gt; files.</source>
          <target state="translated">내부적으로이 매크로는 &lt;a href=&quot;../command/configure_file#command:configure_file&quot; id=&quot;index-3-command:configure_file&quot;&gt; &lt;code&gt;configure_file()&lt;/code&gt; &lt;/a&gt; 을 실행 하여 결과 버전 파일을 만듭니다. 온 따라 &lt;code&gt;COMPATIBILITY&lt;/code&gt; 해당 &lt;code&gt;BasicConfigVersion-&amp;lt;COMPATIBILITY&amp;gt;.cmake.in&lt;/code&gt; 파일이 사용된다. 이러한 파일은 CMake 내부 에 있으며 직접 &lt;a href=&quot;../command/configure_file#command:configure_file&quot; id=&quot;index-4-command:configure_file&quot;&gt; &lt;code&gt;configure_file()&lt;/code&gt; &lt;/a&gt; 을 호출해서는 &lt;code&gt;ConfigVersion.cmake&lt;/code&gt; 보다 정교한 사용자 지정 ConfigVersion.cmake 파일 을 만들기위한 시작 지점으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="ae30d1b78e26f95f1bd946cd3468d39046fec04e" translate="yes" xml:space="preserve">
          <source>Introduction to CMake Buildsystems</source>
          <target state="translated">CMake 빌드 시스템 소개</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="0dac934ff5f7c5ffb7e2765e757f2db836992cbf" translate="yes" xml:space="preserve">
          <source>Invoking the Buildsystem</source>
          <target state="translated">빌드 시스템 호출</target>
        </trans-unit>
        <trans-unit id="305388ace3ade1a2e164495bb37562bbc8391879" translate="yes" xml:space="preserve">
          <source>IronPython</source>
          <target state="translated">IronPython</target>
        </trans-unit>
        <trans-unit id="8457b39aa54c2fc0f5226c9fde9e321d943c29f3" translate="yes" xml:space="preserve">
          <source>Is set if and only if &lt;code&gt;backtrace(3)&lt;/code&gt; support detected.</source>
          <target state="translated">&lt;code&gt;backtrace(3)&lt;/code&gt; 지원이 감지 된 경우에만 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dba70b8a5f5aaf56c2c63b53b03b9d228c6739a" translate="yes" xml:space="preserve">
          <source>Is there a better place for us to save the &lt;code&gt;HAVE_LOG&lt;/code&gt; and &lt;code&gt;HAVE_EXP&lt;/code&gt; values other than in &lt;code&gt;TutorialConfig.h&lt;/code&gt;? Let&amp;rsquo;s try to use &lt;a href=&quot;../../command/target_compile_definitions#command:target_compile_definitions&quot; id=&quot;index-1-command:target_compile_definitions&quot;&gt;&lt;code&gt;target_compile_definitions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TutorialConfig.h&lt;/code&gt; 이외 의 &lt;code&gt;HAVE_LOG&lt;/code&gt; 및 &lt;code&gt;HAVE_EXP&lt;/code&gt; 값 을 저장하는 더 좋은 장소가 있습니까? &lt;a href=&quot;../../command/target_compile_definitions#command:target_compile_definitions&quot; id=&quot;index-1-command:target_compile_definitions&quot;&gt; &lt;code&gt;target_compile_definitions()&lt;/code&gt; &lt;/a&gt; 사용해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="7d97420912521ae43a8c57412cad497ff55be3ff" translate="yes" xml:space="preserve">
          <source>Is this just a name for a rule.</source>
          <target state="translated">이것은 규칙의 이름 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="50e120bec02a986e95253c25cc31dce8a8d930ee" translate="yes" xml:space="preserve">
          <source>Is this source file an abstract class.</source>
          <target state="translated">이 소스 파일은 추상 클래스입니까?</target>
        </trans-unit>
        <trans-unit id="7d52fe04e3dc3e30b5d5dd6d76e74199a69f5c9e" translate="yes" xml:space="preserve">
          <source>Is this source file generated as part of the build or CMake process.</source>
          <target state="translated">이 소스 파일은 빌드 또는 CMake 프로세스의 일부로 생성됩니까?</target>
        </trans-unit>
        <trans-unit id="eee219ca7cd18eaef1940959c469c63bf93fa54b" translate="yes" xml:space="preserve">
          <source>Is this source file only a header file.</source>
          <target state="translated">이 소스 파일은 헤더 파일 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c787c93360fa660548dd883c2cb18709eea4be0a" translate="yes" xml:space="preserve">
          <source>Is this source file skipped by &lt;a href=&quot;../prop_tgt/precompile_headers#prop_tgt:PRECOMPILE_HEADERS&quot; id=&quot;index-0-prop_tgt:PRECOMPILE_HEADERS&quot;&gt;&lt;code&gt;PRECOMPILE_HEADERS&lt;/code&gt;&lt;/a&gt; feature.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/precompile_headers#prop_tgt:PRECOMPILE_HEADERS&quot; id=&quot;index-0-prop_tgt:PRECOMPILE_HEADERS&quot;&gt; &lt;code&gt;PRECOMPILE_HEADERS&lt;/code&gt; &lt;/a&gt; 기능 에서이 소스 파일을 건너 뛰었습니까?</target>
        </trans-unit>
        <trans-unit id="17696532d655f9e6976f8ca06eae3eadff071011" translate="yes" xml:space="preserve">
          <source>It also adds the following macros (from &lt;code&gt;KDE3Macros.cmake&lt;/code&gt;) &lt;code&gt;SRCS_VAR&lt;/code&gt; is always the variable which contains the list of source files for your application or library.</source>
          <target state="translated">또한 다음 매크로를 추가합니다 ( &lt;code&gt;KDE3Macros.cmake&lt;/code&gt; 의 ) &lt;code&gt;SRCS_VAR&lt;/code&gt; 은 항상 응용 프로그램 또는 라이브러리의 소스 파일 목록을 포함하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="3b06ea46613cc8792c43979c89c9537e0315642f" translate="yes" xml:space="preserve">
          <source>It also determines what the name of the library is.</source>
          <target state="translated">또한 라이브러리의 이름을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ecd16171fb833a1fd98017fcad46332c2fc93ee3" translate="yes" xml:space="preserve">
          <source>It also determines what the name of the library is. This code sets the following variables:</source>
          <target state="translated">또한 라이브러리 이름이 무엇인지 결정합니다. 이 코드는 다음 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9eeea1007b693abe3db3ca67519ec2516342d790" translate="yes" xml:space="preserve">
          <source>It contains the following variables: ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE - defaults to ecos.ecc, if your eCos configuration file has a different name, adjust this variable for internal use only:</source>
          <target state="translated">ECOS_DEFINITIONS ECOSCONFIG_EXECUTABLE ECOS_CONFIG_FILE-기본값은 ecos.ecc입니다. eCos 구성 파일의 이름이 다른 경우이 변수를 내부 용으로 만 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0cac0b805c44abeff71f48d654dffb56998dd0fd" translate="yes" xml:space="preserve">
          <source>It creates custom commands in the target as necessary to make data files available for each &lt;code&gt;DATA{}&lt;/code&gt; reference previously evaluated by other functions provided by this module. Data files may be fetched from one of the URL templates specified in the &lt;code&gt;ExternalData_URL_TEMPLATES&lt;/code&gt; variable, or may be found locally in one of the paths specified in the &lt;code&gt;ExternalData_OBJECT_STORES&lt;/code&gt; variable.</source>
          <target state="translated">이 모듈에서 제공하는 다른 기능에 의해 이전에 평가 된 각 &lt;code&gt;DATA{}&lt;/code&gt; 참조 에 대해 데이터 파일을 사용할 수 있도록 필요한대로 대상에 사용자 정의 명령을 작성 합니다. 데이터 파일에 지정된 URL 템플릿 중 하나에서 인출 할 수있다 &lt;code&gt;ExternalData_URL_TEMPLATES&lt;/code&gt; 의 변수 또는에 지정된 경로 중 하나에 로컬로 찾을 수있다 &lt;code&gt;ExternalData_OBJECT_STORES&lt;/code&gt; 의 변수입니다.</target>
        </trans-unit>
        <trans-unit id="9a0c7e6681f032d6ae40114392ccd54a3d21fe22" translate="yes" xml:space="preserve">
          <source>It defines:</source>
          <target state="translated">다음을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="00833fb282230efc9619c0e63d02597a2960c061" translate="yes" xml:space="preserve">
          <source>It generates in &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; definitions of the following macros:</source>
          <target state="translated">다음 매크로의 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 정의 에서 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="3facecfa56a1cc45985dd67ebc07c173d090f4e1" translate="yes" xml:space="preserve">
          <source>It is also possible to define a &lt;code&gt;GLOBAL&lt;/code&gt;&lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-10-prop_tgt:IMPORTED&quot;&gt;&lt;code&gt;IMPORTED&lt;/code&gt;&lt;/a&gt; target which is accessible globally in the buildsystem.</source>
          <target state="translated">빌드 시스템에서 전역 적으로 액세스 할 수 있는 &lt;code&gt;GLOBAL&lt;/code&gt; &lt;a href=&quot;../prop_tgt/imported#prop_tgt:IMPORTED&quot; id=&quot;index-10-prop_tgt:IMPORTED&quot;&gt; &lt;code&gt;IMPORTED&lt;/code&gt; &lt;/a&gt; 대상 을 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f61e27ce463c04079ae5721cc47220d686ab2807" translate="yes" xml:space="preserve">
          <source>It is also used as the default value for the &lt;a href=&quot;../prop_tgt/crosscompiling_emulator#prop_tgt:CROSSCOMPILING_EMULATOR&quot; id=&quot;index-0-prop_tgt:CROSSCOMPILING_EMULATOR&quot;&gt;&lt;code&gt;CROSSCOMPILING_EMULATOR&lt;/code&gt;&lt;/a&gt; target property of executables.</source>
          <target state="translated">실행 파일 의 &lt;a href=&quot;../prop_tgt/crosscompiling_emulator#prop_tgt:CROSSCOMPILING_EMULATOR&quot; id=&quot;index-0-prop_tgt:CROSSCOMPILING_EMULATOR&quot;&gt; &lt;code&gt;CROSSCOMPILING_EMULATOR&lt;/code&gt; &lt;/a&gt; 대상 속성에 대한 기본값으로도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e537d932e0bcacf8a085d48e9c860b9972b2763" translate="yes" xml:space="preserve">
          <source>It is an error to not put a closing brace at the end of a macro name. For example, &lt;code&gt;${sourceDir&lt;/code&gt; is invalid. A dollar sign (&lt;code&gt;$&lt;/code&gt;) followed by anything other than a left curly brace (&lt;code&gt;{&lt;/code&gt;) with a possible namespace is interpreted as a literal dollar sign.</source>
          <target state="translated">매크로 이름 끝에 닫는 중괄호를 넣지 않는 것은 오류입니다. 예를 들어, &lt;code&gt;${sourceDir&lt;/code&gt; 은 유효하지 않습니다. 가능한 네임 스페이스가 있는 왼쪽 중괄호 ( &lt;code&gt;{&lt;/code&gt; ) 이외의 다른 항목이 뒤에 오는 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ) 는 리터럴 달러 기호로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ed100d5a0d2b0f442750f96c3b4307d5d9521983" translate="yes" xml:space="preserve">
          <source>It is designed to be used in a &lt;a href=&quot;../manual/cmake-packages.7#config-file-packages&quot;&gt;Package Configuration File&lt;/a&gt; (&lt;code&gt;&amp;lt;PackageName&amp;gt;Config.cmake&lt;/code&gt;). &lt;code&gt;find_dependency&lt;/code&gt; forwards the correct parameters for &lt;code&gt;QUIET&lt;/code&gt; and &lt;code&gt;REQUIRED&lt;/code&gt; which were passed to the original &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; call. Any additional arguments specified are forwarded to &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../manual/cmake-packages.7#config-file-packages&quot;&gt;패키지 구성 파일&lt;/a&gt; ( &lt;code&gt;&amp;lt;PackageName&amp;gt;Config.cmake&lt;/code&gt; ) 에서 사용하도록 설계되었습니다 . &lt;code&gt;find_dependency&lt;/code&gt; 는 원래 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 호출 로 전달 된 &lt;code&gt;QUIET&lt;/code&gt; 및 &lt;code&gt;REQUIRED&lt;/code&gt; 에 대한 올바른 매개 변수를 전달합니다 . 지정된 추가 인수는 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-2-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a44d71303ec18ea8d05dd3817e65039a5bd6c51" translate="yes" xml:space="preserve">
          <source>It is important to note that the imported targets behave differently than variables created by this module: multiple calls to &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt;&lt;code&gt;find_package(Boost)&lt;/code&gt;&lt;/a&gt; in the same directory or sub-directories with different options (e.g. static or shared) will not override the values of the targets created by the first call.</source>
          <target state="translated">가져온 대상은이 모듈에서 생성 한 변수와 다르게 작동 합니다. 동일한 디렉토리 또는 다른 옵션 (예 : 정적 또는 공유)을 가진 하위 디렉토리에서 &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-1-command:find_package&quot;&gt; &lt;code&gt;find_package(Boost)&lt;/code&gt; &lt;/a&gt; 를 여러 번 호출 해도 대상의 값이 재정의되지 않습니다. 첫 번째 통화에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8582d72a73c33920546dcd125733b9840186c3c3" translate="yes" xml:space="preserve">
          <source>It is initialized by &lt;a href=&quot;../manual/ctest.1#manual:ctest(1)&quot; id=&quot;index-0-manual:ctest(1)&quot;&gt;&lt;code&gt;ctest(1)&lt;/code&gt;&lt;/a&gt;, but may be edited in a &lt;code&gt;CTestCustom&lt;/code&gt; file. See &lt;a href=&quot;../command/ctest_read_custom_files#command:ctest_read_custom_files&quot; id=&quot;index-0-command:ctest_read_custom_files&quot;&gt;&lt;code&gt;ctest_read_custom_files()&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;../manual/ctest.1#manual:ctest(1)&quot; id=&quot;index-0-manual:ctest(1)&quot;&gt; &lt;code&gt;ctest(1)&lt;/code&gt; &lt;/a&gt; 의해 초기화 되지만 &lt;code&gt;CTestCustom&lt;/code&gt; 파일 에서 편집 될 수 있습니다 . &lt;a href=&quot;../command/ctest_read_custom_files#command:ctest_read_custom_files&quot; id=&quot;index-0-command:ctest_read_custom_files&quot;&gt; &lt;code&gt;ctest_read_custom_files()&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eab1e72abeb377c054a6d0a92cd74a82859c897b" translate="yes" xml:space="preserve">
          <source>It is no longer necessary to use this module or call &lt;code&gt;find_package(CUDA)&lt;/code&gt; for compiling CUDA code. Instead, list &lt;code&gt;CUDA&lt;/code&gt; among the languages named in the top-level call to the &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command, or call the &lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt;&lt;code&gt;enable_language()&lt;/code&gt;&lt;/a&gt; command with &lt;code&gt;CUDA&lt;/code&gt;. Then one can add CUDA (&lt;code&gt;.cu&lt;/code&gt;) sources to programs directly in calls to &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt;&lt;code&gt;add_executable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상이 모듈을 사용하거나 CUDA 코드를 컴파일하기 위해 &lt;code&gt;find_package(CUDA)&lt;/code&gt; 를 호출 할 필요가 없습니다 . 대신 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령 에 대한 최상위 호출에서 명명 된 언어 중에서 &lt;code&gt;CUDA&lt;/code&gt; 를 나열 하거나 &lt;code&gt;CUDA&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt; &lt;code&gt;enable_language()&lt;/code&gt; &lt;/a&gt; 명령을 호출합니다 . 그런 다음 &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt; &lt;code&gt;add_executable()&lt;/code&gt; &lt;/a&gt; 에 대한 호출에서 CUDA ( &lt;code&gt;.cu&lt;/code&gt; ) 소스를 프로그램에 직접 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f9bfe26c754a01e84c38006481e9df97af47a8" translate="yes" xml:space="preserve">
          <source>It is no longer necessary to use this module or call &lt;code&gt;find_package(CUDA)&lt;/code&gt;. Instead, list &lt;code&gt;CUDA&lt;/code&gt; among the languages named in the top-level call to the &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command, or call the &lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt;&lt;code&gt;enable_language()&lt;/code&gt;&lt;/a&gt; command with &lt;code&gt;CUDA&lt;/code&gt;. Then one can add CUDA (&lt;code&gt;.cu&lt;/code&gt;) sources to programs directly in calls to &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt;&lt;code&gt;add_executable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상이 모듈을 사용하거나 &lt;code&gt;find_package(CUDA)&lt;/code&gt; 호출 할 필요가 없습니다 . 대신 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령 에 대한 최상위 호출에서 명명 된 언어 중에서 &lt;code&gt;CUDA&lt;/code&gt; 를 나열 하거나 &lt;code&gt;CUDA&lt;/code&gt; 로&lt;a href=&quot;../command/enable_language#command:enable_language&quot; id=&quot;index-0-command:enable_language&quot;&gt; &lt;code&gt;enable_language()&lt;/code&gt; &lt;/a&gt; 명령을 호출하십시오 . 그런 다음 하나는 CUDA (추가 할 수 있습니다 &lt;code&gt;.cu&lt;/code&gt; 에 직접 전화에서 프로그램) 소스를 &lt;a href=&quot;../command/add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt; &lt;code&gt;add_executable()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02d8908871b9ad057bd8f1c249def26296666e73" translate="yes" xml:space="preserve">
          <source>It is not allowed to create an &lt;code&gt;ALIAS&lt;/code&gt; target with the same name as an another target.</source>
          <target state="translated">다른 대상과 이름이 같은 &lt;code&gt;ALIAS&lt;/code&gt; 대상 을 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0ab850b9d62b1442d2c89db7a8be31d527ba579f" translate="yes" xml:space="preserve">
          <source>It is possible for the cache entry to exist prior to the call but have no type set if it was created on the &lt;a href=&quot;../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt;&lt;code&gt;cmake(1)&lt;/code&gt;&lt;/a&gt; command line by a user through the &lt;code&gt;-D&amp;lt;var&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; option without specifying a type. In this case the &lt;code&gt;set&lt;/code&gt; command will add the type. Furthermore, if the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is &lt;code&gt;PATH&lt;/code&gt; or &lt;code&gt;FILEPATH&lt;/code&gt; and the &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; provided on the command line is a relative path, then the &lt;code&gt;set&lt;/code&gt; command will treat the path as relative to the current working directory and convert it to an absolute path.</source>
          <target state="translated">호출 전에 캐시 항목이 존재할 수 있지만 유형 을 지정하지 않고 &lt;code&gt;-D&amp;lt;var&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 옵션을 통해 &lt;a href=&quot;../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt; &lt;code&gt;cmake(1)&lt;/code&gt; &lt;/a&gt; 명령 행에서 사용자 가 작성한 경우 유형이 설정되지 않았습니다 . 이 경우 &lt;code&gt;set&lt;/code&gt; 명령은 유형을 추가합니다. 또한 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 이 &lt;code&gt;PATH&lt;/code&gt; 또는 &lt;code&gt;FILEPATH&lt;/code&gt; 이고 명령 행에 제공된 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 가 상대 경로 인 경우 &lt;code&gt;set&lt;/code&gt; 명령은 경로를 현재 작업 디렉토리에 상대적인 것으로 취급하여 절대 경로로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="99bc959bced8be60dc336dd2e09f758d9c63056b" translate="yes" xml:space="preserve">
          <source>It is possible to create a suitable package configuration file and package version file to define a package for the build tree which may be used without installation. Consumers of the build tree can simply ensure that the &lt;a href=&quot;../../variable/cmake_prefix_path#variable:CMAKE_PREFIX_PATH&quot; id=&quot;index-0-variable:CMAKE_PREFIX_PATH&quot;&gt;&lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt;&lt;/a&gt; contains the build directory, or set the &lt;code&gt;MathFunctions_DIR&lt;/code&gt; to &lt;code&gt;&amp;lt;build_dir&amp;gt;/MathFunctions&lt;/code&gt; in the cache.</source>
          <target state="translated">적절한 패키지 구성 파일과 패키지 버전 파일을 생성하여 설치없이 사용할 수있는 빌드 트리 용 패키지를 정의 할 수 있습니다. 빌드 트리의 소비자는 &lt;a href=&quot;../../variable/cmake_prefix_path#variable:CMAKE_PREFIX_PATH&quot; id=&quot;index-0-variable:CMAKE_PREFIX_PATH&quot;&gt; &lt;code&gt;CMAKE_PREFIX_PATH&lt;/code&gt; &lt;/a&gt; 에 빌드 디렉터리가 포함되어 있는지 확인 하거나 &lt;code&gt;MathFunctions_DIR&lt;/code&gt; 을 캐시에서 &lt;code&gt;&amp;lt;build_dir&amp;gt;/MathFunctions&lt;/code&gt; 로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f15215fb4d40bc6420414ce06e6cb10e611c10" translate="yes" xml:space="preserve">
          <source>It is quite common practice in CMake for modules to use some additional files, such as templates to be copied in after substituting CMake variables. In such cases, a function needs to know where to locate those files in a way that doesn&amp;rsquo;t depend on where the function is called. Without &lt;code&gt;CMAKE_CURRENT_FUNCTION_LIST_DIR&lt;/code&gt;, the code to do that would typically use the following pattern:</source>
          <target state="translated">모듈이 CMake 변수를 대체 한 후 복사 할 템플릿과 같은 일부 추가 파일을 사용하는 것은 CMake에서 매우 일반적인 관행입니다. 이러한 경우 함수는 함수가 호출되는 위치에 의존하지 않는 방식으로 해당 파일을 찾을 위치를 알아야합니다. &lt;code&gt;CMAKE_CURRENT_FUNCTION_LIST_DIR&lt;/code&gt; 이 없으면이 를 수행하는 코드는 일반적으로 다음 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e10f2bd69f9ceeb2fac021dae308fc278bd8f5a" translate="yes" xml:space="preserve">
          <source>It is recommended to build in a separate directory to the source because that keeps the source directory pristine, allows for building a single source with multiple toolchains, and allows easy clearing of build artifacts by simply deleting the build directory.</source>
          <target state="translated">소스 디렉토리를 원래 상태로 유지하고 여러 도구 체인으로 단일 소스를 빌드 할 수 있으며 빌드 디렉토리를 삭제하여 빌드 아티팩트를 쉽게 지울 수 있으므로 소스에 대한 별도의 디렉토리에 빌드하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fa759d68eccaef87507d885f78e836cc680e7bf0" translate="yes" xml:space="preserve">
          <source>It is required for building the same target with multiple SDKs. A common use case is the parallel use of &lt;code&gt;iphoneos&lt;/code&gt; and &lt;code&gt;iphonesimulator&lt;/code&gt; SDKs.</source>
          <target state="translated">여러 SDK를 사용하여 동일한 대상을 빌드하는 데 필요합니다. 일반적인 사용 사례는 &lt;code&gt;iphoneos&lt;/code&gt; 및 &lt;code&gt;iphonesimulator&lt;/code&gt; SDK 의 병렬 사용입니다 .</target>
        </trans-unit>
        <trans-unit id="d45c896b45d69dccaa9f17baef72b5493f57b344" translate="yes" xml:space="preserve">
          <source>It is tempting to use this command to avoid writing the list of source files for a library or executable target. While this seems to work, there is no way for CMake to generate a build system that knows when a new source file has been added. Normally the generated build system knows when it needs to rerun CMake because the &lt;code&gt;CMakeLists.txt&lt;/code&gt; file is modified to add a new source. When the source is just added to the directory without modifying this file, one would have to manually rerun CMake to generate a build system incorporating the new file.</source>
          <target state="translated">라이브러리 또는 실행 가능 대상에 대한 소스 파일 목록을 작성하지 않으려면이 명령을 사용하려고합니다. 이것이 작동하는 것처럼 보이지만 CMake가 새 소스 파일이 언제 추가되었는지 알 수있는 빌드 시스템을 생성 할 수있는 방법이 없습니다. 일반적으로 생성 된 빌드 시스템은 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 파일이 새 소스를 추가하도록 수정 되므로 CMake를 다시 실행해야하는시기를 알고 있습니다. 이 파일을 수정하지 않고 소스를 디렉토리에 추가 한 경우 CMake를 수동으로 다시 실행하여 새 파일을 통합하는 빌드 시스템을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="140f8e24b86c41b95078fcfa1c99dfbbe372bee4" translate="yes" xml:space="preserve">
          <source>It makes no sense to use this module when &lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-0-policy:CMP0069&quot;&gt;&lt;code&gt;CMP0069&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;OLD&lt;/code&gt; so module will return error in this case. See policy &lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-1-policy:CMP0069&quot;&gt;&lt;code&gt;CMP0069&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-0-policy:CMP0069&quot;&gt; &lt;code&gt;CMP0069&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;OLD&lt;/code&gt; 로 설정된 경우이 모듈을 사용하는 것은 의미가 없으므로이 경우 모듈이 오류를 반환합니다. 자세한 내용은 정책 &lt;a href=&quot;../policy/cmp0069#policy:CMP0069&quot; id=&quot;index-1-policy:CMP0069&quot;&gt; &lt;code&gt;CMP0069&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fc53c18edd98c4db973762e1a962adba056dc6c" translate="yes" xml:space="preserve">
          <source>It makes no sense to use this module when &lt;a href=&quot;../policy/cmp0083#policy:CMP0083&quot; id=&quot;index-0-policy:CMP0083&quot;&gt;&lt;code&gt;CMP0083&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;OLD&lt;/code&gt;, so the command will return an error in this case. See policy &lt;a href=&quot;../policy/cmp0083#policy:CMP0083&quot; id=&quot;index-1-policy:CMP0083&quot;&gt;&lt;code&gt;CMP0083&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;../policy/cmp0083#policy:CMP0083&quot; id=&quot;index-0-policy:CMP0083&quot;&gt; &lt;code&gt;CMP0083&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;OLD&lt;/code&gt; 로 설정된 경우이 모듈을 사용하는 것은 의미가 없으므로이 경우 명령이 오류를 리턴합니다. 자세한 내용은 정책 &lt;a href=&quot;../policy/cmp0083#policy:CMP0083&quot; id=&quot;index-1-policy:CMP0083&quot;&gt; &lt;code&gt;CMP0083&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d804edf5700e48bb6d0d12d0a06c6855d2cfc829" translate="yes" xml:space="preserve">
          <source>It may also provide a CMake package configuration file:</source>
          <target state="translated">CMake 패키지 구성 파일을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a248b134ddfc896083ee02843eb91b660d1d14b2" translate="yes" xml:space="preserve">
          <source>It may specify usage requirements such as &lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-8-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt;&lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../prop_tgt/interface_compile_definitions#prop_tgt:INTERFACE_COMPILE_DEFINITIONS&quot; id=&quot;index-3-prop_tgt:INTERFACE_COMPILE_DEFINITIONS&quot;&gt;&lt;code&gt;INTERFACE_COMPILE_DEFINITIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../prop_tgt/interface_compile_options#prop_tgt:INTERFACE_COMPILE_OPTIONS&quot; id=&quot;index-3-prop_tgt:INTERFACE_COMPILE_OPTIONS&quot;&gt;&lt;code&gt;INTERFACE_COMPILE_OPTIONS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../prop_tgt/interface_sources#prop_tgt:INTERFACE_SOURCES&quot; id=&quot;index-0-prop_tgt:INTERFACE_SOURCES&quot;&gt;&lt;code&gt;INTERFACE_SOURCES&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../prop_tgt/interface_position_independent_code#prop_tgt:INTERFACE_POSITION_INDEPENDENT_CODE&quot; id=&quot;index-3-prop_tgt:INTERFACE_POSITION_INDEPENDENT_CODE&quot;&gt;&lt;code&gt;INTERFACE_POSITION_INDEPENDENT_CODE&lt;/code&gt;&lt;/a&gt;. Only the &lt;code&gt;INTERFACE&lt;/code&gt; modes of the &lt;a href=&quot;../command/target_include_directories#command:target_include_directories&quot; id=&quot;index-4-command:target_include_directories&quot;&gt;&lt;code&gt;target_include_directories()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../command/target_compile_definitions#command:target_compile_definitions&quot; id=&quot;index-3-command:target_compile_definitions&quot;&gt;&lt;code&gt;target_compile_definitions()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../command/target_compile_options#command:target_compile_options&quot; id=&quot;index-3-command:target_compile_options&quot;&gt;&lt;code&gt;target_compile_options()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../command/target_sources#command:target_sources&quot; id=&quot;index-0-command:target_sources&quot;&gt;&lt;code&gt;target_sources()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-9-command:target_link_libraries&quot;&gt;&lt;code&gt;target_link_libraries()&lt;/code&gt;&lt;/a&gt; commands may be used with &lt;code&gt;INTERFACE&lt;/code&gt; libraries.</source>
          <target state="translated">&lt;a href=&quot;../prop_tgt/interface_include_directories#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot; id=&quot;index-8-prop_tgt:INTERFACE_INCLUDE_DIRECTORIES&quot;&gt; &lt;code&gt;INTERFACE_INCLUDE_DIRECTORIES&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../prop_tgt/interface_compile_definitions#prop_tgt:INTERFACE_COMPILE_DEFINITIONS&quot; id=&quot;index-3-prop_tgt:INTERFACE_COMPILE_DEFINITIONS&quot;&gt; &lt;code&gt;INTERFACE_COMPILE_DEFINITIONS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../prop_tgt/interface_compile_options#prop_tgt:INTERFACE_COMPILE_OPTIONS&quot; id=&quot;index-3-prop_tgt:INTERFACE_COMPILE_OPTIONS&quot;&gt; &lt;code&gt;INTERFACE_COMPILE_OPTIONS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../prop_tgt/interface_sources#prop_tgt:INTERFACE_SOURCES&quot; id=&quot;index-0-prop_tgt:INTERFACE_SOURCES&quot;&gt; &lt;code&gt;INTERFACE_SOURCES&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../prop_tgt/interface_position_independent_code#prop_tgt:INTERFACE_POSITION_INDEPENDENT_CODE&quot; id=&quot;index-3-prop_tgt:INTERFACE_POSITION_INDEPENDENT_CODE&quot;&gt; &lt;code&gt;INTERFACE_POSITION_INDEPENDENT_CODE&lt;/code&gt; &lt;/a&gt; 와 같은 사용 요구 사항을 지정할 수 있습니다 . &lt;a href=&quot;../command/target_include_directories#command:target_include_directories&quot; id=&quot;index-4-command:target_include_directories&quot;&gt; &lt;code&gt;target_include_directories()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../command/target_compile_definitions#command:target_compile_definitions&quot; id=&quot;index-3-command:target_compile_definitions&quot;&gt; &lt;code&gt;target_compile_definitions()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../command/target_compile_options#command:target_compile_options&quot; id=&quot;index-3-command:target_compile_options&quot;&gt; &lt;code&gt;target_compile_options()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../command/target_sources#command:target_sources&quot; id=&quot;index-0-command:target_sources&quot;&gt; &lt;code&gt;target_sources()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../command/target_link_libraries#command:target_link_libraries&quot; id=&quot;index-9-command:target_link_libraries&quot;&gt; &lt;code&gt;target_link_libraries()&lt;/code&gt; &lt;/a&gt; 명령 의 &lt;code&gt;INTERFACE&lt;/code&gt; 모드 만 &lt;code&gt;INTERFACE&lt;/code&gt; 라이브러리 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e95cd97050f30468877800daaa7c94d730c01f3" translate="yes" xml:space="preserve">
          <source>It might be necessary to set &lt;code&gt;CUDA_TOOLKIT_ROOT_DIR&lt;/code&gt; manually on certain platforms, or to use a CUDA runtime not installed in the default location. In newer versions of the toolkit the CUDA library is included with the graphics driver &amp;ndash; be sure that the driver version matches what is needed by the CUDA runtime version.</source>
          <target state="translated">특정 플랫폼에서 &lt;code&gt;CUDA_TOOLKIT_ROOT_DIR&lt;/code&gt; 을 수동으로 설정 하거나 기본 위치에 설치되지 않은 CUDA 런타임을 사용해야 할 수도 있습니다. 툴킷의 최신 버전에서 CUDA 라이브러리는 그래픽 드라이버에 포함되어 있습니다. 드라이버 버전이 CUDA 런타임 버전에 필요한 것과 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="131215078eb93a6beaa97e51326e25109b378dc3" translate="yes" xml:space="preserve">
          <source>It passes its arguments through &lt;code&gt;ExternalData_Expand_Arguments&lt;/code&gt; and then invokes the &lt;a href=&quot;../command/add_test#command:add_test&quot; id=&quot;index-1-command:add_test&quot;&gt;&lt;code&gt;add_test()&lt;/code&gt;&lt;/a&gt; command using the results.</source>
          <target state="translated">&lt;code&gt;ExternalData_Expand_Arguments&lt;/code&gt; 를 통해 인수를 &lt;a href=&quot;../command/add_test#command:add_test&quot; id=&quot;index-1-command:add_test&quot;&gt; &lt;code&gt;add_test()&lt;/code&gt; &lt;/a&gt; 다음 결과를 사용하여 add_test () 명령 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="46d87800053ac2805e2891d834ab3ef2c398471c" translate="yes" xml:space="preserve">
          <source>It provides the function squish_add_test() for adding a squish test to cmake using Squish &amp;gt;= 4.x:</source>
          <target state="translated">Squish&amp;gt; = 4.x를 사용하여 cmake에 squish 테스트를 추가하는 함수 squish_add_test ()를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="230f709848f654ce14f6b69a491dcb43a43111f9" translate="yes" xml:space="preserve">
          <source>It provides the function squish_v4_add_test() for adding a squish test to cmake using Squish 4.x:</source>
          <target state="translated">Squish 4.x를 사용하여 cmake에 squish 테스트를 추가하기위한 squish_v4_add_test () 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="07fc27ab7696778a7f29619c34de1f0889b7341b" translate="yes" xml:space="preserve">
          <source>It replaces each &lt;code&gt;DATA{}&lt;/code&gt; reference in an argument with the full path of a real data file on disk that will exist after the &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; builds.</source>
          <target state="translated">인수의 각 &lt;code&gt;DATA{}&lt;/code&gt; 참조를 &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; 빌드 후 존재할 디스크의 실제 데이터 파일의 전체 경로로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="18a34744fe75278943e262a733b2f5d2725e4a4b" translate="yes" xml:space="preserve">
          <source>It searches a package using &lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt;&lt;code&gt;find_package()&lt;/code&gt;&lt;/a&gt; and prints the resulting flags to stdout. This can be used instead of pkg-config to find installed libraries in plain Makefile-based projects or in autoconf-based projects (via &lt;code&gt;share/aclocal/cmake.m4&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;../command/find_package#command:find_package&quot; id=&quot;index-0-command:find_package&quot;&gt; &lt;code&gt;find_package()&lt;/code&gt; &lt;/a&gt; 사용하여 패키지를 검색 하고 결과 플래그를 stdout에 인쇄합니다. pkg-config 대신 이것을 사용하여 일반 Makefile 기반 프로젝트 또는 autoconf 기반 프로젝트 ( &lt;code&gt;share/aclocal/cmake.m4&lt;/code&gt; 를 통해)에서 설치된 라이브러리를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539973ffd5ddd232e953d3fb1fd196169e0b538f" translate="yes" xml:space="preserve">
          <source>It sets &lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt; to the given compiler and the cmake internal variable &lt;code&gt;CMAKE_CXX_COMPILER_ID&lt;/code&gt; to the given compiler-id. It also bypasses the check for working compiler and basic compiler information tests.</source>
          <target state="translated">&lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt; 를 주어진 컴파일러로 설정 하고 cmake 내부 변수 &lt;code&gt;CMAKE_CXX_COMPILER_ID&lt;/code&gt; 를 주어진 compiler-id로 설정합니다. 또한 작동하는 컴파일러 검사 및 기본 컴파일러 정보 테스트를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="898027f4b3b38cafac348bbcfc4e0765bc29fb44" translate="yes" xml:space="preserve">
          <source>It sets &lt;code&gt;CMAKE_C_COMPILER&lt;/code&gt; to the given compiler and the cmake internal variable &lt;code&gt;CMAKE_C_COMPILER_ID&lt;/code&gt; to the given compiler-id. It also bypasses the check for working compiler and basic compiler information tests.</source>
          <target state="translated">&lt;code&gt;CMAKE_C_COMPILER&lt;/code&gt; 를 지정된 컴파일러로 설정 하고 cmake 내부 변수 &lt;code&gt;CMAKE_C_COMPILER_ID&lt;/code&gt; 를 지정된 compiler-id로 설정합니다. 또한 작동하는 컴파일러 검사 및 기본 컴파일러 정보 테스트를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f32c02ef20d3c51d0d4963ece4c1f452b2502478" translate="yes" xml:space="preserve">
          <source>It sets &lt;code&gt;CMAKE_Fortran_COMPILER&lt;/code&gt; to the given compiler and the cmake internal variable &lt;code&gt;CMAKE_Fortran_COMPILER_ID&lt;/code&gt; to the given compiler-id. It also bypasses the check for working compiler and basic compiler information tests.</source>
          <target state="translated">&lt;code&gt;CMAKE_Fortran_COMPILER&lt;/code&gt; 를 지정된 컴파일러로 설정 하고 cmake 내부 변수 &lt;code&gt;CMAKE_Fortran_COMPILER_ID&lt;/code&gt; 를 지정된 compiler-id로 설정합니다. 또한 작동하는 컴파일러 검사 및 기본 컴파일러 정보 테스트를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e5537b0969ab25848ac7ea3420bbfe5f95c6ba35" translate="yes" xml:space="preserve">
          <source>It sets the given &lt;code&gt;&amp;lt;cachevariable&amp;gt;&lt;/code&gt; to a command-line string as above but without the &lt;code&gt;--target&lt;/code&gt; option. The &lt;code&gt;&amp;lt;makecommand&amp;gt;&lt;/code&gt; is ignored but should be the full path to devenv, nmake, make or one of the end user build tools for legacy invocations.</source>
          <target state="translated">주어진 &lt;code&gt;&amp;lt;cachevariable&amp;gt;&lt;/code&gt; 을 위와 같이 &lt;code&gt;--target&lt;/code&gt; 옵션 없이 명령 행 문자열로 설정합니다 . &lt;code&gt;&amp;lt;makecommand&amp;gt;&lt;/code&gt; 무시하지만 devenv를, NMAKE, 메이크업 또는 기존의 호출에 대한 최종 사용자의 빌드 도구 중 하나에 대한 전체 경로를해야합니다.</target>
        </trans-unit>
        <trans-unit id="53738665baa8c1906753f38564462b3d686b704c" translate="yes" xml:space="preserve">
          <source>It should also be noted that each build step is created via a call to &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-0-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt;. See that command&amp;rsquo;s documentation for the automatic substitutions that are supported for some options.</source>
          <target state="translated">또한 각 빌드 단계는 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-0-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; 호출을 통해 생성된다는 점에 유의해야합니다 . 일부 옵션에 대해 지원되는 자동 대체에 대해서는 해당 명령의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c04322397828e2d7366a72076e53452b2be788e0" translate="yes" xml:space="preserve">
          <source>It should also be noted that each build step is created via a call to &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-2-command:externalproject_add_step&quot;&gt;&lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt;&lt;/a&gt;. See that command&amp;rsquo;s documentation for the automatic substitutions that are supported for some options.</source>
          <target state="translated">또한 각 빌드 단계는 &lt;a href=&quot;#command:externalproject_add_step&quot; id=&quot;index-2-command:externalproject_add_step&quot;&gt; &lt;code&gt;ExternalProject_Add_Step()&lt;/code&gt; &lt;/a&gt; 대한 호출을 통해 작성됩니다 . 일부 옵션에서 지원되는 자동 대체에 대해서는 해당 명령 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f9523253343e8f7e896301d6304293061bb8661" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;a href=&quot;macho_current_version#prop_tgt:MACHO_CURRENT_VERSION&quot; id=&quot;index-1-prop_tgt:MACHO_CURRENT_VERSION&quot;&gt;&lt;code&gt;MACHO_CURRENT_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;MACHO_COMPATIBILITY_VERSION&lt;/code&gt; properties do not affect the file names or version-related symlinks that CMake generates for the library. The &lt;a href=&quot;version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt;&lt;code&gt;SOVERSION&lt;/code&gt;&lt;/a&gt; target properties still control the file and symlink names. The &lt;code&gt;install_name&lt;/code&gt; is also still controlled by &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-1-prop_tgt:SOVERSION&quot;&gt;&lt;code&gt;SOVERSION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주목해야한다 &lt;a href=&quot;macho_current_version#prop_tgt:MACHO_CURRENT_VERSION&quot; id=&quot;index-1-prop_tgt:MACHO_CURRENT_VERSION&quot;&gt; &lt;code&gt;MACHO_CURRENT_VERSION&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;MACHO_COMPATIBILITY_VERSION&lt;/code&gt; 속성은 파일 이름 또는 CMake는 라이브러리 생성하는 버전 관련 심볼릭 링크에 영향을 미치지 않습니다. &lt;a href=&quot;version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt; &lt;code&gt;SOVERSION&lt;/code&gt; 의&lt;/a&gt; 대상 속성은 여전히 파일과 심볼릭 링크 이름을 제어 할 수 있습니다. &lt;code&gt;install_name&lt;/code&gt; 는 또한 여전히 의해 제어됩니다 &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-1-prop_tgt:SOVERSION&quot;&gt; &lt;code&gt;SOVERSION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ccad6183876e21c33ad3c27a0d504aa8da063c2" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;code&gt;MACHO_CURRENT_VERSION&lt;/code&gt; and &lt;a href=&quot;macho_compatibility_version#prop_tgt:MACHO_COMPATIBILITY_VERSION&quot; id=&quot;index-1-prop_tgt:MACHO_COMPATIBILITY_VERSION&quot;&gt;&lt;code&gt;MACHO_COMPATIBILITY_VERSION&lt;/code&gt;&lt;/a&gt; properties do not affect the file names or version-related symlinks that CMake generates for the library. The &lt;a href=&quot;version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt;&lt;code&gt;SOVERSION&lt;/code&gt;&lt;/a&gt; target properties still control the file and symlink names. The &lt;code&gt;install_name&lt;/code&gt; is also still controlled by &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-1-prop_tgt:SOVERSION&quot;&gt;&lt;code&gt;SOVERSION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주목해야한다 &lt;code&gt;MACHO_CURRENT_VERSION&lt;/code&gt; 및 &lt;a href=&quot;macho_compatibility_version#prop_tgt:MACHO_COMPATIBILITY_VERSION&quot; id=&quot;index-1-prop_tgt:MACHO_COMPATIBILITY_VERSION&quot;&gt; &lt;code&gt;MACHO_COMPATIBILITY_VERSION&lt;/code&gt; &lt;/a&gt; 속성은 파일 이름 또는 CMake는 라이브러리 생성하는 버전 관련 심볼릭 링크에 영향을 미치지 않습니다. &lt;a href=&quot;version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt; &lt;code&gt;SOVERSION&lt;/code&gt; 의&lt;/a&gt; 대상 속성은 여전히 파일과 심볼릭 링크 이름을 제어 할 수 있습니다. &lt;code&gt;install_name&lt;/code&gt; 는 또한 여전히 의해 제어됩니다 &lt;a href=&quot;soversion#prop_tgt:SOVERSION&quot; id=&quot;index-1-prop_tgt:SOVERSION&quot;&gt; &lt;code&gt;SOVERSION&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24adba4122cc7565787fe3aca68e595840687414" translate="yes" xml:space="preserve">
          <source>It tests whether a simple test executable using Fortran and C (and C++ when the CXX option is given) compiles and links successfully. The result is stored in the cache entry &lt;code&gt;FortranCInterface_VERIFIED_C&lt;/code&gt; (or &lt;code&gt;FortranCInterface_VERIFIED_CXX&lt;/code&gt; if &lt;code&gt;CXX&lt;/code&gt; is given) as a boolean. If the check fails and &lt;code&gt;QUIET&lt;/code&gt; is not given the function terminates with a fatal error message describing the problem. The purpose of this check is to stop a build early for incompatible compiler combinations. The test is built in the &lt;code&gt;Release&lt;/code&gt; configuration.</source>
          <target state="translated">Fortran 및 C (및 CXX 옵션이 제공된 경우 C ++)를 사용하여 간단한 테스트 실행 파일이 성공적으로 컴파일 및 링크되는지 테스트합니다. 결과는 캐시 항목 &lt;code&gt;FortranCInterface_VERIFIED_C&lt;/code&gt; (또는 &lt;code&gt;CXX&lt;/code&gt; 가 제공된 경우 &lt;code&gt;FortranCInterface_VERIFIED_CXX&lt;/code&gt; )에 부울로 저장됩니다. 점검에 실패하고 &lt;code&gt;QUIET&lt;/code&gt; 이 제공되지 않으면 함수는 문제점을 설명하는 치명적인 오류 메시지와 함께 종료됩니다. 이 검사의 목적은 호환되지 않는 컴파일러 조합의 빌드를 조기에 중지하는 것입니다. 테스트는 &lt;code&gt;Release&lt;/code&gt; 구성 에서 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="85f95fc1c4b1611a1cdd3bbf0047df01fbb751cd" translate="yes" xml:space="preserve">
          <source>It uses various tools to obtain the list of required shared library files:</source>
          <target state="translated">다양한 도구를 사용하여 필요한 공유 라이브러리 파일 목록을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="540b6bc88ff3316875b57f58e3a610278e37ec1e" translate="yes" xml:space="preserve">
          <source>It will contain &amp;ldquo;supportedProtocolVersions&amp;rdquo; with an array of server protocol versions supported by the cmake server. These are JSON objects with &amp;ldquo;major&amp;rdquo; and &amp;ldquo;minor&amp;rdquo; keys containing non-negative integer values. Some versions may be marked as experimental. These will contain the &amp;ldquo;isExperimental&amp;rdquo; key set to true. Enabling these requires a special command line argument when starting the cmake server mode.</source>
          <target state="translated">cmake 서버가 지원하는 일련의 서버 프로토콜 버전과 함께&amp;ldquo;supportedProtocolVersions&amp;rdquo;를 포함합니다. 음수가 아닌 정수 값을 포함하는 &quot;major&quot;및 &quot;minor&quot;키가있는 JSON 객체입니다. 일부 버전은 실험용으로 표시 될 수 있습니다. 여기에는 &quot;isExperimental&quot;키가 true로 설정됩니다. 이를 활성화하려면 cmake 서버 모드를 시작할 때 특별한 명령 행 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49c5ecd682d4df6243e2acda8ec2f3f0693d778c" translate="yes" xml:space="preserve">
          <source>It will list the complete project structure as it is known to cmake.</source>
          <target state="translated">cmake로 알려진 전체 프로젝트 구조를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e1a8db9e81fa3f8c683b8f9ed9d330ad0f2ecde2" translate="yes" xml:space="preserve">
          <source>It will list the complete project test structure as it is known to cmake.</source>
          <target state="translated">cmake로 알려진 전체 프로젝트 테스트 구조를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6808c8204d577fa2ece3c38b251984f29a930279" translate="yes" xml:space="preserve">
          <source>It would be possible to write a abstraction &lt;code&gt;interface.h&lt;/code&gt; header containing something like:</source>
          <target state="translated">다음과 같은 내용을 포함 하는 추상화 &lt;code&gt;interface.h&lt;/code&gt; 헤더 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5964f43c9a8c6d612958a653b7feb7555a2c779e" translate="yes" xml:space="preserve">
          <source>Items containing &lt;code&gt;::&lt;/code&gt;, such as &lt;code&gt;Foo::Bar&lt;/code&gt;, are assumed to be &lt;a href=&quot;../manual/cmake-buildsystem.7#imported-targets&quot;&gt;IMPORTED&lt;/a&gt; or &lt;a href=&quot;../manual/cmake-buildsystem.7#alias-targets&quot;&gt;ALIAS&lt;/a&gt; library target names and will cause an error if no such target exists. See policy &lt;a href=&quot;../policy/cmp0028#policy:CMP0028&quot; id=&quot;index-0-policy:CMP0028&quot;&gt;&lt;code&gt;CMP0028&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Foo::Bar&lt;/code&gt; 와 같이 &lt;code&gt;::&lt;/code&gt; 를 포함하는 항목 은 &lt;a href=&quot;../manual/cmake-buildsystem.7#imported-targets&quot;&gt;IMPORTED&lt;/a&gt; 또는 &lt;a href=&quot;../manual/cmake-buildsystem.7#alias-targets&quot;&gt;ALIAS&lt;/a&gt; 라이브러리 대상 이름 으로 간주되며 해당 대상이 없으면 오류가 발생합니다. 정책 &lt;a href=&quot;../policy/cmp0028#policy:CMP0028&quot; id=&quot;index-0-policy:CMP0028&quot;&gt; &lt;code&gt;CMP0028&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b863fee645bffa04a955e22068f5052f7c8757fb" translate="yes" xml:space="preserve">
          <source>JNI enables Java code running in a Java Virtual Machine (JVM) to call and be called by native applications and libraries written in other languages such as C, C++.</source>
          <target state="translated">JNI를 사용하면 JVM (Java Virtual Machine)에서 실행되는 Java 코드가 C, C ++과 같은 다른 언어로 작성된 기본 애플리케이션 및 라이브러리에서 호출하고 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb5f1c321d5fcbed8e87d48a0ec750a1556f265" translate="yes" xml:space="preserve">
          <source>JOB_POOLS</source>
          <target state="translated">JOB_POOLS</target>
        </trans-unit>
        <trans-unit id="c715d1fef50af3b2f4b2d6bfcc05ac7e0727b71f" translate="yes" xml:space="preserve">
          <source>JOB_POOL_COMPILE</source>
          <target state="translated">JOB_POOL_COMPILE</target>
        </trans-unit>
        <trans-unit id="a96b3b402f9a3cb22873cb000e7be4f77fc3bc6e" translate="yes" xml:space="preserve">
          <source>JOB_POOL_LINK</source>
          <target state="translated">JOB_POOL_LINK</target>
        </trans-unit>
        <trans-unit id="3919978d27d1d3d6911b704b0fd3db02845a7d9c" translate="yes" xml:space="preserve">
          <source>JOB_POOL_PRECOMPILE_HEADER</source>
          <target state="translated">JOB_POOL_PRECOMPILE_HEADER</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="f3a712a9c3a32dd65f4a99d1dec5512045d746da" translate="yes" xml:space="preserve">
          <source>JSON object representing backtrace information with the following members:</source>
          <target state="translated">다음 멤버로 역 추적 정보를 나타내는 JSON 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="945de2ab564ff9ae4f94af16837480cf4bc991b9" translate="yes" xml:space="preserve">
          <source>JSON trace format:</source>
          <target state="translated">JSON 추적 형식 :</target>
        </trans-unit>
        <trans-unit id="a26e63e0dd630bf0aa29409ebb2007f8ed0989a9" translate="yes" xml:space="preserve">
          <source>Javadoc</source>
          <target state="translated">Javadoc</target>
        </trans-unit>
        <trans-unit id="32f36b7a72227d41f5dc6c620090f2d8c323b7d9" translate="yes" xml:space="preserve">
          <source>Join all the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; arguments together using the &lt;code&gt;&amp;lt;glue&amp;gt;&lt;/code&gt; string and store the result in the named &lt;code&gt;&amp;lt;output_variable&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;glue&amp;gt;&lt;/code&gt; 문자열을 사용하여 모든 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 인수를 결합 하고 결과를 명명 된 &lt;code&gt;&amp;lt;output_variable&amp;gt;&lt;/code&gt; 에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="bf531baac89a93fff2e8c7745df5e283ba2e5568" translate="yes" xml:space="preserve">
          <source>Join all the input arguments together using the glue string and store the result in the named output variable.</source>
          <target state="translated">글루 문자열을 사용하여 모든 입력 인수를 결합하고 결과를 명명 된 출력 변수에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4bf6e958650c635fec6eac782ac58dc98db5630f" translate="yes" xml:space="preserve">
          <source>Joins the list with the content of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 내용으로 목록을 조인합니다 .</target>
        </trans-unit>
        <trans-unit id="010b01fc24aad4280cc924ea685fd017cd4e3f0e" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_DCOP_SKELS(SRCS_VAR header1.h &amp;hellip; headerN.h )</source>
          <target state="translated">KDE3_ADD_DCOP_SKELS (SRCS_VAR header1.h&amp;hellip; headerN.h)</target>
        </trans-unit>
        <trans-unit id="72fb15004d0272e20c14bcadc854b385469ae178" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_DCOP_STUBS(SRCS_VAR header1.h &amp;hellip; headerN.h )</source>
          <target state="translated">KDE3_ADD_DCOP_STUBS (SRCS_VAR header1.h&amp;hellip; headerN.h)</target>
        </trans-unit>
        <trans-unit id="c3221ae61631e028cae95142fd23dcb1bc23dde8" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_EXECUTABLE(name file1 &amp;hellip; fileN )</source>
          <target state="translated">KDE3_ADD_EXECUTABLE (이름 file1&amp;hellip; fileN)</target>
        </trans-unit>
        <trans-unit id="858063d416a37becceacbb209596da2da7b93096" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_KCFG_FILES(SRCS_VAR file1.kcfgc &amp;hellip; fileN.kcfgc )</source>
          <target state="translated">KDE3_ADD_KCFG_FILES (SRCS_VAR file1.kcfgc&amp;hellip; fileN.kcfgc)</target>
        </trans-unit>
        <trans-unit id="2a933d48ae1c94885e1ceb61e81d0b29feadc031" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_KDEINIT_EXECUTABLE(name file1 &amp;hellip; fileN )</source>
          <target state="translated">KDE3_ADD_KDEINIT_EXECUTABLE (이름 file1&amp;hellip; fileN)</target>
        </trans-unit>
        <trans-unit id="ce4727a4e96b751d28ef2aa496ba715b86460449" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_KPART(name [WITH_PREFIX] file1 &amp;hellip; fileN )</source>
          <target state="translated">KDE3_ADD_KPART (이름 [WITH_PREFIX] file1&amp;hellip; fileN)</target>
        </trans-unit>
        <trans-unit id="550583275b9ab6beb79fe9e47ae47f40826ac8c7" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_MOC_FILES(SRCS_VAR file1 &amp;hellip; fileN )</source>
          <target state="translated">KDE3_ADD_MOC_FILES (SRCS_VAR file1&amp;hellip; fileN)</target>
        </trans-unit>
        <trans-unit id="48471772052fd12246be3829e2cc66f71685bc09" translate="yes" xml:space="preserve">
          <source>KDE3_ADD_UI_FILES(SRCS_VAR file1.ui &amp;hellip; fileN.ui )</source>
          <target state="translated">KDE3_ADD_UI_FILES (SRCS_VAR file1.ui&amp;hellip; fileN.ui)</target>
        </trans-unit>
        <trans-unit id="133db4c6a30c7aae981caafbffb3d63a15d5c351" translate="yes" xml:space="preserve">
          <source>KDE3_AUTOMOC(file1 &amp;hellip; fileN)</source>
          <target state="translated">KDE3_AUTOMOC (파일 1&amp;hellip; 파일 N)</target>
        </trans-unit>
        <trans-unit id="ba552bb8a0d3aaabb80c675b000843cefabce4dd" translate="yes" xml:space="preserve">
          <source>KDE3_INSTALL_LIBTOOL_FILE(target)</source>
          <target state="translated">KDE3_INSTALL_LIBTOOL_FILE(target)</target>
        </trans-unit>
        <trans-unit id="a5c84895227d24aa02679556b154aa9aff3585df" translate="yes" xml:space="preserve">
          <source>KEEP_EXTENSION</source>
          <target state="translated">KEEP_EXTENSION</target>
        </trans-unit>
        <trans-unit id="e8231b3cdb17e3f53372033d1d322ce64a775b92" translate="yes" xml:space="preserve">
          <source>Kate</source>
          <target state="translated">Kate</target>
        </trans-unit>
        <trans-unit id="8d68807a0b950fdd8e441c212de1dc02ad69305a" translate="yes" xml:space="preserve">
          <source>Keccak SHA-3.</source>
          <target state="translated">케삭 SHA-3.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="472d3e712d9b9e91c93a4bc69741038feda86527" translate="yes" xml:space="preserve">
          <source>Key points from this example:</source>
          <target state="translated">이 예의 요점 :</target>
        </trans-unit>
        <trans-unit id="96ae20164e98062b734fb48fccbaf90b8749a532" translate="yes" xml:space="preserve">
          <source>Keys are a single letter corresponding to a CMake cache variable type:</source>
          <target state="translated">키는 CMake 캐시 변수 유형에 해당하는 단일 문자입니다.</target>
        </trans-unit>
        <trans-unit id="1db613a313c68f1367b94928244a58851cd00717" translate="yes" xml:space="preserve">
          <source>Keywords terminate lists of values, e.g. if directly after a &lt;code&gt;one_value_keyword&lt;/code&gt; another recognized keyword follows, this is interpreted as the beginning of the new option. E.g. &lt;code&gt;my_install(TARGETS foo DESTINATION OPTIONAL)&lt;/code&gt; would result in &lt;code&gt;MY_INSTALL_DESTINATION&lt;/code&gt; set to &lt;code&gt;&quot;OPTIONAL&quot;&lt;/code&gt;, but as &lt;code&gt;OPTIONAL&lt;/code&gt; is a keyword itself &lt;code&gt;MY_INSTALL_DESTINATION&lt;/code&gt; will be empty (but added to &lt;code&gt;MY_INSTALL_KEYWORDS_MISSING_VALUES&lt;/code&gt;) and &lt;code&gt;MY_INSTALL_OPTIONAL&lt;/code&gt; will therefore be set to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">키워드는 값 목록을 종료합니다. 예를 들어 &lt;code&gt;one_value_keyword&lt;/code&gt; 바로 뒤에 다른 인식 된 키워드 가 오는 경우 이는 새 옵션의 시작으로 해석됩니다. 예를 들어 &lt;code&gt;my_install(TARGETS foo DESTINATION OPTIONAL)&lt;/code&gt; 은 &lt;code&gt;MY_INSTALL_DESTINATION&lt;/code&gt; 이 &lt;code&gt;&quot;OPTIONAL&quot;&lt;/code&gt; 로 설정 되지만 &lt;code&gt;OPTIONAL&lt;/code&gt; 은 키워드 자체 &lt;code&gt;MY_INSTALL_DESTINATION&lt;/code&gt; 은 비어 있습니다 (그러나 &lt;code&gt;MY_INSTALL_KEYWORDS_MISSING_VALUES&lt;/code&gt; 에 추가됨 ). &lt;code&gt;MY_INSTALL_OPTIONAL&lt;/code&gt; 은 &lt;code&gt;TRUE&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="7a7b5b3f1e499e82aabe63eaa09e81ad0a4598fc" translate="yes" xml:space="preserve">
          <source>Known toolset version numbers are:</source>
          <target state="translated">알려진 툴셋 버전 번호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c05bd2887a3c2398070db8292db9cc17084c2553" translate="yes" xml:space="preserve">
          <source>Known version numbers are:</source>
          <target state="translated">알려진 버전 번호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3dcd8a49e464c48d94446a8c88366486a0dad26a" translate="yes" xml:space="preserve">
          <source>LABELS</source>
          <target state="translated">LABELS</target>
        </trans-unit>
        <trans-unit id="2a3ffd9ebb6961e4e446366efa8d0013586561fb" translate="yes" xml:space="preserve">
          <source>LANGUAGE</source>
          <target state="translated">LANGUAGE</target>
        </trans-unit>
        <trans-unit id="44a8e31cec00df4f141118aac60bd55fa0d49c60" translate="yes" xml:space="preserve">
          <source>LANG_CLANG_TIDY</source>
          <target state="translated">LANG_CLANG_TIDY</target>
        </trans-unit>
        <trans-unit id="33de8403580924dd2e976a3103fd769a57970db7" translate="yes" xml:space="preserve">
          <source>LANG_COMPILER_LAUNCHER</source>
          <target state="translated">LANG_COMPILER_LAUNCHER</target>
        </trans-unit>
        <trans-unit id="cec6c7a8fbc84dafa50f931474a881cdd4e73641" translate="yes" xml:space="preserve">
          <source>LANG_CPPCHECK</source>
          <target state="translated">LANG_CPPCHECK</target>
        </trans-unit>
        <trans-unit id="f96e07147917c5d12513e3c24251b83876d7091c" translate="yes" xml:space="preserve">
          <source>LANG_CPPLINT</source>
          <target state="translated">LANG_CPPLINT</target>
        </trans-unit>
        <trans-unit id="cb4e1c8fe3b11a22d6cd88e39c62cf52b197e888" translate="yes" xml:space="preserve">
          <source>LANG_INCLUDE_WHAT_YOU_USE</source>
          <target state="translated">LANG_INCLUDE_WHAT_YOU_USE</target>
        </trans-unit>
        <trans-unit id="e06b25d20650e07bfa0e07095ae584905d6d88ff" translate="yes" xml:space="preserve">
          <source>LANG_VISIBILITY_PRESET</source>
          <target state="translated">LANG_VISIBILITY_PRESET</target>
        </trans-unit>
        <trans-unit id="53b446e895561fdf453c0ea50ada7bf6756264fe" translate="yes" xml:space="preserve">
          <source>LDFLAGS</source>
          <target state="translated">LDFLAGS</target>
        </trans-unit>
        <trans-unit id="2125bf18d3da3c8d4371722e5c9da5edd37aafc3" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_DIRECTORY</source>
          <target state="translated">LIBRARY_OUTPUT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="480a03334097de5faeac9c0bec1ad4a2e000984b" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_DIRECTORY_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LIBRARY_OUTPUT_DIRECTORY_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b42cf1815581dd51e7f01e1dac6350b36736f313" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_DIRECTORY_CONFIG</source>
          <target state="translated">LIBRARY_OUTPUT_DIRECTORY_CONFIG</target>
        </trans-unit>
        <trans-unit id="3d4acd271155c40ac6b27f1e3f71198b9dbf88a6" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_NAME</source>
          <target state="translated">LIBRARY_OUTPUT_NAME</target>
        </trans-unit>
        <trans-unit id="c1381a897c8964dd98ef1abbccc762dac98af533" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_NAME_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LIBRARY_OUTPUT_NAME_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9a0c687844d270f516071592c9db01a10047d3c6" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_NAME_CONFIG</source>
          <target state="translated">LIBRARY_OUTPUT_NAME_CONFIG</target>
        </trans-unit>
        <trans-unit id="27515048cbdf4a6009f2f77883fe7e8b0d176dbc" translate="yes" xml:space="preserve">
          <source>LIBRARY_OUTPUT_PATH</source>
          <target state="translated">LIBRARY_OUTPUT_PATH</target>
        </trans-unit>
        <trans-unit id="63947618a8833355116d86b491ab9d462633eaa0" translate="yes" xml:space="preserve">
          <source>LIBXSLT_FOUND - system has LibXslt LIBXSLT_INCLUDE_DIR - the LibXslt include directory LIBXSLT_LIBRARIES - Link these to LibXslt LIBXSLT_DEFINITIONS - Compiler switches required for using LibXslt LIBXSLT_VERSION_STRING - version of LibXslt found (since CMake 2.8.8)</source>
          <target state="translated">LIBXSLT_FOUND-시스템에 LibXslt LIBXSLT_INCLUDE_DIR 포함-LibXslt 포함 디렉토리 LIBXSLT_LIBRARIES-LibXslt에 연결 LIBXSLT_DEFINITIONS-LibXslt LIBXSLT_VERSION_STRING 사용에 필요한 컴파일러 스위치 발견 (CMake 2.8.8 이후)</target>
        </trans-unit>
        <trans-unit id="f05af4f1b65988277f40848b77106a3e0b3837e3" translate="yes" xml:space="preserve">
          <source>LINKER_LANGUAGE</source>
          <target state="translated">LINKER_LANGUAGE</target>
        </trans-unit>
        <trans-unit id="d0375330b4b150c2c542be102e77dd8eb0641533" translate="yes" xml:space="preserve">
          <source>LINK_DEPENDS</source>
          <target state="translated">LINK_DEPENDS</target>
        </trans-unit>
        <trans-unit id="8822fd17445f54bec87ce2f7c7693add73e508d0" translate="yes" xml:space="preserve">
          <source>LINK_DEPENDS_NO_SHARED</source>
          <target state="translated">LINK_DEPENDS_NO_SHARED</target>
        </trans-unit>
        <trans-unit id="ba16fcbb2171bcc5e11fa1fd8870adbcdbb118d1" translate="yes" xml:space="preserve">
          <source>LINK_DIRECTORIES</source>
          <target state="translated">LINK_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="6742dbe54aec0217212608f98878c9ea49012af1" translate="yes" xml:space="preserve">
          <source>LINK_FLAGS</source>
          <target state="translated">LINK_FLAGS</target>
        </trans-unit>
        <trans-unit id="bfdfa365576034adc147b34e4b54994a4aa588ce" translate="yes" xml:space="preserve">
          <source>LINK_FLAGS_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LINK_FLAGS_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6a5b83554c1fae50cd3d22e32cafbf3ce5c1f8b3" translate="yes" xml:space="preserve">
          <source>LINK_FLAGS_CONFIG</source>
          <target state="translated">LINK_FLAGS_CONFIG</target>
        </trans-unit>
        <trans-unit id="fca845711560c6945794af2b85ab87cb2ccfee95" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_LIBRARIES</source>
          <target state="translated">LINK_INTERFACE_LIBRARIES</target>
        </trans-unit>
        <trans-unit id="984ba4d3f063aedc33b84aacc8b09c533a795f6c" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_LIBRARIES_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LINK_INTERFACE_LIBRARIES_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2ca59efc2446f4bf8c858f12fd2d3a7e01f50973" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_LIBRARIES_CONFIG</source>
          <target state="translated">LINK_INTERFACE_LIBRARIES_CONFIG</target>
        </trans-unit>
        <trans-unit id="62203fe7b8d9762620e9047f0f1423127621fcd6" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_MULTIPLICITY</source>
          <target state="translated">LINK_INTERFACE_MULTIPLICITY</target>
        </trans-unit>
        <trans-unit id="a7051a820bce6b1bb934f1fdf3c64d2bd6a51510" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_MULTIPLICITY_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LINK_INTERFACE_MULTIPLICITY_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d9e29ee3a0a7190700ee30a2aaddc4a64b22b460" translate="yes" xml:space="preserve">
          <source>LINK_INTERFACE_MULTIPLICITY_CONFIG</source>
          <target state="translated">LINK_INTERFACE_MULTIPLICITY_CONFIG</target>
        </trans-unit>
        <trans-unit id="0204d13b20379e039009fad4831e252ff07ed932" translate="yes" xml:space="preserve">
          <source>LINK_LIBRARIES</source>
          <target state="translated">LINK_LIBRARIES</target>
        </trans-unit>
        <trans-unit id="86761e62739241fbd774ad024672540562305557" translate="yes" xml:space="preserve">
          <source>LINK_OPTIONS</source>
          <target state="translated">LINK_OPTIONS</target>
        </trans-unit>
        <trans-unit id="2ad5d57cb23a1c7a9ccc582ebf34cee0abeba207" translate="yes" xml:space="preserve">
          <source>LINK_SEARCH_END_STATIC</source>
          <target state="translated">LINK_SEARCH_END_STATIC</target>
        </trans-unit>
        <trans-unit id="d53ad5936c589b72d5b41f88bc88c7cbd8f7e7e0" translate="yes" xml:space="preserve">
          <source>LINK_SEARCH_START_STATIC</source>
          <target state="translated">LINK_SEARCH_START_STATIC</target>
        </trans-unit>
        <trans-unit id="84f5d850299f846d9e61d5c97e3e3f55634ee841" translate="yes" xml:space="preserve">
          <source>LINK_WHAT_YOU_USE</source>
          <target state="translated">LINK_WHAT_YOU_USE</target>
        </trans-unit>
        <trans-unit id="efe907313826e26d0eaef8e5c927a14832101127" translate="yes" xml:space="preserve">
          <source>LISTFILE_STACK</source>
          <target state="translated">LISTFILE_STACK</target>
        </trans-unit>
        <trans-unit id="a0bad7644cdf8f7358f15691c7f9f8c506488813" translate="yes" xml:space="preserve">
          <source>LLVM libc++ Shared</source>
          <target state="translated">LLVM libc ++ 공유</target>
        </trans-unit>
        <trans-unit id="d155674a5dad17bd5dc7de7f0457a0dccb629928" translate="yes" xml:space="preserve">
          <source>LLVM libc++ Static</source>
          <target state="translated">LLVM libc ++ 정적</target>
        </trans-unit>
        <trans-unit id="dc5c7379599c2942d4306de49be58e442218f5b2" translate="yes" xml:space="preserve">
          <source>LOCAL DCMTK</source>
          <target state="translated">지역 DCMTK</target>
        </trans-unit>
        <trans-unit id="40c3322b3b3d0d946724fe784d34663629e1932a" translate="yes" xml:space="preserve">
          <source>LOCATION</source>
          <target state="translated">LOCATION</target>
        </trans-unit>
        <trans-unit id="54f98562ace52182700d465b67ae966369fa5cbf" translate="yes" xml:space="preserve">
          <source>LOCATION_&amp;lt;CONFIG&amp;gt;</source>
          <target state="translated">LOCATION_&amp;lt;CONFIG&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cb84ab2253fa8454f7c281f828ae9e8f1e538a74" translate="yes" xml:space="preserve">
          <source>LOCATION_CONFIG</source>
          <target state="translated">LOCATION_CONFIG</target>
        </trans-unit>
        <trans-unit id="63ca32757021e9c4c3a4560a7e10b9f10141eb4e" translate="yes" xml:space="preserve">
          <source>LUA50_FOUND, if false, do not try to link to Lua LUA_LIBRARIES, both lua and lualib LUA_INCLUDE_DIR, where to find lua.h and lualib.h (and probably lauxlib.h)</source>
          <target state="translated">LUA50_FOUND가 false 인 경우 lua 및 lualib LUA_INCLUDE_DIR에서 Lua LUA_LIBRARIES에 연결하지 마십시오. lua.h 및 lualib.h (및 아마도 lauxlib.h)를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b1c7459afc13c19ec4de104ab99e38c71617e1" translate="yes" xml:space="preserve">
          <source>LUA51_FOUND, if false, do not try to link to Lua LUA_LIBRARIES LUA_INCLUDE_DIR, where to find lua.h LUA_VERSION_STRING, the version of Lua found (since CMake 2.8.8)</source>
          <target state="translated">LUA51_FOUND, false 인 경우 Lua LUA_LIBRARIES LUA_INCLUDE_DIR에 링크하지 마십시오. 여기서 Lua를 찾은 lua.h LUA_VERSION_STRING을 찾으십시오 (CMake 2.8.8부터).</target>
        </trans-unit>
        <trans-unit id="7e7f38ead3676543d4dc450aea693822a237dafe" translate="yes" xml:space="preserve">
          <source>LUA_FOUND - if false, do not try to link to Lua LUA_LIBRARIES - both lua and lualib LUA_INCLUDE_DIR - where to find lua.h LUA_VERSION_STRING - the version of Lua found LUA_VERSION_MAJOR - the major version of Lua LUA_VERSION_MINOR - the minor version of Lua LUA_VERSION_PATCH - the patch version of Lua</source>
          <target state="translated">LUA_FOUND-false 인 경우 Lua LUA_LIBRARIES-lua 및 lualib LUA_INCLUDE_DIR-lua.h LUA_VERSION_STRING-루아 버전을 찾은 위치 LUA_VERSION_MAJOR-루아 버전 LUA_VERSION_MINOR-루아 LUA_L 루아의 패치 버전</target>
        </trans-unit>
        <trans-unit id="e5ce93d215e8e3a4434238625708b36031de9a8c" translate="yes" xml:space="preserve">
          <source>Label and Subproject Summary</source>
          <target state="translated">라벨 및 하위 프로젝트 요약</target>
        </trans-unit>
        <trans-unit id="d35ca39e2e21cf40f56a6667eff108f9433e4775" translate="yes" xml:space="preserve">
          <source>Lambda functions, as defined in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&quot;&gt;N2927&lt;/a&gt;.</source>
          <target state="translated">람다 함수는로 정의 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2927.pdf&quot;&gt;N2927&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="a5d36440693b6c51d272890eb26092ccb4a17694" translate="yes" xml:space="preserve">
          <source>Language-specific flag to be used to link a library specified by a path to its file.</source>
          <target state="translated">경로로 지정된 라이브러리를 파일에 연결하는 데 사용할 언어 별 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="2162ad22b0cbe82ab6cb30b75d04a8324cd5eaa4" translate="yes" xml:space="preserve">
          <source>Language-specific suffix for libraries that you link to.</source>
          <target state="translated">링크하는 라이브러리의 언어 별 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="db07be184479f34078cd4fc76d248dc0975720e9" translate="yes" xml:space="preserve">
          <source>Languages</source>
          <target state="translated">Languages</target>
        </trans-unit>
        <trans-unit id="64a2cb9f08f164f4b95af179adcd054826d66e95" translate="yes" xml:space="preserve">
          <source>Languages are enabled by the &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command. Language-specific built-in variables, such as &lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt;, &lt;code&gt;CMAKE_CXX_COMPILER_ID&lt;/code&gt; etc are set by invoking the &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-1-command:project&quot;&gt;&lt;code&gt;project()&lt;/code&gt;&lt;/a&gt; command. If no project command is in the top-level CMakeLists file, one will be implicitly generated. By default the enabled languages are &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;CXX&lt;/code&gt;:</source>
          <target state="translated">언어는 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-0-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령 으로 활성화됩니다 . &lt;code&gt;CMAKE_CXX_COMPILER&lt;/code&gt; , &lt;code&gt;CMAKE_CXX_COMPILER_ID&lt;/code&gt; 등과 같은 언어 별 내장 변수 는 &lt;a href=&quot;../command/project#command:project&quot; id=&quot;index-1-command:project&quot;&gt; &lt;code&gt;project()&lt;/code&gt; &lt;/a&gt; 명령 을 호출하여 설정됩니다 . 최상위 CMakeLists 파일에 프로젝트 명령이 없으면 암시 적으로 생성됩니다. 기본적으로 사용 가능한 언어는 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;CXX&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c470204feaa6afa803476577ad28f809eaf43089" translate="yes" xml:space="preserve">
          <source>Languages compiled into an &lt;code&gt;IMPORTED&lt;/code&gt; static library.</source>
          <target state="translated">&lt;code&gt;IMPORTED&lt;/code&gt; 정적 라이브러리 로 컴파일 된 언어</target>
        </trans-unit>
        <trans-unit id="d51b73f96ab72ad3815ce560c5556d25f260bfd7" translate="yes" xml:space="preserve">
          <source>Lastly, suppose that &lt;code&gt;secretsauce&lt;/code&gt; provides a script called &lt;code&gt;makedoc&lt;/code&gt; which can be used to generate its own documentation. Further suppose that the script expects the output directory to be provided as the only parameter and that it should be run from the &lt;code&gt;secretsauce&lt;/code&gt; source directory. A custom step and a custom target to trigger the script can be defined like so:</source>
          <target state="translated">마지막으로 &lt;code&gt;secretsauce&lt;/code&gt; 가 자체 문서를 생성하는 데 사용할 수있는 &lt;code&gt;makedoc&lt;/code&gt; 이라는 스크립트를 제공 한다고 가정합니다 . 또한 스크립트가 출력 디렉토리가 유일한 매개 변수로 제공되고 &lt;code&gt;secretsauce&lt;/code&gt; 소스 디렉토리 에서 실행되어야한다고 가정합니다 . 스크립트를 트리거하는 사용자 정의 단계 및 사용자 정의 대상은 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6cbca8f873c65cbb2e8981679dcca506c7773a" translate="yes" xml:space="preserve">
          <source>Lastly, the following example demonstrates how one might download and unpack a firmware tarball using CMake&amp;rsquo;s &lt;a href=&quot;../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt;&lt;code&gt;script mode&lt;/code&gt;&lt;/a&gt;. The call to &lt;a href=&quot;#command:fetchcontent_populate&quot; id=&quot;index-4-command:fetchcontent_populate&quot;&gt;&lt;code&gt;FetchContent_Populate()&lt;/code&gt;&lt;/a&gt; specifies all the content details and the unpacked firmware will be placed in a &lt;code&gt;firmware&lt;/code&gt; directory below the current working directory.</source>
          <target state="translated">마지막으로, 다음 예는 CMake의 &lt;a href=&quot;../manual/cmake.1#manual:cmake(1)&quot; id=&quot;index-0-manual:cmake(1)&quot;&gt; &lt;code&gt;script mode&lt;/code&gt; &lt;/a&gt; 사용하여 펌웨어 타르볼을 다운로드하고 압축을 풀 수있는 방법을 보여줍니다 . &lt;a href=&quot;#command:fetchcontent_populate&quot; id=&quot;index-4-command:fetchcontent_populate&quot;&gt; &lt;code&gt;FetchContent_Populate()&lt;/code&gt; &lt;/a&gt; 대한 호출 은 모든 컨텐츠 세부 사항을 지정하며 압축 해제 된 펌웨어는 현재 작업 디렉토리 아래의 &lt;code&gt;firmware&lt;/code&gt; 디렉토리에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b59beead33a91a2cb84032d9291768413dffff7" translate="yes" xml:space="preserve">
          <source>Lastly, we have a function called &lt;code&gt;do_test&lt;/code&gt; that runs the application and verifies that the computed square root is correct for given input. For each invocation of &lt;code&gt;do_test&lt;/code&gt;, another test is added to the project with a name, input, and expected results based on the passed arguments.</source>
          <target state="translated">마지막으로, 애플리케이션을 실행하고 계산 된 제곱근이 주어진 입력에 대해 올바른지 확인하는 &lt;code&gt;do_test&lt;/code&gt; 라는 함수가 있습니다 . &lt;code&gt;do_test&lt;/code&gt; 를 호출 할 때마다 전달 된 인수를 기반으로하는 이름, 입력 및 예상 결과와 함께 다른 테스트가 프로젝트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bed35f8913d07b23e0ab067d05c6b979d663dc" translate="yes" xml:space="preserve">
          <source>Later, in another &lt;code&gt;ctest -S&lt;/code&gt; script:</source>
          <target state="translated">나중에 다른 &lt;code&gt;ctest -S&lt;/code&gt; 스크립트에서 :</target>
        </trans-unit>
        <trans-unit id="ead4b43e91ade7f4ca0e613faf6261cbc402a813" translate="yes" xml:space="preserve">
          <source>Launch &lt;a href=&quot;cmake-server.7#manual:cmake-server(7)&quot; id=&quot;index-0-manual:cmake-server(7)&quot;&gt;&lt;code&gt;cmake-server(7)&lt;/code&gt;&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;cmake-server.7#manual:cmake-server(7)&quot; id=&quot;index-0-manual:cmake-server(7)&quot;&gt; &lt;code&gt;cmake-server(7)&lt;/code&gt; &lt;/a&gt; 모드를 시작 하십시오.</target>
        </trans-unit>
        <trans-unit id="8972d921d33dcb292f3d4a102a0721510ecee94b" translate="yes" xml:space="preserve">
          <source>Launch tests in a random order. This may be useful for detecting implicit test dependencies.</source>
          <target state="translated">무작위 순서로 테스트를 시작하십시오. 이것은 암시 적 테스트 종속성을 감지하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1572e6e5de5ba1ea552d8ec5ef3f1b42f331b6e" translate="yes" xml:space="preserve">
          <source>Legacy CPack Modules</source>
          <target state="translated">레거시 CPack 모듈</target>
        </trans-unit>
        <trans-unit id="7064ca9b585df986e1513ca88574711f3f6ad54a" translate="yes" xml:space="preserve">
          <source>Legacy Macros</source>
          <target state="translated">레거시 매크로</target>
        </trans-unit>
        <trans-unit id="7bc5c10b3cc464b7e0602487fdb463ff97f6ea80" translate="yes" xml:space="preserve">
          <source>Legacy option for old Dart2 dashboard server feature. Do not use.</source>
          <target state="translated">기존 Dart2 대시 보드 서버 기능의 레거시 옵션. 사용하지 마세요.</target>
        </trans-unit>
        <trans-unit id="7cfb5b6849e07c693231687b0f4e43523fa02262" translate="yes" xml:space="preserve">
          <source>Legacy option. Not used.</source>
          <target state="translated">레거시 옵션. 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02a2dd730da2ba8ac5c5969f51aea3976b43120f" translate="yes" xml:space="preserve">
          <source>Legacy option. When &lt;code&gt;SubmitURL&lt;/code&gt; is not set, it is constructed from &lt;code&gt;DropMethod&lt;/code&gt;, &lt;code&gt;DropSiteUser&lt;/code&gt;, &lt;code&gt;DropSitePassword&lt;/code&gt;, &lt;code&gt;DropSite&lt;/code&gt;, and &lt;code&gt;DropLocation&lt;/code&gt;.</source>
          <target state="translated">레거시 옵션. 때 &lt;code&gt;SubmitURL&lt;/code&gt; 가 설정되어 있지 않은, 그것은으로 구성되어 &lt;code&gt;DropMethod&lt;/code&gt; , &lt;code&gt;DropSiteUser&lt;/code&gt; , &lt;code&gt;DropSitePassword&lt;/code&gt; , &lt;code&gt;DropSite&lt;/code&gt; 및 &lt;code&gt;DropLocation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="b980c29dffb624a5dc3dc81e69b57b2fbcae8537" translate="yes" xml:space="preserve">
          <source>Let &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-0-prop_tgt:AUTOMOC&quot;&gt;&lt;code&gt;AUTOMOC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../prop_tgt/autouic#prop_tgt:AUTOUIC&quot; id=&quot;index-0-prop_tgt:AUTOUIC&quot;&gt;&lt;code&gt;AUTOUIC&lt;/code&gt;&lt;/a&gt; process &lt;a href=&quot;../prop_sf/generated#prop_sf:GENERATED&quot; id=&quot;index-0-prop_sf:GENERATED&quot;&gt;&lt;code&gt;GENERATED&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">하자 &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-0-prop_tgt:AUTOMOC&quot;&gt; &lt;code&gt;AUTOMOC&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../prop_tgt/autouic#prop_tgt:AUTOUIC&quot; id=&quot;index-0-prop_tgt:AUTOUIC&quot;&gt; &lt;code&gt;AUTOUIC&lt;/code&gt; &lt;/a&gt; 과정 &lt;a href=&quot;../prop_sf/generated#prop_sf:GENERATED&quot; id=&quot;index-0-prop_sf:GENERATED&quot;&gt; &lt;code&gt;GENERATED&lt;/code&gt; &lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="84afbb5aa5f0540b53650c3e5591bd37057ba14d" translate="yes" xml:space="preserve">
          <source>Let &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-0-prop_tgt:AUTOMOC&quot;&gt;&lt;code&gt;AUTOMOC&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../prop_tgt/autouic#prop_tgt:AUTOUIC&quot; id=&quot;index-0-prop_tgt:AUTOUIC&quot;&gt;&lt;code&gt;AUTOUIC&lt;/code&gt;&lt;/a&gt; process header files that end with a &lt;code&gt;.hh&lt;/code&gt; extension.</source>
          <target state="translated">하자 &lt;a href=&quot;../prop_tgt/automoc#prop_tgt:AUTOMOC&quot; id=&quot;index-0-prop_tgt:AUTOMOC&quot;&gt; &lt;code&gt;AUTOMOC&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../prop_tgt/autouic#prop_tgt:AUTOUIC&quot; id=&quot;index-0-prop_tgt:AUTOUIC&quot;&gt; &lt;code&gt;AUTOUIC&lt;/code&gt; &lt;/a&gt; 프로세스 헤더 파일 A를이를 &lt;code&gt;.hh&lt;/code&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="7bd151a608622cb3130e031619f11188439eb047" translate="yes" xml:space="preserve">
          <source>Let CMake know that source files that contain &lt;code&gt;CUSTOM_MACRO&lt;/code&gt; must be &lt;code&gt;moc&lt;/code&gt; processed as well:</source>
          <target state="translated">&lt;code&gt;CUSTOM_MACRO&lt;/code&gt; 가 포함 된 소스 파일 도 &lt;code&gt;moc&lt;/code&gt; 처리 해야 한다는 것을 CMake에 알려 주십시오 .</target>
        </trans-unit>
        <trans-unit id="665a3949600d2d1cf90cd3d7aa7d6d3216fd1d3c" translate="yes" xml:space="preserve">
          <source>Let us consider adding some code to our project that depends on features the target platform may not have. For this example, we will add some code that depends on whether or not the target platform has the &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; functions. Of course almost every platform has these functions but for this tutorial assume that they are not common.</source>
          <target state="translated">대상 플랫폼에없는 기능에 따라 프로젝트에 코드를 추가하는 것을 고려해 보겠습니다. 이 예에서는 대상 플랫폼에 &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;exp&lt;/code&gt; 함수 가 있는지 여부에 따라 몇 가지 코드를 추가 합니다. 물론 거의 모든 플랫폼에 이러한 기능이 있지만이 자습서에서는 일반적이지 않다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a11e1aa1eb06ea278cf8badd0614fafa8ed9c307" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add version numbering to the MathFunctions library. In &lt;code&gt;MathFunctions/CMakeLists.txt&lt;/code&gt;, set the &lt;a href=&quot;../../prop_tgt/version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt;&lt;code&gt;VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../prop_tgt/soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt;&lt;code&gt;SOVERSION&lt;/code&gt;&lt;/a&gt; properties:</source>
          <target state="translated">MathFunctions 라이브러리에 버전 번호를 추가해 보겠습니다. 에서 &lt;code&gt;MathFunctions/CMakeLists.txt&lt;/code&gt; 은 , 설정된 &lt;a href=&quot;../../prop_tgt/version#prop_tgt:VERSION&quot; id=&quot;index-0-prop_tgt:VERSION&quot;&gt; &lt;code&gt;VERSION&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;../../prop_tgt/soversion#prop_tgt:SOVERSION&quot; id=&quot;index-0-prop_tgt:SOVERSION&quot;&gt; &lt;code&gt;SOVERSION&lt;/code&gt; &lt;/a&gt; 속성을 :</target>
        </trans-unit>
        <trans-unit id="057420202e9e083705bdf36a264aea683e02a96e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s edit the &lt;code&gt;MathFunctions&lt;/code&gt; project to use components. The source code for this section can be found in &lt;code&gt;Help\guide\importing-exporting\MathFunctionsComponents&lt;/code&gt;. The CMakeLists file for this project adds two subdirectories: &lt;code&gt;Addition&lt;/code&gt; and &lt;code&gt;SquareRoot&lt;/code&gt;.</source>
          <target state="translated">구성 요소를 사용 하도록 &lt;code&gt;MathFunctions&lt;/code&gt; 프로젝트를 편집 해 보겠습니다 . 이 섹션의 소스 코드는 &lt;code&gt;Help\guide\importing-exporting\MathFunctionsComponents&lt;/code&gt; 에서 찾을 수 있습니다 . 이 프로젝트의 CMakeLists 파일은 &lt;code&gt;Addition&lt;/code&gt; 및 &lt;code&gt;SquareRoot&lt;/code&gt; 의 두 하위 디렉터리를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a476098ec0146605d97a85dacc7525712b475073" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s refactor our code from &lt;a href=&quot;#adding-a-library-step-2&quot;&gt;Adding a Library (Step 2)&lt;/a&gt; to use the modern CMake approach of usage requirements. We first state that anybody linking to MathFunctions needs to include the current source directory, while MathFunctions itself doesn&amp;rsquo;t. So this can become an &lt;code&gt;INTERFACE&lt;/code&gt; usage requirement.</source>
          <target state="translated">사용 요구 사항에 대한 최신 CMake 접근 방식을 사용하기 위해 &lt;a href=&quot;#adding-a-library-step-2&quot;&gt;라이브러리 추가 (2 단계)&lt;/a&gt; 의 코드를 리팩터링 해 보겠습니다 . 먼저 MathFunctions에 링크하는 사람은 현재 소스 디렉토리를 포함해야하지만 MathFunctions 자체는 포함하지 않습니다. 따라서 이것은 &lt;code&gt;INTERFACE&lt;/code&gt; 사용 요구 사항 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4412bd49a1d24ffa482dbc0a8c9eb78d557f322" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by looking at the &lt;code&gt;MathFunctions&lt;/code&gt; project in the &lt;code&gt;Help/guide/importing-exporting/MathFunctions&lt;/code&gt; directory. Here we have a header file &lt;code&gt;MathFunctions.h&lt;/code&gt; that declares a &lt;code&gt;sqrt&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;Help/guide/importing-exporting/MathFunctions&lt;/code&gt; 디렉토리 에있는 &lt;code&gt;MathFunctions&lt;/code&gt; 프로젝트 부터 살펴 보겠습니다 . 여기 에 &lt;code&gt;sqrt&lt;/code&gt; 함수 를 선언하는 헤더 파일 &lt;code&gt;MathFunctions.h&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0227126717e12d2e1a7e8db522ce5e424ca6ae47" translate="yes" xml:space="preserve">
          <source>LibXml2 libraries to be linked</source>
          <target state="translated">연결할 LibXml2 라이브러리</target>
        </trans-unit>
        <trans-unit id="72a5e2ce6a95049ee400a12b23770ed29f508dc7" translate="yes" xml:space="preserve">
          <source>Libraries and targets following &lt;code&gt;LINK_PUBLIC&lt;/code&gt; are linked to, and are made part of the &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt;. If policy &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-1-policy:CMP0022&quot;&gt;&lt;code&gt;CMP0022&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;NEW&lt;/code&gt;, they are also made part of the &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-1-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt;&lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt;&lt;/a&gt;. Libraries and targets following &lt;code&gt;LINK_PRIVATE&lt;/code&gt; are linked to, but are not made part of the &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-2-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-2-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt;&lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;LINK_PUBLIC&lt;/code&gt; 다음의 라이브러리 및 대상 은 &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-1-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; 에&lt;/a&gt; 연결되어 있으며 INTERFACE_LINK_LIBRARIES의 일부입니다 . 정책 &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-1-policy:CMP0022&quot;&gt; &lt;code&gt;CMP0022&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;NEW&lt;/code&gt; 정책 이 아닌 경우 에는 &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-1-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt; &lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt; 의&lt;/a&gt; 일부이기도합니다 . &lt;code&gt;LINK_PRIVATE&lt;/code&gt; 다음의 라이브러리 및 대상 은 &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-2-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-2-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt; &lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt; &lt;/a&gt; )에 연결되어 있지만 그 일부는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b5bb02cc2b547e366731d9c4741cbfe12126d5e9" translate="yes" xml:space="preserve">
          <source>Libraries for Dependents Only (Legacy)</source>
          <target state="translated">부양 가족 전용 라이브러리 (레거시)</target>
        </trans-unit>
        <trans-unit id="c8fd5c30b70e93d2d47ebf09d7bffd470f6e860b" translate="yes" xml:space="preserve">
          <source>Libraries for a Target and/or its Dependents</source>
          <target state="translated">대상 및 / 또는 그 종속물을위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="11e374fe6f743a858d1aafd9c3026ae4c75636ea" translate="yes" xml:space="preserve">
          <source>Libraries for a Target and/or its Dependents (Legacy)</source>
          <target state="translated">대상 및 / 또는 종속 항목에 대한 라이브러리 (레거시)</target>
        </trans-unit>
        <trans-unit id="24e71fb98cd1deecc4c4603225243e84825aa0f9" translate="yes" xml:space="preserve">
          <source>Libraries for both a Target and its Dependents</source>
          <target state="translated">대상과 그 종속물을위한 라이브러리</target>
        </trans-unit>
        <trans-unit id="eff3e6cfcc86dbe4a700e77678e3efbac027153f" translate="yes" xml:space="preserve">
          <source>Libraries linked by full-path must have a valid library file name.</source>
          <target state="translated">전체 경로로 링크 된 라이브러리는 유효한 라이브러리 파일 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="d77fde896b1dad40782fac9b15b74762ae69b65b" translate="yes" xml:space="preserve">
          <source>Libraries linked into every executable and shared library linked for language &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt;. This is meant for specification of system libraries needed by the language for the current platform.</source>
          <target state="translated">언어에 연결된 모든 실행 파일과 공유 라이브러리에 링크 라이브러리 &lt;code&gt;&amp;lt;LANG&amp;gt;&lt;/code&gt; . 이는 현재 플랫폼의 언어에 필요한 시스템 라이브러리를 지정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="87ae7f7631aabc856d140a9563f0187627759799" translate="yes" xml:space="preserve">
          <source>Libraries linked may not have leading or trailing whitespace.</source>
          <target state="translated">연결된 라이브러리에는 선행 또는 후행 공백이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5627f410fd28d61a6f61cadd6cdd713c4b9d5aa" translate="yes" xml:space="preserve">
          <source>Libraries linked using &amp;ldquo;Link Binary With Libraries&amp;rdquo; are linked after the ones linked through regular linker flags. This order should be taken into account when different static libraries contain symbols with the same name, as the former ones will take precedence over the latter.</source>
          <target state="translated">&amp;ldquo;Link Binary With Libraries&amp;rdquo;를 사용하여 연결된 라이브러리는 일반 링커 플래그를 통해 연결된 라이브러리 뒤에 연결됩니다. 이 순서는 다른 정적 라이브러리에 동일한 이름의 기호가 포함 된 경우 고려되어야합니다. 전자가 후자보다 우선하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bd42c5ae851b488cdefdc733c434ab4002beb753" translate="yes" xml:space="preserve">
          <source>Libraries linked via full path no longer produce linker search paths.</source>
          <target state="translated">전체 경로를 통해 연결된 라이브러리는 더 이상 링커 검색 경로를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e9b98d37af82523b3b6aefa1e864f9c1db64c70" translate="yes" xml:space="preserve">
          <source>Libraries may provide entirely different header files depending on requested compiler features.</source>
          <target state="translated">라이브러리는 요청 된 컴파일러 기능에 따라 완전히 다른 헤더 파일을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="411e33e3043f02c2f597cd5e0d7ca0d42a10a103" translate="yes" xml:space="preserve">
          <source>Libraries may themselves have other private library dependencies that expect to be found via &lt;code&gt;RPATH&lt;/code&gt; mechanisms, but some linkers are not able to fully decode those paths (e.g. due to the presence of things like &lt;code&gt;$ORIGIN&lt;/code&gt;).</source>
          <target state="translated">라이브러리 자체에는 &lt;code&gt;RPATH&lt;/code&gt; 메커니즘을 통해 발견 될 것으로 예상되는 다른 개인 라이브러리 종속성이 있을 수 있지만 일부 링커는 해당 경로를 완전히 디코딩 할 수 없습니다 (예 : &lt;code&gt;$ORIGIN&lt;/code&gt; 과 같은 것 때문에 ).</target>
        </trans-unit>
        <trans-unit id="f698e08ff120f1c44fe0f193ce7b7ddfb2b2537c" translate="yes" xml:space="preserve">
          <source>Libraries not Providing Config-file Packages</source>
          <target state="translated">구성 파일 패키지를 제공하지 않는 라이브러리</target>
        </trans-unit>
        <trans-unit id="a7432493f3195167b0589a7c26d296ad1fe0e1a4" translate="yes" xml:space="preserve">
          <source>Libraries providing Config-file packages</source>
          <target state="translated">구성 파일 패키지를 제공하는 라이브러리</target>
        </trans-unit>
        <trans-unit id="e471655a6880afebc8000fb66e6c0b31eaef8523" translate="yes" xml:space="preserve">
          <source>Libraries specified as &lt;code&gt;debug&lt;/code&gt; are wrapped in a generator expression to correspond to debug builds. If policy &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-3-policy:CMP0022&quot;&gt;&lt;code&gt;CMP0022&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;NEW&lt;/code&gt;, the libraries are also appended to the &lt;code&gt;LINK_INTERFACE_LIBRARIES_DEBUG&lt;/code&gt; property (or to the properties corresponding to configurations listed in the &lt;a href=&quot;../prop_gbl/debug_configurations#prop_gbl:DEBUG_CONFIGURATIONS&quot; id=&quot;index-1-prop_gbl:DEBUG_CONFIGURATIONS&quot;&gt;&lt;code&gt;DEBUG_CONFIGURATIONS&lt;/code&gt;&lt;/a&gt; global property if it is set). Libraries specified as &lt;code&gt;optimized&lt;/code&gt; are appended to the &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-4-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt; property. If policy &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-4-policy:CMP0022&quot;&gt;&lt;code&gt;CMP0022&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;NEW&lt;/code&gt;, they are also appended to the &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-4-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt;&lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt;&lt;/a&gt; property. Libraries specified as &lt;code&gt;general&lt;/code&gt; (or without any keyword) are treated as if specified for both &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;optimized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 로 지정된 라이브러리 는 디버그 빌드에 해당하는 생성기 표현식으로 랩핑됩니다. 정책 &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-3-policy:CMP0022&quot;&gt; &lt;code&gt;CMP0022&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;NEW&lt;/code&gt; 가 아닌 경우 라이브러리는 &lt;code&gt;LINK_INTERFACE_LIBRARIES_DEBUG&lt;/code&gt; 특성 (또는 설정된 경우 &lt;a href=&quot;../prop_gbl/debug_configurations#prop_gbl:DEBUG_CONFIGURATIONS&quot; id=&quot;index-1-prop_gbl:DEBUG_CONFIGURATIONS&quot;&gt; &lt;code&gt;DEBUG_CONFIGURATIONS&lt;/code&gt; &lt;/a&gt; 글로벌 특성에 나열된 구성에 해당하는 특성) 에도 추가됩니다 . &lt;code&gt;optimized&lt;/code&gt; 것으로 지정된 라이브러리 는 &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-4-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; 특성에 추가됩니다 . 정책 &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-4-policy:CMP0022&quot;&gt; &lt;code&gt;CMP0022&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;NEW&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-4-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt; &lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt; &lt;/a&gt; 특성 에도 추가됩니다 . &lt;code&gt;general&lt;/code&gt; 지정된 라이브러리(또는 키워드가없는)는 &lt;code&gt;debug&lt;/code&gt; 및 &lt;code&gt;optimized&lt;/code&gt; 모두에 지정된 것처럼 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="c709b0760084759d9153ea402bc8eb230f599f15" translate="yes" xml:space="preserve">
          <source>Libraries to link to GDAL.</source>
          <target state="translated">GDAL에 링크 할 라이브러리</target>
        </trans-unit>
        <trans-unit id="06115790112b5497766706fec699af1b08cf680b" translate="yes" xml:space="preserve">
          <source>Library Output Artifacts</source>
          <target state="translated">라이브러리 출력 아티팩트</target>
        </trans-unit>
        <trans-unit id="ca6b67c2df13230a64623dcad428f2bd48ab54ef" translate="yes" xml:space="preserve">
          <source>Library dependencies are transitive by default with this signature. When this target is linked into another target then the libraries linked to this target will appear on the link line for the other target too. This transitive &amp;ldquo;link interface&amp;rdquo; is stored in the &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt;&lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt;&lt;/a&gt; target property and may be overridden by setting the property directly. When &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-0-policy:CMP0022&quot;&gt;&lt;code&gt;CMP0022&lt;/code&gt;&lt;/a&gt; is not set to &lt;code&gt;NEW&lt;/code&gt;, transitive linking is built in but may be overridden by the &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt;&lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt;&lt;/a&gt; property. Calls to other signatures of this command may set the property making any libraries linked exclusively by this signature private.</source>
          <target state="translated">기본적으로 라이브러리 종속성은이 서명으로 전이됩니다. 이 대상이 다른 대상에 연결되면이 대상에 연결된 라이브러리가 다른 대상에 대한 링크에도 나타납니다. 이 전 이적 &quot;링크 인터페이스&quot;는 &lt;a href=&quot;../prop_tgt/interface_link_libraries#prop_tgt:INTERFACE_LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:INTERFACE_LINK_LIBRARIES&quot;&gt; &lt;code&gt;INTERFACE_LINK_LIBRARIES&lt;/code&gt; &lt;/a&gt; 대상 속성에 저장되며 속성을 직접 설정하여 무시할 수 있습니다. 때 &lt;a href=&quot;../policy/cmp0022#policy:CMP0022&quot; id=&quot;index-0-policy:CMP0022&quot;&gt; &lt;code&gt;CMP0022&lt;/code&gt; 가&lt;/a&gt; 설정되어 있지 않습니다 &lt;code&gt;NEW&lt;/code&gt; , 이적 연결이 내장되어 있지만, 오버라이드 (override) 할 수 &lt;a href=&quot;../prop_tgt/link_interface_libraries#prop_tgt:LINK_INTERFACE_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_INTERFACE_LIBRARIES&quot;&gt; &lt;code&gt;LINK_INTERFACE_LIBRARIES&lt;/code&gt; 의&lt;/a&gt; 속성입니다. 이 명령의 다른 서명을 호출하면이 서명에 의해 독점적으로 링크 된 라이브러리를 비공개로 설정하는 속성이 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce163c3c844e03ab561b26e440d65b63e01841e5" translate="yes" xml:space="preserve">
          <source>License to be embedded in the installer. It will typically be displayed to the user by the produced installer (often with an explicit &amp;ldquo;Accept&amp;rdquo; button, for graphical installers) prior to installation. This license file is NOT added to the installed files but is used by some CPack generators like NSIS. If you want to install a license file (may be the same as this one) along with your project, you must add an appropriate CMake &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command in your &lt;code&gt;CMakeLists.txt&lt;/code&gt;.</source>
          <target state="translated">설치 프로그램에 포함 할 라이센스. 일반적으로 설치하기 전에 제작 된 설치 관리자 (종종 그래픽 설치 프로그램의 경우 명시 적 &quot;수락&quot;버튼 사용)에 의해 사용자에게 표시됩니다. 이 라이센스 파일은 설치된 파일에 추가되지 않지만 NSIS와 같은 일부 CPack 생성기에서 사용됩니다. 프로젝트와 함께 라이센스 파일 (이 파일과 동일 할 수 있음)을 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-1-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;CMakeLists.txt&lt;/code&gt; 에 적절한 CMake install () 명령을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f352328f675c8fd36fb0b57681f635429542821f" translate="yes" xml:space="preserve">
          <source>License to be embedded in the installer. It will typically be displayed to the user by the produced installer (often with an explicit &amp;ldquo;Accept&amp;rdquo; button, for graphical installers) prior to installation. This license file is NOT added to the installed files but is used by some CPack generators like NSIS. If you want to install a license file (may be the same as this one) along with your project, you must add an appropriate CMake &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; command in your &lt;code&gt;CMakeLists.txt&lt;/code&gt;.</source>
          <target state="translated">설치 프로그램에 포함 할 라이센스입니다. 일반적으로 설치 전에 생성 된 설치 프로그램 (그래픽 설치 프로그램의 경우 명시적인 &quot;수락&quot;단추를 사용)에 의해 사용자에게 표시됩니다. 이 라이센스 파일은 설치된 파일에 추가되지 않지만 NSIS와 같은 일부 CPack 생성기에서 사용됩니다. 프로젝트와 함께 라이선스 파일 (이 파일과 동일 할 수 있음)을 &lt;a href=&quot;../command/install#command:install&quot; id=&quot;index-2-command:install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;CMakeLists.txt&lt;/code&gt; 에 적절한 CMake install () 명령을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9fc9c5a7d8326df046caa8d770d0b0dc0dbc12f4" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD 3-clause License.</source>
          <target state="translated">BSD 3 절 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="e20a81f6afd3fae0c59c38944ac6767fd62525b0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--trace&lt;/code&gt;, but with variables expanded.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--trace&lt;/code&gt; 하지만 변수로 확장.</target>
        </trans-unit>
        <trans-unit id="7fa7519fd60587f27eeeb3830c6632412281a7fe" translate="yes" xml:space="preserve">
          <source>Like build specifications, &lt;a href=&quot;../prop_tgt/link_libraries#prop_tgt:LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_LIBRARIES&quot;&gt;&lt;code&gt;link libraries&lt;/code&gt;&lt;/a&gt; may be specified with generator expression conditions. However, as consumption of usage requirements is based on collection from linked dependencies, there is an additional limitation that the link dependencies must form a &amp;ldquo;directed acyclic graph&amp;rdquo;. That is, if linking to a target is dependent on the value of a target property, that target property may not be dependent on the linked dependencies:</source>
          <target state="translated">빌드 스펙과 마찬가지로 &lt;a href=&quot;../prop_tgt/link_libraries#prop_tgt:LINK_LIBRARIES&quot; id=&quot;index-0-prop_tgt:LINK_LIBRARIES&quot;&gt; &lt;code&gt;link libraries&lt;/code&gt; &lt;/a&gt; 는 생성기 표현식 조건으로 지정할 수 있습니다. 그러나 사용 요구 사항 소비는 링크 된 종속성의 콜렉션을 기반으로하기 때문에 링크 종속성이 &quot;지시 된 비순환 그래프&quot;를 형성해야한다는 추가 제한 사항이 있습니다. 즉, 대상에 연결하는 것이 대상 속성의 값에 의존하는 경우 해당 대상 속성은 연결된 종속성에 의존하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c61f2d88449b24792933c53c3ca5cd4c331181" translate="yes" xml:space="preserve">
          <source>Limit the number of distinct strings to be extracted.</source>
          <target state="translated">추출 할 고유 문자열의 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="0d030f1ce0ccb1a363316bcd988f700f7adba65c" translate="yes" xml:space="preserve">
          <source>Limit the number of input bytes to read from the file.</source>
          <target state="translated">파일에서 읽을 입력 바이트 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="8ee50303c4ddfddbb00406211f00133c89003342" translate="yes" xml:space="preserve">
          <source>Limit the number of total bytes to store in the &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 에 저장할 총 바이트 수를 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="add5aa8287282db812baa350d4df83c631b5b90e" translate="yes" xml:space="preserve">
          <source>Limit the output for failed tests to &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; bytes.</source>
          <target state="translated">실패한 테스트의 출력을 &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; 바이트로 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="51317cc26f371b435b137e2748387d95729495b2" translate="yes" xml:space="preserve">
          <source>Limit the output for passed tests to &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; bytes.</source>
          <target state="translated">전달 된 테스트의 출력을 &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; 바이트로 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="52c0a2f3a058b234bb1af57941e3f1c4df61c56c" translate="yes" xml:space="preserve">
          <source>Limitations:</source>
          <target state="translated">Limitations:</target>
        </trans-unit>
        <trans-unit id="de88e6cb0c37e7eccb7bafa70f3d7b501270c9b2" translate="yes" xml:space="preserve">
          <source>Line 1 loads the target CMake file. Although we only exported a single target, this file may import any number of targets. Their locations are computed relative to the file location so that the install tree may be easily moved. Line 3 references the imported &lt;code&gt;MathFunctions&lt;/code&gt; library. The resulting build system will link to the library from its installed location.</source>
          <target state="translated">1 행은 대상 CMake 파일을로드합니다. 단일 대상 만 내보냈지만이 파일은 여러 대상을 가져올 수 있습니다. 설치 트리를 쉽게 이동할 수 있도록 해당 위치는 파일 위치를 기준으로 계산됩니다. 3 행은 가져온 &lt;code&gt;MathFunctions&lt;/code&gt; 라이브러리를 참조합니다 . 결과 빌드 시스템은 설치된 위치에서 라이브러리로 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7983cc27bfad92522c4689e8fce94e2c7241a2" translate="yes" xml:space="preserve">
          <source>Line Comment</source>
          <target state="translated">라인 코멘트</target>
        </trans-unit>
        <trans-unit id="d04a3fe528bdb5fe9ea62798df9b0dad04583c4a" translate="yes" xml:space="preserve">
          <source>Line number in the file where the backtrace was added.</source>
          <target state="translated">역 추적이 추가 된 파일의 줄 번호</target>
        </trans-unit>
        <trans-unit id="ee718585268b0a865f1a2143d226cdf80de7dcd7" translate="yes" xml:space="preserve">
          <source>Link Libraries and Generator Expressions</source>
          <target state="translated">라이브러리 및 생성기 링크 연결</target>
        </trans-unit>
        <trans-unit id="cf1b25d2af3b2317b872b27fb369aca91c0011b5" translate="yes" xml:space="preserve">
          <source>Link dependency files usage requirements commonly differ between the build-tree and the install-tree. The &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; and &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; generator expressions can be used to describe separate usage requirements based on the usage location. Relative paths are allowed within the &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; expression and are interpreted relative to the installation prefix. For example:</source>
          <target state="translated">링크 종속성 파일 사용 요구 사항은 일반적으로 빌드 트리와 설치 트리간에 다릅니다. &lt;code&gt;BUILD_INTERFACE&lt;/code&gt; 및 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 발전기 표현은 사용 위치에 따라 별도의 사용 요구 사항을 설명하는 데 사용 할 수 있습니다. 상대 경로는 &lt;code&gt;INSTALL_INTERFACE&lt;/code&gt; 표현식 내에서 허용 되며 설치 접 두부와 관련하여 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33752246473e44877194f4c9ccca77da1be8eb56" translate="yes" xml:space="preserve">
          <source>Link flags specified here are inserted into the link command in the same place as the link libraries. This might not be correct, depending on the linker. Use the &lt;a href=&quot;../prop_tgt/link_options#prop_tgt:LINK_OPTIONS&quot; id=&quot;index-0-prop_tgt:LINK_OPTIONS&quot;&gt;&lt;code&gt;LINK_OPTIONS&lt;/code&gt;&lt;/a&gt; target property or &lt;a href=&quot;target_link_options#command:target_link_options&quot; id=&quot;index-0-command:target_link_options&quot;&gt;&lt;code&gt;target_link_options()&lt;/code&gt;&lt;/a&gt; command to add link flags explicitly. The flags will then be placed at the toolchain-defined flag position in the link command.</source>
          <target state="translated">여기에 지정된 링크 플래그는 링크 라이브러리와 같은 위치에 링크 명령에 삽입됩니다. 링커에 따라 올바르지 않을 수 있습니다. 링크 플래그를 명시 적으로 추가 하려면 &lt;a href=&quot;../prop_tgt/link_options#prop_tgt:LINK_OPTIONS&quot; id=&quot;index-0-prop_tgt:LINK_OPTIONS&quot;&gt; &lt;code&gt;LINK_OPTIONS&lt;/code&gt; &lt;/a&gt; 대상 특성 또는 &lt;a href=&quot;target_link_options#command:target_link_options&quot; id=&quot;index-0-command:target_link_options&quot;&gt; &lt;code&gt;target_link_options()&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오. 그러면 플래그는 링크 명령에서 툴체인 정의 플래그 위치에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="83359e6ad72de707c3a2f1ef1482680899ef79f1" translate="yes" xml:space="preserve">
          <source>Link libraries by full path even in implicit directories.</source>
          <target state="translated">암시 적 디렉토리에서도 전체 경로로 라이브러리를 링크하십시오.</target>
        </trans-unit>
        <trans-unit id="14083047b165d39e704fd9d398460fe872c9caa3" translate="yes" xml:space="preserve">
          <source>Link libraries to all targets added later.</source>
          <target state="translated">나중에 추가 된 모든 대상에 라이브러리를 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="fba1336f71e3b8d8812bc5830620a3de3e3846b0" translate="yes" xml:space="preserve">
          <source>Link libraries to swig module:</source>
          <target state="translated">라이브러리를 Swig 모듈에 연결 :</target>
        </trans-unit>
        <trans-unit id="2d07a6a8b36cd3ae8edb0887e25115aeeb4da214" translate="yes" xml:space="preserve">
          <source>Link the target using the C++ linker tool (obsolete).</source>
          <target state="translated">C ++ 링커 도구 (더 이상 사용되지 않음)를 사용하여 대상을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="e0c454888d257808ea084fbec2b78eb410b84da6" translate="yes" xml:space="preserve">
          <source>Link these to use BZip2</source>
          <target state="translated">BZip2를 사용하기 위해 링크</target>
        </trans-unit>
        <trans-unit id="7924c2fc63d8b06519c041c2ec246f61b485c603" translate="yes" xml:space="preserve">
          <source>Link to these if you need to link against the exslt library.</source>
          <target state="translated">exslt 라이브러리에 연결해야하는 경우 이들에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="59ec70fbd649c685c55088fb883eab5ccb35bc39" translate="yes" xml:space="preserve">
          <source>Link with &lt;code&gt;-cudart=none&lt;/code&gt; or equivalent flag(s) to use no CUDA runtime library.</source>
          <target state="translated">CUDA 런타임 라이브러리를 사용하지 &lt;code&gt;-cudart=none&lt;/code&gt; 또는 이와 동등한 플래그로 링크하십시오 .</target>
        </trans-unit>
        <trans-unit id="deb89ee46e96906174c4a9ac0d4e1b6da16bab12" translate="yes" xml:space="preserve">
          <source>Link with &lt;code&gt;-cudart=shared&lt;/code&gt; or equivalent flag(s) to use a dynamically-linked CUDA runtime library.</source>
          <target state="translated">와 링크 &lt;code&gt;-cudart=shared&lt;/code&gt; 또는 이에 상응하는 플래그 (들)을 동적으로 링크 된 CUDA 런타임 라이브러리를 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d068d4ea382da4de6bd9225e40926898dec251ae" translate="yes" xml:space="preserve">
          <source>Link with &lt;code&gt;-cudart=static&lt;/code&gt; or equivalent flag(s) to use a statically-linked CUDA runtime library.</source>
          <target state="translated">와 링크 &lt;code&gt;-cudart=static&lt;/code&gt; 또는 이에 상응하는 플래그 (들)은 정적으로 링크 CUDA 런타임 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd8775a4b04b16dd310081e33a82811f46683343" translate="yes" xml:space="preserve">
          <source>Linker flag to be used to specify a &lt;code&gt;.def&lt;/code&gt; file for dll creation.</source>
          <target state="translated">dll 생성을위한 &lt;code&gt;.def&lt;/code&gt; 파일 을 지정하는 데 사용되는 링커 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="5f40c95d128f8d0b322f7abd1a9f30c68b3fcd15" translate="yes" xml:space="preserve">
          <source>Linker flags for MPI programs.</source>
          <target state="translated">MPI 프로그램의 링커 플래그.</target>
        </trans-unit>
        <trans-unit id="5c00b3b7b8e668799ba268c093ac3bbe6cf568f8" translate="yes" xml:space="preserve">
          <source>Linker flags to be used to create executables.</source>
          <target state="translated">실행 파일을 만드는 데 사용되는 링커 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="60e98971e6c589c940537f70b749bf8d3bc026da" translate="yes" xml:space="preserve">
          <source>Linker flags to be used to create modules.</source>
          <target state="translated">모듈을 만드는 데 사용되는 링커 플래그.</target>
        </trans-unit>
        <trans-unit id="c2bf79d512366ac0e24e9710bf0fb67a79bea2b3" translate="yes" xml:space="preserve">
          <source>Linker flags to be used to create shared libraries.</source>
          <target state="translated">공유 라이브러리를 작성하는 데 사용되는 링커 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="b8ac2eefa8bef732f5ce615412014b8948247a35" translate="yes" xml:space="preserve">
          <source>Linker flags to be used to create static libraries.</source>
          <target state="translated">정적 라이브러리를 작성하는 데 사용되는 링커 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="efcbb30ef14dcce7a4053fc793959e787134b546" translate="yes" xml:space="preserve">
          <source>Linking Object Libraries</source>
          <target state="translated">객체 라이브러리 연결</target>
        </trans-unit>
        <trans-unit id="b3bff7095e80135ddc8d8585d859c9f31cf78f34" translate="yes" xml:space="preserve">
          <source>Links to available documentation and community resources may be found on this web page.</source>
          <target state="translated">사용 가능한 문서 및 커뮤니티 리소스에 대한 링크는이 웹 페이지에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370441f3fd35c3b9beef515e04ebf5bbea33eb54" translate="yes" xml:space="preserve">
          <source>Linux-specific</source>
          <target state="translated">Linux-specific</target>
        </trans-unit>
        <trans-unit id="fdde76936d4b5732be629827a3727f3c2fad9dfc" translate="yes" xml:space="preserve">
          <source>List &lt;code&gt;CACHE&lt;/code&gt; variables will run CMake and list all the variables from the CMake &lt;code&gt;CACHE&lt;/code&gt; that are not marked as &lt;code&gt;INTERNAL&lt;/code&gt; or &lt;a href=&quot;../prop_cache/advanced#prop_cache:ADVANCED&quot; id=&quot;index-0-prop_cache:ADVANCED&quot;&gt;&lt;code&gt;ADVANCED&lt;/code&gt;&lt;/a&gt;. This will effectively display current CMake settings, which can then be changed with &lt;code&gt;-D&lt;/code&gt; option. Changing some of the variables may result in more variables being created. If &lt;code&gt;A&lt;/code&gt; is specified, then it will display also advanced variables. If &lt;code&gt;H&lt;/code&gt; is specified, it will also display help for each variable.</source>
          <target state="translated">&lt;code&gt;CACHE&lt;/code&gt; 변수 나열 은 CMake를 실행 하고 &lt;code&gt;INTERNAL&lt;/code&gt; 또는 &lt;a href=&quot;../prop_cache/advanced#prop_cache:ADVANCED&quot; id=&quot;index-0-prop_cache:ADVANCED&quot;&gt; &lt;code&gt;ADVANCED&lt;/code&gt; &lt;/a&gt; 로 표시되지 않은 CMake &lt;code&gt;CACHE&lt;/code&gt; 의 모든 변수를 나열합니다 . 현재 CMake 설정을 효과적으로 표시 한 다음 &lt;code&gt;-D&lt;/code&gt; 옵션 으로 변경할 수 있습니다 . 일부 변수를 변경하면 더 많은 변수가 작성 될 수 있습니다. 경우 &lt;code&gt;A&lt;/code&gt; 를 지정하면 그것은 또한 고급 변수를 표시합니다. 경우 &lt;code&gt;H&lt;/code&gt; 가 지정, 그것은 또한 각 변수에 대한 도움말을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4dc48f438aae2cd9880c9a9748d49daeaa79adf3" translate="yes" xml:space="preserve">
          <source>List TARGET_OBJECTS in SOURCES target property.</source>
          <target state="translated">SOURCES 대상 특성에 TARGET_OBJECTS를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="a025a8b217f304b78cb2f0fdd5f2c0720f013546" translate="yes" xml:space="preserve">
          <source>List additional properties to export for a target.</source>
          <target state="translated">대상으로 내보낼 추가 속성을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="c1abc7d41ba446ca12b616918bc7ded62ca0189d" translate="yes" xml:space="preserve">
          <source>List archive contents. The &lt;code&gt;&amp;lt;pathname&amp;gt;...&lt;/code&gt; argument could be used to list only selected files or directories.</source>
          <target state="translated">보관 내용을 나열합니다. &lt;code&gt;&amp;lt;pathname&amp;gt;...&lt;/code&gt; 인수는 목록에 선택된 파일이나 디렉토리에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="6b537b87099043cc63ef054045ade58c2f8c6ca2" translate="yes" xml:space="preserve">
          <source>List commands with help available and exit.</source>
          <target state="translated">사용 가능한 도움말과 함께 명령을 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="ec8be6cdc3f4b8e0deb5cfb4a1c67709509e3570" translate="yes" xml:space="preserve">
          <source>List help manuals available and exit.</source>
          <target state="translated">사용 가능한 도움말 설명서를 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="d2aaa4dc59293f80eead68f2dee3a02a6bd1f441" translate="yes" xml:space="preserve">
          <source>List modules with help available and exit.</source>
          <target state="translated">사용 가능한 도움말이있는 모듈을 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a09c50f043c7cc560e4b93dcf230360cd50c4b9c" translate="yes" xml:space="preserve">
          <source>List non-advanced cached variables.</source>
          <target state="translated">고급 캐시되지 않은 변수를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="fbba8e27d2c1e7f3d5ed08725e9cf83a607fdc49" translate="yes" xml:space="preserve">
          <source>List of &lt;code&gt;Key=Value&lt;/code&gt; records to be set per target as target properties &lt;code&gt;VS_GLOBAL_&amp;lt;variable&amp;gt;&lt;/code&gt; with &lt;code&gt;variable=Key&lt;/code&gt; and value &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;variable=Key&lt;/code&gt; 및 value &lt;code&gt;Value&lt;/code&gt; 를 가진 대상 특성 &lt;code&gt;VS_GLOBAL_&amp;lt;variable&amp;gt;&lt;/code&gt; 으로 대상 당 설정할 &lt;code&gt;Key=Value&lt;/code&gt; 레코드 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="915df2f87fff454b88d546d3ebff01f1a089458f" translate="yes" xml:space="preserve">
          <source>List of C features known to this version of CMake.</source>
          <target state="translated">이 CMake 버전에 알려진 C 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a9cb1eebec9a08b3ce31ea034a369ba0289994b2" translate="yes" xml:space="preserve">
          <source>List of C++ features known to this version of CMake.</source>
          <target state="translated">이 CMake 버전에 알려진 C ++ 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="134e92ada5709426f1cea34a5c25490c0bc22cf0" translate="yes" xml:space="preserve">
          <source>List of CMake scripts to execute after CPack has installed the files to be packaged into a staging directory and before producing the package(s) from those files. See also &lt;a href=&quot;#variable:CPACK_INSTALL_SCRIPTS&quot; id=&quot;index-0-variable:CPACK_INSTALL_SCRIPTS&quot;&gt;&lt;code&gt;CPACK_INSTALL_SCRIPTS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variable:CPACK_POST_BUILD_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_POST_BUILD_SCRIPTS&quot;&gt;&lt;code&gt;CPACK_POST_BUILD_SCRIPTS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CPack이 스테이징 디렉토리에 패키징 할 파일을 설치 한 후 해당 파일에서 패키지를 생성하기 전에 실행할 CMake 스크립트 목록입니다. &lt;a href=&quot;#variable:CPACK_INSTALL_SCRIPTS&quot; id=&quot;index-0-variable:CPACK_INSTALL_SCRIPTS&quot;&gt; &lt;code&gt;CPACK_INSTALL_SCRIPTS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#variable:CPACK_POST_BUILD_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_POST_BUILD_SCRIPTS&quot;&gt; &lt;code&gt;CPACK_POST_BUILD_SCRIPTS&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b927f6b89abdb56b0ec03be555fe13b067cb6f9a" translate="yes" xml:space="preserve">
          <source>List of CMake scripts to execute after CPack has produced the resultant packages and before copying them back to the build directory. See also &lt;a href=&quot;#variable:CPACK_INSTALL_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_INSTALL_SCRIPTS&quot;&gt;&lt;code&gt;CPACK_INSTALL_SCRIPTS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#variable:CPACK_PRE_BUILD_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_PRE_BUILD_SCRIPTS&quot;&gt;&lt;code&gt;CPACK_PRE_BUILD_SCRIPTS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#variable:CPACK_PACKAGE_FILES&quot; id=&quot;index-0-variable:CPACK_PACKAGE_FILES&quot;&gt;&lt;code&gt;CPACK_PACKAGE_FILES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CPack이 결과 패키지를 생성 한 후 빌드 디렉터리로 다시 복사하기 전에 실행할 CMake 스크립트 목록입니다. &lt;a href=&quot;#variable:CPACK_INSTALL_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_INSTALL_SCRIPTS&quot;&gt; &lt;code&gt;CPACK_INSTALL_SCRIPTS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#variable:CPACK_PRE_BUILD_SCRIPTS&quot; id=&quot;index-1-variable:CPACK_PRE_BUILD_SCRIPTS&quot;&gt; &lt;code&gt;CPACK_PRE_BUILD_SCRIPTS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#variable:CPACK_PACKAGE_FILES&quot; id=&quot;index-0-variable:CPACK_PACKAGE_FILES&quot;&gt; &lt;code&gt;CPACK_PACKAGE_FILES&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebeb870d8d6a741199511c8afa6997886bd1f7bd" translate="yes" xml:space="preserve">
          <source>List of CPack generators to use. If not specified, CPack will create a set of options following the naming pattern &lt;a href=&quot;#variable:CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&quot; id=&quot;index-0-variable:CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&quot;&gt;&lt;code&gt;CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;CPACK_BINARY_NSIS&lt;/code&gt;) allowing the user to enable/disable individual generators. If the &lt;code&gt;-G&lt;/code&gt; option is given on the &lt;a href=&quot;../manual/cpack.1#manual:cpack(1)&quot; id=&quot;index-4-manual:cpack(1)&quot;&gt;&lt;code&gt;cpack&lt;/code&gt;&lt;/a&gt; command line, it will override this variable and any &lt;code&gt;CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&lt;/code&gt; options.</source>
          <target state="translated">사용할 CPack 생성기 목록 지정하지 않으면 CPack은 이름 지정 패턴 &lt;a href=&quot;#variable:CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&quot; id=&quot;index-0-variable:CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&quot;&gt; &lt;code&gt;CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&lt;/code&gt; &lt;/a&gt; (예 : &lt;code&gt;CPACK_BINARY_NSIS&lt;/code&gt; )에 따라 사용자가 개별 생성기를 활성화 / 비활성화 할 수있는 옵션 세트를 작성합니다 . 경우 &lt;code&gt;-G&lt;/code&gt; 옵션이에 기재되어 있습니다 &lt;a href=&quot;../manual/cpack.1#manual:cpack(1)&quot; id=&quot;index-4-manual:cpack(1)&quot;&gt; &lt;code&gt;cpack&lt;/code&gt; 의&lt;/a&gt; 명령 줄,이 변수 및 재정의합니다 &lt;code&gt;CPACK_BINARY_&amp;lt;GENNAME&amp;gt;&lt;/code&gt; 옵션을.</target>
        </trans-unit>
        <trans-unit id="f5e63eec28c4bad3cecd4eef7b93d40da1dd80f0" translate="yes" xml:space="preserve">
          <source>List of CUDA features known to this version of CMake.</source>
          <target state="translated">이 버전의 CMake에 알려진 CUDA 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c1ce195e071f38f585a1192c5903ddb7b679d85a" translate="yes" xml:space="preserve">
          <source>List of absolute paths of all files currently on the stack of file inclusion, with the bottom-most file first and the currently processed file (that is, &lt;code&gt;current_list_file&lt;/code&gt;) last.</source>
          <target state="translated">현재 파일 포함 스택에있는 모든 파일의 절대 경로 목록입니다. 맨 아래 파일이 먼저이고 현재 처리 된 파일 (즉, &lt;code&gt;current_list_file&lt;/code&gt; )이 마지막에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd671b1ceed778c01ed034278f2055d8993d58f" translate="yes" xml:space="preserve">
          <source>List of additional directories to be searched for imported .proto files.</source>
          <target state="translated">가져온 .proto 파일을 검색 할 추가 디렉토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c10ae89d5d7a6cb4871964ad645e45d92a10bb0f" translate="yes" xml:space="preserve">
          <source>List of additional directories to search for dependencies. On Linux platforms, these directories are searched if the dependency is not found in any of the other usual paths. If it is found in such a directory, a warning is issued, because it means that the file is incomplete (it does not list all of the directories that contain its dependencies). On Windows platforms, these directories are searched if the dependency is not found in any of the other search paths, but no warning is issued, because searching other paths is a normal part of Windows dependency resolution. On Apple platforms, this argument has no effect.</source>
          <target state="translated">종속성을 검색 할 추가 디렉토리 목록입니다. Linux 플랫폼에서는 다른 일반적인 경로에서 종속성이 발견되지 않으면 이러한 디렉토리가 검색됩니다. 이러한 디렉토리에서 발견되면 파일이 불완전 함을 의미하므로 경고가 발행됩니다 (종속성을 포함하는 모든 디렉토리를 나열하지 않음). Windows 플랫폼에서 다른 검색 경로에서 종속성이 발견되지 않으면 이러한 디렉토리가 검색되지만 다른 경로 검색은 Windows 종속성 해결의 일반적인 부분이므로 경고가 발생하지 않습니다. Apple 플랫폼에서이 인수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dc4569891b36fef8b6d93bc0ad9e73cc2459551" translate="yes" xml:space="preserve">
          <source>List of additional options to pass to the compiler.</source>
          <target state="translated">컴파일러에 전달할 추가 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6f28890a8812a2d74e3437708bc18ae8eb848d9b" translate="yes" xml:space="preserve">
          <source>List of all source files which are relevant for setting the &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; properties (including &lt;code&gt;.cs&lt;/code&gt;, &lt;code&gt;.resx&lt;/code&gt; and &lt;code&gt;.Designer.cs&lt;/code&gt; extensions).</source>
          <target state="translated">&lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; 특성 ( &lt;code&gt;.cs&lt;/code&gt; , &lt;code&gt;.resx&lt;/code&gt; 및 &lt;code&gt;.Designer.cs&lt;/code&gt; 확장자 포함) 설정과 관련된 모든 소스 파일 목록 .</target>
        </trans-unit>
        <trans-unit id="0d7f0489b33c1aaa23ffb3dabbf745313bc7c84d" translate="yes" xml:space="preserve">
          <source>List of all source files which are relevant for setting the &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; properties (including &lt;code&gt;.cs&lt;/code&gt;, &lt;code&gt;.resx&lt;/code&gt;, &lt;code&gt;.settings&lt;/code&gt; and &lt;code&gt;.Designer.cs&lt;/code&gt; extensions).</source>
          <target state="translated">설정에 관련된 모든 소스 파일 목록 &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; (포함 속성 &lt;code&gt;.cs&lt;/code&gt; , &lt;code&gt;.resx&lt;/code&gt; , &lt;code&gt;.settings&lt;/code&gt; 및 &lt;code&gt;.Designer.cs&lt;/code&gt; 의 확장).</target>
        </trans-unit>
        <trans-unit id="5132d66809ea5e79e4b772bef7578b957e31b14e" translate="yes" xml:space="preserve">
          <source>List of all source files which are relevant for setting the &lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; properties (including &lt;code&gt;.cs&lt;/code&gt;, &lt;code&gt;.xaml&lt;/code&gt;, and &lt;code&gt;.xaml.cs&lt;/code&gt; extensions).</source>
          <target state="translated">&lt;code&gt;VS_CSHARP_&amp;lt;tagname&amp;gt;&lt;/code&gt; 특성 ( &lt;code&gt;.cs&lt;/code&gt; , &lt;code&gt;.xaml&lt;/code&gt; 및 &lt;code&gt;.xaml.cs&lt;/code&gt; 확장자 포함) 설정과 관련된 모든 소스 파일 목록 .</target>
        </trans-unit>
        <trans-unit id="7ff26866cfbea9e91258582fd8af4cf6e10bb2fa" translate="yes" xml:space="preserve">
          <source>List of architectures to generate device code for.</source>
          <target state="translated">장치 코드를 생성 할 아키텍처 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e88c45bc1851bd78ba66ec0646eaa510ec364553" translate="yes" xml:space="preserve">
          <source>List of cache variables available in the current directory.</source>
          <target state="translated">현재 디렉토리에서 사용 가능한 캐시 변수 목록</target>
        </trans-unit>
        <trans-unit id="8c2aa33f8853a72274e522af0c187d0e27ec3f2e" translate="yes" xml:space="preserve">
          <source>List of command names.</source>
          <target state="translated">명령 이름 목록</target>
        </trans-unit>
        <trans-unit id="195342bce7ade901a916858e8e538cae3bb39814" translate="yes" xml:space="preserve">
          <source>List of desktop links to create. Each desktop link requires a corresponding start menu shortcut as created by &lt;a href=&quot;#variable:CPACK_PACKAGE_EXECUTABLES&quot; id=&quot;index-0-variable:CPACK_PACKAGE_EXECUTABLES&quot;&gt;&lt;code&gt;CPACK_PACKAGE_EXECUTABLES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만들 데스크톱 링크 목록입니다. 각 데스크탑 링크에는 &lt;a href=&quot;#variable:CPACK_PACKAGE_EXECUTABLES&quot; id=&quot;index-0-variable:CPACK_PACKAGE_EXECUTABLES&quot;&gt; &lt;code&gt;CPACK_PACKAGE_EXECUTABLES&lt;/code&gt; 에&lt;/a&gt; 의해 작성된 해당 시작 메뉴 바로 가기가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="50067f05db2343c467e1356119fbd2d6bc0b2308" translate="yes" xml:space="preserve">
          <source>List of direct link dependencies.</source>
          <target state="translated">직접 링크 종속성 목록</target>
        </trans-unit>
        <trans-unit id="adb417d50f7ac59698590014e9a49cefe69cdd46" translate="yes" xml:space="preserve">
          <source>List of directories to use for the link step of shared library, module and executable targets.</source>
          <target state="translated">공유 라이브러리, 모듈 및 실행 가능 대상의 링크 단계에 사용할 디렉토리 목록.</target>
        </trans-unit>
        <trans-unit id="c31d069636aa94d8e23d4c7610e109c56467745c" translate="yes" xml:space="preserve">
          <source>List of executable files to read for dependencies. These are executables that are typically created with &lt;a href=&quot;add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt;&lt;code&gt;add_executable()&lt;/code&gt;&lt;/a&gt;, but they do not have to be created by CMake. On Apple platforms, the paths to these files determine the value of &lt;code&gt;@executable_path&lt;/code&gt; when recursively resolving the libraries. Specifying any kind of library (&lt;code&gt;STATIC&lt;/code&gt;, &lt;code&gt;MODULE&lt;/code&gt;, or &lt;code&gt;SHARED&lt;/code&gt;) here will result in undefined behavior.</source>
          <target state="translated">종속성을 읽을 실행 파일 목록입니다. 일반적으로 &lt;a href=&quot;add_executable#command:add_executable&quot; id=&quot;index-0-command:add_executable&quot;&gt; &lt;code&gt;add_executable()&lt;/code&gt; &lt;/a&gt; 으로 생성되는 실행 파일 이지만 CMake로 생성 할 필요는 없습니다. Apple 플랫폼에서 이러한 파일의 경로 는 라이브러리를 반복적 으로 &lt;code&gt;@executable_path&lt;/code&gt; 때 @executable_path 의 값을 결정합니다 . 여기에 모든 종류의 라이브러리 ( &lt;code&gt;STATIC&lt;/code&gt; , &lt;code&gt;MODULE&lt;/code&gt; 또는 &lt;code&gt;SHARED&lt;/code&gt; )를 지정하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e9956d2b2cc8b766abcb6054400c39a490f402d" translate="yes" xml:space="preserve">
          <source>List of features known to the C compiler</source>
          <target state="translated">C 컴파일러에 알려진 기능 목록</target>
        </trans-unit>
        <trans-unit id="d538651b170b1224ef3f6c4993cbfc990e613466" translate="yes" xml:space="preserve">
          <source>List of features known to the C++ compiler</source>
          <target state="translated">C ++ 컴파일러에 알려진 기능 목록</target>
        </trans-unit>
        <trans-unit id="a29b36947e0173d7331688d7e60ec92883f40ddf" translate="yes" xml:space="preserve">
          <source>List of features known to the CUDA compiler</source>
          <target state="translated">CUDA 컴파일러에 알려진 기능 목록</target>
        </trans-unit>
        <trans-unit id="6cfb9370da805cbbf35f87fd0fae202e1f563767" translate="yes" xml:space="preserve">
          <source>List of features which are disabled during the CMake run.</source>
          <target state="translated">CMake 실행 중에 비활성화 된 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="96006cfd7ef5e512f99dd9909a27ac6094dbc39d" translate="yes" xml:space="preserve">
          <source>List of features which are disabled during the CMake run. By default it contains the names of all packages which were not found. This is determined using the &lt;code&gt;&amp;lt;NAME&amp;gt;_FOUND&lt;/code&gt; variables. Packages which are searched &lt;code&gt;QUIET&lt;/code&gt; are not listed. A project can add its own features to this list. This property is used by the macros in &lt;code&gt;FeatureSummary.cmake&lt;/code&gt;.</source>
          <target state="translated">CMake 실행 중에 비활성화 된 기능 목록입니다. 기본적으로 찾을 수없는 모든 패키지의 이름이 포함됩니다. 이것은 &lt;code&gt;&amp;lt;NAME&amp;gt;_FOUND&lt;/code&gt; 변수를 사용하여 결정됩니다 . &lt;code&gt;QUIET&lt;/code&gt; 으로 검색된 패키지가 나열되지 않습니다. 프로젝트는이 목록에 자체 기능을 추가 할 수 있습니다. 이 특성은 &lt;code&gt;FeatureSummary.cmake&lt;/code&gt; 의 매크로에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c70444e2e6956567714faa86689cfc0debfde384" translate="yes" xml:space="preserve">
          <source>List of features which are enabled during the CMake run.</source>
          <target state="translated">CMake 실행 중에 활성화되는 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4e1d7e880ed735b92e2f32efa64118ef827f031e" translate="yes" xml:space="preserve">
          <source>List of features which are enabled during the CMake run. By default it contains the names of all packages which were found. This is determined using the &lt;code&gt;&amp;lt;NAME&amp;gt;_FOUND&lt;/code&gt; variables. Packages which are searched &lt;code&gt;QUIET&lt;/code&gt; are not listed. A project can add its own features to this list. This property is used by the macros in &lt;code&gt;FeatureSummary.cmake&lt;/code&gt;.</source>
          <target state="translated">CMake 실행 중에 활성화되는 기능 목록입니다. 기본적으로 발견 된 모든 패키지의 이름이 포함됩니다. 이것은 &lt;code&gt;&amp;lt;NAME&amp;gt;_FOUND&lt;/code&gt; 변수를 사용하여 결정됩니다 . &lt;code&gt;QUIET&lt;/code&gt; 으로 검색된 패키지가 나열되지 않습니다. 프로젝트는이 목록에 자체 기능을 추가 할 수 있습니다. 이 특성은 &lt;code&gt;FeatureSummary.cmake&lt;/code&gt; 의 매크로에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a7f1e9da8df69f074f8e124e9ae7140e19d657c" translate="yes" xml:space="preserve">
          <source>List of file names.</source>
          <target state="translated">파일 이름 목록</target>
        </trans-unit>
        <trans-unit id="a3cfcdc6c343c24fbe87ba8aca9cdda4b1cd1a77" translate="yes" xml:space="preserve">
          <source>List of files in the source tree that will be stripped. Starting with CMake 2.6.0, &lt;code&gt;CPACK_SOURCE_STRIP_FILES&lt;/code&gt; will be a boolean variable which enables stripping of all files (a list of files evaluates to &lt;code&gt;TRUE&lt;/code&gt; in CMake, so this change is compatible).</source>
          <target state="translated">소스 트리에서 제거 될 파일 목록. CMake 2.6.0부터 &lt;code&gt;CPACK_SOURCE_STRIP_FILES&lt;/code&gt; 는 모든 파일을 제거 할 수있는 부울 변수가 됩니다 (CMake에서는 파일 목록이 &lt;code&gt;TRUE&lt;/code&gt; 로 평가 되므로이 변경은 호환됩니다).</target>
        </trans-unit>
        <trans-unit id="0713f0e66444a60b68d57eb1329d3610a93120c4" translate="yes" xml:space="preserve">
          <source>List of files required to run the test.</source>
          <target state="translated">테스트를 실행하는 데 필요한 파일 목록</target>
        </trans-unit>
        <trans-unit id="5d281409a91fbae42c6a5d40afbf23296d870059" translate="yes" xml:space="preserve">
          <source>List of files required to run the test. The filenames are relative to the test &lt;a href=&quot;working_directory#prop_test:WORKING_DIRECTORY&quot; id=&quot;index-0-prop_test:WORKING_DIRECTORY&quot;&gt;&lt;code&gt;WORKING_DIRECTORY&lt;/code&gt;&lt;/a&gt; unless an absolute path is specified.</source>
          <target state="translated">테스트를 실행하는 데 필요한 파일 목록입니다. 절대 경로가 지정되지 않은 경우 파일 이름은 테스트 &lt;a href=&quot;working_directory#prop_test:WORKING_DIRECTORY&quot; id=&quot;index-0-prop_test:WORKING_DIRECTORY&quot;&gt; &lt;code&gt;WORKING_DIRECTORY&lt;/code&gt; 에&lt;/a&gt; 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="6f0a4464c42be55e78ee694af53c7cb45f10190c" translate="yes" xml:space="preserve">
          <source>List of files to be stripped. Starting with CMake 2.6.0, &lt;code&gt;CPACK_STRIP_FILES&lt;/code&gt; will be a boolean variable which enables stripping of all files (a list of files evaluates to &lt;code&gt;TRUE&lt;/code&gt; in CMake, so this change is compatible).</source>
          <target state="translated">제거 할 파일 목록. CMake 2.6.0부터 &lt;code&gt;CPACK_STRIP_FILES&lt;/code&gt; 는 모든 파일을 제거 할 수있는 부울 변수입니다 ( CMake에서는 파일 목록이 &lt;code&gt;TRUE&lt;/code&gt; 로 평가 되므로이 변경은 호환됩니다).</target>
        </trans-unit>
        <trans-unit id="50e719397ab892b587649543d2b80df31640a748" translate="yes" xml:space="preserve">
          <source>List of files which have been installed using an &lt;code&gt;ABSOLUTE DESTINATION&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;ABSOLUTE DESTINATION&lt;/code&gt; 경로를 사용하여 설치된 파일 목록 .</target>
        </trans-unit>
        <trans-unit id="e4ead512df46822a131f20422edf3867142d694e" translate="yes" xml:space="preserve">
          <source>List of four values that specify what project to install. The four values are: Build directory, Project Name, Project Component, Directory. If omitted, CPack will build an installer that installs everything.</source>
          <target state="translated">설치할 프로젝트를 지정하는 4 개의 값 목록. 네 가지 값은 빌드 디렉토리, 프로젝트 이름, 프로젝트 구성 요소, 디렉토리입니다. 생략하면 CPack은 모든 것을 설치하는 설치 프로그램을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="5afe2616a886cb197524ef8c90d4402e744ed06c" translate="yes" xml:space="preserve">
          <source>List of generators used for the source packages. As with &lt;a href=&quot;#variable:CPACK_GENERATOR&quot; id=&quot;index-8-variable:CPACK_GENERATOR&quot;&gt;&lt;code&gt;CPACK_GENERATOR&lt;/code&gt;&lt;/a&gt;, if this is not specified then CPack will create a set of options (e.g. &lt;code&gt;CPACK_SOURCE_ZIP&lt;/code&gt;) allowing users to select which packages will be generated.</source>
          <target state="translated">소스 패키지에 사용 된 생성기 목록 &lt;a href=&quot;#variable:CPACK_GENERATOR&quot; id=&quot;index-8-variable:CPACK_GENERATOR&quot;&gt; &lt;code&gt;CPACK_GENERATOR&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 , 이것을 지정하지 않으면 CPack은 사용자가 생성 할 패키지를 선택할 수있는 옵션 세트 (예 : &lt;code&gt;CPACK_SOURCE_ZIP&lt;/code&gt; )를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="efad7d5a007ff906b77a881264cfc9ba71a330e0" translate="yes" xml:space="preserve">
          <source>List of header files to precompile.</source>
          <target state="translated">사전 컴파일 할 헤더 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5a81164f2d731d66ce810f6c2e5f4090d022a8d8" translate="yes" xml:space="preserve">
          <source>List of instruction set architectures to generate code for.</source>
          <target state="translated">코드를 생성 할 명령어 세트 아키텍처 목록입니다.</target>
        </trans-unit>
        <trans-unit id="92759b8e3ff6cff83b2ee1110b8f32c767f70ded" translate="yes" xml:space="preserve">
          <source>List of interface header files to precompile into consuming targets.</source>
          <target state="translated">사용 대상으로 사전 컴파일 할 인터페이스 헤더 파일 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b58c5b7942a4d3e614b21fac34466c0251db3058" translate="yes" xml:space="preserve">
          <source>List of interface options to pass to uic.</source>
          <target state="translated">uic에 전달할 인터페이스 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="66f8d7e4959cd55fc4db905f1f6aa0dfe92ba9d0" translate="yes" xml:space="preserve">
          <source>List of interface sources to compile into consuming targets.</source>
          <target state="translated">소비 대상으로 컴파일 할 인터페이스 소스 목록</target>
        </trans-unit>
        <trans-unit id="a263d67d7dcf4130eb0596168022f4d29edfb2d3" translate="yes" xml:space="preserve">
          <source>List of libraries when using &lt;code&gt;curl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;curl&lt;/code&gt; 사용시 라이브러리 목록 .</target>
        </trans-unit>
        <trans-unit id="60f173df2a5792ed4de974358e0da4848736dfcf" translate="yes" xml:space="preserve">
          <source>List of libraries when using ALSA.</source>
          <target state="translated">ALSA 사용시 라이브러리 목록.</target>
        </trans-unit>
        <trans-unit id="fc4ce994d1bc8fec54c702e6f23b819acbab5f07" translate="yes" xml:space="preserve">
          <source>List of library files to read for dependencies. These are libraries that are typically created with &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt;&lt;code&gt;add_library(SHARED)&lt;/code&gt;&lt;/a&gt;, but they do not have to be created by CMake. Specifying &lt;code&gt;STATIC&lt;/code&gt; libraries, &lt;code&gt;MODULE&lt;/code&gt; libraries, or executables here will result in undefined behavior.</source>
          <target state="translated">종속성을 위해 읽을 라이브러리 파일 목록입니다. 일반적으로 &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-0-command:add_library&quot;&gt; &lt;code&gt;add_library(SHARED)&lt;/code&gt; &lt;/a&gt; 생성되는 라이브러리 이지만 CMake로 생성 할 필요는 없습니다. 여기에 &lt;code&gt;STATIC&lt;/code&gt; 라이브러리, &lt;code&gt;MODULE&lt;/code&gt; 라이브러리 또는 실행 파일을 지정 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15664c885f9dfd394c9b8bb343a372f80a038d23" translate="yes" xml:space="preserve">
          <source>List of linker search directories.</source>
          <target state="translated">링커 검색 디렉토리 목록</target>
        </trans-unit>
        <trans-unit id="724c1280740ddf3a03a3def89967f3f10a08859a" translate="yes" xml:space="preserve">
          <source>List of loadable module files to read for dependencies. These are modules that are typically created with &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-1-command:add_library&quot;&gt;&lt;code&gt;add_library(MODULE)&lt;/code&gt;&lt;/a&gt;, but they do not have to be created by CMake. They are typically used by calling &lt;code&gt;dlopen()&lt;/code&gt; at runtime rather than linked at link time with &lt;code&gt;ld -l&lt;/code&gt;. Specifying &lt;code&gt;STATIC&lt;/code&gt; libraries, &lt;code&gt;SHARED&lt;/code&gt; libraries, or executables here will result in undefined behavior.</source>
          <target state="translated">종속성을 위해 읽을로드 가능한 모듈 파일 목록입니다. 일반적으로 &lt;a href=&quot;add_library#command:add_library&quot; id=&quot;index-1-command:add_library&quot;&gt; &lt;code&gt;add_library(MODULE)&lt;/code&gt; &lt;/a&gt; 로 생성되는 모듈 이지만 CMake로 생성 할 필요는 없습니다. 일반적으로 링크 타임에 &lt;code&gt;ld -l&lt;/code&gt; 로 연결하는 대신 런타임에 &lt;code&gt;dlopen()&lt;/code&gt; 을 호출하여 사용합니다 . 여기에 &lt;code&gt;STATIC&lt;/code&gt; 라이브러리, &lt;code&gt;SHARED&lt;/code&gt; 라이브러리 또는 실행 파일을 지정 하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d99e96e7d3acd4bd1f740bc1d75b7fffdbc36158" translate="yes" xml:space="preserve">
          <source>List of macro commands available in the current directory.</source>
          <target state="translated">현재 디렉토리에서 사용 가능한 매크로 명령 목록.</target>
        </trans-unit>
        <trans-unit id="6727d2c7040e8c86fa279088a0a53d645aae2692" translate="yes" xml:space="preserve">
          <source>List of natures to add to the generated Eclipse project file.</source>
          <target state="translated">생성 된 Eclipse 프로젝트 파일에 추가 할 특성 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7bd23c607b6bfd80bb9168a873f1db33c16ceb7d" translate="yes" xml:space="preserve">
          <source>List of node JSON objects with members:</source>
          <target state="translated">멤버가있는 노드 JSON 오브젝트 목록 :</target>
        </trans-unit>
        <trans-unit id="aa6369ac2ae9eb0d2ebb6f2b84232f2595a1a60c" translate="yes" xml:space="preserve">
          <source>List of objects resulting from build of &lt;code&gt;objLib&lt;/code&gt;.</source>
          <target state="translated">빌드의 결과 개체 목록 &lt;code&gt;objLib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="156f578524088af067c3096f5686c575e51da96c" translate="yes" xml:space="preserve">
          <source>List of options to pass to the compiler.</source>
          <target state="translated">컴파일러에 전달할 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4c32c951d57fc2b9ed86770cdc48deec6b6231fc" translate="yes" xml:space="preserve">
          <source>List of options to use for the link step of shared library, module and executable targets as well as the device link step.</source>
          <target state="translated">공유 라이브러리, 모듈 및 실행 가능 대상의 링크 단계와 장치 링크 단계에 사용할 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b3fe610acdff893b7d82e7ed1c248064bc2ae447" translate="yes" xml:space="preserve">
          <source>List of options to use for the link step of shared library, module and executable targets as well as the device link step. Targets that are static libraries need to use the &lt;a href=&quot;static_library_options#prop_tgt:STATIC_LIBRARY_OPTIONS&quot; id=&quot;index-0-prop_tgt:STATIC_LIBRARY_OPTIONS&quot;&gt;&lt;code&gt;STATIC_LIBRARY_OPTIONS&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">공유 라이브러리, 모듈 및 실행 가능 대상의 링크 단계와 장치 링크 단계에 사용할 옵션 목록입니다. 정적 라이브러리 인 대상 은 &lt;a href=&quot;static_library_options#prop_tgt:STATIC_LIBRARY_OPTIONS&quot; id=&quot;index-0-prop_tgt:STATIC_LIBRARY_OPTIONS&quot;&gt; &lt;code&gt;STATIC_LIBRARY_OPTIONS&lt;/code&gt; &lt;/a&gt; 대상 속성 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="706fa0ec2243e87f5502ced66237d826b2b35f77" translate="yes" xml:space="preserve">
          <source>List of options to use for the link step of shared library, module and executable targets.</source>
          <target state="translated">공유 라이브러리, 모듈 및 실행 가능 대상의 링크 단계에 사용할 옵션 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a1bc657056b0306d31aa2f77305080e6fde0247c" translate="yes" xml:space="preserve">
          <source>List of options to use for the link step of shared library, module and executable targets. Targets that are static libraries need to use the &lt;a href=&quot;static_library_options#prop_tgt:STATIC_LIBRARY_OPTIONS&quot; id=&quot;index-0-prop_tgt:STATIC_LIBRARY_OPTIONS&quot;&gt;&lt;code&gt;STATIC_LIBRARY_OPTIONS&lt;/code&gt;&lt;/a&gt; target property.</source>
          <target state="translated">공유 라이브러리, 모듈 및 실행 가능 대상의 링크 단계에 사용할 옵션 목록입니다. 정적 라이브러리 인 대상 은 &lt;a href=&quot;static_library_options#prop_tgt:STATIC_LIBRARY_OPTIONS&quot; id=&quot;index-0-prop_tgt:STATIC_LIBRARY_OPTIONS&quot;&gt; &lt;code&gt;STATIC_LIBRARY_OPTIONS&lt;/code&gt; &lt;/a&gt; 대상 특성 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ecab3c53449208064d5c57b5c19e1bca174fcb62" translate="yes" xml:space="preserve">
          <source>List of package files created in the staging directory, with each file provided as a full absolute path. This variable is populated by CPack just before invoking the post-build scripts listed in &lt;a href=&quot;#variable:CPACK_POST_BUILD_SCRIPTS&quot; id=&quot;index-2-variable:CPACK_POST_BUILD_SCRIPTS&quot;&gt;&lt;code&gt;CPACK_POST_BUILD_SCRIPTS&lt;/code&gt;&lt;/a&gt;. It is the preferred way for the post-build scripts to know the set of package files to operate on. Projects should not try to set this variable themselves.</source>
          <target state="translated">스테이징 디렉토리에 생성 된 패키지 파일 목록이며 각 파일은 전체 절대 경로로 제공됩니다. 이 변수는 단지에 열거 된 후 빌드 스크립트 호출하기 전에 CPack에 의해 채워집니다 &lt;a href=&quot;#variable:CPACK_POST_BUILD_SCRIPTS&quot; id=&quot;index-2-variable:CPACK_POST_BUILD_SCRIPTS&quot;&gt; &lt;code&gt;CPACK_POST_BUILD_SCRIPTS&lt;/code&gt; 을&lt;/a&gt; . 빌드 후 스크립트가 작동 할 패키지 파일 세트를 파악하는 것이 선호되는 방법입니다. 프로젝트는이 변수를 직접 설정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="09189c7c5e83232bbc96061bc18973a20d85ac92" translate="yes" xml:space="preserve">
          <source>List of packages which were found during the CMake run.</source>
          <target state="translated">CMake 실행 중에 발견 된 패키지 목록.</target>
        </trans-unit>
        <trans-unit id="15e4378c3f55ae7ad3e541e106cdea93ea0d8e2c" translate="yes" xml:space="preserve">
          <source>List of packages which were found during the CMake run. Whether a package has been found is determined using the &amp;lt;NAME&amp;gt;_FOUND variables.</source>
          <target state="translated">CMake 실행 중에 발견 된 패키지 목록. 패키지가 발견되었는지 여부는 &amp;lt;NAME&amp;gt; _FOUND 변수를 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a62ab053dbde5d0483b69d6422032c9dfc01047" translate="yes" xml:space="preserve">
          <source>List of packages which were not found during the CMake run.</source>
          <target state="translated">CMake 실행 중에 찾을 수없는 패키지 목록.</target>
        </trans-unit>
        <trans-unit id="7ad56d03ca659d64c948892f4638e6f63ea023cd" translate="yes" xml:space="preserve">
          <source>List of packages which were not found during the CMake run. Whether a package has been found is determined using the &amp;lt;NAME&amp;gt;_FOUND variables.</source>
          <target state="translated">CMake 실행 중에 찾을 수없는 패키지 목록. 패키지가 발견되었는지 여부는 &amp;lt;NAME&amp;gt; _FOUND 변수를 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="35a5949965d44961947fb77f9fab11454d8295bc" translate="yes" xml:space="preserve">
          <source>List of paths and/or URL(s) of the external project&amp;rsquo;s source. When more than one URL is given, they are tried in turn until one succeeds. A URL may be an ordinary path in the local file system (in which case it must be the only URL provided) or any downloadable URL supported by the &lt;a href=&quot;../command/file#command:file&quot; id=&quot;index-0-command:file&quot;&gt;&lt;code&gt;file(DOWNLOAD)&lt;/code&gt;&lt;/a&gt; command. A local filesystem path may refer to either an existing directory or to an archive file, whereas a URL is expected to point to a file which can be treated as an archive. When an archive is used, it will be unpacked automatically unless the &lt;code&gt;DOWNLOAD_NO_EXTRACT&lt;/code&gt; option is set to prevent it. The archive type is determined by inspecting the actual content rather than using logic based on the file extension.</source>
          <target state="translated">외부 프로젝트 소스의 경로 및 / 또는 URL 목록. 둘 이상의 URL이 제공되면 성공할 때까지 차례로 시도합니다. URL은 로컬 파일 시스템의 일반적인 경로 (이 경우 제공된 URL이어야 함) 또는 &lt;a href=&quot;../command/file#command:file&quot; id=&quot;index-0-command:file&quot;&gt; &lt;code&gt;file(DOWNLOAD)&lt;/code&gt; &lt;/a&gt; 명령이 지원하는 다운로드 가능한 URL 일 수 있습니다. 로컬 파일 시스템 경로는 기존 디렉토리 또는 아카이브 파일을 참조 할 수 있지만 URL은 아카이브로 취급 될 수있는 파일을 가리킬 것으로 예상됩니다. 아카이브를 사용하는 경우 &lt;code&gt;DOWNLOAD_NO_EXTRACT&lt;/code&gt; 옵션을 설정 하지 않으면 아카이브가 자동으로 압축 해제됩니다 . 아카이브 유형은 파일 확장자 기반의 논리를 사용하지 않고 실제 컨텐츠를 검사하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc09ccc7063616ef48146c6d7f1f700f1503c46e" translate="yes" xml:space="preserve">
          <source>List of post-exclude regexes through which to filter the names of resolved dependencies.</source>
          <target state="translated">해결 된 종속성의 이름을 필터링하는 데 사용할 제외 후 정규식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5cbee37b2adb438656cd912858e8afc1628e1405" translate="yes" xml:space="preserve">
          <source>List of post-include regexes through which to filter the names of resolved dependencies.</source>
          <target state="translated">해결 된 종속성의 이름을 필터링하는 데 사용할 포함 후 정규식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="303c8171c2eab70cdb2828b9883eac473a7e3bba" translate="yes" xml:space="preserve">
          <source>List of pre-exclude regexes through which to filter the names of not-yet-resolved dependencies.</source>
          <target state="translated">아직 해결되지 않은 종속성의 이름을 필터링하는 데 사용할 사전 제외 정규식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="03d068258fa9524873e35a7becd4638540439d85" translate="yes" xml:space="preserve">
          <source>List of pre-include regexes through which to filter the names of not-yet-resolved dependencies.</source>
          <target state="translated">아직 해결되지 않은 종속성의 이름을 필터링하는 데 사용할 사전 포함 정규식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="32fbba8eea6a9d64aebf4adf04c146b6ab2114c5" translate="yes" xml:space="preserve">
          <source>List of preprocessor include file search directories.</source>
          <target state="translated">전 처리기 목록에는 파일 검색 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2c2e49f97c7b9b103cc78239f4827a08abc923" translate="yes" xml:space="preserve">
          <source>List of public compile definitions requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공개 컴파일 정의 요구 사항 목록</target>
        </trans-unit>
        <trans-unit id="abbf5a006c48a969d63cf22e42edda848b8919d5" translate="yes" xml:space="preserve">
          <source>List of public compile features requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공개 컴파일 기능 요구 사항 목록.</target>
        </trans-unit>
        <trans-unit id="f9ddffcd4f5ac6147760ef492101c2f5f2020a3c" translate="yes" xml:space="preserve">
          <source>List of public compile options requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공개 컴파일 옵션 요구 사항 목록.</target>
        </trans-unit>
        <trans-unit id="4632e5092b336901b5cb0b8270efac3d64595e65" translate="yes" xml:space="preserve">
          <source>List of public include directories requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공용 포함 디렉토리 요구 사항 목록</target>
        </trans-unit>
        <trans-unit id="4542f5265cc9dd34c29cf2d58c17345454ab90ab" translate="yes" xml:space="preserve">
          <source>List of public link directories requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공용 링크 디렉토리 요구 사항 목록</target>
        </trans-unit>
        <trans-unit id="2c5e8448bbb546cff1e35a7a3c76ad521b1be376" translate="yes" xml:space="preserve">
          <source>List of public link options requirements for a library.</source>
          <target state="translated">라이브러리에 대한 공개 링크 옵션 요구 사항 목록.</target>
        </trans-unit>
        <trans-unit id="239ec1e7a37b77cb65f214857eeb55a7ff756bd4" translate="yes" xml:space="preserve">
          <source>List of public system include directories for a library.</source>
          <target state="translated">공용 시스템 목록에는 라이브러리의 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d482272d0fe7d73f0536bb20a937a6045b867b81" translate="yes" xml:space="preserve">
          <source>List of requested components</source>
          <target state="translated">요청 된 구성 요소 목록</target>
        </trans-unit>
        <trans-unit id="b55411f7b6d30fc8bc2c85028f036978342ad347" translate="yes" xml:space="preserve">
          <source>List of sources for the library. Files with extension &lt;code&gt;.i&lt;/code&gt; will be identified as sources for the &lt;code&gt;SWIG&lt;/code&gt; tool. Other files will be handled in the standard way. This behavior can be overridden by specifying the variable &lt;code&gt;SWIG_SOURCE_FILE_EXTENSIONS&lt;/code&gt;.</source>
          <target state="translated">라이브러리의 소스 목록입니다. 확장자가 &lt;code&gt;.i&lt;/code&gt; 인 파일 은 &lt;code&gt;SWIG&lt;/code&gt; 도구의 소스로 식별됩니다 . 다른 파일은 표준 방식으로 처리됩니다. 이 동작은 &lt;code&gt;SWIG_SOURCE_FILE_EXTENSIONS&lt;/code&gt; 변수를 지정하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed191a1f700c2874db3c075e170cc1b914b0c849" translate="yes" xml:space="preserve">
          <source>List of sources for the library. Files with extension &lt;code&gt;.i&lt;/code&gt; will be identified as sources for the &lt;code&gt;SWIG&lt;/code&gt; tool. Other files will be handled in the standard way. This behavior can be overriden by specifying the variable &lt;code&gt;SWIG_SOURCE_FILE_EXTENSIONS&lt;/code&gt;.</source>
          <target state="translated">라이브러리의 소스 목록 확장자가 &lt;code&gt;.i&lt;/code&gt; 인 파일 은 &lt;code&gt;SWIG&lt;/code&gt; 도구의 소스로 식별됩니다 . 다른 파일은 표준 방식으로 처리됩니다. 변수 &lt;code&gt;SWIG_SOURCE_FILE_EXTENSIONS&lt;/code&gt; 를 지정하면이 동작을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21d7b65443d58bf8d68229134c5a3274b05de640" translate="yes" xml:space="preserve">
          <source>List of sources specified for a target.</source>
          <target state="translated">대상에 지정된 소스 목록.</target>
        </trans-unit>
        <trans-unit id="d77c6cea16889183a1a66824a7d987aa2fa1b74b" translate="yes" xml:space="preserve">
          <source>List of tests.</source>
          <target state="translated">테스트 목록.</target>
        </trans-unit>
        <trans-unit id="fa84e733e68012cfdffe915d8657ca30c62bb803" translate="yes" xml:space="preserve">
          <source>List of the FLTK libraries found</source>
          <target state="translated">찾은 FLTK 라이브러리 목록</target>
        </trans-unit>
        <trans-unit id="490084205605bc1d5317caf1a072c2c992174e8d" translate="yes" xml:space="preserve">
          <source>List of variables defined in the current directory.</source>
          <target state="translated">현재 디렉토리에 정의 된 변수 목록.</target>
        </trans-unit>
        <trans-unit id="7c3d3b8acf32d921346c9fa15ccc3e0af5f493f8" translate="yes" xml:space="preserve">
          <source>List of variables that the &lt;a href=&quot;../command/try_compile#command:try_compile&quot; id=&quot;index-0-command:try_compile&quot;&gt;&lt;code&gt;try_compile()&lt;/code&gt;&lt;/a&gt; command source file signature must propagate into the test project in order to target the same platform as the host project.</source>
          <target state="translated">호스트 프로젝트와 동일한 플랫폼을 대상으로하기 위해 &lt;a href=&quot;../command/try_compile#command:try_compile&quot; id=&quot;index-0-command:try_compile&quot;&gt; &lt;code&gt;try_compile()&lt;/code&gt; &lt;/a&gt; 명령 소스 파일 서명이 테스트 프로젝트에 전파 해야하는 변수 목록 .</target>
        </trans-unit>
        <trans-unit id="2136f9decb402dc033169190742a9590a2e8171a" translate="yes" xml:space="preserve">
          <source>List operations.</source>
          <target state="translated">작업을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="52249135d6a5917c8cb8e8f1762ae75a001ee804" translate="yes" xml:space="preserve">
          <source>List policies with help available and exit.</source>
          <target state="translated">사용 가능한 도움말과 함께 정책을 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e087b78036348487783e10639c165d85d7369504" translate="yes" xml:space="preserve">
          <source>List properties with help available and exit.</source>
          <target state="translated">사용 가능한 도움말로 특성을 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="094ec0170f9291a9538b5cdbd09479ec209be775" translate="yes" xml:space="preserve">
          <source>List public interface libraries for a library.</source>
          <target state="translated">라이브러리의 공용 인터페이스 라이브러리를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="e55a1825f7ab0756a6c9cfb6107ada508a93ea86" translate="yes" xml:space="preserve">
          <source>List public interface libraries for a shared library or executable.</source>
          <target state="translated">공유 라이브러리 또는 실행 파일에 대한 공용 인터페이스 라이브러리를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="51a831556002c054eaec09a9d7cbb5115c4ccb6f" translate="yes" xml:space="preserve">
          <source>List symbols to mangle automatically with C preprocessor definitions:</source>
          <target state="translated">C 전 처리기 정의를 사용하여 자동으로 맹 글링 할 기호를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="02df771d534f50e0ddeeec6134b9551690844c5e" translate="yes" xml:space="preserve">
          <source>List variables with help available and exit.</source>
          <target state="translated">사용 가능한 도움말로 변수를 나열하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="765f52025a84eecdfb7232eeeceb364593df2d25" translate="yes" xml:space="preserve">
          <source>List where the first element is the test command and the remaining elements are the command arguments.</source>
          <target state="translated">첫 번째 요소가 테스트 명령이고 나머지 요소가 명령 인수 인 위치를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="1b00d733e1dd02d87f6710920168803a1c27d027" translate="yes" xml:space="preserve">
          <source>Lists are meant for simple use cases such as a list of source files and should not be used for complex data processing tasks. Most commands that construct lists do not escape &lt;code&gt;;&lt;/code&gt; characters in list elements, thus flattening nested lists:</source>
          <target state="translated">목록은 소스 파일 목록과 같은 간단한 사용 사례를위한 것이며 복잡한 데이터 처리 작업에는 사용해서는 안됩니다. 리스트를 구성하는 대부분의 명령은 이스케이프되지 않습니다 &lt;code&gt;;&lt;/code&gt; 목록 요소의 문자로 중첩 된 목록을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="0b3b55f5ca9fdf6e28c60add4fea4cd1f9c8fa36" translate="yes" xml:space="preserve">
          <source>Lists each of the executables and associated text label to be used to create Start Menu shortcuts. For example, setting this to the list &lt;code&gt;ccmake;CMake&lt;/code&gt; will create a shortcut named &amp;ldquo;CMake&amp;rdquo; that will execute the installed executable &lt;code&gt;ccmake&lt;/code&gt;. Not all CPack generators use it (at least NSIS, WIX and OSXX11 do).</source>
          <target state="translated">시작 메뉴 바로 가기를 만드는 데 사용되는 각 실행 파일 및 관련 텍스트 레이블을 나열합니다. 예를 들어, 이것을 &lt;code&gt;ccmake;CMake&lt;/code&gt; 목록으로 설정 하면 설치된 실행 가능한 &lt;code&gt;ccmake&lt;/code&gt; 를 실행하는&amp;ldquo;CMake&amp;rdquo;라는 바로 가기가 생성됩니다 . 모든 CPack 생성기가이를 사용하는 것은 아닙니다 (적어도 NSIS, WIX 및 OSXX11에서 사용).</target>
        </trans-unit>
        <trans-unit id="ef86b4fce27c8051e270d6b02a9d443bc5000bf8" translate="yes" xml:space="preserve">
          <source>Lists in &lt;code&gt;COMMAND&lt;/code&gt; arguments will be expanded, including those created with &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-0-manual:cmake-generator-expressions(7)&quot;&gt;&lt;code&gt;generator expressions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-0-manual:cmake-generator-expressions(7)&quot;&gt; &lt;code&gt;generator expressions&lt;/code&gt; &lt;/a&gt; 생성 된 목록을 포함하여 &lt;code&gt;COMMAND&lt;/code&gt; 인수의 목록 이 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1218597b91afbb4f1920f93a2138605327f1e9a" translate="yes" xml:space="preserve">
          <source>Lists in &lt;code&gt;COMMAND&lt;/code&gt; arguments will be expanded, including those created with &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-1-manual:cmake-generator-expressions(7)&quot;&gt;&lt;code&gt;generator expressions&lt;/code&gt;&lt;/a&gt;, allowing &lt;code&gt;COMMAND&lt;/code&gt; arguments such as &lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; to be properly expanded.</source>
          <target state="translated">&lt;code&gt;COMMAND&lt;/code&gt; 인수의 목록은 &lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; 와 같은 &lt;code&gt;COMMAND&lt;/code&gt; 인수를 허용 하여 &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-1-manual:cmake-generator-expressions(7)&quot;&gt; &lt;code&gt;generator expressions&lt;/code&gt; &lt;/a&gt; 작성된 목록을 포함하여 확장 됩니다. 제대로 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="3079d38755c4402f452a2ecb794eee20520f48f6" translate="yes" xml:space="preserve">
          <source>Lists in &lt;code&gt;COMMAND&lt;/code&gt; arguments will be expanded, including those created with &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-2-manual:cmake-generator-expressions(7)&quot;&gt;&lt;code&gt;generator expressions&lt;/code&gt;&lt;/a&gt;, allowing &lt;code&gt;COMMAND&lt;/code&gt; arguments such as &lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; to be properly expanded.</source>
          <target state="translated">&lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; 와 같은 &lt;code&gt;COMMAND&lt;/code&gt; 인수를 허용 하는 &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-2-manual:cmake-generator-expressions(7)&quot;&gt; &lt;code&gt;generator expressions&lt;/code&gt; &lt;/a&gt; 포함하여 &lt;code&gt;COMMAND&lt;/code&gt; 인수의 목록 이 확장 됩니다. 제대로 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="dbba980bfa0b1fa9b8ed0f9dec8db7858dbd7c4a" translate="yes" xml:space="preserve">
          <source>Lists in &lt;code&gt;COMMAND&lt;/code&gt; arguments will be expanded, including those created with &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-3-manual:cmake-generator-expressions(7)&quot;&gt;&lt;code&gt;generator expressions&lt;/code&gt;&lt;/a&gt;, allowing &lt;code&gt;COMMAND&lt;/code&gt; arguments such as &lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; to be properly expanded.</source>
          <target state="translated">&lt;code&gt;COMMAND&lt;/code&gt; 인수의 목록은 &lt;code&gt;${CC} &quot;-I$&amp;lt;JOIN:$&amp;lt;TARGET_PROPERTY:foo,INCLUDE_DIRECTORIES&amp;gt;,;-I&amp;gt;&quot; foo.cc&lt;/code&gt; 와 같은 &lt;code&gt;COMMAND&lt;/code&gt; 인수를 허용 하여 &lt;a href=&quot;../manual/cmake-generator-expressions.7#manual:cmake-generator-expressions(7)&quot; id=&quot;index-3-manual:cmake-generator-expressions(7)&quot;&gt; &lt;code&gt;generator expressions&lt;/code&gt; &lt;/a&gt; 작성된 목록을 포함하여 확장 됩니다. 제대로 확장되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
